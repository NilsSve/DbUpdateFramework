Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLConnections.src
Memory Available: 2147483646
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dfallent.pkd)
79228>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardCommandBarSystem.pkg)
79228>>>// these are all the packages used in a standard MDI menubar/toolbar system
79228>>>
79228>>>Use cCJCommandBarSystem.pkg
79228>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardMenuItemClasses.pkg)
79228>>>>>Use Dfpanel.pkg
79228>>>>>Use cCJCommandBarSystem.pkg
79228>>>>>Use LanguageText.pkg
79228>>>>>
79228>>>>>
79228>>>>>Class cCJUndoMenuItem is a cCJMenuItem
79229>>>>>    
79229>>>>>    Procedure Construct_Object
79231>>>>>        Forward Send Construct_Object
79233>>>>>        Set psCaption   to C_$CaptionUndo
79234>>>>>        Set psToolTip to C_$ToolTipUndo
79235>>>>>        Set psDescription to C_$DescUndo
79236>>>>>        Set psImage to "ActionUndo.ico"
79237>>>>>        Set pbActiveUpdate to True
79238>>>>>        Set psCategory to C_$CategoryEdit
79239>>>>>        Set psShortcut to C_$Key_Ctrl_Z
79240>>>>>    End_Procedure
79241>>>>>
79241>>>>>    Procedure OnExecute Variant vCommandBarControl
79243>>>>>        Send Undo of (focus(Self))
79244>>>>>    End_Procedure
79245>>>>>    
79245>>>>>    Function IsEnabled Returns Boolean
79247>>>>>        Boolean bEnabled
79247>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
79248>>>>>        Function_Return bEnabled
79249>>>>>    End_Function
79250>>>>>         
79250>>>>>End_Class
79251>>>>>
79251>>>>>
79251>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
79252>>>>>    
79252>>>>>    Procedure Construct_Object
79254>>>>>        Forward Send Construct_Object
79256>>>>>        Set psCaption   to C_$CaptionDelete
79257>>>>>        Set psToolTip to C_$ToolTipDelete
79258>>>>>        Set psDescription to C_$DescDelete
79259>>>>>        Set psImage to "actionDelete.ico"
79260>>>>>        Set psShortcut to C_$Key_Delete
79261>>>>>        Set pbActiveUpdate to True
79262>>>>>        Set psCategory to C_$CategoryEdit
79263>>>>>    End_Procedure
79264>>>>>
79264>>>>>
79264>>>>>    Procedure OnExecute Variant vCommandBarControl
79266>>>>>        Send Delete of (focus(Self))
79267>>>>>    End_Procedure
79268>>>>>    
79268>>>>>    Function IsEnabled Returns Boolean
79270>>>>>        Boolean bEnabled
79270>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
79271>>>>>        Function_Return bEnabled
79272>>>>>    End_Function
79273>>>>>         
79273>>>>>End_Class
79274>>>>>
79274>>>>>
79274>>>>>Class cCJCutMenuItem is a cCJMenuItem
79275>>>>>    
79275>>>>>    Procedure Construct_Object
79277>>>>>        Forward Send Construct_Object
79279>>>>>        Set psCaption   to C_$CaptionCut
79280>>>>>        Set psToolTip to C_$TooltipCut
79281>>>>>        Set psDescription to C_$DescCut
79282>>>>>        Set psImage to "actionCut.ico"
79283>>>>>        Set psShortcut to C_$Key_Ctrl_X
79284>>>>>        Set pbActiveUpdate to True
79285>>>>>        Set psCategory to C_$CategoryEdit
79286>>>>>    End_Procedure
79287>>>>>
79287>>>>>
79287>>>>>    Procedure OnExecute Variant vCommandBarControl
79289>>>>>        Send Cut of (focus(Self))
79290>>>>>    End_Procedure
79291>>>>>    
79291>>>>>    Function IsEnabled Returns Boolean
79293>>>>>        Boolean bEnabled
79293>>>>>        Get CanCut of (Focus(Self)) to bEnabled
79294>>>>>        Function_Return bEnabled
79295>>>>>    End_Function
79296>>>>>         
79296>>>>>End_Class
79297>>>>>
79297>>>>>
79297>>>>>Class cCJCopyMenuItem is a cCJMenuItem
79298>>>>>    
79298>>>>>    Procedure Construct_Object
79300>>>>>        Forward Send Construct_Object
79302>>>>>        Set psCaption   to C_$CaptionCopy
79303>>>>>        Set psToolTip to C_$ToolTipCopy
79304>>>>>        Set psDescription to C_$DescCopy
79305>>>>>        Set psImage to "actionCopy.ico"
79306>>>>>        Set psShortcut to C_$Key_Ctrl_C
79307>>>>>        Set pbActiveUpdate to True
79308>>>>>        Set psCategory to C_$CategoryEdit
79309>>>>>    End_Procedure
79310>>>>>
79310>>>>>
79310>>>>>    Procedure OnExecute Variant vCommandBarControl
79312>>>>>        Send Copy of (focus(Self))
79313>>>>>    End_Procedure
79314>>>>>    
79314>>>>>    Function IsEnabled Returns Boolean
79316>>>>>        Boolean bEnabled
79316>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
79317>>>>>        Function_Return bEnabled
79318>>>>>    End_Function
79319>>>>>         
79319>>>>>End_Class
79320>>>>>
79320>>>>>
79320>>>>>Class cCJPasteMenuItem is a cCJMenuItem
79321>>>>>    
79321>>>>>    Procedure Construct_Object
79323>>>>>        Forward Send Construct_Object
79325>>>>>        Set psCaption   to C_$CaptionPaste
79326>>>>>        Set psToolTip to C_$ToolTipPaste
79327>>>>>        Set psDescription to C_$DescPaste
79328>>>>>        Set psImage to "actionPaste.ico"
79329>>>>>        Set pbActiveUpdate to True
79330>>>>>        Set psShortcut to C_$Key_Ctrl_V
79331>>>>>        Set psCategory to C_$CategoryEdit
79332>>>>>    End_Procedure
79333>>>>>
79333>>>>>
79333>>>>>    Procedure OnExecute Variant vCommandBarControl
79335>>>>>        Send Paste of (focus(Self))
79336>>>>>    End_Procedure
79337>>>>>    
79337>>>>>    Function IsEnabled Returns Boolean
79339>>>>>        Boolean bEnabled
79339>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
79340>>>>>        Function_Return bEnabled
79341>>>>>    End_Function
79342>>>>>         
79342>>>>>End_Class
79343>>>>>
79343>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
79344>>>>>    
79344>>>>>    Procedure Construct_Object
79346>>>>>        Forward Send Construct_Object
79348>>>>>        Set psCaption   to C_$CaptionSelectAll
79349>>>>>        Set psToolTip to C_$ToolTipSelectAll
79350>>>>>        Set psDescription to C_$DescSelectAll
79351>>>>>        Set pbActiveUpdate to True
79352>>>>>        Set psShortcut to C_$Key_Ctrl_A
79353>>>>>        Set psCategory to C_$CategoryEdit
79354>>>>>    End_Procedure
79355>>>>>
79355>>>>>
79355>>>>>    Procedure OnExecute Variant vCommandBarControl
79357>>>>>        Send Select_All of (focus(Self))
79358>>>>>    End_Procedure
79359>>>>>    
79359>>>>>    Function IsEnabled Returns Boolean
79361>>>>>        Boolean bEnabled
79361>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
79362>>>>>        Function_Return bEnabled
79363>>>>>    End_Function
79364>>>>>         
79364>>>>>End_Class
79365>>>>>
79365>>>>> 
79365>>>>>Class cCJExitMenuItem is a cCJMenuItem
79366>>>>>
79366>>>>>    Procedure Construct_Object
79368>>>>>        Forward Send Construct_Object
79370>>>>>        Set psCaption to C_$CaptionExit
79371>>>>>        Set psToolTip to C_$ToolTipExit
79372>>>>>        Set psDescription to C_$ToolTipExit
79373>>>>>        Set psShortcut to C_$Key_Alt_F4
79374>>>>>        Set psCategory to C_$CategoryFile
79375>>>>>    End_Procedure
79376>>>>>
79376>>>>>    Procedure OnExecute Variant vCommandBarControl
79378>>>>>        Send Exit_Application of Desktop
79379>>>>>    End_Procedure
79380>>>>>
79380>>>>>End_Class           
79381>>>>>
79381>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
79382>>>>>
79382>>>>>    Procedure Construct_Object
79384>>>>>        Forward Send Construct_Object
79386>>>>>        Set psCaption to C_$CaptionHelp
79387>>>>>        Set psDescription to C_$ToolTipHelp
79388>>>>>        Set psToolTip to C_$DescHelp
79389>>>>>        Set psImage to "ActionHelp.ico"
79390>>>>>        Set psShortcut to "F1"
79391>>>>>        Set psCategory to C_$CategoryHelp
79392>>>>>    End_Procedure
79393>>>>>    
79393>>>>>    Procedure OnExecute Variant vCommandBarControl
79395>>>>>        Send Help of (Focus(Self))
79396>>>>>    End_Procedure
79397>>>>>
79397>>>>>End_Class
79398>>>>>
79398>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
79399>>>>>
79399>>>>>    Procedure Construct_Object
79401>>>>>        Forward Send Construct_Object
79403>>>>>        Set psCaption to C_$CaptionAddStatusbar
79404>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
79405>>>>>        Set psDescription to  C_$DescAddStatusbar
79406>>>>>        Set psCategory to C_$CategoryWindow
79407>>>>>    End_Procedure
79408>>>>>
79408>>>>>    Procedure OnExecute Variant vCommandBarControl
79410>>>>>        Handle hoCommandBars hoClientArea
79410>>>>>        Get CommandBarSystemObject to hoCommandBars
79411>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79412>>>>>        If hoClientArea Begin
79414>>>>>            // the clientarea's parent panel has message
79414>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
79415>>>>>        End
79415>>>>>>
79415>>>>>    End_Procedure
79416>>>>>
79416>>>>>     Function IsChecked Returns Boolean
79418>>>>>        Boolean bOn
79418>>>>>        Handle hoCommandBars hoClientArea
79418>>>>>        Get CommandBarSystemObject to hoCommandBars
79419>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79420>>>>>        If hoClientArea Begin
79422>>>>>            // the clientarea's parent panel has message
79422>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
79423>>>>>        End
79423>>>>>>
79423>>>>>        Function_Return bOn
79424>>>>>     End_Function
79425>>>>>End_Class
79426>>>>>
79426>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
79427>>>>>
79427>>>>>    Procedure Construct_Object
79429>>>>>        Forward Send Construct_Object
79431>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
79432>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
79433>>>>>        Set psDescription to C_$DescAutoArrangeIcons
79434>>>>>        Set psCategory to C_$CategoryWindow
79435>>>>>    End_Procedure
79436>>>>>
79436>>>>>    Procedure OnExecute Variant vCommandBarControl
79438>>>>>        Handle hoCommandBars hoClientArea
79438>>>>>        Get CommandBarSystemObject to hoCommandBars
79439>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79440>>>>>        If hoClientArea Begin
79442>>>>>            // the clientarea's parent panel has message
79442>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
79443>>>>>        End
79443>>>>>>
79443>>>>>    End_Procedure
79444>>>>>    
79444>>>>>     Function IsChecked Returns Boolean
79446>>>>>        Boolean bOn
79446>>>>>        Handle hoCommandBars hoClientArea
79446>>>>>        Get CommandBarSystemObject to hoCommandBars
79447>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79448>>>>>        If hoClientArea Begin
79450>>>>>            // the clientarea's parent panel has message
79450>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
79451>>>>>        End
79451>>>>>>
79451>>>>>        Function_Return bOn
79452>>>>>     End_Function
79453>>>>>End_Class
79454>>>>>
79454>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
79455>>>>>
79455>>>>>    Procedure Construct_Object
79457>>>>>        Forward Send Construct_Object
79459>>>>>        Set psCaption to C_$CaptionRestoreMenus
79460>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
79461>>>>>        Set psDescription to C_$DescRestoreMenus
79462>>>>>        Set psCategory to C_$CategoryWindow
79463>>>>>    End_Procedure
79464>>>>>
79464>>>>>    Procedure OnExecute Variant vCommandBarControl
79466>>>>>        Handle hoCommandBars
79466>>>>>        Get CommandBarSystemObject to hoCommandBars
79467>>>>>        Send RestoreLayout of hoCommandBars
79468>>>>>    End_Procedure
79469>>>>>    
79469>>>>>End_Class
79470>>>>>
79470>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
79471>>>>>
79471>>>>>    Procedure Construct_Object
79473>>>>>        Forward Send Construct_Object
79475>>>>>        Set psCaption to C_$CaptionCascade
79476>>>>>        Set psToolTip to C_$ToolTipCascade
79477>>>>>        Set psDescription to  C_$DescCascade
79478>>>>>        Set psImage to "ActionCascade.ico"
79479>>>>>        Set psCategory to C_$CategoryWindow
79480>>>>>    End_Procedure
79481>>>>>    
79481>>>>>    Procedure OnExecute Variant vCommandBarControl
79483>>>>>        Handle hoCommandBars hoClientArea
79483>>>>>        Get CommandBarSystemObject to hoCommandBars
79484>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79485>>>>>        If hoClientArea Begin
79487>>>>>            Send Cascade_Windows of hoClientArea
79488>>>>>        End
79488>>>>>>
79488>>>>>    End_Procedure
79489>>>>>End_Class
79490>>>>>
79490>>>>>Class cCJTileHorizontally is a cCJMenuItem
79491>>>>>
79491>>>>>    Procedure Construct_Object
79493>>>>>        Forward Send Construct_Object
79495>>>>>        Set psCaption to C_$CaptionTileHorizontally 
79496>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
79497>>>>>        Set psDescription to  C_$DescTileHorizontally
79498>>>>>        Set psImage to "ActionTileHorizontally.ico"
79499>>>>>        Set psCategory to C_$CategoryWindow
79500>>>>>    End_Procedure
79501>>>>>
79501>>>>>    Procedure OnExecute Variant vCommandBarControl
79503>>>>>        Handle hoCommandBars hoClientArea
79503>>>>>        Get CommandBarSystemObject to hoCommandBars
79504>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79505>>>>>        If hoClientArea Begin
79507>>>>>            Send Tile_Windows_Horizontal of hoClientArea
79508>>>>>        End
79508>>>>>>
79508>>>>>    End_Procedure
79509>>>>>End_Class
79510>>>>>
79510>>>>>Class cCJTileVertically is a cCJMenuItem
79511>>>>>
79511>>>>>    Procedure Construct_Object
79513>>>>>        Forward Send Construct_Object
79515>>>>>        Set psCaption to C_$CaptionTileVertically  
79516>>>>>        Set psToolTip to C_$ToolTipTileVertically
79517>>>>>        Set psDescription to  C_$DescTileVertically
79518>>>>>        Set psImage to "ActionTileVertically.ico"
79519>>>>>        Set psCategory to C_$CategoryWindow
79520>>>>>    End_Procedure
79521>>>>>
79521>>>>>    Procedure OnExecute Variant vCommandBarControl
79523>>>>>        Handle hoCommandBars hoClientArea
79523>>>>>        Get CommandBarSystemObject to hoCommandBars
79524>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79525>>>>>        If hoClientArea Begin
79527>>>>>            Send Tile_Windows_Vertical of hoClientArea
79528>>>>>        End
79528>>>>>>
79528>>>>>    End_Procedure
79529>>>>>End_Class
79530>>>>>
79530>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
79531>>>>>
79531>>>>>    Procedure Construct_Object
79533>>>>>        Forward Send Construct_Object
79535>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
79536>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
79537>>>>>        Set psDescription to  C_$DescMinimizeWindows
79538>>>>>        Set psCategory to C_$CategoryWindow
79539>>>>>    End_Procedure
79540>>>>>
79540>>>>>    Procedure OnExecute Variant vCommandBarControl
79542>>>>>        Handle hoCommandBars hoClientArea
79542>>>>>        Get CommandBarSystemObject to hoCommandBars
79543>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79544>>>>>        If hoClientArea Begin
79546>>>>>            // the clientarea's parent panel has message
79546>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
79547>>>>>        End
79547>>>>>>
79547>>>>>    End_Procedure
79548>>>>>End_Class
79549>>>>>
79549>>>>>
79549>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
79550>>>>>
79550>>>>>    Procedure Construct_Object
79552>>>>>        Forward Send Construct_Object
79554>>>>>        Set psCaption to C_$CaptionRestoreWindows
79555>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
79556>>>>>        Set psDescription to  C_$DescRestoreWindows
79557>>>>>        Set psCategory to C_$CategoryWindow
79558>>>>>    End_Procedure
79559>>>>>
79559>>>>>    Procedure OnExecute Variant vCommandBarControl
79561>>>>>        Handle hoCommandBars hoClientArea
79561>>>>>        Get CommandBarSystemObject to hoCommandBars
79562>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79563>>>>>        If hoClientArea Begin
79565>>>>>            // the clientarea's parent panel has message
79565>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
79566>>>>>        End
79566>>>>>>
79566>>>>>    End_Procedure
79567>>>>>End_Class
79568>>>>>
79568>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
79569>>>>>
79569>>>>>    Procedure Construct_Object
79571>>>>>        Forward Send Construct_Object
79573>>>>>        Set psCaption to C_$CaptionArrangeIcons  
79574>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
79575>>>>>        Set psDescription to  C_$DescArrangeIcons
79576>>>>>        Set psCategory to C_$CategoryWindow
79577>>>>>    End_Procedure
79578>>>>>
79578>>>>>    Procedure OnExecute Variant vCommandBarControl
79580>>>>>        Handle hoCommandBars hoClientArea
79580>>>>>        Get CommandBarSystemObject to hoCommandBars
79581>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79582>>>>>        If hoClientArea Begin
79584>>>>>            Send Arrange_Icons of hoClientArea
79585>>>>>        End
79585>>>>>>
79585>>>>>    End_Procedure
79586>>>>>
79586>>>>>End_Class
79587>>>>>    
79587>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJAboutMenuItem.pkg)
79587>>>>>Use cCJCommandBarSystem.pkg
79587>>>>>Use LanguageText.pkg
79587>>>>>
79587>>>>>// It is expected that if you use this class that you provide an about object that is
79587>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
79587>>>>>// because you may wish to create your own custom about package.
79587>>>>>
79587>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
79588>>>>>
79588>>>>>    Procedure Construct_Object
79590>>>>>        Forward Send Construct_Object
79592>>>>>        Set psCaption to C_$CaptionAbout
79593>>>>>        Set psDescription to C_$ToolTipAbout
79594>>>>>        Set psToolTip to C_$DescAbout
79595>>>>>        Set psImage to "ActionAbout.ico"
79596>>>>>        Set psCategory to C_$CategoryHelp
79597>>>>>    End_Procedure
79598>>>>>    
79598>>>>>    Procedure OnExecute Variant vCommandBarControl
79600>>>>>        Handle hoCommandBars hoClientArea
79600>>>>>        Get CommandBarSystemObject to hoCommandBars
79601>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79602>>>>>        If hoClientArea Begin
79604>>>>>            Send Activate_About of hoClientArea
79605>>>>>        End
79605>>>>>>
79605>>>>>    End_Procedure
79606>>>>>
79606>>>>>End_Class
79607>>>>>
79607>>>>>
79607>>>Use cCJDeoMenuItemClasses.pkg
79607>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJMDIWindowsMenuItem.pkg)
79607>>>>>Use cCJCommandBarSystem.pkg
79607>>>>>
79607>>>>>Register_Function Client_ID Returns Integer
79607>>>>>
79607>>>>>// only used by cCJMDIWIndowsMenuItem
79607>>>>>Class cCJMDIWindowItem is a cCJMenuItem
79608>>>>>
79608>>>>>    Procedure Construct_Object
79610>>>>>        Forward Send Construct_Object
79612>>>>>        Property Handle phWindow 0 // object id of view
79613>>>>>        Set pbControlFlagNoMovable to True
79614>>>>>        Set pbActiveUpdate to True
79615>>>>>    End_Procedure
79616>>>>>    
79616>>>>>    Procedure OnExecute Variant vCommandBarControl
79618>>>>>        Handle hWindow
79618>>>>>        Get phWindow to hWindow
79619>>>>>        Send Activate_View of hWindow
79620>>>>>    End_Procedure
79621>>>>>    
79621>>>>>End_Class                
79622>>>>>
79622>>>>>
79622>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
79623>>>>>    
79623>>>>>    Procedure Construct_Object
79625>>>>>        Forward Send Construct_Object
79627>>>>>        Property Handle[] phArrayOfWindows
79628>>>>>        Set peControlType to xtpControlPopup
79629>>>>>        Set psCategory to C_$CategoryWindow
79630>>>>>    End_Procedure
79631>>>>>    
79631>>>>>     // This adds MDI windows to the existing menu items.
79631>>>>>     // This removes any existing windows menus and always adds a new set to the end
79631>>>>>
79631>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
79633>>>>>        Handle  hClientArea hView
79633>>>>>        String  sLabel
79633>>>>>        Integer i iWindows
79633>>>>>        Handle[] hArrayOfWindows
79634>>>>>        Variant vItem
79634>>>>>        
79634>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
79634>>>>>        // also assume that destroying an action removes all menu instances of that action
79634>>>>>        Get phArrayOfWindows to hArrayOfWindows
79635>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
79636>>>>>        For i from 0 to (iWindows-1)
79642>>>>>>
79642>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
79643>>>>>        Loop
79644>>>>>>
79644>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
79645>>>>>
79645>>>>>        // Add all views to this menu. Create the action and add the item
79645>>>>>        Move 0 to i
79646>>>>>        Get Client_Id to hClientArea // object id of client area
79647>>>>>        If (hClientArea > 0) Begin
79649>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
79650>>>>>            While (hView <> 0)
79654>>>>>                If (Active_State(hView)) Begin
79656>>>>>                    // create the action
79656>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
79657>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
79658>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
79659>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
79660>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
79662>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
79663>>>>>                    End
79663>>>>>>
79663>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
79664>>>>>                    If (i=0) Begin
79666>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
79667>>>>>                    End
79667>>>>>>
79667>>>>>                    // Create a menu item for this action
79667>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
79668>>>>>                    Increment i
79669>>>>>                End
79669>>>>>>
79669>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
79670>>>>>            Loop
79671>>>>>>
79671>>>>>        End
79671>>>>>>
79671>>>>>
79671>>>>>        Set phArrayOfWindows to hArrayOfWindows
79672>>>>>
79672>>>>>     End_Procedure
79673>>>>>     
79673>>>>>End_Class
79674>>>>>
79674>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vWin32fh.pkg)
79674>>>// This code is part of VDF GUIdance
79674>>>// Visit us @ http://www.vdf-guidance.com
79674>>>// e-Mail us @ info@vdf-guidance.com
79674>>>// VDF GUIdance is a mutual project of
79674>>>// Frank Vandervelpen - Vandervelpen Systems and
79674>>>// Wil van Antwerpen  - Antwise Solutions
79674>>>// All software source code should be used <<AS IS>> without any warranty.
79674>>>//
79674>>>//
79674>>>// *** Windows 32bit file handling wrapper class ***
79674>>>//
79674>>>
79674>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
79674>>>//                   This may be painfull for some of you, but it was really needed as it was
79674>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
79674>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
79674>>>//
79674>>>// The used naming-convention is:
79674>>>//     - a prefix of "vWin32_" for every external function declaration
79674>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
79674>>>//
79674>>>// By using this we are guarding ourselves for conflicts with variable declarations
79674>>>// of DataAccess in the future.
79674>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
79674>>>//
79674>>>// mm-dd-yyyy Author Description
79674>>>//
79674>>>//                   vSHGetFolderPath added to retrieve the new shell folders
79674>>>//                   vGetWindowsDirectory
79674>>>//
79674>>>//                   vGetTempFileName
79674>>>//                   vGetTempPath
79674>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
79674>>>//                   This is an absolute need for WebApp. We expect you to handle the
79674>>>//                   error in your application anyways. Changed this for:
79674>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
79674>>>// 03-02-2002 **WvA: vRemoveDirectory added
79674>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
79674>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
79674>>>//                   It is renamed too avoid this.
79674>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
79674>>>//                   function vSelectedFileName is now just SelectedFileName
79674>>>//                   Removed the local keyword in the variable declarations
79674>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
79674>>>//                   created file-open dialog
79674>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
79674>>>//                   in that it didn't exactly return the correct filename of the file created.
79674>>>//                   This has now been taken care of.
79674>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
79674>>>//                   These declarations are now included from the vWin32fh header file.
79674>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
79674>>>//                   Before today one could always undo the operation, as of now you cannot as
79674>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
79674>>>//                   Since i don't really expect someone to use that feature it has been removed.
79674>>>//                   One can however restore to the old way of handling by simply calling the
79674>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
79674>>>//                   filehandling operations
79674>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
79674>>>//                   as well as the StringFromRightOfChar function.
79674>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
79674>>>//                   DISABLED now as testing shows that it does not work as advertised...
79674>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
79674>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
79674>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
79674>>>//                   extended characters are treated ok too.
79674>>>//                   Reported by Flemming from
79674>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
79674>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
79674>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
79674>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
79674>>>//                   Added vSelectSavefile function to create a file save dialog
79674>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
79674>>>//                   Added vParentPath function to retrieve the parent "node" of a path
79674>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
79674>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
79674>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
79674>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
79674>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
79674>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
79674>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
79674>>>
79674>>>Use Case.mac
79674>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
79674>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cvFileDialogs.pkg)
79674>>>>>//***************************************************************************
79674>>>>>//*
79674>>>>>//* Class:        cvSaveAsDialog
79674>>>>>//* Package Name: cvFileDialogs.pkg
79674>>>>>//*
79674>>>>>//***************************************************************************
79674>>>>>
79674>>>>>Use File_dlg.pkg
79674>>>>>
79674>>>>>// *WvA: 13-01-1999 Created
79674>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
79674>>>>>// This function opens the Windows standard file open dialog and returns the selected
79674>>>>>// file_name.
79674>>>>>Class cvSelectFile_Dialog Is An OpenDialog
79675>>>>>
79675>>>>>  Procedure Construct_Object Integer iImage_Id
79677>>>>>    Forward Send Construct_Object iImage_Id
79679>>>>>    Set HideReadOnly_State To True
79680>>>>>  End_Procedure // Construct_Object
79681>>>>>
79681>>>>>  Function SelectedFileName Returns String
79683>>>>>    String sFileName
79683>>>>>    Move "" To sFileName
79684>>>>>    If (Show_Dialog(Self)) Begin
79686>>>>>      Move (RTrim(File_Name(Self))) To sFileName
79687>>>>>    End
79687>>>>>>
79687>>>>>    Function_Return sFileName
79688>>>>>  End_Function // SelectedFileName
79689>>>>>End_Class // cvSelectFile_Dialog
79690>>>>>
79690>>>>>
79690>>>>>// *WvA: 13-01-1999 Created
79690>>>>>// This function opens the Windows standard file open dialog and returns the selected
79690>>>>>// file_name. Returns '' if the user didn't make a selection.
79690>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
79690>>>>>//                   file-open dialog
79690>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
79692>>>>>  String sSelectedFile
79692>>>>>  Integer hoOpenFileDialog
79692>>>>>
79692>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
79694>>>>>
79694>>>>>    Set Dialog_Caption    To sCaptionText
79695>>>>>    Set Filter_String     To sSupportedFileTypes
79696>>>>>    Set Initial_Folder    To sInitialFolder
79697>>>>>
79697>>>>>    Move Self       To hoOpenFileDialog
79698>>>>>  End_Object // oOpenFileDialog
79699>>>>>
79699>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
79700>>>>>  Send Destroy_Object To hoOpenFileDialog
79701>>>>>  Function_Return sSelectedFile
79702>>>>>End_Function // vSelect_File
79703>>>>>
79703>>>>>
79703>>>>>Class cvSaveAsDialog is a SaveAsDialog
79704>>>>>
79704>>>>>  Procedure Construct_Object
79706>>>>>    Forward Send Construct_Object
79708>>>>>    Set HideReadOnly_State To True
79709>>>>>  End_Procedure // Construct_Object
79710>>>>>
79710>>>>>  Function SelectedFileName Returns String
79712>>>>>    String sFileName
79712>>>>>    Move "" To sFileName
79713>>>>>    If (Show_Dialog(Self)) Begin
79715>>>>>      Move (RTrim(File_Name(Self))) To sFileName
79716>>>>>    End
79716>>>>>>
79716>>>>>    Function_Return sFileName
79717>>>>>  End_Function // SelectedFileName
79718>>>>>
79718>>>>>End_Class // cvSaveAsDialog
79719>>>>>
79719>>>>>// Added optional default filename as suggested by Nils
79719>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
79721>>>>>  String sSelectedFile
79721>>>>>  Integer hoDialog
79721>>>>>
79721>>>>>  Move "" To sSelectedFile
79722>>>>>  Get Create U_cvSaveAsDialog To hoDialog
79723>>>>>  If (hoDialog) Begin
79725>>>>>    //Set NoChangeDir_State Of hoDialog To True
79725>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
79726>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
79727>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
79728>>>>>    If (Num_Arguments = 4) Begin
79730>>>>>      Set File_Title        of hoDialog to sDefaultFileName
79731>>>>>    End
79731>>>>>>
79731>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
79732>>>>>    Send Destroy Of hoDialog
79733>>>>>  End
79733>>>>>>
79733>>>>>  Function_Return sSelectedFile
79734>>>>>End_Function // vSelectSaveFile
79735>>>Use Seq_chnl.pkg
79735>>>
79735>>>Use windows
79735>>>//Use Dferror
79735>>>Use Dll
79735>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vwin32fh.h)
79735>>>>>//TH-Header
79735>>>>>//*****************************************************************************************
79735>>>>>// Copyright (c)  2004 KURANT Project
79735>>>>>// All rights reserved.
79735>>>>>//
79735>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
79735>>>>>// $ProjectName : Windows 32 bits file handling
79735>>>>>// $Authors     : Wil van Antwerpen
79735>>>>>// $Created     : 19.02.2004  19:25
79735>>>>>// $Type        : BSD (as in do with it whatever you like)
79735>>>>>//
79735>>>>>// Contents:
79735>>>>>//  This file contains the Windows API external function call definitions and
79735>>>>>//  constants as they are used in the vWin32fh package.
79735>>>>>//*****************************************************************************************
79735>>>>>//TH-RevisionStart
79735>>>>>//TH-RevisionEnd
79735>>>>>
79735>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
79735>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
79735>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
79735>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
79735>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
79735>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
79735>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
79735>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
79735>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
79735>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
79735>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
79735>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
79735>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
79735>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
79735>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
79735>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
79735>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
79735>>>>>
79735>>>>>
79735>>>>>Define vMax_Path     For |CI260
79735>>>>>Define vMinChar      For |CI$80
79735>>>>>Define vMaxChar      For |CI$7F
79735>>>>>Define vMinShort     For |CI$8000
79735>>>>>Define vMaxShort     For |CI$7FFF
79735>>>>>Define vMinLong      For |CI$80000000
79735>>>>>Define vMaxLong      For |CI$7FFFFFFF
79735>>>>>Define vMaxByte      For |CI$FF
79735>>>>>Define vMaxWord      For |CI$FFFF
79735>>>>>Define vMaxDword     For |CI$FFFFFFFF
79735>>>>>
79735>>>>>
79735>>>>>
79735>>>>>// For FindFirstFile
79735>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
79735>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
79735>>>>>Define vERROR_NO_MORE_FILES    For |CI18
79735>>>>>
79735>>>>>// The defines below can be used to find out what kind of error has occurred if
79735>>>>>// the API-call ShellExecute is used.
79735>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
79735>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
79735>>>>>Define vERROR_BAD_FORMAT       For |CI0011
79735>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
79735>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
79735>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
79735>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
79735>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
79735>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
79735>>>>>Define vSE_ERR_FNF             For |CI0002
79735>>>>>Define vSE_ERR_NOASSOC         For |CI0031
79735>>>>>Define vSE_ERR_OOM             For |CI0008
79735>>>>>Define vSE_ERR_PNF             For |CI0003
79735>>>>>Define vSE_ERR_SHARE           For |CI0026
79735>>>>>
79735>>>>>
79735>>>>>// C-Structure
79735>>>>>//typedef struct _browseinfo {
79735>>>>>//    HWND hwndOwner;
79735>>>>>//    LPCITEMIDLIST pidlRoot;
79735>>>>>//    LPSTR pszDisplayName;
79735>>>>>//    LPCSTR lpszTitle;
79735>>>>>//    UINT ulFlags;
79735>>>>>//    BFFCALLBACK lpfn;
79735>>>>>//    LPARAM lParam;
79735>>>>>//    int iImage;
79735>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
79735>>>>>
79735>>>>>//declare C structure struct_browseinfo
79735>>>>>//as documented in MSDN under Windows Shell API
79735>>>>>Type vtBrowseInfo
79735>>>>>  Field vtBrowseInfo.hWndOwner      as Handle
79735>>>>>  Field vtBrowseInfo.pIDLRoot       as Pointer
79735>>>>>  Field vtBrowseInfo.pszDisplayName as Pointer
79735>>>>>  Field vtBrowseInfo.lpszTitle      as Pointer
79735>>>>>  Field vtBrowseInfo.ulFlags        as dWord
79735>>>>>  Field vtBrowseInfo.lpfnCallback   as Pointer
79735>>>>>  Field vtBrowseInfo.lParam         as dWord
79735>>>>>  Field vtBrowseInfo.iImage         as dWord
79735>>>>>End_Type // tBrowseInfo
79735>>>>>
79735>>>>>// Browsing for directory.
79735>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
79735>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
79735>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
79735>>>>>                                            // The callback function can set the status text by
79735>>>>>                                            // sending messages to the dialog box.
79735>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
79735>>>>>
79735>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
79735>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
79735>>>>>
79735>>>>>// message from browser
79735>>>>>//Define BFFM_INITIALIZED        1
79735>>>>>//Define BFFM_SELCHANGED         2
79735>>>>>
79735>>>>>// messages to browser
79735>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
79735>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
79735>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
79735>>>>>
79735>>>>>
79735>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
79736>>>>>
79736>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
79737>>>>>
79737>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
79738>>>>>
79738>>>>>
79738>>>>>
79738>>>>>
79738>>>>>Type vtSecurity_attributes
79738>>>>>  Field vtSecurity_attributes.nLength        as dWord
79738>>>>>  Field vtSecurity_attributes.lpDescriptor   as Pointer
79738>>>>>  Field vtSecurity_attributes.bInheritHandle as Integer
79738>>>>>End_Type // vtSecurity_attributes
79738>>>>>
79738>>>>>//nLength:
79738>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
79738>>>>>// SECURITY_ATTRIBUTES structure.
79738>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
79738>>>>>// value of the nLength member. However, an application should still set it properly.
79738>>>>>// That ensures current, future, and cross-platform compatibility.
79738>>>>>//
79738>>>>>//lpSecurityDescriptor:
79738>>>>>// Points to a security descriptor for the object that controls the sharing of it.
79738>>>>>// If NULL is specified for this member, the object may be assigned the default security
79738>>>>>// descriptor of the calling process.
79738>>>>>//
79738>>>>>//bInheritHandle:
79738>>>>>// Specifies whether the returned handle is inherited when a new process is created.
79738>>>>>// If this member is TRUE, the new process inherits the handle.
79738>>>>>
79738>>>>>
79738>>>>>// BOOL CreateDirectory(
79738>>>>>//    LPCTSTR lpPathName,
79738>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
79738>>>>>//   );
79738>>>>>//
79738>>>>>// lpPathName
79738>>>>>//  Points to a null-terminated string that specifies the path of the directory
79738>>>>>//  to be created.
79738>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
79738>>>>>//  This limit is related to how the CreateDirectory function parses paths.
79738>>>>>// lpSecurityAttributes
79738>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
79738>>>>>//  determines whether the returned handle can be inherited by child processes.
79738>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
79738>>>>>// Returns:
79738>>>>>//  If the function succeeds, the return value is nonzero.
79738>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
79738>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
79739>>>>>
79739>>>>>
79739>>>>>// lpPathName
79739>>>>>//  Points to a null-terminated string that specifies the path of the directory
79739>>>>>//  to be removed.
79739>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
79739>>>>>// Returns:
79739>>>>>//  If the function succeeds, the return value is nonzero.
79739>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
79739>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
79740>>>>>
79740>>>>>
79740>>>>>
79740>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
79740>>>>>// executable file or a document file.
79740>>>>>//
79740>>>>>// Operation can be one of the following:
79740>>>>>//    "OPEN"  The function opens the file specified by lpFile.
79740>>>>>//            The file can be an executable file or a document file.
79740>>>>>//            The file can be a folder to open.
79740>>>>>//    "PRINT" The function prints the file specified by lpFile.
79740>>>>>//            The file should be a document file. If the file is an executable file,
79740>>>>>//            the function opens the file, as if "open" had been specified.
79740>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
79740>>>>>//
79740>>>>>// Return Values:
79740>>>>>//
79740>>>>>// If the function succeeds, the return value is the instance handle of the application that
79740>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
79740>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
79740>>>>>//
79740>>>>>// The following table lists these error values:
79740>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
79740>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
79740>>>>>// Public Const ERROR_BAD_FORMAT = 11&
79740>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
79740>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
79740>>>>>// Public Const SE_ERR_DDEBUSY = 30
79740>>>>>// Public Const SE_ERR_DDEFAIL = 29
79740>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
79740>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
79740>>>>>// Public Const SE_ERR_FNF = 2
79740>>>>>// Public Const SE_ERR_NOASSOC = 31
79740>>>>>// Public Const SE_ERR_OOM = 8
79740>>>>>// Public Const SE_ERR_PNF = 3
79740>>>>>// Public Const SE_ERR_SHARE = 26
79740>>>>>
79740>>>>>
79740>>>>>
79740>>>>>// Code to open the program that is associated with the selected file.
79740>>>>>//
79740>>>>>// External function call used in Procedure DoStartDocument
79740>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>
79741>>>>>                                          // Must be freed using SHFreeNameMappings
79741>>>>>
79741>>>>>Type vtShFileOpStruct
79741>>>>>  Field vtShFileOpStruct.hWnd                   as Handle
79741>>>>>  Field vtShFileOpStruct.wFunc                  as Integer
79741>>>>>  Field vtShFileOpStruct.pFrom                  as Pointer
79741>>>>>  Field vtShFileOpStruct.pTo                    as Pointer
79741>>>>>  Field vtShFileOpStruct.fFlags                 as Short
79741>>>>>  Field vtShFileOpStruct.fAnyOperationsAborted  as Short
79741>>>>>  Field vtShFileOpStruct.hNameMappings          as Pointer
79741>>>>>  Field vtShFileOpStruct.lpszProgressTitle      as Pointer // only used if FOF_SIMPLEPROGRESS
79741>>>>>End_Type // tShFileOpStruct
79741>>>>>
79741>>>>>// hwnd
79741>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
79741>>>>>
79741>>>>>// wFunc
79741>>>>>//   Operation to perform. This member can be one of the following values:
79741>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
79741>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
79741>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
79741>>>>>//     FO_RENAME   Renames the files specified by pFrom.
79741>>>>>
79741>>>>>// pFrom
79741>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
79741>>>>>//   be null-separated. The list of names must be double null-terminated.
79741>>>>>
79741>>>>>// pTo
79741>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
79741>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
79741>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
79741>>>>>//   double null-terminated.
79741>>>>>
79741>>>>>// fAnyOperationsAborted
79741>>>>>//   Value that receives TRUE if the user aborted any file operations before they
79741>>>>>//   were completed or FALSE otherwise.
79741>>>>>
79741>>>>>
79741>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
79741>>>>>// This can be a file or a folder.
79741>>>>>// With thanks to Andrew S Kaplan
79741>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
79742>>>>>
79742>>>>>
79742>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
79742>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
79743>>>>>
79743>>>>>
79743>>>>>
79743>>>>>// Courtesy Of Vincent Oorsprong
79743>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
79743>>>>>//   Pointer lpPathName ;
79743>>>>>//   Pointer lpPrefixString ;
79743>>>>>//   Integer uUnique ;
79743>>>>>//   Pointer lpTempFileName ;
79743>>>>>//   Returns Integer
79743>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
79743>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
79744>>>>>
79744>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
79745>>>>>
79745>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
79746>>>>>                  
79746>>>>>// from:
79746>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
79746>>>>>//
79746>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
79746>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
79746>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
79746>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
79746>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
79746>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
79746>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
79746>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
79746>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
79746>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
79746>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
79746>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
79746>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
79746>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
79746>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
79746>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
79746>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
79746>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
79746>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
79746>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
79746>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
79746>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
79746>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
79746>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
79746>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
79746>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
79746>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
79746>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
79746>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
79746>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
79746>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
79746>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
79746>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
79746>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
79746>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
79746>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
79746>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
79746>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
79746>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
79746>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
79746>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
79746>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
79746>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
79746>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
79746>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
79746>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
79746>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
79746>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
79746>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
79746>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
79746>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
79746>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
79746>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
79746>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
79746>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
79746>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
79746>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
79746>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
79746>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
79746>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
79746>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
79746>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
79746>>>>>
79746>>>>>
79746>>>>>//HRESULT SHGetFolderPath(
79746>>>>>//    HWND hwndOwner,
79746>>>>>//    int nFolder,
79746>>>>>//    HANDLE hToken,
79746>>>>>//    DWORD dwFlags,
79746>>>>>//    LPTSTR pszPath
79746>>>>>//);
79746>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
79746>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
79746>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
79746>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
79746>>>>>// If that fails, it will try to simulate the appropriate behavior.
79746>>>>>//
79746>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
79747>>>>>
79747>>>>>
79747>>>>>
79747>>>>>Type vWin32_Find_Data
79747>>>>>  Field vWin32_Find_Data.dwFileAttributes As Dword
79747>>>>>  Field vWin32_Find_Data.ftCreationLowDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftCreationHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastAccessLowDateTime As dword
79747>>>>>  Field vWin32_Find_Data.ftLastAccessHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastWriteLowDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.ftLastWriteHighDateTime As Dword
79747>>>>>  Field vWin32_Find_Data.nFileSizeHigh As Dword
79747>>>>>  Field vWin32_Find_Data.nFileSizeLow As Dword
79747>>>>>  Field vWin32_Find_Data.dwReserved0 As Dword
79747>>>>>  Field vWin32_Find_Data.dwReserved1 As Dword
79747>>>>>  Field vWin32_Find_Data.cFileName As Char vMax_Path
79747>>>>>  Field vWin32_Find_Data.cAlternateFileName As Char 14
79747>>>>>End_Type // vWin32_Find_Data
79747>>>>>
79747>>>>>// Courtesy Of Vincent Oorsprong
79747>>>>>// lpFileName      : address of name of file to search for
79747>>>>>// lpFindFileData  : address of returned information
79747>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
79748>>>>>
79748>>>>>// Courtesy Of Vincent Oorsprong
79748>>>>>// hFindFile       : handle of search
79748>>>>>// lpFindFileData  : address of structure for data on found file
79748>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
79749>>>>>
79749>>>>>// Courtesy Of Vincent Oorsprong
79749>>>>>//  hFindFile      : file search handle
79749>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
79750>>>>>
79750>>>>>
79750>>>>>
79750>>>>>Type vFileTime
79750>>>>>  Field vFileTime.dwLowDateTime As Dword
79750>>>>>  Field vFileTime.dwHighDateTime As Dword
79750>>>>>End_Type // vFileTime
79750>>>>>
79750>>>>>
79750>>>>>Type vSystemTime
79750>>>>>  Field vSystemTime.wYear As Word
79750>>>>>  Field vSystemTime.wMonth As Word
79750>>>>>  Field vSystemTime.wDayOfWeek As Word
79750>>>>>  Field vSystemTime.wDay As Word
79750>>>>>  Field vSystemTime.wHour As Word
79750>>>>>  Field vSystemTime.wMinute As Word
79750>>>>>  Field vSystemTime.wSecond As Word
79750>>>>>  Field vSystemTime.wMilliSeconds As Word
79750>>>>>End_Type // vSystemTime
79750>>>>>
79750>>>>>
79750>>>>>// Courtesy Of Vincent Oorsprong
79750>>>>>//  lpFileTime     : pointer to file time to convert
79750>>>>>//  lpSystemTime   : pointer to structure to receive system time
79750>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
79751>>>>>
79751>>>>>// Courtesy Of Vincent Oorsprong
79751>>>>>// This function formats the time in a picture-string passed
79751>>>>>//
79751>>>>>// Picture      Meaning
79751>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
79751>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
79751>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
79751>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
79751>>>>>//    m         Minutes with no leading zero for single-digit minutes
79751>>>>>//    mm        Minutes with leading zero for single-digit minutes
79751>>>>>//    s         Seconds with no leading zero for single-digit seconds
79751>>>>>//    ss        Seconds with leading zero for single-digit seconds
79751>>>>>//    t         One character time marker string, such as A or P
79751>>>>>//    tt        Multicharacter time marker string, such as AM or PM
79751>>>>>//
79751>>>>>// For example, to get the time string  "11:29:40 PM"
79751>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
79751>>>>>
79751>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
79752>>>>>
79752>>>>>
79752>>>>>// Courtesy Of Vincent Oorsprong
79752>>>>>// This function formats the date in a picture-string passed
79752>>>>>//
79752>>>>>// Picture      Meaning
79752>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
79752>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
79752>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
79752>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
79752>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
79752>>>>>//              value associated with the specified locale.
79752>>>>>//    M         Month as digits with no leading zero for single-digit months.
79752>>>>>//    MM        Month as digits with leading zero for single-digit months.
79752>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
79752>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
79752>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
79752>>>>>//              associated with the specified locale.
79752>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
79752>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
79752>>>>>//    yyyy      Year represented hy full four digits.
79752>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
79752>>>>>//              with the specified locale. This element is ignored if the date to be formatted
79752>>>>>//              does not have an associated era or period string.
79752>>>>>// For example, to get the date string  "Wed, Aug 31 94"
79752>>>>>// use the following picture string:    "ddd","MMM dd yy"
79752>>>>>
79752>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
79753>>>>>
79753>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
79753>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$0000000l  //  do not use minutes or seconds
79753>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
79753>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
79753>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
79753>>>>>
79753>>>>>//  Date Flags for GetDateFormatW.
79753>>>>>//
79753>>>>>Define DATE_SHORTDATE           For |CI$0000000l  //  use short date picture
79753>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
79753>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
79753>>>>>
79753>>>>>
79753>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
79754>>>>>
79754>>>>>
79754>>>>>// **WvA: 20-02-2004
79754>>>>>// While i was testing the format capabilities i stumbled over a very
79754>>>>>// weird problem where it looks like that the integer value gets somehow translated
79754>>>>>// incorrectly into an unsigned integer.
79754>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
79754>>>>>// It does smell a bit fishy though
79754>>>>>// Tested it with the same results on both VDF7 and VDF9.1
79754>>>>>
79754>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
79754>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
79754>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
79754>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
79754>>>>>
79754>>>>>// Possible errors that can be returned by the shellformat function
79754>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
79754>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
79754>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
79754>>>>>                                                
79754>>>>>
79754>>>>> // Courtesy Of Steve Walter,
79754>>>>> // USA Software, Inc
79754>>>>> // Format a disk
79754>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
79754>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
79755>>>>>
79755>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
79755>>>>>
79755>>>>>// SHCreateDirectoryEx
79755>>>>>
79755>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
79755>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
79755>>>>>//
79755>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
79755>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
79755>>>>>//    the files are visible. If they are not visible, expect one of the following:
79755>>>>>//
79755>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
79755>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
79755>>>>>//        ERROR_CANCELLED.
79755>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
79755>>>>>
79755>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
79755>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
79755>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
79755>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
79755>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
79755>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
79755>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
79755>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
79755>>>>>
79755>>>>>//        int SHCreateDirectoryEx(
79755>>>>>//            HWND hwnd,
79755>>>>>//            LPCTSTR pszPath,
79755>>>>>//            const SECURITY_ATTRIBUTES *psa
79755>>>>>//        );
79755>>>>>
79755>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
79756>>>
79756>>>
79756>>>
79756>>>
79756>>>
79756>>>//
79756>>>// Gets the string from the right of the last sStopChar in sFrom
79756>>>// If sStopChar has no occurences in the string an empty string is
79756>>>// returned.
79756>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
79758>>>  String  sRetVal
79758>>>  String  sChar
79758>>>  Integer iLength
79758>>>  Integer iPos
79758>>>  Boolean bStopChar
79758>>>  Move "" To sRetval
79759>>>  Move (Length(sFrom)) To iLength
79760>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
79762>>>    Move iLength   To iPos
79763>>>    Move (False)   To bStopChar
79764>>>    While Not bStopChar
79768>>>      Move (Mid(sFrom,1,iPos)) To sChar
79769>>>      Decrement iPos
79770>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
79772>>>        Move (True) To bStopChar
79773>>>      End
79773>>>>
79773>>>      Else Begin
79774>>>        Move (sChar+sRetVal) To sRetVal
79775>>>      End
79775>>>>
79775>>>    Loop
79776>>>>
79776>>>  End
79776>>>>
79776>>>  Function_Return sRetVal
79777>>>End_Function // StringFromRightOfChar
79778>>>
79778>>>
79778>>>// Pre:  sFileName contains the complete path of the file.
79778>>>// Post: returns the complete path of the file.
79778>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
79778>>>Function ParseFolderName Global String sFileName Returns String
79780>>>  String sFile
79780>>>  String sFolderName
79780>>>  String sDirSep // this is "\" for windows, or "/" for unix
79780>>>  MOve "" To sFolderName
79781>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
79782>>>  If sDirSep In sFileName Begin
79784>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
79785>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
79786>>>  End
79786>>>>
79786>>>  Else If ":" In sFileName Begin
79789>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
79790>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
79791>>>  End
79791>>>>
79791>>>  Function_Return sFolderName
79792>>>End_Function // ParseFolderName
79793>>>
79793>>>
79793>>>// Pre:  sFileName contains the complete path of the file.
79793>>>// post: The returned filename has it's path removed, but will have a extension
79793>>>Function ParseFileName Global String sFileName Returns String
79795>>>  String sFolderName
79795>>>  String sDirSep // this is "\" for windows, or "/" for unix
79795>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
79796>>>  Get ParseFolderName sFileName To sFolderName
79797>>>  If (sFolderName <> "") Move (Replace(sFolderName,sFileName,"")) To sFileName
79800>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
79801>>>  Function_Return sFilename
79802>>>End_Function // ParseFileName
79803>>>
79803>>>
79803>>>// Pre:  sFileName may contain the complete path of the file.
79803>>>//       or contain multiple dots in the filename, so temp.gif.bak will
79803>>>//       return "bak" as the extension and not "gif"
79803>>>// Post: returns the extension only, this extension can be a valid unixlike extension
79803>>>//       such as "html" or "java"
79803>>>Function ParseFileExtension Global String sFileName Returns String
79805>>>  String  sFileExtension
79805>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
79806>>>  Function_Return sFileExtension
79807>>>End_Function // ParseFileExtension
79808>>>
79808>>>
79808>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
79808>>>
79808>>>
79808>>>Function DDE_Error_To_String Integer iErrorID Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
79810>>>  String sMessage
79810>>>  Case Begin
79810>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
79812>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
79813>>>      Case Break
79814>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
79817>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
79818>>>      Case Break
79819>>>    Case (iErrorID = vERROR_BAD_FORMAT)
79822>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
79823>>>      Case Break
79824>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
79827>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
79828>>>      Case Break
79829>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
79832>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
79833>>>      Case Break
79834>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
79837>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
79838>>>      Case Break
79839>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
79842>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
79843>>>      Case Break
79844>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
79847>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
79848>>>      Case Break
79849>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
79852>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
79853>>>      Case Break
79854>>>    Case (iErrorID = vSE_ERR_NOASSOC)
79857>>>      Move CS_DDE_ERR_NOASSOC To sMessage
79858>>>      Case Break
79859>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
79862>>>      Move CS_DDE_ERR_OOM To sMessage
79863>>>      Case Break
79864>>>    Case (iErrorID = vSE_ERR_PNF)
79867>>>      Move CS_DDE_ERR_PNF To sMessage
79868>>>      Case Break
79869>>>    Case (iErrorID = vSE_ERR_SHARE)
79872>>>      Move CS_DDE_ERR_SHARE To sMessage
79873>>>      Case Break
79874>>>    Case Else
79874>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
79875>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
79876>>>      Case Break
79877>>>  Case End
79877>>>  Function_Return sMessage
79878>>>End_Function // DDE_Error_To_String
79879>>>
79879>>>
79879>>>Procedure vDDE_Error_Handler Integer iErrorID
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
79881>>>  String sMessage
79881>>>  Get DDE_Error_To_String iErrorID To sMessage
79882>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
79883>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
79884>>>End_Procedure // vDDE_Error_Handler hInstance
79885>>>
79885>>>
79885>>>// Does the directory exist? - No = 0, Yes = 1
79885>>>// This also works with UNC path encoding and wildcards
79885>>>Function vFolderExists Global String sFolderName Returns Integer
79887>>>  String  sFolder sTmp
79887>>>  Integer bFolderExists iCh
79887>>>
79887>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
79887>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
79888>>>  If (sFolderName = "") Begin
79890>>>    Function_Return False
79891>>>  End
79891>>>>
79891>>>
79891>>>  Move dfTrue To bFolderExists
79892>>>  Move "dir:" To sFolder
79893>>>  Append sFolder sFolderName
79894>>>  Get Seq_New_Channel To iCh  // get free channel for input
79895>>>  Direct_Input Channel iCh sFolder
79897>>>    Repeat
79897>>>>
79897>>>      Readln Channel iCh sTmp
79899>>>      If (Trim(sTmp)="") Move dfFalse To bFolderExists
79902>>>      Else Begin
79903>>>        Move dfTrue To bFolderExists
79904>>>        Indicate seqeof True  // end loop
79905>>>        End
79905>>>>
79905>>>    Until (seqeof)
79907>>>  Close_Input Channel iCh
79909>>>  Send Seq_Release_Channel iCh
79910>>>  Function_Return bFolderExists
79911>>>End_Function  // vFolderExists
79912>>>
79912>>>
79912>>>// returns folder name if a folder was selected, otherwise returns ""
79912>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
79914>>>  String sFolder sBrowseInfo sTitle
79914>>>  Pointer lpItemIdList lpsFolder lpsBrowseInfo lpsTitle
79914>>>  Integer iFolderSelected iRetval
79914>>>
79914>>>  // fill string variable with null characters
79914>>>  ZeroType vtBrowseInfo To sBrowseInfo
79915>>>
79915>>>  If (sDialogTitle<>"") Begin
79917>>>    Move sDialogTitle To sTitle
79918>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
79918>>>    // disables showing some commonly used ascii characters like ascii 137 ()
79918>>>    // These chars are correctly shown if no toansi is used.
79918>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
79918>>>    // selected it will always be valid.
79918>>>    GetAddress Of sTitle To lpsTitle
79919>>>    Put lpsTitle To sBrowseInfo At vtBrowseInfo.lpszTitle
79920>>>  End
79920>>>>
79920>>>
79920>>>  Put vBIF_RETURNONLYFSDIRS To sBrowseInfo At vtBrowseInfo.ulFlags
79921>>>
79921>>>  // Torben Lund added line below. Move handle of focus object to structure before
79921>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
79921>>>  Put (window_handle(focus(desktop))) To sBrowseInfo At vtBrowseInfo.hWndOwner
79922>>>
79922>>>  GetAddress Of sBrowseInfo To lpsBrowseInfo
79923>>>
79923>>>  // null 128 chars into var (make space)
79923>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
79924>>>  GetAddress Of sFolder To lpsFolder
79925>>>
79925>>>  // select folder
79925>>>  Move (vWin32_SHBrowseForFolder(lpsBrowseInfo)) To lpItemIdList
79926>>>  // get selected folder name
79926>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, lpsFolder)) To iFolderSelected
79927>>>
79927>>>  // release memory resources that are used by the ItemIdList
79927>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
79928>>>
79928>>>  If (iFolderSelected<>0) Function_Return (CString(sFolder))
79931>>>  Else Function_Return ""
79933>>>End_Function // vSHBrowseForFolder
79934>>>
79934>>>
79934>>>// returns 0 if the folder is created.
79934>>>//         1 if the API-call returned an error.
79934>>>Function vCreateDirectory Global String sNewFolder Returns Integer
79936>>>  String  sFolder sSA
79936>>>  Pointer lpsFolder lpsSecurity_Attributes lpDescriptor
79936>>>  Integer iRetval bFolderCreated bInheritHandle
79936>>>
79936>>>  Move (False) To bFolderCreated
79937>>>  // fill string variable with null characters
79937>>>  ZeroType vtSecurity_attributes To sSA
79938>>>
79938>>>  // null MAX_PATH chars into var (make space)
79938>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
79939>>>
79939>>>  If (sNewFolder <> "") Begin
79941>>>
79941>>>    Move dfTrue To  bInheritHandle
79942>>>    // Setting this to NULL is already done by the zerotype command
79942>>>    // Move NULL   To  lpDescriptor
79942>>>    Put (length(sSA))   To sSA At vtSecurity_attributes.nLength
79943>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
79943>>>    Put bInheritHandle To sSA At vtSecurity_attributes.bInheritHandle
79944>>>
79944>>>    GetAddress Of sSA To lpsSecurity_Attributes
79945>>>
79945>>>    //
79945>>>    Move sNewFolder To sFolder
79946>>>    GetAddress Of sFolder To lpsFolder
79947>>>    Move (vWin32_CreateDirectory(lpsFolder, lpsSecurity_Attributes)) To bFolderCreated
79948>>>  End
79948>>>>
79948>>>
79948>>>  Ifnot bFolderCreated Move 1 To iRetVal
79951>>>  Function_Return iRetVal
79952>>>End_Function // vCreateDirectory
79953>>>
79953>>>
79953>>>// **WvA: 03-02-2002 Function created.
79953>>>// With this function one can remove a directory.
79953>>>// returns 0 if the folder is removed.
79953>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
79953>>>//         2 if the folder did not exist
79953>>>//         3 if the sFolder parameter passed is equal to ""
79953>>>Function vRemoveDirectory Global String sFolder Returns Integer
79955>>>  String  sPath
79955>>>  Pointer lpsPath
79955>>>  Integer iRetval bRemoved bExists
79955>>>
79955>>>  Move (False) To bRemoved
79956>>>  Move 0 To iRetVal
79957>>>  Move (Trim(sFolder)) To sFolder
79958>>>  If (sFolder="") Begin
79960>>>    Move 3 To iRetVal
79961>>>  End
79961>>>>
79961>>>  If (vFolderExists(sFolder)=False) Begin
79963>>>    Move 2 To iRetVal
79964>>>  End
79964>>>>
79964>>>  If (iRetVal=0) Begin
79966>>>    // null MAX_PATH chars into var (make space)
79966>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
79967>>>    //
79967>>>    Move (Insert(sFolder,sPath,1)) To sPath
79968>>>    GetAddress Of sPath To lpsPath
79969>>>    Move (vWin32_RemoveDirectory(lpsPath)) To bRemoved
79970>>>  End
79970>>>>
79970>>>
79970>>>  If ((iRetVal=0) And (bRemoved=False)) Begin
79972>>>    Move 1 To iRetVal
79973>>>  End
79973>>>>
79973>>>  Function_Return iRetVal
79974>>>End_Function // vRemoveDirectory
79975>>>
79975>>>
79975>>>
79975>>>// This function informs the user that he entered a yet unknown folder and
79975>>>// asks if he/she wants to create the folder (Yes/No)
79975>>>// Choice: "Yes" - this creates the folder
79975>>>//                 if successful, the function returns false
79975>>>//                 else it will be true.
79975>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
79975>>>//                 For example: to stop a save
79975>>>// Precondition: A foldername must be entered. We do not check for empty paths
79975>>>// This function returns a non-zero value if the folder isn't created afterwards
79975>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
79977>>>  Integer bIsNotValid
79977>>>  Integer iUsers_Choice
79977>>>  String  sMessage
79977>>>
79977>>>  If (vFolderExists(sFolderName) Eq 0) Begin
79979>>>    Move "The folder '" To sMessage
79980>>>    Append sMessage sFolderName
79981>>>    Append sMessage "' does not yet exist,\n"
79982>>>    Append sMessage "Do you want to create it now?"
79983>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
79984>>>    Case Begin
79984>>>      Case (iUsers_Choice = MBR_Yes)
79986>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
79987>>>        If bIsNotValid Begin
79989>>>          Move "An error occurred while trying to create folder '" To sMessage
79990>>>          Append sMessage sFolderName "'.\n\n"
79992>>>          Send Info_Box sMessage "Info"
79993>>>          End
79993>>>>
79993>>>        Case Break
79994>>>      Case (iUsers_Choice = MBR_No)
79997>>>        Move dfTrue To bIsNotValid // Cancel the save
79998>>>        Case Break
79999>>>    Case End
79999>>>  End
79999>>>>
79999>>>  Function_Return bIsNotValid
80000>>>End_Function // vVerifyNewFolder
80001>>>
80001>>>
80001>>>// This will perform an operation on a file (e.g. open) with the application
80001>>>// registered in the Windows Registry to open that type of file (via its extension)
80001>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
80001>>>Procedure vShellExecute global String sOperation String sDocument String sParameters String sPath
80003>>>  Handle  hInstance hWnd
80003>>>  Pointer lpsOperation
80003>>>  Pointer lpsDocument
80003>>>  Pointer lpsParameters
80003>>>  Pointer lpsPath
80003>>>  // remove any leading/trailing spaces in the string
80003>>>  Move (Trim(sDocument)) To sDocument
80004>>>  Move (Trim(sPath))     To sPath
80005>>>  // Make the strings readable for windows API, by converting them to null-terminated
80005>>>  Append sOperation   (Character(0))
80006>>>  Append sDocument    (Character(0))
80007>>>  Append sParameters  (Character(0))
80008>>>  Append sPath        (Character(0))
80009>>>  // Connect the corresponding pointers to the strings
80009>>>  GetAddress Of sOperation  To lpsOperation
80010>>>  GetAddress Of sDocument   To lpsDocument
80011>>>  GetAddress Of sParameters To lpsParameters
80012>>>  GetAddress Of sPath       To lpsPath
80013>>>
80013>>>  Get Window_Handle To hWnd
80014>>>  Move (vWin32_ShellExecute (hWnd, lpsOperation, lpsDocument, lpsParameters, lpsPath, 1)) To hInstance
80015>>>  If (hInstance <= 32) Begin
80017>>>    Send vDDE_Error_Handler hInstance
80018>>>  End
80018>>>>
80018>>>End_Procedure // vShellExecute
80019>>>
80019>>>
80019>>>Class cShellFileOperations Is a Array
80020>>>
80020>>>  Procedure Construct_Object
80022>>>    Forward Send Construct_Object
80024>>>    Property Integer piDeleteFlags        Public 0
80025>>>    Property Integer piCopyFlags          Public 0
80026>>>    Property Integer piMoveFlags          Public 0
80027>>>    Property Integer piRenameFlags        Public 0
80028>>>
80028>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80029>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
80030>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
80031>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80032>>>  End_Procedure // Construct_Object
80033>>>
80033>>>
80033>>>  // This function uses the shell API to perform a file operation on the
80033>>>  // files supplied.
80033>>>  //
80033>>>  Function FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
80035>>>    String   sShFileOp
80035>>>    Pointer  lpShFileOp
80035>>>    Pointer  lpsSource
80035>>>    Pointer  lpsDestination
80035>>>    Integer  iRetVal
80035>>>    Integer  bUserAbort
80035>>>
80035>>>    ZeroType vtShFileOpStruct To sShFileOp
80036>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
80037>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
80038>>>    GetAddress Of sSource    To lpsSource
80039>>>    If iOperation Ne vFO_DELETE Begin
80041>>>      GetAddress Of sDestination      To lpsDestination
80042>>>      Put lpsDestination To sShFileOp At vtShFileOpStruct.pTo
80043>>>    End
80043>>>>
80043>>>
80043>>>    Put iOperation     To sShFileOp At vtShFileOpStruct.wFunc
80044>>>    Put lpsSource      To sShFileOp At vtShFileOpStruct.pFrom
80045>>>    Put iFlags         To sShFileOp At vtShFileOpStruct.fFlags
80046>>>
80046>>>    GetAddress Of sShFileOp To lpShFileOp
80047>>>
80047>>>    Move (vWin32_SHFileOperation(lpShFileOp)) To iRetVal
80048>>>    GetBuff From sShFileOp At vtShFileOpStruct.fAnyOperationsAborted To bUserAbort
80049>>>    If (bUserAbort <> 0) Begin
80051>>>      Move 80 To iRetVal  // file Operation Aborted by USER
80052>>>    End
80052>>>>
80052>>>    Function_Return (iRetVal)
80053>>>  End_Function // FileOperation
80054>>>
80054>>>
80054>>>  Function sfoDeleteFile String sFileName Returns Integer
80056>>>    Integer  iRetVal
80056>>>    Integer  iFlags
80056>>>
80056>>>    Get piDeleteFlags To iFlags
80057>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
80058>>>    Function_Return iRetVal
80059>>>  End_Function // sfoDeleteFile
80060>>>
80060>>>
80060>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
80062>>>    Integer  iRetVal
80062>>>    Integer  iFlags
80062>>>
80062>>>    Get piCopyFlags To iFlags
80063>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
80064>>>    Function_Return iRetVal
80065>>>  End_Function // sfoCopyFile
80066>>>
80066>>>
80066>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
80068>>>    Integer  iRetVal
80068>>>    Integer  iFlags
80068>>>
80068>>>    Get piMoveFlags To iFlags
80069>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
80070>>>    Function_Return iRetVal
80071>>>  End_Function // sfoMoveFile
80072>>>
80072>>>
80072>>>  // Rename a file or folder
80072>>>  // Returns a nonzero value if the operation failed.
80072>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
80074>>>    Integer  iRetVal
80074>>>    Integer  iFlags
80074>>>
80074>>>    Get piRenameFlags To iFlags
80075>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
80076>>>    Function_Return iRetVal
80077>>>  End_Function // sfoRenameFile
80078>>>
80078>>>  // Courtesy Of Steve Walter
80078>>>  // Requires Windows 2000 and up according to msdn but it was
80078>>>  //  in fact available before that as an unpublished API call
80078>>>  //  a little google search shows that this was already available
80078>>>  //  in windows 95 and NT
80078>>>  //
80078>>>  // The format is controlled by the dialog interface.
80078>>>  // That is, the user must click the OK button To actually Begin the format
80078>>>  // the format cannot be started programmatically.
80078>>>  // An alternative to this functionality would be to use a controlpanel
80078>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
80078>>>  //
80078>>>  // hWnd = The windows handle of the object from which the format Function
80078>>>  //        is called.
80078>>>  // To Get this,
80078>>>  //          use:  Get Window_Handle Of <object>
80078>>>  //          For instance, in this app, we're going to use the Report_Panel:
80078>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
80078>>>  //
80078>>>  // sDrive = The drive letter. At this moment only A and B are valid
80078>>>  //
80078>>>  // iOptions = Format options.
80078>>>  //  SHFMT_OPT_DEFAULT = Quick format
80078>>>  //  SHFMT_OPT_FULL    = Full Format
80078>>>  //  SHFMT_OPT_SYSONLY = System only
80078>>>  //  3                 = Full format with system. (unsupported)
80078>>>  //
80078>>>  // Return Values:
80078>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
80078>>>  //  SHFMT_CANCEL   = Format cancelled by user.
80078>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
80078>>>  //
80078>>>  //
80078>>>  // *** ATTENTION: This function has been disabled as it doesn't
80078>>>  //                seem to work, i must have made a silly mistake
80078>>>  //                somewhere.
80078>>>  //
80078>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
80080>>>    Handle   hWnd
80080>>>    Integer  iObj
80080>>>    DWORD    dwReturnVal
80080>>>    Integer iDrive
80080>>>
80080>>>    Function_Return (1) // STOP HERE
80081>>>
80081>>>    Move (Trim(sDrive)) To sDrive
80082>>>    If ( sDrive <> '' ) Begin
80084>>>      If ( sDrive Contains ':' ) Move (Replace(':',sDrive,'')) To sDrive
80087>>>      If (Not( 'AB' Contains sDrive )) Function_Return (SHFMT_NOFORMAT)
80090>>>      If ( sDrive = 'A' ) Move 0 To iDrive
80093>>>      Else If ( sDrive = 'B' ) Move 1 To iDrive
80097>>>      // Window_Handle Of Desktop equals to 0
80097>>>
80097>>>      Get focus Of desktop To iObj
80098>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
80101>>>      While (hWnd=0 And iObj<>Desktop)
80105>>>          Get Parent Of iObj To iObj
80106>>>          Get Container_Handle Of iObj To hWnd
80107>>>      End
80108>>>>
80108>>>
80108>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
80108>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
80109>>>    End
80109>>>>
80109>>>    Else Begin
80110>>>      Move (SHFMT_ERROR) To dwReturnVal
80111>>>    End
80111>>>>
80111>>>    Function_Return dwReturnVal
80112>>>  End_Function // sfoFormatDisk
80113>>>
80113>>>  //Example:
80113>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
80113>>>  //                                          mode.
80113>>>
80113>>>End_Class // cShellFileOperations
80114>>>
80114>>>
80114>>>Object oShellFileOperations Is a cShellFileOperations
80116>>>End_Object // oShellFileOperations
80117>>>
80117>>>
80117>>>// Restore to the old way of working with the shell file operations.
80117>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
80117>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
80117>>>Procedure vWin32fhCompatibilityMode
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80119>>>  Integer hoSFO
80119>>>  Integer iFlags
80119>>>
80119>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
80120>>>  Move (oShellFileOperations(Self)) To hoSFO
80121>>>
80121>>>  Set piDeleteFlags Of hoSFO To iFlags
80122>>>  Set piCopyFlags   Of hoSFO To iFlags
80123>>>  Set piMoveFlags   Of hoSFO To iFlags
80124>>>  Set piRenameFlags Of hoSFO To iFlags
80125>>>End_Procedure // vWin32fhCompatibilityMode
80126>>>
80126>>>
80126>>>Function vDeleteFile Global String sFileName Returns Integer
80128>>>  Integer  iRetVal
80128>>>
80128>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
80129>>>  Function_Return iRetVal
80130>>>End_Function // vDeleteFile
80131>>>
80131>>>
80131>>>Function vCopyFile Global String sSource String sDestination Returns Integer
80133>>>  Integer  iRetVal
80133>>>
80133>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80134>>>  Function_Return iRetVal
80135>>>End_Function // vCopyFile
80136>>>
80136>>>
80136>>>Function vMoveFile Global String sSource String sDestination Returns Integer
80138>>>  Integer  iRetVal
80138>>>
80138>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80139>>>  Function_Return iRetVal
80140>>>End_Function // vMoveFile
80141>>>
80141>>>
80141>>>// Rename a file or folder
80141>>>// Returns a nonzero value if the operation failed.
80141>>>Function vRenameFile Global String sSource String sDestination Returns Integer
80143>>>  Integer  iRetVal
80143>>>
80143>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80144>>>  Function_Return iRetVal
80145>>>End_Function // vRenameFile
80146>>>
80146>>>
80146>>>
80146>>>Function vGetWindowsDirectory Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80148>>>  String  sDirectory
80148>>>  Pointer lpDirectory
80148>>>  Integer iVoid
80148>>>
80148>>>  ZeroString vMAX_PATH To sDirectory
80149>>>  GetAddress Of sDirectory To lpDirectory
80150>>>
80150>>>  Move (vWin32_GetWindowsDirectory(lpDirectory, vMAX_PATH)) To iVoid
80151>>>  Function_Return (CString(sDirectory))  // **WvA: Changed to CString()
80152>>>End_Function // vGetWindowsDirectory
80153>>>
80153>>>
80153>>>
80153>>>
80153>>>// Courtesy of Marco Kuipers
80153>>>Function vMakeTempFile Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80155>>>    Integer iRetval
80155>>>    String  sTempPath sTempFileName sPrefixString
80155>>>    Pointer lpTempPath lpTempFileName lpPrefixString
80155>>>
80155>>>    Move (Repeat (Character (0), 255)) To sTempPath
80156>>>    GetAddress Of sTempPath To lpTempPath
80157>>>    Move (vWin32_GetTempPath (255, lpTempPath)) To iRetVal
80158>>>
80158>>>    If (sTempPath = "") Begin
80160>>>       Get_Current_Directory To sTempPath
80161>>>    End
80161>>>>
80161>>>    Move (pad(sTempPath,vMax_Path-14)) To sTempPath // *WvA: 28-04-2005 Quote from msdn: The string cannot be longer than MAX_PATH-14 characters.
80162>>>    Move (Repeat (Character (0), 255)) To sTempFileName
80163>>>    GetAddress Of sTempFileName To lpTempFileName
80164>>>    Move ("tmp"+character(0)) To sPrefixString // **WvA: 28-04-2005 Added a null
80165>>>    GetAddress Of sPrefixString To lpPrefixString
80166>>>    GetAddress Of sTempPath To lpTempPath
80167>>>    Move (vWin32_GetTempFileName (lpTempPath, lpPrefixString, 0, lpTempFileName)) To iRetval
80168>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
80170>>>        Move "" To sTempFileName
80171>>>    End
80171>>>>
80171>>>
80171>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
80172>>>End_Function // vMakeTempFile
80173>>>
80173>>>
80173>>>// This function creates a uniquely named temporary file in folder sPath
80173>>>// The file created will have a prefix based on the first 3 characters in sPrefix
80173>>>// Note that you will have to cleanup the tempfile yourself as the function
80173>>>// does not take care of that.
80173>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80175>>>    String sTempFileName
80175>>>    Integer iCnt iRetVal
80175>>>    Pointer lpTempFileName
80175>>>    Pointer lpPath
80175>>>    Pointer lpPrefix
80175>>>
80175>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
80176>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
80177>>>    Move (pad("", vMAX_PATH)) To sTempFileName
80178>>>    GetAddress Of sTempFileName To lpTempFileName
80179>>>    GetAddress Of sPath         To lpPath
80180>>>    GetAddress Of sPrefix       To lpPrefix
80181>>>
80181>>>    Move (vWin32_GetTempFileName(lpPath, lpPrefix, 0, lpTempFileName)) To iRetVal
80182>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
80183>>>    Function_Return sTempFileName
80184>>>End_Function // vCreateTempFileInPath
80185>>>
80185>>>//
80185>>>// Get a specific shell folder for example to get the desktop folder
80185>>>// simply call this function and pass it vCSIDL_DESKTOP
80185>>>//
80185>>>Function vSHGetFolderPath Integer eFolder Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80187>>>  String  sFolder
80187>>>  Integer iVoid
80187>>>  Pointer lpsFolder
80187>>>  Handle  hWnd
80187>>>  Move (Window_Handle(focus(desktop))) To hWnd
80188>>>
80188>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
80189>>>  GetAddress Of sFolder To lpsFolder
80190>>>
80190>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,lpsFolder)) To iVoid
80191>>>  Function_Return (CString(sFolder))
80192>>>End_Function // vSHGetFolderPath
80193>>>
80193>>>
80193>>>
80193>>>// Courtesy Of Vincent Oorsprong
80193>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
80195>>>  String  sftTime sSystemTime sFormattedTime sFormattedDate
80195>>>  Pointer lpsftTime lpsSystemTime lpsFormattedTime lpsFormattedDate
80195>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
80195>>>
80195>>>  ZeroType vFileTime  To sftTime
80196>>>  Put dwLowDateTime  To sftTime At vFileTime.dwLowDateTime
80197>>>  Put dwHighDateTime To sftTime At vFileTime.dwHighDateTime
80198>>>  GetAddress Of sftTime To lpsftTime
80199>>>
80199>>>  ZeroType vSystemTime To sSystemTime
80200>>>  GetAddress Of sSystemTime To lpsSystemTime
80201>>>
80201>>>  Moveint (vWin32_FileTimeToSystemTime (lpsftTime, lpsSystemTime)) To iSuccess
80202>>>>
80202>>>  If iSuccess Eq DfTrue Begin
80204>>>    ZeroString 255 To sFormattedTime
80205>>>    GetAddress Of sFormattedTime To lpsFormattedTime
80206>>>    Length sFormattedTime To iLenCcTime
80207>>>>
80207>>>    Moveint (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedTime, iLenCcTime)) To iDataLength
80208>>>>
80208>>>    ZeroString 255 To sFormattedDate
80209>>>    GetAddress Of sFormattedDate To lpsFormattedDate
80210>>>    Length sFormattedDate To iLenCcDate
80211>>>>
80211>>>    Moveint (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedDate, iLenCcDate)) To iDataLength
80212>>>>
80212>>>    Function_Return (Cstring (sFormattedDate)  * Cstring (sFormattedTime))
80213>>>  End // iSuccess
80213>>>>
80213>>>End_Function // vConvertFileDateTime
80214>>>
80214>>>
80214>>>// **WvA Removed, See the cFileSet class for an alternative
80214>>>//Procedure DoBrowseDir String sFilePath
80214>>>//End_Procedure // DoBrowseDir
80214>>>
80214>>>// **WvA:
80214>>>// A windows replacement for the standard function FileExists.
80214>>>// This version will also return (true) for a file when it is open by an application.
80214>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
80214>>>// Example: Get vFilePathExists "C:\config.sy?"
80214>>>// This will return true if you have a file matching these conditions. (aka config.sys)
80214>>>Function vFilePathExists Global String sFilePathMask Returns Integer
80216>>>  String  sWin32FindData
80216>>>  String  sDirSep
80216>>>  Pointer lpsFilePathMask lpsWin32FindData
80216>>>  Handle  hFindFile
80216>>>  Integer iVoid
80216>>>
80216>>>  Move vINVALID_HANDLE_VALUE To hFindFile
80217>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
80218>>>
80218>>>  If (length(sFilePathMask)>0) Begin
80220>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
80220>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80221>>>    While (Right(sFilePathMask, 1) = sDirSep)
80225>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
80226>>>    Loop
80227>>>>
80227>>>
80227>>>    GetAddress Of sFilePathMask To lpsFilePathMask
80228>>>    ZeroType vWin32_Find_Data To sWin32FindData
80229>>>    GetAddress Of sWin32FindData To lpswin32FindData
80230>>>    Move (vWin32_FindFirstFile (lpsFilePathMask, lpsWin32FindData)) To hFindFile
80231>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
80232>>>  End
80232>>>>
80232>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
80233>>>End_Function // vFilePathExists
80234>>>
80234>>>
80234>>>// **WvA
80234>>>// Formats a foldername by first trimming it and after that by sticking a
80234>>>// directory separator (/\) to the end if it doesn't have one there already.
80234>>>// The folder may contain a drive letter or UNC encoding.
80234>>>Function vFolderFormat Global String sFolderName Returns String
80236>>>  String sDirSep
80236>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
80237>>>  Move (Trim(sFolderName)) To sFolderName
80238>>>  If (Right(sFolderName,1)<>sDirSep) Begin
80240>>>    Move (sFolderName+sDirSep) To sFolderName
80241>>>  End
80241>>>>
80241>>>  Function_Return sFolderName
80242>>>End_Function // vFolderFormat
80243>>>//
80243>>>// Returns the amount of files in the folder (if it exists)
80243>>>// Returns -1 if folder doesn't exist.
80243>>>// The files "." and ".." are not counted.
80243>>>//
80243>>>Function vFolderFileCount Global String sFolderName Returns Integer
80245>>>  Boolean bFound
80245>>>  Handle  hFindFile
80245>>>  Integer iCount  iVoid
80245>>>  Integer iSuccess
80245>>>  Pointer lpsFolderName lpsWin32FindData
80245>>>  String  sWin32FindData
80245>>>  String  sFileName
80245>>>
80245>>>  Move -1 To iCount
80246>>>  Get vFolderFormat sFolderName To sFolderName
80247>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
80248>>>  GetAddress Of sFolderName To lpsFolderName
80249>>>  ZeroType vWin32_Find_Data To sWin32FindData
80250>>>  GetAddress Of sWin32FindData To lpswin32FindData
80251>>>  Move (vWin32_FindFirstFile (lpsFolderName, lpsWin32FindData)) To hFindFile
80252>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
80253>>>  If (bFound) Move 0 To iCount
80256>>>  While (bFound)
80260>>>    Increment iCount
80261>>>    GetBuff_String From sWin32FindData At vWin32_Find_Data.cFileName To sFileName
80262>>>    If (sFileName="." or sFileName="..") Decrement iCount
80265>>>    Move (vWin32_FindNextFile(hFindFile, lpsWin32FindData)) To iSuccess
80266>>>    Move (iSuccess<>0) To bFound
80267>>>  Loop
80268>>>>
80268>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
80269>>>  Function_Return iCount
80270>>>End_Function // vFolderFileCount
80271>>>
80271>>>
80271>>>//
80271>>>// Gets the parent path of the currently supplied path
80271>>>// Returns "" when we are at the root folder.
80271>>>//
80271>>>Function vParentPath Global String sPath Returns String
80273>>>  String sStrip
80273>>>  Integer iLength
80273>>>  
80273>>>  If (Right(sPath,1)="\") Begin
80275>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
80276>>>  End
80276>>>>
80276>>>  If (Pos("\",sPath)) Begin
80278>>>    Move (StringFromRightOfChar(sPath,"\")) to sStrip
80279>>>    Move (Length(sStrip)) to iLength
80280>>>    Move (Left(sPath, (Length(sPath) - iLength -1))) to sPath
80281>>>//    Move (Replace(sStrip,sPath,"")) To sPath
80281>>>  End
80281>>>>
80281>>>  Else Begin
80282>>>    Move "" To sPath
80283>>>  End
80283>>>>
80283>>>  Function_Return sPath
80284>>>End_Function // vParentPath
80285>>>
80285>>>// Create the folder, including intermediate directories.
80285>>>// Don't panic if the folder already exists.
80285>>>// Michael Mullan June 2009.
80285>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
80287>>>  String  sFolder sSA
80287>>>  Pointer lpsFolder lpsSecurity_Attributes
80287>>>  Integer iRetval bFolderCreated bInheritHandle
80287>>>  Move (False) to bFolderCreated
80288>>>  // fill string variable with null characters
80288>>>  ZeroType vtSecurity_attributes to sSA
80289>>>  // null MAX_PATH chars into var (make space)
80289>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
80290>>>  If (sNewFolder <> "") Begin
80292>>>    Move dfTrue to  bInheritHandle
80293>>>    // Setting this to NULL is already done by the zerotype command
80293>>>    // Move NULL   To  lpDescriptor
80293>>>    Put (length(sSA))   to sSA At vtSecurity_attributes.nLength
80294>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
80294>>>    Put bInheritHandle to sSA At vtSecurity_attributes.bInheritHandle
80295>>>    GetAddress of sSA to lpsSecurity_Attributes
80296>>>    //
80296>>>    Move sNewFolder to sFolder
80297>>>    GetAddress of sFolder to lpsFolder
80298>>>    Move (vWin32_SHCreateDirectoryEx(0,lpsFolder, lpsSecurity_Attributes)) to bFolderCreated
80299>>>  End
80299>>>>
80299>>>
80299>>>  If (bFolderCreated <> 0) Begin
80301>>>    Move 1 to iRetVal
80302>>>
80302>>>    If (bFolderCreated = 161 ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
80305>>>    Else If (bFolderCreated = 206 ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
80309>>>    Else If (bFolderCreated = 3   ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
80313>>>    Else If (bFolderCreated = 80  ) Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
80317>>>    Else If (bFolderCreated = 183 ) Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
80321>>>    Else If (bFolderCreated = 1223) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
80325>>>    Else Error DFERR_OPERATOR ("Folder Creation Error # " + String(bfoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
80327>>>  End
80327>>>>
80327>>>  Function_Return iRetVal
80328>>>End_Function // vshCreateDirectoryEX
80329>>>
80329>>>
80329>>>Function vWin32_APIFileSize Global string sFileName returns integer
80331>>>     dWord dwFileSizeHigh dwFileSizeLow
80331>>>     integer iFileSize iVoid
80331>>>     handle hFindFile
80331>>>     pointer lpsFilePath lpsWin32FindData
80331>>>     string sWin32FindData
80331>>>
80331>>>     GetAddress of sFileName to lpsFilePath
80332>>>
80332>>>     ZeroType vWin32_Find_Data to sWin32FindData
80333>>>     GetAddress of sWin32FindData to lpsWin32FindData
80334>>>
80334>>>     move (vWin32_FindFirstFile (lpsFilePath, lpsWin32FindData)) to hFindFile
80335>>>     if (hFindFile<>vINVALID_HANDLE_VALUE) begin
80337>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeHigh To dwFileSizeHigh
80338>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeLow To dwFileSizeLow
80339>>>     end
80339>>>>
80339>>>     move (vWin32_FindClose (hFindFile)) to iVoid
80340>>>
80340>>>     moveInt ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
80341>>>>
80341>>>
80341>>>     function_return iFileSize
80342>>>End_Function  // vWin32_APIFileSize
80343>>>
80343>>>
80343>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJSkinFramework.pkg)
80343>>>Use windows.pkg
80343>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJComSkinFramework.pkg)
80343>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v17.3.0\Bin\Codejock.SkinFramework.v17.3.0.ocx
80343>>>>>Use FlexCom20.pkg
80343>>>>>
80343>>>>>// Changes to Imported package
80343>>>>>//     OLEXTPxx to XTPxx
80343>>>>>//     OLExtpxx to xtpxx
80343>>>>>//     OLESkinFramework to SkinFramework
80343>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
80343>>>>>//     cCom classes to cCJ
80343>>>>>//     cCJAutomationObject back to cComAutomationObject
80343>>>>>//     cCJActiveXControl back to cComActiveXControl
80343>>>>>//     cCJSkinFramework to cCJComSkinFramework
80343>>>>>//     Use statements as noted below (classes moved to these files)
80343>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
80343>>>>>
80343>>>>>// These have been extracted from this class and moved into seperate packages
80343>>>>>// because other Codejock classes use these.
80343>>>>>Use cCJColorManager.pkg     // cCJColorManager
80343>>>>>
80343>>>>>Define SkinFrameworkApplyOptions for Integer
80343>>>>>    Define xtpSkinApplyMetrics for 1
80343>>>>>    Define xtpSkinApplyFrame for 2
80343>>>>>    Define xtpSkinApplyColors for 4
80343>>>>>    Define xtpSkinApplyMenus for 8
80343>>>>>
80343>>>>>// CLSID: {AFA0E6A1-28D7-4F2C-87A7-7266367B4655}
80343>>>>>// Dispatch interface for SkinFramework Control
80343>>>>>Class cCJ_DSkinFramework is a Mixin
80344>>>>>
80344>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
80346>>>>>        SkinFrameworkApplyOptions retVal
80346>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
80347>>>>>        Function_Return retVal
80348>>>>>    End_Function
80349>>>>>
80349>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
80351>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
80352>>>>>    End_Procedure
80353>>>>>
80353>>>>>    Function ComAutoApplyNewWindows Returns Boolean
80355>>>>>        Boolean retVal
80355>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
80356>>>>>        Function_Return retVal
80357>>>>>    End_Function
80358>>>>>
80358>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
80360>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
80361>>>>>    End_Procedure
80362>>>>>
80362>>>>>    Function ComAutoApplyNewThreads Returns Boolean
80364>>>>>        Boolean retVal
80364>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
80365>>>>>        Function_Return retVal
80366>>>>>    End_Function
80367>>>>>
80367>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
80369>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
80370>>>>>    End_Procedure
80371>>>>>
80371>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
80373>>>>>        Handle hDispatchDriver
80373>>>>>        Boolean retVal
80373>>>>>        Get phDispatchDriver to hDispatchDriver
80374>>>>>        Send PrepareParams to hDispatchDriver 2
80375>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
80376>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
80377>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
80378>>>>>        Function_Return retVal
80379>>>>>    End_Function
80380>>>>>
80380>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
80382>>>>>        Handle hDispatchDriver
80382>>>>>        Get phDispatchDriver to hDispatchDriver
80383>>>>>        Send PrepareParams to hDispatchDriver 1
80384>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80385>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
80386>>>>>    End_Procedure
80387>>>>>
80387>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
80389>>>>>        Handle hDispatchDriver
80389>>>>>        Get phDispatchDriver to hDispatchDriver
80390>>>>>        Send PrepareParams to hDispatchDriver 2
80391>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80392>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
80393>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
80394>>>>>    End_Procedure
80395>>>>>
80395>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
80397>>>>>        Handle hDispatchDriver
80397>>>>>        Get phDispatchDriver to hDispatchDriver
80398>>>>>        Send PrepareParams to hDispatchDriver 1
80399>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80400>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
80401>>>>>    End_Procedure
80402>>>>>
80402>>>>>    Procedure ComRemoveAllWindows
80404>>>>>        Handle hDispatchDriver
80404>>>>>        Get phDispatchDriver to hDispatchDriver
80405>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
80406>>>>>    End_Procedure
80407>>>>>
80407>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
80409>>>>>        Handle hDispatchDriver
80409>>>>>        Get phDispatchDriver to hDispatchDriver
80410>>>>>        Send PrepareParams to hDispatchDriver 2
80411>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
80412>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
80413>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
80414>>>>>    End_Procedure
80415>>>>>
80415>>>>>    Procedure ComRemoveWindowClass String llClassName
80417>>>>>        Handle hDispatchDriver
80417>>>>>        Get phDispatchDriver to hDispatchDriver
80418>>>>>        Send PrepareParams to hDispatchDriver 1
80419>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
80420>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
80421>>>>>    End_Procedure
80422>>>>>
80422>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
80424>>>>>        Handle hDispatchDriver
80424>>>>>        Variant retVal
80424>>>>>        Get phDispatchDriver to hDispatchDriver
80425>>>>>        Send PrepareParams to hDispatchDriver 2
80426>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
80427>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
80428>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
80429>>>>>        Function_Return retVal
80430>>>>>    End_Function
80431>>>>>
80431>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
80433>>>>>        Handle hDispatchDriver
80433>>>>>        Variant retVal
80433>>>>>        Get phDispatchDriver to hDispatchDriver
80434>>>>>        Send PrepareParams to hDispatchDriver 1
80435>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
80436>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
80437>>>>>        Function_Return retVal
80438>>>>>    End_Function
80439>>>>>
80439>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
80441>>>>>        Handle hDispatchDriver
80441>>>>>        OLE_COLOR retVal
80441>>>>>        Get phDispatchDriver to hDispatchDriver
80442>>>>>        Send PrepareParams to hDispatchDriver 1
80443>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80444>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
80445>>>>>        Function_Return retVal
80446>>>>>    End_Function
80447>>>>>
80447>>>>>    Procedure ComExcludeModule String llModuleName
80449>>>>>        Handle hDispatchDriver
80449>>>>>        Get phDispatchDriver to hDispatchDriver
80450>>>>>        Send PrepareParams to hDispatchDriver 1
80451>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
80452>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
80453>>>>>    End_Procedure
80454>>>>>
80454>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
80456>>>>>        Handle hDispatchDriver
80456>>>>>        Variant retVal
80456>>>>>        Get phDispatchDriver to hDispatchDriver
80457>>>>>        Send PrepareParams to hDispatchDriver 2
80458>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
80459>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
80460>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
80461>>>>>        Function_Return retVal
80462>>>>>    End_Function
80463>>>>>
80463>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
80465>>>>>        Handle hDispatchDriver
80465>>>>>        Get phDispatchDriver to hDispatchDriver
80466>>>>>        Send PrepareParams to hDispatchDriver 2
80467>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80468>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
80469>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
80470>>>>>    End_Procedure
80471>>>>>
80471>>>>>    Procedure ComAboutBox
80473>>>>>        Handle hDispatchDriver
80473>>>>>        Get phDispatchDriver to hDispatchDriver
80474>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
80475>>>>>    End_Procedure
80476>>>>>End_Class
80477>>>>>
80477>>>>>// CLSID: {40217CB8-4463-4030-B324-AC6A8075FEC8}
80477>>>>>// Event interface for SkinFramework Control
80477>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
80478>>>>>
80478>>>>>    Procedure RegisterComEvents
80480>>>>>    End_Procedure
80481>>>>>End_Class
80482>>>>>
80482>>>>>// CoClass
80482>>>>>// ProgID: Codejock.SkinFramework.17.3.0
80482>>>>>// CLSID: {DE67160B-9A3E-4EA6-846E-8C9A72F9F203}
80482>>>>>// SkinFramework Control
80482>>>>>Class cCJComSkinFramework is a cComActiveXControl
80483>>>>>    Import_Class_Protocol cCJ_DSkinFramework
80484>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
80485>>>>>
80485>>>>>    Procedure Construct_Object
80487>>>>>        Forward Send Construct_Object
80489>>>>>        Set psProgID to "{DE67160B-9A3E-4EA6-846E-8C9A72F9F203}"
80490>>>>>        Set psEventId to "{40217CB8-4463-4030-B324-AC6A8075FEC8}"
80491>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2016 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v17.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
80492>>>>>        Set peAutoCreate to acAutoCreate
80493>>>>>    End_Procedure
80494>>>>>End_Class
80495>>>>>
80495>>>>>// CLSID: {06E8A85B-70E4-4F71-A0FC-D1D5658C7E17}
80495>>>>>// SkinFramework Global Settings
80495>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
80496>>>>>
80496>>>>>    Function ComLicense Returns String
80498>>>>>        String retVal
80498>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
80499>>>>>        Function_Return retVal
80500>>>>>    End_Function
80501>>>>>
80501>>>>>    Procedure Set ComLicense String value
80503>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
80504>>>>>    End_Procedure
80505>>>>>
80505>>>>>    Function ComTitle Returns String
80507>>>>>        String retVal
80507>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
80508>>>>>        Function_Return retVal
80509>>>>>    End_Function
80510>>>>>
80510>>>>>    Procedure Set ComTitle String value
80512>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
80513>>>>>    End_Procedure
80514>>>>>
80514>>>>>    Function ComVersion Returns String
80516>>>>>        Handle hDispatchDriver
80516>>>>>        String retVal
80516>>>>>        Get phDispatchDriver to hDispatchDriver
80517>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
80518>>>>>        Function_Return retVal
80519>>>>>    End_Function
80520>>>>>
80520>>>>>    Function ComUnicode Returns Boolean
80522>>>>>        Handle hDispatchDriver
80522>>>>>        Boolean retVal
80522>>>>>        Get phDispatchDriver to hDispatchDriver
80523>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
80524>>>>>        Function_Return retVal
80525>>>>>    End_Function
80526>>>>>
80526>>>>>    Function ComOcxPath Returns String
80528>>>>>        Handle hDispatchDriver
80528>>>>>        String retVal
80528>>>>>        Get phDispatchDriver to hDispatchDriver
80529>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
80530>>>>>        Function_Return retVal
80531>>>>>    End_Function
80532>>>>>End_Class
80533>>>>>
80533>>>>>// CoClass
80533>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.17.3.0
80533>>>>>// CLSID: {C4136A4A-67FD-4FC1-BA62-A715B4D60808}
80533>>>>>// SkinFramework Global Settings
80533>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
80534>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
80535>>>>>
80535>>>>>    Procedure Construct_Object
80537>>>>>        Forward Send Construct_Object
80539>>>>>        Set psProgID to "{C4136A4A-67FD-4FC1-BA62-A715B4D60808}"
80540>>>>>        Set peAutoCreate to acNoAutoCreate
80541>>>>>    End_Procedure
80542>>>>>End_Class
80543>>>>>
80543>>>>>// CLSID: {27E4AC9B-4A2D-4FBB-A782-BD76BEFA4345}
80543>>>>>Class cCJSkinIniFile is a cComAutomationObject
80544>>>>>
80544>>>>>    Function ComColorScheme Returns String
80546>>>>>        String retVal
80546>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80547>>>>>        Function_Return retVal
80548>>>>>    End_Function
80549>>>>>
80549>>>>>    Procedure Set ComColorScheme String value
80551>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80552>>>>>    End_Procedure
80553>>>>>
80553>>>>>    Function ComFontSize Returns String
80555>>>>>        String retVal
80555>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80556>>>>>        Function_Return retVal
80557>>>>>    End_Function
80558>>>>>
80558>>>>>    Procedure Set ComFontSize String value
80560>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80561>>>>>    End_Procedure
80562>>>>>
80562>>>>>    Function ComIniFileName Returns String
80564>>>>>        String retVal
80564>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
80565>>>>>        Function_Return retVal
80566>>>>>    End_Function
80567>>>>>
80567>>>>>    Procedure Set ComIniFileName String value
80569>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
80570>>>>>    End_Procedure
80571>>>>>End_Class
80572>>>>>
80572>>>>>// CLSID: {5005F22B-A30E-4B12-B142-E97F62A927A6}
80572>>>>>Class cCJSkinDescription is a cComAutomationObject
80573>>>>>
80573>>>>>    Function ComName Returns String
80575>>>>>        String retVal
80575>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80576>>>>>        Function_Return retVal
80577>>>>>    End_Function
80578>>>>>
80578>>>>>    Procedure Set ComName String value
80580>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80581>>>>>    End_Procedure
80582>>>>>
80582>>>>>    Function ComPath Returns String
80584>>>>>        String retVal
80584>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80585>>>>>        Function_Return retVal
80586>>>>>    End_Function
80587>>>>>
80587>>>>>    Procedure Set ComPath String value
80589>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80590>>>>>    End_Procedure
80591>>>>>
80591>>>>>    Function ComCount Returns Integer
80593>>>>>        Handle hDispatchDriver
80593>>>>>        Integer retVal
80593>>>>>        Get phDispatchDriver to hDispatchDriver
80594>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80595>>>>>        Function_Return retVal
80596>>>>>    End_Function
80597>>>>>
80597>>>>>    Function ComIniFile Integer llIndex Returns Variant
80599>>>>>        Handle hDispatchDriver
80599>>>>>        Variant retVal
80599>>>>>        Get phDispatchDriver to hDispatchDriver
80600>>>>>        Send PrepareParams to hDispatchDriver 1
80601>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80602>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80603>>>>>        Function_Return retVal
80604>>>>>    End_Function
80605>>>>>
80605>>>>>    Function Com_NewEnum Returns Variant
80607>>>>>        Handle hDispatchDriver
80607>>>>>        Variant retVal
80607>>>>>        Get phDispatchDriver to hDispatchDriver
80608>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80609>>>>>        Function_Return retVal
80610>>>>>    End_Function
80611>>>>>End_Class
80612>>>>>
80612>>>>>// CLSID: {C4367A33-2A7C-4CC6-BF0C-C50383B34B51}
80612>>>>>Class cCJSkinDescriptions is a cComAutomationObject
80613>>>>>
80613>>>>>    Function ComCount Returns Integer
80615>>>>>        Handle hDispatchDriver
80615>>>>>        Integer retVal
80615>>>>>        Get phDispatchDriver to hDispatchDriver
80616>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80617>>>>>        Function_Return retVal
80618>>>>>    End_Function
80619>>>>>
80619>>>>>    Function ComSkin Integer llIndex Returns Variant
80621>>>>>        Handle hDispatchDriver
80621>>>>>        Variant retVal
80621>>>>>        Get phDispatchDriver to hDispatchDriver
80622>>>>>        Send PrepareParams to hDispatchDriver 1
80623>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80624>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80625>>>>>        Function_Return retVal
80626>>>>>    End_Function
80627>>>>>
80627>>>>>    Function Com_NewEnum Returns Variant
80629>>>>>        Handle hDispatchDriver
80629>>>>>        Variant retVal
80629>>>>>        Get phDispatchDriver to hDispatchDriver
80630>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80631>>>>>        Function_Return retVal
80632>>>>>    End_Function
80633>>>>>End_Class
80634>>>>>
80634>>>>>// CLSID: {128507E0-C56F-43C0-BCF1-8193B35FE4C4}
80634>>>>>Class cCJSkinSchema is a cComAutomationObject
80635>>>>>End_Class
80636>>>Use cApplication.pkg
80636>>>
80636>>>Struct tSkinInformation
80636>>>    String sName     // description of the skin
80636>>>    String sSkinfile // file path. Can be relative or full
80636>>>    String sSkinIni  // section name
80636>>>End_Struct
80636>>>
80636>>>
80636>>>Class cCJSkinFramework is a cCJComSkinFramework
80637>>>    
80637>>>    Procedure Construct_Object
80639>>>        Forward Send Construct_Object
80641>>>        
80641>>>        Property String psSkinFile ""
80642>>>        Property String psSkinIni ""
80643>>>        Property Boolean pbLoadPreference False
80644>>>        
80644>>>        Set peAutoCreate to acAutoCreate
80645>>>        
80645>>>        Move Self to ghoSkinFramework
80646>>>    End_Procedure
80647>>>    
80647>>>    // return the default skin path, which is the programs directory.
80647>>>    // This requires an application object.
80647>>>    // If you want to different skin path, override this.
80647>>>    Function SkinPath Returns String
80649>>>        String sPath sPaths
80649>>>        Handle hoWorkspace
80649>>>        If ghoApplication Begin
80651>>>            Get phoWorkspace of ghoApplication to hoWorkspace
80652>>>            Get psProgramPath of hoWorkspace to sPaths
80653>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
80654>>>        End
80654>>>>
80654>>>        Else Begin
80655>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80656>>>>
80656>>>        End
80656>>>>
80656>>>        Function_Return sPath
80657>>>    End_Function
80658>>>    
80658>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
80658>>>    // returns itself. If it is not, it uses SkinPath to get the path.
80658>>>    Function SkinQFile Returns String
80660>>>        String sFile sPath sSep
80660>>>        Boolean bQualified
80660>>>        Get psSkinFile to sFile
80661>>>        If not (IsFileNameQualified(sFile)) Begin
80663>>>            Get SkinPath to sPath
80664>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80665>>>            Move (sPath - sSep - sFile) to sFile
80666>>>        End
80666>>>>
80666>>>        Function_Return sFile
80667>>>    End_Function
80668>>>        
80668>>>    // defines the default VDF window class mapping.    
80668>>>    Procedure OnAddVDFWindowClasses
80670>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
80671>>>        Send ComAddWindowClass "DFentry"                 "Edit"
80672>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
80673>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
80674>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
80675>>>        Send ComAddWindowClass "DFformlist"              "Edit"
80676>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
80677>>>        Send ComAddWindowClass "DFbutton"                "Button"
80678>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
80679>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
80680>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
80681>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient" 
80682>>>        Send ComAddWindowClass "DFedit"                  "edit"
80683>>>        Send ComAddWindowClass "DFlistedit"              "edit"
80684>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
80685>>>        Send ComAddWindowClass "DFgroup"                 "Button"
80686>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
80687>>>        // External class
80687>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
80688>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
80689>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
80690>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
80691>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
80692>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
80693>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
80694>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
80695>>>    End_Procedure
80696>>>    
80696>>>    // Used to support developer designed class mappings (e.g. COM controls)
80696>>>    Procedure OnAddCustomWindowClasses
80698>>>    End_Procedure
80699>>>
80699>>>    // called when object is created during end_construct_object.
80699>>>    Procedure OnCreate
80701>>>        Integer iOpts
80701>>>        Boolean bUseWindowsFont
80701>>>        Forward Send OnCreate
80703>>>        
80703>>>        // if we are using the windows fonts we will disable the apply metrics which
80703>>>        // never really looked good anyway. This test only exists or legacy purposes
80703>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
80704>>>        If bUseWindowsFont Begin
80706>>>            Get ComApplyOptions to iOpts
80707>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
80708>>>        End
80708>>>>
80708>>>
80708>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down. 
80708>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
80708>>>        // and this was the suggested workaround.
80708>>>        Set ComAutoApplyNewThreads to False
80709>>>
80709>>>        Send OnAddVDFWindowClasses
80710>>>        Send OnAddCustomWindowClasses
80711>>>        
80711>>>        // if preferences are used, it will set psSkinFile and psSkinIni
80711>>>        If (pbLoadPreference(Self)) Begin
80713>>>            Send LoadSkinPreference
80714>>>        End
80714>>>>
80714>>>        // if a skin file name exists, we apply the skin.    
80714>>>        If (psSkinFile(Self)<>"") Begin
80716>>>            Send ApplySkin
80717>>>        End        
80717>>>>
80717>>>    End_Procedure
80718>>>    
80718>>>    // called by framework as part of application exit.
80718>>>    Procedure Broadcast_Notify_Exit_Application
80720>>>        Send Notify_Exit_Application
80721>>>    End_Procedure // Notify_Exit_Application
80722>>>
80722>>>    Procedure Notify_Exit_Application
80724>>>        If (pbLoadPreference(Self)) Begin
80726>>>            Send SaveSkinPreference
80727>>>        End
80727>>>>
80727>>>    End_Procedure
80728>>>
80728>>>    Procedure NotifyPreApplySkin
80730>>>        Broadcast Send OnPreApplySkin of Desktop True       
80732>>>    End_Procedure
80733>>>
80733>>>    Procedure NotifyPostApplySkin
80735>>>        Broadcast Send OnPostApplySkin of Desktop True       
80737>>>    End_Procedure
80738>>>    
80738>>>    // returns an array of all skins in the path. If path is "", use the default path.
80738>>>    // If the default path is used, returns the file names as relative names, else use full path.
80738>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
80740>>>        tSkinInformation[] Skins
80740>>>        tSkinInformation[] Skins
80741>>>        String sSkinName sSkinFile sDefaultPath sSep
80741>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
80741>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
80741>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
80741>>>        Integer iPos iDfltLen
80741>>>        Boolean bUseRelativePath
80741>>>        
80741>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80742>>>        
80742>>>        Get SkinPath to sDefaultPath
80743>>>        If (sPath="") Begin
80745>>>            Move sDefaultPath to sPath
80746>>>        End
80746>>>>
80746>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
80747>>>        Move (Length(sDefaultPath)) to iDfltLen
80748>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
80749>>>
80749>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
80750>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
80752>>>
80752>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
80753>>>            Get Create U_cCJSkinDescription to hSkinDescription
80754>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
80755>>>            
80755>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
80756>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
80757>>>            
80757>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
80763>>>>
80763>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
80764>>>                Set pvComObject of hSkinDescription to vSkinDescription
80765>>>
80765>>>                Get ComCount of hSkinDescription to iNumSkins
80766>>>                    
80766>>>                For iSkinsCount from 0 to (iNumSkins-1)
80772>>>>
80772>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
80773>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
80774>>>
80774>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
80775>>>                    Get ComPath of hSkinDescription to sSkinFile
80776>>>                    If bUseRelativePath Begin
80778>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
80779>>>                        If iPos Begin
80781>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile   
80782>>>                            While (Left(sSkinFile,1)=sSep)
80786>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile   
80787>>>                            Loop                         
80788>>>>
80788>>>                        End
80788>>>>
80788>>>                    End
80788>>>>
80788>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
80789>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
80790>>>
80790>>>                    Increment iArrayItem
80791>>>                Loop
80792>>>>
80792>>>            Loop
80793>>>>
80793>>>                            
80793>>>            Send Destroy of hSkinDescriptions
80794>>>            Send Destroy of hSkinDescription
80795>>>            Send Destroy of hSkinIniFile
80796>>>                
80796>>>        End
80796>>>>
80796>>>        Function_Return Skins
80797>>>    End_Function 
80798>>>    
80798>>>    // Save the skin preference. This requires an application object.
80798>>>    // Only do this if the application object allows it. 
80798>>>    // This is called during startup if pbLoadPreference is True
80798>>>    // Suitable for override
80798>>>    Procedure SaveSkinPreference 
80800>>>        String sSkin sIni
80800>>>        If ghoApplication Begin
80802>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80804>>>                Get psSkinFile to sSkin
80805>>>                Get psSkinIni to sIni
80806>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
80807>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
80808>>>            End
80808>>>>
80808>>>        End
80808>>>>
80808>>>        Else Begin
80809>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80810>>>>
80810>>>        End
80810>>>>
80810>>>    End_Procedure
80811>>>
80811>>>    // Load the skin preference. This requires an application object.
80811>>>    // Only do this if the application object allows it. 
80811>>>    // This is called during startup if pbLoadPreference is True
80811>>>    // Suitable for override
80811>>>    Procedure LoadSkinPreference 
80813>>>        String sSkin sIni
80813>>>        Boolean bExists
80813>>>        If ghoApplication Begin
80815>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80817>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
80818>>>                If bExists Begin
80820>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
80821>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
80822>>>                    Set psSkinFile to sSkin
80823>>>                    Set psSkinIni to sIni
80824>>>                End
80824>>>>
80824>>>            End
80824>>>>
80824>>>        End
80824>>>>
80824>>>        Else Begin
80825>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80826>>>>
80826>>>        End
80826>>>>
80826>>>    End_Procedure
80827>>>
80827>>>    // Can be called to apply the current skin.
80827>>>    Procedure ApplySkin
80829>>>        Boolean bOk
80829>>>        String sSkin sIni
80829>>>        If (IsComObjectCreated(Self)) Begin
80831>>>            Get SkinQFile to sSkin
80832>>>            Get psSkinIni to sIni
80833>>>            
80833>>>            Send NotifyPreApplySkin
80834>>>            // when skins are used we don't want to use built in Visual Styles
80834>>>            Send EnableVisualStyles of Desktop (sSkin="")
80835>>>            Get ComLoadSkin sSkin sIni to bOK
80836>>>            If (sSkin<>"" and not(bOk)) Begin
80838>>>                // if not ok, no skin was appied. Enable visual styles
80838>>>                Send EnableVisualStyles of Desktop True
80839>>>            End
80839>>>>
80839>>>            Send NotifyPostApplySkin
80840>>>        End
80840>>>>
80840>>>    End_Procedure
80841>>>
80841>>>
80841>>>End_Class
80842>
80842>Object oHtmlHelp is a cHtmlHelp
80844>End_Object
80845>
80845>Object oApplication is a cApplication
80847>    Set peHelpType to htHtmlHelp
80848>    Set psHelpFile to "DataFlex.chm"
80849>    Set psCompany to "RDC Tools International"
80850>    Set psProduct to "SQL Connections Manager"
80851>    Set psVersion to (String(piVersionMajor(phoVersionInfo(Self))) + "." + String(piVersionMinor(phoVersionInfo(Self))))
80852>    Set psAutoOpenWorkspace to ""
80853>
80853>    Property String psCommandLineIniFilePath ""
80855>    Property Boolean pbIniFileExists False
80857>
80857>    Procedure OnCreate
80860>        Integer eOpened
80860>        Handle hoCmdLine
80860>        String sArgument sPath sFileName sWsFile
80860>        Integer iRetval
80860>        Boolean bExists
80860>
80860>        Get phoCommandLine to hoCmdLine
80861>        Get Argument of hoCmdLine 1 to sArgument
80862>        If (sArgument <> "") Begin
80864>            Get ParseFolderName sArgument to sPath
80865>            Get vFolderExists sPath to iRetval
80866>            If (iRetval = True) Begin
80868>                Set psCommandLineIniFilePath to sPath
80869>                Get vFilePathExists (sPath + "SQLConnections.ini") to bExists
80870>                Set pbIniFileExists to bExists
80871>            End
80871>        End
80871>
80871>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
80872>        If (eOpened <> wsWorkspaceOpened) Begin
80874>            Get GetApplicationPath to sPath
80875>            Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
80876>            Get vFilePathExists sWsFile to bExists
80877>            If (bExists = False) Begin
80879>                Send Stop_Box "No Workspace file selected. Cannot continue!"
80880>                Send Exit_Application
80881>            End
80881>            Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
80882>            If (eOpened <> wsWorkspaceOpened) Begin
80884>                Set psHome          of (phoWorkspace(Self)) to sPath
80885>                Set psProgramPath   of (phoWorkspace(Self)) to sPath
80886>                Set psDataPath      of (phoWorkspace(Self)) to sPath
80887>                Set psFileList      of (phoWorkspace(Self)) to sPath
80888>                Set psHelpPath      of (phoWorkspace(Self)) to sPath
80889>                Set psBitmapPath    of (phoWorkspace(Self)) to sPath
80890>            End
80890>        End
80890>    End_Procedure
80891>
80891>
80891>End_Object
80892>
80892>// Unmark these Define lines if using Mertech drivers!
80892>Define DUF_Use_Mertech_Drivers
80892>
80892>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
80892>>>//****************************************************************************
80892>>>// $Module type: Class
80892>>>// $Module name: cSQLConnectionHandler.pkg
80892>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
80892>>>// Web-site    : http://www.rdctools.com
80892>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
80892>>>//
80892>>>// Description : A handler class for using CLI connection ID's to login to a database server.
80892>>>//
80892>>>// $Rev History:
80892>>>//    2015-08-11  Module header created
80892>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
80892>>>//                Added a new structure for passing connection data back & forth.
80892>>>//                Added better error handling.
80892>>>//                Added a decompose message for the connection string.
80892>>>//    2017-01-09  Added support for Mertech drivers
80892>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
80892>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
80892>>>//    2017-02-12  Reworked the whole connection property interface.
80892>>>//                Now there is one struct property that is the at cencter of a connection.
80892>>>//****************************************************************************
80892>>>Use cli.pkg
80892>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MSSqldrv.pkg)
80892>>>>>//*****************************************************************************
80892>>>>>//*** MSSQLDRV.PKG                                                          ***
80892>>>>>//***                                                                       ***
80892>>>>>//*** Author: Ben Weijers                                                   ***
80892>>>>>//***         Data Access Nederland                                         ***
80892>>>>>//***         29 June 1998                                                  ***
80892>>>>>//***                                                                       ***
80892>>>>>//***                                                                       ***
80892>>>>>//*** Purpose:                                                              ***
80892>>>>>//***   Package that declares MS SQL driver constants and functions.        ***
80892>>>>>//****                                                                      ***
80892>>>>>//***   This package can be used by developers who want to add Data Access  ***
80892>>>>>//***   MS SQL Client specific code to a DataFlex application.              ***
80892>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
80892>>>>>//***             Changed EnumerateServers function to use the highest      ***
80892>>>>>//***             available SQL Server client driver.                       ***
80892>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
80892>>>>>//***             mssqldrv.pkg                                              ***
80892>>>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
80892>>>>>//***             Added constants for SQL Server specific native types      ***
80892>>>>>//***             ( var...(max) types, money types, datetime types)         ***
80892>>>>>//*****************************************************************************
80892>>>>>
80892>>>>>Use Cli.pkg
80892>>>>>Use SQL.pkg
80892>>>>>
80892>>>>>//*** Driver Indentification
80892>>>>>
80892>>>>>//*** Error number constants
80892>>>>>
80892>>>>>
80892>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>// SQL Server spcific types. 
80892>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
80892>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
80892>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
80892>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
80892>>>>>
80892>>>>>// SQL Server spcific types. 
80892>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
80892>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
80892>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
80892>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
80892>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
80892>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
80892>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
80892>>>>>
80892>>>>>
80892>>>>>//*****************************************************************************
80892>>>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
80892>>>>>//***                                                                       ***
80892>>>>>//***   Setup a constraint for a file.                                      ***
80892>>>>>//*****************************************************************************
80892>>>>>
80892>>>>>
80892>>>>>
80892>>>>>Class cMSSQLHandler Is A cCLIHandler
80893>>>>>
80893>>>>>    Procedure Construct_Object
80895>>>>>        Forward Send Construct_Object
80897>>>>>
80897>>>>>        Set psDriverID To MSSQLDRV_ID
80898>>>>>    End_Procedure // Construct_Object
80899>>>>>
80899>>>>>
80899>>>>>
80899>>>>>    //***
80899>>>>>    //*** Function: ExtractList
80899>>>>>    //*** Purpose : Extract the list from the out connect string.
80899>>>>>    //***
80899>>>>>
80899>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
80901>>>>>        Local String  sItem
80901>>>>>        Local Integer iStart
80901>>>>>        Local Integer iEnd
80901>>>>>
80901>>>>>        If (hoStore = 0) ;            Move Current_object To hoStore
80904>>>>>
80904>>>>>        Send Delete_Data To hoStore
80905>>>>>        Move (Pos("{", sOutConnStr)) To iStart
80906>>>>>        While (iStart > 0)
80910>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
80911>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
80914>>>>>            Else Begin
80915>>>>>                Move (Pos(",", sOutConnStr)) To iStart
80916>>>>>                Move (Pos("}", sOutConnStr)) To iEnd
80917>>>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
80920>>>>>
80920>>>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
80923>>>>>
80923>>>>>                If (iStart = iEnd) ;                    Move 0 To iStart
80926>>>>>            End
80926>>>>>>
80926>>>>>        Loop
80927>>>>>>
80927>>>>>
80927>>>>>        Function_Return (Item_Count(hoStore))
80928>>>>>    End_Procedure // ExtractList
80929>>>>>
80929>>>>>
80929>>>>>
80929>>>>>    //***
80929>>>>>    //*** Function: BrowseConnect
80929>>>>>    //*** Purpose : Call the driver's browse connect function
80929>>>>>    //***
80929>>>>>
80929>>>>>    Function BrowseConnect String sInConnStr Returns String
80931>>>>>        Local String  sDriver
80931>>>>>        Local String  sOutConnStr
80931>>>>>        Local Integer iArg
80931>>>>>        Local Integer iRetval
80931>>>>>
80931>>>>>        Get psDriverID To sDriver
80932>>>>>        If (sDriver <> "") Begin
80934>>>>>            Move (Repeat(" ", 8192)) To sOutConnStr
80935>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
80940>>>>>        End
80940>>>>>>
80940>>>>>
80940>>>>>        Function_Return sOutConnStr
80941>>>>>    End_Function// BrowseConnect
80942>>>>>
80942>>>>>
80942>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
80944>>>>>        Local String  sDriver
80944>>>>>        Local String  sOutConnStr
80944>>>>>        Local Integer iArg
80944>>>>>        Local Integer iRetval
80944>>>>>        
80944>>>>>        Move 1 to iArg // Browses only local
80945>>>>>
80945>>>>>        Get psDriverID to sDriver
80946>>>>>        If (sDriver <> "") Begin
80948>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
80949>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
80954>>>>>        End
80954>>>>>>
80954>>>>>
80954>>>>>        Function_Return sOutConnStr
80955>>>>>    End_Function// BrowseConnect
80956>>>>>
80956>>>>>
80956>>>>>    Function DriverIndex String sDriver Returns Integer
80958>>>>>    
80958>>>>>        Local String  sCurrentDriver
80958>>>>>        Local Integer iNumberOfDrivers iDriver iCount
80958>>>>>    
80958>>>>>        Move 0 to iDriver
80959>>>>>    
80959>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
80962>>>>>        For iCount from 1 to iNumberOfDrivers
80968>>>>>>
80968>>>>>    
80968>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
80971>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
80973>>>>>                Move iCount to iDriver
80974>>>>>            End
80974>>>>>>
80974>>>>>        Loop
80975>>>>>>
80975>>>>>    
80975>>>>>        Function_Return iDriver
80976>>>>>    
80976>>>>>    End_Function 
80977>>>>>
80977>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
80979>>>>>        
80979>>>>>        Local String  sServerList
80979>>>>>        Local Integer iNumServers
80979>>>>>        Local Integer iDriver
80979>>>>>        Local Integer iClientVersion
80979>>>>>        Local String  sDriver
80979>>>>>        
80979>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
80980>>>>>
80980>>>>>        If (iDriver) Begin
80982>>>>>                
80982>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
80985>>>>>            
80985>>>>>            Case Begin
80985>>>>>    
80985>>>>>                Case (iClientVersion = SQLSERVER2016CLIENT)
80987>>>>>                    Move SQLSERVER2016DRVRSTR to sDriver
80988>>>>>                    Case Break
80989>>>>>    
80989>>>>>                Case (iClientVersion = SQLSERVER2014CLIENT)
80992>>>>>                    Move SQLSERVER2014DRVRSTR to sDriver
80993>>>>>                    Case Break
80994>>>>>            
80994>>>>>                Case (iClientVersion = SQLSERVER2012CLIENT)
80997>>>>>                    Move SQLSERVER2012DRVRSTR to sDriver
80998>>>>>                    Case Break
80999>>>>>    
80999>>>>>                Case (iClientVersion = SQLSERVER2008CLIENT)
81002>>>>>                    Move SQLSERVER2008DRVRSTR to sDriver
81003>>>>>                    Case Break
81004>>>>>    
81004>>>>>                Case (iClientVersion = SQLSERVER2005CLIENT)
81007>>>>>                    Move SQLSERVER2005DRVRSTR to sDriver
81008>>>>>                    Case Break
81009>>>>>            
81009>>>>>                Case (iClientVersion = SQLSERVER2000CLIENT)
81012>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81013>>>>>                    Case Break
81014>>>>>            
81014>>>>>                Case Else
81014>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81015>>>>>            
81015>>>>>            Case End
81015>>>>>    
81015>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
81016>>>>>            If (iNetworkLocal = 0) Begin
81018>>>>>                Get BrowseConnect sDriver to sServerList
81019>>>>>            End
81019>>>>>>
81019>>>>>            Else Begin
81020>>>>>                Get BrowseConnectLocal sDriver to sServerList
81021>>>>>            End
81021>>>>>>
81021>>>>>            Get ExtractList sServerList Current_object to iNumServers
81022>>>>>        End
81022>>>>>>
81022>>>>>        
81022>>>>>        Function_Return iNumServers
81023>>>>>        
81023>>>>>    End_Function
81024>>>>>
81024>>>>>    //***
81024>>>>>    //*** Procedure: EnumerateServers
81024>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81024>>>>>    //***            This function will return all SQL Server instances on the network. 
81024>>>>>    //***            This may take a long time. 
81024>>>>>    //***            To enumerate only local SQL Server instances use EnumerateServersLocal 
81024>>>>>    Function EnumerateServers Returns Integer
81026>>>>>
81026>>>>>        Local Integer iNumServers
81026>>>>>        Local Integer iNetworkLocal
81026>>>>>        
81026>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
81027>>>>>        
81027>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81028>>>>>        
81028>>>>>        Function_Return iNumServers
81029>>>>>        
81029>>>>>    End_Function
81030>>>>>
81030>>>>>
81030>>>>>    //***
81030>>>>>    //*** Procedure: EnumerateServersLocal
81030>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81030>>>>>    //***            This function will return only return SQL Server instance on the local machine
81030>>>>>    //***            To enumerate all SQL Server instances in a network use EnumerateServers
81030>>>>>    Function EnumerateServersLocal Returns Integer
81032>>>>>
81032>>>>>        Local Integer iNumServers
81032>>>>>        Local Integer iNetworkLocal
81032>>>>>        
81032>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
81033>>>>>        
81033>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81034>>>>>        
81034>>>>>        Function_Return iNumServers
81035>>>>>        
81035>>>>>    End_Function
81036>>>>>
81036>>>>>    
81036>>>>>
81036>>>>>    //***
81036>>>>>    //*** Function: EnumerateDatabases
81036>>>>>    //*** Purpose : Enumerate database in a given server.
81036>>>>>    //***
81036>>>>>
81036>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
81038>>>>>        Local Integer hoSQL
81038>>>>>        Local String  sConnect
81038>>>>>        Local String  sDatabase
81038>>>>>        Local Integer hdbc
81038>>>>>        Local Integer hstmt
81038>>>>>        Local Integer iFetchResult
81038>>>>>
81038>>>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
81041>>>>>        If (Num_Arguments < 2) ;            Move "" To sUser
81044>>>>>
81044>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
81047>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
81049>>>>>
81049>>>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
81051>>>>>            Move Current_Object To hoSQL
81052>>>>>        End_Object // oEnumDBSQLManager
81053>>>>>
81053>>>>>        If (hoSQL <> 0) Begin
81055>>>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
81056>>>>>            If (hdbc <> 0) Begin
81058>>>>>                Get SQLOpen Of hdbc To hstmt
81059>>>>>                If (hstmt <> 0) Begin
81061>>>>>                    //*** We could do a direct select on the sysdatabases table but we use
81061>>>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
81061>>>>>                    //*** approach in case meta data might change, the stored procedure will
81061>>>>>                    //*** stay the same.
81061>>>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
81062>>>>>                    Send SQLCall To hstmt
81063>>>>>                    Repeat
81063>>>>>>
81063>>>>>                        Get SQLFetch Of hstmt To iFetchResult
81064>>>>>                        If (iFetchResult <> 0) Begin
81066>>>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
81067>>>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
81068>>>>>                        End
81068>>>>>>
81068>>>>>                    Until (iFetchResult = 0)
81070>>>>>
81070>>>>>                    Send SQLClose To hstmt
81071>>>>>                End
81071>>>>>>
81071>>>>>                Send SQLDisconnect To hdbc
81072>>>>>            End
81072>>>>>>
81072>>>>>        End
81072>>>>>>
81072>>>>>        Send Destroy_Object To hoSQL
81073>>>>>
81073>>>>>        Function_return (Item_Count(Current_Object))
81074>>>>>    End_Function // EnumerateDatabases
81075>>>>>
81075>>>>>
81075>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
81077>>>>>        
81077>>>>>        Local String  sSqlServerClientVersionName
81077>>>>>        
81077>>>>>            
81077>>>>>        Case Begin
81077>>>>>
81077>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
81079>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
81080>>>>>                Case Break
81081>>>>>
81081>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
81084>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
81085>>>>>                Case Break
81086>>>>>        
81086>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
81089>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
81090>>>>>                Case Break
81091>>>>>
81091>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
81094>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
81095>>>>>                Case Break
81096>>>>>
81096>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
81099>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
81100>>>>>                Case Break
81101>>>>>        
81101>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
81104>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
81105>>>>>                Case Break
81106>>>>>        
81106>>>>>            Case Else
81106>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
81107>>>>>        
81107>>>>>        Case End
81107>>>>>    
81107>>>>>        
81107>>>>>        Function_Return sSqlServerClientVersionName
81108>>>>>        
81108>>>>>    End_Function
81109>>>>>
81109>>>>>
81109>>>>>End_Class // cMSSQLHandler
81110>>>>>
81110>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\db2_drv.pkg)
81110>>>>>//*****************************************************************************
81110>>>>>//*** DB2_DRV.PKG                                                           ***
81110>>>>>//***                                                                       ***
81110>>>>>//*** Author: Ben Weijers                                                   ***
81110>>>>>//***         Data Access Nederland                                         ***
81110>>>>>//***         30 July 1998                                                  ***
81110>>>>>//***                                                                       ***
81110>>>>>//*** Last updated: May 2, 2007                                                                      ***
81110>>>>>//***                                                                       ***
81110>>>>>//*** Purpose:                                                              ***
81110>>>>>//***   Package that declares DB2 driver constants and functions.           ***
81110>>>>>//****                                                                      ***
81110>>>>>//***   This package can be used by developers who want to add DB2 driver   ***
81110>>>>>//***   specific code to a DataFlex application.                            ***
81110>>>>>//*****************************************************************************
81110>>>>>
81110>>>>>Use Cli.pkg
81110>>>>>
81110>>>>>//*** Driver attributes
81110>>>>>
81110>>>>>
81110>>>>>//*** Driver Indentification
81110>>>>>
81110>>>>>//*** Error number constants
81110>>>>>
81110>>>>>//*** Call driver function identifiers
81110>>>>>
81110>>>>>// DB2 specific data types
81110>>>>>Define SQL_CLOB           for   (-99)  
81110>>>>>Define SQL_BLOB           for   (-98)  
81110>>>>>Define SQL_XML            for   (-370) 
81110>>>>>// DB2 Graphic types are Unicode types
81110>>>>>Define SQL_GRAPHIC        for   (-95)  
81110>>>>>Define SQL_VARGRAPHIC     for   (-96)  
81110>>>>>Define SQL_LONGVARGRAPHIC for   (-97)  
81110>>>>>Define SQL_DBCLOB         for   (-350) 
81110>>>>>
81110>>>>>
81110>>>>>//*** Extra DB2 commands
81110>>>>>
81110>>>>>
81110>>>>>//*****************************************************************************
81110>>>>>//*** DB2_CheckTrigger <NewState>                                           ***
81110>>>>>//***                                                                       ***
81110>>>>>//*** This command will set the trigger check at open on or off.            ***
81110>>>>>//*****************************************************************************
81110>>>>>
81110>>>>>
81110>>>>>
81110>>>>>//*****************************************************************************
81110>>>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
81110>>>>>//***                                                                       ***
81110>>>>>//***   Setup a constraint for a file.                                      ***
81110>>>>>//*****************************************************************************
81110>>>>>
81110>>>>>
81110>>>>>
81110>>>>>Class cDB2Handler Is A cCLIHandler
81111>>>>>
81111>>>>>    Procedure Construct_Object
81113>>>>>        Forward Send Construct_Object
81115>>>>>
81115>>>>>        Set psDriverID To DB2_DRV_ID
81116>>>>>    End_Procedure // Construct_Object
81117>>>>>
81117>>>>>
81117>>>>>
81117>>>>>    //***
81117>>>>>    //*** Procedure: SeedDataSources
81117>>>>>    //*** Purpose  : Reset the datasource list to the beginning
81117>>>>>    //***
81117>>>>>
81117>>>>>    Procedure SeedDataSources
81119>>>>>        Local String  sDriver
81119>>>>>        Local String  sVoid
81119>>>>>        Local Integer iRetval
81119>>>>>
81119>>>>>        Get psDriverID To sDriver
81120>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
81127>>>>>    End_Procedure // SeedDataSources
81128>>>>>
81128>>>>>
81128>>>>>
81128>>>>>    //***
81128>>>>>    //*** Function: DataSources
81128>>>>>    //*** Purpose : Call the driver's data sources function
81128>>>>>    //***
81128>>>>>
81128>>>>>    Function DataSources Returns String
81130>>>>>        Local String  sDriver
81130>>>>>        Local String  sDataSource
81130>>>>>        Local String  sDescription
81130>>>>>        Local Integer iLength
81130>>>>>        Local Integer iRetval
81130>>>>>
81130>>>>>        Get psDriverID To sDriver
81131>>>>>        If (sDriver <> "") Begin
81133>>>>>            Move 8192 To iLength
81134>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81135>>>>>            Move (Repeat(" ", iLength)) To sDescription
81136>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81141>>>>>        End
81141>>>>>>
81141>>>>>
81141>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81144>>>>>        Else ;            Function_Return ""
81146>>>>>    End_Function// DataSources
81147>>>>>
81147>>>>>End_Class // cODBCHandler
81148>>>>>
81148>>>>>
81148>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\odbc_drv.pkg)
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBC_DRV.PKG                                                          ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Author: Ben Weijers                                                   ***
81148>>>>>//***         Data Access Nederland                                         ***
81148>>>>>//***         3 February 1998                                               ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Last updated: May 2, 2007                                                                      ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Purpose:                                                              ***
81148>>>>>//***   Package that declares ODBC driver constants and functions.          ***
81148>>>>>//****                                                                      ***
81148>>>>>//***   This package can be used by developers who want to add Data Access  ***
81148>>>>>//***   ODBC Client specific code to a DataFlex application.                ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>Use Cli.pkg
81148>>>>>
81148>>>>>//*** Driver Indentification
81148>>>>>
81148>>>>>//*** Error number constants
81148>>>>>
81148>>>>>//*** Call driver function identifiers
81148>>>>>
81148>>>>>//*** Extra ODBC commands
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCManage                                                            ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Start the ODBC manager.                                               ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCNumberOfDataSources To <NumDSN>                                   ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the number of data sources.                                   ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCDSNName <DSNNumber> To <DSNName>                                  ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the name of the data source.                                  ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCEnumerateTables <DSNName> To <TableNum>                           ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Builds internal table array and returns the number of tables in the   ***
81148>>>>>//*** DSN.                                                                  ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCTableName <TableNum> To <TableName>                               ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the name of the table.                                        ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCSchemaName <TableNum> To <SchemaName>                             ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the schema name of the table.                                 ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCNumberOfFields <DSNName> <TableName> To <NumDSN>                  ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the number of fields.                                         ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBCFieldName <FieldNumber> To <FieldName>                            ***
81148>>>>>//***                                                                       ***
81148>>>>>//*** Returns the name of the field.                                  ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>
81148>>>>>//*****************************************************************************
81148>>>>>//*** ODBC_SetConstraint <FileNum> <ConstraintText>                         ***
81148>>>>>//***                                                                       ***
81148>>>>>//***   Setup a constraint for a file.                                      ***
81148>>>>>//*****************************************************************************
81148>>>>>
81148>>>>>
81148>>>>>
81148>>>>>Class cODBCHandler Is A cCLIHandler
81149>>>>>
81149>>>>>    Procedure Construct_Object
81151>>>>>        Forward Send Construct_Object
81153>>>>>
81153>>>>>        Set psDriverID To ODBC_DRV_ID
81154>>>>>    End_Procedure // Construct_Object
81155>>>>>
81155>>>>>
81155>>>>>
81155>>>>>    //***
81155>>>>>    //*** Procedure Set: DataSourceType
81155>>>>>    //*** Purpose      : Setup the type of data sources returned by the datasources function
81155>>>>>    //***
81155>>>>>
81155>>>>>    Procedure Set DataSourceType Integer iNewType
81157>>>>>        Local String  sDriver
81157>>>>>        Local String  sVoid
81157>>>>>        Local Integer iRetval
81157>>>>>
81157>>>>>        Get psDriverID To sDriver
81158>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
81165>>>>>    End_Procedure // Set DataSourceType
81166>>>>>
81166>>>>>
81166>>>>>
81166>>>>>    //***
81166>>>>>    //*** Function: DataSources
81166>>>>>    //*** Purpose : Call the driver's data sources function
81166>>>>>    //***
81166>>>>>
81166>>>>>    Function DataSources Returns String
81168>>>>>        Local String  sDriver
81168>>>>>        Local String  sDataSource
81168>>>>>        Local String  sDescription
81168>>>>>        Local Integer iLength
81168>>>>>        Local Integer iRetval
81168>>>>>
81168>>>>>        Get psDriverID To sDriver
81169>>>>>        If (sDriver <> "") Begin
81171>>>>>            Move 8192 To iLength
81172>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81173>>>>>            Move (Repeat(" ", iLength)) To sDescription
81174>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81179>>>>>        End
81179>>>>>>
81179>>>>>
81179>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81182>>>>>        Else ;            Function_Return ""
81184>>>>>    End_Function// DataSources
81185>>>>>
81185>>>>>End_Class // cODBCHandler
81186>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
81186>>>>>//****************************************************************************
81186>>>>>// $Module type: Class
81186>>>>>// $Module name: cSQLConnectionIniFile.pkg
81186>>>>>//
81186>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
81186>>>>>// Copyright (c) 2012 RDC Tools International
81186>>>>>// E-mail      : support@rdctools.com
81186>>>>>// Web-site    : http://www.rdctools.com
81186>>>>>//
81186>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
81186>>>>>//
81186>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
81186>>>>>//               properties of that object.
81186>>>>>//
81186>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
81186>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
81186>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
81186>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
81186>>>>>// in the help folder for more details.
81186>>>>>//
81186>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
81186>>>>>>>//****************************************************************************
81186>>>>>>>// $Module type: Include file
81186>>>>>>>// $Module name: cSQLConnectionIniFile.inc
81186>>>>>>>//
81186>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
81186>>>>>>>// Copyright (c) 2012 RDC Tools International
81186>>>>>>>// E-mail      : support@rdctools.com
81186>>>>>>>// Web-site    : http://www.rdctools.com
81186>>>>>>>//
81186>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
81186>>>>>>>//
81186>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
81186>>>>>>>//
81186>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
81186>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
81186>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
81186>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
81186>>>>>>>// in the help folder for more details.
81186>>>>>>>//
81186>>>>>>>Use Winkern.pkg
81186>>>>>>>Use cIniFile.pkg
81186>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCryptographer.pkg)
81186>>>>>>>>>Use VdfBase.pkg
81186>>>>>>>>>
81186>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\CryptographerConstants.pkg)
81186>>>>>>>>>>>//                                      
81186>>>>>>>>>>>// File    : CryptographerConstants.pkg
81186>>>>>>>>>>>//
81186>>>>>>>>>>>//   Author  : Ulbe Stellema
81186>>>>>>>>>>>//             Data Access Worldwide
81186>>>>>>>>>>>//
81186>>>>>>>>>>>//   Date    : October 4, 2009
81186>>>>>>>>>>>//
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Algorithm classes
81186>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
81186>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
81186>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Algorithm types
81186>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
81186>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
81186>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Generic sub-ids
81186>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
81186>>>>>>>>>>>
81186>>>>>>>>>>>// RSA sub-ids
81186>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
81186>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
81186>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
81186>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
81186>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
81186>>>>>>>>>>>
81186>>>>>>>>>>>// DSS sub-ids
81186>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
81186>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
81186>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
81186>>>>>>>>>>>
81186>>>>>>>>>>>// DES sub_ids
81186>>>>>>>>>>>Define ALG_SID_DES                      for 1
81186>>>>>>>>>>>Define ALG_SID_3DES                     for 3
81186>>>>>>>>>>>Define ALG_SID_DESX                     for 4
81186>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
81186>>>>>>>>>>>Define ALG_SID_CAST                     for 6
81186>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
81186>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
81186>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
81186>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
81186>>>>>>>>>>>Define ALG_SID_RC5                      for 13
81186>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
81186>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
81186>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
81186>>>>>>>>>>>Define ALG_SID_AES                      for 17
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Fortezza sub-ids
81186>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
81186>>>>>>>>>>>Define ALG_SID_TEK                      for 11
81186>>>>>>>>>>>
81186>>>>>>>>>>>// RC2 sub-ids
81186>>>>>>>>>>>Define ALG_SID_RC2                      for 2
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Stream cipher sub-ids
81186>>>>>>>>>>>Define ALG_SID_RC4                      for 1
81186>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Diffie-Hellman sub-ids
81186>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
81186>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
81186>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
81186>>>>>>>>>>>Define ALG_SID_KEA                      for 4
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Hash sub ids
81186>>>>>>>>>>>Define ALG_SID_MD2                      for 1
81186>>>>>>>>>>>Define ALG_SID_MD4                      for 2
81186>>>>>>>>>>>Define ALG_SID_MD5                      for 3
81186>>>>>>>>>>>Define ALG_SID_SHA                      for 4
81186>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
81186>>>>>>>>>>>Define ALG_SID_MAC                      for 5
81186>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
81186>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
81186>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
81186>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
81186>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
81186>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
81186>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
81186>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
81186>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
81186>>>>>>>>>>>
81186>>>>>>>>>>>// secure channel sub ids
81186>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
81186>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
81186>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
81186>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
81186>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
81186>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
81186>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
81186>>>>>>>>>>>
81186>>>>>>>>>>>// algorithm identifier definitions
81186>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
81186>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
81186>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
81186>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
81186>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
81186>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
81186>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81186>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
81186>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
81186>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81186>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
81186>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
81186>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
81186>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
81186>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
81186>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
81186>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
81186>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
81186>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
81186>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
81186>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
81186>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
81186>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
81186>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
81186>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
81186>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
81186>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
81186>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
81186>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
81186>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
81186>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
81186>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
81186>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
81186>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
81186>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
81186>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
81186>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
81186>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
81186>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
81186>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
81186>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
81186>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
81186>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
81186>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Providers
81186>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
81186>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
81186>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
81186>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
81186>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
81186>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
81186>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
81186>>>>>>>>>>>
81186>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
81186>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
81186>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
81186>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
81186>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
81186>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
81186>>>>>>>>>>>
81186>>>>>>>>>>>// dwFlag definitions for CryptGenKey
81186>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
81186>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
81186>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
81186>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
81186>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
81186>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
81186>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
81186>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
81186>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
81186>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
81186>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
81186>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
81186>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
81186>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
81186>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
81186>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
81186>>>>>>>>>>>
81186>>>>>>>>>>>// Provider types
81186>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
81186>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
81186>>>>>>>>>>>Define PROV_DSS                         for 3
81186>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
81186>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
81186>>>>>>>>>>>Define PROV_SSL                         for 6
81186>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
81186>>>>>>>>>>>Define PROV_DSS_DH                      for 13
81186>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
81186>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
81186>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
81186>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
81186>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
81186>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
81186>>>>>>>>>>>Define PROV_RNG                         for 21
81186>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
81186>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
81186>>>>>>>>>>>Define PROV_RSA_AES                     for 24
81186>>>>>>>>>>>
81186>>>>>>>>>>>// KP_MODE
81186>>>>>>>>>>>// KP_MODE
81186>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
81186>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
81186>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
81186>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
81186>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
81186>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
81186>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
81186>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
81186>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
81186>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
81186>>>>>>>>>>>
81186>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
81186>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
81186>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
81186>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
81186>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
81186>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
81186>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
81186>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
81186>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
81186>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
81186>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
81186>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
81186>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
81186>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
81186>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
81186>>>>>>>>>>>Define KP_Y                             for 15      // Y value
81186>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
81186>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
81186>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
81186>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
81186>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
81186>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
81186>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
81186>>>>>>>>>>>Define KP_RP                            for 23
81186>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
81186>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
81186>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
81186>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
81186>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
81186>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
81186>>>>>>>>>>>Define KP_KEYVAL                        for 30
81186>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
81186>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
81186>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
81186>>>>>>>>>>>Define KP_PREHASH                       for 34
81186>>>>>>>>>>>Define KP_ROUNDS                        for 35
81186>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
81186>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
81186>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
81186>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
81186>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
81186>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
81186>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
81186>>>>>>>>>>>
81186>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
81186>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
81186>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
81186>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
81186>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
81186>>>>>>>>>>>
81186>>>>>>>>>>>// key BLOB types
81186>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
81186>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
81186>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
81186>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
81186>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
81186>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
81186>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
81186>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
81186>>>>>>>>>>>
81186>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
81186>>>>>>>>>>>
81186>>>>>>>>>>>//  Structure cryptimportkey
81186>>>>>>>>>>>Struct PUBLICKEYSTRUC
81186>>>>>>>>>>>    UChar    bType
81186>>>>>>>>>>>    UChar    bVersion
81186>>>>>>>>>>>    UShort   reserved
81186>>>>>>>>>>>    UInteger aiKeyAlg
81186>>>>>>>>>>>End_Struct
81186>>>>>>>>>>>
81186>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
81186>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81186>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81186>>>>>>>>>>>    UInteger       dwKeySize
81186>>>>>>>>>>>//    UChar[]        rgbKeyData
81186>>>>>>>>>>>End_Struct
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
81186>>>>>>>>>>>Struct HMAC_INFO
81186>>>>>>>>>>>    UInteger HashAlgid
81186>>>>>>>>>>>    Pointer pbInnerString
81186>>>>>>>>>>>    DWord cbInnerString
81186>>>>>>>>>>>    Pointer pbOuterString
81186>>>>>>>>>>>    DWord cbOuterString
81186>>>>>>>>>>>End_Struct
81186>>>>>>>>>>>
81186>>>>>>>>>>>
81186>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
81187>>>>>>>>>>>
81187>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
81188>>>>>>>>>>>
81188>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
81189>>>>>>>>>>>
81189>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
81190>>>>>>>>>>>
81190>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
81191>>>>>>>>>>>
81191>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81192>>>>>>>>>>>
81192>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
81193>>>>>>>>>>>
81193>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
81194>>>>>>>>>>>
81194>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81195>>>>>>>>>>>
81195>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
81196>>>>>>>>>>>    
81196>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
81197>>>>>>>>>>>
81197>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
81198>>>>>>>>>>>
81198>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
81199>>>>>>>>>>>
81199>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
81200>>>>>>>>>>>    
81200>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
81201>>>>>>>>>>>    
81201>>>>>>>>>
81201>>>>>>>>>Class cCryptographer is a cObject
81202>>>>>>>>>    
81202>>>>>>>>>    // Procedure : Construct_Object
81202>>>>>>>>>    // Purpose   : Object constructor
81202>>>>>>>>>    Procedure Construct_Object
81204>>>>>>>>>        Forward Send Construct_Object
81206>>>>>>>>>
81206>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
81207>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
81208>>>>>>>>>        Property Integer    piCipher    CALG_RC4
81209>>>>>>>>>        Property Integer    piHash      CALG_MD5
81210>>>>>>>>>        
81210>>>>>>>>>        // Private properties
81210>>>>>>>>>        Property Handle     Private_phProv
81211>>>>>>>>>    End_Procedure
81212>>>>>>>>>    
81212>>>>>>>>>    
81212>>>>>>>>>    // Function : AcquireContext
81212>>>>>>>>>    // Purpose  : Acquire key container handle
81212>>>>>>>>>    Function AcquireContext Returns Handle
81214>>>>>>>>>        Integer iProvider
81214>>>>>>>>>        String sProvider
81214>>>>>>>>>        Handle hProv
81214>>>>>>>>>        Boolean bOk
81214>>>>>>>>>        Address addrProv
81214>>>>>>>>>        
81214>>>>>>>>>        Move 0 to hProv
81215>>>>>>>>>        Get piProvider to iProvider
81216>>>>>>>>>        Get psProvider to sProvider
81217>>>>>>>>>        
81217>>>>>>>>>        //  Determine address to be passed as provider
81217>>>>>>>>>        If (Trim(sProvider) <> "") Begin
81219>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
81220>>>>>>>>>        End
81220>>>>>>>>>>
81220>>>>>>>>>        Else Begin
81221>>>>>>>>>            Move 0 to addrProv
81222>>>>>>>>>        End
81222>>>>>>>>>>
81222>>>>>>>>>        
81222>>>>>>>>>        //  Acquire Crypto Context
81222>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
81223>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81225>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
81226>>>>>>>>>        End
81226>>>>>>>>>>
81226>>>>>>>>>        
81226>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81228>>>>>>>>>            // Fallback to original
81228>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
81229>>>>>>>>>            
81229>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
81231>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
81232>>>>>>>>>            End
81232>>>>>>>>>>
81232>>>>>>>>>        End
81232>>>>>>>>>>
81232>>>>>>>>>        Set Private_phProv to hProv
81233>>>>>>>>>        
81233>>>>>>>>>        Function_Return hProv
81234>>>>>>>>>    End_Function
81235>>>>>>>>>    
81235>>>>>>>>>    // Function : ReleaseContext
81235>>>>>>>>>    // Purpose  : Releases key container handle
81235>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
81237>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
81238>>>>>>>>>    End_Function
81239>>>>>>>>>    
81239>>>>>>>>>    // Function : CreateHash
81239>>>>>>>>>    // Purpose  : Creates hash object
81239>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
81241>>>>>>>>>        Integer iAlgorithm
81241>>>>>>>>>        Handle hHash
81241>>>>>>>>>        Boolean bOk
81241>>>>>>>>>        
81241>>>>>>>>>        Move 0 to hHash
81242>>>>>>>>>        Get piHash to iAlgorithm
81243>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
81244>>>>>>>>>        
81244>>>>>>>>>        Function_Return hHash
81245>>>>>>>>>    End_Function
81246>>>>>>>>>    
81246>>>>>>>>>    // Function : DestroyHash
81246>>>>>>>>>    // Purpose  : Destroys the hash object
81246>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
81248>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
81249>>>>>>>>>    End_Function
81250>>>>>>>>>    
81250>>>>>>>>>    // Function : HashData
81250>>>>>>>>>    // Purpose  : Adds data to hash object
81250>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
81252>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
81253>>>>>>>>>    End_Function
81254>>>>>>>>>    
81254>>>>>>>>>    // Function : DeriveKey
81254>>>>>>>>>    // Purpose  : Generates session key
81254>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
81256>>>>>>>>>        Integer iAlgorithm
81256>>>>>>>>>        Handle hKey
81256>>>>>>>>>        Boolean bOk
81256>>>>>>>>>        
81256>>>>>>>>>        Move 0 to hKey
81257>>>>>>>>>        Get piCipher to iAlgorithm
81258>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
81259>>>>>>>>>        
81259>>>>>>>>>        Function_Return hKey
81260>>>>>>>>>    End_Function
81261>>>>>>>>>    
81261>>>>>>>>>    // Function : ImportPlainTextKey
81261>>>>>>>>>    // Purpose  : Imports a plain text key
81261>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
81263>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81263>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81263>>>>>>>>>        Boolean   bSuccess
81263>>>>>>>>>        Handle    hKey
81263>>>>>>>>>        Integer   iHeadSize iKeySize
81263>>>>>>>>>        UChar[]   ucaKeyblob
81264>>>>>>>>>        Integer iVoid
81264>>>>>>>>>    
81264>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
81265>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
81266>>>>>>>>>    
81266>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
81267>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
81268>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
81269>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
81270>>>>>>>>>    
81270>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
81271>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
81272>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
81273>>>>>>>>>    
81273>>>>>>>>>        Move 0 to hKey
81274>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
81275>>>>>>>>>        If (not(bSuccess)) Begin 
81277>>>>>>>>>            Move (ShowLastError()) to iVoid
81278>>>>>>>>>        End
81278>>>>>>>>>>
81278>>>>>>>>>    
81278>>>>>>>>>        Function_Return hKey
81279>>>>>>>>>    End_Function
81280>>>>>>>>>
81280>>>>>>>>>    // Function : DestroyKey
81280>>>>>>>>>    // Purpose  : Destroys the key
81280>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
81282>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
81283>>>>>>>>>    End_Function
81284>>>>>>>>>    
81284>>>>>>>>>    // Function : KeyParameter
81284>>>>>>>>>    // Purpose  : Retrieves key data
81284>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
81286>>>>>>>>>        Integer iBuffer iLen
81286>>>>>>>>>        Boolean bOk
81286>>>>>>>>>        
81286>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
81287>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
81288>>>>>>>>>        Function_Return iBuffer
81289>>>>>>>>>    End_Function
81290>>>>>>>>>    
81290>>>>>>>>>    // Function : HashValue
81290>>>>>>>>>    // Purpose  : Retrieves a hash value
81290>>>>>>>>>    Function HashValue Handle lhHash Returns String
81292>>>>>>>>>        Pointer lpSize
81292>>>>>>>>>        Pointer lpHash
81292>>>>>>>>>        String  lsSize
81292>>>>>>>>>        String  lsHash
81292>>>>>>>>>        Integer liResult
81292>>>>>>>>>
81292>>>>>>>>>        Move (Repeat(Character(0),4)) to lsSize
81293>>>>>>>>>        GetAddress of lsSize to lpSize
81294>>>>>>>>>
81294>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,lpSize,0)) to liResult
81295>>>>>>>>>        If (liResult = 0) Function_Return ""
81298>>>>>>>>>
81298>>>>>>>>>        Move (Repeat(Character(0),BytesTodWord(lsSize,1))) to lsHash
81299>>>>>>>>>        GetAddress of lsHash to lpHash
81300>>>>>>>>>
81300>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,lpHash,lpSize,0)) to liResult
81301>>>>>>>>>        If (liResult = 0) Function_Return ""
81304>>>>>>>>>
81304>>>>>>>>>        Function_Return lsHash
81305>>>>>>>>>    End_Function  // HashValue
81306>>>>>>>>>    
81306>>>>>>>>>            
81306>>>>>>>>>    // Function : Encrypt
81306>>>>>>>>>    // Purpose  : Encrypts data
81306>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
81308>>>>>>>>>        Handle hProv hHash hKey
81308>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
81308>>>>>>>>>        Boolean bOk
81308>>>>>>>>>        
81308>>>>>>>>>        Get AcquireContext to hProv
81309>>>>>>>>>        If (hProv) Begin
81311>>>>>>>>>            Get CreateHash hProv to hHash
81312>>>>>>>>>            If (hHash) Begin
81314>>>>>>>>>                Get HashData hHash sPassword to bOk
81315>>>>>>>>>                If (bOk) Begin
81317>>>>>>>>>                    Get piCipher to iAlgorithm
81318>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
81319>>>>>>>>>                End // If (bOk) Begin            
81319>>>>>>>>>>
81319>>>>>>>>>                Get DestroyHash hHash to bOk
81320>>>>>>>>>            End // If (hHash) Begin
81320>>>>>>>>>>
81320>>>>>>>>>            
81320>>>>>>>>>            If (hKey) Begin
81322>>>>>>>>>                //  First call to determine resulting data size
81322>>>>>>>>>                Move (Length(sData)) to iDataLen
81323>>>>>>>>>                Move (Length(sData)) to iCipherLen
81324>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
81325>>>>>>>>>                
81325>>>>>>>>>                //  Reserve space in string
81325>>>>>>>>>                If (iDataLen < iCipherLen) Begin
81327>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
81328>>>>>>>>>                End
81328>>>>>>>>>>
81328>>>>>>>>>                
81328>>>>>>>>>                //  Call to really decrypt
81328>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
81329>>>>>>>>>                //If (not(bOk)) Begin
81329>>>>>>>>>                    //Move "" to sData
81329>>>>>>>>>                    //Move (GetLastError()) to iErr
81329>>>>>>>>>                //End
81329>>>>>>>>>                
81329>>>>>>>>>                Get DestroyKey hKey to bOk
81330>>>>>>>>>            End // If (hKey) Begin
81330>>>>>>>>>>
81330>>>>>>>>>            Get ReleaseContext hProv to bOk
81331>>>>>>>>>        End // If (hProv) Begin
81331>>>>>>>>>>
81331>>>>>>>>>        Function_Return sData
81332>>>>>>>>>    End_Function
81333>>>>>>>>>    
81333>>>>>>>>>    // Function : Decrypt
81333>>>>>>>>>    // Purpose  : Decrypts data
81333>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
81335>>>>>>>>>        Handle hProv hHash hKey
81335>>>>>>>>>        Integer iAlgorithm iDataLen
81335>>>>>>>>>        Boolean bOk
81335>>>>>>>>>        
81335>>>>>>>>>        Get AcquireContext to hProv
81336>>>>>>>>>        If (hProv) Begin
81338>>>>>>>>>            Get CreateHash hProv to hHash
81339>>>>>>>>>            If (hHash) Begin
81341>>>>>>>>>                Get HashData hHash sPassword to bOk
81342>>>>>>>>>                If (bOk) Begin
81344>>>>>>>>>                    Get piCipher to iAlgorithm
81345>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
81346>>>>>>>>>                End // If (bOk) Begin            
81346>>>>>>>>>>
81346>>>>>>>>>                Get DestroyHash hHash to bOk
81347>>>>>>>>>            End // If (hHash) Begin
81347>>>>>>>>>>
81347>>>>>>>>>            
81347>>>>>>>>>            If (hKey) Begin
81349>>>>>>>>>                Move (Length(sData)) to iDataLen
81350>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
81351>>>>>>>>>                //If (bOk = False) Move "" to sData
81351>>>>>>>>>                
81351>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
81351>>>>>>>>>                If (Length(sData) > iDataLen) Begin
81353>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
81354>>>>>>>>>                End
81354>>>>>>>>>>
81354>>>>>>>>>                
81354>>>>>>>>>                Get DestroyKey hKey to bOk
81355>>>>>>>>>            End // If (hKey) Begin
81355>>>>>>>>>>
81355>>>>>>>>>            Get ReleaseContext hProv to bOk
81356>>>>>>>>>        End // If (hProv) Begin
81356>>>>>>>>>>
81356>>>>>>>>>        Function_Return sData
81357>>>>>>>>>    End_Function
81358>>>>>>>>>    
81358>>>>>>>>>    //  Function : GenerateRandom
81358>>>>>>>>>    //  Purpose  : Generates random data.
81358>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
81360>>>>>>>>>        Handle hProv
81360>>>>>>>>>        UChar[] uaResult
81361>>>>>>>>>        Boolean bRes
81361>>>>>>>>>        
81361>>>>>>>>>        Get AcquireContext to hProv
81362>>>>>>>>>        
81362>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
81363>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
81364>>>>>>>>>        
81364>>>>>>>>>        Get ReleaseContext hProv to bRes
81365>>>>>>>>>        
81365>>>>>>>>>        Function_Return uaResult
81366>>>>>>>>>    End_Function
81367>>>>>>>>>    
81367>>>>>>>>>    //  Function : GenerateRandomString
81367>>>>>>>>>    //  Purpose  : Generates random data and does a base64 encoding to properly present it as a string.
81367>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
81369>>>>>>>>>        String sResult
81369>>>>>>>>>        UChar[] aData
81370>>>>>>>>>        Address pBase64
81370>>>>>>>>>        Integer iVoid
81370>>>>>>>>>
81370>>>>>>>>>        Get GenerateRandom iLenght to aData
81371>>>>>>>>>        
81371>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
81372>>>>>>>>>        Move pBase64 to sResult
81373>>>>>>>>>        Move (Free(pBase64)) to iVoid    
81374>>>>>>>>>        
81374>>>>>>>>>        Function_Return (Left(sResult, iLenght))
81375>>>>>>>>>    End_Function
81376>>>>>>>>>
81376>>>>>>>>>End_Class
81377>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Base64Functions.pkg)
81377>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
81377>>>>>>>>>//>
81377>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
81377>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
81377>>>>>>>>>//>
81377>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
81377>>>>>>>>>//> strings.
81377>>>>>>>>>//>
81377>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
81377>>>>>>>>>//> Base64Decode) that are built into the runtime.
81377>>>>>>>>>//>
81377>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
81377>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
81377>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
81377>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
81377>>>>>>>>>
81377>>>>>>>>>Use VdfBase.pkg
81377>>>>>>>>>
81377>>>>>>>>>// Functions in vdfBase64.dll
81377>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
81378>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
81379>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
81380>>>>>>>>>
81380>>>>>>>>>// Structure
81380>>>>>>>>>Struct txxfBase64Buffer
81380>>>>>>>>>    Pointer pData
81380>>>>>>>>>    Integer iLength
81380>>>>>>>>>End_Struct
81380>>>>>>>>>
81380>>>>>>>>>Global_Variable Integer oBase64Functions
81380>>>>>>>>>
81380>>>>>>>>>Object _oBase64Functions is a cObject
81382>>>>>>>>>    Move Self to oBase64Functions
81383>>>>>>>>>
81383>>>>>>>>>
81383>>>>>>>>>    Function EncodeString String sValue Returns String
81386>>>>>>>>>        Address pBase64
81386>>>>>>>>>        String sResult
81386>>>>>>>>>        Integer iVoid
81386>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
81387>>>>>>>>>        Move pBase64 to sResult
81388>>>>>>>>>        Move (Free(pBase64)) to iVoid
81389>>>>>>>>>        Function_Return sResult
81390>>>>>>>>>    End_Function
81391>>>>>>>>>
81391>>>>>>>>>    Function DecodeString String sValue Returns String
81394>>>>>>>>>        Address pBinary
81394>>>>>>>>>        String sBinary
81394>>>>>>>>>        Integer iVoid iLen
81394>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
81395>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
81396>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
81397>>>>>>>>>        Move (Free(pBinary)) to iVoid
81398>>>>>>>>>        Function_Return sBinary
81399>>>>>>>>>    End_Function
81400>>>>>>>>>
81400>>>>>>>>>End_Object
81401>>>>>>>Use MSSqldrv.pkg
81401>>>>>>>Use db2_drv.pkg
81401>>>>>>>Use odbc_drv.pkg
81401>>>>>>>Use vWin32fh.pkg
81401>>>>>>>
81401>>>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
81401>>>>>>>>>//
81401>>>>>>>>>// *** The Database Update Framework Include file ***
81401>>>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
81401>>>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
81401>>>>>>>>>//
81401>>>>>>>>>//
81401>>>>>>>>>Use LanguageText.Pkg
81401>>>>>>>>>
81401>>>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
81401>>>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
81401>>>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
81401>>>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
81401>>>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
81401>>>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
81401>>>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
81401>>>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_UpdateVersion     for "Updating database"
81401>>>>>>>>>    Define CS_UpdateFromVersion for "from version"
81401>>>>>>>>>    Define CS_UpdateToVersion   for "to version:"
81401>>>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
81401>>>>>>>>>//
81401>>>>>>>>>    Define CS_DatabaseInUseShort  for "There are others using the application/database. Are you sure you still want to update the database?"
81401>>>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
81401>>>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
81401>>>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
81401>>>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
81401>>>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
81401>>>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
81401>>>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
81401>>>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
81401>>>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>>>
81401>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MertechDUF.pkg)
81401>>>>>>>>>//
81401>>>>>>>>>// Use of Mertech drivers:
81401>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
81401>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
81401>>>>>>>>>//Define DUF_Use_Mertech_Drivers
81401>>>>>>>>>//
#REM USE MERTECH.INC
81401>>>>>>>>>    Use Flex2SQLDUF.pkg
Including file: Flex2SQLDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Flex2SQLDUF.pkg)
81401>>>>>>>>>>>//*************************************************************************
81401>>>>>>>>>>>//*                                                                       *
81401>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
81401>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
81401>>>>>>>>>>>//*  All rights reserved.                                                 *
81401>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
81401>>>>>>>>>>>//*                                                                       *
81401>>>>>>>>>>>//*  NOTE: This version of Flex2SQL is specially adapted to be used with  *
81401>>>>>>>>>>>// * the Database Update Framework (DUF)                                  *
81401>>>>>>>>>>>// *                                                                      *
81401>>>>>>>>>>>//*************************************************************************
81401>>>>>>>>>>>Use mertech.inc
Including file: mertech.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mertech.inc)
81401>>>>>>>>>>>>>//*************************************************************************
81401>>>>>>>>>>>>>//*                                                                       *
81401>>>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
81401>>>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
81401>>>>>>>>>>>>>//*  All rights reserved.                                                 *
81401>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
81401>>>>>>>>>>>>>//*                                                                       *
81401>>>>>>>>>>>>>//*************************************************************************
81401>>>>>>>>>>>>>Use UI
81401>>>>>>>>>>>>>Use SEQ_CHNL.PKG
81401>>>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 3.1.1
#REM -----------------------------------------------
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>// #DEFINE's
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FILE_PRIMARY_KEY                          For (DF_FILE_RECORD_REREAD+1)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
81401>>>>>>>>>>>>>Define DF_FILE_NUMBER_INVERSE_KEYS                  For (DF_FILE_RECORD_REREAD+3)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SET_MODE
81401>>>>>>>>>>>>>/// @Description Allows switching between set-oriented and record oriented fetch modes.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// If DF_FILE_SET_MODE is set to True, the driver will fetch a set of records
81401>>>>>>>>>>>>>/// for each find. If DF_FILE_SET_MODE is False, the driver will fetch only one
81401>>>>>>>>>>>>>/// record at a time. This attribute can also be specified in the .INT file during
81401>>>>>>>>>>>>>/// migration through Flex2SQL. This settings is normally used alongside
81401>>>>>>>>>>>>>/// DF_FILE_MAX_ROWS to set the number of rows to return and DF_FILE_CACHE_MODE
81401>>>>>>>>>>>>>/// to turn on local caching.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: Turning off set-mode can have a detrimental impact on performance. Unless
81401>>>>>>>>>>>>>/// there is a specific reason to do otherwise, this option should be left on.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default value: True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See DF_FILE_MAX_ROWS DF_FILE_CACHE_MODE
81401>>>>>>>>>>>>>/// @INTOPT OPTIMIZE {FOR_SET | ONE_ROW}
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Mode for the FileNumber. True for set-mode, False for one-row mode.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to True
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to boolVar
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>Define DF_FILE_SET_MODE                             For (DF_FILE_RECORD_REREAD+5)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_DATABASENAME
81401>>>>>>>>>>>>>/// @Description Returns a string containing the name of the database where the
81401>>>>>>>>>>>>>/// table referenced by the passed File Number resides. This is a READ ONLY
81401>>>>>>>>>>>>>/// attribute. Note that because Oracle doesn't support the concept of multiple
81401>>>>>>>>>>>>>/// databases on one server, this attribute is not valid for Oracle.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex, PGFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Database
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_DATABASENAME of Orderhea.File_Number to strVal
81401>>>>>>>>>>>>>Define DF_FILE_DATABASENAME                         For (DF_FILE_RECORD_REREAD+6)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_MAX_ROWS
81401>>>>>>>>>>>>>/// @Description Controls the maximum number of rows retrieved by a Find GT/LT
81401>>>>>>>>>>>>>/// operation. The driver will automatically retrieve and cache this many rows
81401>>>>>>>>>>>>>/// for future find GT/LT operations. Setting this property to a very high
81401>>>>>>>>>>>>>/// value can be inefficient from a UI perspective but may be advisable for
81401>>>>>>>>>>>>>/// local processing of rows (such as in a batch process).
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default value: 10
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See DF_FILE_SET_MODE DF_FILE_CACHE_MODE
81401>>>>>>>>>>>>>/// @INTOPT MAX_ROWS_TO_QUERY {integer}
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Attribute Value
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to 10
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to intVal
81401>>>>>>>>>>>>>Define DF_FILE_MAX_ROWS                             For (DF_FILE_RECORD_REREAD+7)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_TABLE_NAME
81401>>>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the SQL table
81401>>>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
81401>>>>>>>>>>>>>/// this attribute may be used to permanently change the table that a filelist
81401>>>>>>>>>>>>>/// entry is pointing to.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT DATABASE_NAME {string}
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the SQL Table.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_TABLE_NAME of Orderhea.File_Number to strVal
81401>>>>>>>>>>>>>Define DF_FILE_TABLE_NAME                           For (DF_FILE_RECORD_REREAD+8)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_CACHE_MODE
81401>>>>>>>>>>>>>/// @Description Activates or deactivates the local cache for set-oriented searches.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Through the DF_FILE_CACHE_MODE attribute, we can activate or deactivate the
81401>>>>>>>>>>>>>/// local cache. When the cache is active in a set-oriented search, a fixed
81401>>>>>>>>>>>>>/// number of records are pre-fetched and kept in the local cache. If a record
81401>>>>>>>>>>>>>/// is not found in the local cache, a new set is fetched. The number of records
81401>>>>>>>>>>>>>/// fetched is controlled via the DF_FILE_MAX_ROWS attribute. Set-mode vs. one-row
81401>>>>>>>>>>>>>/// mode is controlled via the DF_FILE_SET_MODE attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: Turning off the cache can have significant detrimental effects on performance.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default value: True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See         DF_FILE_MAX_ROWS DF_FILE_SET_MODE
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Mode for FileNumber. True for active. False for inactive.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to True
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to boolVal
81401>>>>>>>>>>>>>Define DF_FILE_CACHE_MODE                           For (DF_FILE_RECORD_REREAD+9)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_BASE                         For (DF_FILE_RECORD_REREAD+10)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_STATIC
81401>>>>>>>>>>>>>/// @Description Activates or deactivates a special table mode where all rows
81401>>>>>>>>>>>>>/// from the table are loaded into a local cache. When active, all searches are
81401>>>>>>>>>>>>>/// done in memory and the actual table is not accessed.  The driver does not allow
81401>>>>>>>>>>>>>/// editing of a table in static mode.  This is a very useful feature especially
81401>>>>>>>>>>>>>/// when a table contains configuration or static information used in
81401>>>>>>>>>>>>>/// calculations, (i.e., Tax Rate tables, etc.) By keeping this table locally
81401>>>>>>>>>>>>>/// in memory, network round trips are saved resulting in significant
81401>>>>>>>>>>>>>/// performance improvements. This attribute is also useful for batch
81401>>>>>>>>>>>>>/// processes that make extensive table IO requests for reading static information.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: Because the entire table is loaded into memory, it is inadvisable to use
81401>>>>>>>>>>>>>/// this on very large tables.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_STATIC of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Static Mode for FileNumber. True for static. False for dynamic.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_STATIC of Orderhea.File_Number to True
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_STATIC of Orderhea.File_Number to boolVal
81401>>>>>>>>>>>>>Define DF_FILE_STATIC                               For (DF_FILE_RECORD_REREAD+11)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SERVER_NAME
81401>>>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the database server
81401>>>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
81401>>>>>>>>>>>>>/// this attribute may be used to permanently change the server that a filelist
81401>>>>>>>>>>>>>/// entry is pointing to.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT SERVER_NAME {string}
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the database server.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to "(localdb)\v11.0"
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to strVal
81401>>>>>>>>>>>>>Define DF_FILE_SERVER_NAME                          For (DF_FILE_RECORD_REREAD+12)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FETCH_FIELD_COUNT
81401>>>>>>>>>>>>>/// @Description This attribute is used to get the number of fields or columns
81401>>>>>>>>>>>>>/// in the given table. Note that this is referring to the columns in the SQL
81401>>>>>>>>>>>>>/// backend and may not necessarily reflect the number of columns in DataFlex.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a readonly attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     MsSQLFlex MySQLFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FETCH_FIELD_COUNT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>/// Get_Attribute DF_FETCH_FIELD_COUNT of hFile To "INDXS"
81401>>>>>>>>>>>>>Define DF_FETCH_FIELD_COUNT                         For (DF_FILE_RECORD_REREAD+13)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_TABLESPACE_NAME
81401>>>>>>>>>>>>>/// @Description A tablespace is a container of segments (objects that have an
81401>>>>>>>>>>>>>/// allotted amount of space), i.e. tables and indexes. This attribute is
81401>>>>>>>>>>>>>/// used to get or set the name of the tablespace being used for the data tables.
81401>>>>>>>>>>>>>/// To set or get the tablespace name for indexes, use the DF_FILE_INDEXTABLESPACE_NAME
81401>>>>>>>>>>>>>/// attribute. Setting the tablespace name can only be done during a Structure_Start
81401>>>>>>>>>>>>>/// (during table creation).  Getting the name, however can be done at
81401>>>>>>>>>>>>>/// anytime.  Note that when setting the tablespace name, it must be set to an
81401>>>>>>>>>>>>>/// already existing tablespace, this attribute does not create the tablespace itself.
81401>>>>>>>>>>>>>/// Even though MYSQL uses tablespaces, this this attribute is only supported
81401>>>>>>>>>>>>>/// in Oracle and PostgreSQL.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_INDEXTABLESPACE_NAME
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// move 0 to hFile
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///             // More table creation here
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
81401>>>>>>>>>>>>>Define DF_FILE_TABLESPACE_NAME                      For (DF_FILE_RECORD_REREAD+14)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
81401>>>>>>>>>>>>>Define DF_FETCH_FIELDNUMBER                         For (DF_FILE_RECORD_REREAD+15)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_INDEXTABLESPACE_NAME
81401>>>>>>>>>>>>>/// @Description This attribute is used to get or set the name of the tablespace
81401>>>>>>>>>>>>>/// being used for the index segment of a database. For a description of tablespaces,
81401>>>>>>>>>>>>>/// see the description above for DF_FILE_TABLESPACE_NAME. Similar to the Tablespace
81401>>>>>>>>>>>>>/// name attribute, setting the index tablespace name can only be done during creation
81401>>>>>>>>>>>>>/// and must use an already existing tablespace as the variable. This attribute is
81401>>>>>>>>>>>>>/// only available for Oracle and Postgre.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_TABLESPACE_NAME
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// move 0 to hFile
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///             // More table creation here
81401>>>>>>>>>>>>>///             //
81401>>>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
81401>>>>>>>>>>>>>Define DF_FILE_INDEXTABLESPACE_NAME                 For (DF_FILE_RECORD_REREAD+16)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_RETRIEVE_RECNUM
81401>>>>>>>>>>>>>/// @Description When creating records on a table with RECNUM support, the
81401>>>>>>>>>>>>>/// record number is returned after creation. When this attribute is false, the newly
81401>>>>>>>>>>>>>/// created record's RECNUM is not returned from the server. This could result in a
81401>>>>>>>>>>>>>/// slight performance improvement when many records are being created in a loop.
81401>>>>>>>>>>>>>/// The optimization, however, is negligible.  Having this attribute set to false can
81401>>>>>>>>>>>>>/// have detrimental effects if used improperly; i.e. DD-based saves or UI-based
81401>>>>>>>>>>>>>/// operations. Thus, this should almost always be set to true unless there is a
81401>>>>>>>>>>>>>/// compelling reason to do otherwise.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-31 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. false to not retrieve record number, true otherwise.
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open ORDERHEA
81401>>>>>>>>>>>>>/// Handle  hFile
81401>>>>>>>>>>>>>/// Boolean bRetrieve
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_RETRIEVE_RECNUM of hFile to false
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_RETRIEVE_RECNUM of hFile To bRetrieve
81401>>>>>>>>>>>>>Define DF_FILE_RETRIEVE_RECNUM                      For (DF_FILE_RECORD_REREAD+17)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_NAME_SPACE
81401>>>>>>>>>>>>>/// @Description In Postgres, schemas are objects where all the tables,views and indexes
81401>>>>>>>>>>>>>/// are stored. Separate schemas are used to specify relational data. This attribute is
81401>>>>>>>>>>>>>/// used to set the name of the schema where a table is created. Schema's do not account
81401>>>>>>>>>>>>>/// for any physical space but are merely used as theory to explain the order of a database.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     PGFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Name of the Schema
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open ORDERHEA
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// String sSchemaName
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Set_Attribute DF_FILE_NAME_SPACE of hFile to "ORDERHEA"
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_NAME_SPACE of hFile To sSchemaName
81401>>>>>>>>>>>>>Define DF_FILE_NAME_SPACE                           For (DF_FILE_RECORD_REREAD+18)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_PCTFREE                      For (DF_FILE_RECORD_REREAD+19)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_PCTUSED                      For (DF_FILE_RECORD_REREAD+21)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_INITIAL                      For (DF_FILE_RECORD_REREAD+23)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_STORAGE_NEXT                         For (DF_FILE_RECORD_REREAD+25)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
81401>>>>>>>>>>>>>Define DF_FILE_ALLOW_NULL                           For (DF_FILE_RECORD_REREAD+27)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_GET_SERVERNAME_FROM_LOGIN
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SERVER_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SERVER_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the SERVER_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Deprecated
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_GET_SERVERNAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+29)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will be included
81401>>>>>>>>>>>>>/// in the INT file.  If set to True, the server name will not be included in the INT file,
81401>>>>>>>>>>>>>/// if set to false, the server name will be included in the INT file. This has two uses.
81401>>>>>>>>>>>>>/// The first is during a Structure_Start i.e. table creation/modification. The other is
81401>>>>>>>>>>>>>/// when using the OUTPUT_INT_FILE command. Set this attribute before the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// to indicate how the INT file will be written.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///   Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///   OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_SERVERNAME_OUTPUT                       For DF_FILE_GET_SERVERNAME_FROM_LOGIN
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_GET_DATABASENAME_FROM_LOGIN
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Deprecated
81401>>>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_GET_DATABASENAME_FROM_LOGIN          For (DF_FILE_RECORD_REREAD+31)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_DATABASENAME_OUTPUT                     For DF_FILE_GET_DATABASENAME_FROM_LOGIN
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_GET_SCHEMANAME_FROM_LOGIN
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Deprecated
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_GET_SCHEMANAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+33)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
81401>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
81401>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
81401>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
81401>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
81401>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
81401>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
81401>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
81401>>>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Default Value: False
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
81401>>>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of Customer.File_Number to True
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Close Customer
81401>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT           For DF_FILE_GET_SCHEMANAME_FROM_LOGIN
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FILE_PRESERVE_RECNUM                      For 184
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FILE_NATIVE_RECORD_LENGTH                 For 194
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_OEM_TRANSLATION
81401>>>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
81401>>>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
81401>>>>>>>>>>>>>/// code pages. When migrating data, this attribute is used to determine whether
81401>>>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
81401>>>>>>>>>>>>>/// migrating passwords with special characters may call for different code pages.
81401>>>>>>>>>>>>>/// Setting this attribute to true will convert the OEM data to ANSI, setting it
81401>>>>>>>>>>>>>/// to false will not.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Indicates if OEM data will be converted to ANSI. True converts it, false does not.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Boolean bTranslate
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
81401>>>>>>>>>>>>>///     Get_Attribute DF_FILE_OEM_TRANSLATION of hFile to bTranslate
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FILE_OEM_TRANSLATION                      For (DF_FILE_RECORD_REREAD+51)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_EPOCH_YEAR
81401>>>>>>>>>>>>>/// @Description When dealing with two-digit years, an epoch year must be used
81401>>>>>>>>>>>>>/// to determine which century the date is referring to. For example if the
81401>>>>>>>>>>>>>/// epoch year is set to 30, then any two digit year greater than 30 will be
81401>>>>>>>>>>>>>/// considered in the 20th Century, anything less than or equal to 30 will be
81401>>>>>>>>>>>>>/// considered in the 21st Century.  This attribute is used to turn on or off
81401>>>>>>>>>>>>>/// this feature. To use this feature, set this attribute to whatever the epoch
81401>>>>>>>>>>>>>/// year is expected to be. To disable this feature, set this attribute to 0
81401>>>>>>>>>>>>>/// or false. Note that setting this attribute must be done at table creation
81401>>>>>>>>>>>>>/// or inside of a Structure_Start.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT      EPOCH_YEAR
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Indicates what the epoch year is. 0 to disable
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Boolean bEpoch
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_EPOCH_YEAR of hFile to 30
81401>>>>>>>>>>>>>///     Get_Attribute DF_FILE_EPOCH_YEAR of hFile to bEpoch
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FILE_EPOCH_YEAR                           For (DF_FILE_RECORD_REREAD+53)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define DF_FILE_USE_ROWCOUNT_IN_TRANSACTIONS         For 628
81401>>>>>>>>>>>>>Define DF_FILE_ICF_STATUS                           For 630
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_LOCK_RECORD_STATUS
81401>>>>>>>>>>>>>/// @Description Table locking is done during transactions to maintain atomicity.
81401>>>>>>>>>>>>>/// In DataFlex, this is usually done with the REREAD/UNLOCK commands. This
81401>>>>>>>>>>>>>/// attribute is used to get the status of a table lock. If a table is currently
81401>>>>>>>>>>>>>/// in a REREAD, or locked, then the attribute will return true. Otherwise, it
81401>>>>>>>>>>>>>/// returns false. It is a read-only attribute so no setting can be done.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_LOCK_RECORD_STATUS of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Indicates the status of the file lock
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Integer bLocked
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_LOCK_RECORD_STATUS of hFile to bLocked
81401>>>>>>>>>>>>>Define DF_FILE_LOCK_RECORD_STATUS                   For 632
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_CASING
81401>>>>>>>>>>>>>/// @Description Controls the filename and column name casing.
81401>>>>>>>>>>>>>/// You can set this to either keep the file case, force to lower case or force
81401>>>>>>>>>>>>>/// to uppercase.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CASING of {FileNumber} to {FILE_CASING_KEEP|FILE_CASING_LOWER|FILE_CASING_UPPER}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CASING of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              integer set to one of the above values.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Integer eCasing
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///    Set_Attribute DF_FILE_CASING of hFile to FILE_CASING_KEEP
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_CASING of hFile to eCasing
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define DF_FILE_CASING                               For 634
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_NAME                    For (DF_FIELD_NATIVE_LENGTH+1)
81401>>>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_TYPE                    For (DF_FIELD_NATIVE_LENGTH+2)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FIELD_TEXT_SEGMENT_NAME                   For (DF_FIELD_NATIVE_LENGTH+3)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FIELD_TEXT_NUM_SEGMENTS                   For (DF_FIELD_NATIVE_LENGTH+4)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_DEFAULT_VALUE
81401>>>>>>>>>>>>>/// @Description Use this attribute to get or set the default value for a given column.
81401>>>>>>>>>>>>>/// Setting the default value can only be done during a structure_start or during table
81401>>>>>>>>>>>>>/// creation. If this attribute is not set, it is defaulted to the driver default.
81401>>>>>>>>>>>>>/// See Mertech.cfg
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
81401>>>>>>>>>>>>>/// @Param  variable              Variable for the default value of the field
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>/// String sDefault
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Integer iColumn
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move "California" to sDefault
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>/// Move 3 to iColumn
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///    Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
81401>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE                       For (DF_FIELD_NATIVE_LENGTH+5)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_TEXT_LENGTH_SEGMENT                 For (DF_FIELD_NATIVE_LENGTH+6)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_TIME_ON
81401>>>>>>>>>>>>>/// @Description Assign a field to retrieve Time Stamp value from a DATETIME
81401>>>>>>>>>>>>>/// column in a table.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This option was implemented because some versions of DataFlex do not support
81401>>>>>>>>>>>>>/// DATETIME fields normally supported by SQL databases.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// To use this: Change the type of a date field in your FD to string type,
81401>>>>>>>>>>>>>/// Set the attribute DF_FIELD_TIME_ON of this field to TRUE and
81401>>>>>>>>>>>>>/// recompile your program.
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_TIME_ON of <FileNumber|FileName FieldNumber> to DFTRUE | DFFALSE
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  FileName              Name of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// #INCLUDE MERTECH.INC
81401>>>>>>>>>>>>>/// string sDateTime sDatabaseName
81401>>>>>>>>>>>>>/// open ORDERHEA
81401>>>>>>>>>>>>>/// Set_Attribute DF_FIELD_TIME_ON of 30 3 to dfTrue
81401>>>>>>>>>>>>>/// find GE ORDERHEA by recnum
81401>>>>>>>>>>>>>/// move ORDERHEA.ORDER_DATE to sDateTime
81401>>>>>>>>>>>>>/// showln "sDateTime: " sDateTime
81401>>>>>>>>>>>>>Define DF_FIELD_TIME_ON                             For (DF_FIELD_NATIVE_LENGTH+8)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_NAME
81401>>>>>>>>>>>>>/// @Description This attribute is used to get the name of the desired column
81401>>>>>>>>>>>>>/// on the SQL backend. Currently this attribute is ReadOnly and so setting
81401>>>>>>>>>>>>>/// or modifying a column name cannot be done using this attribute.  In most
81401>>>>>>>>>>>>>/// cases, the field name on the SQL backend will be the same as the Dataflex name.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_NAME of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
81401>>>>>>>>>>>>>/// @Param  variable                    String containing the name of the field
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// String sName
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_NATIVE_NAME of Customer.File_Number 3 to sName
81401>>>>>>>>>>>>>Define DF_FIELD_NATIVE_NAME                         For (DF_FIELD_NATIVE_LENGTH+9)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_NULL
81401>>>>>>>>>>>>>/// @Description Use this attribute to get or set whether a column in a table will
81401>>>>>>>>>>>>>/// allow null values. When set to true, the column accepts null values. Setting
81401>>>>>>>>>>>>>/// this attribute to false will keep it from accepting null values. Although,
81401>>>>>>>>>>>>>/// getting the value of this attribute can be done at anytime, setting it must
81401>>>>>>>>>>>>>/// be done in a Structure_Start or during table creation.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
81401>>>>>>>>>>>>>/// @Param  variable                    Boolean variable
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>/// Integer iColumn
81401>>>>>>>>>>>>>/// Boolean bAllowNull
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>/// Move 3 to iColumn
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
81401>>>>>>>>>>>>>///    Set_Attribute DF_FIELD_NULL of hFile iColumn to True
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_NULL of hFile iColumn to bAllowNull
81401>>>>>>>>>>>>>Define DF_FIELD_NULL                                For (DF_FIELD_NATIVE_LENGTH+10)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_TYPE
81401>>>>>>>>>>>>>/// @Description Use this attribute to get or set the Native type for a specific
81401>>>>>>>>>>>>>/// field in a table.  The native type refers to the data type of the field on the
81401>>>>>>>>>>>>>/// SQL backend. Setting this attribute can only be done during table creation or
81401>>>>>>>>>>>>>/// inside of a Structure_Start. When setting this attribute, it is good practice
81401>>>>>>>>>>>>>/// to use the constants mentioned below instead of the integers. For a list of
81401>>>>>>>>>>>>>/// these constants, refer to the sections: "Oracle Data Types", "MySQL Data Types",
81401>>>>>>>>>>>>>/// "PostgreSQL Data Types", and "SQL Server Data Types" included in this document.
81401>>>>>>>>>>>>>/// Note that when getting the value for this attribute, an integer will be returned
81401>>>>>>>>>>>>>/// so these lists of constants can again prove useful.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT      FIELD_TYPE
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
81401>>>>>>>>>>>>>/// @Param  variable                    variable for the native data type
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iColumn iType
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to "eSQLServer_DATE"
81401>>>>>>>>>>>>>///     Get_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
81401>>>>>>>>>>>>>///     Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE                         For (DF_FIELD_NATIVE_LENGTH+12)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute (readOnly used by DataFlex 18.0 Studio)
81401>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME                    For 711
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_NATIVE_OFFSET                       For (DF_FIELD_NATIVE_LENGTH+14)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_AUTO_INCREMENT
81401>>>>>>>>>>>>>/// @Description Auto incrementing is a technique used in Dataflex usually for
81401>>>>>>>>>>>>>/// fields that are set as the unique identifier. Instead of generating a value
81401>>>>>>>>>>>>>/// or manually inserting data into the column, when a field auto increments,
81401>>>>>>>>>>>>>/// the value of the field increases by one (usually) with each record.  This
81401>>>>>>>>>>>>>/// field is used to get or set whether the field uses this technique or not.
81401>>>>>>>>>>>>>/// The attribute, however, can only be set inside of a Structure_Start or during
81401>>>>>>>>>>>>>/// table creation. Getting the attribute's value can be done at anytime. The
81401>>>>>>>>>>>>>/// value is stored as a boolean, either true or false.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT      FIELD_AUTOINCREMENT_TYPE
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
81401>>>>>>>>>>>>>/// @Param  variable                    Boolean variable indicating if the field auto increments.
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iColumn
81401>>>>>>>>>>>>>/// Boolean bIncrement
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to True
81401>>>>>>>>>>>>>///     Get_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to bIncrement
81401>>>>>>>>>>>>>///     Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FIELD_AUTO_INCREMENT                      For (DF_FIELD_NATIVE_LENGTH+16)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_GENERATE_ALWAYS                     For (DF_FIELD_NATIVE_LENGTH+18)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_SEND_LONG_DATA                      For 702
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_NATIVE_CREATED
81401>>>>>>>>>>>>>/// @Description Use this attribute to verify if the index that maps to the DataFlex
81401>>>>>>>>>>>>>/// index was created correctly at the SQL backend
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Wil van Antwerpen
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NATIVE_CREATED of {FileNumber} {IndexNumber} to variable
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
81401>>>>>>>>>>>>>/// @Param  variable              True if created, false if not
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Handle  hFile
81401>>>>>>>>>>>>>/// Integer iIndex
81401>>>>>>>>>>>>>/// Boolean bCreated
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>/// Move 1 To iIndex
81401>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_NATIVE_CREATED of hFile iIndex to bCreated
81401>>>>>>>>>>>>>Define DF_INDEX_NATIVE_CREATED                      For (DF_INDEX_KEY_LENGTH+1)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_NAME
81401>>>>>>>>>>>>>/// @Description Use this attribute to get the name of the index on the SQL backend
81401>>>>>>>>>>>>>/// that maps to the numbered index in Dataflex.  This is because, unlike Dataflex,
81401>>>>>>>>>>>>>/// all indexes in SQL are stored as names, not numbers. Since this attribute is
81401>>>>>>>>>>>>>/// currently only a ReadOnly attribute, it can not be used to set or modify a named
81401>>>>>>>>>>>>>/// index.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NAME of {FileNumber} {IndexNumber} to variable
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
81401>>>>>>>>>>>>>/// @Param  variable              Name of the index
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iFile iIndex iIndexes
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Open Orderhea
81401>>>>>>>>>>>>>/// Move Orderhea.File_Number to iFile
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// For iIndex From 0 to iIndexes
81401>>>>>>>>>>>>>///     Get_Attribute DF_INDEX_NAME of iFile iIndex to sIndexName
81401>>>>>>>>>>>>>///     Showln "Orderhea.Index." iIndex " : " sIndexName
81401>>>>>>>>>>>>>/// Loop
81401>>>>>>>>>>>>>Define DF_INDEX_NAME                                For (DF_INDEX_KEY_LENGTH+2)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_PRIMARY_KEY
81401>>>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
81401>>>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
81401>>>>>>>>>>>>>/// done at any time, but setting the index must be during a
81401>>>>>>>>>>>>>/// Structure_Start or during table creation.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Deprecated
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See                 DF_INDEX_PRIMARY_KEY
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iKey
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_PRIMARY_KEY of hFile to 2
81401>>>>>>>>>>>>>///     Get_Attribute DF_PRIMARY_KEY of hFile to iKey
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_PRIMARY_KEY                               For (DF_INDEX_KEY_LENGTH+3)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_PRIMARY_KEY
81401>>>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
81401>>>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
81401>>>>>>>>>>>>>/// done at any time, but setting the index must be during a
81401>>>>>>>>>>>>>/// Structure_Start or during table creation.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT              PRIMARY_KEY
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iKey
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_INDEX_PRIMARY_KEY of hFile to 2
81401>>>>>>>>>>>>>///     Get_Attribute DF_INDEX_PRIMARY_KEY of hFile to iKey
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_INDEX_PRIMARY_KEY                         For (DF_INDEX_KEY_LENGTH+3)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_STATUS
81401>>>>>>>>>>>>>/// @Description Oracle has an attribute for indexes called "STATUS" which indicates
81401>>>>>>>>>>>>>/// whether or not an index is valid for use. This attribute can only be used to get
81401>>>>>>>>>>>>>/// the value of the "STATUS" property in Oracle. It currently does not support setting
81401>>>>>>>>>>>>>/// the attribute. The two values for this attribute are "VALID" or "UNUSABLE".
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     ORAFlex
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_STATUS of {FileNumber} {IndexNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
81401>>>>>>>>>>>>>/// @Param  variable              String indicating validity
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// String sIndexStatus
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_STATUS of Customer.File_Number 1 to sIndexStatus
81401>>>>>>>>>>>>>Define DF_INDEX_STATUS                              For (DF_INDEX_KEY_LENGTH+4)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_STORAGE_PCTFREE                     For (DF_INDEX_KEY_LENGTH+5)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_INDEX_UNIQUE
81401>>>>>>>>>>>>>/// @Description An index on a column that is unique is considered so if it
81401>>>>>>>>>>>>>/// does not have two equal values in that column in two different rows. This
81401>>>>>>>>>>>>>/// attribute is used to find out whether or not the specified index is unique.
81401>>>>>>>>>>>>>/// If it is, this attribute will return "U" indicating that it is indeed unique.
81401>>>>>>>>>>>>>/// This is important to note because when getting the value of this attribute,
81401>>>>>>>>>>>>>/// a string variable must be used. Since this is a ReadOnly attribute, setting
81401>>>>>>>>>>>>>/// an idex to unique cannot be done with this attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_UNIQUE of {FileNumber} {IndexNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
81401>>>>>>>>>>>>>/// @Param  variable              String indicating if unique
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// String sIndexUnique
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_UNIQUE of Customer.File_Number 1 to sIndexUnique
81401>>>>>>>>>>>>>Define DF_INDEX_UNIQUE                              For (DF_INDEX_KEY_LENGTH+6)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_STORAGE_BASE                        For (DF_INDEX_KEY_LENGTH+7)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_STORAGE_INITIAL                     For (DF_INDEX_KEY_LENGTH+8)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_STORAGE_NEXT                        For (DF_INDEX_KEY_LENGTH+10)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_INDEX_NATIVE_TYPE                         For (DF_INDEX_KEY_LENGTH+13)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_INDEX_TABLESPACE                          For (DF_INDEX_KEY_LENGTH+14)
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FIELD_PROGRAMMATIC_DEFAULT                For 701
81401>>>>>>>>>>>>>Define DF_FIELD_TIME                                For 703
81401>>>>>>>>>>>>>Define DF_FIELD_IS_NULL                             For 704
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FIELD_IS_LOB
81401>>>>>>>>>>>>>/// @Description In databases a LOB data type is any type that is considered
81401>>>>>>>>>>>>>/// a "Large Object" i.e. XML types, Binary types etc.  This attribute is a
81401>>>>>>>>>>>>>/// ReadOnly attribute used to indicate whether the given field is considered
81401>>>>>>>>>>>>>/// a LOB data type. Since it is ReadOnly, this attribute cannot set a field
81401>>>>>>>>>>>>>/// to a LOB data type.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_IS_LOB of {FileNumber} {FieldNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param      FieldNumber                       Number of the field
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if LOB
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Boolean bIsLOB
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_IS_LOB of Customer.File_Number 6 to bIsLOB
81401>>>>>>>>>>>>>Define DF_FIELD_IS_LOB                              For 706
81401>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_FUNCTION                    For 707
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_HANDLE_AS_LOB                       For 708
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_FIELD_PARTIAL_OVERLAP                     For 710
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_NUMBER_SQL_RELATIONS
81401>>>>>>>>>>>>>/// @Description This attribute is used to get the number of foreign keys
81401>>>>>>>>>>>>>/// for a given table on the SQL backend. Foreign keys are used to specify
81401>>>>>>>>>>>>>/// relationships between tables. Since this attribute is ReadOnly, it cannot
81401>>>>>>>>>>>>>/// be used to set the number of foreign keys in a table.  Note that this
81401>>>>>>>>>>>>>/// attribute returns only the number of foreign keys, no other information
81401>>>>>>>>>>>>>/// is provided with this attribute.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// This is a ReadOnly attribute
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Integer variable showing number of relationships
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Integer iRelations
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of Customer.File_Number to iRelations
81401>>>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS                 For 626
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//TODO
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN                       For 716
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA               For 717
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE                For 719
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN               For 721
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_NAME                         For 723
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_STATUS                       For 724
81401>>>>>>>>>>>>>Define DF_SQL_RELATION_DELETE_REF_ACTION            For 726
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_START                       For 728
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_END                         For 730
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_START                For 732
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Currently Unsupported Attribute
81401>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_END                  For 734
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_TABLE
81401>>>>>>>>>>>>>/// @Description Dataflex's embedded database, by default, uses a Recnum column
81401>>>>>>>>>>>>>/// as the unique identifier for a table instead of a primary key. A table can
81401>>>>>>>>>>>>>/// easily be changed to use another column though and this attribute gets or
81401>>>>>>>>>>>>>/// sets whether the Recnum is being used for a table. Getting the value of this
81401>>>>>>>>>>>>>/// attribute can be done at any time for any driver. The setting of this attribute,
81401>>>>>>>>>>>>>/// however, can only be done in certain situations. Only if an alternative primary
81401>>>>>>>>>>>>>/// key is set up already can this attribute be set to false and only during a
81401>>>>>>>>>>>>>/// Structure_Start. Also, the attribute can only be turned off (set to false),
81401>>>>>>>>>>>>>/// it can not be turned back on (set to True).
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: In Postgres, this attribute is a ReadOnly attribute and can not be set.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME DF_FILE_PRIMARY_INDEX
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if recnum is used
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Boolean bRecnum
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to False
81401>>>>>>>>>>>>>///     Get_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to bRecnum
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FILE_RECNUM_TABLE                         For 1401
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_PRIMARY_INDEX
81401>>>>>>>>>>>>>/// @Description This attribute gets or sets the index which is used as the
81401>>>>>>>>>>>>>/// primary key for a table. The variable used for this attribute is an integer
81401>>>>>>>>>>>>>/// containing the numbered index used. Getting the value of this attribute can
81401>>>>>>>>>>>>>/// be done at any time, whereas setting can only be done at table creation or
81401>>>>>>>>>>>>>/// during a Structure_Start. If a RECNUM is used as the unique identifier then
81401>>>>>>>>>>>>>/// 0 is returned.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Note: In Postgres this attribute is ReadOnly, so it can only be used to get
81401>>>>>>>>>>>>>/// the index used as the primary key.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if a primary key is used
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Boolean bPrimary
81401>>>>>>>>>>>>>/// Handle hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Structure_Start hFile
81401>>>>>>>>>>>>>///     Set_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to False
81401>>>>>>>>>>>>>///     Get_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to bPrimary
81401>>>>>>>>>>>>>/// Structure_End hFile
81401>>>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX                        For 1402
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_NAME
81401>>>>>>>>>>>>>/// @Description This attribute is used to get the name of the Recnum field
81401>>>>>>>>>>>>>/// in the table, if one exists. It is a ReadOnly attribute so it can only
81401>>>>>>>>>>>>>/// be used in getting the name of the recnum field to a string variable.
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Assumptions
81401>>>>>>>>>>>>>/// @Status      Public
81401>>>>>>>>>>>>>/// @Drivers     All
81401>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
81401>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_TABLE
81401>>>>>>>>>>>>>/// @INTOPT
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_NAME of {FileNumber} to {variable}
81401>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
81401>>>>>>>>>>>>>/// @Param  variable              String name of recnum field
81401>>>>>>>>>>>>>/// @Example
81401>>>>>>>>>>>>>/// Open Customer
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// String sRecnum
81401>>>>>>>>>>>>>///
81401>>>>>>>>>>>>>/// Get_Attribute DF_FILE_RECNUM_NAME of Customer.File_Number to sRecnum
81401>>>>>>>>>>>>>Define DF_FILE_RECNUM_NAME                          For 1403
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define DF_FETCH_ALL                                 For -1
81401>>>>>>>>>>>>>Define DF_FETCH_TRUE                                For "TRUE"
81401>>>>>>>>>>>>>Define DF_FETCH_FALSE                               For "FALSE"
81401>>>>>>>>>>>>>Define DF_BIND_ALL_COLUMNS                          For -1
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// SQLFlex Lock Type
81401>>>>>>>>>>>>>Define DF_LOCK_TYPE_PAGE                            For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Extended Callback Types
81401>>>>>>>>>>>>>Define DF_MESSAGE_ERROR                             For 9
81401>>>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_STATUS                   For 20
81401>>>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_CONTINUE                 For 21
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Drivers
81401>>>>>>>>>>>>>Define ORAFLEX                                      For "ORA_DRV"
81401>>>>>>>>>>>>>Define SQLFLEX                                      For "SQL_DRV"
81401>>>>>>>>>>>>>Define MDSDB2                                       For "MDS_DB2"
81401>>>>>>>>>>>>>Define MDSPgSQL                                     For "MDSPGSQL"
81401>>>>>>>>>>>>>Define PgFlex                                       For "MDSPGSQL"
81401>>>>>>>>>>>>>Define MDSMySQL                                     For "MDSMYSQL"
81401>>>>>>>>>>>>>Define MySQLFlex                                    For "MDSMYSQL"
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Delimiter for SQL ID objects
81401>>>>>>>>>>>>>Define DB2_ID_DELIM                                 For '"'
81401>>>>>>>>>>>>>Define MYSQL_ID_DELIM                               For "`"
81401>>>>>>>>>>>>>Define ORACLE_ID_DELIM                              For '"'
81401>>>>>>>>>>>>>Define PGSQL_ID_DELIM                               For '"'
81401>>>>>>>>>>>>>Define SQLSERVER_ID_DELIM                           For '"'
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// dfStructureEnd Option bits
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_INDEX_ONLY                  For 16    // Internal Use Only
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_INVK                  For 32
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_OLD_INVK_NAME               For 64
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_NOT_NULL              For 128
81401>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_CREATE_ROWID_TABLE          For 256
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Additional Data Types
81401>>>>>>>>>>>>>Define DF_DATETIME                                  For 7
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Call_Driver Functions
81401>>>>>>>>>>>>>Define CALLDRV_LICENSE_ENVIRONMENT_SET              For 0
81401>>>>>>>>>>>>>Define CALLDRV_ORA_CURRENT_SQL_SERVER               For 6
81401>>>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE                    For 14
81401>>>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER                   for 19
81401>>>>>>>>>>>>>Define CALLDRV_SQL_NEXT_RESULTSET                                       for 22
81401>>>>>>>>>>>>>Define CALLDRV_BIND_PARAMETER                       for 23
81401>>>>>>>>>>>>>Define CALLDRV_SQL_MAX_CURSORS                      For 26
81401>>>>>>>>>>>>>Define CALLDRV_SQLLOADER_FIELDS_TERM                For 30
81401>>>>>>>>>>>>>Define CALLDRV_CREATE_TABLE_FROM_DAT                For 30
81401>>>>>>>>>>>>>Define CALLDRV_SQLLOADER_DECIMAL_SEP                For 31
81401>>>>>>>>>>>>>Define CALLDRV_CONVERT_DAT_FILE                     For 32
81401>>>>>>>>>>>>>Define CALLDRV_SQLFLEX_MAX_CURSORS                  For 37
81401>>>>>>>>>>>>>Define CALLDRV_NATIVE_OPTIMIZATION                  For 38
81401>>>>>>>>>>>>>Define CALLDRV_GET_RETURNED_COLUMNS                 For 39
81401>>>>>>>>>>>>>Define CALLDRV_GET_RETURNED_ROWS                    For 40
81401>>>>>>>>>>>>>Define CALLDRV_GET_COLUMN_ATTRIBUTE                 For 41
81401>>>>>>>>>>>>>Define CALLDRV_START_TXTGEN_AFTER_RECNUM            For 42
81401>>>>>>>>>>>>>Define CALLDRV_FINISH_TXTGEN_AFTER_RECNUM           For 43
81401>>>>>>>>>>>>>Define CALLDRV_SET_ISOLATION_LEVEL                  For 44
81401>>>>>>>>>>>>>Define CALLDRV_GET_SERVER_CFG                       For 45
81401>>>>>>>>>>>>>Define CALLDRV_SET_SQL_LOCK_TIMEOUT                 For 46
81401>>>>>>>>>>>>>Define CALLDRV_GET_SQL_LOCK_TIMEOUT                 For 47
81401>>>>>>>>>>>>>Define CALLDRV_GET_RESULTS                          For 48
81401>>>>>>>>>>>>>Define CALLDRV_GET_MORE_RESULTS                     For 49
81401>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_NAME                For 50
81401>>>>>>>>>>>>>Define CALLDRV_OPEN_EMBEDDED_CURSOR                 For 51
81401>>>>>>>>>>>>>Define CALLDRV_CLOSE_EMBEDDED_CURSOR                For 52
81401>>>>>>>>>>>>>Define CALLDRV_SET_CURRENT_EMBEDDED_CURSOR          For 53
81401>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_EMBEDDED_CURSOR          For 54
81401>>>>>>>>>>>>>Define CALLDRV_SET_MAX_EMBEDDED_CURSOR              For 55
81401>>>>>>>>>>>>>Define CALLDRV_GET_MAX_EMBEDDED_CURSOR              For 56
81401>>>>>>>>>>>>>Define CALLDRV_SQL_TRANSACTION                      For 57
81401>>>>>>>>>>>>>Define CALLDRV_LOCAL_TD_PATH                        For 58
81401>>>>>>>>>>>>>Define CALLDRV_CREATE_DB                            For 59
81401>>>>>>>>>>>>>Define CALLDRV_ESCAPE_STRING                        For 60
81401>>>>>>>>>>>>>Define CALLDRV_SET_PROC_ATTRIBUTE_TYPE              For 61
81401>>>>>>>>>>>>>Define CALLDRV_SQL_REFRESH_CACHE                    For 62
81401>>>>>>>>>>>>>Define CALLDRV_GET_SQL_STMT                         For 63
81401>>>>>>>>>>>>>Define CALLDRV_DIRECT_PATH_LOAD                     For 64
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>Define CALLDRV_READ_LOB                             For 65
81401>>>>>>>>>>>>>Define CALLDRV_WRITE_LOB                            For 66
81401>>>>>>>>>>>>>Define CALLDRV_APPEND_LOB                           For 67
81401>>>>>>>>>>>>>Define CALLDRV_LENGTH_LOB                           For 68
81401>>>>>>>>>>>>>Define CALLDRV_LOADFROMFILE_LOB                     For 69
81401>>>>>>>>>>>>>Define CALLDRV_ERASE_LOB                            For 70
81401>>>>>>>>>>>>>Define CALLDRV_TRUNCATE_LOB                         For 71
81401>>>>>>>>>>>>>Define CALLDRV_INITIALIZE_SEQUENCE                  For 72
81401>>>>>>>>>>>>>Define CALLDRV_CLIENT_CFG                           For 73
81401>>>>>>>>>>>>>Define CALLDRV_END_SAVERECORD                       For 74
81401>>>>>>>>>>>>>Define CALLDRV_ENABLE_RECONNECT                     For 75
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER                     For 76
81401>>>>>>>>>>>>>Define CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS         For 77
81401>>>>>>>>>>>>>Define CALLDRV_USE_DFLEX_DATE_FORMAT                For 78
81401>>>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NOT_NULL                For 79
81401>>>>>>>>>>>>>Define CALLDRV_ORA_CREATE_TABLE_FROM_DAT            For 80
81401>>>>>>>>>>>>>Define CALLDRV_MAX_DATA_SIZE                        For 81
81401>>>>>>>>>>>>>Define CALLDRV_CHUNK_SIZE                           For 82
81401>>>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK                       For 83
81401>>>>>>>>>>>>>Define CALLDRV_MIRROR_SERVER                        For 84
81401>>>>>>>>>>>>>Define CALLDRV_COPY_DATA                            For 85
81401>>>>>>>>>>>>>Define CALLDRV_SET_SQL_CURSOR_TYPE                  For 86
81401>>>>>>>>>>>>>Define CALLDRV_ICF                                  For 87
81401>>>>>>>>>>>>>Define CALLDRV_CLEAR_INT_CACHE                      For 88
81401>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_PASSWORD            For 89
81401>>>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NULL                    For 90
81401>>>>>>>>>>>>>Define CALLDRV_TRANSACTIONS_ALLOWED                 For 91
81401>>>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE2                   For 92
81401>>>>>>>>>>>>>Define CALLDRV_PGSQL_NAME_SPACE                     For 93
81401>>>>>>>>>>>>>Define CALLDRV_EMBEDDED_SQL_TYPE                    For 94
81401>>>>>>>>>>>>>Define CALLDRV_CREATE_INVK_FUNCTIONS                For 95
81401>>>>>>>>>>>>>Define CALLDRV_DEFAULT_FILE_CASING                  For 96
81401>>>>>>>>>>>>>Define CALLDRV_GLOBAL_SETTING                       For 97
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT                   For 98
81401>>>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER_CONNECTION        For 99
81401>>>>>>>>>>>>>Define CALLDRV_100                                  For 100
81401>>>>>>>>>>>>>Define CALLDRV_FILE_STRUCT_DYNAMIC_ONLINE           For 101
81401>>>>>>>>>>>>>Define CALLDRV_SET_FIXED_FILE_RECORDS_USED          For 102
81401>>>>>>>>>>>>>Define CALLDRV_GET_FIXED_FILE_RECORDS_USED          For 103
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_WRITE                         For 104
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_APPEND                        For 105
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_READ                          For 106
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_GET_LENGTH                    For 107
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_LENGTH                    For 108
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_TEST                          For 109
81401>>>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_NULL                      For 110
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// License and environment settings
81401>>>>>>>>>>>>>Define CALLDRV_DRIVER_REVISION                      For 0
81401>>>>>>>>>>>>>Define CALLDRV_COMPANY_NAME                         For 1
81401>>>>>>>>>>>>>Define CALLDRV_SERIAL_NUMBER                        For 2
81401>>>>>>>>>>>>>Define CALLDRV_LICENSED_USERS                       For 3
81401>>>>>>>>>>>>>Define CALLDRV_MAJOR_REVISION                       For 4
81401>>>>>>>>>>>>>Define CALLDRV_VERSION_COMMENTS                     For 5
81401>>>>>>>>>>>>>Define CALLDRV_OLEDB_OEM_TRANSLATION                For 6
81401>>>>>>>>>>>>>Define CALLDRV_SET_DB_PORT                          For 7
81401>>>>>>>>>>>>>Define CALLDRV_GET_DB_PORT                          For 8
81401>>>>>>>>>>>>>Define CALLDRV_SET_DB_SOCKET                        For 9
81401>>>>>>>>>>>>>Define CALLDRV_GET_DB_SOCKET                        For 10
81401>>>>>>>>>>>>>Define CALLDRV_SET_AS_SYSDBA                        For 11
81401>>>>>>>>>>>>>Define CALLDRV_OEM_TRANSLATION_STATE                For 12
81401>>>>>>>>>>>>>Define CALLDRV_TIME_TO_LIC_EXPIRATION               For 13
81401>>>>>>>>>>>>>Define CALLDRV_LICENSE_EXPIRATION_WARN              For 14
81401>>>>>>>>>>>>>Define CALLDRV_LICENSE_PATH                         For 15
81401>>>>>>>>>>>>>Define CALLDRV_AUTO_NUMERIC_REMAPPING               For 16
81401>>>>>>>>>>>>>Define CALLDRV_FORCE_DATE_FORMAT_INIT               For 17
81401>>>>>>>>>>>>>Define CALLDRV_STATIC_TABLE_OPT                     For 18
81401>>>>>>>>>>>>>Define CALLDRV_MAX_OBJECT_NAME_LENGTH               For 19
81401>>>>>>>>>>>>>Define CALLDRV_USE_LAZY_OPEN_MODE                   For 20
81401>>>>>>>>>>>>>Define CALLDRV_SET_CUSTOM_OEM_TO_ANSI               For 21
81401>>>>>>>>>>>>>Define CALLDRV_GET_CUSTOM_OEM_TO_ANSI               For 22
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//CALLDRV_ENUMERATE_SERVER_OPTION
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_COUNT               For 0
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_SERVER              For 1
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//CALLDRV_DEFAULT_FILE_CASING
81401>>>>>>>>>>>>>Define FILE_CASING_UPPER                            For 0
81401>>>>>>>>>>>>>Define FILE_CASING_LOWER                            For 1
81401>>>>>>>>>>>>>Define FILE_CASING_KEEP                             For 2
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// CALLDRV_GLOBAL_SETTING
81401>>>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_SET                For 0
81401>>>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_GET                For 1
81401>>>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_SET          For 2
81401>>>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_GET          For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// CALLDRV_RESTRUCTURE_SCRIPT
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_ENABLE            For 0
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_DISABLE           For 1
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_SQL     For 2
81401>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_INT     For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// DF_SQL_RELATION_STATUS attributes
81401>>>>>>>>>>>>>Define FOREIGN_KEY_NONE                             For -1
81401>>>>>>>>>>>>>Define FOREIGN_KEY_CREATE                           For  0
81401>>>>>>>>>>>>>Define FOREIGN_KEY_ENABLE                           For  1
81401>>>>>>>>>>>>>Define FOREIGN_KEY_DISABLE                          For  2
81401>>>>>>>>>>>>>Define FOREIGN_KEY_DROP                             For  3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// DF_SQL_RELATION_DELETE_REF_ACTION attributes
81401>>>>>>>>>>>>>Define DELETE_REF_NONE                              For 0
81401>>>>>>>>>>>>>Define DELETE_REF_CASCADE                           For 1
81401>>>>>>>>>>>>>Define DELETE_REF_SET_NULL                          For 2
81401>>>>>>>>>>>>>Define DELETE_REF_SET_DEFAULT                       For 3
81401>>>>>>>>>>>>>Define DELETE_REF_RESTRICT                          For 4
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Embedded SQL Cursor Types
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_NONE           For 0
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_CLIENT         For 1
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_SERVER         For 2
81401>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_PARAMETERIZED  For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Driver Call Direction
81401>>>>>>>>>>>>>Define CALLDRV_VALUE_GET                            For 0
81401>>>>>>>>>>>>>Define CALLDRV_VALUE_SET                            For 1
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Inverse Key types
81401>>>>>>>>>>>>>Define REGULAR_SEG                                  For -1
81401>>>>>>>>>>>>>Define INVK_CASE_SEG                                For 0
81401>>>>>>>>>>>>>Define INVK_DESC_SEG                                For 1
81401>>>>>>>>>>>>>Define INVK_DESC_AND_CASE_SEG                       For 2
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//DB2 Index Types
81401>>>>>>>>>>>>>Define REG_INDEX                                    For 0
81401>>>>>>>>>>>>>Define REV_INDEX                                    For 1
81401>>>>>>>>>>>>>Define CLUST_INDEX                                  For 2
81401>>>>>>>>>>>>>Define REV_CLUST_INDEX                              For 3
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//Oracle Procedure Arguments type
81401>>>>>>>>>>>>>Define IS_NONE                                      For 0
81401>>>>>>>>>>>>>Define IS_IN                                        For 1
81401>>>>>>>>>>>>>Define IS_OUT                                       For 2
81401>>>>>>>>>>>>>Define IS_IN_OUT                                    For 3
81401>>>>>>>>>>>>>Define IS_RSET                                      For 4
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// SQL_GET_COL Attributes
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SIZE                      For 1
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DECIMALS                  For 2
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_LABEL                     For 3
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_COLUMN_NAME               For 4
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_TABLE_NAME                For 5
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SQLTYPE                   For 6
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_NULLABLE                  For 7
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DFTYPE                    For 8
81401>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DATA_LENGTH               For 9
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// MySQL Data Types
81401>>>>>>>>>>>>>Define eMySQL_DECIMAL                               For 0
81401>>>>>>>>>>>>>Define eMySQL_TINY                                  For 1
81401>>>>>>>>>>>>>Define eMySQL_SHORT                                 For 2
81401>>>>>>>>>>>>>Define eMySQL_LONG                                  For 3
81401>>>>>>>>>>>>>Define eMySQL_FLOAT                                 For 4
81401>>>>>>>>>>>>>Define eMySQL_DOUBLE                                For 5
81401>>>>>>>>>>>>>Define eMySQL_NULL                                  For 6
81401>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             For 7
81401>>>>>>>>>>>>>Define eMySQL_LONGLONG                              For 8
81401>>>>>>>>>>>>>Define eMySQL_INT24                                 For 9
81401>>>>>>>>>>>>>Define eMySQL_DATE                                  For 10
81401>>>>>>>>>>>>>Define eMySQL_TIME                                  For 11
81401>>>>>>>>>>>>>Define eMySQL_DATETIME                              For 12
81401>>>>>>>>>>>>>Define eMySQL_YEAR                                  For 13
81401>>>>>>>>>>>>>Define eMySQL_NEWDATE                               For 14
81401>>>>>>>>>>>>>Define eMySQL_BIT                                   For 16
81401>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            For 246
81401>>>>>>>>>>>>>Define eMySQL_ENUM                                  For 247
81401>>>>>>>>>>>>>Define eMySQL_SET                                   For 248
81401>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             For 249
81401>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           For 250
81401>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             For 251
81401>>>>>>>>>>>>>Define eMySQL_BLOB                                  For 252
81401>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            For 253
81401>>>>>>>>>>>>>Define eMySQL_STRING                                For 254
81401>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             For -249
81401>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           For -250
81401>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             For -251
81401>>>>>>>>>>>>>Define eMySQL_TEXT                                  For -252
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// Oracle Data Types
81401>>>>>>>>>>>>>Define eOracle_VARCHAR2                             For   1
81401>>>>>>>>>>>>>Define eOracle_NUMBER                               For   2
81401>>>>>>>>>>>>>Define eOracle_INT                                  For   3
81401>>>>>>>>>>>>>Define eOracle_FLOAT                                For   4
81401>>>>>>>>>>>>>Define eOracle_STRING                               For   5
81401>>>>>>>>>>>>>Define eOracle_LONG                                 For   8
81401>>>>>>>>>>>>>Define eOracle_ROWID                                For  11
81401>>>>>>>>>>>>>Define eOracle_DATE                                 For  12
81401>>>>>>>>>>>>>Define eOracle_RAW                                  For  23
81401>>>>>>>>>>>>>Define eOracle_LONGRAW                              For  24
81401>>>>>>>>>>>>>Define eOracle_CHAR                                 For  96
81401>>>>>>>>>>>>>Define eOracle_MSLABEL                              For 106
81401>>>>>>>>>>>>>Define eOracle_CLOB                                 For 112
81401>>>>>>>>>>>>>Define eOracle_BLOB                                 For 113
81401>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            For 187
81401>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          For 188
81401>>>>>>>>>>>>>Define eOracle_INTERVALYM                           For 189
81401>>>>>>>>>>>>>Define eOracle_INTERVALDS                           For 190
81401>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         For 232
81401>>>>>>>>>>>>>Define eOracle_NCHAR                                For 286
81401>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            For 287
81401>>>>>>>>>>>>>Define eOracle_NCLOB                                For 288
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// PostgreSQL Data Types
81401>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                For  718
81401>>>>>>>>>>>>>Define ePgSQL_MONEY                                 For  790
81401>>>>>>>>>>>>>Define ePgSQL_BOOL                                  For   16
81401>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 For   17
81401>>>>>>>>>>>>>Define ePgSQL_CHAR                                  For   18
81401>>>>>>>>>>>>>Define ePgSQL_INT2                                  For   21
81401>>>>>>>>>>>>>Define ePgSQL_INT4                                  For   23
81401>>>>>>>>>>>>>Define ePgSQL_REGPROC                               For   24
81401>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          For 2202
81401>>>>>>>>>>>>>Define ePgSQL_REGOPER                               For 2203
81401>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           For 2204
81401>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              For 2205
81401>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               For 2206
81401>>>>>>>>>>>>>Define ePgSQL_TEXT                                  For   25
81401>>>>>>>>>>>>>Define ePgSQL_CITEXT                                For  -25
81401>>>>>>>>>>>>>Define ePgSQL_OID                                   For   26
81401>>>>>>>>>>>>>Define ePgSQL_TID                                   For   27
81401>>>>>>>>>>>>>Define ePgSQL_XID                                   For   28
81401>>>>>>>>>>>>>Define ePgSQL_CID                                   For   29
81401>>>>>>>>>>>>>Define ePgSQL_XML                                   For  142
81401>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                For 1042
81401>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               For 1043
81401>>>>>>>>>>>>>Define ePgSQL_INT8                                  For   20
81401>>>>>>>>>>>>>Define ePgSQL_PATH                                  For  602
81401>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                For  700
81401>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                For  701
81401>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               For  702
81401>>>>>>>>>>>>>Define ePgSQL_RELTIME                               For  703
81401>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             For  704
81401>>>>>>>>>>>>>Define ePgSQL_POINT                                 For  600
81401>>>>>>>>>>>>>Define ePgSQL_LINE                                  For  628
81401>>>>>>>>>>>>>Define ePgSQL_LSEG                                  For  601
81401>>>>>>>>>>>>>Define ePgSQL_BOX                                   For  603
81401>>>>>>>>>>>>>Define ePgSQL_POLYGON                               For  604
81401>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               For 1033
81401>>>>>>>>>>>>>Define ePgSQL_MACADDR                               For  829
81401>>>>>>>>>>>>>Define ePgSQL_INET                                  For  869
81401>>>>>>>>>>>>>Define ePgSQL_CIDR                                  For  650
81401>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             For 1114
81401>>>>>>>>>>>>>Define ePgSQL_DATE                                  For 1082
81401>>>>>>>>>>>>>Define ePgSQL_TIME                                  For 1083
81401>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           For 1184
81401>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              For 1186
81401>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               For 1700
81401>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                For 1266
81401>>>>>>>>>>>>>Define ePgSQL_BIT                                   For 1560
81401>>>>>>>>>>>>>Define ePgSQL_VARBIT                                For 1562
81401>>>>>>>>>>>>>Define ePgSQL_UUID                                  For 2950
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>// SQL Server Data Types
81401>>>>>>>>>>>>>Define eSQLServer_NA                                For    0
81401>>>>>>>>>>>>>Define eSQLServer_CHAR                              For    1
81401>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           For    2
81401>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           For    3
81401>>>>>>>>>>>>>Define eSQLServer_INT                               For    4
81401>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          For    5
81401>>>>>>>>>>>>>Define eSQLServer_FLOAT                             For    6
81401>>>>>>>>>>>>>Define eSQLServer_REAL                              For    7
81401>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            For    8
81401>>>>>>>>>>>>>Define eSQLServer_DATETIME                          For   11
81401>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           For   12
81401>>>>>>>>>>>>>Define eSQLServer_DATE                              For   40
81401>>>>>>>>>>>>>Define eSQLServer_TIME                              For   41
81401>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         For   42
81401>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    For   43
81401>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     For   58
81401>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         For   93
81401>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       For  128
81401>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          For  129
81401>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         For  130
81401>>>>>>>>>>>>>Define eSQLServer_TEXT                              For   -1
81401>>>>>>>>>>>>>Define eSQLServer_BINARY                            For   -2
81401>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         For   -3
81401>>>>>>>>>>>>>Define eSQLServer_IMAGE                             For   -4
81401>>>>>>>>>>>>>Define eSQLServer_BIGINT                            For   -5
81401>>>>>>>>>>>>>Define eSQLServer_TINYINT                           For   -6
81401>>>>>>>>>>>>>Define eSQLServer_BIT                               For   -7
81401>>>>>>>>>>>>>Define eSQLServer_NCHAR                             For   -8
81401>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          For   -9
81401>>>>>>>>>>>>>Define eSQLServer_NTEXT                             For  -10
81401>>>>>>>>>>>>>Define eSQLServer_GUID                              For  -11
81401>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      For  -98
81401>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        For  -99
81401>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       For -100
81401>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        For -150
81401>>>>>>>>>>>>>Define eSQLServer_XML                               For -370
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>//Error Text
81401>>>>>>>>>>>>>//==========
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>//Define Self if needed
81401>>>>>>>>>>>>>//=====================
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>//=============================================================================
81401>>>>>>>>>>>>>//Define varibles we need
81401>>>>>>>>>>>>>//=======================
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    Define MertechInc_Variables_Defined
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    Indicator MertechInc_bThereIsBinding
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    Integer MertechInc_FileNumber      //Replaces _SAVEFILENUMBER# and FILENUMBER
81401>>>>>>>>>>>>>    Integer MertechInc_iArg            //Replaces _LLONG#
81401>>>>>>>>>>>>>    Integer MertechInc_iCallBack       //Replaces _CALLBACK#
81401>>>>>>>>>>>>>    Integer MertechInc_iCount          //General loop limit integer
81401>>>>>>>>>>>>>    Integer MertechInc_iDecSep         //Holds the decimal seperator
81401>>>>>>>>>>>>>    Integer MertechInc_iFunction       //Replaces _FID#    ??? check is this is need when tidy is complete
81401>>>>>>>>>>>>>    Integer MertechInc_iLoop           //General loop integer
81401>>>>>>>>>>>>>    Integer Mertech_iMySQLParam        //Replaces _ALL_PAR_POS#
81401>>>>>>>>>>>>>    Integer MertechInc_iParamCount     //Replaces _NPAR#
81401>>>>>>>>>>>>>    Integer MertechInc_iRet            //Replaces _RET#
81401>>>>>>>>>>>>>    Integer MertechInc_iSaveCount      //Replaces _NPOS#
81401>>>>>>>>>>>>>    Integer MertechInc_iWork           //General work integer
81401>>>>>>>>>>>>>    Integer MertechInc_iWork2
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    String MertechInc_Blank            //Replaces _BLANK#
81401>>>>>>>>>>>>>    String MertechInc_DriverName       //Replaces _DRIVERNAME#
81401>>>>>>>>>>>>>    String MertechInc_sArg1 255        //Replaces _ARG1#
81401>>>>>>>>>>>>>    String MertechInc_sArg2 255        //Replaces _ARG2#
81401>>>>>>>>>>>>>    String MertechInc_sWork 255        //General work string
81401>>>>>>>>>>>>>
81401>>>>>>>>>>>>>    String MertechInc_CurrentDriver    //Keep the current driver name
81401>>>>>>>>>>>>>    //Global string are created pre-filled with spaces. We need an empty string
81401>>>>>>>>>>>>>    Move "" to MertechInc_Blank
81402>>>>>>>>>>>>>    Move "" to MertechInc_CurrentDriver
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>//=============================================================================
81403>>>>>>>>>>>>>//Use Obsolete Code
81403>>>>>>>>>>>>>//=================
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>//=============================================================================
81403>>>>>>>>>>>>>//Comment Block Template
81403>>>>>>>>>>>>>//======================
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>/// @Name {Name of the command for indexing} (used for documentation)
81403>>>>>>>>>>>>>/// @Description {Short Command Description} (used for documentation)
81403>>>>>>>>>>>>>///     The description can be multiple lines, and contain HTML tags.
81403>>>>>>>>>>>>>///     The other tokens will have HTML encoded so we can show stuff
81403>>>>>>>>>>>>>///     like <param1> properly. A blank line will automatically be
81403>>>>>>>>>>>>>///         translated into a paragraph break in the documentation, so
81403>>>>>>>>>>>>>///     no need for <br> or <p> tags.
81403>>>>>>>>>>>>>///
81403>>>>>>>>>>>>>/// @Assumptions {Assumptions made in order for the command to work}
81403>>>>>>>>>>>>>/// @Status {Obsolete, Internal, or Public} (used for documentation)
81403>>>>>>>>>>>>>/// @Drivers {DB2Flex, MySQLFlex, ORAFlex, PgFlex, SQLFlex or All} (used for documentation)
81403>>>>>>>>>>>>>/// @VersionNote {Date and author of the last revision}
81403>>>>>>>>>>>>>/// @See {list of related commands}
81403>>>>>>>>>>>>>///
81403>>>>>>>>>>>>>/// @Syntax {Syntax of use} (used for documentation)
81403>>>>>>>>>>>>>/// @Param {Each parameter with a brief description} (used for documentation)
81403>>>>>>>>>>>>>/// @DBMS {List of supported databases}
81403>>>>>>>>>>>>>/// @DataFlex {List of supported DataFlex versions}
81403>>>>>>>>>>>>>/// @Usage {Different uses command can have multiple syntaxes} (used for documentation)
81403>>>>>>>>>>>>>///
81403>>>>>>>>>>>>>/// @Example {An example of the command being used} (used for documentation)
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>//=============================================================================
81403>>>>>>>>>>>>>/// @Name        DO_GETFILENUMBER_DRIVERNAME
81403>>>>>>>>>>>>>/// @Description Retrieves the current driver name and or the file number
81403>>>>>>>>>>>>>/// that will be used by the macro commands.
81403>>>>>>>>>>>>>///
81403>>>>>>>>>>>>>/// @Assumptions
81403>>>>>>>>>>>>>/// @Status      Internal Use Only
81403>>>>>>>>>>>>>/// @Drivers     All
81403>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-14 By Ian Smith
81403>>>>>>>>>>>>>/// @See
81403>>>>>>>>>>>>>
81403>>>>>>>>>>>>>//Most commands use DO_GETFILENUMBER_DRIVERNAME so this code was being duplicated
81403>>>>>>>>>>>>>//all the time. It has been moved to this method to remove that duplication.
81403>>>>>>>>>>>>>Procedure MertechInc_Get_Driver_name Global
81405>>>>>>>>>>>>>    //If we have a file number get its driver, else find first loaded Mertech driver
81405>>>>>>>>>>>>>    If MertechInc_FileNumber GT 0 ;        Get_Attribute DF_FILE_DRIVER of MertechInc_FileNumber to MertechInc_DriverName
81410>>>>>>>>>>>>>    Else Begin
81411>>>>>>>>>>>>>        If (MertechInc_CurrentDriver > "") Move MertechInc_CurrentDriver to MertechInc_DriverName
81414>>>>>>>>>>>>>        Else Begin
81415>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to MertechInc_iCount
81418>>>>>>>>>>>>>            For MertechInc_iLoop from 1 to MertechInc_iCount
81424>>>>>>>>>>>>>>
81424>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_NAME of MertechInc_iLoop to MertechInc_DriverName
81427>>>>>>>>>>>>>                Move (UPPERCASE(MertechInc_DriverName)) to MertechInc_DriverName
81428>>>>>>>>>>>>>                If (MertechInc_DriverName EQ ORAFLEX  or MertechInc_DriverName EQ SQLFLEX or MertechInc_DriverName EQ MDSDB2 or ;                    MertechInc_DriverName EQ MDSPgSQL or MertechInc_DriverName EQ MDSMySQL) Move MertechInc_iCount to MertechInc_iLoop
81431>>>>>>>>>>>>>                Else Move "" to MertechInc_DriverName
81433>>>>>>>>>>>>>            Loop
81434>>>>>>>>>>>>>>
81434>>>>>>>>>>>>>        End
81434>>>>>>>>>>>>>>
81434>>>>>>>>>>>>>    End
81434>>>>>>>>>>>>>>
81434>>>>>>>>>>>>>
81434>>>>>>>>>>>>>    //Ensure that we return a valid Mertech driver.
81434>>>>>>>>>>>>>    If (MertechInc_DriverName NE ORAFLEX  and ;        MertechInc_DriverName NE SQLFLEX  and ;        MertechInc_DriverName NE MDSDB2   and ;        MertechInc_DriverName NE MDSPgSQL and ;        MertechInc_DriverName NE MDSMySQL     ) ;        Begin
81436>>>>>>>>>>>>>
81436>>>>>>>>>>>>>        //Report invalid driver
81436>>>>>>>>>>>>>//        Error 25100 ("Invalid Driver - file" * String(MertechInc_FileNumber))
81436>>>>>>>>>>>>>//        Error 25100 ("Mertech.inc - Not a Mertech driver (file number " * String(MertechInc_FileNumber) * ")")
81436>>>>>>>>>>>>>        Error 25100 ("Mertech.inc - Not a Mertech driver. File" * String(MertechInc_FileNumber) * "Driver" * Trim(MertechInc_DriverName) )
81437>>>>>>>>>>>>>>
81437>>>>>>>>>>>>>
81437>>>>>>>>>>>>>        //Set MertechInc_FileNumber to MertechInc_Invalid_Driver so that the commands can
81437>>>>>>>>>>>>>        //determine if the driver is valid. MertechInc_FileNumber is use instead of
81437>>>>>>>>>>>>>        //MertechInc_DriverName as integer conparisons are quicker than string conparisons
81437>>>>>>>>>>>>>        Move MertechInc_Invalid_Driver to MertechInc_FileNumber
81438>>>>>>>>>>>>>    End
81438>>>>>>>>>>>>>>
81438>>>>>>>>>>>>>End_Procedure
81439>>>>>>>>>>>>>
81439>>>>>>>>>>>>>//=============================================================================
81439>>>>>>>>>>>>>/// @Name        MertechInc_Pre_Size_String
81439>>>>>>>>>>>>>/// @Description Returns a string full of spaces.
81439>>>>>>>>>>>>>///
81439>>>>>>>>>>>>>/// @Assumptions
81439>>>>>>>>>>>>>/// @Status      Internal
81439>>>>>>>>>>>>>/// @Drivers     n/a
81439>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-12-02 By Gandalf Hernandez
81439>>>>>>>>>>>>>/// @See
81439>>>>>>>>>>>>>Function MertechInc_Pre_Size_String Global Integer iSize Returns String
81441>>>>>>>>>>>>>   Local String sWork
81441>>>>>>>>>>>>>   Local Integer iBlocks iRemainder
81441>>>>>>>>>>>>>
81441>>>>>>>>>>>>>   If (iSize <= 1) Begin
81443>>>>>>>>>>>>>      // marcelo 06/28/2000 implemented logic to avoid VDF 7 crashing problems
81443>>>>>>>>>>>>>          If FMAC_VERSION eq 7 Move 1000 to iSize
81446>>>>>>>>>>>>>          Else Move 16384 to iSize
81448>>>>>>>>>>>>>   End
81448>>>>>>>>>>>>>>
81448>>>>>>>>>>>>>
81448>>>>>>>>>>>>>   // Build the string in blocks of 32, to speed things up
81448>>>>>>>>>>>>>   // If the string is less than 32 bytes, just fill it up regularly
81448>>>>>>>>>>>>>   Move (iSize / 32) to iBlocks
81449>>>>>>>>>>>>>   Move (Mod(iSize, 32)) to iRemainder
81450>>>>>>>>>>>>>
81450>>>>>>>>>>>>>   If (iBlocks > 0) Begin
81452>>>>>>>>>>>>>      Move (Repeat("                                ", iBlocks)) to sWork
81453>>>>>>>>>>>>>      Move (Append (sWork, (Repeat(" ", iRemainder)))) to sWork
81454>>>>>>>>>>>>>   End
81454>>>>>>>>>>>>>>
81454>>>>>>>>>>>>>   Else Move (Repeat(" ", iSize)) to sWork
81456>>>>>>>>>>>>>
81456>>>>>>>>>>>>>   Function_Return sWork
81457>>>>>>>>>>>>>End_Function
81458>>>>>>>>>>>>>
81458>>>>>>>>>>>>>//=============================================================================
81458>>>>>>>>>>>>>/// @Name        MertechInc_Set_DecSep
81458>>>>>>>>>>>>>/// @Description Saves the current decimal separator and sets the decimal
81458>>>>>>>>>>>>>/// separator to '.'.
81458>>>>>>>>>>>>>///
81458>>>>>>>>>>>>>/// @Assumptions
81458>>>>>>>>>>>>>/// @Status      Internal
81458>>>>>>>>>>>>>/// @Drivers     n/a
81458>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
81458>>>>>>>>>>>>>Procedure MertechInc_Set_DecSep Global
81460>>>>>>>>>>>>>    Get_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
81463>>>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to 46 // (.) WILL BE DECIMAL SEPARATOR
81468>>>>>>>>>>>>>End_Procedure
81469>>>>>>>>>>>>>
81469>>>>>>>>>>>>>//=============================================================================
81469>>>>>>>>>>>>>/// @Name        MertechInc_Reset_DecSep
81469>>>>>>>>>>>>>/// @Description Sets the decimal separator to the saved value.
81469>>>>>>>>>>>>>///
81469>>>>>>>>>>>>>/// @Status      Internal
81469>>>>>>>>>>>>>/// @Drivers     n/a
81469>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
81469>>>>>>>>>>>>>///
81469>>>>>>>>>>>>>Procedure MertechInc_Reset_DecSep Global
81471>>>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
81476>>>>>>>>>>>>>End_Procedure
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        FETCH_FIELD
81477>>>>>>>>>>>>>/// @Description Selects or de-selects the fields to be fetched during the
81477>>>>>>>>>>>>>/// next FIND (query).
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Status      Internal
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-16 By Ian Smith
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <FieldStart> THRU <FieldEnd> TO DF_FETCH_TRUE
81477>>>>>>>>>>>>>/// @Param  FileNum    is the File Number
81477>>>>>>>>>>>>>/// @Param  FieldStart is the Field Name or Number that will start the selection range
81477>>>>>>>>>>>>>/// @Param  FieldEnd   is the Field Name or Number that will finish the selection range
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <Field1> TO DF_FETCH_TRUE
81477>>>>>>>>>>>>>/// @Param  FileNum  is the File Number
81477>>>>>>>>>>>>>/// @Param  Field1 Fields Name or Number to be selected
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_TEXT_MESSAGE
81477>>>>>>>>>>>>>/// @Description Use this command to manually insert a string into a trace
81477>>>>>>>>>>>>>/// file. This can be useful for readability within the trace file to log
81477>>>>>>>>>>>>>/// what is actually happening at certain points.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions The text string is less than 80 characters long.
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 20013-08-19 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See         ENABLE_TRACE_ON DISABLE_TRACE_ON
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_TEXT_MESSAGE {variable}
81477>>>>>>>>>>>>>/// @Param  {variable}          The string to insert into the trace file.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Login "localhost" "mds" "mertech" "ora_drv"
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// ENABLE_TRACE_ON to "c:\trace.txt" DEBUG_LEVEL
81477>>>>>>>>>>>>>/// open Customer
81477>>>>>>>>>>>>>/// SQL_TEXT_MESSAGE "The table has been opened"
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name       SELECT_COLUMNS_FIND
81477>>>>>>>>>>>>>/// @Description This command is used to fetch only a certain number of fields
81477>>>>>>>>>>>>>/// while doing a "find". When specifying the field number to start from and
81477>>>>>>>>>>>>>/// field number to end on, the find will only fetch the given fields from the
81477>>>>>>>>>>>>>/// record. It is important to always use this command after first deselecting
81477>>>>>>>>>>>>>/// all columns i.e. setting RESET_FETCH_FIELDS to DF_FETCH_FALSE. Also, after
81477>>>>>>>>>>>>>/// using this command, all columns need to be reselected i.e. setting
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS to DF_FETCH_TRUE. Note that fields used as a part the
81477>>>>>>>>>>>>>/// index segment associated with the find will always be fetched regardless.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 20014-04-30 by Marcello Yo
81477>>>>>>>>>>>>>/// @See         RESET_FETCH_FIELDS DISABLE_SELECT_COLUMNS_ERRORS
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SELECT_COLUMNS_FIND {FileNumber} {fieldStart} THRU {fieldEnd}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>/// @Param  fieldStart          The field number to start the fetch from
81477>>>>>>>>>>>>>/// @Param  FieldEnd            The field number to end the fetch at
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Open Customer
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
81477>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
81477>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// Clear Customer
81477>>>>>>>>>>>>>/// Repeat
81477>>>>>>>>>>>>>///    Find Gt Customer by Index.1
81477>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
81477>>>>>>>>>>>>>/// Until (Not(Found))
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        RESET_FETCH_FIELDS
81477>>>>>>>>>>>>>/// @Description This command is used to specify whether to retrieve all columns
81477>>>>>>>>>>>>>/// or no columns when performing a find. It is usually used with the command
81477>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND to reset the column fetching. This command can either be
81477>>>>>>>>>>>>>/// set to DF_FETCH_TRUE, which will fetch all columns or set to DF_FETCH_FALSE,
81477>>>>>>>>>>>>>/// which will fetch no columns.
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Marcello Yo
81477>>>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND DISABLE_SELECT_COLUMNS_ERRORS
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax RESET_FETCH_FIELDS {FileNumber} {DF_FETCH_TRUE/DF_FETCH_FALSE}
81477>>>>>>>>>>>>>/// @Param  FileNumber                  The number of the file
81477>>>>>>>>>>>>>/// @Param  DF_FETCH_TRUE               fetch all columns
81477>>>>>>>>>>>>>/// @Param  DF_FETCH_FALSE              fetch no columns
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Open Customer
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
81477>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
81477>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// Clear Customer
81477>>>>>>>>>>>>>/// Repeat
81477>>>>>>>>>>>>>///    Find Gt Customer by Index.1
81477>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
81477>>>>>>>>>>>>>/// Until (Not(Found))
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_FOR_ONEROW
81477>>>>>>>>>>>>>/// @Description This command will instruct the driver to fetch one row
81477>>>>>>>>>>>>>/// per query
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Deprecated
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_FOR_ONEROW {FileNumber}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>///     open Customer
81477>>>>>>>>>>>>>///     SQL_FOR_ONEROW Customer.File_Number
81477>>>>>>>>>>>>>///     Repeat
81477>>>>>>>>>>>>>///             find gt Customer by Recnum
81477>>>>>>>>>>>>>///         If (Found) Begin
81477>>>>>>>>>>>>>///             showln "Sales name is " Customer.FirstName
81477>>>>>>>>>>>>>///         end
81477>>>>>>>>>>>>>///     until (Customer.ID = 10)
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_REFRESH_CACHE
81477>>>>>>>>>>>>>/// @Description For optimization during record retrieval, a set number of
81477>>>>>>>>>>>>>/// records are stored in a local cache. This command forces a refresh, by
81477>>>>>>>>>>>>>/// making the next find retrieve the record from the database instead of
81477>>>>>>>>>>>>>/// the cache.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_REFRESH_CACHE OF {FileNumber}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Open Customer
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// Find gt Customer by Index.1
81477>>>>>>>>>>>>>/// While (Found) Begin
81477>>>>>>>>>>>>>///     showln "Customer name is " CUSTOMER.CUSTOMER
81477>>>>>>>>>>>>>/// Loop
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// SQL_REFRESH_CACHE of CUSTOMER
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_FOR_SET
81477>>>>>>>>>>>>>/// @Description Use this command during LT or GT finds to only fetch a set
81477>>>>>>>>>>>>>/// number of rows. An option is also available for this command to disable
81477>>>>>>>>>>>>>/// the local cash by passing NOCACHE at the end of the command call. Note
81477>>>>>>>>>>>>>/// that if the rowcount is set low, too many round-trips to the server may
81477>>>>>>>>>>>>>/// result, effecting performance significantly. Also, if the rowcount is set
81477>>>>>>>>>>>>>/// too high a large number of records can be pre-fetched and end up not being
81477>>>>>>>>>>>>>/// used by the application. Because of this, the default of 10 rows and a cache
81477>>>>>>>>>>>>>/// will be adequate for most situations.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions
81477>>>>>>>>>>>>>/// @Status      Public
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_FOR_SET {FileNumber} MAXROWS {variable} {CACHE/NOCACHE}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>/// @Param  variable            The maximum number of rows to retrieve
81477>>>>>>>>>>>>>/// @Param  CACHE               fetched rows will be kept at the local cache
81477>>>>>>>>>>>>>/// @Param  NOCACHE             fetched rows will not be kept at the local cache
81477>>>>>>>>>>>>>/// @Example
81477>>>>>>>>>>>>>/// Open Customer
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// SQL_FOR_SET Customer MAXROWS 15 CACHE
81477>>>>>>>>>>>>>/// find gt Customer by Index.1
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>//=============================================================================
81477>>>>>>>>>>>>>/// @Name        SQL_SET
81477>>>>>>>>>>>>>/// @Description Initializes and sets an initial statement for embedded
81477>>>>>>>>>>>>>/// sql execution.
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81477>>>>>>>>>>>>>/// @Status      Deprecated
81477>>>>>>>>>>>>>/// @Drivers     All
81477>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81477>>>>>>>>>>>>>/// @See         SQL_SET_STMT
81477>>>>>>>>>>>>>///
81477>>>>>>>>>>>>>/// @Syntax SQL_SET {FileNumber}
81477>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
81477>>>>>>>>>>>>>
81477>>>>>>>>>>>>>Procedure MertechInc_SQL_SET Global String sStatement
81479>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 1 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
81484>>>>>>>>>>>>>End_Procedure
81485>>>>>>>>>>>>>
81485>>>>>>>>>>>>>//=============================================================================
81485>>>>>>>>>>>>>/// @Name        SQL_APPEND
81485>>>>>>>>>>>>>/// @Description Appends a string value to the current embedded sql statement
81485>>>>>>>>>>>>>/// already set.
81485>>>>>>>>>>>>>///
81485>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81485>>>>>>>>>>>>>/// @Status      Deprecated
81485>>>>>>>>>>>>>/// @Drivers     All
81485>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81485>>>>>>>>>>>>>/// @See                 SQL_APPEND_STMT
81485>>>>>>>>>>>>>
81485>>>>>>>>>>>>>Procedure MertechInc_SQL_APPEND Global String sStatement
81487>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 2 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
81492>>>>>>>>>>>>>End_Procedure
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>//=============================================================================
81493>>>>>>>>>>>>>/// @Name        SQL_EXECUTE
81493>>>>>>>>>>>>>/// @Description Executes the current embedded SQL statement set and commits
81493>>>>>>>>>>>>>/// finishing any pending transaction.
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Assumptions
81493>>>>>>>>>>>>>/// @Status      Deprecated
81493>>>>>>>>>>>>>/// @Drivers     All
81493>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81493>>>>>>>>>>>>>/// @See                 SQL_EXECUTE_STMT
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>//=============================================================================
81493>>>>>>>>>>>>>/// @Name        LOCK_TABLE
81493>>>>>>>>>>>>>/// @Description Locks a table. This is equivalent to locking a DAT file.
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Assumptions
81493>>>>>>>>>>>>>/// @Status      Deprecated
81493>>>>>>>>>>>>>/// @Drivers     DB2Flex, and ORAFlex 3.x
81493>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81493>>>>>>>>>>>>>/// @See
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Syntax LOCK_TABLE {FileName} {FileName1} {FileName2} {FileName3}...
81493>>>>>>>>>>>>>/// @Param  FileName            The name of file to be locked. Can be more than one
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>//=============================================================================
81493>>>>>>>>>>>>>/// @Name        SQL_CHECK_TABLE
81493>>>>>>>>>>>>>/// @Description Use this command to verify that a given table exists on the
81493>>>>>>>>>>>>>/// SQL backend. This command takes three arguments, a string containing the
81493>>>>>>>>>>>>>/// name of the database, a string containing the name of the user and finally
81493>>>>>>>>>>>>>/// a string containing the name of the table being checked. If the table exists,
81493>>>>>>>>>>>>>/// the program proceeds normally. If the table does not exist then the flag
81493>>>>>>>>>>>>>/// "finderr" is set to true. Note that in order to handle the error a check must
81493>>>>>>>>>>>>>/// be done on the "finderr" variable.
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Assumptions All three parameters are less than 256 characters long.
81493>>>>>>>>>>>>>/// @Status      Public
81493>>>>>>>>>>>>>/// @Drivers     All
81493>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81493>>>>>>>>>>>>>/// @See
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Syntax SQL_CHECK_TABLE {database} {username} {table}
81493>>>>>>>>>>>>>/// @Param  database            Name of the database
81493>>>>>>>>>>>>>/// @Param  username            Name of the user
81493>>>>>>>>>>>>>/// @Param  table                       Name of the table being checked
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Example
81493>>>>>>>>>>>>>/// SQL_CHECK_TABLE "testDB" "user" "Customer"
81493>>>>>>>>>>>>>/// If (finderr) Begin
81493>>>>>>>>>>>>>///     Showln "This table does not exist"
81493>>>>>>>>>>>>>/// End
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>//=============================================================================
81493>>>>>>>>>>>>>/// @Name        SET_SQL_CONSTRAINT
81493>>>>>>>>>>>>>/// @Description This command allows you to put an additional constraint on
81493>>>>>>>>>>>>>/// your finds, moving filtering to the SQL backend. Using this command can
81493>>>>>>>>>>>>>/// result in significantly improved performance, since the server network traffic
81493>>>>>>>>>>>>>/// reduced. Note that the SQL statement passed for this command is added onto
81493>>>>>>>>>>>>>/// the predefined Database SQL statement so treat it as such. Because of this,
81493>>>>>>>>>>>>>/// it will almost always begin with "AND" followed by the desired constraint.
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81493>>>>>>>>>>>>>/// @Status      Public
81493>>>>>>>>>>>>>/// @Drivers     All
81493>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81493>>>>>>>>>>>>>/// @See         SQL_CONSTRAINT GET_SQL_CONSTRAINT DF_FIELD_PROGRAMMATIC_DEFAULT
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Syntax SET_SQL_CONSTRAINT of {file} to {variable}
81493>>>>>>>>>>>>>/// @Param  file                        Name or Number of the file.
81493>>>>>>>>>>>>>/// @Param  variable            A SQL expression that constrains the data
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// @Example
81493>>>>>>>>>>>>>/// Open Customer
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of 1 to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
81493>>>>>>>>>>>>>///
81493>>>>>>>>>>>>>/// For_All Customer by Index.1 do
81493>>>>>>>>>>>>>///     Showln Customer.FirstName
81493>>>>>>>>>>>>>/// End_For_All
81493>>>>>>>>>>>>>
81493>>>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT Global Integer iFunction String sConstraint
81495>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 0 RESULT MertechInc_iRet
81500>>>>>>>>>>>>>End_Procedure
81501>>>>>>>>>>>>>
81501>>>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT_PROGRAMMATIC Global Integer iFunction
81503>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 4 RESULT MertechInc_iRet
81508>>>>>>>>>>>>>End_Procedure
81509>>>>>>>>>>>>>
81509>>>>>>>>>>>>>//=============================================================================
81509>>>>>>>>>>>>>/// @Name        GET_SQL_CONSTRAINT
81509>>>>>>>>>>>>>/// @Description This command returns the current SQL constraint for the given
81509>>>>>>>>>>>>>/// table.  If there is no current constraint, then a blank string is returned.
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81509>>>>>>>>>>>>>/// @Status      Public
81509>>>>>>>>>>>>>/// @Drivers     All
81509>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81509>>>>>>>>>>>>>/// @See         SQL_CONSTRAINT SET_SQL_CONSTRAINT
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// @Syntax GET_SQL_CONSTRAINT of {File} to {variable}
81509>>>>>>>>>>>>>/// @Param  File                        Name or number of the file
81509>>>>>>>>>>>>>/// @Param  variable            The string containing the constraining SQL expression
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// @Example
81509>>>>>>>>>>>>>/// Open Customer
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// String sCon
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
81509>>>>>>>>>>>>>/// GET_SQL_CONSTRAINT of Customer to sCon
81509>>>>>>>>>>>>>///
81509>>>>>>>>>>>>>/// For_All Customer by Index.1 do
81509>>>>>>>>>>>>>///     Showln Customer.FirstName
81509>>>>>>>>>>>>>///     Showln sCon
81509>>>>>>>>>>>>>/// End_For_All
81509>>>>>>>>>>>>>
81509>>>>>>>>>>>>>Function MertechInc_GET_SQL_CONSTRAINT Global Integer iFunction Returns String
81511>>>>>>>>>>>>>    Local String sConstraint
81511>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sConstraint
81512>>>>>>>>>>>>>
81512>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 3 RESULT MertechInc_iRet
81517>>>>>>>>>>>>>    Function_Return sConstraint
81518>>>>>>>>>>>>>End_Function
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        SQL_CONSTRAINT
81519>>>>>>>>>>>>>/// @Description This command is used to toggle on or off the current SQL
81519>>>>>>>>>>>>>/// constraint that is set for a table. To deactivate the current constraint,
81519>>>>>>>>>>>>>/// pass the constant DEACTIVATE to this command. to reactivate the constraint,
81519>>>>>>>>>>>>>/// pass ACTIVATE to this command.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Status      Public
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See         SET_SQL_CONSTRAINT GET_SQL_CONSTRAINT
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax SQL_CONSTRAINT of {File} to {Activate|Deactivate}
81519>>>>>>>>>>>>>/// @Param  File                        Name or Number of the file
81519>>>>>>>>>>>>>/// @Param  Activate            Activates the constraint
81519>>>>>>>>>>>>>/// @Param  Deactivate          Deactivates the constraint
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Example
81519>>>>>>>>>>>>>/// Open Customer
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "FirstName", "Aaron"))
81519>>>>>>>>>>>>>/// SQL_CONSTRAINT of Customer to Deactivate
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// For_All Customer by Index.1 do
81519>>>>>>>>>>>>>///     Showln Customer.FirstName
81519>>>>>>>>>>>>>/// End_For_All
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        CREATE_TD_FILE
81519>>>>>>>>>>>>>/// @Description A .TD file is created when the attribute is set to True.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Assumptions
81519>>>>>>>>>>>>>/// @Status      Deprecated
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax CREATE_TD_FILE {variable}
81519>>>>>>>>>>>>>/// @Param  variable            True to create the .TD file, false doesn't create it.
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        OPEN_INT
81519>>>>>>>>>>>>>/// @Description This command is used to replace the OPEN command in DataFlex.
81519>>>>>>>>>>>>>/// It can be useful when accessing tables that are not in the current filelist.
81519>>>>>>>>>>>>>/// To access these tables, the INT and FD files must be in the directory. From
81519>>>>>>>>>>>>>/// there, all that is needed is to open the table using this command under an
81519>>>>>>>>>>>>>/// alias name. If the command is executed successfully then the table can be
81519>>>>>>>>>>>>>/// queried normally as if it were a standard table. Note that if the desired
81519>>>>>>>>>>>>>/// table is already in the filelist or doesn't have an INT file then this
81519>>>>>>>>>>>>>/// command will act as a normal open command.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Assumptions
81519>>>>>>>>>>>>>/// @Status      Public
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax OPEN_INT {variable} as {aliasName}
81519>>>>>>>>>>>>>/// @Param  variable            The name of the int file without the extension.
81519>>>>>>>>>>>>>/// @Param  aliasName           The alias name being used to query this table.
81519>>>>>>>>>>>>>/// @Example
81519>>>>>>>>>>>>>/// OPEN_INT "customer" as Customer
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// For_All Customer by Index.1 do
81519>>>>>>>>>>>>>///     Showln Customer.FirstName
81519>>>>>>>>>>>>>/// End_For_All
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        SET_OPEN_MODE
81519>>>>>>>>>>>>>/// @Description This command is used to enable an option known as "Lazy Open
81519>>>>>>>>>>>>>/// Mode". When turned on the table's metadata i.e. table, columns, index
81519>>>>>>>>>>>>>/// descriptions, is deferred until a field is accessed, even if a OPEN has
81519>>>>>>>>>>>>>/// already been done. This can significantly improve an application's initial
81519>>>>>>>>>>>>>/// performance, especially when a large number of files are opened when the
81519>>>>>>>>>>>>>/// program is launched. By default, tables are set to open normally, but by
81519>>>>>>>>>>>>>/// passing the constant LAZY_MODE to this command, it can be altered to use
81519>>>>>>>>>>>>>/// this mode. Note that when this mode is activated, it effects all tables
81519>>>>>>>>>>>>>/// that are opened. To deactivate this feature, pass the constant "DEFAULT"
81519>>>>>>>>>>>>>/// to this command at any time. This is the preferred method to activate or
81519>>>>>>>>>>>>>/// deactive this feature but it can also be set globally in the .INI file.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// Default Value: DEFAULT (Off)
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Assumptions
81519>>>>>>>>>>>>>/// @Status      Public
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax SET_OPEN_MODE to {DEFAULT/LAZY_MODE}
81519>>>>>>>>>>>>>/// @Param  DEFAULT                     Used to turn of the lazy mode feature.
81519>>>>>>>>>>>>>/// @Param  LAZY_MODE           Turns on the lazy mode feature
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Example
81519>>>>>>>>>>>>>/// SET_OPEN_MODE TO LAZY_MODE
81519>>>>>>>>>>>>>/// Open "customer.int" as Customer
81519>>>>>>>>>>>>>/// ...
81519>>>>>>>>>>>>>/// ...
81519>>>>>>>>>>>>>/// Find gt Customer by Index.1
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>//=============================================================================
81519>>>>>>>>>>>>>/// @Name        SQL_SET_STMT
81519>>>>>>>>>>>>>/// @Description Use this command to set an SQL statement to be executed on the
81519>>>>>>>>>>>>>/// desired table. The string passed to this command must be a valid SQL
81519>>>>>>>>>>>>>/// expression and must be on a table that has already been opened. Note that
81519>>>>>>>>>>>>>/// when using this command, the SQL_PREPARE_STMT and SQL_EXECUTE_STMT must be
81519>>>>>>>>>>>>>/// used in addition to carry out the expression. The option to pass the file
81519>>>>>>>>>>>>>/// name as an extra parameter is used in cases where the data needs to be
81519>>>>>>>>>>>>>/// fetched directly into the record buffer of the specified file.
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81519>>>>>>>>>>>>>/// @Status      Public
81519>>>>>>>>>>>>>/// @Drivers     All
81519>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
81519>>>>>>>>>>>>>/// @See                 SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Syntax SQL_SET_STMT [of {file}] to {variable}
81519>>>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
81519>>>>>>>>>>>>>/// @Param variable                     String containing the SQL statement
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Usage SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81519>>>>>>>>>>>>>/// @Usage SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// @Example
81519>>>>>>>>>>>>>/// Open Customer
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
81519>>>>>>>>>>>>>///
81519>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81519>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81519>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81519>>>>>>>>>>>>>/// While (Found)
81519>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
81519>>>>>>>>>>>>>///     Showln sID
81519>>>>>>>>>>>>>///     Showln sFirstName
81519>>>>>>>>>>>>>///     Showln sLastName
81519>>>>>>>>>>>>>///     Showln sDOB
81519>>>>>>>>>>>>>/// Loop
81519>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81519>>>>>>>>>>>>>
81519>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_STMT Global String sStatment
81521>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatment 0 RESULT MertechInc_iRet
81526>>>>>>>>>>>>>End_Procedure
81527>>>>>>>>>>>>>
81527>>>>>>>>>>>>>//=============================================================================
81527>>>>>>>>>>>>>/// @Name        SQL_APPEND_STMT
81527>>>>>>>>>>>>>/// @Description This command is used to append a command string to the
81527>>>>>>>>>>>>>/// command buffer initialized by SQL_SET_STMT. SQL_APPEND_STMT was added
81527>>>>>>>>>>>>>/// so that long SQL expressions could be broken into smaller strings and
81527>>>>>>>>>>>>>/// appended to a dynamic command buffer, which is then passed to the server.
81527>>>>>>>>>>>>>/// The SQL_APPEND_STMT will concatenate a string to the command buffer
81527>>>>>>>>>>>>>/// initialized by the SQL_SET_STMT command. SQL_APPEND_STMT can be called as
81527>>>>>>>>>>>>>/// many times as necessary to complete the SQL expression. Subsequently, the
81527>>>>>>>>>>>>>/// SQL_EXECUTE_STMT command executes the completed command.  The option to
81527>>>>>>>>>>>>>/// pass the file name as an extra parameter is used in cases where the data
81527>>>>>>>>>>>>>/// needs to be fetched directly into the record buffer of the specified file.
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
81527>>>>>>>>>>>>>/// @Status      Public
81527>>>>>>>>>>>>>/// @Drivers     All
81527>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-22 by Aaron Gulack
81527>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// @Syntax SQL_APPEND_STMT [of {file}] to {variable}
81527>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
81527>>>>>>>>>>>>>/// @Param variable                     The string to be appended to the current SQL expression
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// @Usage SQL_APPEND_STMT to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
81527>>>>>>>>>>>>>/// @Usage SQL_APPEND_STMT of Customer to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// @Example
81527>>>>>>>>>>>>>/// Open Customer
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
81527>>>>>>>>>>>>>///
81527>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81527>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81527>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81527>>>>>>>>>>>>>/// While (Found)
81527>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
81527>>>>>>>>>>>>>///     Showln sID
81527>>>>>>>>>>>>>///     Showln sFirstName
81527>>>>>>>>>>>>>///     Showln sLastName
81527>>>>>>>>>>>>>///     Showln sDOB
81527>>>>>>>>>>>>>/// Loop
81527>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81527>>>>>>>>>>>>>
81527>>>>>>>>>>>>>Procedure MertechInc_SQL_APPEND_STMT Global String sStatement
81529>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
81534>>>>>>>>>>>>>End_Procedure
81535>>>>>>>>>>>>>
81535>>>>>>>>>>>>>//=============================================================================
81535>>>>>>>>>>>>>/// @Name        APPEND_UPDATE_COLUMN
81535>>>>>>>>>>>>>/// @Description Append a given string to the existing SQL statement
81535>>>>>>>>>>>>>/// already set.
81535>>>>>>>>>>>>>///
81535>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method
81535>>>>>>>>>>>>>/// @Status      Internal
81535>>>>>>>>>>>>>/// @Drivers     All
81535>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81535>>>>>>>>>>>>>/// @See
81535>>>>>>>>>>>>>///
81535>>>>>>>>>>>>>/// @Syntax APPEND_UPDCOL_STMT {variable} for {fileName}.{fieldName} {fields...}
81535>>>>>>>>>>>>>/// @Param variable                             SQL expression to be appended
81535>>>>>>>>>>>>>/// @Param fileName                             Name of the file
81535>>>>>>>>>>>>>/// @Param fieldName                    Name of the field
81535>>>>>>>>>>>>>/// @Param fields...                    Any additional fields, use the file.field format
81535>>>>>>>>>>>>>
81535>>>>>>>>>>>>>Procedure MertechInc_APPEND_UPDATE_COLUMN Global String sStatement
81537>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
81542>>>>>>>>>>>>>End_Procedure
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_APPEND_UPDCOL_STMT
81543>>>>>>>>>>>>>/// @Description Used to optimize the update process of columns being loaded
81543>>>>>>>>>>>>>/// with the same value.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Deprecated
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_APPEND_UPDCOL_STMT [of {file}] Value {variable} for {fileName}.{fieldName} {fields...}
81543>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
81543>>>>>>>>>>>>>/// @Param variable                     The value being uploaded
81543>>>>>>>>>>>>>/// @Param fileName                     The name of the file
81543>>>>>>>>>>>>>/// @Param fieldName            The name of the field
81543>>>>>>>>>>>>>/// @Param fields...            Any additional fields, use the file.field format
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Example
81543>>>>>>>>>>>>>/// Open Customer
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_SET_STMT    of Customer to "UPDATE CUSTOMER SET"
81543>>>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " ASC11='x', ASC12='y', ASC13='z'"
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_APPEND_UPDCOL_STMT of Customer value 0 ;
81543>>>>>>>>>>>>>///     for Customer.ID Customer.Purchases Customer.Credit ;
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " WHERE RECNUM=1"
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_SET_CURSOR_TYPE
81543>>>>>>>>>>>>>/// @Description Specify the SQL cursor type to be used during the next
81543>>>>>>>>>>>>>/// embedded SQL statement execution.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Internal
81543>>>>>>>>>>>>>/// @Drivers     SQLFlex
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_SET_CURSOR_TYPE to {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
81543>>>>>>>>>>>>>/// @Param TYPE_NONE                    the default cursor type should be used
81543>>>>>>>>>>>>>/// @Param TYPE_CLIENT                  a client side cursor should be used
81543>>>>>>>>>>>>>/// @Param TYPE_SERVER                  a server side cursor should be used
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        CLEAR_INT_CACHE
81543>>>>>>>>>>>>>/// @Description Clears all memory-cached INT info. This is used in the
81543>>>>>>>>>>>>>/// test framework to force a "reload" of int info which the framework
81543>>>>>>>>>>>>>/// modifies for its tests. This is a different cache than the TD files
81543>>>>>>>>>>>>>/// which are a file based cache of the structure for use at file open.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Internal
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax CLEAR_INT_CACHE
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        CREATE_INVERSE_KEY_FUNCTIONS
81543>>>>>>>>>>>>>/// @Description Create SQL Functions to handle Inverse Key columns.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Internal
81543>>>>>>>>>>>>>/// @Drivers     All (v10.1 and above)
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax CREATE_INVERSE_KEY_FUNCTIONS
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// @Description Prepares a statement and opens a cursor to be executed by
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT. This command tells the server to parse the SQL statement
81543>>>>>>>>>>>>>/// created by the respective SQL_SET_STMT and all subsequent SQL_APPEND_STMT
81543>>>>>>>>>>>>>/// statements and to allocate cursor handles to be used to fetch the data.
81543>>>>>>>>>>>>>/// A cursor can be thought of as a pointer to a record set. The CURSOR_TYPE
81543>>>>>>>>>>>>>/// argument is only supported by SQLFlex and by default SQLFLex is using a
81543>>>>>>>>>>>>>/// TYPE_SERVER cursor type to all embedded SQL. TYPE_CLIENT should be used only
81543>>>>>>>>>>>>>/// for the statements that are querying LOB columns i.e. TEXT, NVARCHAR(MAX),
81543>>>>>>>>>>>>>/// VARCHAR(MAX), IMAGE, VARBINARY(MAX), XML. If the cursor type is
81543>>>>>>>>>>>>>/// TYPE_SERVER and a LOB type column is selected, MS SQL Server will not be
81543>>>>>>>>>>>>>/// able to get into a transaction, either explicitly or implicitly through a
81543>>>>>>>>>>>>>/// REREAD, LOCK, SAVERECORD, etc.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Public
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_PREPARE_STMT [of {file}] CURSOR_TYPE {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
81543>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
81543>>>>>>>>>>>>>/// @Param CURSOR_TYPE          Used if the cursor type is being set, do not include otherwise
81543>>>>>>>>>>>>>/// @Param TYPE_NONE            Default cursor will be used
81543>>>>>>>>>>>>>/// @Param TYPE_CLIENT          A client side cursor should be used
81543>>>>>>>>>>>>>/// @Param TYPE_SERVER          A server side cursor should be used (Default)
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer
81543>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT CURSOR_TYPE TYPE_SERVER
81543>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer CURSOR_TYPE TYPE_CLIENT
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Example
81543>>>>>>>>>>>>>/// Open Customer
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// String sID sFirstName
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81543>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81543>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_BIND_COLUMN
81543>>>>>>>>>>>>>/// @Description Clears all cached INT info. This should be merged with
81543>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT, but has to remain as a separate command for
81543>>>>>>>>>>>>>/// compatibility.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Internal
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_BIND_COLUMN FileNumber FieldNumber | DF_BIND_ALL_COLUMNS
81543>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
81543>>>>>>>>>>>>>/// @Param FieldNumber                  The number of the field
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_BINDCOLUMNS_STMT
81543>>>>>>>>>>>>>/// @Description This command is used to fetch the returned data of a
81543>>>>>>>>>>>>>/// specified SQL expression into the given field in the record buffer. By
81543>>>>>>>>>>>>>/// passing any number of fields to this command, the fetched record will then
81543>>>>>>>>>>>>>/// be put into the subsequent fields in the record buffer. The order of the
81543>>>>>>>>>>>>>/// fields must be the same as the order of the columns being retrieved from
81543>>>>>>>>>>>>>/// the SQL expression. SQL_FETCH_NEXT_ROW can then be called to take the data
81543>>>>>>>>>>>>>/// retrieved from the server and place it into the corresponding fields in the
81543>>>>>>>>>>>>>/// buffer. Instead of specifying each field, DF_BIND_ALL_COLUMNS can be passed,
81543>>>>>>>>>>>>>/// which will retrieve every column in the table.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Public
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_BINDCOLUMNS_STMT of {file} to {field/DF_BIND_ALL_COLUMNS}
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Param file                 Name or number of the file
81543>>>>>>>>>>>>>/// @Param field                        Name or number of the field (can be multiple)
81543>>>>>>>>>>>>>/// @Param DF_BIND_ALL_COLUMNS  Used instead of the field to retrieve all columns in the file
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Example
81543>>>>>>>>>>>>>/// Open Customer
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81543>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
81543>>>>>>>>>>>>>/// While (Found)
81543>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
81543>>>>>>>>>>>>>///     Showln Customer.ID
81543>>>>>>>>>>>>>///     Showln Customer.FirstName
81543>>>>>>>>>>>>>///     Showln Customer.LastName
81543>>>>>>>>>>>>>///     Showln Customer.DOB
81543>>>>>>>>>>>>>/// Loop
81543>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//=============================================================================
81543>>>>>>>>>>>>>/// @Name        SQL_EXECUTE_STMT
81543>>>>>>>>>>>>>/// @Description This command is used to execute the SQL expression created
81543>>>>>>>>>>>>>/// by the SQL_SET_STMT and any subsequent SQL_APPEND_STMT commands issued
81543>>>>>>>>>>>>>/// after a SQL_PREPARE_STMT. If the results will be sent to the record
81543>>>>>>>>>>>>>/// buffer directly, then the file must be specified. An optional parameter
81543>>>>>>>>>>>>>/// can also be passed, indicating the maximum number of rows to be sent to
81543>>>>>>>>>>>>>/// the local cache. This is done by adding the constant ROWCOUNT followed
81543>>>>>>>>>>>>>/// by the maximun number.
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Assumptions
81543>>>>>>>>>>>>>/// @Status      Public
81543>>>>>>>>>>>>>/// @Drivers     All
81543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
81543>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Syntax SQL_EXECUTE_STMT [of {file} ROWCOUNT {variable}]
81543>>>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
81543>>>>>>>>>>>>>/// @Param variable                     Maximum number of rows to send to the local cache (optional)
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT
81543>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer
81543>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer ROWCOUNT 10
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// @Example
81543>>>>>>>>>>>>>/// Open Customer
81543>>>>>>>>>>>>>///
81543>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81543>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81543>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
81543>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
81543>>>>>>>>>>>>>/// While (Found)
81543>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
81543>>>>>>>>>>>>>///     Showln Customer.ID
81543>>>>>>>>>>>>>///     Showln Customer.FirstName
81543>>>>>>>>>>>>>///     Showln Customer.LastName
81543>>>>>>>>>>>>>///     Showln Customer.DOB
81543>>>>>>>>>>>>>/// Loop
81543>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>
81543>>>>>>>>>>>>>//This alias may be redundant. Is was only called from MertechInc_SQL_FUNCTION_EXECUTE
81543>>>>>>>>>>>>>//which has been recoded to directly call SQL_EXECUTE_STMT - I.S. 2009-09-19
81543>>>>>>>>>>>>>Procedure MertechInc_SQL_PROCEDURE_EXECUTE Global
81545>>>>>>>>>>>>>    SQL_EXECUTE_STMT
81560>>>>>>>>>>>>>End_Procedure
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>/// @Description Transactions in SQL are used to maintain atomicity within
81561>>>>>>>>>>>>>/// an process. If one procedure in the transaction fails, then they all
81561>>>>>>>>>>>>>/// will fail. This command is used to start an SQL transaction. Inside of
81561>>>>>>>>>>>>>/// a transaction, there can be any number of SQL statements, none of which
81561>>>>>>>>>>>>>/// will be executed until SQL_COMMIT_STMT is called. Note that transactions
81561>>>>>>>>>>>>>/// are generally only needed when a table is being altered.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See         SQL_COMMIT_STMT SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// SQL_COMMIT_STMT
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_COMMIT_STMT
81561>>>>>>>>>>>>>/// @Description Just as the SQL_EXECUTE_STMT is used to execute the SQL
81561>>>>>>>>>>>>>/// statement in the block, this command is used to commit the transaction
81561>>>>>>>>>>>>>/// started by SQL_START_TRANSACTION_STMT. When this command is called, any
81561>>>>>>>>>>>>>/// preceding statements or procedures that are apart of the transaction will
81561>>>>>>>>>>>>>/// be committed. If one or more of these statements fail, then none of them
81561>>>>>>>>>>>>>/// will be successful, thus maintaining atomicity.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_COMMIT_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// SQL_COMMIT_STMT
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>/// @Description Rolls back an SQL transaction, any data changes inside the
81561>>>>>>>>>>>>>/// transaction will not be committed by the server.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_COMMIT_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "DELETE FROM CUSTOMER WHERE ID = 2145"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// If (Err) Begin
81561>>>>>>>>>>>>>///             SQL_ERROR_MESSAGE errorString
81561>>>>>>>>>>>>>///     Showln errorString
81561>>>>>>>>>>>>>///     SQL_ROLLBACK_STMT
81561>>>>>>>>>>>>>/// End
81561>>>>>>>>>>>>>/// Else
81561>>>>>>>>>>>>>///     Showln "SQL Statement successful - committing"
81561>>>>>>>>>>>>>///     SQL_COMMIT_STMT
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SET_TRANSACTIONS_ALLOWED
81561>>>>>>>>>>>>>/// @Description This command is used to toggle on or off the ability to
81561>>>>>>>>>>>>>/// complete transaction to the server. Passing false to this command will
81561>>>>>>>>>>>>>/// not allow transactions to be made, passing true will allow the transactions.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Internal
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SET_TRANSACTIONS_ALLOWED of {server} to {variable}
81561>>>>>>>>>>>>>/// @Param server                               The name of the server being used
81561>>>>>>>>>>>>>/// @Param variable                     Boolean to enable or disable transactions
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SET_TRANSACTIONS_ALLOWED of "localhost" to True
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_FETCH_NEXT_ROW
81561>>>>>>>>>>>>>/// @Description This command is used to fetch the next row returned by the
81561>>>>>>>>>>>>>/// associated SQL statement. The SQL statement is created from the
81561>>>>>>>>>>>>>/// SQL_SET_STMT and executed with the SQL_EXECUTE_STMT. This command can be
81561>>>>>>>>>>>>>/// used in two ways. If the results are to be attached to variables, then no
81561>>>>>>>>>>>>>/// file needs to be specified, just the variables for each column in the row.
81561>>>>>>>>>>>>>/// If the results are to be inserted into the record buffer directly, then the
81561>>>>>>>>>>>>>/// file must be specified. From there, a SQL_BINDCOLUMNS_STMT can be used to
81561>>>>>>>>>>>>>/// bind the fetched row to the specific fields in the file. Note that the
81561>>>>>>>>>>>>>/// columns are fecthed in the order that the SQL statement generates them, so
81561>>>>>>>>>>>>>/// the variables must follow the same order. The two constants, "found" and
81561>>>>>>>>>>>>>/// "finderr" are set depending on whether the next row was found.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_BINDCOLUMNS_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_FETCH_NEXT_ROW [of {file}] into {variable}
81561>>>>>>>>>>>>>/// @Param  file                                The name or number of the file
81561>>>>>>>>>>>>>/// @Param  variable                    The variable that the next column in the fetched row will be put into (can be multiple)
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW of Customer
81561>>>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW into sRecnum sID
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// String sID sRecnum
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER ID"
81561>>>>>>>>>>>>>/// SQL_APPEND_STMT to " BY NAME DESC"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// While (found)
81561>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sRecnum sID
81561>>>>>>>>>>>>>///     If (found) Begin
81561>>>>>>>>>>>>>///             Showln sID
81561>>>>>>>>>>>>>///    End
81561>>>>>>>>>>>>>/// Loop
81561>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// Open Customer
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
81561>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
81561>>>>>>>>>>>>>/// While (Found)
81561>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
81561>>>>>>>>>>>>>///     Showln Customer.ID
81561>>>>>>>>>>>>>///     Showln Customer.FirstName
81561>>>>>>>>>>>>>///             Showln Customer.LastName
81561>>>>>>>>>>>>>/// Loop
81561>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        GET_RESULT_SET
81561>>>>>>>>>>>>>/// @Description Fetches the next row in the result set returned by a
81561>>>>>>>>>>>>>/// query or stored procedure.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Deprecated
81561>>>>>>>>>>>>>/// @Drivers     All
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET into {variable}
81561>>>>>>>>>>>>>/// @Param variable                     The variable receiving the result (can be multiple)
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>//=============================================================================
81561>>>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK
81561>>>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
81561>>>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
81561>>>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
81561>>>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
81561>>>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
81561>>>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
81561>>>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Assumptions
81561>>>>>>>>>>>>>/// @Status      Public
81561>>>>>>>>>>>>>/// @Drivers     SQLFlex
81561>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81561>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
81561>>>>>>>>>>>>>/// @Param column                               Column number to get chunk from
81561>>>>>>>>>>>>>/// @Param offset                       Offset to start at for the chunk
81561>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned chunk
81561>>>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length
81561>>>>>>>>>>>>>///
81561>>>>>>>>>>>>>/// @Example
81561>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81561>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81561>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81561>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
81561>>>>>>>>>>>>>/// If (Found) Begin
81561>>>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
81561>>>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
81561>>>>>>>>>>>>>///     Showln sChunk
81561>>>>>>>>>>>>>///     Showln iLength
81561>>>>>>>>>>>>>/// End
81561>>>>>>>>>>>>>
81561>>>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK Global Integer iColumn Integer iOffset Returns String
81563>>>>>>>>>>>>>    Local Integer iChuck_Size
81563>>>>>>>>>>>>>    Local String sChunk
81563>>>>>>>>>>>>>
81563>>>>>>>>>>>>>    //Get current Chuck size and pre size string
81563>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
81568>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
81569>>>>>>>>>>>>>
81569>>>>>>>>>>>>>    //Get data
81569>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK CALLBACK 0 PASSING iColumn sChunk iOffset RESULT MertechInc_iRet
81574>>>>>>>>>>>>>
81574>>>>>>>>>>>>>    //sArg1 (iColumn) contains the number of bytes returned, so move it to
81574>>>>>>>>>>>>>    //MertechInc_Arg1 to pass the value back
81574>>>>>>>>>>>>>    Move iColumn to MertechInc_sArg1
81575>>>>>>>>>>>>>
81575>>>>>>>>>>>>>    Function_Return sChunk
81576>>>>>>>>>>>>>End_Function
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_SET_CHUNK_SIZE
81577>>>>>>>>>>>>>/// @Description This command sets the size of the chunk to retrieve when
81577>>>>>>>>>>>>>/// using SQL_GET_DATA_CHUNK. Whatever number is set here will be the
81577>>>>>>>>>>>>>/// length of the chunk that is retrieved, as long as it does not exceed
81577>>>>>>>>>>>>>/// the maximum chunk size.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     SQLFlex
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_GET_DATA_CHUNK SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_SET_CHUNK_SIZE to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Length of chunk to retrive
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
81577>>>>>>>>>>>>>/// If (Found) Begin
81577>>>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
81577>>>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
81577>>>>>>>>>>>>>///     Showln sChunk
81577>>>>>>>>>>>>>///     Showln iLength
81577>>>>>>>>>>>>>/// End
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_CHUNK_SIZE
81577>>>>>>>>>>>>>/// @Description This command gets the size of the chunk being retrieved
81577>>>>>>>>>>>>>/// from SQL_GET_DATA_CHUNK and puts it into the specified variable.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     SQLFlex
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_CHUNK_SIZE to {variable}
81577>>>>>>>>>>>>>/// @Param variable             Variable to hold the chunk size
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_GET_CHUNK_SIZE to iLength
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_SET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>/// @Description This command sets the maximum size for data chunks
81577>>>>>>>>>>>>>/// retrieved through SQL_GET_DATA_CHUNK. If SQL_SET_CHUNK_SIZE is higher
81577>>>>>>>>>>>>>/// than the maximum size set with this command, then this will override
81577>>>>>>>>>>>>>/// it and the chunk will be no longer than the maximum size set here.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     SQLFlex
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_GET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_SET_MAX_DATA_SIZE to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Max length to allow for chunks
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to 1000
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>/// @Description This command returns the maximum chunk size allowed
81577>>>>>>>>>>>>>/// for SQL_GET_DATA_CHUNK.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     SQLFlex
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_MAX_DATA_SIZE to {variable}
81577>>>>>>>>>>>>>/// @Param variable             Variable to hold the maximum chunk size
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_GET_MAX_DATA_SIZE to iLength
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_NUM_COLS
81577>>>>>>>>>>>>>/// @Description This command is used to get the number of columns retrieved
81577>>>>>>>>>>>>>/// from an SQL expression result set. Since the column number is based on
81577>>>>>>>>>>>>>/// the result set, this command cannot be used when the results are being
81577>>>>>>>>>>>>>/// bound to the record buffer.  If this command is used with the record
81577>>>>>>>>>>>>>/// buffer or if no columns are found, -1 is returned.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_SET_STMT
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_NUM_COLS to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
81577>>>>>>>>>>>>>/// Showln iNumCols
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        GET_RESULT_SET_NUM_COLS
81577>>>>>>>>>>>>>/// @Description Returns the number of columns in the result set.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Deprecated
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET_NUM_COLS to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// Integer iNumCols
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
81577>>>>>>>>>>>>>/// Showln iNumCols
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_NUM_ROWS
81577>>>>>>>>>>>>>/// @Description This command is used to get the number of rows retrieved
81577>>>>>>>>>>>>>/// from a result set of an SQL expression. It cannot be used when binding
81577>>>>>>>>>>>>>/// the result set to the record buffer.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// Note: The number of rows may not always be available, depending
81577>>>>>>>>>>>>>/// on server and cursor types.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_NUM_ROWS to {variable}
81577>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of rows
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// Integer iNumRows
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// SQL_GET_NUM_ROWS to iNumRows
81577>>>>>>>>>>>>>/// Showln iNumRows
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_COL_NAME
81577>>>>>>>>>>>>>/// @Description This command is used to retrieve the name of a specified
81577>>>>>>>>>>>>>/// column within an SQL result set. An optional second variable can be used
81577>>>>>>>>>>>>>/// to retrieve the size of the specified column. Note that this command
81577>>>>>>>>>>>>>/// cannot be used when the results are being directly binded to the record
81577>>>>>>>>>>>>>/// buffer, it can only be used for the results of an SQL statement.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_COL_NAME {columnNumber} to {variable} [{length}]
81577>>>>>>>>>>>>>/// @Param columnNumber                 The column number being used
81577>>>>>>>>>>>>>/// @Param variable                             String variable for the column name
81577>>>>>>>>>>>>>/// @Param length                       Variable to hold the column length (optional)
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// Open Customer
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// String sColumnName
81577>>>>>>>>>>>>>/// Integer iLength
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// SQL_GET_COL_NAME 1 to sColumnName iLength
81577>>>>>>>>>>>>>/// showln sColumnName
81577>>>>>>>>>>>>>/// showln iLength
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        GET_RESULT_SET_COL_NAME
81577>>>>>>>>>>>>>/// @Description Returns the column name being populated from the result set.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Deprecated
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See                 SQL_GET_COL_NAME
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET_COL_NAME {columnNumber} to {variable} [{length}]
81577>>>>>>>>>>>>>/// @Param columnNumber                 The column number being used
81577>>>>>>>>>>>>>/// @Param variable                             String variable for the column name
81577>>>>>>>>>>>>>/// @Param length                       Variable receiving the column length (optional)
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        SQL_GET_COL_ATTRIBUTE
81577>>>>>>>>>>>>>/// @Description This command is used to get specific column information from
81577>>>>>>>>>>>>>/// the columns in a result set of an SQL statement. By passing one of the
81577>>>>>>>>>>>>>/// supported attributes below, the command will return the desired information.
81577>>>>>>>>>>>>>/// Note that some attributes only work with specific drivers. See the list
81577>>>>>>>>>>>>>/// below for more information.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// Supported attributes are:
81577>>>>>>>>>>>>>/// <dl>
81577>>>>>>>>>>>>>/// <dt>SIZE        </dt><dd>The maximum length of the column</dd>
81577>>>>>>>>>>>>>/// <dt>DATA_LENGTH </dt><dd>Length of data currently in the column</dd>
81577>>>>>>>>>>>>>/// <dt>DECIMALS    </dt><dd>If numeric, shows number of decimal places</dd>
81577>>>>>>>>>>>>>/// <dt>LABEL       </dt><dd>Returns the column name in ORAFlex and MySQLFlex</dd>
81577>>>>>>>>>>>>>/// <dt>COLUMN_NAME </dt><dd>Returns the name of the column</dd>
81577>>>>>>>>>>>>>/// <dt>TABLE_NAME  </dt><dd>Returns the name of the table (MySQLFlex only)</dd>
81577>>>>>>>>>>>>>/// <dt>SQLTYPE     </dt><dd>Returns the number representing the SQL data type</dd>
81577>>>>>>>>>>>>>/// <dt>NULLABLE    </dt><dd>Returns true if null is allowed, false otherwise (doesn't work in PostgreSQL)</dd>
81577>>>>>>>>>>>>>/// <dt>DFTYPE      </dt><dd>Dataflex type column is mapped to</dd>
81577>>>>>>>>>>>>>/// </dl>
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Public
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Syntax SQL_GET_COL_ATTRIBUTE of {columnNumber} {attribute} to {variable}
81577>>>>>>>>>>>>>/// @Param columnNumber                 The number of the column that is being examined
81577>>>>>>>>>>>>>/// @Param attribute                    The attribute being checked (see list)
81577>>>>>>>>>>>>>/// @Param variable                             Variable to hold the attribute value
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Example
81577>>>>>>>>>>>>>/// String sFirstName sLastName sColumn1Name sColumn2Name
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// Open Customer
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81577>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81577>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81577>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
81577>>>>>>>>>>>>>/// If (Found) Begin
81577>>>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 1 COLUMN_NAME to sColumn1Name
81577>>>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 2 COLUMN_NAME to sColumn2Name
81577>>>>>>>>>>>>>///     Showln (sColumn1Name + " = " + sFirstName)
81577>>>>>>>>>>>>>///     Showln (sColumn2Name + " = " + sLastName)
81577>>>>>>>>>>>>>/// End
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        DDO_GET_BIND_RSPARAMETERS
81577>>>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_RSPARAMETERS.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Internal
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>//=============================================================================
81577>>>>>>>>>>>>>/// @Name        DO_GET_BIND_RSPARAMETERS
81577>>>>>>>>>>>>>/// @Description Gets bound parameters values for result set call.
81577>>>>>>>>>>>>>///
81577>>>>>>>>>>>>>/// @Assumptions
81577>>>>>>>>>>>>>/// @Status      Internal
81577>>>>>>>>>>>>>/// @Drivers     All
81577>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
81577>>>>>>>>>>>>>/// @See
81577>>>>>>>>>>>>>
81577>>>>>>>>>>>>>Function MertechInc_DO_GET_BIND_RSPARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
81579>>>>>>>>>>>>>    Local String sReturnValue
81579>>>>>>>>>>>>>    Local Integer iSize
81579>>>>>>>>>>>>>
81579>>>>>>>>>>>>>    move 0 to iSize
81580>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
81597>>>>>>>>>>>>>>
81597>>>>>>>>>>>>>
81597>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
81598>>>>>>>>>>>>>    Move (|CI$10000 * iArg) To iArg // Shift column number 16 bits to the left
81599>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
81604>>>>>>>>>>>>>
81604>>>>>>>>>>>>>    Function_Return sReturnValue
81605>>>>>>>>>>>>>End_Function
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        SQL_NEXT_RESULT_SET
81606>>>>>>>>>>>>>/// @Description This command is used when working with SQL statements that
81606>>>>>>>>>>>>>/// return multiple result sets. In that scenario, calling this command will
81606>>>>>>>>>>>>>/// move to the next result set. That set can now be fetched or binded to
81606>>>>>>>>>>>>>/// columns on a table.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>/// @Status      Public
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-02 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Syntax SQL_NEXT_RESULT_SET [of {file}]
81606>>>>>>>>>>>>>/// @Param file                 Name or number of the file (optional)
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Example
81606>>>>>>>>>>>>>/// SQL_SET_STMT to "SP_HELP CUSTOMER"
81606>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81606>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81606>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sTable sOwner sTableType dtCreated
81606>>>>>>>>>>>>>/// If (Found) Begin
81606>>>>>>>>>>>>>///     Showln sTable
81606>>>>>>>>>>>>>///     Showln sOwner
81606>>>>>>>>>>>>>///     Showln sTableType
81606>>>>>>>>>>>>>///     Showln dtCreated
81606>>>>>>>>>>>>>/// End
81606>>>>>>>>>>>>>/// SQL_NEXT_RESULT_SET
81606>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sColumnName sColumnType sComputed sLength
81606>>>>>>>>>>>>>/// If (Found) Begin
81606>>>>>>>>>>>>>///     Showln sColumnName
81606>>>>>>>>>>>>>///     Showln sColumnType
81606>>>>>>>>>>>>>///     Showln sComputed
81606>>>>>>>>>>>>>///     Showln sLength
81606>>>>>>>>>>>>>/// End
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        DDO_PASS_ARGUMENTS
81606>>>>>>>>>>>>>/// @Description Calls DO_PASS_ARGUMENTS until the argument is "BINDING" and
81606>>>>>>>>>>>>>/// then stops.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Assumptions
81606>>>>>>>>>>>>>/// @Status      Internal
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        DO_PASS_ARGUMENTS
81606>>>>>>>>>>>>>/// @Description Builds parameter statements for stored procedures and adds
81606>>>>>>>>>>>>>/// them to the current query.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Assumptions
81606>>>>>>>>>>>>>/// @Status      internal
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        DDO_BIND_PARAMETERS
81606>>>>>>>>>>>>>/// @Description Recursively calls DO_BIND_PARAMETERS until the keyword
81606>>>>>>>>>>>>>/// "BINDING" is encountered.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Assumptions
81606>>>>>>>>>>>>>/// @Status      Internal
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>//=============================================================================
81606>>>>>>>>>>>>>/// @Name        DO_BIND_PARAMETERS
81606>>>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
81606>>>>>>>>>>>>>///
81606>>>>>>>>>>>>>/// @Assumptions
81606>>>>>>>>>>>>>/// @Status      Internal
81606>>>>>>>>>>>>>/// @Drivers     All
81606>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81606>>>>>>>>>>>>>/// @See
81606>>>>>>>>>>>>>
81606>>>>>>>>>>>>>Procedure MertechInc_DO_BIND_PARAMETERS Global String sValue String sName Integer iLength
81608>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sValue sName iLength RESULT MertechInc_iRet
81613>>>>>>>>>>>>>End_Procedure
81614>>>>>>>>>>>>>
81614>>>>>>>>>>>>>//=============================================================================
81614>>>>>>>>>>>>>/// @Name        DO_BIND_PAR_RET
81614>>>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
81614>>>>>>>>>>>>>///
81614>>>>>>>>>>>>>/// @Assumptions
81614>>>>>>>>>>>>>/// @Status      Internal
81614>>>>>>>>>>>>>/// @Drivers     OraFlex
81614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81614>>>>>>>>>>>>>/// @See
81614>>>>>>>>>>>>>
81614>>>>>>>>>>>>>//=============================================================================
81614>>>>>>>>>>>>>/// @Name        DDO_GET_BIND_PARAMETERS
81614>>>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_PARAMETERS.
81614>>>>>>>>>>>>>///
81614>>>>>>>>>>>>>/// @Assumptions
81614>>>>>>>>>>>>>/// @Status      Internal
81614>>>>>>>>>>>>>/// @Drivers     All
81614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81614>>>>>>>>>>>>>/// @See
81614>>>>>>>>>>>>>
81614>>>>>>>>>>>>>//=============================================================================
81614>>>>>>>>>>>>>/// @Name        DO_GET_BIND_PARAMETERS
81614>>>>>>>>>>>>>/// @Description Gets bound parameter values for a stored procedure call.
81614>>>>>>>>>>>>>///
81614>>>>>>>>>>>>>/// @Assumptions
81614>>>>>>>>>>>>>/// @Status      Internal
81614>>>>>>>>>>>>>/// @Drivers     All
81614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81614>>>>>>>>>>>>>/// @See
81614>>>>>>>>>>>>>
81614>>>>>>>>>>>>>Function MertechInc_DO_GET_BIND_PARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
81616>>>>>>>>>>>>>    Local String sReturnValue
81616>>>>>>>>>>>>>    Local Integer iSize
81616>>>>>>>>>>>>>
81616>>>>>>>>>>>>>    if (MertechInc_DriverName = SQLFLEX) ;                move (iArg+1) to iArg
81619>>>>>>>>>>>>>//        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
81619>>>>>>>>>>>>>
81619>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
81620>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
81625>>>>>>>>>>>>>
81625>>>>>>>>>>>>>    Function_Return sReturnValue
81626>>>>>>>>>>>>>End_Function
81627>>>>>>>>>>>>>
81627>>>>>>>>>>>>>//=============================================================================
81627>>>>>>>>>>>>>/// @Name        SQL_GET_OUTPUT_VALUE
81627>>>>>>>>>>>>>/// @Description This command is used to get the value of a specific
81627>>>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
81627>>>>>>>>>>>>>/// command will work with any parameter, it is mostly used with
81627>>>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
81627>>>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
81627>>>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
81627>>>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
81627>>>>>>>>>>>>>/// in order to work properly.
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Assumptions
81627>>>>>>>>>>>>>/// @Status      Deprecated
81627>>>>>>>>>>>>>/// @Drivers     All
81627>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
81627>>>>>>>>>>>>>/// @See                 SQL_GET_PROCEDURE_PARAMETER
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Syntax SQL_GET_OUTPUT_VALUE {parameter} to {variable}
81627>>>>>>>>>>>>>/// @Param parameter            Number of the parameter
81627>>>>>>>>>>>>>/// @Param variable                     Variable to hold the parameter's value
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Example
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
81627>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
81627>>>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 1 to sStatus
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// Showln sStatus
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Example
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
81627>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
81627>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
81627>>>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 2 to sStatus
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// Showln sStatus
81627>>>>>>>>>>>>>// OLI:
81627>>>>>>>>>>>>>// This function is identical in operation to SQL_GET_PROCEDURE_PARAMETER, so just do a replace
81627>>>>>>>>>>>>>
81627>>>>>>>>>>>>>//=============================================================================
81627>>>>>>>>>>>>>/// @Name        SQL_FETCH_COLUMN
81627>>>>>>>>>>>>>/// @Description This command is used to retrieve a specified column from a
81627>>>>>>>>>>>>>/// result set of an SQL statement. Note that this command cannot be used to
81627>>>>>>>>>>>>>/// replace SQL_FETCH_NEXT_ROW but is used in addition to it when only one
81627>>>>>>>>>>>>>/// column is needed. For most cases, SQL_FETCH_NEXT_ROW can be used alone
81627>>>>>>>>>>>>>/// to retrieve the columns desired so this should only be used if there is
81627>>>>>>>>>>>>>/// a specific reason to do so.
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Assumptions
81627>>>>>>>>>>>>>/// @Status      Public
81627>>>>>>>>>>>>>/// @Drivers     All
81627>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
81627>>>>>>>>>>>>>/// @See                 SQL_FETCH_NEXT_ROW
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Syntax SQL_FETCH_COLUMN {columnNumber} into {variable}
81627>>>>>>>>>>>>>/// @Param columnNumber    Number of the column to fetch
81627>>>>>>>>>>>>>/// @Param variable        Variable to hold the fetched value
81627>>>>>>>>>>>>>///
81627>>>>>>>>>>>>>/// @Example
81627>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
81627>>>>>>>>>>>>>/// SQL_PREPARE_STMT
81627>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
81627>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW
81627>>>>>>>>>>>>>/// SQL_GET_NUM_COLS to iCols
81627>>>>>>>>>>>>>/// For fieldIndex from 1 to iCols
81627>>>>>>>>>>>>>///     SQL_FETCH_COLUMN fieldIndex into sValue
81627>>>>>>>>>>>>>///     Showln sValue
81627>>>>>>>>>>>>>/// Loop
81627>>>>>>>>>>>>>
81627>>>>>>>>>>>>>Function MertechInc_SQL_FETCH_COLUMN Global String sArg1 String sArg2 Integer iArg Returns String
81629>>>>>>>>>>>>>    Local String sReturnValue
81629>>>>>>>>>>>>>    Local Integer iSize
81629>>>>>>>>>>>>>
81629>>>>>>>>>>>>>    Move 0 to iSize
81630>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
81647>>>>>>>>>>>>>>
81647>>>>>>>>>>>>>
81647>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
81648>>>>>>>>>>>>>    Move (|CI$10000 * iArg) to iArg // Shift column number 16 bits to the left
81649>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
81654>>>>>>>>>>>>>
81654>>>>>>>>>>>>>    Function_Return sReturnValue
81655>>>>>>>>>>>>>End_Function
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>//=============================================================================
81656>>>>>>>>>>>>>/// @Name        SET_SCHEMA_NAME
81656>>>>>>>>>>>>>/// @Description This command is used to set the schema name to be used when
81656>>>>>>>>>>>>>/// opening tables. Note that this command will override the schema name that
81656>>>>>>>>>>>>>/// is set in the INT file.  The default schema for the current user is used
81656>>>>>>>>>>>>>/// when no name is set.
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Assumptions
81656>>>>>>>>>>>>>/// @Status      Public
81656>>>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
81656>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
81656>>>>>>>>>>>>>/// @See                 GET_SCHEMA_NAME
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Syntax SET_SCHEMA_NAME to {schema}
81656>>>>>>>>>>>>>/// @Param variable                     Name of the schema
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Example
81656>>>>>>>>>>>>>/// SET_SCHEMA_NAME to 'CustomerSchema'
81656>>>>>>>>>>>>>/// OPEN "CUSTOMER.INT" as CUSTOMER
81656>>>>>>>>>>>>>/// SET_SCHEMA_NAME to 'SalesSchema'
81656>>>>>>>>>>>>>/// OPEN "SALESP.INT" as SALESP
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>//=============================================================================
81656>>>>>>>>>>>>>/// @Name        GET_SCHEMA_NAME
81656>>>>>>>>>>>>>/// @Description This command is used to get the name of the schema being
81656>>>>>>>>>>>>>/// used to open tables.
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Assumptions
81656>>>>>>>>>>>>>/// @Status      Public
81656>>>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
81656>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
81656>>>>>>>>>>>>>/// @See                 SET_SCHEMA_NAME
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Syntax GET_SCHEMA_NAME to {variable}
81656>>>>>>>>>>>>>/// @Param variable                     variable to hold the schema name
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Example
81656>>>>>>>>>>>>>/// GET_SCHEMA_NAME to sName
81656>>>>>>>>>>>>>/// Showln sName
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>//=============================================================================
81656>>>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_PROCEDURE
81656>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
81656>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
81656>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
81656>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
81656>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
81656>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
81656>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
81656>>>>>>>>>>>>>/// is set to true.
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Assumptions
81656>>>>>>>>>>>>>/// @Status      Deprecated
81656>>>>>>>>>>>>>/// @Drivers     ORAFLex
81656>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
81656>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
81656>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
81656>>>>>>>>>>>>>/// @Param variable                     Argument being passed to procedure (can be multiple)
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Example
81656>>>>>>>>>>>>>/// CALL_ORACLE_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>//=============================================================================
81656>>>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_NAME
81656>>>>>>>>>>>>>/// @Description This command is used to set the procedure to be executed.
81656>>>>>>>>>>>>>/// This is used when the procedure is being split up into multiple lines
81656>>>>>>>>>>>>>/// as shown below. When using this command, SQL_PROCEDURE_EXECUTE must be
81656>>>>>>>>>>>>>/// called after all parameters have been set to successfully execute the
81656>>>>>>>>>>>>>/// procedure. The constant "NUMPAR" is used to indicate how many parameters
81656>>>>>>>>>>>>>/// will be passed.
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Assumptions The procedure is a valid procedure in the SQL database
81656>>>>>>>>>>>>>/// @Status      Public
81656>>>>>>>>>>>>>/// @Drivers     All
81656>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
81656>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_NAME {procedure} NUMPAR {variable}
81656>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
81656>>>>>>>>>>>>>/// @Param variable                     Number of parameters to be passed
81656>>>>>>>>>>>>>///
81656>>>>>>>>>>>>>/// @Example
81656>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
81656>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
81656>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
81656>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
81656>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>
81656>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAPROCEDURE_NAME Global String strProcName Integer iNumpar
81658>>>>>>>>>>>>>    Local Integer iParam
81658>>>>>>>>>>>>>
81658>>>>>>>>>>>>>    Move 0 to MertechInc_iParamCount       //Redundant, but left in incase called
81659>>>>>>>>>>>>>    INDICATE ERR False              //directly and not via SQL_SET_PROCEDURE_NAME
81660>>>>>>>>>>>>>    Move ORAFlex to MertechInc_DriverName  //
81661>>>>>>>>>>>>>
81661>>>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
81669>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
81677>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
81685>>>>>>>>>>>>>    For iParam from 1 to iNumpar
81691>>>>>>>>>>>>>>
81691>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
81723>>>>>>>>>>>>>    Loop
81724>>>>>>>>>>>>>>
81724>>>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
81732>>>>>>>>>>>>>    SQL_PREPARE_STMT
81744>>>>>>>>>>>>> End_Procedure
81745>>>>>>>>>>>>>
81745>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYPROCEDURE_NAME Global String strProcName Integer iNumpar
81747>>>>>>>>>>>>>    Local Integer iParam
81747>>>>>>>>>>>>>
81747>>>>>>>>>>>>>    Move 0 to MertechInc_iParamCount           //Redundant, but left in incase called
81748>>>>>>>>>>>>>    INDICATE ERR False                  //directly and not via SQL_SET_PROCEDURE_NAME
81749>>>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName    //
81750>>>>>>>>>>>>>
81750>>>>>>>>>>>>>    SQL_SET_STMT to "CALL "
81758>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
81766>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
81774>>>>>>>>>>>>>    For iParam from 1 to iNumpar
81780>>>>>>>>>>>>>>
81780>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
81812>>>>>>>>>>>>>    Loop
81813>>>>>>>>>>>>>>
81813>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
81821>>>>>>>>>>>>>    SQL_PREPARE_STMT
81833>>>>>>>>>>>>>End_Procedure
81834>>>>>>>>>>>>>
81834>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MSPROCEDURE_NAME Global String strProcName Integer iNumpar
81836>>>>>>>>>>>>>    local Integer iParam
81836>>>>>>>>>>>>>    local String  sParam
81836>>>>>>>>>>>>>
81836>>>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
81837>>>>>>>>>>>>>
81837>>>>>>>>>>>>>    // This calling syntax is referred to as the "ODBC CALL escape sequence".  This syntax is
81837>>>>>>>>>>>>>    // advised over the execute command since CALL allows for the retrieval of the return codes
81837>>>>>>>>>>>>>    // from the call.
81837>>>>>>>>>>>>>    SQL_SET_STMT to "{? = CALL "
81845>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
81853>>>>>>>>>>>>>
81853>>>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
81853>>>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
81853>>>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
81853>>>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to " ("
81863>>>>>>>>>>>>>
81863>>>>>>>>>>>>>    For iParam from 1 to iNumpar
81869>>>>>>>>>>>>>>
81869>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
81901>>>>>>>>>>>>>    Loop
81902>>>>>>>>>>>>>>
81902>>>>>>>>>>>>>
81902>>>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to ")"
81912>>>>>>>>>>>>>    SQL_APPEND_STMT to  " };"
81920>>>>>>>>>>>>>
81920>>>>>>>>>>>>>    SQL_PREPARE_STMT
81932>>>>>>>>>>>>>
81932>>>>>>>>>>>>>    // This bind parameter is for the "{? = " which is technically the first parameter even though
81932>>>>>>>>>>>>>    // it is the return value.  The driver will bind MertechInc_iWork to it.
81932>>>>>>>>>>>>>    DO_BIND_PARAMETERS MertechInc_iWork
81955>>>>>>>>>>>>>End_Procedure
81956>>>>>>>>>>>>>
81956>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGPROCEDURE_NAME Global String strProcName Integer iNumpar
81958>>>>>>>>>>>>>    local Integer iParam
81958>>>>>>>>>>>>>    local String  sParam
81958>>>>>>>>>>>>>
81958>>>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
81959>>>>>>>>>>>>>
81959>>>>>>>>>>>>>    // For Postgres, you can call a function just by passing the function name and
81959>>>>>>>>>>>>>    // open/close parens
81959>>>>>>>>>>>>>    SQL_SET_STMT to strProcName
81967>>>>>>>>>>>>>
81967>>>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
81967>>>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
81967>>>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
81967>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
81975>>>>>>>>>>>>>
81975>>>>>>>>>>>>>    For iParam from 1 to iNumpar
81981>>>>>>>>>>>>>>
81981>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
82013>>>>>>>>>>>>>    Loop
82014>>>>>>>>>>>>>>
82014>>>>>>>>>>>>>
82014>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
82022>>>>>>>>>>>>>
82022>>>>>>>>>>>>>    SQL_PREPARE_STMT
82034>>>>>>>>>>>>>    // Indicate that a stored function will be executed - Query = 0, Procedure = 1, Function = 2
82034>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_EMBEDDED_SQL_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 1 RESULT MertechInc_iRet
82039>>>>>>>>>>>>>End_Procedure
82040>>>>>>>>>>>>>
82040>>>>>>>>>>>>>//=============================================================================
82040>>>>>>>>>>>>>/// @Name        SQL_GET_STMT
82040>>>>>>>>>>>>>/// @Description This command returns the last embedded SQL statement that
82040>>>>>>>>>>>>>/// was executed into a string. Optional parameters can be passed to specify
82040>>>>>>>>>>>>>/// what character to start the string at and also the maximum number of
82040>>>>>>>>>>>>>/// characters to allow for the string.
82040>>>>>>>>>>>>>///
82040>>>>>>>>>>>>>/// @Assumptions
82040>>>>>>>>>>>>>/// @Status      Public
82040>>>>>>>>>>>>>/// @Drivers     All
82040>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
82040>>>>>>>>>>>>>/// @See                 SQL_GET_STATEMENT
82040>>>>>>>>>>>>>///
82040>>>>>>>>>>>>>/// @Syntax SQL_GET_STMT to {variable} [{max} {start}]
82040>>>>>>>>>>>>>/// @Param variable                     SQL statement to be executed
82040>>>>>>>>>>>>>/// @Param max                          Indicates the maximum number of characters to get (optional)
82040>>>>>>>>>>>>>/// @Param start                        Indicates what character to start at for the returned string (optional)
82040>>>>>>>>>>>>>///
82040>>>>>>>>>>>>>/// @Example
82040>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82040>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82040>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82040>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
82040>>>>>>>>>>>>>/// If (Found) Begin
82040>>>>>>>>>>>>>///     Showln sFirstName
82040>>>>>>>>>>>>>///     Showln sLastName
82040>>>>>>>>>>>>>/// End
82040>>>>>>>>>>>>>///
82040>>>>>>>>>>>>>/// SQL_GET_STATEMENT to sValue
82040>>>>>>>>>>>>>/// Showln sValue
82040>>>>>>>>>>>>>
82040>>>>>>>>>>>>>
82040>>>>>>>>>>>>>Function MertechInc_SQL_GET_STATEMENT Global Integer iLength Integer iStart Returns String
82042>>>>>>>>>>>>>    Local String sStatement
82042>>>>>>>>>>>>>
82042>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82044>>>>>>>>>>>>>
82044>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82046>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sStatement
82047>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SQL_STMT CALLBACK 0 PASSING sStatement iStart iLength RESULT MertechInc_iRet
82052>>>>>>>>>>>>>    End
82052>>>>>>>>>>>>>>
82052>>>>>>>>>>>>>    Function_Return sStatement
82053>>>>>>>>>>>>>End_Function
82054>>>>>>>>>>>>>
82054>>>>>>>>>>>>>//=============================================================================
82054>>>>>>>>>>>>>/// @Name        SQL_SET_FUNCTION_NAME
82054>>>>>>>>>>>>>/// @Description This command is used in the same way as SQL_SET_PROCEDURE_NAME
82054>>>>>>>>>>>>>/// and SQL_SET_STMT to set the name of the function to be executed. When
82054>>>>>>>>>>>>>/// calling SQL functions in this fashion, this command must be used along with
82054>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE (to execute the function), SQL_SET_FUNCTION_PARAMETER
82054>>>>>>>>>>>>>/// (to set the needed parameters) and SQL_GET_FUNCTION_RETURN (to get any
82054>>>>>>>>>>>>>/// returned value). The number of parameters must be set using the constant,
82054>>>>>>>>>>>>>/// NUMPAR, followed by the number of parameters. Note that when setting the
82054>>>>>>>>>>>>>/// name of the function, the user can be specified or, if left blank, the
82054>>>>>>>>>>>>>/// current user will be inserted before the function name.
82054>>>>>>>>>>>>>///
82054>>>>>>>>>>>>>/// @Assumptions
82054>>>>>>>>>>>>>/// @Status      Public
82054>>>>>>>>>>>>>/// @Drivers     All
82054>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82054>>>>>>>>>>>>>/// @See                 SQL_FUNCTION_EXECUTE SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
82054>>>>>>>>>>>>>///
82054>>>>>>>>>>>>>/// @Syntax SQL_SET_FUNCTION_NAME {function} NUMPAR {parameters}
82054>>>>>>>>>>>>>/// @Param function                     Full name of the function
82054>>>>>>>>>>>>>/// @Param parameters           Number of parameters to pass
82054>>>>>>>>>>>>>///
82054>>>>>>>>>>>>>/// @Example
82054>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
82054>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
82054>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
82054>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
82054>>>>>>>>>>>>>/// Showln dDOB
82054>>>>>>>>>>>>>
82054>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAFUNCTION_NAME Global String strProcName Integer iNumpar
82056>>>>>>>>>>>>>    Local Integer iParam
82056>>>>>>>>>>>>>
82056>>>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
82064>>>>>>>>>>>>>    SQL_APPEND_STMT to ":PAR_RET := "
82072>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
82080>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
82088>>>>>>>>>>>>>    For iParam from 1 to iNumpar
82094>>>>>>>>>>>>>>
82094>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
82126>>>>>>>>>>>>>    Loop
82127>>>>>>>>>>>>>>
82127>>>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
82135>>>>>>>>>>>>>    SQL_PREPARE_STMT
82147>>>>>>>>>>>>>
82147>>>>>>>>>>>>>    Move IS_OUT to MertechInc_iArg
82148>>>>>>>>>>>>>    Call_Driver 0 ORAFLEX Function CALLDRV_SET_PROC_ATTRIBUTE_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank MertechInc_iArg RESULT MertechInc_iRet
82153>>>>>>>>>>>>>
82153>>>>>>>>>>>>>    Increment MertechInc_iParamCount
82154>>>>>>>>>>>>>    Move ":PAR_RET" to MertechInc_sArg2
82155>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING MertechInc_Blank MertechInc_sArg2 16384 RESULT MertechInc_iRet
82160>>>>>>>>>>>>>End_Procedure
82161>>>>>>>>>>>>>
82161>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYFUNCTION_NAME Global String strProcName Integer iNumpar
82163>>>>>>>>>>>>>    Local Integer iParam
82163>>>>>>>>>>>>>
82163>>>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName
82164>>>>>>>>>>>>>
82164>>>>>>>>>>>>>    SQL_SET_STMT to "SELECT "
82172>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
82180>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
82188>>>>>>>>>>>>>    For iParam from 1 to iNumpar
82194>>>>>>>>>>>>>>
82194>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
82226>>>>>>>>>>>>>    Loop
82227>>>>>>>>>>>>>>
82227>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
82235>>>>>>>>>>>>>    SQL_PREPARE_STMT
82247>>>>>>>>>>>>>End_Procedure
82248>>>>>>>>>>>>>
82248>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_SQLFUNCTION_NAME Global String strProcName Integer iNumpar
82250>>>>>>>>>>>>>    Local Integer iParam
82250>>>>>>>>>>>>>
82250>>>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
82251>>>>>>>>>>>>>
82251>>>>>>>>>>>>>    If (not(strProcName contains ".")) Begin
82253>>>>>>>>>>>>>        String schema
82253>>>>>>>>>>>>>        GET_SCHEMA_NAME to schema
82275>>>>>>>>>>>>>        Move (schema + "." + strProcName) to strProcName
82276>>>>>>>>>>>>>    End
82276>>>>>>>>>>>>>>
82276>>>>>>>>>>>>>
82276>>>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
82284>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
82292>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
82300>>>>>>>>>>>>>End_Procedure
82301>>>>>>>>>>>>>
82301>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGFUNCTION_NAME Global String strProcName Integer iNumpar
82303>>>>>>>>>>>>>    Local Integer iParam
82303>>>>>>>>>>>>>
82303>>>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
82304>>>>>>>>>>>>>
82304>>>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
82312>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
82320>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
82328>>>>>>>>>>>>>End_Procedure
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>//=============================================================================
82329>>>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_PARAMETER
82329>>>>>>>>>>>>>/// @Description
82329>>>>>>>>>>>>>/// With this command you can pass one or more parameters to predefined
82329>>>>>>>>>>>>>/// stored procedures on a MySQL or Oracle server. The SQL_SET_PROCEDURE_PARAMETER
82329>>>>>>>>>>>>>/// command enables you to add a parameter to a stored procedure which you are
82329>>>>>>>>>>>>>/// planning to call. You can pass multiple parameters by calling the command
82329>>>>>>>>>>>>>/// for each parameter.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// When passing parameters you'll have to inform the driver which variable
82329>>>>>>>>>>>>>/// you are passing, starting with 1 from left-to-right in the parameter list.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// For each parameter you'll have to indicate if the variable is to be
82329>>>>>>>>>>>>>/// regarded as input, output or both.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>///@Assumptions
82329>>>>>>>>>>>>>/// @Status      Public
82329>>>>>>>>>>>>>/// @Drivers     All
82329>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-27 by Aaron Gulack
82329>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_PARAMETER {number} to {variable} {direction}
82329>>>>>>>>>>>>>/// @Param number                       Index number of the parameter being defined.
82329>>>>>>>>>>>>>/// @Param variable                     Variable holding the parameter to be passed.
82329>>>>>>>>>>>>>/// @Param direction            IN, OUT, IN_OUT, RSET, or leave blank
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
82329>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>//=============================================================================
82329>>>>>>>>>>>>>/// @Name        SQL_GET_PROCEDURE_PARAMETER
82329>>>>>>>>>>>>>/// @Description This command is used to get the value of a specific
82329>>>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
82329>>>>>>>>>>>>>/// command will work with any parameter, it is mostly be used with
82329>>>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
82329>>>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
82329>>>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
82329>>>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
82329>>>>>>>>>>>>>/// in order to work properly.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Assumptions
82329>>>>>>>>>>>>>/// @Status      Public
82329>>>>>>>>>>>>>/// @Drivers     All
82329>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82329>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Syntax SQL_GET_PROCEDURE_PARAMETER {parameter} to {variable}
82329>>>>>>>>>>>>>/// @Param parameter            Number of paramater to return
82329>>>>>>>>>>>>>/// @Param variable                     Variable to hold the value of the parameter
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
82329>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 1 to sStatus
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// Showln sStatus
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
82329>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
82329>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
82329>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// Showln sStatus
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>//=============================================================================
82329>>>>>>>>>>>>>/// @Name        SQL_GET_FUNCTION_RETURN
82329>>>>>>>>>>>>>/// @Description This variable is used to get the value returned from a SQL
82329>>>>>>>>>>>>>/// function call. After the function has been successfully called, this
82329>>>>>>>>>>>>>/// command takes the returned value and inserts it the given variable.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Assumptions
82329>>>>>>>>>>>>>/// @Status      Public
82329>>>>>>>>>>>>>/// @Drivers     All
82329>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82329>>>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Syntax SQL_GET_FUNCTION_RETURN to {variable}
82329>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
82329>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
82329>>>>>>>>>>>>>/// Showln dDOB
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>//=============================================================================
82329>>>>>>>>>>>>>/// @Name        SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>/// @Description This command is used to execute the function statement
82329>>>>>>>>>>>>>/// that was built by the SQL_SET_FUNCTION_NAME and subsequent
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER commands. This works similarly to the
82329>>>>>>>>>>>>>/// SQL_EXECUTE_STMT command. Note that executing the function with this
82329>>>>>>>>>>>>>/// command will not get any returned values but will simply execute the
82329>>>>>>>>>>>>>/// function.
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Assumptions
82329>>>>>>>>>>>>>/// @Status      Public
82329>>>>>>>>>>>>>/// @Drivers     All
82329>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82329>>>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Syntax SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>///
82329>>>>>>>>>>>>>/// @Example
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
82329>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
82329>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
82329>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
82329>>>>>>>>>>>>>/// Showln dDOB
82329>>>>>>>>>>>>>
82329>>>>>>>>>>>>>Procedure MertechInc_SQL_FUNCTION_EXECUTE Global String sDriverName
82331>>>>>>>>>>>>>    Local Integer iParam
82331>>>>>>>>>>>>>    Local String  sParam
82331>>>>>>>>>>>>>
82331>>>>>>>>>>>>>    If (sDriverName = SQLFLEX or sDriverName = PgFlex) Begin
82333>>>>>>>>>>>>>       SQL_APPEND_STMT to ')'
82341>>>>>>>>>>>>>       SQL_PREPARE_STMT
82353>>>>>>>>>>>>>    End
82353>>>>>>>>>>>>>>
82353>>>>>>>>>>>>>
82353>>>>>>>>>>>>>    SQL_EXECUTE_STMT
82368>>>>>>>>>>>>>    If (sDriverName <> ORAFLEX) Begin
82370>>>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
82385>>>>>>>>>>>>>>
82385>>>>>>>>>>>>>    End
82385>>>>>>>>>>>>>>
82385>>>>>>>>>>>>>End_Procedure
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>//=============================================================================
82386>>>>>>>>>>>>>/// @Name        REEXEC_ORACLE_STORED_PROCEDURE
82386>>>>>>>>>>>>>/// @Description This command is used to re-execute a stored procedure
82386>>>>>>>>>>>>>/// when using Oracle. Although it follows the same format as
82386>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE, it can be useful because it does not need to
82386>>>>>>>>>>>>>/// prepare the procedure again before executing. This can cause speed
82386>>>>>>>>>>>>>/// improvements when calling a stored procedure multiple times.
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Assumptions A procedure has already been created through CALL_STORED_PROCEDURE
82386>>>>>>>>>>>>>/// @Status      Public
82386>>>>>>>>>>>>>/// @Drivers     ORAFLex
82386>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82386>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
82386>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
82386>>>>>>>>>>>>>/// @Param variable                     Parameter to pass (optional and can be multiple)
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Example
82386>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "user.getCustomerStatus" Passing sCustomerID sStatus
82386>>>>>>>>>>>>>/// Showln sStatus
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// Move (sCustomerID + 1) to sCustomerID
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// REEXEC_ORACLE_STORED_PROCEDURE "user.getCustomerStatus" passing sCustomerID sStatus
82386>>>>>>>>>>>>>/// Showln sStatus
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>//=============================================================================
82386>>>>>>>>>>>>>/// @Name        CALL_STORED_FUNCTION
82386>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in the
82386>>>>>>>>>>>>>/// SQL backend. This is an alternative to building a function with the
82386>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME, SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE
82386>>>>>>>>>>>>>/// commands. This command builds and executes the function by setting the full
82386>>>>>>>>>>>>>/// function name, the parameter(s) to pass and the variable to hold the
82386>>>>>>>>>>>>>/// returned value. Note that this command can only return a single value
82386>>>>>>>>>>>>>/// so SQL_SET_FUNCTION_PARAMETER and SQL_SET_FUNCTION_NAME must be used when
82386>>>>>>>>>>>>>/// dealing with multiple return values.
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// Assumptions
82386>>>>>>>>>>>>>/// @Status      Public
82386>>>>>>>>>>>>>/// @Drivers     ORAFLex MySQLFlex PgFlex
82386>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82386>>>>>>>>>>>>>/// @See
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Syntax CALL_STORED_FUNCTION {function} Returns {variable} Passing {parameters}
82386>>>>>>>>>>>>>/// @Param function                     Full name of the function
82386>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82386>>>>>>>>>>>>>/// @Param parameters           Parameter to pass to the function (can be multiple)
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Example
82386>>>>>>>>>>>>>/// Move 5 to sCustomerID
82386>>>>>>>>>>>>>/// CALL_STORED_FUNCTION "getCustomerStatus" Returns sStatus Passing sCustomerID
82386>>>>>>>>>>>>>/// Showln sStatus
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>//=============================================================================
82386>>>>>>>>>>>>>/// @Name        OUTPUT_INT_FILE
82386>>>>>>>>>>>>>/// @Description This command is used to output the int file of an opened
82386>>>>>>>>>>>>>/// table. If the file to be output to does not exist, it will be created
82386>>>>>>>>>>>>>/// upon execution of this command. Note that the INT file can be output
82386>>>>>>>>>>>>>/// into multiple types of files i.e. .doc, .txt, .int.
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Assumptions
82386>>>>>>>>>>>>>/// @Status      Public
82386>>>>>>>>>>>>>/// @Drivers     All
82386>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82386>>>>>>>>>>>>>/// @See
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Syntax OUTPUT_INT_FILE for {FileNumber} to {variable}
82386>>>>>>>>>>>>>/// @Param FileNumber           The file number
82386>>>>>>>>>>>>>/// @Param variable                     Path of the file being output to
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>///@Example
82386>>>>>>>>>>>>>/// OUTPUT_INT_FILE for Customer.File_Number to "C:\Temp\Customer.int"
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>//=============================================================================
82386>>>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE
82386>>>>>>>>>>>>>/// @Description This command is used to get an error message
82386>>>>>>>>>>>>>/// from a given SQL statement. If the given statement is executed with
82386>>>>>>>>>>>>>/// no errors, the variable specified with this command will be blank.
82386>>>>>>>>>>>>>/// Otherwise the message will be stored in the given variable. Note that
82386>>>>>>>>>>>>>/// unless specified, strings have a size limit of 80 characters, so using
82386>>>>>>>>>>>>>/// a variant can ensure the full message is retrieved.
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Assumptions
82386>>>>>>>>>>>>>/// @Status      Public
82386>>>>>>>>>>>>>/// @Drivers     All
82386>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82386>>>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE2
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE {variable}
82386>>>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
82386>>>>>>>>>>>>>///
82386>>>>>>>>>>>>>/// @Example
82386>>>>>>>>>>>>>/// SQL_ERROR_MESSAGE sError
82386>>>>>>>>>>>>>
82386>>>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE Global Returns String
82388>>>>>>>>>>>>>    Local String sMessage
82388>>>>>>>>>>>>>
82388>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sMessage
82389>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE CALLBACK 0 PASSING MertechInc_Blank sMessage 0 RESULT MertechInc_iRet
82394>>>>>>>>>>>>>
82394>>>>>>>>>>>>>    Function_Return sMessage
82395>>>>>>>>>>>>>End_Function
82396>>>>>>>>>>>>>
82396>>>>>>>>>>>>>//=============================================================================
82396>>>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE2
82396>>>>>>>>>>>>>/// @Description This command is used to get the last error message used
82396>>>>>>>>>>>>>/// for the specified server. This can be useful once a transaction has
82396>>>>>>>>>>>>>/// already been completed and any error messages need to be retrieved.
82396>>>>>>>>>>>>>///
82396>>>>>>>>>>>>>/// @Assumptions
82396>>>>>>>>>>>>>/// @Status      Public
82396>>>>>>>>>>>>>/// @Drivers     All
82396>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82396>>>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE SQL_ERROR_MESSAGE2
82396>>>>>>>>>>>>>///
82396>>>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE2 of {server} to {variable}
82396>>>>>>>>>>>>>/// @Param server                       Name of the server
82396>>>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
82396>>>>>>>>>>>>>///
82396>>>>>>>>>>>>>/// @Example
82396>>>>>>>>>>>>>/// SQL_ERROR_MESSAGE2 of "localhost" to sError
82396>>>>>>>>>>>>>
82396>>>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE2 Global String sServer Returns String
82398>>>>>>>>>>>>>    Local String sMessage
82398>>>>>>>>>>>>>
82398>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 800 to sMessage
82399>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE2 CALLBACK 0 PASSING sServer sMessage 0 RESULT MertechInc_iRet
82404>>>>>>>>>>>>>
82404>>>>>>>>>>>>>    Function_Return sMessage
82405>>>>>>>>>>>>>End_Function
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        MERTECH_WARNING_MESSAGE
82406>>>>>>>>>>>>>/// @Description When restructuring a table, i.e. Structure_Start, a warning
82406>>>>>>>>>>>>>/// message will appear to confirm the restructure before it is executed.
82406>>>>>>>>>>>>>/// This command is used to disable or enable that warning message. All that
82406>>>>>>>>>>>>>/// is passed is either the constant "Enabled" or "Disabled". By default,
82406>>>>>>>>>>>>>/// this message is enabled.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax MERTECH_WARNING_MESSAGE {Enabled|Disabled}
82406>>>>>>>>>>>>>/// @Param Enabled                      Enables the restructure warning
82406>>>>>>>>>>>>>/// @Param Disabled                     Disables the restructure warning
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
82406>>>>>>>>>>>>>/// MERTECH_WARNING_MESSAGE Disabled
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// Structure_Start hFile
82406>>>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
82406>>>>>>>>>>>>>/// Structure_End hFile
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        DISABLE_SELECT_COLUMNS_ERRORS
82406>>>>>>>>>>>>>/// @Description When using SELECT_COLUMNS_FIND to limit the number of columns
82406>>>>>>>>>>>>>/// to fetch, the framework might still ask for columns that you do not need.
82406>>>>>>>>>>>>>/// As a result you'll end up getting runtime errors you do not want to see.
82406>>>>>>>>>>>>>/// This command gives you the ability to stop reporting errors for querying
82406>>>>>>>>>>>>>/// for data from columns that are not part of the query.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// DISABLED_SELECT_COLUMNS_ERRORS DISABLED will disable the errors, use
82406>>>>>>>>>>>>>/// ENABLED to turn the error messages back on.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// By default triggering error messages on unknown columns is ENABLED
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
82406>>>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND RESET_FETCH_FIELDS
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// Open Customer
82406>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
82406>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
82406>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// Clear Customer
82406>>>>>>>>>>>>>/// Repeat
82406>>>>>>>>>>>>>///    Find Gt Customer by Index.1
82406>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
82406>>>>>>>>>>>>>/// Until (Not(Found))
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax DISABLE_SELECT_COLUMNS_ERRORS {ENABLED|DISABLED}
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SQLFlex_REVISION
82406>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
82406>>>>>>>>>>>>>/// of the MSSQL driver associated with the current workspace into the
82406>>>>>>>>>>>>>/// specified variable.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Deprecated
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SQLFlex_REVISION {variable}
82406>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SQLFlex_REVISION sVersion
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SQLFlex_MAJOR_REVISION
82406>>>>>>>>>>>>>/// @Description This command will put the major version (no decimals) of
82406>>>>>>>>>>>>>/// the the MSSQL driver associated with the current workspace into the
82406>>>>>>>>>>>>>/// specified variable.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Deprecated
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SQLFlex_MAJOR_REVISION {variable}
82406>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SQLFlex_MAJOR_REVISION sVersion
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        LOGGED_USERS
82406>>>>>>>>>>>>>/// @Description This command returns the number of native users that are
82406>>>>>>>>>>>>>/// using the driver currently. This number is stored in the variable that
82406>>>>>>>>>>>>>/// is passed with the command.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 MAXIMUM_NUMBER_OF_USERS
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax LOGGED_USERS {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of users
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example LOGGED_USERS sUsers
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_USERS
82406>>>>>>>>>>>>>/// @Description This command returns the maximum number of user allowed by
82406>>>>>>>>>>>>>/// the current license.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 LOGGED_USERS
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_USERS {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of users
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_USERS sMax
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_DATABASE_NAME
82406>>>>>>>>>>>>>/// @Description This command overrides the database set in the INT file
82406>>>>>>>>>>>>>/// under DATABASE_SPACE_NAME. Any opens or finds will use the database
82406>>>>>>>>>>>>>/// specified here. This can be used when the database is not stated in
82406>>>>>>>>>>>>>/// the INT file or if the database needs to be dynamically changed for
82406>>>>>>>>>>>>>/// a certain query. If the database is not specified with this command
82406>>>>>>>>>>>>>/// or in the INT file, then the default database for the server will be
82406>>>>>>>>>>>>>/// used. To set the database to be used for embedded SQL statements,
82406>>>>>>>>>>>>>/// use SQL_USE_DATABASE.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PGFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_DATABASE_NAME SQL_USE_DATABASE
82406>>>>>>>>>>>>>/// @INTOPT              DATABASE_SPACE_NAME
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_DATABASE_NAME to {database}
82406>>>>>>>>>>>>>/// @Param database                     Name of the database
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// Login "localhost" "user" "pas123" "sql_drv"
82406>>>>>>>>>>>>>/// SET_DATABASE_NAME to "TestDB"
82406>>>>>>>>>>>>>/// Open Customer
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        GET_DATABASE_NAME
82406>>>>>>>>>>>>>/// @Description This command is used to get the name of the database
82406>>>>>>>>>>>>>/// currently being used. The name of the database is returned into the
82406>>>>>>>>>>>>>/// specified string. Even though this command works either way, it is
82406>>>>>>>>>>>>>/// typically used when the INT file does not contain the DATABASE_SPACE_NAME.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PgFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See SET_DATABASE_NAME SQL_USE_DATABASE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax GET_DATABASE_NAME to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the database name
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// GET_DATABASE_NAME to sDbName
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        GET_NAME_SPACE
82406>>>>>>>>>>>>>/// @Description This command returns the name space, or schema, being
82406>>>>>>>>>>>>>/// used with the current application.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     PgFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SET_NAME_SPACE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax GET_NAME_SPACE to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned name space.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// GET_NAME_SPACE to sNameSpace
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_NAME_SPACE
82406>>>>>>>>>>>>>/// @Description This command sets the name space, or schema, to be used
82406>>>>>>>>>>>>>/// for the application. In Postgres, schemas are objects where all the
82406>>>>>>>>>>>>>/// tables,views and indexes are stored. Separate schemas are used to
82406>>>>>>>>>>>>>/// specify relational data. Note that this command will override the
82406>>>>>>>>>>>>>/// NAME_SPACE value in the INT file.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     PgFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-14 By Ian Smith
82406>>>>>>>>>>>>>/// @See                 GET_NAME_SPACE
82406>>>>>>>>>>>>>/// @INTOPT              NAME_SPACE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_NAME_SPACE to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Name of the name space
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SET_NAME_SPACE to "public"
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SQL_USE_DATABASE
82406>>>>>>>>>>>>>/// @Description This command is used to specify which database is used
82406>>>>>>>>>>>>>/// for SQL statements only. Any normal table queries or changes will
82406>>>>>>>>>>>>>/// still use the default database, this only effects SQL statements.
82406>>>>>>>>>>>>>/// If none is specified then the default database is used. This can
82406>>>>>>>>>>>>>/// be useful if a certain SQL statement needs to query data from a
82406>>>>>>>>>>>>>/// database not currently being used. Note that this only works if
82406>>>>>>>>>>>>>/// the table name is not fully qualified in the SQl statement, i.e.
82406>>>>>>>>>>>>>/// "TestDB.Customer".
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex MySQLFLex PgSQL
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SET_DATABASE_NAME GET_DATABASE_NAME
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SQL_USE_DATABASE of {server} to {database}
82406>>>>>>>>>>>>>/// @Param server                       Name of the server (Postgre only)
82406>>>>>>>>>>>>>/// @Param database                     Name of the database
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SQL_USE_DATABASE "testDB"
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82406>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82406>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82406>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName
82406>>>>>>>>>>>>>/// If (Found) Begin
82406>>>>>>>>>>>>>///     Showln sFirstName
82406>>>>>>>>>>>>>///     Showln sLastName
82406>>>>>>>>>>>>>/// End
82406>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>/// @Description This command is used to set the server to be used when
82406>>>>>>>>>>>>>/// opening tables. It will override the SERVER_NAME token in the INT file.
82406>>>>>>>>>>>>>/// If the server is not specified in the INT file or with this command,
82406>>>>>>>>>>>>>/// then the server used during login will be used. This command is only
82406>>>>>>>>>>>>>/// needed when connecting to multiple SQL servers. To set the server to
82406>>>>>>>>>>>>>/// use for embedded SQL statements, use SET_CURRENT_SQL_SERVER_CONNECTION.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER  SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
82406>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER to {server}
82406>>>>>>>>>>>>>/// @Param server                       Name of the server
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER to "localhost"
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
82406>>>>>>>>>>>>>//               replace conflicts with the property SET message.
82406>>>>>>>>>>>>>//#Replace SET_CURRENT_SERVER SET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>/// @Description This command returns the name of the server to be used
82406>>>>>>>>>>>>>/// for opening and querying tables.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See SET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax GET_CURRENT_SERVER to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Variable to hold the server name
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER to sServer
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
82406>>>>>>>>>>>>>//               replace conflicts with the property GET message.
82406>>>>>>>>>>>>>//#Replace GET_CURRENT_SERVER GET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER_CONNECTION
82406>>>>>>>>>>>>>/// @Description This command is used to specify which server to use for
82406>>>>>>>>>>>>>/// embedded SQL statements. By default, the last logged in server will
82406>>>>>>>>>>>>>/// be used. Note that in addition to setting the server, this command
82406>>>>>>>>>>>>>/// also sets the driver to be used. This command is only needed when
82406>>>>>>>>>>>>>/// connecting to multiple servers. To set the server for opening tables,
82406>>>>>>>>>>>>>/// use SET_CURRENT_SQL_SERVER.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {server}
82406>>>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
82406>>>>>>>>>>>>>/// @Param server               Name of the server
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to "(localdb)\v11.0"
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER_CONNECTION
82406>>>>>>>>>>>>>/// @Description This command returns the server currently being used for
82406>>>>>>>>>>>>>/// embedded SQL statements.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax GET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {variable}
82406>>>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
82406>>>>>>>>>>>>>/// @Param variable             Variable to hold the name of the server
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        LOGIN_SQLFLEX
82406>>>>>>>>>>>>>/// @Description This command allows the user to login with a specified
82406>>>>>>>>>>>>>/// hostname. The default hostname that is passed is the path of the
82406>>>>>>>>>>>>>/// executable. Passing a custom hostname can be very useful for tracking
82406>>>>>>>>>>>>>/// a specific user for different situations. For example, if a company
82406>>>>>>>>>>>>>/// is using a terminal server and a whole sales team logs in under the
82406>>>>>>>>>>>>>/// same username and hostname, locating a specific user could otherwise
82406>>>>>>>>>>>>>/// be difficult. With this command, each user can pass a custom hostname,
82406>>>>>>>>>>>>>/// easily distinguishing themselves from other users.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax LOGIN_SQLFLEX {server} {username} {password} {hostname}
82406>>>>>>>>>>>>>/// @Param server               Server to use for login
82406>>>>>>>>>>>>>/// @Param username     Username to use for login
82406>>>>>>>>>>>>>/// @Param password     Password to use for login
82406>>>>>>>>>>>>>/// @Param hostname     Hostname to use for login
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// LOGIN_SQLFLEX "localhost" "guestUser" "pas123" "WIN-MM7PQS5CP6C"
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SQL_CANCEL_QUERY_STMT
82406>>>>>>>>>>>>>/// @Description This command is used to close any open cursors related to
82406>>>>>>>>>>>>>/// an SQL_EXECUTE_STMT. This should be used once the SQL statement has
82406>>>>>>>>>>>>>/// been executed and all rows have been fetched.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-03 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_EXECUTE_STMT SQL_FETCH_NEXT_ROW SQL_APPEND_STMT SQL_PREPARE_STMT
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SQL_CANCEL_QUERY_STMT [of {FileName}]
82406>>>>>>>>>>>>>/// @Param FileName             Name of the file (optional)
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82406>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82406>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
82406>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
82406>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW of Customer
82406>>>>>>>>>>>>>/// If (Found) Begin
82406>>>>>>>>>>>>>///     Showln Customer.FirstName
82406>>>>>>>>>>>>>///     Showln Customer.LastName
82406>>>>>>>>>>>>>/// End
82406>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT of Customer
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        NATIVE_OPTIMIZATION
82406>>>>>>>>>>>>>/// @Description Allows user to turn off the use of index hints on the native
82406>>>>>>>>>>>>>/// server. Setting this command to DEFAULT will cause the server to use the
82406>>>>>>>>>>>>>/// default settings for hints. Hints are off by default in Microsoft SQL
82406>>>>>>>>>>>>>/// Server but are on in Oracle. Care should be taken with changing the
82406>>>>>>>>>>>>>/// default, and should only be used if the diagnostics tool for your server
82406>>>>>>>>>>>>>/// indicates performance problems with the type of queries that are being
82406>>>>>>>>>>>>>/// generated. Note that this can be turned off or on for the whole server
82406>>>>>>>>>>>>>/// or just for a specific table.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// DEFAULT             - The specified server's default settings
82406>>>>>>>>>>>>>/// USE_INDEXHINT       - All Index hints will be used
82406>>>>>>>>>>>>>/// NO_INDEXHINT        - No index hints will be used
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     SQLFlex, ORAFlex
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax NATIVE_OPTIMIZATION of {scopeLevel} {variable} to {constant}
82406>>>>>>>>>>>>>/// @Param scopeLevel           TABLE or SERVER. Indicates the scope of the setting
82406>>>>>>>>>>>>>/// @Param variable                     Either the name of the server or of the table
82406>>>>>>>>>>>>>/// @Param constant                     DEFAULT, USE_INDEXHINT, or NO_INDEXHINT
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// NATIVE_OPTIMIZATION of SERVER "localhost" to USE_INDEXHINT
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_ISOLATION_LEVEL
82406>>>>>>>>>>>>>/// @Description This command sets the locking and row versioning behavior
82406>>>>>>>>>>>>>/// for SQL statements. See the options below for information on the various
82406>>>>>>>>>>>>>/// effects they can have on transactions.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// DEFAULT  - The default isolation level for the server (READ_COMMITTED
82406>>>>>>>>>>>>>/// for MSSQL).
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// READ_COMMITTED - This option is used to prevent dirty reads. A dirty
82406>>>>>>>>>>>>>/// read is when one transaction reads data from another transaction that
82406>>>>>>>>>>>>>/// has yet to be committed. If one transaction fails, the other now is
82406>>>>>>>>>>>>>/// dealing with invalid data. By setting the isolation level to
82406>>>>>>>>>>>>>/// READ_COMMITTED, dirty reads will be avoided by not allowing transactions
82406>>>>>>>>>>>>>/// to deal with any other data that has not been committed yet. However,
82406>>>>>>>>>>>>>/// in between statements within the current transaction, data can be changed
82406>>>>>>>>>>>>>/// by other transactions. This can result in phantom data or non-repeatable
82406>>>>>>>>>>>>>/// reads. Note that this can slow down performance speeds but is usually
82406>>>>>>>>>>>>>/// good practice.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// READ_UNCOMMITTED - This option is the least restrictive isolation level.
82406>>>>>>>>>>>>>/// With this option, dirty reads are allowed, thus no exclusive locks are
82406>>>>>>>>>>>>>/// honored and modified data from one uncommitted transaction can be read
82406>>>>>>>>>>>>>/// by other transactions.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// REPEATABLE_READ - This option is similar to the READ_COMMITTED option
82406>>>>>>>>>>>>>/// in that locks all placed on all transactions and uncommitted data from
82406>>>>>>>>>>>>>///     other transactions cannot be read, preventing dirty reads. However, unlike
82406>>>>>>>>>>>>>/// READ_COMMITTED, new rows that are added by other transactions can be read
82406>>>>>>>>>>>>>/// by the current transaction if it is retried, possibly resulting in phantom
82406>>>>>>>>>>>>>/// reads. This option should not be used unless there is a specific reason to
82406>>>>>>>>>>>>>/// do so.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// SERIALIZABLE - This option is the most restrictive isolation level. With
82406>>>>>>>>>>>>>/// this option, no interaction is allowed between transactions until they
82406>>>>>>>>>>>>>/// have been committed. Similar to READ_COMMITTED, no transaction can deal
82406>>>>>>>>>>>>>/// with any uncommitted data. On top of that though, range locks are placed on
82406>>>>>>>>>>>>>/// all rows being modified until the current transaction is complete. Because
82406>>>>>>>>>>>>>/// concurrency is so low with this option, performance speeds can be much lower
82406>>>>>>>>>>>>>/// and so this should only be used when there is a specific reason to do so.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_ISOLATION_LEVEL of {server} to {constant}
82406>>>>>>>>>>>>>/// @Param server                       Name of the server
82406>>>>>>>>>>>>>/// @Param constant                     DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, or SERIALIZABLE
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// LOGIN "localhost" "user" "pass123" "SQL_DRV"
82406>>>>>>>>>>>>>/// SET_ISOLATION_LEVEL of "localhost" to READ_COMMITTED
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>//=============================================================================
82406>>>>>>>>>>>>>/// @Name        SET_SESSION_PARAMETER
82406>>>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
82406>>>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
82406>>>>>>>>>>>>>/// code pages. When migrating data, this command is used to determine whether
82406>>>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
82406>>>>>>>>>>>>>/// migrating passwords with special characters may call for different code
82406>>>>>>>>>>>>>/// pages. Sending true will convert the OEM data to ANSI, sending false will
82406>>>>>>>>>>>>>/// not. Both OEM_TO_ANSI and OEM_TRANSLATION_STATE do essentially the same
82406>>>>>>>>>>>>>/// thing, however since MSSQL has the functionality built in, OEM_TO_ANSI
82406>>>>>>>>>>>>>/// will use MSSQL's built in translation and thus only works with SQLFlex.
82406>>>>>>>>>>>>>/// OEM_TRANSLATION_STATE is internal and built into the driver so it works
82406>>>>>>>>>>>>>/// for all drivers. Note that if using custom entries with
82406>>>>>>>>>>>>>/// SET_CUSTOM_OEM_TO_ANSI then OEM_TRANSLATION_STATE must be used. Also, if
82406>>>>>>>>>>>>>/// there are already custom entries set then turning OEM_TRANSLATION_STATE
82406>>>>>>>>>>>>>/// on will automatically enable those custom translations.
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Assumptions
82406>>>>>>>>>>>>>/// @Status      Public
82406>>>>>>>>>>>>>/// @Drivers     All
82406>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82406>>>>>>>>>>>>>/// @See                 SET_CUSTOM_OEM_TO_ANSI GET_CUSTOM_OEM_TO_ANSI
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Syntax SET_SESSION_PARAMETER {OEM_TO_ANSI/OEM_TRANSLATION_STATE} to {variable}
82406>>>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling translation
82406>>>>>>>>>>>>>///
82406>>>>>>>>>>>>>/// @Example
82406>>>>>>>>>>>>>/// SET_SESSION_PARAMETER OEM_TO_ANSI to True
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>Procedure MertechInc_SET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
82408>>>>>>>>>>>>>    Move iChar to MertechInc_sArg1
82409>>>>>>>>>>>>>    move (String(iOem) + "," + String(iAnsi)) to MertechInc_sArg2
82410>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_SET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
82415>>>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
82418>>>>>>>>>>>>>End_Procedure
82419>>>>>>>>>>>>>
82419>>>>>>>>>>>>>//=============================================================================
82419>>>>>>>>>>>>>/// @Name        SET_CUSTOM_OEM_TO_ANSI
82419>>>>>>>>>>>>>/// @Description In very rare situations, a custom OEM to ANSI translation
82419>>>>>>>>>>>>>/// is needed. When that is the case, this command can be used to create
82419>>>>>>>>>>>>>/// those custom entries. This is done by passing the character numbered
82419>>>>>>>>>>>>>/// position, the OEM value and the ANSI value. Note that
82419>>>>>>>>>>>>>/// OEM_TRANSLATION_STATE must be set to true for these custom entries to
82419>>>>>>>>>>>>>/// work.
82419>>>>>>>>>>>>>///
82419>>>>>>>>>>>>>/// @Assumptions
82419>>>>>>>>>>>>>/// @Status      Public
82419>>>>>>>>>>>>>/// @Drivers     All
82419>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82419>>>>>>>>>>>>>/// @See                 GET_CUSTOM_OEM_TO_ANSI SET_SESSION_PARAMETER
82419>>>>>>>>>>>>>///
82419>>>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
82419>>>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
82419>>>>>>>>>>>>>/// @Param value1                       Character number for the OEM value
82419>>>>>>>>>>>>>/// @Param value2                       Character number for the ANSI value
82419>>>>>>>>>>>>>
82419>>>>>>>>>>>>>Procedure MertechInc_GET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
82421>>>>>>>>>>>>>    Move iChar to MertechInc_sArg1
82422>>>>>>>>>>>>>    Move (Repeat(" ", 255)) to MertechInc_sArg2
82423>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_GET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
82428>>>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
82431>>>>>>>>>>>>>End_Function
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        GET_CUSTOM_OEM_TO_ANSI
82432>>>>>>>>>>>>>/// @Description This command returns the custom OEM and ANSI values
82432>>>>>>>>>>>>>/// respectively for a given character. If there is no custom translation
82432>>>>>>>>>>>>>/// for the specified character then no error will be raised, but nothing
82432>>>>>>>>>>>>>/// will be returned.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions There exists a custom translation for the specified character
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     All
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
82432>>>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
82432>>>>>>>>>>>>>/// @Param value1                       Variable to hold the OEM value
82432>>>>>>>>>>>>>/// @Param value2                       Variable to hold the ANSI value
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING
82432>>>>>>>>>>>>>/// @Description This command toggles off and on the automatic numeric
82432>>>>>>>>>>>>>/// data type remapping built into SQLFlex. When adding or creating
82432>>>>>>>>>>>>>/// smaller numeric columns during a restructure, SQLFlex will change
82432>>>>>>>>>>>>>/// the type to a more specific data type i.e. smallint or tinyint since
82432>>>>>>>>>>>>>/// they are handled more efficiently by the server. Sending false to this
82432>>>>>>>>>>>>>/// command will force SQl to keep the column as a numeric field, preserving
82432>>>>>>>>>>>>>/// the length and precision. Passing true will leave the remapping up to the
82432>>>>>>>>>>>>>/// driver.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     SQLFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to {variable}
82432>>>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling remapping
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Example
82432>>>>>>>>>>>>>/// Structure_Start hFile
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>///     Create_Field hFile
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>///     SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to False
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_NAME   of hFile iColumn to "Transaction_Count"
82432>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_TYPE   of hFile iColumn to DF_BCD
82432>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_LENGTH of hFile iColumn to 1
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// Structure_End hFile
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        SET_FORCE_DATE_FORMAT_INIT
82432>>>>>>>>>>>>>/// @Description At times, a stored procedure, function or trigger may
82432>>>>>>>>>>>>>/// alter the default format for dates. This could cause problems because,
82432>>>>>>>>>>>>>/// for example, if a trigger on a table does this, then every time a save
82432>>>>>>>>>>>>>/// takes place on that table, the format for dates will be changed. By
82432>>>>>>>>>>>>>/// sending true to this command, the date formats will reset to their
82432>>>>>>>>>>>>>/// default format. Note that this is essentially the same thing as running
82432>>>>>>>>>>>>>/// the SQL statement: "ALTER SESSION SET NLS_DATE_FORMAT='MM/DD/YYYY'", so
82432>>>>>>>>>>>>>/// in most situations, that should be used instead of this command.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Deprecated
82432>>>>>>>>>>>>>/// @Drivers     ORAFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_FORCE_DATE_FORMAT_INIT to {variable}
82432>>>>>>>>>>>>>/// @Param variable             Boolean variable enabling or disabling format reset
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        SET_STATIC_TABLE_OPTIMIZATION
82432>>>>>>>>>>>>>/// @Description At this time, this command no longer serves any function.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Deprecated
82432>>>>>>>>>>>>>/// @Drivers     SQLFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_STATIC_TABLE_OPTIMIZATION to {ENABLED/DISABLED}
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        GET_MAX_OBJECT_NAME_LENGTH
82432>>>>>>>>>>>>>/// @Description This command returns the maximum length allowed for object
82432>>>>>>>>>>>>>/// names in the SQl backend. This includes table names, column names,
82432>>>>>>>>>>>>>/// database names etc. The maximum length in put into the specified variable.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     All
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax GET_MAX_OBJECT_NAME_LENGTH to {variable}
82432>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum length
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Example
82432>>>>>>>>>>>>>/// GET_MAX_OBJECT_NAME_LENGTH to iMaxLength
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        SET_SQL_LOCK_TIMEOUT
82432>>>>>>>>>>>>>/// @Description This command is used to set the number of milliseconds
82432>>>>>>>>>>>>>/// an SQL statement waits for a database lock to be released before timing
82432>>>>>>>>>>>>>/// out. Locks are used with transactions to maintain atomicity. If a lock is
82432>>>>>>>>>>>>>/// not released before the timeout, then the statement will fail and an error
82432>>>>>>>>>>>>>/// will be raised. By default, the timeout is set to -1, indicating that
82432>>>>>>>>>>>>>/// statements will wait indefinitely before timing out.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     SQLFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See                 GET_SQL_LOCK_TIMEOUT
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax SET_SQL_LOCAL_TIMEOUT of {server} to {variable}
82432>>>>>>>>>>>>>/// @Param server                       Name of the server
82432>>>>>>>>>>>>>/// @Param variable                     Number of milliseconds to wait until timeout
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Example
82432>>>>>>>>>>>>>/// SET_SQL_LOCK_TIMEOUT of "localhost" to 6000
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        GET_SQL_LOCK_TIMEOUT
82432>>>>>>>>>>>>>/// @Description This command returns the number of milliseconds an SQL
82432>>>>>>>>>>>>>/// statement will wait for a database lock to be released. If the lock
82432>>>>>>>>>>>>>/// is not released before the timeout, then the statement will fail and
82432>>>>>>>>>>>>>/// an error will be raised. Note that the default value is -1, indicating
82432>>>>>>>>>>>>>/// that the statement will wait indefinitely.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Public
82432>>>>>>>>>>>>>/// @Drivers     SQLFlex
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82432>>>>>>>>>>>>>/// @See                 SET_SQL_LOCK_TIMEOUT
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Syntax GET_SQL_LOCAL_TIMEOUT of {server} to {variable}
82432>>>>>>>>>>>>>/// @Param server                       Name of the server
82432>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of milliseconds
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Example
82432>>>>>>>>>>>>>/// GET_SQL_LOCK_TIMEOUT of "localhost" to iTimeout
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>//=============================================================================
82432>>>>>>>>>>>>>/// @Name        DO_GET_SQLSERVER_PARAMETERS
82432>>>>>>>>>>>>>/// @Description Retrieves stored procedure parameter values.
82432>>>>>>>>>>>>>///
82432>>>>>>>>>>>>>/// @Assumptions
82432>>>>>>>>>>>>>/// @Status      Internal
82432>>>>>>>>>>>>>/// @Drivers     All
82432>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82432>>>>>>>>>>>>>/// @See
82432>>>>>>>>>>>>>
82432>>>>>>>>>>>>>Function MertechInc_DO_GET_SQLSERVER_PARAMETERS Global Integer iParameter Returns String
82434>>>>>>>>>>>>>    Local String sValue
82434>>>>>>>>>>>>>
82434>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sValue //Need to check if Call_Driver needs pre sized strings. Until then assume it does
82435>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 24 CALLBACK 0 PASSING sValue MertechInc_Blank iParameter RESULT MertechInc_iRet
82440>>>>>>>>>>>>>
82440>>>>>>>>>>>>>    Function_Return sValue
82441>>>>>>>>>>>>>End_Function
82442>>>>>>>>>>>>>
82442>>>>>>>>>>>>>//=============================================================================
82442>>>>>>>>>>>>>/// @Name        DO_BIND_SQLSERVER_PARAMETERS
82442>>>>>>>>>>>>>/// @Description Binds parameters for stored procedure call.
82442>>>>>>>>>>>>>///
82442>>>>>>>>>>>>>/// @Assumptions
82442>>>>>>>>>>>>>/// @Status      Internal
82442>>>>>>>>>>>>>/// @Drivers     All
82442>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82442>>>>>>>>>>>>>/// @See
82442>>>>>>>>>>>>>
82442>>>>>>>>>>>>>Procedure MertechInc_DO_BIND_SQLSERVER_PARAMETERS Global String sDirection String sParameter Integer iSize
82444>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sDirection sParameter iSize RESULT MertechInc_iRet
82449>>>>>>>>>>>>>End_Procedure
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        DO_CHECK_BINDING
82450>>>>>>>>>>>>>/// @Description Sets MertechInc_bThereIsBinding True if any of the
82450>>>>>>>>>>>>>/// parameters is the keyword BINDING.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Internal
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        DO_FETCH_FIRST_ROW
82450>>>>>>>>>>>>>/// @Description Recursive - drops first parameter until the first parameter
82450>>>>>>>>>>>>>/// is BINDING and then calls SQL_FETCH_NEXT_ROW passing remaining parameters.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Internal
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CALL_STORED_PROCEDURE
82450>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
82450>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
82450>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
82450>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
82450>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
82450>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
82450>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
82450>>>>>>>>>>>>>/// is set to true.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CALL_STORED_PROCEDURE {procedure} Passing {variable}
82450>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
82450>>>>>>>>>>>>>/// @Param variable                     Argument being passed (can be multiple)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CALL_SQLSERVER_PROCEDURE
82450>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
82450>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
82450>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
82450>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
82450>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
82450>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN, SQL_FETCH_NEXT_ROW or
82450>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN can be used to get the value(s). If an error is found
82450>>>>>>>>>>>>>/// then the indicator "Err" is set to true.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CALL_SQLSERVER_PROCEDURE {procedure} Passing {variable}
82450>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
82450>>>>>>>>>>>>>/// @Param variable                     Argument to be passed (can be multiple)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_SQLSERVER_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        END_CALL_PROCEDURE
82450>>>>>>>>>>>>>/// @Description This command is used to close any open cursors created
82450>>>>>>>>>>>>>/// by the respective stored procedure. Cursors are used in MSSQL to make
82450>>>>>>>>>>>>>/// the results from one procedure temporarily available to other procedures
82450>>>>>>>>>>>>>/// or triggers. To avoid causing unwanted results, it is good practice to
82450>>>>>>>>>>>>>/// use this command once a procedure call is completed.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax END_CALL_PROCEDURE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_spaceused" Passing "Customer"
82450>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sValue
82450>>>>>>>>>>>>>/// END_CALL_PROCEDURE
82450>>>>>>>>>>>>>/// Showln sValue
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_PROCEDURE_RETURN
82450>>>>>>>>>>>>>/// @Description This command is used to get a returned value from a stored
82450>>>>>>>>>>>>>/// procedure using MSSQL. Note that this command can only handle one
82450>>>>>>>>>>>>>/// returned value and must be used after the procedure has already been
82450>>>>>>>>>>>>>/// built and executed.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_PROCEDURE_RETURN to {variable}
82450>>>>>>>>>>>>>/// @Param variable             Variable to hold the returned value
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_spaceused" NUMPAR 1
82450>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to "Customer" IN
82450>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
82450>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sSpaceUsed
82450>>>>>>>>>>>>>/// Showln sSpaceUsed
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_MIRROR_SERVER
82450>>>>>>>>>>>>>/// @Description This command is used to programmatically set the mirror
82450>>>>>>>>>>>>>/// server for the database. This is to be used along with SQl server
82450>>>>>>>>>>>>>/// failover mirroring. Note that this simply sets the server and database
82450>>>>>>>>>>>>>/// to be used for mirroring. All set up for the servers must already be
82450>>>>>>>>>>>>>/// working properly through SQL Server.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions A compatible version of SQL Server is being used
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 GET_MIRROR_SERVER
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_MIRROR_SERVER to {server} {database}
82450>>>>>>>>>>>>>/// @Param server                       The name of the mirror server
82450>>>>>>>>>>>>>/// @Param database                     The database acting as a mirror
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SET_MIRROR_SERVER to "(localdb)\v11.0" "MirrorDB"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_MIRROR_SERVER
82450>>>>>>>>>>>>>/// @Description This command is used to get the name of the server
82450>>>>>>>>>>>>>/// and database being used for failover mirroring. Mirroring must
82450>>>>>>>>>>>>>/// be properly set up in SQL Server for this command to return the
82450>>>>>>>>>>>>>/// correct values.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_MIRROR_SERVER
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_MIRROR_SERVER to {server} {database}
82450>>>>>>>>>>>>>/// @Param server                       Variable to hold the name of the mirrored server
82450>>>>>>>>>>>>>/// @Param database                     Variable to hold the name of the mirrored database
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// GET_MIRROR_SERVER to sServer sDatabase
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        COPY_DATA
82450>>>>>>>>>>>>>/// @Description This command is used to copy data from a DAT file to an
82450>>>>>>>>>>>>>/// SQL table. Both the source and the destination files are opened, the
82450>>>>>>>>>>>>>/// data is copied and then the files are closed. This is usually used
82450>>>>>>>>>>>>>/// along with CREATE_TABLE_FROM_DAT_FILE, which creates the structure
82450>>>>>>>>>>>>>/// and then this command will insert the data. If needed, this command
82450>>>>>>>>>>>>>/// can also work backwards, copying data from an SQL table to a DAT file.
82450>>>>>>>>>>>>>/// This is an alternative to using the Flex2SQL Migration Tool and can
82450>>>>>>>>>>>>>/// improve performance when used in the right situations. Note that in
82450>>>>>>>>>>>>>/// order for this process to work properly the table being copied can not
82450>>>>>>>>>>>>>/// be opened. Because of this, a manual login must take place, using
82450>>>>>>>>>>>>>/// something like LOGIN_SQLFLEX or LOGIN. Since this only copies the data,
82450>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE can be used to create the table structure.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Because COPY_DATA requires no user interaction, an optional callback
82450>>>>>>>>>>>>>/// function can be passed for tracing purposes. By passing the constant
82450>>>>>>>>>>>>>/// "CALLBACK" followed by the object name, a function can be used to set
82450>>>>>>>>>>>>>/// up messages for tracking and error handling. Below is more information
82450>>>>>>>>>>>>>/// regarding this callback object.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// This function should follow this pattern:
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Function Callback String sText Integer iStatusID Returns Integer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// sText - Message corresponding to the current status ID
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// iStatusID - Integer value mapping to the current status constant:
82450>>>>>>>>>>>>>///                     DF_MESSAGE_PROGRESS_TITLE    Sent when SQLFlex starts the
82450>>>>>>>>>>>>>///                                                                              process
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///             DF_MESSAGE_HEADING_1         Sent when SQLFlex is about to
82450>>>>>>>>>>>>>///                                                                              copy the source data
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///             DF_MESSAGE_ERROR             Sent when an error occurs
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///             DF_MESSAGE_PROGRESS_STATUS   Sent each time an additional
82450>>>>>>>>>>>>>///                                                                              10% of the data is copied
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// NOTE: Returning false each time the function is called will continue
82450>>>>>>>>>>>>>/// copying process. Returning true will end it.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Another optional parameter that can be used is a constrain on the data
82450>>>>>>>>>>>>>/// being copied. This is done by passing the constant "CONSTRAIN" followed
82450>>>>>>>>>>>>>/// by an SQL constrain statement. When passing a constrain but not a callback
82450>>>>>>>>>>>>>/// object, pass 0 for the callback before passsing the constrain.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE CONVERT_DAT_FILE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax COPY_DATA {from} to {destination} [CALLBACK {function}] [CONSTRAIN {variable}]
82450>>>>>>>>>>>>>/// @Param from                         Table to copy from.
82450>>>>>>>>>>>>>/// @Param destination          Table to copy to.
82450>>>>>>>>>>>>>/// @Param function             Object with callback function (optional)
82450>>>>>>>>>>>>>/// @Param variable                     SQL contraint to use when copying (optional)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Object CallBackObj is a Array
82450>>>>>>>>>>>>>///     Function Callback String sText Integer iLogicalID Returns Integer
82450>>>>>>>>>>>>>///         If (iLogicalID = DF_MESSAGE_ERROR) Begin
82450>>>>>>>>>>>>>///             Showln "Error"
82450>>>>>>>>>>>>>///                             Showln sText
82450>>>>>>>>>>>>>///                             Function_Return True
82450>>>>>>>>>>>>>///         End
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///         Else Showln sText
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///                     Function_Return False
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>///     End_Function
82450>>>>>>>>>>>>>/// End_Object
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
82450>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
82450>>>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        ORAFlex_REVISION
82450>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
82450>>>>>>>>>>>>>/// of the Oracle driver associated with the current workspace into the specified
82450>>>>>>>>>>>>>/// variable.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax ORAFlex_REVISION {variable}
82450>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// ORAFlex_REVISION sVersion
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        KEEP_FILES_OPEN
82450>>>>>>>>>>>>>/// @Description Keep the files, currently in use, open after the server is
82450>>>>>>>>>>>>>/// logged out. Sometimes an application needs to login to the same server
82450>>>>>>>>>>>>>/// with a different user id. When logging out, however, the drivers
82450>>>>>>>>>>>>>/// automatically close all opened files. The overhead of opening these files
82450>>>>>>>>>>>>>/// should be avoided if the user will work with the same files that were
82450>>>>>>>>>>>>>/// closed. KEEP_FILES_OPEN keeps all files opened after a user logs out
82450>>>>>>>>>>>>>/// from the server.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax KEEP_FILES_OPEN of {server}
82450>>>>>>>>>>>>>/// @Param server               Name of the server
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_MAX_OPEN_CURSORS
82450>>>>>>>>>>>>>/// @Description Set the maximum number of cursors you want the driver to use.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// The driver will recycle the least used cursors if this limit is hit.
82450>>>>>>>>>>>>>/// The trade off is between increased resources on the server and
82450>>>>>>>>>>>>>/// re-preparing of cursors.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// For a program that keeps 40+ files opened at the same time, 255 is a good
82450>>>>>>>>>>>>>/// number for the open cursors parameter. For programs that open less than
82450>>>>>>>>>>>>>/// 40 files, any number between 100-255 is sufficient. These numbers can be
82450>>>>>>>>>>>>>/// changed based on available server resources.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// On Oracle this value should not exceed the value of open_cursors in
82450>>>>>>>>>>>>>/// init.ora
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// Note: Only change this setting if you are having performance issues
82450>>>>>>>>>>>>>/// and the server is indicating you are using up too many cursors or too
82450>>>>>>>>>>>>>/// much memory. GET_OPENED_CURSORS can be used to check the number of
82450>>>>>>>>>>>>>/// cursors the server has opened. If this number is hitting the limit,
82450>>>>>>>>>>>>>/// it is worth increasing the number, as long as the server has enough
82450>>>>>>>>>>>>>/// resources.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         GET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_MAX_OPEN_CURSORS of {server} to {variable}
82450>>>>>>>>>>>>>/// @Param server                       The name of the server
82450>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_MAX_OPEN_CURSORS
82450>>>>>>>>>>>>>/// @Description This command will return the maximum number of open
82450>>>>>>>>>>>>>/// cursors allowed by the server.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
82450>>>>>>>>>>>>>/// @Param server                       Name of the server
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of open cursors
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_OPENED_CURSORS
82450>>>>>>>>>>>>>/// @Description This command returns the number of cursors currently
82450>>>>>>>>>>>>>/// open on the server.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_MAX_OPEN_CURSORS
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
82450>>>>>>>>>>>>>/// @Param server                       Name of the server
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of cursors currently open
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        ACTIVATE_TIME_STAMP
82450>>>>>>>>>>>>>/// @Description This command will specify whether or not to show the time
82450>>>>>>>>>>>>>/// portion of a date field. When set to ON, the time portion will be
82450>>>>>>>>>>>>>/// included, OFF will just show the date. This is the same as changing
82450>>>>>>>>>>>>>/// the date format with "ALTER SESSION SET nls_timestamp_format". Note that
82450>>>>>>>>>>>>>/// this will only take effect if the date is put into a string variable.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     OraFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax ACTIVATE_TIME_STAMP of {server} to {ON/OFF}
82450>>>>>>>>>>>>>/// @Param server                       Name of the server
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// ACTIVATE_TIME_STAMP of "localhost/orcl.localdomain" to OFF
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SET_STMT to 'SELECT * from USER."Customer" '
82450>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82450>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82450>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
82450>>>>>>>>>>>>>/// If (Found) Begin
82450>>>>>>>>>>>>>///     Showln sDOB
82450>>>>>>>>>>>>>/// End
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_FUNCTION
82450>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
82450>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
82450>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
82450>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
82450>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
82450>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
82450>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
82450>>>>>>>>>>>>>/// values.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     ORAFLex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_FUNCTION {function} Returns {variable} Passing {argument}
82450>>>>>>>>>>>>>/// @Param function                     Full name of the function
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82450>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_ORACLE_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
82450>>>>>>>>>>>>>/// Showln sStatus
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CALL_PGSQL_STORED_FUNCTION
82450>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
82450>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
82450>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
82450>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
82450>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
82450>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
82450>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
82450>>>>>>>>>>>>>/// values.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Status      Deprecated
82450>>>>>>>>>>>>>/// @Drivers     PGFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CALL_PGSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
82450>>>>>>>>>>>>>/// @Param function                     Full name of the function
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82450>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// CALL_PGSQL_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
82450>>>>>>>>>>>>>/// Showln sStatus
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        MERTECH_LANGUAGE_SUPPORT
82450>>>>>>>>>>>>>/// @Description Sets the support language for the driver.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Internal
82450>>>>>>>>>>>>>/// @Drivers     ORAFLex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax MERTECH_LANGUAGE_SUPPORT of {server} to {language}
82450>>>>>>>>>>>>>/// @Param server               The name of the server being used
82450>>>>>>>>>>>>>/// @Param language             The language to set support to
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_BEGIN
82450>>>>>>>>>>>>>/// @Description This command is used to initialize a SAVE_BUFFER
82450>>>>>>>>>>>>>/// statement. Doing this will allow a specified set of records to be
82450>>>>>>>>>>>>>/// stored in the buffer before a save takes place. Once the buffer is
82450>>>>>>>>>>>>>/// filled, it will be saved automatically. This set of commands can be
82450>>>>>>>>>>>>>/// used to efficiently save a large number of records. Once the buffer
82450>>>>>>>>>>>>>/// is full, the save occurs automatically and the buffer will be emptied
82450>>>>>>>>>>>>>/// out. It is good practice to use this method inside of a transaction to
82450>>>>>>>>>>>>>/// maintain atomicity. Note that these commands should not be used in
82450>>>>>>>>>>>>>/// conjuction with finds.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_END SQL_SAVE_BUFFER
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_BEGIN of {FileName} to {variable}
82450>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82450>>>>>>>>>>>>>/// @Param variable                     Number of records to store in the buffer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Open Customer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// For i from 0 to 1000
82450>>>>>>>>>>>>>///     Move i to Transactions.ID
82450>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
82450>>>>>>>>>>>>>/// Loop
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER
82450>>>>>>>>>>>>>/// @Description This command is used to send a record to the "Save
82450>>>>>>>>>>>>>/// Record" buffer. It must be used along with SQL_SAVE_BUFFER_BEGIN
82450>>>>>>>>>>>>>/// and SQL_SAVE_BUFFER_END. SQL_SAVE_BUFFER_BEGIN sets the number of
82450>>>>>>>>>>>>>/// records to store in the buffer before a save is done on all the records
82450>>>>>>>>>>>>>/// at once. Each time a record is created, this command should be called
82450>>>>>>>>>>>>>/// to insert it into the buffer. Using this set of commands can be useful
82450>>>>>>>>>>>>>/// to efficiently save a large number of records. Once the buffer is full,
82450>>>>>>>>>>>>>/// the save occurs automatically and the buffer will be emptied out. It is
82450>>>>>>>>>>>>>/// good practice to use this method inside of a transaction to maintain
82450>>>>>>>>>>>>>/// atomicity.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER_END
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER of {FileName}
82450>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Open Customer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// For i from 0 to 1000
82450>>>>>>>>>>>>>///     Move i to Transactions.ID
82450>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
82450>>>>>>>>>>>>>/// Loop
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_END
82450>>>>>>>>>>>>>/// @Description This command indicates the end of the extended record
82450>>>>>>>>>>>>>/// buffer and forces a save of any data currently in the buffer.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_END of {FileName}
82450>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Open Customer
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// For i from 0 to 1000
82450>>>>>>>>>>>>>///     Move i to Transactions.ID
82450>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
82450>>>>>>>>>>>>>/// Loop
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SQL_SAVE_SET_ATTRIBUTES
82450>>>>>>>>>>>>>/// @Description Unknown - Not in help - Not call by any other macros
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Internal
82450>>>>>>>>>>>>>/// @Drivers     SQLFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
82450>>>>>>>>>>>>>/// @See
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        ENABLE_TRACE_ON
82450>>>>>>>>>>>>>/// @Description This command enables driver level tracing to the
82450>>>>>>>>>>>>>/// specified file. Enabling trace on an application and using it
82450>>>>>>>>>>>>>/// in conjunction with SQL_TEXT_MESSAGE is a good way to study
82450>>>>>>>>>>>>>/// particular problems you encounter in the driver. SQL_TEXT_MESSAGE
82450>>>>>>>>>>>>>/// allows you to insert sections of your code into the trace file.
82450>>>>>>>>>>>>>/// This command can also set the trace to three different levels,
82450>>>>>>>>>>>>>/// allowing different amounts of information to be logged. Note that
82450>>>>>>>>>>>>>/// trace files can become very large so it is good practice to only
82450>>>>>>>>>>>>>/// turn them on when specifically needed.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 DISABLE_TRACE_ON SQL_TEXT_MESSAGE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax ENABLE_TRACE_ON to {fileName} Debug_Level [{constant}]
82450>>>>>>>>>>>>>/// @Param fileName                     The path of the file to send the trace to
82450>>>>>>>>>>>>>/// @Param constant             DETAIL_LEVEL1, DETAIL_LEVEL2, DETAIL_LEVEL3 (optional)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example ENABLE_TRACE_ON TO "C:\Temp\trace_file.txt" Debug_Level DETAIL_LEVEL3
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        DISABLE_TRACE_ON
82450>>>>>>>>>>>>>/// @Description This command disables the current trace taking
82450>>>>>>>>>>>>>/// place on a driver.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See ENABLE_TRACE_ON SQL_TEXT_MESSAGE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax DISABLE_TRACE_ON
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CREATE_TABLE_FROM_DAT_FILE
82450>>>>>>>>>>>>>/// @Description This command is used to create a SQL table from a .DAT
82450>>>>>>>>>>>>>/// file. The table being copied must be not be opened in order for this
82450>>>>>>>>>>>>>/// command to work properly. This is the programmatic equivalent to
82450>>>>>>>>>>>>>/// using the Flex2SQL Migration Tool. Optional restructuring options
82450>>>>>>>>>>>>>/// can be specified here (see below) as well as an alternative table
82450>>>>>>>>>>>>>/// name than the physical name of the .DAT file. Note that this only
82450>>>>>>>>>>>>>/// creates the  table structure, no data will be copied here. To copy
82450>>>>>>>>>>>>>/// the data, use COPY_DATA after the table has been created.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 COPY_DATA CONVERT_DAT_FILE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CREATE_TABLE_FROM_DAT_FILE {FileNumber} [{options} {table}]
82450>>>>>>>>>>>>>/// @Param FileNumber           Number of the file
82450>>>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
82450>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
82450>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
82450>>>>>>>>>>>>>/// @Param table            name of table to use instead of physical name (optional)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
82450>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
82450>>>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        CONVERT_DAT_FILE
82450>>>>>>>>>>>>>/// @Description This command is the programmatic equivalent to the
82450>>>>>>>>>>>>>/// Flex2SQL Migration Tool. With this command, a SQL table can be
82450>>>>>>>>>>>>>/// created from a .DAT table. This combines the COPY_DATA and
82450>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE, creating the table structure and
82450>>>>>>>>>>>>>/// copying all the data into the new table with one command. The
82450>>>>>>>>>>>>>/// table being converted cannot be opened and so a manual login is
82450>>>>>>>>>>>>>/// needed. Note that to specify the database to copy the table to,
82450>>>>>>>>>>>>>/// use SET_DATABASE_NAME. Below is a list of the optional restructure
82450>>>>>>>>>>>>>/// options to use when creating the table.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE COPY_DATA
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax CONVERT_DAT_FILE {FileNumber} [{options} {table}]
82450>>>>>>>>>>>>>/// @Param FileNumber           Number of the file
82450>>>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
82450>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
82450>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
82450>>>>>>>>>>>>>/// @Param table            Name of table to use instead of physical name (optional)
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
82450>>>>>>>>>>>>>/// CONVERT_DAT_FILE Customer.File_Number DF_STRUCTEND_OPT_FORCE_NOT_NULL "Customer"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_DEFAULT_FILE_CASING
82450>>>>>>>>>>>>>/// @Description This command is used to set the file casing standard when
82450>>>>>>>>>>>>>/// creating or restructuring tables. By default, all table and column names
82450>>>>>>>>>>>>>/// are created using the specified casing. Passing FILE_CASING_UPPER or
82450>>>>>>>>>>>>>/// FILE_CASING_LOWER will allow the names to be saved in uppercase or
82450>>>>>>>>>>>>>/// lowercase respectively. This can be useful for backwards compatibility
82450>>>>>>>>>>>>>/// where casing was important. Note that the casing standard for a file can
82450>>>>>>>>>>>>>/// also be changed through mertech.ini. Below is a description of the constants
82450>>>>>>>>>>>>>/// that can be passed to this command.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
82450>>>>>>>>>>>>>/// FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
82450>>>>>>>>>>>>>/// FILE_CASING_KEEP (default) : All created or edited object names will maintain their inputed casing.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 GET_DEFAULT_FILE_CASING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_FILE_CASING to {constant}
82450>>>>>>>>>>>>>/// @Param constant                     FILE_CASING_UPPER, FILE_CASING_LOWER, FILE_CASING_KEEP
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SET_DEFAULT_FILE_CASING to FILE_CASING_UPPER
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_DEFAULT_FILE_CASING
82450>>>>>>>>>>>>>/// @Description This command returns the file casing standard used
82450>>>>>>>>>>>>>/// when creating or restructuring tables. Note that an integer is returned,
82450>>>>>>>>>>>>>/// mapping to a casing method. Below are the meanings of the possible
82450>>>>>>>>>>>>>/// returned integers.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// 0 - FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
82450>>>>>>>>>>>>>/// 1 - FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
82450>>>>>>>>>>>>>/// 2 - FILE_CASING_KEEP : All created or edited object names will maintain their inputed casing.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_DEFAULT_FILE_CASING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_FILE_CASING to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned casing
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// GET_DEFAULT_FILE_CASING TO iCasing
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_DEFAULT_TABLESPACE
82450>>>>>>>>>>>>>/// @Description This command sets the default table space to use when
82450>>>>>>>>>>>>>/// creating tables through Dataflex. A tablespace is a container of
82450>>>>>>>>>>>>>/// segments (objects that have an allotted amount of space), i.e. tables
82450>>>>>>>>>>>>>/// and indexes.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_TABLESPACE to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Name of the default table space
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SET_DEFAULT_TABLESPACE to "Users"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_DEFAULT_TABLESPACE
82450>>>>>>>>>>>>>/// @Description This command returns the default table space name for
82450>>>>>>>>>>>>>/// the current database.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_TABLESPACE to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default table space name.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// GET_DEFAULT_TABLESPACE to sTableSpace
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        SET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>/// @Description This command sets the default table space for indexes
82450>>>>>>>>>>>>>/// when creating tables through the DataFlex API. A tablespace is a
82450>>>>>>>>>>>>>/// container of segments (objects that have an allotted amount of space),
82450>>>>>>>>>>>>>/// i.e. tables and indexes.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09-2013 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_INDEX_TABLESPACE to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// SET_DEFAULT_INDEX_TABLESPACE to "Users"
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        GET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>/// @Description This command returns the default table space name for
82450>>>>>>>>>>>>>/// indexes in the current database.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_INDEX_TABLESPACE to {variable}
82450>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// GET_DEFAULT_INDEX_TABLESPACE to sTableSpace
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        ENABLE_SCRIPTING
82450>>>>>>>>>>>>>/// @Description Scripting is used for testing and preparation. This
82450>>>>>>>>>>>>>/// command allows structural changes to be compiled and tested without
82450>>>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
82450>>>>>>>>>>>>>/// between this command and DISABLE_SCRIPTING will not actually be
82450>>>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
82450>>>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82450>>>>>>>>>>>>>/// @See                 DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax ENABLE_SCRIPTING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// ENABLE_SCRIPTING
82450>>>>>>>>>>>>>///     //Table restructuring would go here
82450>>>>>>>>>>>>>/// DISABLE_SCRIPTING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
82450>>>>>>>>>>>>>/// Showln sChunk
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>//=============================================================================
82450>>>>>>>>>>>>>/// @Name        DISABLE_SCRIPTING
82450>>>>>>>>>>>>>/// @Description This command ends any scripting started by ENABLE_SCRIPTING.
82450>>>>>>>>>>>>>/// The mock INT file and script can then be retrieved and examined.
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Assumptions
82450>>>>>>>>>>>>>/// @Status      Public
82450>>>>>>>>>>>>>/// @Drivers     All
82450>>>>>>>>>>>>>/// @VersionNote Last Revised: 2010-12-13 By Marcelo Nachbar
82450>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING  GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Syntax DISABLE_SCRIPTING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// @Example
82450>>>>>>>>>>>>>/// ENABLE_SCRIPTING
82450>>>>>>>>>>>>>///     //Table restructuring would go here
82450>>>>>>>>>>>>>/// DISABLE_SCRIPTING
82450>>>>>>>>>>>>>///
82450>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
82450>>>>>>>>>>>>>/// Showln sChunk
82450>>>>>>>>>>>>>
82450>>>>>>>>>>>>>Function MertechInc_GET_RESTRUCTURE_SCRIPT Global Integer iLong Integer iOffset Returns String
82452>>>>>>>>>>>>>    Local Integer iChuck_Size
82452>>>>>>>>>>>>>    Local String sChunk
82452>>>>>>>>>>>>>
82452>>>>>>>>>>>>>    //Get current Chuck size and pre size string
82452>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
82457>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
82458>>>>>>>>>>>>>
82458>>>>>>>>>>>>>    //Get data
82458>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_RESTRUCTURE_SCRIPT CALLBACK 0 PASSING sChunk iOffset iLong RESULT MertechInc_iRet
82463>>>>>>>>>>>>>
82463>>>>>>>>>>>>>    // Replace insert a CR before any LF character
82463>>>>>>>>>>>>>    Move (Replaces(Character(10), sChunk, Character(13)+Character(10))) to sChunk
82464>>>>>>>>>>>>>
82464>>>>>>>>>>>>>    Function_Return sChunk
82465>>>>>>>>>>>>>End_Function
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>//=============================================================================
82466>>>>>>>>>>>>>/// @Name        GET_SQL_SCRIPT_CHUNK
82466>>>>>>>>>>>>>/// @Description This command returns a chunk of the script generated
82466>>>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
82466>>>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some scripts can be very large, the script
82466>>>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Assumptions
82466>>>>>>>>>>>>>/// @Status      Public
82466>>>>>>>>>>>>>/// @Drivers     All
82466>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82466>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_INT_CHUNK
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Syntax GET_SQL_SCRIPT_CHUNK OFFSET {offset} to {variable} [{length}]
82466>>>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
82466>>>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
82466>>>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Example
82466>>>>>>>>>>>>>/// ENABLE_SCRIPTING
82466>>>>>>>>>>>>>///     //Table restructuring would go here
82466>>>>>>>>>>>>>/// DISABLE_SCRIPTING
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
82466>>>>>>>>>>>>>/// Showln sChunk
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>//=============================================================================
82466>>>>>>>>>>>>>/// @Name        GET_INT_CHUNK
82466>>>>>>>>>>>>>/// @Description This command returns a chunk of the INT file generated
82466>>>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
82466>>>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some INT files can be very large, the file
82466>>>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Assumptions
82466>>>>>>>>>>>>>/// @Status      Public
82466>>>>>>>>>>>>>/// @Drivers     All
82466>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82466>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Syntax GET_INT_CHUNK OFFSET {offset} to {variable} [{length}]
82466>>>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
82466>>>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
82466>>>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Example
82466>>>>>>>>>>>>>/// ENABLE_SCRIPTING
82466>>>>>>>>>>>>>///     //Table restructuring would go here
82466>>>>>>>>>>>>>/// DISABLE_SCRIPTING
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// GET_INT_CHUNK OFFSET 0 to sChunk sLength
82466>>>>>>>>>>>>>/// Showln sChunk
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>//=============================================================================
82466>>>>>>>>>>>>>/// @Name        REPORT_STMT
82466>>>>>>>>>>>>>/// @Description This command is an alternative to DataFlex's "Report"
82466>>>>>>>>>>>>>/// command. This allows embedded SQL to be used to fetch data instead of
82466>>>>>>>>>>>>>/// standard table queries.. All of the finds, for example, normally found
82466>>>>>>>>>>>>>/// in "Report" are replaced by SQL_FETCH_NEXT_ROW.
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Assumptions
82466>>>>>>>>>>>>>/// @Status      Public
82466>>>>>>>>>>>>>/// @Drivers     n/a
82466>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82466>>>>>>>>>>>>>/// @See
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Syntax See DataFlex / Visual DataFlex documentation
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Example
82466>>>>>>>>>>>>>/// /Header
82466>>>>>>>>>>>>>/// __/__/____                                                        Page ___.
82466>>>>>>>>>>>>>///                 MERTECH DATA SYSTEMS, INC. - NOT FOR RESALE
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// ID   NAME
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// /Body
82466>>>>>>>>>>>>>/// ____ _________________________
82466>>>>>>>>>>>>>/// /Total
82466>>>>>>>>>>>>>/// Records printed = _______.
82466>>>>>>>>>>>>>/// /*
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// OPEN SALESP
82466>>>>>>>>>>>>>/// direct_output "con:"
82466>>>>>>>>>>>>>/// // Write the complete SELECT statement to retrieve the expected records from your REPORT
82466>>>>>>>>>>>>>/// // Must include the expression to qualify the required records and specify the order by as well
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// sql_set_stmt of salesp to "select recnum, id, name from SALESP where recnum > 5 order by id"
82466>>>>>>>>>>>>>/// sql_prepare_stmt of salesp
82466>>>>>>>>>>>>>/// sql_bindcolumns_stmt of salesp to salesp.recnum salesp.id salesp.name
82466>>>>>>>>>>>>>/// sql_execute_stmt of salesp
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// Report_stmt SALESP By Index.1
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// Section Header
82466>>>>>>>>>>>>>///     Sysdate Header.1
82466>>>>>>>>>>>>>///     Move PageCount to Header.2
82466>>>>>>>>>>>>>///     output header
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// Section Body
82466>>>>>>>>>>>>>///     Print Salesp.id   to Body.1
82466>>>>>>>>>>>>>///     Print Salesp.name to Body.2
82466>>>>>>>>>>>>>///     output body
82466>>>>>>>>>>>>>/// Section Total
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// Return
82466>>>>>>>>>>>>>/// ReportEnd
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>//=============================================================================
82466>>>>>>>>>>>>>/// @Name        GET_SERVER_CFG
82466>>>>>>>>>>>>>/// @Description This command, when passed a valid server name, returns
82466>>>>>>>>>>>>>/// the a value for the specified attribute. See the list below for an
82466>>>>>>>>>>>>>/// explanation of each attribute.
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// SERVER_REVISION    Returns the major version, to the left of the decimal, of the server
82466>>>>>>>>>>>>>/// SUPPORT_DESC       Returns 1 if Server supports descending index segments
82466>>>>>>>>>>>>>/// SUPPORT_CASE       Returns 1 if Server supports case insensitive index segments
82466>>>>>>>>>>>>>/// SERVER_VERSION     Returns the full version of the server
82466>>>>>>>>>>>>>/// SERVER_ENCODING    Returns the Server Encoding
82466>>>>>>>>>>>>>/// CONNECTION_ACTIVE  Returns 1 if the connection to the server is active
82466>>>>>>>>>>>>>/// CITEXT_SUPPORT     Returns 1 if Server supports citext, a PostgreSQL data type
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Assumptions
82466>>>>>>>>>>>>>/// @Status      Internal
82466>>>>>>>>>>>>>/// @Drivers     All
82466>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82466>>>>>>>>>>>>>/// @See
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Syntax GET_SERVER_CFG {constant} of {server} to {variable}
82466>>>>>>>>>>>>>/// @Param constant                     SERVER_REVISION,SERVER_MIN_REVISION,SUPPORT_DESC,SUPPORT_CASE,SERVER_VERSION,SERVER_ENCODING,CONNECTION_ACTIVE
82466>>>>>>>>>>>>>/// @Param server                       Name of the server being checked
82466>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82466>>>>>>>>>>>>>///
82466>>>>>>>>>>>>>/// @Example
82466>>>>>>>>>>>>>/// GET_SERVER_CFG SERVER_VERSION of "localhost" to sVersion
82466>>>>>>>>>>>>>
82466>>>>>>>>>>>>>Function MertechInc_GET_SERVER_CFG Global String sServer Integer iAttribute Returns String
82468>>>>>>>>>>>>>    Local String sReturnValue
82468>>>>>>>>>>>>>
82468>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 512 to sReturnValue
82469>>>>>>>>>>>>>
82469>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SERVER_CFG CALLBACK 0 PASSING sServer sReturnValue iAttribute RESULT MertechInc_iRet
82474>>>>>>>>>>>>>
82474>>>>>>>>>>>>>    //If iAttribute = SERVER_VERSION or SERVER_ENCODING then return sReturnValue
82474>>>>>>>>>>>>>    //else we need to return MertechInc_iRet
82474>>>>>>>>>>>>>    If ((iAttribute = 4) or (iAttribute = 5)) Function_Return sReturnValue
82477>>>>>>>>>>>>>    Else                                      Function_Return MertechInc_iRet
82479>>>>>>>>>>>>>End_Function
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_CONNECTION_STATUS
82480>>>>>>>>>>>>>/// @Description Retrieve the connection status for the specified server.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Internal
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_CONNECTION_STATUS of <serverName> [<databaseName>] to <variable>
82480>>>>>>>>>>>>>/// @Param serverName    Server Name
82480>>>>>>>>>>>>>/// @Param databaseName  Database Name
82480>>>>>>>>>>>>>/// @Param variable      DFTRUE means connection is active
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_CLIENT_CFG
82480>>>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Internal
82480>>>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_CLIENT_CFG [ENCODING | ENCODING_ID] of <Server> [<MySQL_Database>] to <Var>
82480>>>>>>>>>>>>>/// @Param Server           Server name to get encoding of
82480>>>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
82480>>>>>>>>>>>>>/// @Param Var              Variable to hold returned value
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SET_CLIENT_CFG
82480>>>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Internal
82480>>>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SET_CLIENT_CFG [ENCODING | UNIQUE_CHECKS] of <Server> [<MySQL_Database>] to <Value>
82480>>>>>>>>>>>>>/// @Param Server           Server name to get encoding of
82480>>>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
82480>>>>>>>>>>>>>/// @Param Value            Value to set
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Comment ENCODING - Set the Client Encoding
82480>>>>>>>>>>>>>/// @Comment UNIQUE_CHECKS {DFTRUE/DFFALSE} - enable/disable uniqueness checks for secondary indexes in InnoDB tables
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        CALL_DB2_PROCEDURE
82480>>>>>>>>>>>>>/// @Description Executes a DB2 Server stored procedure.
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     DB2Flex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax CALL_DB2_PROCEDURE <OWNER> <STORED_PROC> {PASSING <ARG1> {. <ARGn>}}
82480>>>>>>>>>>>>>/// @Param Owner        Name of the Procedure's Owner.
82480>>>>>>>>>>>>>/// @Param Stored_Proc  Full name of the stored procedure being called.
82480>>>>>>>>>>>>>/// @Param Arg1..Argn   Arguments passed to the procedure.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_RESULTS
82480>>>>>>>>>>>>>/// @Description Returns the initial result set.
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     DB2Flex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_RESULTS
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_MORE_RESULTS
82480>>>>>>>>>>>>>/// @Description Returns remaining values not retrieved with GET_RESULT.
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     DB2Flex
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_MORE_RESULTS
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_CURRENT_USER_NAME
82480>>>>>>>>>>>>>/// @Description This command is used to get the name of the user currently
82480>>>>>>>>>>>>>/// logged into the server.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_CURRENT_USER_PASSWORD
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_NAME of {server} to {variable}
82480>>>>>>>>>>>>>/// @Param server               The name of the server the user is in
82480>>>>>>>>>>>>>/// @Param variable             Variable to hold the username
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_CURRENT_USER_NAME of "localhost" to sUserName
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_CURRENT_USER_PASSWORD
82480>>>>>>>>>>>>>/// @Description This command is used to get the password associated with
82480>>>>>>>>>>>>>/// the user currently logged into the server.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_CURRENT_USER_NAME
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_PASSWORD of {server} to {variable}
82480>>>>>>>>>>>>>/// @Param server               The name of the server the user is in
82480>>>>>>>>>>>>>/// @Param variable             Variable to hold the password
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_CURRENT_USER_PASSWORD of "localhost" to sPassword
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        CREATE_DB2_DATABASE
82480>>>>>>>>>>>>>/// @Description Creates a DB2 database with the same DataFlex collating sequence.
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-12 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax CREATE_DB2_DATABASE <DB Name> <DB Alias> <Code Set> <Territory> [<Path> <Node Name> <User ID><Password>]
82480>>>>>>>>>>>>>/// @Param DB Name     Name of the database being created
82480>>>>>>>>>>>>>/// @Param DB Alias    Alias Name applied to the database being created
82480>>>>>>>>>>>>>/// @Param Code Set    Code Set used by the database being created
82480>>>>>>>>>>>>>/// @Param Territory   Territory associated to the database being created
82480>>>>>>>>>>>>>/// @Param Path        Location of the database                                    - Optional
82480>>>>>>>>>>>>>/// @Param Node Name   Name of the machine (node) where the database is to reside  - Optional
82480>>>>>>>>>>>>>/// @Param User ID     User ID owning the database                                 - Optional
82480>>>>>>>>>>>>>/// @Param Password    Password of the User owning the database                    - Optional
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_OPEN_CURSOR_STMT
82480>>>>>>>>>>>>>/// @Description This command is used to create a new SQl Cursor. Once
82480>>>>>>>>>>>>>/// created, SQL_SET_CURRENT_CURSOR_STMT can be called to specify which
82480>>>>>>>>>>>>>/// cursor is to be used for a given SQL statement. Creating multiple
82480>>>>>>>>>>>>>/// cursors using this command allows multiple SQL statements to be
82480>>>>>>>>>>>>>/// opened at once. Optionally a different server can be specified for each
82480>>>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
82480>>>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
82480>>>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_OPEN_CURSOR_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned cursor handle
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// Integer iCursor1 iCursor2 iCustomer
82480>>>>>>>>>>>>>/// String  sName
82480>>>>>>>>>>>>>/// Number  nOrderTotal
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to iCursor1
82480>>>>>>>>>>>>>/// SQL_SET_STMT         to "SELECT CUSTOMER_NUMBER,NAME FROM CUSTOMER "
82480>>>>>>>>>>>>>/// SQL_APPEND_STMT      to "ORDER BY NAME "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>/// Repeat
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT TO iCursor1
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO iCustomer sName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///        SQL_OPEN_CURSOR_STMT to iCursor2
82480>>>>>>>>>>>>>///        SQL_SET_STMT         to "SELECT SUM(ORDER_TOTAL) FROM ORDERHEA "
82480>>>>>>>>>>>>>///        SQL_APPEND_STMT      to ("WHERE CUSTOMER_NUMBER = " + Trim(iCustomer))
82480>>>>>>>>>>>>>///        SQL_PREPARE_STMT
82480>>>>>>>>>>>>>///        SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///        SQL_FETCH_NEXT_ROW INTO nOrderTotal
82480>>>>>>>>>>>>>///        If (Found and nOrderTotal > 0) Begin
82480>>>>>>>>>>>>>///            Showln "Customer : " iCustomer "-" sName " - Total: " nOrderTotal
82480>>>>>>>>>>>>>///        End
82480>>>>>>>>>>>>>///        SQL_CLOSE_CURSOR_STMT to Cursor2
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>///        Indicate Found True
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>/// Until (Not(Found))
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to Cursor1
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_CLOSE_CURSOR_STMT
82480>>>>>>>>>>>>>/// @Description This command closes the specified cursor that was created
82480>>>>>>>>>>>>>/// from SQL_OPEN_CURSOR_STMT. It is good practice to close all cursors
82480>>>>>>>>>>>>>/// once the statements associated with them are complete.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_CLOSE_CURSOR_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Cursor handle to close
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// Repeat
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>/// Until (FindErr)
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_SET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>/// @Description This command is used to open a cursor to be used for an
82480>>>>>>>>>>>>>/// SQl statement. The cursor must be created using the SQL_OPEN_CURSOR_STMT,
82480>>>>>>>>>>>>>/// but once it has been created, this command can easily switch between
82480>>>>>>>>>>>>>/// cursors as desired. Optionally a different server can be specified for each
82480>>>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
82480>>>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
82480>>>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_SET_CURRENT_CURSOR_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Cursor handle to use
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
82480>>>>>>>>>>>>>/// SQL_PREPARE_STMT
82480>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// Repeat
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
82480>>>>>>>>>>>>>///     If (Found) Begin
82480>>>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
82480>>>>>>>>>>>>>///     End
82480>>>>>>>>>>>>>/// Until (FindErr)
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
82480>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_GET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>/// @Description This command returns the current active cursor being
82480>>>>>>>>>>>>>/// used. The cursor is returned to the specified variable.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_GET_CURRENT_CURSOR_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable         Variable to hold the current cursor handle
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// SQL_GET_CURRENT_CURSOR_STMT to hCursor
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_SET_MAX_CURSORS_STMT
82480>>>>>>>>>>>>>/// @Description Sets the maximum number of simultaneous cursors allowed.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Deprecated
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_SET_MAX_CURSORS_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// SQL_SET_MAX_CURSORS_STMT to 50
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_GET_MAX_CURSORS_STMT
82480>>>>>>>>>>>>>/// @Description Retrieves the maximum number of cursors allowed.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Deprecated
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_GET_MAX_CURSORS_STMT [of {server}] to {variable}
82480>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
82480>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// SQL_GET_MAX_CURSORS_STMT to iCursors
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_SET_LOCAL_TD_PATH
82480>>>>>>>>>>>>>/// @Description Sets the directory where the driver will find the LOCAL TD files.
82480>>>>>>>>>>>>>/// @Status      Deprecated
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
82480>>>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the TD files are to be located.
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SQL_GET_LOCAL_TD_PATH
82480>>>>>>>>>>>>>/// @Description Gets the directory where the driver is looking for the LOCAL TD files.
82480>>>>>>>>>>>>>/// @Status      Deprecated
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
82480>>>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the driver is looking
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_DRIVER_REVISION
82480>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
82480>>>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
82480>>>>>>>>>>>>>/// variable.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_DRIVER_REVISION to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_DRIVER_REVISION to sVersion
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_DRIVER_MAJOR_REVISION
82480>>>>>>>>>>>>>/// @Description This command will put the current version (no decimals)
82480>>>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
82480>>>>>>>>>>>>>/// variable.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_DRIVER_MAJOR_REVISION to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_DRIVER_MAJOR_REVISION to sVersion
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_EXPIRATION_TIME
82480>>>>>>>>>>>>>/// @Description This command is used to find out how long until a
82480>>>>>>>>>>>>>/// specific temporary license for a driver expires. If 0 is returned,
82480>>>>>>>>>>>>>/// then the license is not a temporary license. If -1 is returned, then
82480>>>>>>>>>>>>>/// the license has already expired. Otherwise, the number returned
82480>>>>>>>>>>>>>/// is the number of days until the license will expire.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH SET_DRIVER_LICENSE_EXPIRATION_WARNING
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_EXPIRATION_TIME to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     Variable to hold the days until expiration
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// GET_DRIVER_LICENSE_EXPIRATION_TIME to iExpire
82480>>>>>>>>>>>>>/// Showln iExpire
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        SET_DRIVER_LICENSE_EXPIRATION_WARNING
82480>>>>>>>>>>>>>/// @Description This command is used to set a custom warning message to
82480>>>>>>>>>>>>>/// be displayed when a temporary license for a driver is close to expiring.
82480>>>>>>>>>>>>>/// Note that since the license evaluation is done during Login and before
82480>>>>>>>>>>>>>/// any open calls, this command should be called before either of those.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Public
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH GET_DRIVER_LICENSE_EXPIRATION_TIME
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax SET_DRIVER_LICENSE_EXPIRATION_WARNING to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     New warning message for expiring license
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Example
82480>>>>>>>>>>>>>/// SET_DRIVER_LICENSE_EXPIRATION_WARNING to "Your license is about to expire."
82480>>>>>>>>>>>>>/// Login "localhost" "" "" "sql_drv"
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>//=============================================================================
82480>>>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_PATH
82480>>>>>>>>>>>>>/// @Description This command will return the current path of the license
82480>>>>>>>>>>>>>/// associated with the driver.
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Assumptions
82480>>>>>>>>>>>>>/// @Status      Internal
82480>>>>>>>>>>>>>/// @Drivers     All
82480>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
82480>>>>>>>>>>>>>/// @See                 SET_DRIVER_LICENSE_EXPIRATION_WARNING GET_DRIVER_LICENSE_EXPIRATION_TIME
82480>>>>>>>>>>>>>///
82480>>>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_PATH to {variable}
82480>>>>>>>>>>>>>/// @Param variable                     Variable to hold the path of the license
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>Function MertechInc_GET_DRIVER_LICENSE_PATH Global Returns String
82482>>>>>>>>>>>>>    Local String sReturnValue
82482>>>>>>>>>>>>>
82482>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82484>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82486>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 4096 to sReturnValue
82487>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING sReturnValue MertechInc_Blank CALLDRV_LICENSE_PATH RESULT MertechInc_iRet
82492>>>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
82495>>>>>>>>>>>>>    End
82495>>>>>>>>>>>>>>
82495>>>>>>>>>>>>>
82495>>>>>>>>>>>>>    Function_Return sReturnValue
82496>>>>>>>>>>>>>End_Function
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        SET_DATABASE_PORT
82497>>>>>>>>>>>>>/// @Description This command is used to dynamically change the port
82497>>>>>>>>>>>>>/// number to use for all TCP/IP connections to the server. Note that
82497>>>>>>>>>>>>>/// the port is used for the current session only.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions The port is valid and available
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See                 GET_DATABASE_PORT
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SET_DATABASE_PORT of {constant} to {variable}
82497>>>>>>>>>>>>>/// @Param constant                     MYSQL or PGSQL
82497>>>>>>>>>>>>>/// @Param variable                     Port number to use to connect to server
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to 1433
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        GET_DATABASE_PORT
82497>>>>>>>>>>>>>/// @Description This command returns the TCP/IP port used to connect
82497>>>>>>>>>>>>>/// to the server.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See                 SET_DATABASE_PORT
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax GET_DATABASE_PORT of {MYSQL/PGSQL} to {variable}
82497>>>>>>>>>>>>>/// @Param variable                     Variable to hold the TCP/IP port number
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to iPort
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        GET_SERIAL_NUMBER
82497>>>>>>>>>>>>>/// @Description This command returns the serial number associated with
82497>>>>>>>>>>>>>/// the current driver's license.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     All
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax GET_SERIAL_NUMBER to {variable}
82497>>>>>>>>>>>>>/// @Param variable                     Variable to hold the driver's serial number
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// GET_SERIAL_NUMBER to iSerial
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        SET_DATABASE_SOCKET
82497>>>>>>>>>>>>>/// @Description This command is used to set the socket used to connect
82497>>>>>>>>>>>>>/// to the server when running an application under Linux/Unix.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See                 GET_DATABASE_SOCKET
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
82497>>>>>>>>>>>>>/// @Param variable                     Full name of the socket
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        GET_DATABASE_SOCKET
82497>>>>>>>>>>>>>/// @Description This command returns the name of the socket used to
82497>>>>>>>>>>>>>/// connect to the server when running an application under Linux/Unix.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See                 SET_DATABASE_SOCKET
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
82497>>>>>>>>>>>>>/// @Param variable                     Variable to hold the full socket name
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        SET_AUTHENTICATION_MODE
82497>>>>>>>>>>>>>/// @Description This command is used to control what mode the user logs
82497>>>>>>>>>>>>>/// in as. When DEFAULT is passed, the user will be logged in with the
82497>>>>>>>>>>>>>/// default privileges given to it. When SYSDBA is passed, the user will
82497>>>>>>>>>>>>>/// be logged in with the roles assigned to the sysdba user, most likely
82497>>>>>>>>>>>>>/// full control over the database.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     OraFlex
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SET_AUTHENTICATION_MODE of Oracle to {SYSDBA/DEFAULT}
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// SET_AUTHENTICATION_MODE of Oracle to DEFAULT
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>//=============================================================================
82497>>>>>>>>>>>>>/// @Name        SQL_ESCAPE_STRING
82497>>>>>>>>>>>>>/// @Description This command is used to properly escape strings before
82497>>>>>>>>>>>>>/// they are used in embedded SQL statements. This can be extremely
82497>>>>>>>>>>>>>/// important when you do not have full control of the strings being passed
82497>>>>>>>>>>>>>/// to the SQL statement as this will ensure that the strings are properly
82497>>>>>>>>>>>>>/// quoted.
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Assumptions
82497>>>>>>>>>>>>>/// @Status      Public
82497>>>>>>>>>>>>>/// @Drivers     All
82497>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82497>>>>>>>>>>>>>/// @See
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Syntax SQL_ESCAPE_STRING of {string} to {variable}
82497>>>>>>>>>>>>>/// @Param string               The string to be escaped.
82497>>>>>>>>>>>>>/// @Param variable     Variable to hold the newly escaped string
82497>>>>>>>>>>>>>///
82497>>>>>>>>>>>>>/// @Example
82497>>>>>>>>>>>>>/// SQL_ESCAPE_STRING of "They said to me, 'hello'." to sEscaped
82497>>>>>>>>>>>>>
82497>>>>>>>>>>>>>Function SQLESCAPESTRING Global String sData Returns String
82499>>>>>>>>>>>>>    String sReturnData
82499>>>>>>>>>>>>>
82499>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82501>>>>>>>>>>>>>
82501>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82503>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sReturnData
82504>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_ESCAPE_STRING CALLBACK 0 PASSING sData sReturnData 0 RESULT MertechInc_iRet
82509>>>>>>>>>>>>>    End
82509>>>>>>>>>>>>>>
82509>>>>>>>>>>>>>
82509>>>>>>>>>>>>>    Function_Return sReturnData
82510>>>>>>>>>>>>>End_Function
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        DIRECT_PATH_LOAD
82511>>>>>>>>>>>>>/// @Description
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Internal
82511>>>>>>>>>>>>>/// @Drivers     OraFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
82511>>>>>>>>>>>>>/// @See
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        SQL_INITIALIZE_SEQUENCE
82511>>>>>>>>>>>>>/// @Description This command is used to initialize all auto increment
82511>>>>>>>>>>>>>/// columns, or sequences in Oracle, of the specified table to be the
82511>>>>>>>>>>>>>/// highest number plus one. This is useful when inserting a large amount
82511>>>>>>>>>>>>>/// of records in the table and the sequence is not being updated because
82511>>>>>>>>>>>>>/// the auto incremented column is being manually filled.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Public
82511>>>>>>>>>>>>>/// @Drivers     OraFlex PgFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// SQL_INITIALIZE_SEQUENCE of {FileNumber}
82511>>>>>>>>>>>>>/// @Param FileNumber                   The file number
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_APPEND
82511>>>>>>>>>>>>>/// @Description This command is used to append data to an existing LOB
82511>>>>>>>>>>>>>/// column in the database. When called, the data corresponding field
82511>>>>>>>>>>>>>/// in the buffer is appended to the respective column in the database.
82511>>>>>>>>>>>>>/// This can be very useful when saving data that exceeds VDF size limits
82511>>>>>>>>>>>>>/// but falls within the limits of the SQL database. Note that this command
82511>>>>>>>>>>>>>/// must write to a file that is active and locked. Also the save is handled
82511>>>>>>>>>>>>>/// within the command so no extra calls are needed to save the changes made.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 SQL_LOB_ADD_CHUNK
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_APPEND of {FileName} {FieldNumber}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being appended to
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>///    Find Eq Customer by Recnum
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>///    Read_Block Customer.Comments 16384
82511>>>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
82511>>>>>>>>>>>>>///    Repeat
82511>>>>>>>>>>>>>///        Read_Block Customer.Comments 16384
82511>>>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
82511>>>>>>>>>>>>>///    Until (SeqEOF)
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Close_Input
82511>>>>>>>>>>>>>/// Find Eq Customer By Recnum
82511>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
82511>>>>>>>>>>>>>/// Showln 'Length: ' iLength
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_LENGTH
82511>>>>>>>>>>>>>/// @Description This command returns the length of the data in the
82511>>>>>>>>>>>>>/// specified column. This command must be used after a proper FIND to
82511>>>>>>>>>>>>>/// ensure that a valid record is in the buffer. This can be a useful
82511>>>>>>>>>>>>>/// command for checking if uploaded data exceeds size limits.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 SQL_GET_LOB_LENGTH
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_LENGTH of {FileName} {FieldNumber} to {variable}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB field
82511>>>>>>>>>>>>>/// @Param variable                     Variable to hold the length
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
82511>>>>>>>>>>>>>/// Showln 'Length: ' iLength
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_READ
82511>>>>>>>>>>>>>/// @Description This command reads a chunk of data from a specified LOB
82511>>>>>>>>>>>>>/// column, moving it into its corresponding field buffer. Because the
82511>>>>>>>>>>>>>/// chunk will be moved into the field buffer, it can only be as large as
82511>>>>>>>>>>>>>/// the buffer allows. To account for this, the constants FIRST or NEXT
82511>>>>>>>>>>>>>/// are passed as well indicating whether to grab the first chunk for
82511>>>>>>>>>>>>>/// the buffer or the next. Each chunk grabbed will be as large as allowed.
82511>>>>>>>>>>>>>/// All these things considered, when reading data larger than the field
82511>>>>>>>>>>>>>/// buffer, it is good practice to perform the read in a loop, adding the
82511>>>>>>>>>>>>>/// length each time. Another optional parameter that can be passed is a
82511>>>>>>>>>>>>>/// variable that will store the length of the chunk. Note that a LOB read
82511>>>>>>>>>>>>>/// must be done after a successful find on the record.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 SQL_GET_LOB SQL_GET_LOB_CHUNK
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_READ of {FileName} {FieldNumber} {FIRST/NEXT} [{length}]
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being read from
82511>>>>>>>>>>>>>/// @Param FIRST                        Reads the first chunk of data
82511>>>>>>>>>>>>>/// @Param NEXT                         Reads the next chuck of data (if larger than buffer limit)
82511>>>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length (optional)
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Direct_Output ('binary:Mertech.pdf')
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Clear customer
82511>>>>>>>>>>>>>/// Find Gt customer by Index.1
82511>>>>>>>>>>>>>/// SQL_LOB_LENGTH of customer 13 to liLength
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// While (liLength > 0)
82511>>>>>>>>>>>>>///     Write customer.comments
82511>>>>>>>>>>>>>///     SQL_LOB_READ of customer 13 Next liLength
82511>>>>>>>>>>>>>/// Loop
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Close_Output
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_WRITE
82511>>>>>>>>>>>>>/// @Description This command is used to write data to a LOB column.
82511>>>>>>>>>>>>>/// By passing the file name and field number of the LOB column, this
82511>>>>>>>>>>>>>/// command will take the current value of the respective field in
82511>>>>>>>>>>>>>/// the field buffer, write it to the database and save it. Any data
82511>>>>>>>>>>>>>/// currently in that field will be overridden by the data from the
82511>>>>>>>>>>>>>/// buffer. Note that this command must write to a file that is active
82511>>>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
82511>>>>>>>>>>>>>/// are needed to save the changes.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_WRITE of {FileName} {FieldNumber}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being written to
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>///    Find Eq Customer by Recnum
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>///    Read_Block Customer.Comments 16384
82511>>>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
82511>>>>>>>>>>>>>///    Repeat
82511>>>>>>>>>>>>>///        Read_Block Customer.Comments 16384
82511>>>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
82511>>>>>>>>>>>>>///    Until (SeqEOF)
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>/// Close_Input
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Find Eq Customer By Recnum
82511>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
82511>>>>>>>>>>>>>/// Showln 'Length: ' iLength
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_LOADFROMFILE
82511>>>>>>>>>>>>>/// @Description This command loads an external file into a specified LOB
82511>>>>>>>>>>>>>/// column. After specifying the file name and field number, the path and
82511>>>>>>>>>>>>>/// file must then be passed respectively. When using Oracle, instead of
82511>>>>>>>>>>>>>/// passing the directory, a directory alias must be passed. This alias
82511>>>>>>>>>>>>>/// can be created using a "CREATE DIRECTORY" statement in SQL. For more
82511>>>>>>>>>>>>>/// information on setting this directory alias, see the Oracle help.
82511>>>>>>>>>>>>>/// For other servers, the file must be a local file available to the
82511>>>>>>>>>>>>>/// application that is calling the command. Note that this command must
82511>>>>>>>>>>>>>/// write to a file that is active and locked. Also this command handles
82511>>>>>>>>>>>>>/// the save so no extra calls are needed to save the changes.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_LOADFROMFILE of {FileName} {FieldNumber} From {path} {file}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being used
82511>>>>>>>>>>>>>/// @Param path                         The path of the file, excluding the file name
82511>>>>>>>>>>>>>/// @Param file                         The name of the file, including the extension
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>///    Find Eq Customer by Recnum
82511>>>>>>>>>>>>>///    LOB_TRUNCATE OF customel 13 to 0 // Customer.Comments
82511>>>>>>>>>>>>>///    Saverecord Customer
82511>>>>>>>>>>>>>///    // Directory name is case sensitive.
82511>>>>>>>>>>>>>///    // Make sure the name case matches
82511>>>>>>>>>>>>>///    LOB_LOADFROMFILE OF customel 13 FROM "C:\Mertech\FilesToLoad" "Mertech.XML"
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_ERASE
82511>>>>>>>>>>>>>/// @Description This command is used to erase a portion of data from a
82511>>>>>>>>>>>>>/// LOB column. For text fields, the portion of data to be erased is
82511>>>>>>>>>>>>>/// replaced with white space, and in binary fields, with 0X0. To erase
82511>>>>>>>>>>>>>/// a portion of the data, pass the length to erase as well as the number
82511>>>>>>>>>>>>>/// to offset from. For this command to work properly, it must be done
82511>>>>>>>>>>>>>/// after a valid find. Note that the save is handled inside this command
82511>>>>>>>>>>>>>/// so no extra commands are needed to save the changes.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_ERASE OF {FileName} {FieldNumber} {length} {offset}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
82511>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being erased
82511>>>>>>>>>>>>>/// @Param Length                       Length of chunk to erase from column
82511>>>>>>>>>>>>>/// @Param offset                       Starting position for erase
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear customer
82511>>>>>>>>>>>>>/// Find Gt customer by Recnum
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>/// Find Eq customer by Recnum
82511>>>>>>>>>>>>>/// LOB_LENGTH OF customer 13 to liTotalLength
82511>>>>>>>>>>>>>/// LOB_ERASE  OF customer 13    liTotalLength 1
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        LOB_TRUNCATE
82511>>>>>>>>>>>>>/// @Description This command is used to trim a LOB column down to a
82511>>>>>>>>>>>>>/// specified length. By passing the table name and column number, the
82511>>>>>>>>>>>>>/// value in the column can then be trimmed down the specified length.
82511>>>>>>>>>>>>>/// This can be a useful command for clearing out a column before entering
82511>>>>>>>>>>>>>/// new data into it. Note that this command must write to a file that is active
82511>>>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
82511>>>>>>>>>>>>>/// are needed to save the changes. This command can be used to clear out a field before adding new data
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     All
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE FLUSH_LOB_BUFFER
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax LOB_TRUNCATE of {FileName} {FieldNumber} to {variable}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82511>>>>>>>>>>>>>/// @Param FieldNumber          The field number
82511>>>>>>>>>>>>>/// @Param length                       New length to truncate to
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// Clear Customer
82511>>>>>>>>>>>>>/// Find Gt Customer By Index.1
82511>>>>>>>>>>>>>/// Lock
82511>>>>>>>>>>>>>///    Find Eq Customer by Recnum
82511>>>>>>>>>>>>>///    SQL_LOB_TRUNCATE of Customer 13 to 0 // Customer.Comments
82511>>>>>>>>>>>>>///    Saverecord Customer
82511>>>>>>>>>>>>>/// Unlock
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        FLUSH_LOB_BUFFER
82511>>>>>>>>>>>>>/// @Description This command currently serves no function.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax FLUSH_LOB_BUFFER of {FileName}
82511>>>>>>>>>>>>>/// @Param FileName                     Name of the file
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        SQL_ENABLE_RECONNECT
82511>>>>>>>>>>>>>/// @Description Allow MySql Driver to auto reconnect after a time-out.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// Driver auto-reconnect feature handles the issue where MySQL
82511>>>>>>>>>>>>>/// will kick off a user after inactivity.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     MySQL
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-11 By Ian Smith
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax SQL_ENABLE_RECONNECT of <ServerName> to dftrue/dffalse
82511>>>>>>>>>>>>>/// @Param ServerName  Server Name.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Usage SQL_ENABLE_RECONNECT Of sServerID To dftrue
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_PROCEDURE
82511>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
82511>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
82511>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
82511>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
82511>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
82511>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
82511>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
82511>>>>>>>>>>>>>/// is set to true.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_PROCEDURE {procedure} Passing {argument}
82511>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
82511>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// CALL_MYSQL_STORED_PROCEDURE "getCustomerStatus" passing sCustomerID sStatus
82511>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
82511>>>>>>>>>>>>>/// Showln sStatus
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_FUNCTION
82511>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in MySQL.
82511>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
82511>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
82511>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
82511>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
82511>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
82511>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
82511>>>>>>>>>>>>>/// values.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Status      Deprecated
82511>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
82511>>>>>>>>>>>>>/// @Param function                     Full name of the function
82511>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
82511>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// CALL_MYSQL_STORED_FUNCTION "getCustomerStatus" Returns sStatus passing sCustomerID
82511>>>>>>>>>>>>>/// Showln sStatus
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        DO_SET_ALL_FUNCTION_PARAMETERS
82511>>>>>>>>>>>>>/// @Description Sets the parameters for a MySQL stored function call.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions
82511>>>>>>>>>>>>>/// @Status      Internal
82511>>>>>>>>>>>>>/// @Drivers     MySQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
82511>>>>>>>>>>>>>/// @See
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax DO_SET_ALL_FUNCTION_PARAMETERS [sParam1 [sParam2 . sParamn]]
82511>>>>>>>>>>>>>/// @Param sParam1.n    Parameters for the stored function
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>//=============================================================================
82511>>>>>>>>>>>>>/// @Name        GET_NO_AVAILABLE_SQLSERVERS
82511>>>>>>>>>>>>>/// @Description This command is used to get the number of available MSSQL
82511>>>>>>>>>>>>>/// servers detected in the network. When used with GET_SQLSERVER_NAME,
82511>>>>>>>>>>>>>/// all the available server names can be easily retrieved.
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
82511>>>>>>>>>>>>>/// @Status      Public
82511>>>>>>>>>>>>>/// @Drivers     SQLFlex
82511>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82511>>>>>>>>>>>>>/// @See                 GET_SQLSERVER_NAME
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Syntax GET_NO_AVAILABLE_SQLSERVERS to {variable}
82511>>>>>>>>>>>>>/// @Param variable                     Variable to hold number of servers
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// @Example
82511>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
82511>>>>>>>>>>>>>///
82511>>>>>>>>>>>>>/// While (i <= iServers)
82511>>>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
82511>>>>>>>>>>>>>///     Showln sServer
82511>>>>>>>>>>>>>///     Increment i
82511>>>>>>>>>>>>>/// Loop
82511>>>>>>>>>>>>>
82511>>>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVERS Global Returns Integer
82513>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_ENUMERATE_SERVER_COUNT RESULT MertechInc_iRet
82518>>>>>>>>>>>>>
82518>>>>>>>>>>>>>    Function_Return MertechInc_iRet
82519>>>>>>>>>>>>>End_Function
82520>>>>>>>>>>>>>
82520>>>>>>>>>>>>>
82520>>>>>>>>>>>>>//=============================================================================
82520>>>>>>>>>>>>>/// @Name        GET_SQLSERVER_NAME
82520>>>>>>>>>>>>>/// @Description This command returns the name of the server based on the
82520>>>>>>>>>>>>>/// specified index number. The number of servers can be retrieved from
82520>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS and the names can be indexed from that
82520>>>>>>>>>>>>>/// number.
82520>>>>>>>>>>>>>///
82520>>>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
82520>>>>>>>>>>>>>/// @Status      Public
82520>>>>>>>>>>>>>/// @Drivers     SQLFlex
82520>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82520>>>>>>>>>>>>>/// @See                 GET_NO_AVAILABLE_SQLSERVERS
82520>>>>>>>>>>>>>///
82520>>>>>>>>>>>>>/// @Syntax SQL_AVAILABLE_SQL_SERVER_NAME {index} to {variable}
82520>>>>>>>>>>>>>/// @Param index                The numbered index name to retrieve
82520>>>>>>>>>>>>>/// @Param variable             Variable to hold the server name
82520>>>>>>>>>>>>>///
82520>>>>>>>>>>>>>/// @Example
82520>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
82520>>>>>>>>>>>>>///
82520>>>>>>>>>>>>>/// While (i <= iServers)
82520>>>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
82520>>>>>>>>>>>>>///     Showln sServer
82520>>>>>>>>>>>>>///     Increment i
82520>>>>>>>>>>>>>/// Loop
82520>>>>>>>>>>>>>
82520>>>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVER_NAME Global Integer iIndex Returns String
82522>>>>>>>>>>>>>    Local String sName
82522>>>>>>>>>>>>>
82522>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 80 to sName
82523>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING sName iIndex CALLDRV_ENUMERATE_SERVER_SERVER RESULT MertechInc_iRet
82528>>>>>>>>>>>>>
82528>>>>>>>>>>>>>    Function_Return sName
82529>>>>>>>>>>>>>End_Function
82530>>>>>>>>>>>>>
82530>>>>>>>>>>>>>
82530>>>>>>>>>>>>>//=============================================================================
82530>>>>>>>>>>>>>/// @Name        SET_USE_ROWCOUNT_IN_TRANSACTION
82530>>>>>>>>>>>>>/// @Description Turn on / off Row_Count for specified server.
82530>>>>>>>>>>>>>/// @Status      Deprecated
82530>>>>>>>>>>>>>/// @Drivers     All
82530>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
82530>>>>>>>>>>>>>///
82530>>>>>>>>>>>>>/// @Syntax SET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
82530>>>>>>>>>>>>>/// @Param Server      Name of server to turn On / Off Row_Count
82530>>>>>>>>>>>>>/// @Param State       TRUE = turn on Row_Count  FALSE = turn off Row_Count
82530>>>>>>>>>>>>>///
82530>>>>>>>>>>>>>/// @Comment This SHOULD ALWAYS BE TURNED ON
82530>>>>>>>>>>>>>
82530>>>>>>>>>>>>>Procedure Set SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Integer iState
82532>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82534>>>>>>>>>>>>>
82534>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer iState CALLDRV_VALUE_SET RESULT MertechInc_iRet
82539>>>>>>>>>>>>>    If MertechInc_iRet EQ -1 INDICATE ERR True
82542>>>>>>>>>>>>>End_Procedure
82543>>>>>>>>>>>>>
82543>>>>>>>>>>>>>//IGS - commented out by a.n. Other
82543>>>>>>>>>>>>>//#REPLACE UseRowCountInTransactions SQL_USE_ROWCOUNT_IN_TRANSACTIONS
82543>>>>>>>>>>>>>
82543>>>>>>>>>>>>>//=============================================================================
82543>>>>>>>>>>>>>/// @Name        GET_USE_ROWCOUNT_IN_TRANSACTION
82543>>>>>>>>>>>>>/// @Description Gets the Row_Count setting for specified server.
82543>>>>>>>>>>>>>/// @Status      Deprecated
82543>>>>>>>>>>>>>/// @Drivers     All
82543>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
82543>>>>>>>>>>>>>///
82543>>>>>>>>>>>>>/// @Syntax GET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
82543>>>>>>>>>>>>>/// @Param Server      Name of server to get Row_Count state of
82543>>>>>>>>>>>>>/// @Param State       Variable to hold returned value
82543>>>>>>>>>>>>>
82543>>>>>>>>>>>>>Function SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Returns Integer
82545>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82547>>>>>>>>>>>>>
82547>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
82552>>>>>>>>>>>>>
82552>>>>>>>>>>>>>    Function_Return MertechInc_iRet
82553>>>>>>>>>>>>>End_Function
82554>>>>>>>>>>>>>
82554>>>>>>>>>>>>>
82554>>>>>>>>>>>>>//=============================================================================
82554>>>>>>>>>>>>>/// @Name        SQL_SET_DATE_FORMAT
82554>>>>>>>>>>>>>/// @Description This command controls the date format of data returned
82554>>>>>>>>>>>>>/// through embedded SQL. If set to DATAFLEX, then the dates will be
82554>>>>>>>>>>>>>/// returned in whatever format is set in DF_DATE_FORMAT. When set to
82554>>>>>>>>>>>>>/// NATIVE, this command will force dates to return dates in the format
82554>>>>>>>>>>>>>/// specified on the SQL server. Note that in order for the variables to
82554>>>>>>>>>>>>>/// be in the right form, they need to be string variables.
82554>>>>>>>>>>>>>///
82554>>>>>>>>>>>>>/// @Assumptions
82554>>>>>>>>>>>>>/// @Status      Public
82554>>>>>>>>>>>>>/// @Drivers     SQLFlex
82554>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
82554>>>>>>>>>>>>>/// @See
82554>>>>>>>>>>>>>///
82554>>>>>>>>>>>>>/// @Syntax SQL_SET_DATE_FORMAT to {DATAFLEX/NATIVE}
82554>>>>>>>>>>>>>///
82554>>>>>>>>>>>>>/// @Example
82554>>>>>>>>>>>>>/// SQL_SET_DATE_FORMAT to NATIVE
82554>>>>>>>>>>>>>
82554>>>>>>>>>>>>>Procedure Set SQL_USE_DATAFLEX_DATEFORMAT Global Integer iState
82556>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82558>>>>>>>>>>>>>
82558>>>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
82560>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
82565>>>>>>>>>>>>>        IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
82568>>>>>>>>>>>>>    End
82568>>>>>>>>>>>>>>
82568>>>>>>>>>>>>>End_Procedure
82569>>>>>>>>>>>>>
82569>>>>>>>>>>>>>Function SQL_USE_DATAFLEX_DATEFORMAT Global Returns Integer
82571>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82573>>>>>>>>>>>>>
82573>>>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
82575>>>>>>>>>>>>>        CALL_DRIVER 0 MertechInc_DriverName FUNCTION CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
82580>>>>>>>>>>>>>    End
82580>>>>>>>>>>>>>>
82580>>>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
82582>>>>>>>>>>>>>
82582>>>>>>>>>>>>>    function_return MertechInc_iRet
82583>>>>>>>>>>>>>End_Function
82584>>>>>>>>>>>>>
82584>>>>>>>>>>>>>
82584>>>>>>>>>>>>>//=============================================================================
82584>>>>>>>>>>>>>/// @Name        SET_FIELDS_NOT_NULL
82584>>>>>>>>>>>>>/// @Description This command is used to specify how to handle blank
82584>>>>>>>>>>>>>/// and zero values on the SQL backend. Since blank or zero values can
82584>>>>>>>>>>>>>/// often be stored as null in the server database, this command allows
82584>>>>>>>>>>>>>/// that to be altered if needed. When set to true, a value will be
82584>>>>>>>>>>>>>/// inserted into blank records to keep them from being null. See the
82584>>>>>>>>>>>>>/// list below for what value will be stored instead of null. If set to
82584>>>>>>>>>>>>>/// false, values will be stored normally in the database. Note that this
82584>>>>>>>>>>>>>/// command effects all data types.
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
82584>>>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
82584>>>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// DF_BINARY -                                 0X0
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// @Assumptions
82584>>>>>>>>>>>>>/// @Status      Public
82584>>>>>>>>>>>>>/// @Drivers     All
82584>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82584>>>>>>>>>>>>>/// @See                 SET_FIELDS_NULL GET_FIELDS_NULL
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>/// @Syntax SET_FIELDS_NOT_NULL to {variable}
82584>>>>>>>>>>>>>/// @Param variable             Boolean variable to indicate how to handle null values
82584>>>>>>>>>>>>>///
82584>>>>>>>>>>>>>
82584>>>>>>>>>>>>>Procedure Set SQL_FORCE_FIELDS_NOT_NULL Global Integer iState
82586>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82588>>>>>>>>>>>>>
82588>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82590>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
82595>>>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
82598>>>>>>>>>>>>>    End
82598>>>>>>>>>>>>>>
82598>>>>>>>>>>>>>End_Procedure
82599>>>>>>>>>>>>>
82599>>>>>>>>>>>>>
82599>>>>>>>>>>>>>
82599>>>>>>>>>>>>>
82599>>>>>>>>>>>>>Function SQL_FORCE_FIELDS_NOT_NULL Global Returns Integer
82601>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
82603>>>>>>>>>>>>>
82603>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
82605>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
82610>>>>>>>>>>>>>    End
82610>>>>>>>>>>>>>>
82610>>>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
82612>>>>>>>>>>>>>
82612>>>>>>>>>>>>>    Function_Return MertechInc_iRet
82613>>>>>>>>>>>>>End_Function
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SET_FIELDS_NULL
82614>>>>>>>>>>>>>/// @Description This command is used to specify how to store blank or zero
82614>>>>>>>>>>>>>/// values in the database. Since database can sometimes store these value,
82614>>>>>>>>>>>>>/// i.e. '' or 0, as null, using this command can be useful in managing that.
82614>>>>>>>>>>>>>/// When set to true, any value in a column of the given type considered blank
82614>>>>>>>>>>>>>/// or 0 will be stored as null in the database. Setting it to false will cause
82614>>>>>>>>>>>>>/// the server to save as it normally would. Note that this command is used to
82614>>>>>>>>>>>>>/// set specific data types only, it can not effect all types at once. Below is
82614>>>>>>>>>>>>>/// a list of value that would be considered blank/zero values.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
82614>>>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
82614>>>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// DF_BINARY -                                 0X0
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 GET_FIELDS_NULL SET_FIELDS_NOT_NULL
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SET_FIELDS_NULL {datatype} to {variable}
82614>>>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
82614>>>>>>>>>>>>>/// @Param variable             Boolean to indicate how to handle blank data
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        GET_FIELDS_NULL
82614>>>>>>>>>>>>>/// @Description This command will return the value of SET_FIELDS_NULL for
82614>>>>>>>>>>>>>/// the specified data type.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 SET_FIELDS_NULL SET_FIELDS_NOT_NULL
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax GET_FIELDS_NULL {datatype} to {variable}
82614>>>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
82614>>>>>>>>>>>>>/// @Param variable             Variable to hold the value of SET_FIELDS_NULL
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        STRUCTURE_START_DYNAMIC
82614>>>>>>>>>>>>>/// @Description This command is used when scripting structural changes.
82614>>>>>>>>>>>>>/// It is the same as using ENABLE_SCRIPTING and Structure_Start separately.
82614>>>>>>>>>>>>>/// It allows structural changes to be compiled and tested without
82614>>>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
82614>>>>>>>>>>>>>/// between this command and STRUCTURE_END_DYNAMIC will not actually be
82614>>>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
82614>>>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Deprecated
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
82614>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        STRUCTURE_END_DYNAMIC
82614>>>>>>>>>>>>>/// @Description This command ends the scripting started by
82614>>>>>>>>>>>>>/// STRUCTURE_START_DYNAMIC. It is the same as calling Structure_End
82614>>>>>>>>>>>>>/// and DISABLE_SCRIPTING separately.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Deprecated
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
82614>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SQLSERVER_ATTACH_DB
82614>>>>>>>>>>>>>/// @Description Attachs an MS SQL mdf to the current server instance. If
82614>>>>>>>>>>>>>/// the passed database is already attached, no error is generated.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// The SQLSERVER_ATTACH_DB command is intended for use with our new support
82614>>>>>>>>>>>>>/// of Microsoft LocalDB's.  When using LocalDB's a common use case might be
82614>>>>>>>>>>>>>/// to attach to a customer DB, do some work on it, and then detach this DB
82614>>>>>>>>>>>>>/// and attach to a different DB.  This was possible using stored procedures,
82614>>>>>>>>>>>>>/// but the code had some complexities that a developer need not worry about.
82614>>>>>>>>>>>>>/// When you attach a database, you must pass the database name, along with
82614>>>>>>>>>>>>>/// the path to an MDF file which contains the database.  Any associated LDF's
82614>>>>>>>>>>>>>/// (log files) and NDF's (secondary data files) must be in the same folder.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// If you call SQLSERVER_ATTACH_DB on a database that is already attached,
82614>>>>>>>>>>>>>/// no error will be generated.  After you call SQLSERVER_ATTACH_DB, you
82614>>>>>>>>>>>>>/// should call SET_DATABASE_NAME if you wish to make the attached database
82614>>>>>>>>>>>>>/// the currently selected database.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// SQLSERVER_ATTACH_DB will work on all supported version of SQL server.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     SQLFlex
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 Aaron Gulack
82614>>>>>>>>>>>>>/// @See
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SQLSERVER_ATTACH_DB {database} on {filePath}
82614>>>>>>>>>>>>>/// @Param database                     Name of the database
82614>>>>>>>>>>>>>/// @Param filePath                     Path of the MDF file
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// SQLSERVER_ATTACH_DB "MTSample" ON "C:\Mertech\Data\SampleDb.mdf"
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SQLSERVER_DETACH_DB
82614>>>>>>>>>>>>>/// @Description The SQLSERVER_DETACH_DB command is intended for use with our
82614>>>>>>>>>>>>>/// new support of Microsoft LocalDB's.  When using LocalDB's a common use
82614>>>>>>>>>>>>>/// case might be to attach to a customer DB, do some work on it, and then
82614>>>>>>>>>>>>>/// detach this DB and attach to a different DB.  This was possible using
82614>>>>>>>>>>>>>/// stored procedures, but the code had some complexities that a developer
82614>>>>>>>>>>>>>/// need not worry about.  A detach can only be done if the database passed
82614>>>>>>>>>>>>>/// has no open connections.  As part of the detach process, the command
82614>>>>>>>>>>>>>/// closes ALL open files (even those not associated with this database or
82614>>>>>>>>>>>>>/// driver).
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// NOTE: SQLSERVER_DETACH_DB will often fail to execute if you are testing
82614>>>>>>>>>>>>>/// your application from the studio.  This is because the studio itself
82614>>>>>>>>>>>>>/// normally has open connections to the database.  If you test your
82614>>>>>>>>>>>>>/// application outside of the studio and the studio is closed (and any
82614>>>>>>>>>>>>>/// other application or tools that access this database are closed) you
82614>>>>>>>>>>>>>/// can successfully detach the database.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     SQLFlex
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SQLSERVER_DETACH_DB {database}
82614>>>>>>>>>>>>>/// @Param database                     Name of the database
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// SQLSERVER_DETACH_DB "TestDB"
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// @Description This command is used to set DF_FILE_RECORDS_USED to a
82614>>>>>>>>>>>>>/// fixed value. This can be useful because doing a SELECT COUNT(*) is
82614>>>>>>>>>>>>>/// a very expensive process to the server. Many applications do counts
82614>>>>>>>>>>>>>/// often and using this command can help cut down the server traffic.
82614>>>>>>>>>>>>>/// Sometimes when counts are used, an exact number is not necessary so
82614>>>>>>>>>>>>>/// a fixed value, updated occasionally can be used. By setting this
82614>>>>>>>>>>>>>/// command to 0 or greater, the value of DF_FILE_RECORDS_USED will be
82614>>>>>>>>>>>>>/// set to that specified value and the internal SELECT COUNT(*) will be
82614>>>>>>>>>>>>>/// suppressed. If this command is set to something less that zero,
82614>>>>>>>>>>>>>/// DF_FILE_RECORDS_USED will be dynamically calculated whenever it is
82614>>>>>>>>>>>>>/// called.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// The default value for this command is -1
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status              Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 GET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SET_FIXED_FILE_RECORDS_USED to {variable}
82614>>>>>>>>>>>>>/// @Param variable                     Fixed value for DF_FILE_RECORDS_USED
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// SET_FIXED_FILE_RECORDS_USED to 10000
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        GET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// @Description This command returns the value of DF_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// if it has been set to a fixed value by SET_FIXED_FILE_RECORDS_USED.
82614>>>>>>>>>>>>>/// If anything greater than or equal to 0 is returned then that is the
82614>>>>>>>>>>>>>/// fixed value returned by any SELECT COUNT(*) statements, internal or
82614>>>>>>>>>>>>>/// not. If something less than zero is returned, then DF_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// returns a dynamic count whenever it is called.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// By default the value of this is -1
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status              Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 SET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax GET_FILE_RECORDS_USED to {variable}
82614>>>>>>>>>>>>>/// @Param variable                     Variable to hold the fixed value
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// GET_FIXED_FILE_RECORDS_USED to iRecords
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>/// @Description This command sets the value of DF_FILE_RECORDS_USED to
82614>>>>>>>>>>>>>/// a fixed value of zero. That way anytime a SELECT COUNT(*) is done,
82614>>>>>>>>>>>>>/// zero is returned, cutting down on server traffic. This is the same
82614>>>>>>>>>>>>>/// as setting SET_FIXED_FILE_RECORDS_USED to 0.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 UNSUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax SUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        UNSUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>/// @Description This command resets the value of DF_FILE_RECORDS_USED to
82614>>>>>>>>>>>>>/// -1. That way anytime a SELECT COUNT(*) is done, it returns the actual
82614>>>>>>>>>>>>>/// count of records. This is the same as setting SET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>/// to -1.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 SUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax UNSUPPRESS_SELECT_COUNT
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>// Private:
82614>>>>>>>>>>>>>// Get the filenumber of a file.field parameter
82614>>>>>>>>>>>>>//
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>// Private:
82614>>>>>>>>>>>>>// Get the fieldnumber of a file.field parameter
82614>>>>>>>>>>>>>//
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//
82614>>>>>>>>>>>>>// Minimum required DataFlex version for new LOB support below is VDF 4
82614>>>>>>>>>>>>>//
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>TYPE tMertechLOB_Args
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.cbSize       AS WORD          // always the size of the structure (verification + versioning)
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nField       AS DWORD         // always the field number
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.pszData      AS POINTER
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nSize        AS DWORD
82614>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nOffset      AS POINTER
82614>>>>>>>>>>>>>END_TYPE
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>//=============================================================================
82614>>>>>>>>>>>>>/// @Name        SQL_SET_LOB
82614>>>>>>>>>>>>>/// @Description This command replaces whatever is currently in a LOB Field
82614>>>>>>>>>>>>>/// with the data passed. It writes to a client side buffer. It can be used
82614>>>>>>>>>>>>>/// to Write an arbitrary amount of data into a LOB.
82614>>>>>>>>>>>>>/// If passed an empty String, it will remove all the contents of the LOB.
82614>>>>>>>>>>>>>/// If you wish to Set a LOB back to NULL, please use the SQL_SET_LOB_NULL
82614>>>>>>>>>>>>>/// command.
82614>>>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_WRITE, this call does not
82614>>>>>>>>>>>>>/// perform the Save. This must be done separately.
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82614>>>>>>>>>>>>>/// @Status      Public
82614>>>>>>>>>>>>>/// @Drivers     All
82614>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82614>>>>>>>>>>>>>/// @See                 SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Syntax             SQL_SET_LOB {FileName.FieldName} to {variable}
82614>>>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
82614>>>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
82614>>>>>>>>>>>>>/// @Param              variable                The variable to use to set the field's value
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// @Example
82614>>>>>>>>>>>>>/// Set_Argument_Size 262144
82614>>>>>>>>>>>>>/// String sLine
82614>>>>>>>>>>>>>///
82614>>>>>>>>>>>>>/// Clear Customer
82614>>>>>>>>>>>>>///    Move iID to Customer.ID
82614>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82614>>>>>>>>>>>>>/// If (Found) Begin
82614>>>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
82614>>>>>>>>>>>>>///    Reread Customer
82614>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
82614>>>>>>>>>>>>>///       Read_Block sLine 262144
82614>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
82614>>>>>>>>>>>>>///       While (not(SeqEof))
82614>>>>>>>>>>>>>///          Read_Block sLine 262144
82614>>>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
82614>>>>>>>>>>>>>///       Loop
82614>>>>>>>>>>>>>///    Saverecord Customer
82614>>>>>>>>>>>>>///    Unlock
82614>>>>>>>>>>>>>///    Close_Input
82614>>>>>>>>>>>>>/// End
82614>>>>>>>>>>>>>
82614>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB String sDriver Integer iFile Integer iField String sData
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82616>>>>>>>>>>>>>    Local String sLOB_Args       // can drop local command if minimum vdf version is 6
82616>>>>>>>>>>>>>
82616>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82617>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82617>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82618>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82619>>>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
82620>>>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
82621>>>>>>>>>>>>>
82621>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_WRITE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82626>>>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB
82627>>>>>>>>>>>>>
82627>>>>>>>>>>>>>//=============================================================================
82627>>>>>>>>>>>>>/// @Name        SQL_ADD_LOB_CHUNK
82627>>>>>>>>>>>>>/// @Description This command is used to add additional chunks to the buffer
82627>>>>>>>>>>>>>/// before saving the record. After SQL_SET_LOB has been called
82627>>>>>>>>>>>>>/// SQL_ADD_LOB_CHUNK can be called as many times as needed to add additional
82627>>>>>>>>>>>>>/// chunks of data before a save. It can also be called independent of
82627>>>>>>>>>>>>>/// SQL_SET_LOB to append data to an existing LOB column.
82627>>>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_APPEND, this call does not perform
82627>>>>>>>>>>>>>/// the save. This must be done separately.
82627>>>>>>>>>>>>>///
82627>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82627>>>>>>>>>>>>>/// @Status      Public
82627>>>>>>>>>>>>>/// @Drivers     All
82627>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82627>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
82627>>>>>>>>>>>>>///
82627>>>>>>>>>>>>>/// @Syntax             SQL_ADD_LOB_CHUNK {FileName.FieldName} to {variable}
82627>>>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
82627>>>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
82627>>>>>>>>>>>>>/// @Param              variable                The variable to add as the LOB chunk
82627>>>>>>>>>>>>>///
82627>>>>>>>>>>>>>/// @Example
82627>>>>>>>>>>>>>/// Set_Argument_Size 262144
82627>>>>>>>>>>>>>/// String sLine
82627>>>>>>>>>>>>>///
82627>>>>>>>>>>>>>/// Clear Customer
82627>>>>>>>>>>>>>///    Move iID to Customer.ID
82627>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82627>>>>>>>>>>>>>/// If (Found) Begin
82627>>>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
82627>>>>>>>>>>>>>///    Reread Customer
82627>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
82627>>>>>>>>>>>>>///       Read_Block sLine 262144
82627>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
82627>>>>>>>>>>>>>///       While (not(SeqEof))
82627>>>>>>>>>>>>>///          Read_Block sLine 262144
82627>>>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
82627>>>>>>>>>>>>>///       Loop
82627>>>>>>>>>>>>>///    Saverecord Customer
82627>>>>>>>>>>>>>///    Unlock
82627>>>>>>>>>>>>>///    Close_Input
82627>>>>>>>>>>>>>/// End
82627>>>>>>>>>>>>>
82627>>>>>>>>>>>>>Procedure MertechInc_SQL_ADD_LOB_CHUNK String sDriver Integer iFile Integer iField String sData
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82629>>>>>>>>>>>>>    Local String sLOB_Args
82629>>>>>>>>>>>>>
82629>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82630>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82630>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82631>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82632>>>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
82633>>>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
82634>>>>>>>>>>>>>
82634>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_APPEND CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82639>>>>>>>>>>>>>end_procedure // MertechInc_SQL_ADD_LOB_CHUNK
82640>>>>>>>>>>>>>
82640>>>>>>>>>>>>>//=============================================================================
82640>>>>>>>>>>>>>/// @Name        SQL_GET_LOB
82640>>>>>>>>>>>>>/// @Description This command is used for getting the value of a specified LOB
82640>>>>>>>>>>>>>/// field. Two optional parameters can be passed specifying the offset and
82640>>>>>>>>>>>>>/// length of the chunk to get. Passing these parameters essentially makes this
82640>>>>>>>>>>>>>/// call the same as SQL_GET_LOB_CHUNK.
82640>>>>>>>>>>>>>/// Depending on the situation, the two calls can be interchanged for improved
82640>>>>>>>>>>>>>/// code readability. Excluding these additional parameters will get the whole
82640>>>>>>>>>>>>>/// field value within DataFlex variable size limits.
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82640>>>>>>>>>>>>>/// @Status      Public
82640>>>>>>>>>>>>>/// @Drivers     All
82640>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82640>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// @Syntax     SQL_GET_LOB {FileName.FieldName} TO {variable} [ OFFSET {offset} LENGTH {length} ]
82640>>>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
82640>>>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
82640>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB value
82640>>>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB value (optional)
82640>>>>>>>>>>>>>/// @Param              length                          Length of value to get from the LOB field (optional)
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// @Example
82640>>>>>>>>>>>>>/// Set_Argument_Size 262144
82640>>>>>>>>>>>>>/// String sResult
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// Move 262144 to iChunkSize
82640>>>>>>>>>>>>>/// Move 0      to iChunk
82640>>>>>>>>>>>>>///
82640>>>>>>>>>>>>>/// Clear Customer
82640>>>>>>>>>>>>>///    Move iID to Customer.ID
82640>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82640>>>>>>>>>>>>>/// If (Found) Begin
82640>>>>>>>>>>>>>///    Direct_Output ('Binary:' + sDestFileName)
82640>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
82640>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
82640>>>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
82640>>>>>>>>>>>>>///       Write sResult
82640>>>>>>>>>>>>>///       Increment iChunk
82640>>>>>>>>>>>>>///    Loop
82640>>>>>>>>>>>>>///    Close_Output
82640>>>>>>>>>>>>>/// End
82640>>>>>>>>>>>>>
82640>>>>>>>>>>>>>
82640>>>>>>>>>>>>>Function MertechInc_SQL_GET_LOB String sDriver Integer iFile Integer iField Integer iOffset Integer iLength Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82642>>>>>>>>>>>>>    Local String sLOB_Args
82642>>>>>>>>>>>>>    Local String sData
82642>>>>>>>>>>>>>    Local DWord  nSize
82642>>>>>>>>>>>>>
82642>>>>>>>>>>>>>    Move "" To sData
82643>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82644>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82644>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82645>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82646>>>>>>>>>>>>>
82646>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82651>>>>>>>>>>>>>
82651>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
82652>>>>>>>>>>>>>    If nSize GT 0 Begin
82654>>>>>>>>>>>>>      If (iOffset=0 and iLength=0) Begin
82656>>>>>>>>>>>>>        ZeroString nSize to sData
82657>>>>>>>>>>>>>            //Send Assert (AddressOf(sData) <> 0) ("AddressOf(sData) is NULL") DFTrue
82657>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
82658>>>>>>>>>>>>>      End
82658>>>>>>>>>>>>>>
82658>>>>>>>>>>>>>      Else Begin
82659>>>>>>>>>>>>>        ZeroString iLength to sData
82660>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
82661>>>>>>>>>>>>>        Put iLength            to sLOB_Args at tMertechLOB_Args.nSize
82662>>>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
82663>>>>>>>>>>>>>      End
82663>>>>>>>>>>>>>>
82663>>>>>>>>>>>>>      Call_Driver iFile sDriver Function CALLDRV_LOB_EX_READ CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82668>>>>>>>>>>>>>    End
82668>>>>>>>>>>>>>>
82668>>>>>>>>>>>>>    Else Begin
82669>>>>>>>>>>>>>        Move "" to sData
82670>>>>>>>>>>>>>    End
82670>>>>>>>>>>>>>>
82670>>>>>>>>>>>>>    Function_Return sData
82671>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB
82672>>>>>>>>>>>>>
82672>>>>>>>>>>>>>//=============================================================================
82672>>>>>>>>>>>>>/// @Name        SQL_GET_LOB_CHUNK
82672>>>>>>>>>>>>>/// @Description This command is used for getting a chunk of data from a specified
82672>>>>>>>>>>>>>/// LOB field. The difference between this command and SQL_GET_LOB is only that
82672>>>>>>>>>>>>>/// the parameters OFFSET and LENGTH are not optional when using this command.
82672>>>>>>>>>>>>>/// You may consider using this command to retrieve small portions of a very
82672>>>>>>>>>>>>>/// large BLOB so as to reduce memory usage.
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82672>>>>>>>>>>>>>/// @Status      Public
82672>>>>>>>>>>>>>/// @Drivers     All
82672>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82672>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Syntax     SQL_GET_LOB_CHUNK {FileName.FieldName} TO {variable} OFFSET {offset} LENGTH {length}
82672>>>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
82672>>>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
82672>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB chunk
82672>>>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB chunk
82672>>>>>>>>>>>>>/// @Param              length                          Length of chunk to get from the LOB field
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Example
82672>>>>>>>>>>>>>/// Set_Argument_Size 262144
82672>>>>>>>>>>>>>/// String sResult
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// Move 262144 to iChunkSize
82672>>>>>>>>>>>>>/// Move 0      to iChunk
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// Clear Customer
82672>>>>>>>>>>>>>///    Move iID to Customer.ID
82672>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82672>>>>>>>>>>>>>/// If (Found) Begin
82672>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
82672>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
82672>>>>>>>>>>>>>///       SQL_GET_LOB_CHUNK Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
82672>>>>>>>>>>>>>///       // Do something with the LOB data
82672>>>>>>>>>>>>>///       Increment iChunk
82672>>>>>>>>>>>>>///    Loop
82672>>>>>>>>>>>>>/// End
82672>>>>>>>>>>>>>
82672>>>>>>>>>>>>>//=============================================================================
82672>>>>>>>>>>>>>/// @Name        SQL_GET_LOB_LENGTH
82672>>>>>>>>>>>>>/// @Description This command is used to get the length of a specified LOB field.
82672>>>>>>>>>>>>>/// It is useful, for example, in determining the number of iterations to
82672>>>>>>>>>>>>>/// perform while reading from a LOB field using chunking.
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82672>>>>>>>>>>>>>/// @Status      Public
82672>>>>>>>>>>>>>/// @Drivers     All
82672>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82672>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Syntax             SQL_GET_LOB_LENGTH {FileName.FieldName} to {variable}
82672>>>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
82672>>>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
82672>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the length of the field
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// @Example
82672>>>>>>>>>>>>>/// Set_Argument_Size 262144
82672>>>>>>>>>>>>>/// String sResult
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// Move 16384 to iChunkSize
82672>>>>>>>>>>>>>/// Move 0     to iChunk
82672>>>>>>>>>>>>>///
82672>>>>>>>>>>>>>/// Clear Customer
82672>>>>>>>>>>>>>///    Move iID to Customer.ID
82672>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82672>>>>>>>>>>>>>/// If (Found) Begin
82672>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
82672>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
82672>>>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
82672>>>>>>>>>>>>>///       // Do something with the LOB data
82672>>>>>>>>>>>>>///       Increment iChunk
82672>>>>>>>>>>>>>///    Loop
82672>>>>>>>>>>>>>/// End
82672>>>>>>>>>>>>>
82672>>>>>>>>>>>>>
82672>>>>>>>>>>>>>Function MertechInc_SQL_GET_LOB_LENGTH String sDriver Integer iFile Integer iField Returns Integer
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82674>>>>>>>>>>>>>    Local String sLOB_Args
82674>>>>>>>>>>>>>    Local DWord  nSize
82674>>>>>>>>>>>>>
82674>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82675>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82675>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82676>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82677>>>>>>>>>>>>>
82677>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82682>>>>>>>>>>>>>
82682>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
82683>>>>>>>>>>>>>    Function_Return nSize
82684>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB_LENGTH
82685>>>>>>>>>>>>>
82685>>>>>>>>>>>>>//=============================================================================
82685>>>>>>>>>>>>>/// @Name        SQL_SET_LOB_NULL
82685>>>>>>>>>>>>>/// @Description This command is used to set a LOB column to null. Often
82685>>>>>>>>>>>>>/// LOB columns should either contain data or be null. A "blank" LOB column
82685>>>>>>>>>>>>>/// often doesn't appear empty in other environments, so settings it back to
82685>>>>>>>>>>>>>/// null is best.
82685>>>>>>>>>>>>>///
82685>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
82685>>>>>>>>>>>>>/// @Status      Public
82685>>>>>>>>>>>>>/// @Drivers     All
82685>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
82685>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
82685>>>>>>>>>>>>>///
82685>>>>>>>>>>>>>/// @Syntax             SQL_SET_LOB_NULL    {FileName.FieldName}
82685>>>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
82685>>>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
82685>>>>>>>>>>>>>///
82685>>>>>>>>>>>>>/// @Example
82685>>>>>>>>>>>>>////
82685>>>>>>>>>>>>>/// Clear Customer
82685>>>>>>>>>>>>>/// Move iID to Customer.ID
82685>>>>>>>>>>>>>/// Find Eq Customer by Index.1
82685>>>>>>>>>>>>>/// If (Found) Begin
82685>>>>>>>>>>>>>///    Reread Customer
82685>>>>>>>>>>>>>///        SQL_SET_LOB_NULL Customer.Comments
82685>>>>>>>>>>>>>///        Saverecord Customer
82685>>>>>>>>>>>>>///    Unlock
82685>>>>>>>>>>>>>/// End
82685>>>>>>>>>>>>>
82685>>>>>>>>>>>>>
82685>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB_NULL String sDriver Integer iFile Integer iField
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
82687>>>>>>>>>>>>>    Local String sLOB_Args
82687>>>>>>>>>>>>>
82687>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
82688>>>>>>>>>>>>>    // First move the size of the structure to the Structure
82688>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
82689>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
82690>>>>>>>>>>>>>
82690>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_SET_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
82695>>>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB_NULL
82696>>>>>>>>>>>>>
82696>>>>>>>>>>>>>
82696>>>>>>>>>>>>>
82696>>>>>>>>>>>>>//=============================================================================
82696>>>>>>>>>>>>>// End of Mertech.inc
82696>>>>>>>>>>>>>//=============================================================================
82696>>>>>>>>>>>Use cli.pkg
82696>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 1.0.3 FOR DATAFLEX UPDATE FRAMEWORK
#REM -----------------------------------------------
82696>>>>>>>>>>>
82696>>>>>>>>>>>Struct tCLIHandleMap
82696>>>>>>>>>>>    Integer iHdbc
82696>>>>>>>>>>>    String sDriver
82696>>>>>>>>>>>    String sConnect
82696>>>>>>>>>>>End_Struct
82696>>>>>>>>>>>
82696>>>>>>>>>>>Struct tColumnMap
82696>>>>>>>>>>>    Integer iFileNum
82696>>>>>>>>>>>    Variant[] vResultColumn
82696>>>>>>>>>>>End_Struct
82696>>>>>>>>>>>
82696>>>>>>>>>>>//*** Embedded SQL statement attribute constants
82696>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
82696>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
82696>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
82696>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
82696>>>>>>>>>>>
82696>>>>>>>>>>>//*** Embedded SQL column attribute constants
82696>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
82696>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
82696>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
82696>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
82696>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
82696>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
82696>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
82696>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
82696>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
82696>>>>>>>>>>>
82696>>>>>>>>>>>
82696>>>>>>>>>>>//*** Enforced DAC SQL.PKG Compatibility
82696>>>>>>>>>>>Define SQL_DAC_HIGH_COMPATABILITY for 1
82696>>>>>>>>>>>Define SQL_DAC_NORMAL_COMPATIBILITY  for 0
82696>>>>>>>>>>>
82696>>>>>>>>>>>Global_Variable Integer giSQLCompatibilityMode
82696>>>>>>>>>>>Move SQL_DAC_NORMAL_COMPATIBILITY to giSQLCompatibilityMode
82697>>>>>>>>>>>
82697>>>>>>>>>>>//*** Global object handle for the manager
82697>>>>>>>>>>>Handle _embsqlghoSQLHandleMngr
82697>>>>>>>>>>>Register_Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
82697>>>>>>>>>>>
82697>>>>>>>>>>>Class cSQLStatementDUF is a cObject
82698>>>>>>>>>>>    Procedure Construct_Object
82700>>>>>>>>>>>        Forward Send Construct_Object
82702>>>>>>>>>>>
82702>>>>>>>>>>>        Property Integer phCLIHandle      0
82703>>>>>>>>>>>        Property Integer piLastColumn     0
82704>>>>>>>>>>>        Property Integer piLastArgument   0
82705>>>>>>>>>>>        Property Integer piBindFile       0
82706>>>>>>>>>>>        Property Integer piCursorNum      0
82707>>>>>>>>>>>        Property Boolean pisBeforeFetch   True
82708>>>>>>>>>>>        Property Integer piParameterCount 0
82709>>>>>>>>>>>
82709>>>>>>>>>>>        Property Integer piDataChunkOffset 0
82710>>>>>>>>>>>        Property String psProcName ""
82711>>>>>>>>>>>        Property String psSchemaName ""
82712>>>>>>>>>>>        Property Variant[] pvParams
82713>>>>>>>>>>>        Property tColumnMap ptColumnMap
82714>>>>>>>>>>>    End_Procedure
82715>>>>>>>>>>>
82715>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns String
82717>>>>>>>>>>>        Integer hoCLIHandler
82717>>>>>>>>>>>        Date dDFDate
82717>>>>>>>>>>>
82717>>>>>>>>>>>        //*** Create a CLI handler object
82717>>>>>>>>>>>        Object oSQLDFCLIHandler is a cCLIHandler
82719>>>>>>>>>>>            Move Current_Object to hoCLIHandler
82720>>>>>>>>>>>        End_Object // oCLIHandler
82721>>>>>>>>>>>
82721>>>>>>>>>>>        //*** Convert the date
82721>>>>>>>>>>>        Get CLISQLDateToDFDate of hoCLIHandler (psDRiverID(Current_Object)) sSQLDate to dDFDate
82722>>>>>>>>>>>
82722>>>>>>>>>>>        //*** Destroy the object
82722>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
82723>>>>>>>>>>>
82723>>>>>>>>>>>        Function_Return dDFDate
82724>>>>>>>>>>>    End_Function // SQLDateToDFDate
82725>>>>>>>>>>>
82725>>>>>>>>>>>    Function DFDateToSQLDate for cSQLStatementDUF Date dDFDate Returns String
82727>>>>>>>>>>>        Integer hoCLIHandler
82727>>>>>>>>>>>        String sSQLDate
82727>>>>>>>>>>>
82727>>>>>>>>>>>        //*** Create a CLI handler object
82727>>>>>>>>>>>        Object oDFSQLCLIHandler is a cCLIHandler
82729>>>>>>>>>>>            Move Current_Object to hoCLIHandler
82730>>>>>>>>>>>        End_Object // oCLIHandler
82731>>>>>>>>>>>
82731>>>>>>>>>>>        //*** Convert the date
82731>>>>>>>>>>>        Get CLIDFDateToSQLDate of hoCLIHandler (psDRiverID(Current_Object)) dDFDate to sSQLDate
82732>>>>>>>>>>>
82732>>>>>>>>>>>        //*** Destroy the object
82732>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
82733>>>>>>>>>>>
82733>>>>>>>>>>>        Function_Return sSQLDate
82734>>>>>>>>>>>    End_Function // DFDateToSQLDate
82735>>>>>>>>>>>
82735>>>>>>>>>>>
82735>>>>>>>>>>>    Function IsProcedure String sFunctionName Returns Boolean
82737>>>>>>>>>>>        String sRoutineType
82737>>>>>>>>>>>
82737>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82751>>>>>>>>>>>>
82751>>>>>>>>>>>
82751>>>>>>>>>>>        Case Begin
82751>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
82753>>>>>>>>>>>                sql_set_stmt to (SFormat("select type from master.sys.sysobjects where name = '%1' union all select type from sys.sysobjects where name = '%1'", sFunctionName))
82761>>>>>>>>>>>                sql_prepare_stmt
82773>>>>>>>>>>>                sql_execute_stmt
82788>>>>>>>>>>>
82788>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
82812>>>>>>>>>>>>
82812>>>>>>>>>>>                If (sRoutineType = "P") Move "PROCEDURE" to sRoutineType
82815>>>>>>>>>>>                Else Move "FUNCTION" to sRoutineType
82817>>>>>>>>>>>                Case Break
82818>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
82821>>>>>>>>>>>                sql_set_stmt to (SFormat("select routine_type from information_schema.routines where routine_name = '%1'", sFunctionName))
82829>>>>>>>>>>>                sql_prepare_stmt
82841>>>>>>>>>>>                sql_execute_stmt
82856>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
82880>>>>>>>>>>>>
82880>>>>>>>>>>>
82880>>>>>>>>>>>                Case Break
82881>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
82884>>>>>>>>>>>                sql_set_stmt  to (SFormat("SELECT object_type from all_objects where object_name = '%1'", sFunctionName))
82892>>>>>>>>>>>                sql_prepare_stmt
82904>>>>>>>>>>>                sql_execute_stmt
82919>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
82943>>>>>>>>>>>>
82943>>>>>>>>>>>
82943>>>>>>>>>>>                Case Break
82944>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
82947>>>>>>>>>>>                // Postgres doesn't differentiate between procedures and functions, so treat everything as procedures
82947>>>>>>>>>>>                // because that is better tested.
82947>>>>>>>>>>>                Move "PROCEDURE" to sRoutineType
82948>>>>>>>>>>>                Case Break
82949>>>>>>>>>>>        Case End
82949>>>>>>>>>>>
82949>>>>>>>>>>>        Function_Return (sRoutineType = "PROCEDURE")
82950>>>>>>>>>>>    End_Function
82951>>>>>>>>>>>
82951>>>>>>>>>>>    Function ProcParams String sFunctionName Returns Variant[]
82953>>>>>>>>>>>        Variant[] vFuncParams
82954>>>>>>>>>>>        Integer i iParamType
82954>>>>>>>>>>>
82954>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82968>>>>>>>>>>>>
82968>>>>>>>>>>>
82968>>>>>>>>>>>        Case Begin
82968>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
82970>>>>>>>>>>>                sql_set_stmt to (SFormat("sys.sp_procedure_params_managed @procedure_name = '%1'", sFunctionName))
82978>>>>>>>>>>>                sql_prepare_stmt
82990>>>>>>>>>>>                sql_execute_stmt
83005>>>>>>>>>>>
83005>>>>>>>>>>>                Repeat
83005>>>>>>>>>>>>
83005>>>>>>>>>>>                    sql_fetch_next_row
83020>>>>>>>>>>>>
83020>>>>>>>>>>>                    If (Found) Begin
83022>>>>>>>>>>>                        sql_fetch_column 6 into iParamType
83027>>>>>>>>>>>
83027>>>>>>>>>>>                        If (iParamType = 1) Move "IN" to vFuncParams[i]
83030>>>>>>>>>>>                        If (iParamType = 2) Move "INOUT" to vFuncParams[i]
83033>>>>>>>>>>>                        If (iParamType = 3) Move "OUT" to vFuncParams[i]
83036>>>>>>>>>>>                        If (iParamType <> 4) Increment i
83039>>>>>>>>>>>                    End
83039>>>>>>>>>>>>
83039>>>>>>>>>>>                Until (not(Found))
83041>>>>>>>>>>>
83041>>>>>>>>>>>                Function_Return vFuncParams
83042>>>>>>>>>>>
83042>>>>>>>>>>>                Case Break
83043>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
83046>>>>>>>>>>>                sql_set_stmt to (SFormat("select parameter_mode from INFORMATION_SCHEMA.PARAMETERS where SPECIFIC_NAME = '%1' order by ordinal_position", sFunctionName))
83054>>>>>>>>>>>                sql_prepare_stmt
83066>>>>>>>>>>>                sql_execute_stmt
83081>>>>>>>>>>>
83081>>>>>>>>>>>                Case Break
83082>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
83085>>>>>>>>>>>                sql_set_stmt to    "SELECT all_arguments.in_out as parameter_mode "
83093>>>>>>>>>>>                sql_append_stmt to "FROM all_objects inner join all_arguments on all_objects.object_id = all_arguments.object_id "
83101>>>>>>>>>>>                sql_append_stmt to (SFormat("WHERE all_objects.object_name = '%1' order by all_arguments.position", sFunctionName))
83109>>>>>>>>>>>                sql_prepare_stmt
83121>>>>>>>>>>>                sql_execute_stmt
83136>>>>>>>>>>>
83136>>>>>>>>>>>                Case Break
83137>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
83140>>>>>>>>>>>                sql_set_stmt    to "select information_schema.parameters.parameter_mode "
83148>>>>>>>>>>>                sql_append_stmt to "from information_schema.routines inner join information_schema.parameters "
83156>>>>>>>>>>>                sql_append_stmt to "on information_schema.routines.specific_name=information_schema.parameters.specific_name "
83164>>>>>>>>>>>                sql_append_stmt to (SFormat("where information_schema.routines.routine_name = '%1' ", sFunctionName))
83172>>>>>>>>>>>                sql_append_stmt to "order by information_schema.parameters.ordinal_position"
83180>>>>>>>>>>>                sql_prepare_stmt
83192>>>>>>>>>>>                sql_execute_stmt
83207>>>>>>>>>>>
83207>>>>>>>>>>>                Case Break
83208>>>>>>>>>>>        Case End
83208>>>>>>>>>>>
83208>>>>>>>>>>>        Repeat
83208>>>>>>>>>>>>
83208>>>>>>>>>>>            sql_fetch_next_row into vFuncParams[i]
83232>>>>>>>>>>>>
83232>>>>>>>>>>>            Increment i
83233>>>>>>>>>>>        Until (not(Found))
83235>>>>>>>>>>>
83235>>>>>>>>>>>        Function_Return vFuncParams
83236>>>>>>>>>>>    End_Function
83237>>>>>>>>>>>
83237>>>>>>>>>>>    Procedure Set StoreHandleInfo Handle hConn
83239>>>>>>>>>>>        Set phCLIHandle to hConn
83240>>>>>>>>>>>    End_Procedure
83241>>>>>>>>>>>
83241>>>>>>>>>>>    Procedure FreeHandle
83243>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83257>>>>>>>>>>>>
83257>>>>>>>>>>>
83257>>>>>>>>>>>                                 Case Begin
83257>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
83259>>>>>>>>>>>                                END_CALL_PROCEDURE
83264>>>>>>>>>>>                Case Break
83265>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
83268>>>>>>>>>>>                Case Break
83269>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
83272>>>>>>>>>>>                Case Break
83273>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
83276>>>>>>>>>>>                Case Break
83277>>>>>>>>>>>        Case End
83277>>>>>>>>>>>
83277>>>>>>>>>>>
83277>>>>>>>>>>>        SQL_CLOSE_CURSOR_STMT to (piCursorNum(Self))
83291>>>>>>>>>>>>
83291>>>>>>>>>>>        Send Destroy_Object
83292>>>>>>>>>>>    End_Procedure // FreeHandle
83293>>>>>>>>>>>
83293>>>>>>>>>>>    Procedure SQLClose
83295>>>>>>>>>>>        Send FreeHandle
83296>>>>>>>>>>>    End_Procedure // SQLClose
83297>>>>>>>>>>>
83297>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
83299>>>>>>>>>>>        Integer iErrHandle
83299>>>>>>>>>>>        Integer iErrNum
83299>>>>>>>>>>>        String  sLocationInfo
83299>>>>>>>>>>>
83299>>>>>>>>>>>        //*** Get the DataFlex statement identifier
83299>>>>>>>>>>>        Move Current_object to iErrHandle
83300>>>>>>>>>>>
83300>>>>>>>>>>>        //*** Determine error number
83300>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
83303>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
83307>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
83311>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
83313>>>>>>>>>>>
83313>>>>>>>>>>>        //*** Create location information
83313>>>>>>>>>>>        Move "[" to sLocationInfo
83314>>>>>>>>>>>        If (sOriginMsg <> "") Begin
83316>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
83317>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
83318>>>>>>>>>>>        End
83318>>>>>>>>>>>>
83318>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
83319>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
83320>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
83321>>>>>>>>>>>
83321>>>>>>>>>>>        //*** Generate the error
83321>>>>>>>>>>>        Error iErrNum sLocationInfo
83322>>>>>>>>>>>>
83322>>>>>>>>>>>    End_Procedure
83323>>>>>>>>>>>
83323>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
83325>>>>>>>>>>>        Local Integer iErrHandle
83325>>>>>>>>>>>        Local String  sLocationInfo
83325>>>>>>>>>>>
83325>>>>>>>>>>>        //*** Get the DataFlex statement identifier
83325>>>>>>>>>>>        Move Current_object to iErrHandle
83326>>>>>>>>>>>
83326>>>>>>>>>>>
83326>>>>>>>>>>>        //*** Create location information
83326>>>>>>>>>>>        Move "[" to sLocationInfo
83327>>>>>>>>>>>        If (sOriginMsg <> "") Begin
83329>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
83330>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
83331>>>>>>>>>>>        End
83331>>>>>>>>>>>>
83331>>>>>>>>>>>        If (sErrtext <> "") Begin
83333>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
83334>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
83335>>>>>>>>>>>        End
83335>>>>>>>>>>>>
83335>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
83336>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
83337>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
83338>>>>>>>>>>>
83338>>>>>>>>>>>        //*** Generate the error
83338>>>>>>>>>>>        Error iErrNum sLocationInfo
83339>>>>>>>>>>>>
83339>>>>>>>>>>>    End_Procedure
83340>>>>>>>>>>>
83340>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
83342>>>>>>>>>>>        Local Integer bReport
83342>>>>>>>>>>>
83342>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
83345>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
83348>>>>>>>>>>>    End_Procedure // SQLIllegalAttribute
83349>>>>>>>>>>>
83349>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
83351>>>>>>>>>>>        String sResult
83351>>>>>>>>>>>        Integer iCols
83351>>>>>>>>>>>        Integer iOrgDateFmt
83351>>>>>>>>>>>        Integer iOrgDateSep
83351>>>>>>>>>>>        String sType
83351>>>>>>>>>>>
83351>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83365>>>>>>>>>>>>
83365>>>>>>>>>>>
83365>>>>>>>>>>>        SQL_GET_NUM_COLS to iCols
83375>>>>>>>>>>>>
83375>>>>>>>>>>>        If (iCol <= iCols) Begin
83377>>>>>>>>>>>            //DAC SQL Driver currently uses military format for the SQL getting of dates.
83377>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83379>>>>>>>>>>>                Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
83382>>>>>>>>>>>                Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83385>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
83388>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
83391>>>>>>>>>>>            End
83391>>>>>>>>>>>>
83391>>>>>>>>>>>
83391>>>>>>>>>>>            //DAC SQL Driver cannot directly get TEXT fields into a result.
83391>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83393>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sType
83410>>>>>>>>>>>>
83410>>>>>>>>>>>                If (sType=5) Move "" to sResult
83413>>>>>>>>>>>                Else Begin
83414>>>>>>>>>>>                    SQL_FETCH_COLUMN iCol into sResult
83419>>>>>>>>>>>                End
83419>>>>>>>>>>>>
83419>>>>>>>>>>>            End
83419>>>>>>>>>>>>
83419>>>>>>>>>>>            Else Begin
83420>>>>>>>>>>>               SQL_FETCH_COLUMN iCol into sResult
83425>>>>>>>>>>>            End
83425>>>>>>>>>>>>
83425>>>>>>>>>>>
83425>>>>>>>>>>>
83425>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83427>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
83430>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
83433>>>>>>>>>>>            End
83433>>>>>>>>>>>>
83433>>>>>>>>>>>
83433>>>>>>>>>>>            Function_Return sResult
83434>>>>>>>>>>>        End
83434>>>>>>>>>>>>
83434>>>>>>>>>>>        Else Send HandleError (phCLIHandle(Self)) (phCLIHandle(Parent(Self))) (psDriverID(Self)) "SQLColumnValue"
83436>>>>>>>>>>>    End_Function // SQLColumnValue
83437>>>>>>>>>>>
83437>>>>>>>>>>>    Function SQLNextColumn Returns String
83439>>>>>>>>>>>        Integer iCol
83439>>>>>>>>>>>        String  sResult
83439>>>>>>>>>>>
83439>>>>>>>>>>>        Get piLastColumn to iCol
83440>>>>>>>>>>>        Increment iCol
83441>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
83442>>>>>>>>>>>        Set piLastColumn to iCol
83443>>>>>>>>>>>
83443>>>>>>>>>>>        Function_Return sResult
83444>>>>>>>>>>>    End_Function // SQLNextColumn
83445>>>>>>>>>>>
83445>>>>>>>>>>>    Procedure SQLPrepare String sStatement
83447>>>>>>>>>>>        tColumnMap tColumnMap
83447>>>>>>>>>>>        tColumnMap tColumnMap
83447>>>>>>>>>>>        Set ptColumnMap to tColumnMap
83448>>>>>>>>>>>        Set pisBeforeFetch to True
83449>>>>>>>>>>>
83449>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83463>>>>>>>>>>>>
83463>>>>>>>>>>>        SQL_SET_STMT to sStatement
83471>>>>>>>>>>>
83471>>>>>>>>>>>        SQL_PREPARE_STMT
83483>>>>>>>>>>>    End_Procedure // SQLPrepare
83484>>>>>>>>>>>
83484>>>>>>>>>>>    Procedure SQLExecute
83486>>>>>>>>>>>        SQL_EXECUTE_STMT
83501>>>>>>>>>>>    End_Procedure
83502>>>>>>>>>>>
83502>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
83504>>>>>>>>>>>        tColumnMap tColumnMap
83504>>>>>>>>>>>        tColumnMap tColumnMap
83504>>>>>>>>>>>        Set ptColumnMap to tColumnMap
83505>>>>>>>>>>>        Set pisBeforeFetch to True
83506>>>>>>>>>>>
83506>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83520>>>>>>>>>>>>
83520>>>>>>>>>>>
83520>>>>>>>>>>>        SQL_SET_STMT to sStatement
83528>>>>>>>>>>>        SQL_PREPARE_STMT
83540>>>>>>>>>>>        SQL_EXECUTE_STMT
83555>>>>>>>>>>>    End_Procedure
83556>>>>>>>>>>>
83556>>>>>>>>>>>    Function SQLFetch Returns Integer
83558>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83572>>>>>>>>>>>>
83572>>>>>>>>>>>        Set pisBeforeFetch to False
83573>>>>>>>>>>>
83573>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
83588>>>>>>>>>>>>
83588>>>>>>>>>>>        Function_Return (Found)
83589>>>>>>>>>>>    End_Function
83590>>>>>>>>>>>
83590>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
83592>>>>>>>>>>>        tColumnMap tColumnMap
83592>>>>>>>>>>>        tColumnMap tColumnMap
83592>>>>>>>>>>>        String[] sBindFileColumns
83593>>>>>>>>>>>        Integer[] iBufferColumn
83594>>>>>>>>>>>        Integer iColCnt i iDateFormat iResultColumnType iBindFileColumnType
83594>>>>>>>>>>>        String sColumnName
83594>>>>>>>>>>>        Variant vFieldValue
83594>>>>>>>>>>>        Boolean isRecnumTable
83594>>>>>>>>>>>
83594>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83608>>>>>>>>>>>>
83608>>>>>>>>>>>
83608>>>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFileNum to isRecnumTable
83611>>>>>>>>>>>        Get ptColumnMap to tColumnMap
83612>>>>>>>>>>>
83612>>>>>>>>>>>        If (tColumnMap.iFileNum <> iFileNum) Begin
83614>>>>>>>>>>>            Move iFileNum to tColumnMap.iFileNum
83615>>>>>>>>>>>
83615>>>>>>>>>>>            // First we build an array of the column names (in order) from the file buffer to bind to
83615>>>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNum to iColCnt
83618>>>>>>>>>>>            For i from 0 to iColCnt
83624>>>>>>>>>>>>
83624>>>>>>>>>>>                If (isRecnumTable) Get_Attribute DF_FIELD_NAME of iFileNum i to sColumnName
83629>>>>>>>>>>>                Else Move "" to sColumnName
83631>>>>>>>>>>>
83631>>>>>>>>>>>                Move (Uppercase(sColumnName)) to sBindFileColumns[i]
83632>>>>>>>>>>>            Loop
83633>>>>>>>>>>>>
83633>>>>>>>>>>>
83633>>>>>>>>>>>            // Next we iterate over the columns in the resultset.  Any column names that match we
83633>>>>>>>>>>>            // set its match location into an array that maps each resultset column to its matching
83633>>>>>>>>>>>            // column number in the file buffer.  If there is no match, we set that resultset
83633>>>>>>>>>>>            // column mappped column to -1.
83633>>>>>>>>>>>            //
83633>>>>>>>>>>>            // Since Arrays are zero based and columns are numbered from 1, when we actually map
83633>>>>>>>>>>>            // to set the value, we need to add 1 to array indexer to get the proper resultset
83633>>>>>>>>>>>            // column AND we need to add 1 to the mapped-to column since it was loaded into a zero
83633>>>>>>>>>>>            // based array also.  (Ex: vResultColumn[0] = 2 means column 1 from the resultset maps
83633>>>>>>>>>>>            // to Column 3 of the file buffer)
83633>>>>>>>>>>>
83633>>>>>>>>>>>
83633>>>>>>>>>>>            SQL_GET_NUM_COLS to iColCnt
83643>>>>>>>>>>>>
83643>>>>>>>>>>>            For i from 1 to iColCnt
83649>>>>>>>>>>>>
83649>>>>>>>>>>>                SQL_GET_COL_NAME i to sColumnName
83665>>>>>>>>>>>>
83665>>>>>>>>>>>                // Because SearchArray returns -1 if there isn't a match, we don't need to do
83665>>>>>>>>>>>                // anything to make an "unmapped column" have a value of -1.
83665>>>>>>>>>>>                Move (SearchArray(Uppercase(sColumnName), sBindFileColumns)) to tColumnMap.vResultColumn[i-1]
83666>>>>>>>>>>>
83666>>>>>>>>>>>                // If the types don't match between the columns, then "unmap" the column.  This
83666>>>>>>>>>>>                // should only occur when you're not mapping to the same file as the resultset.
83666>>>>>>>>>>>                // In this case, sql.pkg silently does nothing, so we need to duplicate this instead
83666>>>>>>>>>>>                // of generating an error.  If the mapping is to a string, then any type can be
83666>>>>>>>>>>>                // converted to a string so its okay.
83666>>>>>>>>>>>                If (tColumnMap.vResultColumn[i-1] <> -1) Begin
83668>>>>>>>>>>>                    SQL_GET_COL_ATTRIBUTE of i DFTYPE to iResultColumnType
83685>>>>>>>>>>>>
83685>>>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFileNum (tColumnMap.vResultColumn[i-1]) to iBindFileColumnType
83688>>>>>>>>>>>
83688>>>>>>>>>>>                    // If the conversion is to string (even if the resultset column is something
83688>>>>>>>>>>>                    // else) its ok, so Break out of the If block before we muck things up.
83688>>>>>>>>>>>                    If (iBindFileColumnType = DF_ASCII) Break
83691>>>>>>>>>>>
83691>>>>>>>>>>>                    // Otherwise, break the mapping
83691>>>>>>>>>>>                    If (iResultColumnType <> iBindFileColumnType) Move -1 to tColumnMap.vResultColumn[i-1]
83694>>>>>>>>>>>                End
83694>>>>>>>>>>>>
83694>>>>>>>>>>>            Loop
83695>>>>>>>>>>>>
83695>>>>>>>>>>>
83695>>>>>>>>>>>            Set ptColumnMap to tColumnMap
83696>>>>>>>>>>>        End
83696>>>>>>>>>>>>
83696>>>>>>>>>>>
83696>>>>>>>>>>>        Get SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
83697>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to True
83698>>>>>>>>>>>        Clear iFileNum
83699>>>>>>>>>>>        For i from 0 to (SizeOfArray(tColumnMap.vResultColumn)-1)
83705>>>>>>>>>>>>
83705>>>>>>>>>>>            If (tColumnMap.vResultColumn[i] > -1) Begin
83707>>>>>>>>>>>                SQL_FETCH_COLUMN (i+1) into vFieldValue
83712>>>>>>>>>>>                Set_Field_Value iFileNum (tColumnMap.vResultColumn[i]) to vFieldValue
83715>>>>>>>>>>>            End
83715>>>>>>>>>>>>
83715>>>>>>>>>>>        Loop
83716>>>>>>>>>>>>
83716>>>>>>>>>>>        Set_Attribute DF_FILE_STATUS of iFileNum to DF_FILE_ACTIVE
83719>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
83720>>>>>>>>>>>    End_Procedure
83721>>>>>>>>>>>
83721>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
83723>>>>>>>>>>>        String data
83723>>>>>>>>>>>        Integer retlen
83723>>>>>>>>>>>
83723>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83737>>>>>>>>>>>>
83737>>>>>>>>>>>
83737>>>>>>>>>>>        SQL_SET_CHUNK_SIZE to iLen
83754>>>>>>>>>>>>
83754>>>>>>>>>>>        SQL_GET_DATA_CHUNK COLUMN iCol OFFSET (piDataChunkOffset(Self)) to data retlen
83764>>>>>>>>>>>>
83764>>>>>>>>>>>        Set piDataChunkOffset to (piDataChunkOffset(Self)+retlen)
83765>>>>>>>>>>>
83765>>>>>>>>>>>        Function_Return data
83766>>>>>>>>>>>    End_Function
83767>>>>>>>>>>>
83767>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
83769>>>>>>>>>>>        Integer iNumColumns i iIndex
83769>>>>>>>>>>>        String[] cols
83770>>>>>>>>>>>
83770>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83784>>>>>>>>>>>>
83784>>>>>>>>>>>
83784>>>>>>>>>>>        Get SQLStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT to iNumColumns
83785>>>>>>>>>>>
83785>>>>>>>>>>>        For i from 1 to iNumColumns
83791>>>>>>>>>>>>
83791>>>>>>>>>>>            SQL_GET_COL_NAME i to cols[i-1]
83807>>>>>>>>>>>>
83807>>>>>>>>>>>            Move (trim(Uppercase(cols[i-1]))) to cols[i-1]
83808>>>>>>>>>>>        Loop
83809>>>>>>>>>>>>
83809>>>>>>>>>>>
83809>>>>>>>>>>>        Move (trim(Uppercase(sColname))) to sColname
83810>>>>>>>>>>>        Move (SearchArray(sColname, cols)) to iIndex
83811>>>>>>>>>>>        Function_Return (iIndex+1)  // even if searcharray returns -1 (not found) this expects 0 for not found, so it's ok
83812>>>>>>>>>>>    End_Function
83813>>>>>>>>>>>
83813>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
83815>>>>>>>>>>>        Integer iCnt
83815>>>>>>>>>>>
83815>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83829>>>>>>>>>>>>
83829>>>>>>>>>>>
83829>>>>>>>>>>>        Case Begin
83829>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
83831>>>>>>>>>>>                SQL_GET_NUM_COLS to iCnt
83841>>>>>>>>>>>>
83841>>>>>>>>>>>                Function_Return iCnt
83842>>>>>>>>>>>                Case Break
83843>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
83846>>>>>>>>>>>                SQL_GET_NUM_ROWS to iCnt
83856>>>>>>>>>>>>
83856>>>>>>>>>>>
83856>>>>>>>>>>>                //DAC Driver doesn't know the rowcount before the first fetch.
83856>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83858>>>>>>>>>>>                    If (pisBeforeFetch(Self)) Function_Return -1
83861>>>>>>>>>>>                End
83861>>>>>>>>>>>>
83861>>>>>>>>>>>
83861>>>>>>>>>>>                Function_Return iCnt
83862>>>>>>>>>>>                Case Break
83863>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
83866>>>>>>>>>>>                // TODO: Need something to indicate the quality of the SQL_GET_NUM_ROWS, or fake till I make it
83866>>>>>>>>>>>                Case Break
83867>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
83870>>>>>>>>>>>                Function_Return -1
83871>>>>>>>>>>>                // TODO: Are the messages returned in SQLGetMessage from the driver, or from the underlying connection?
83871>>>>>>>>>>>                Case Break
83872>>>>>>>>>>>            Case Else
83872>>>>>>>>>>>        Case End
83872>>>>>>>>>>>
83872>>>>>>>>>>>    End_Function
83873>>>>>>>>>>>
83873>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
83875>>>>>>>>>>>        String sValue
83875>>>>>>>>>>>        Integer iSQLType
83875>>>>>>>>>>>        Integer iDFType
83875>>>>>>>>>>>
83875>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83889>>>>>>>>>>>>
83889>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol SQLTYPE to iSQLType
83906>>>>>>>>>>>>
83906>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to iDFType
83923>>>>>>>>>>>>
83923>>>>>>>>>>>
83923>>>>>>>>>>>        Case Begin
83923>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SIZE)
83925>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol SIZE to sValue
83942>>>>>>>>>>>>
83942>>>>>>>>>>>
83942>>>>>>>>>>>                //DAC Driver uses different values.
83942>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83944>>>>>>>>>>>                    If (iSQLType=12) Move (Integer(sValue-1)) to sValue
83947>>>>>>>>>>>                    If (iDFType=5) Move "0" to sValue
83950>>>>>>>>>>>                    If (iSQLType=40)  Move "10" to sValue
83953>>>>>>>>>>>                End
83953>>>>>>>>>>>>
83953>>>>>>>>>>>
83953>>>>>>>>>>>                Case Break
83954>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_PRECISION)
83957>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DECIMALS to sValue
83974>>>>>>>>>>>>
83974>>>>>>>>>>>                Case Break
83975>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_LABEL)
83978>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
83995>>>>>>>>>>>>
83995>>>>>>>>>>>                Case Break
83996>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
83999>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
84016>>>>>>>>>>>>
84016>>>>>>>>>>>
84016>>>>>>>>>>>                //DAC Driver doesn't use Base Column Name.
84016>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
84018>>>>>>>>>>>                    Move "" to sValue
84019>>>>>>>>>>>                End
84019>>>>>>>>>>>>
84019>>>>>>>>>>>
84019>>>>>>>>>>>                Case Break
84020>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
84023>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol TABLE_NAME to sValue
84040>>>>>>>>>>>>
84040>>>>>>>>>>>                Case Break
84041>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
84044>>>>>>>>>>>                Move iSQLType to sValue
84045>>>>>>>>>>>
84045>>>>>>>>>>>                //DAC Driver uses different values.
84045>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
84047>>>>>>>>>>>                    If (iSQLType=2) Move "3" to sValue
84050>>>>>>>>>>>                    If (iSQLType=-99) Move "12" to sValue
84053>>>>>>>>>>>                    If (iSQLType=40)  Move "91" to sValue
84056>>>>>>>>>>>                End
84056>>>>>>>>>>>>
84056>>>>>>>>>>>
84056>>>>>>>>>>>                Case Break
84057>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_NULLABLE)
84060>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol NULLABLE to sValue
84077>>>>>>>>>>>>
84077>>>>>>>>>>>                Case Break
84078>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_DFTYPE)
84081>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sValue
84098>>>>>>>>>>>>
84098>>>>>>>>>>>
84098>>>>>>>>>>>                //DAC Driver uses different values.
84098>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
84100>>>>>>>>>>>                    If (iDFType = 5) Move "0" to sValue
84103>>>>>>>>>>>                End
84103>>>>>>>>>>>>
84103>>>>>>>>>>>                Case Break
84104>>>>>>>>>>>        Case End
84104>>>>>>>>>>>
84104>>>>>>>>>>>        Function_Return sValue
84105>>>>>>>>>>>    End_Function
84106>>>>>>>>>>>
84106>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
84108>>>>>>>>>>>        Set psProcName to sProcName
84109>>>>>>>>>>>        If (Num_Arguments >= 2) ;            Set psSchemaName to sSchemaArg
84112>>>>>>>>>>>        Else ;            Set psSchemaName to ""
84114>>>>>>>>>>>    End_Procedure
84115>>>>>>>>>>>
84115>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
84117>>>>>>>>>>>        Integer iArgnum
84117>>>>>>>>>>>
84117>>>>>>>>>>>        Get piLastArgument to iArgnum
84118>>>>>>>>>>>        Increment iArgnum
84119>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
84120>>>>>>>>>>>        Set piLastArgument to iArgnum
84121>>>>>>>>>>>    End_Procedure // SQLSetNextArgument
84122>>>>>>>>>>>
84122>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
84124>>>>>>>>>>>        Variant[] vParams
84125>>>>>>>>>>>
84125>>>>>>>>>>>        Get pvParams to vParams
84126>>>>>>>>>>>        Move sArgument to vParams[iArgnum-1]
84127>>>>>>>>>>>        Set pvParams to vParams
84128>>>>>>>>>>>
84128>>>>>>>>>>>    End_Procedure // SQLSetArgument
84129>>>>>>>>>>>
84129>>>>>>>>>>>    Procedure SQLCall
84131>>>>>>>>>>>        Variant[] vParams
84132>>>>>>>>>>>        Variant[] vParamOpts
84133>>>>>>>>>>>        Integer i
84133>>>>>>>>>>>        Integer iMax
84133>>>>>>>>>>>        Integer iParamsIn
84133>>>>>>>>>>>        String sParameter
84133>>>>>>>>>>>        Boolean bIsProcedure
84133>>>>>>>>>>>
84133>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
84147>>>>>>>>>>>>
84147>>>>>>>>>>>
84147>>>>>>>>>>>        Get pvParams to vParams
84148>>>>>>>>>>>
84148>>>>>>>>>>>        // First, we need to figure out if this is a procedure or a function. Then if
84148>>>>>>>>>>>        // it's a procedure, "analyze" it to figure out which parameters are IN,
84148>>>>>>>>>>>        // OUT, or IN_OUT.  Then we adjust how we call SQL_SET_PROCEDURE_PARAMETER
84148>>>>>>>>>>>        // so that after the call you can retrieve the value.
84148>>>>>>>>>>>
84148>>>>>>>>>>>        Get IsProcedure (psProcName(Self)) to bIsProcedure
84149>>>>>>>>>>>
84149>>>>>>>>>>>        If (bIsProcedure) Begin
84151>>>>>>>>>>>            Get ProcParams (psProcName(Self)) to vParamOpts
84152>>>>>>>>>>>
84152>>>>>>>>>>>            Move (sizeOfArray(vParamOpts)) to iMax
84153>>>>>>>>>>>            Move (SizeOfArray(vParams)) to iParamsIn
84154>>>>>>>>>>>            Set piParameterCount to iMax
84155>>>>>>>>>>>
84155>>>>>>>>>>>            SQL_SET_PROCEDURE_NAME (psProcName(Self)) NUMPAR iMax
84175>>>>>>>>>>>            For i from 1 to iMax
84181>>>>>>>>>>>>
84181>>>>>>>>>>>                If ( (i-1) >= iParamsIn) Move "" to sParameter
84184>>>>>>>>>>>                Else Move vParams[i-1] to sParameter
84186>>>>>>>>>>>
84186>>>>>>>>>>>                Case Begin
84186>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN")
84188>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN
84229>>>>>>>>>>>>
84229>>>>>>>>>>>                        Case Break
84230>>>>>>>>>>>                    Case (vParamOpts[i-1] = "OUT")
84233>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter OUT
84274>>>>>>>>>>>>
84274>>>>>>>>>>>                        Case Break
84275>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN/OUT" or vParamOpts[i-1] = "INOUT")
84278>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN_OUT
84319>>>>>>>>>>>>
84319>>>>>>>>>>>                        Case Break
84320>>>>>>>>>>>                Case End
84320>>>>>>>>>>>            Loop
84321>>>>>>>>>>>>
84321>>>>>>>>>>>
84321>>>>>>>>>>>            SQL_PROCEDURE_EXECUTE
84336>>>>>>>>>>>        End
84336>>>>>>>>>>>>
84336>>>>>>>>>>>        Else Begin
84337>>>>>>>>>>>            SQL_SET_FUNCTION_NAME (psProcName(Self)) NUMPAR (SizeOfArray(vParams))
84361>>>>>>>>>>>            For i from 1 to (SizeOfArray(vParams))
84367>>>>>>>>>>>>
84367>>>>>>>>>>>                SQL_SET_FUNCTION_PARAMETER i to vParams[i-1]
84439>>>>>>>>>>>>
84439>>>>>>>>>>>            Loop
84440>>>>>>>>>>>>
84440>>>>>>>>>>>
84440>>>>>>>>>>>            SQL_FUNCTION_EXECUTE
84441>>>>>>>>>>>        End
84441>>>>>>>>>>>>
84441>>>>>>>>>>>    End_Procedure
84442>>>>>>>>>>>
84442>>>>>>>>>>>    Function SQLGetNextArgument Returns String
84444>>>>>>>>>>>        Local Integer iArgnum
84444>>>>>>>>>>>        Local String  sResult
84444>>>>>>>>>>>
84444>>>>>>>>>>>        Get piLastArgument to iArgnum
84445>>>>>>>>>>>        Increment iArgnum
84446>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
84447>>>>>>>>>>>        Set piLastArgument to iArgnum
84448>>>>>>>>>>>
84448>>>>>>>>>>>        Function_Return sResult
84449>>>>>>>>>>>    End_Function // SQLGetNextArgument
84450>>>>>>>>>>>
84450>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
84452>>>>>>>>>>>        String retval
84452>>>>>>>>>>>
84452>>>>>>>>>>>        If ( (piParameterCount(Self)) < iArgnum) Function_Return ""
84455>>>>>>>>>>>        SQL_GET_PROCEDURE_PARAMETER iArgnum to retval
84479>>>>>>>>>>>>
84479>>>>>>>>>>>
84479>>>>>>>>>>>        Function_Return retval
84480>>>>>>>>>>>    End_Function
84481>>>>>>>>>>>
84481>>>>>>>>>>>    Function SQLReturnValue Returns String
84483>>>>>>>>>>>        String retval
84483>>>>>>>>>>>
84483>>>>>>>>>>>        SQL_GET_FUNCTION_RETURN to retval
84515>>>>>>>>>>>        Function_Return retval
84516>>>>>>>>>>>    End_Function
84517>>>>>>>>>>>
84517>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
84519>>>>>>>>>>>        SQL_NEXT_RESULT_SET
84531>>>>>>>>>>>
84531>>>>>>>>>>>        Function_Return (Found)
84532>>>>>>>>>>>    End_Function
84533>>>>>>>>>>>
84533>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
84535>>>>>>>>>>>        // TODO
84535>>>>>>>>>>>    End_Function
84536>>>>>>>>>>>
84536>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
84538>>>>>>>>>>>        // TODO
84538>>>>>>>>>>>    End_Procedure
84539>>>>>>>>>>>
84539>>>>>>>>>>>
84539>>>>>>>>>>>End_Class
84540>>>>>>>>>>>
84540>>>>>>>>>>>Class cSQLConnectionDUF is a cObject
84541>>>>>>>>>>>    Procedure Construct_Object
84543>>>>>>>>>>>        Forward Send Construct_Object
84545>>>>>>>>>>>
84545>>>>>>>>>>>        Property Handle phCLIHandle 0
84546>>>>>>>>>>>        Property String psDriverID MertechInc_DriverName
84547>>>>>>>>>>>        Property Integer piBindFile 0
84548>>>>>>>>>>>        Property String psUsername ""
84549>>>>>>>>>>>        Property String psPassword ""
84550>>>>>>>>>>>
84550>>>>>>>>>>>        Property String psCurrentDatabase ""
84551>>>>>>>>>>>
84551>>>>>>>>>>>        Property tCLIHandleMap ptCLIHandleMap
84552>>>>>>>>>>>    End_Procedure
84553>>>>>>>>>>>
84553>>>>>>>>>>>    Procedure StoreHandleInfo Handle hCLIHandle String sDrvrId Handle iParentHandle
84555>>>>>>>>>>>        Set phCLIHandle      to hCLIHandle
84556>>>>>>>>>>>        Set psDriverID       to sDrvrId
84557>>>>>>>>>>>    End_Procedure // StoreHandleInfo
84558>>>>>>>>>>>
84558>>>>>>>>>>>    Procedure FreeHandle
84560>>>>>>>>>>>        Send Destroy
84561>>>>>>>>>>>    End_Procedure
84562>>>>>>>>>>>
84562>>>>>>>>>>>    Procedure Set SQLDatabase String sDatabase
84564>>>>>>>>>>>        tCLIHandleMap conn
84564>>>>>>>>>>>        tCLIHandleMap conn
84564>>>>>>>>>>>
84564>>>>>>>>>>>        Get ptCLIHandleMap to conn
84565>>>>>>>>>>>        Set psCurrentDatabase to sDatabase
84566>>>>>>>>>>>        SQL_USE_DATABASE of conn.sConnect to sDatabase
84580>>>>>>>>>>>>
84580>>>>>>>>>>>    End_Procedure
84581>>>>>>>>>>>
84581>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect Returns Handle
84583>>>>>>>>>>>        tCLIHandleMap[] maps
84583>>>>>>>>>>>        tCLIHandleMap[] maps
84584>>>>>>>>>>>        tCLIHandleMap conn
84584>>>>>>>>>>>        tCLIHandleMap conn
84584>>>>>>>>>>>
84584>>>>>>>>>>>        Get ptCLIHandleMaps to maps
84585>>>>>>>>>>>        Move sDriver to conn.sDriver
84586>>>>>>>>>>>        Move sConnect to conn.sConnect
84587>>>>>>>>>>>
84587>>>>>>>>>>>        If (SizeOfArray(maps) > 0) Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
84590>>>>>>>>>>>        Else Move 1 to conn.iHdbc
84592>>>>>>>>>>>
84592>>>>>>>>>>>        Set CurrentConnection to sDriver sConnect
84593>>>>>>>>>>>        If (not(Err)) Begin
84595>>>>>>>>>>>            Move conn to maps[(SizeOfArray(maps))]
84596>>>>>>>>>>>            Set ptCLIHandleMaps to maps
84597>>>>>>>>>>>            Set ptCLIHandleMap to conn
84598>>>>>>>>>>>        End
84598>>>>>>>>>>>>
84598>>>>>>>>>>>
84598>>>>>>>>>>>        Function_Return Self
84599>>>>>>>>>>>    End_Function
84600>>>>>>>>>>>
84600>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
84602>>>>>>>>>>>        Boolean bIsOpen
84602>>>>>>>>>>>        String sDriver sServer
84602>>>>>>>>>>>        tCLIHandleMap[] maps
84602>>>>>>>>>>>        tCLIHandleMap[] maps
84603>>>>>>>>>>>        tCLIHandleMap conn
84603>>>>>>>>>>>        tCLIHandleMap conn
84603>>>>>>>>>>>
84603>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
84606>>>>>>>>>>>        If (bIsOpen) Begin
84608>>>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
84608>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDriver
84609>>>>>>>>>>>            Move (Repeat(' ', 255)) to sServer
84610>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDriver
84613>>>>>>>>>>>            Get_Attribute DF_FILE_SERVER_NAME of iFileNum to sServer
84616>>>>>>>>>>>
84616>>>>>>>>>>>            Indicate Err False
84617>>>>>>>>>>>
84617>>>>>>>>>>>            Get ptCLIHandleMaps to maps
84618>>>>>>>>>>>            Move sDriver to conn.sDriver
84619>>>>>>>>>>>            Move sServer to conn.sConnect
84620>>>>>>>>>>>
84620>>>>>>>>>>>            If (SizeOfArray(maps) > 0) Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
84623>>>>>>>>>>>            Else Move 1 to conn.iHdbc
84625>>>>>>>>>>>
84625>>>>>>>>>>>            Set CurrentConnection to sDriver sServer
84626>>>>>>>>>>>            If (not(Err)) Begin
84628>>>>>>>>>>>                Move conn to maps[(SizeOfArray(maps))]
84629>>>>>>>>>>>                Set ptCLIHandleMaps to maps
84630>>>>>>>>>>>                Set ptCLIHandleMap to conn
84631>>>>>>>>>>>            End
84631>>>>>>>>>>>>
84631>>>>>>>>>>>
84631>>>>>>>>>>>            Send StoreHandleInfo conn.iHdbc conn.sDriver
84632>>>>>>>>>>>            Set piBindFile to iFileNum
84633>>>>>>>>>>>        End
84633>>>>>>>>>>>>
84633>>>>>>>>>>>        Else Error 4099 "File Not Open"
84635>>>>>>>>>>>
84635>>>>>>>>>>>        //*** Return success status
84635>>>>>>>>>>>        Function_Return (not(Err))
84636>>>>>>>>>>>    End_Function
84637>>>>>>>>>>>
84637>>>>>>>>>>>    Procedure SQLDisconnect
84639>>>>>>>>>>>        tCLIHandleMap map
84639>>>>>>>>>>>        tCLIHandleMap map
84639>>>>>>>>>>>        tCLIHandleMap[] maps
84639>>>>>>>>>>>        tCLIHandleMap[] maps
84640>>>>>>>>>>>        Integer iFound
84640>>>>>>>>>>>
84640>>>>>>>>>>>        Get ptCLIHandleMap to map
84641>>>>>>>>>>>        Get ptCLIHandleMaps to maps
84642>>>>>>>>>>>
84642>>>>>>>>>>>        Move (SearchArray(map, maps, Parent(Self), RefFunc(CompareMaps))) to iFound
84643>>>>>>>>>>>        If (iFound > -1) Begin
84645>>>>>>>>>>>            Send FreeHandle
84646>>>>>>>>>>>        End
84646>>>>>>>>>>>>
84646>>>>>>>>>>>    End_Procedure // SQLDisconnect
84647>>>>>>>>>>>
84647>>>>>>>>>>>    Function CreateHandle Returns Integer
84649>>>>>>>>>>>        Handle hSQL
84649>>>>>>>>>>>        Integer iCursor
84649>>>>>>>>>>>
84649>>>>>>>>>>>        Get Create U_cSQLStatementDUF to hSQL
84650>>>>>>>>>>>
84650>>>>>>>>>>>        Set piBindFile of hSQL to (piBindFile(Current_object))
84651>>>>>>>>>>>
84651>>>>>>>>>>>        SQL_OPEN_CURSOR_STMT to iCursor
84665>>>>>>>>>>>>
84665>>>>>>>>>>>        Set piCursorNum of hSQL to iCursor
84666>>>>>>>>>>>
84666>>>>>>>>>>>        Function_Return hSQL
84667>>>>>>>>>>>    End_Function // CreateHandle
84668>>>>>>>>>>>
84668>>>>>>>>>>>    Function SQLOpen Returns Integer
84670>>>>>>>>>>>        Handle hDFHandle
84670>>>>>>>>>>>
84670>>>>>>>>>>>        Get CreateHandle to hDFHandle
84671>>>>>>>>>>>
84671>>>>>>>>>>>        Send StoreHandleInfo to hDFHandle Self (psDriverID(Self))
84672>>>>>>>>>>>
84672>>>>>>>>>>>        Function_Return hDFHandle
84673>>>>>>>>>>>    End_Function // SQLOpen
84674>>>>>>>>>>>
84674>>>>>>>>>>>
84674>>>>>>>>>>>
84674>>>>>>>>>>>
84674>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
84676>>>>>>>>>>>        String sCurrentDriver
84676>>>>>>>>>>>        Integer iDriver
84676>>>>>>>>>>>        Integer iNumDrivers
84676>>>>>>>>>>>
84676>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumDrivers
84679>>>>>>>>>>>        For iDriver from 1 to iNumDrivers
84685>>>>>>>>>>>>
84685>>>>>>>>>>>          Get_Attribute DF_DRIVER_NAME of iDriver to sCurrentDriver
84688>>>>>>>>>>>          If (Uppercase(sDriver) = Uppercase(sCurrentDriver)) ;              Function_Return iDriver
84691>>>>>>>>>>>        Loop
84692>>>>>>>>>>>>
84692>>>>>>>>>>>        Function_Return 0
84693>>>>>>>>>>>    End_Function // DriverIndex
84694>>>>>>>>>>>
84694>>>>>>>>>>>    Function FirstServerForDriverNo Integer iDriver Returns String
84696>>>>>>>>>>>        String sServer
84696>>>>>>>>>>>        Integer iNumServers
84696>>>>>>>>>>>        Integer iServer
84696>>>>>>>>>>>
84696>>>>>>>>>>>        If (iDriver <> 0) Begin
84698>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
84701>>>>>>>>>>>            If (iNumServers<>0) Begin
84703>>>>>>>>>>>                Move 1 to iServer
84704>>>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iServer to sServer
84707>>>>>>>>>>>            End
84707>>>>>>>>>>>>
84707>>>>>>>>>>>        End
84707>>>>>>>>>>>>
84707>>>>>>>>>>>
84707>>>>>>>>>>>        Function_Return sServer
84708>>>>>>>>>>>    End_Function
84709>>>>>>>>>>>
84709>>>>>>>>>>>    Procedure Set CurrentConnection String sDriver String sServer
84711>>>>>>>>>>>        Integer iDriver
84711>>>>>>>>>>>        String sUsername
84711>>>>>>>>>>>        String sPassword
84711>>>>>>>>>>>
84711>>>>>>>>>>>        If (sDriver="") Begin
84713>>>>>>>>>>>            DO_GETFILENUMBER_DRIVERNAME 0
84715>>>>>>>>>>>            Move MertechInc_DriverName to sDriver
84716>>>>>>>>>>>        End
84716>>>>>>>>>>>>
84716>>>>>>>>>>>
84716>>>>>>>>>>>        If ("MDSMYSQL|ORA_DRV|MDSPGSQL|SQL_DRV|MDS_DB2" contains Uppercase(Trim(sDriver))) Begin
84718>>>>>>>>>>>            Move (Uppercase(Trim(sDriver))) to MertechInc_DriverName
84719>>>>>>>>>>>
84719>>>>>>>>>>>            If (Trim(sDriver) <> "") Move (Uppercase(Trim(sDriver))) to MertechInc_CurrentDriver
84722>>>>>>>>>>>            Else Move "" to MertechInc_CurrentDriver
84724>>>>>>>>>>>
84724>>>>>>>>>>>            Get psUsername to sUsername
84725>>>>>>>>>>>            Get psPassword to sPassword
84726>>>>>>>>>>>
84726>>>>>>>>>>>            Get DriverIndex MertechInc_CurrentDriver to iDriver
84727>>>>>>>>>>>
84727>>>>>>>>>>>            If (sServer="") Get FirstServerForDriverNo iDriver to sServer
84730>>>>>>>>>>>            If (sUsername="") GET_CURRENT_USER_NAME of sServer to sUsername
84747>>>>>>>>>>>            If (sPassword="") get_current_user_password of sServer to sPassword
84764>>>>>>>>>>>            Move False to Err
84765>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 25000
84766>>>>>>>>>>>            Login sServer sUsername sPassword sDriver
84768>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 25000
84769>>>>>>>>>>>            If (Err = False) Begin
84771>>>>>>>>>>>                Call_Driver 0 MertechInc_DriverName Function CALLDRV_CURRENT_SQL_SERVER_CONNECTION CALLBACK 0 PASSING sServer MertechInc_Blank 0 RESULT MertechInc_iRet
84776>>>>>>>>>>>            End
84776>>>>>>>>>>>>
84776>>>>>>>>>>>            Else Begin
84777>>>>>>>>>>>                Procedure_Return
84778>>>>>>>>>>>            End
84778>>>>>>>>>>>>
84778>>>>>>>>>>>
84778>>>>>>>>>>>            If MertechInc_iRet EQ -1 INDICATE ERR True
84781>>>>>>>>>>>        End
84781>>>>>>>>>>>>
84781>>>>>>>>>>>        Else Error 4099 "Invalid Driver"
84783>>>>>>>>>>>
84783>>>>>>>>>>>    End_Procedure
84784>>>>>>>>>>>
84784>>>>>>>>>>>End_Class
84785>>>>>>>>>>>
84785>>>>>>>>>>>Class cSQLHandleManagerDUF is a cObject
84786>>>>>>>>>>>
84786>>>>>>>>>>>    Procedure Construct_Object
84788>>>>>>>>>>>        Forward Send Construct_Object
84790>>>>>>>>>>>
84790>>>>>>>>>>>        Property String  psDefaultDriver     ""
84791>>>>>>>>>>>        Property String  psDefaultConnection ""
84792>>>>>>>>>>>        Property tCLIHandleMap[] ptCLIHandleMaps
84793>>>>>>>>>>>    End_Procedure
84794>>>>>>>>>>>
84794>>>>>>>>>>>    Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
84796>>>>>>>>>>>        If ((map1.iHdbc = map2.iHdbc) and (map1.sConnect = map2.sConnect) and (map1.sDriver = map2.sDriver)) Begin
84798>>>>>>>>>>>            Function_Return (EQ)
84799>>>>>>>>>>>        End
84799>>>>>>>>>>>>
84799>>>>>>>>>>>    End_Function
84800>>>>>>>>>>>
84800>>>>>>>>>>>    Function CreateHandle Returns Handle
84802>>>>>>>>>>>        Handle hSQL
84802>>>>>>>>>>>
84802>>>>>>>>>>>        Get Create U_cSQLConnectionDUF to hSQL
84803>>>>>>>>>>>        Function_Return hSQL
84804>>>>>>>>>>>    End_Function
84805>>>>>>>>>>>
84805>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
84807>>>>>>>>>>>        Set psDefaultDriver to sDriver
84808>>>>>>>>>>>        Set psDefaultConnection to sConnect
84809>>>>>>>>>>>    End_Procedure
84810>>>>>>>>>>>
84810>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect String sUsername String sPassword Returns Handle
84812>>>>>>>>>>>        Handle hSql
84812>>>>>>>>>>>        Boolean bOK
84812>>>>>>>>>>>
84812>>>>>>>>>>>        Get CreateHandle to hSql
84813>>>>>>>>>>>
84813>>>>>>>>>>>        If (sDriver = "" and sConnect = "") Begin
84815>>>>>>>>>>>            Move (psDefaultDriver(Self)) to sDriver
84816>>>>>>>>>>>            Move (psDefaultConnection(Self)) to sConnect
84817>>>>>>>>>>>        End
84817>>>>>>>>>>>>
84817>>>>>>>>>>>
84817>>>>>>>>>>>        If (num_arguments>2) Begin
84819>>>>>>>>>>>            Set psUsername of hSql to sUsername
84820>>>>>>>>>>>            Set psPassword of hSql to sPassword
84821>>>>>>>>>>>        End
84821>>>>>>>>>>>>
84821>>>>>>>>>>>
84821>>>>>>>>>>>        Get SQLConnect of hSql sDriver sConnect to bOK
84822>>>>>>>>>>>        If (not(bOK)) Begin
84824>>>>>>>>>>>            Send FreeHandle of hSQL
84825>>>>>>>>>>>            Function_Return 0
84826>>>>>>>>>>>        End
84826>>>>>>>>>>>>
84826>>>>>>>>>>>
84826>>>>>>>>>>>        Function_Return hSql
84827>>>>>>>>>>>    End_Function
84828>>>>>>>>>>>
84828>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
84830>>>>>>>>>>>        Handle hSql
84830>>>>>>>>>>>        Boolean bOK
84830>>>>>>>>>>>
84830>>>>>>>>>>>        //*** Allocate a new handle
84830>>>>>>>>>>>        Get CreateHandle to hSql
84831>>>>>>>>>>>        Get SQLFileConnect of hSql iFileNum to bOK
84832>>>>>>>>>>>
84832>>>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
84832>>>>>>>>>>>        If (not(bOK)) Begin
84834>>>>>>>>>>>            Send FreeHandle of hSql
84835>>>>>>>>>>>            Function_Return 0
84836>>>>>>>>>>>        End
84836>>>>>>>>>>>>
84836>>>>>>>>>>>
84836>>>>>>>>>>>        Function_Return hSql
84837>>>>>>>>>>>    End_Function // SQLFileConnect
84838>>>>>>>>>>>
84838>>>>>>>>>>>End_Class
84839>>>>>>>>>>>
84839>>>>>>>>>>>
84839>>>>>>>>>>>Function CreateSQLmanager for cDesktop Returns Integer
84841>>>>>>>>>>>    Handle hSqlManager
84841>>>>>>>>>>>
84841>>>>>>>>>>>    Get Create U_cSQLHandleManagerDUF to hSqlManager
84842>>>>>>>>>>>    Function_Return hSqlManager
84843>>>>>>>>>>>End_Function // CreateSQLMngr
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>
84844>>>>>>>>>>>Get CreateSQLManager of Desktop to _embsqlghoSQLHandleMngr
84845>>>>>>>>>>>
84845>>>>>>>>>>>
84845>>>>>>>>>    Use Mertech.inc
84845>>>>>>>>>
84845>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
84845>>>>>>>>>>>Use DUFLanguageConstants.inc
84845>>>>>>>>>>>
84845>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
84845>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
84845>>>>>>>>>>>
84845>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
84845>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateHandler
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define DATAFLEX_ID for "DATAFLEX"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_SERVER for "SERVER"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
84845>>>>>>>>>>>
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLScriptArray
84845>>>>>>>>>>>    Boolean bError
84845>>>>>>>>>>>    Boolean bArgumentSizeChanged
84845>>>>>>>>>>>    Integer iOrgArgumentSize
84845>>>>>>>>>>>    String[] sSQLScriptArray
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSqlErrorArray
84845>>>>>>>>>>>    String[]  sSqlErrorArray
84845>>>>>>>>>>>    String[]  sSqlStatementArray
84845>>>>>>>>>>>    Integer[] iSqlErrorArray
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSqlColumnNew
84845>>>>>>>>>>>    String  sBaseColumnName
84845>>>>>>>>>>>    String  sBaseTableName
84845>>>>>>>>>>>    String  sLabel
84845>>>>>>>>>>>    Integer iSqlType
84845>>>>>>>>>>>    Integer iSize
84845>>>>>>>>>>>    Integer iPrecision
84845>>>>>>>>>>>    Integer iDFType
84845>>>>>>>>>>>    Integer iDFNativeType
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tColumnType
84845>>>>>>>>>>>    String  sType
84845>>>>>>>>>>>    Integer iType
84845>>>>>>>>>>>    String  sDataFlexType
84845>>>>>>>>>>>    Integer iDataFlexType
84845>>>>>>>>>>>    String  sPrecision
84845>>>>>>>>>>>    Boolean bFixedSize 
84845>>>>>>>>>>>    Boolean bNativeDataType
84845>>>>>>>>>>>    Integer iDefaultSize
84845>>>>>>>>>>>    Integer iMinSize
84845>>>>>>>>>>>    Number  nMaxSize
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
84845>>>>>>>>>>>// Various SQL back-ends can have slightly different
84845>>>>>>>>>>>// keywords.
84845>>>>>>>>>>>Struct tSQLKeyWords
84845>>>>>>>>>>>    Integer iSQLWord
84845>>>>>>>>>>>    Integer iSQLDbType
84845>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLRelation
84845>>>>>>>>>>>    Integer iFileNumber
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    String  sFileName
84845>>>>>>>>>>>    String  sFieldName
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLLoggedInUser
84845>>>>>>>>>>>    String sUser
84845>>>>>>>>>>>    String sProgram
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
84845>>>>>>>>>>>Enumeration_List
84845>>>>>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
84845>>>>>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
84845>>>>>>>>>>>End_Enumeration_List
84845>>>>>>>>>>>
84845>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
84845>>>>>>>>>>>// They can have slightly different SQL keywords.
84845>>>>>>>>>>>// Note: If a new type is added to the list,
84845>>>>>>>>>>>//       the struct array xxx must be adjusted
84845>>>>>>>>>>>//       so that it is filled with all SQL
84845>>>>>>>>>>>//       keywords for that new type.
84845>>>>>>>>>>>Enum_List
84845>>>>>>>>>>>    Define EN_DbTypeMSSQL
84845>>>>>>>>>>>    Define EN_DbTypeMySQL
84845>>>>>>>>>>>    Define EN_DbTypeOracle
84845>>>>>>>>>>>    Define EN_DbTypeDB2
84845>>>>>>>>>>>    Define EN_DbTypePostgre
84845>>>>>>>>>>>    Define EN_DbTypeDataFlex // Embedded database.
84845>>>>>>>>>>>End_Enum_List
84845>>>>>>>>>>>
84845>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
84845>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
84845>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
84845>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
84845>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
84845>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
84845>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
84845>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
84845>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
84845>>>>>>>>>>>
84845>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
84845>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
84845>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
84845>>>>>>>>>>>Enum_List
84845>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
84845>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
84845>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
84845>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
84845>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
84845>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
84845>>>>>>>>>>>End_Enum_List
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
84845>>>>>>>>>>>
84845>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
84845>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
84845>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
84845>>>>>>>>>>>
84845>>>>>>>>>>>// These are not defined pre DF 18:
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLIntTableInfo
84845>>>>>>>>>>>    String sDriverName
84845>>>>>>>>>>>    String sServerName
84845>>>>>>>>>>>    String sDatabaseName
84845>>>>>>>>>>>    String sSchemaName
84845>>>>>>>>>>>    Boolean bRecnumTable
84845>>>>>>>>>>>    Integer iPrimaryIndex
84845>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
84845>>>>>>>>>>>    String sTableCharacterFormat
84845>>>>>>>>>>>    Boolean bUseDummyZeroDate
84845>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
84845>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
84845>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
84845>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
84845>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
84845>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
84845>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
84845>>>>>>>>>>>    String sFileIndexTablespace
84845>>>>>>>>>>>    String sFileLongTablespace
84845>>>>>>>>>>>    String sTableTablespace
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tSQLIntColumnInfo
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    Integer iFieldIndex
84845>>>>>>>>>>>    Integer iFieldRelatedFile
84845>>>>>>>>>>>    Integer iFieldRelatedField
84845>>>>>>>>>>>    Integer iIndexNumber
84845>>>>>>>>>>>    Integer iIndexNumberSegments      
84845>>>>>>>>>>>    Integer iIndexSegmentField1
84845>>>>>>>>>>>    Integer iIndexSegmentField2
84845>>>>>>>>>>>    Integer iIndexSegmentFieldn
84845>>>>>>>>>>>    String  sIndexName
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIColumn 
84845>>>>>>>>>>>    String  sFieldName 
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    Integer iType  
84845>>>>>>>>>>>    String  sType
84845>>>>>>>>>>>    Integer iLength 
84845>>>>>>>>>>>    Integer iPrecision 
84845>>>>>>>>>>>    Integer iOptions  
84845>>>>>>>>>>>    Boolean bIsSQLType
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>End_Struct  
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIRelation
84845>>>>>>>>>>>    Handle  hTableFrom
84845>>>>>>>>>>>    String  sLogicalNameFrom
84845>>>>>>>>>>>    Handle  hTableTo 
84845>>>>>>>>>>>    String  sLogicalNameTo
84845>>>>>>>>>>>    Integer iColumnFrom
84845>>>>>>>>>>>    String  sFieldNameFrom
84845>>>>>>>>>>>    Integer iColumnTo 
84845>>>>>>>>>>>    String  sFieldNameTo
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>End_Struct 
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIIndexSegment
84845>>>>>>>>>>>    Integer iFieldNumber
84845>>>>>>>>>>>    String  sFieldName 
84845>>>>>>>>>>>    Boolean bUppercase
84845>>>>>>>>>>>    Boolean bAscending
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPIIndex
84845>>>>>>>>>>>    Integer iIndexNumber
84845>>>>>>>>>>>    String  sSQLIndexName
84845>>>>>>>>>>>    Integer iSQLIndexType
84845>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray 
84845>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray 
84845>>>>>>>>>>>    Boolean bIsPrimaryKey
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPITableNameInfo
84845>>>>>>>>>>>    Integer iTableNumber 
84845>>>>>>>>>>>    String  sRootName
84845>>>>>>>>>>>    String  sLogicalName
84845>>>>>>>>>>>    String  sDisplayName  
84845>>>>>>>>>>>    String  sDriverID
84845>>>>>>>>>>>    Boolean bIsAlias
84845>>>>>>>>>>>    Boolean bIsSQL
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>    
84845>>>>>>>>>>>Struct tAPITable
84845>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
84845>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
84845>>>>>>>>>>>    tAPIColumn[]      aApiColumns
84845>>>>>>>>>>>    tAPIColumn[]      aApiColumns
84845>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
84845>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
84845>>>>>>>>>>>    tAPIRelation[]    aApiRelations
84845>>>>>>>>>>>    tAPIRelation[]    aApiRelations
84845>>>>>>>>>>>    Boolean bShouldChange
84845>>>>>>>>>>>End_Struct 
84845>>>>>>>>>>>
84845>>>>>>>>>>>Struct tAPITableBooleans
84845>>>>>>>>>>>    Boolean bCompareDate_DateTime
84845>>>>>>>>>>>    Boolean bCompareIndexAscending
84845>>>>>>>>>>>    Boolean bCompareIndexUppercase
84845>>>>>>>>>>>    Boolean bCompareFilelistUppercase
84845>>>>>>>>>>>End_Struct
84845>>>>>>>>>>>
84845>>>>>>>>>>>Define C_tAPIColumn_None for 0
84845>>>>>>>>>>>Define C_tAPIColumn_Identity for 1 
84845>>>>>>>>>>>
84845>>>>>>>>>>>// SQL Key-Word Constants:
84845>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
84845>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
84845>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
84845>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
84845>>>>>>>>>>>Enum_List
84845>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
84845>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
84845>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
84845>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
84845>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
84845>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
84845>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
84845>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
84845>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
84845>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
84845>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
84845>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
84845>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
84845>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
84845>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
84845>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
84845>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
84845>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
84845>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
84845>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
84845>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
84845>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
84845>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
84845>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
84845>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
84845>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
84845>>>>>>>>>>>
84845>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
84845>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
84845>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
84845>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
84845>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
84845>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
84845>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
84845>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
84845>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
84845>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
84845>>>>>>>>>>>End_Enum_List
84845>>>>>>>>>>>
84845>>>>>>>
84845>>>>>>>// This needs to be after Mertech drivers are defined.
84845>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
84845>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
84845>>>>>>>>>//
84845>>>>>>>>>// We need to create a mixin class for the library.
84845>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
84845>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
84845>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
84845>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
84845>>>>>>>>>//
84845>>>>>>>>>Use VdfBase.pkg
84845>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinUuid.pkg)
84845>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
84846>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
84847>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
84848>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
84849>>>>>>>>>>>
84849>>>>>>>>>>>// RandomHexUUID:
84849>>>>>>>>>>>
84849>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
84849>>>>>>>>>>>Function RandomHexUUID Global Returns String
84851>>>>>>>>>>>    Address pUUID pUUIDStr
84851>>>>>>>>>>>    Integer iRetval iOffset iChar
84851>>>>>>>>>>>    String sUUID sKey
84851>>>>>>>>>>>    
84851>>>>>>>>>>>    Move (Alloc(16)) to pUUID
84852>>>>>>>>>>>    
84852>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
84853>>>>>>>>>>>    
84853>>>>>>>>>>>    If (iRetval = 0) Begin
84855>>>>>>>>>>>        Move 0 to pUUIDStr
84856>>>>>>>>>>>        
84856>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
84857>>>>>>>>>>>        If (iRetval = 0) Begin
84859>>>>>>>>>>>            Move pUUIDStr to sUUID
84860>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
84861>>>>>>>>>>> 
84861>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
84862>>>>>>>>>>>        End
84862>>>>>>>>>>>>
84862>>>>>>>>>>>    End
84862>>>>>>>>>>>>
84862>>>>>>>>>>>    
84862>>>>>>>>>>>    Move (Free(pUUID)) to iRetval 
84863>>>>>>>>>>>    
84863>>>>>>>>>>>    Function_Return sUUID
84864>>>>>>>>>>>End_Function
84865>>>>>>>>>>>
84865>>>>>>>>>>>
84865>>>>>>>>>>>// SeqHexUUID:
84865>>>>>>>>>>>
84865>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
84865>>>>>>>>>>>Function SeqHexUUID Global Returns String    
84867>>>>>>>>>>>    Address pUUID pUUIDStr
84867>>>>>>>>>>>    Integer iRetval iOffset iChar
84867>>>>>>>>>>>    String sUUID sKey
84867>>>>>>>>>>>    
84867>>>>>>>>>>>    Move (Alloc(16)) to pUUID
84868>>>>>>>>>>>    
84868>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
84869>>>>>>>>>>>    
84869>>>>>>>>>>>    If (iRetval = 0) Begin
84871>>>>>>>>>>>        Move 0 to pUUIDStr
84872>>>>>>>>>>>        
84872>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
84873>>>>>>>>>>>        If (iRetval = 0) Begin
84875>>>>>>>>>>>            Move pUUIDStr to sUUID
84876>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
84877>>>>>>>>>>> 
84877>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
84878>>>>>>>>>>>        End
84878>>>>>>>>>>>>
84878>>>>>>>>>>>    End
84878>>>>>>>>>>>>
84878>>>>>>>>>>>    
84878>>>>>>>>>>>    Move (Free(pUUID)) to iRetval 
84879>>>>>>>>>>>    
84879>>>>>>>>>>>    Function_Return sUUID
84880>>>>>>>>>>>End_Function
84881>>>>>>>>>Use cli.pkg
84881>>>>>>>>>Use sql.pkg
84881>>>>>>>>>Use MSSqldrv.pkg
84881>>>>>>>>>Use db2_drv.pkg
84881>>>>>>>>>Use odbc_drv.pkg
84881>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DFBTRDRV.PKG)
84881>>>>>>>>>>>//****************************************************************************
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// $File name  : DFBTRDRV.PKG
84881>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
84881>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
84881>>>>>>>>>>>//               specific functions in the DFBTRDRV.
84881>>>>>>>>>>>// $Author(s)  : Eddy Kleinjan
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
84881>>>>>>>>>>>// Created     : 01-07-97 @ 12:00:00
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : 04-04-2001.
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : June 6, 2001
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//               Added DFBTR_DDF_OWNER command.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : June 12, 2001
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : August 4, 2004
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//               Added cDfbtrdrvHandler class.
84881>>>>>>>>>>>//               New functions in this class:
84881>>>>>>>>>>>//                  Function CKRevision Returns String
84881>>>>>>>>>>>//                  Function CkUsesUri Returns Integer
84881>>>>>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
84881>>>>>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
84881>>>>>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Changed     : September 30, 2005
84881>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
84881>>>>>>>>>>>//****************************************************************************
84881>>>>>>>>>>>Use Ui
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Driver Indentification
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//*** Driver attributes
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Call_Driver functions ID's
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// DFBTRFN_SET_OWNER options
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to create all vars which may be needed
84881>>>>>>>>>>>// in other commands.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to set the owner of a Btrieve file.
84881>>>>>>>>>>>// File must have been opened.
84881>>>>>>>>>>>// Filenumber needs to be passed.
84881>>>>>>>>>>>// To clear set the owner to "".
84881>>>>>>>>>>>// Examples:
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
84881>>>>>>>>>>>// To clear:
84881>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
84881>>>>>>>>>>>// options.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to parse for Callback
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
84881>>>>>>>>>>>// File must have been opened.
84881>>>>>>>>>>>// Filenumber needs to be passed.
84881>>>>>>>>>>>// Examples:
84881>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
84881>>>>>>>>>>>// which will be tries when opening files.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
84881>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
84881>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
84881>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to change the transaction type.
84881>>>>>>>>>>>// Valid types are:
84881>>>>>>>>>>>//     DFBTRTT_NONE
84881>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
84881>>>>>>>>>>>//     DFBTRTT_CONCURRENT
84881>>>>>>>>>>>//
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to get the current transaction type.
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to set explicit_locking
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to get explicit locking
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//
84881>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
84881>>>>>>>>>>>//
84881>>>>>>>>>>>
84881>>>>>>>>>>>//*****************************************************************************
84881>>>>>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
84881>>>>>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
84881>>>>>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
84881>>>>>>>>>>>//*****************************************************************************
84881>>>>>>>>>>>
84881>>>>>>>>>>>Class cDFBtrDrvHandler Is An Array
84882>>>>>>>>>>>
84882>>>>>>>>>>>    Procedure Construct_Object Integer iImage
84884>>>>>>>>>>>        Forward Send Construct_object iImage
84886>>>>>>>>>>>
84886>>>>>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
84887>>>>>>>>>>>    End_Procedure // Construct_Object
84888>>>>>>>>>>>
84888>>>>>>>>>>>
84888>>>>>>>>>>>
84888>>>>>>>>>>>    //***
84888>>>>>>>>>>>    //*** Function: CKRevsion
84888>>>>>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
84888>>>>>>>>>>>    //***
84888>>>>>>>>>>>
84888>>>>>>>>>>>    Function CKRevision Returns String
84890>>>>>>>>>>>        Local String  sDriverID
84890>>>>>>>>>>>        Local String  sRevision
84890>>>>>>>>>>>        Local String  sVoid
84890>>>>>>>>>>>        Local Integer iRetval
84890>>>>>>>>>>>
84890>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
84890>>>>>>>>>>>        // This error would otherwise be raised when we have an older
84890>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
84890>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
84891>>>>>>>>>>>        Get psDriverID To sDriverID
84892>>>>>>>>>>>        Move (Repeat(" ", 255)) To sRevision
84893>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
84898>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
84899>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
84901>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
84901>>>>>>>>>>>            Move "0.0.0.0" To sRevision
84902>>>>>>>>>>>        End
84902>>>>>>>>>>>>
84902>>>>>>>>>>>        Function_Return sRevision
84903>>>>>>>>>>>    End_Function // CKRevision
84904>>>>>>>>>>>
84904>>>>>>>>>>>    Function CkUsesUri Returns Integer
84906>>>>>>>>>>>        Local String  sDriverID
84906>>>>>>>>>>>        Local String  sVoid1
84906>>>>>>>>>>>        Local String  sVoid2
84906>>>>>>>>>>>        Local Integer iRetval
84906>>>>>>>>>>>
84906>>>>>>>>>>>        Get psDriverID To sDriverID
84907>>>>>>>>>>>
84907>>>>>>>>>>>        Move 0 To iRetval
84908>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
84908>>>>>>>>>>>        // This error would otherwise be raised when we have an older
84908>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
84908>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
84909>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
84914>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
84915>>>>>>>>>>>
84915>>>>>>>>>>>        Function_Return iRetval
84916>>>>>>>>>>>    End_Function // CKUsesUri
84917>>>>>>>>>>>
84917>>>>>>>>>>>
84917>>>>>>>>>>>
84917>>>>>>>>>>>    //***
84917>>>>>>>>>>>    //*** Function: ExtractPartFromRevsion
84917>>>>>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
84917>>>>>>>>>>>    //***
84917>>>>>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
84917>>>>>>>>>>>    //***
84917>>>>>>>>>>>
84917>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
84919>>>>>>>>>>>        Local Integer iPartRev
84919>>>>>>>>>>>        Local Integer iCurrentPart
84919>>>>>>>>>>>        Local Integer iSeparatorPos
84919>>>>>>>>>>>
84919>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
84922>>>>>>>>>>>
84922>>>>>>>>>>>        Move 0 To iCurrentPart
84923>>>>>>>>>>>        Repeat
84923>>>>>>>>>>>>
84923>>>>>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
84924>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
84926>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
84927>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
84928>>>>>>>>>>>                Increment iCurrentPart
84929>>>>>>>>>>>            End
84929>>>>>>>>>>>>
84929>>>>>>>>>>>            Else If (sRevision <> "") Begin
84932>>>>>>>>>>>                Move sRevision To iPartRev
84933>>>>>>>>>>>                Move "" To sRevision
84934>>>>>>>>>>>                Increment iCurrentPart
84935>>>>>>>>>>>            End
84935>>>>>>>>>>>>
84935>>>>>>>>>>>            Else ;                Move -1 To iPartRev
84937>>>>>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
84939>>>>>>>>>>>
84939>>>>>>>>>>>        Function_Return iPartRev
84940>>>>>>>>>>>    End_Function // EcxtractPartFromRevision
84941>>>>>>>>>>>
84941>>>>>>>>>>>
84941>>>>>>>>>>>
84941>>>>>>>>>>>    //***
84941>>>>>>>>>>>    //*** Function: CKMajorRevision
84941>>>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
84941>>>>>>>>>>>    //***
84941>>>>>>>>>>>
84941>>>>>>>>>>>    Function CKMajorRevision Returns Integer
84943>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
84944>>>>>>>>>>>    End_Function // CKMajorRevision
84945>>>>>>>>>>>
84945>>>>>>>>>>>
84945>>>>>>>>>>>
84945>>>>>>>>>>>    //***
84945>>>>>>>>>>>    //*** Function: CKMinorRevision
84945>>>>>>>>>>>    //*** Purpose : Returns the minor revision of the CK
84945>>>>>>>>>>>    //***
84945>>>>>>>>>>>
84945>>>>>>>>>>>    Function CKMinorRevision Returns Integer
84947>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
84948>>>>>>>>>>>    End_Function // CKMinorRevision
84949>>>>>>>>>>>
84949>>>>>>>>>>>
84949>>>>>>>>>>>
84949>>>>>>>>>>>    //***
84949>>>>>>>>>>>    //*** Function: CKReleaseRevision
84949>>>>>>>>>>>    //*** Purpose : Returns the release revision of the CK
84949>>>>>>>>>>>    //***
84949>>>>>>>>>>>
84949>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
84951>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
84952>>>>>>>>>>>    End_Function // CKReleaseRevision
84953>>>>>>>>>>>
84953>>>>>>>>>>>
84953>>>>>>>>>>>
84953>>>>>>>>>>>    //***
84953>>>>>>>>>>>    //*** Function: CKBuildRevision
84953>>>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
84953>>>>>>>>>>>    //***
84953>>>>>>>>>>>
84953>>>>>>>>>>>    Function CKBuildRevision Returns Integer
84955>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
84956>>>>>>>>>>>    End_Function // CKBuildRevision
84957>>>>>>>>>>>
84957>>>>>>>>>>>
84957>>>>>>>>>>>
84957>>>>>>>>>>>    //***
84957>>>>>>>>>>>    //*** Function: IsMinimalRevision
84957>>>>>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
84957>>>>>>>>>>>    //***
84957>>>>>>>>>>>
84957>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
84959>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
84962>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
84965>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
84968>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
84971>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
84974>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
84978>>>>>>>>>>>            End
84978>>>>>>>>>>>>
84978>>>>>>>>>>>        End
84978>>>>>>>>>>>>
84978>>>>>>>>>>>
84978>>>>>>>>>>>        Function_Return (FALSE)
84979>>>>>>>>>>>    End_Function // IsMinimalRevision
84980>>>>>>>>>>>
84980>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
84980>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
84980>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
84980>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
84980>>>>>>>>>>>    //
84980>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
84980>>>>>>>>>>>    //   in the following format:
84980>>>>>>>>>>>    //       <version>.<revision>.<type>
84980>>>>>>>>>>>    //   possible values for <type>:
84980>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
84980>>>>>>>>>>>    //         server using Workgroup authentication mode
84980>>>>>>>>>>>    //       C for client cache engine
84980>>>>>>>>>>>    //       D for DOS workstation
84980>>>>>>>>>>>    //       N for client Requester
84980>>>>>>>>>>>    //       S for NetWare server
84980>>>>>>>>>>>    //       T for 32-bit Windows server engine
84980>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
84980>>>>>>>>>>>    //
84980>>>>>>>>>>>    //   example:
84980>>>>>>>>>>>    //       8.50.T
84980>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
84980>>>>>>>>>>>    //   32-bits Windows server.
84980>>>>>>>>>>>    //
84980>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
84980>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
84980>>>>>>>>>>>    //
84980>>>>>>>>>>>    //   If the version information is not available or can not be obtained
84980>>>>>>>>>>>    //   the functions will return "0.0.0"
84980>>>>>>>>>>>
84980>>>>>>>>>>>
84980>>>>>>>>>>>    //***
84980>>>>>>>>>>>    //*** Function: PSQLRequesterVersionInfo
84980>>>>>>>>>>>    //*** Purpose : Returns the version information of the
84980>>>>>>>>>>>    //***           Pervasive.SQL Client requester.
84980>>>>>>>>>>>
84980>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
84982>>>>>>>>>>>
84982>>>>>>>>>>>        Local String  sDriverID
84982>>>>>>>>>>>        Local String  sVersion
84982>>>>>>>>>>>        Local String  sVoid
84982>>>>>>>>>>>        Local Integer iRetval
84982>>>>>>>>>>>
84982>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
84982>>>>>>>>>>>        // This error would otherwise be raised when we have an older
84982>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
84982>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
84983>>>>>>>>>>>        Get psDriverID To sDriverID
84984>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
84985>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
84990>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
84991>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
84993>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
84993>>>>>>>>>>>            Move "0.0.0" To sVersion
84994>>>>>>>>>>>        End
84994>>>>>>>>>>>>
84994>>>>>>>>>>>        Function_Return sVersion
84995>>>>>>>>>>>    End_Function //  PSQLRequesterVersion
84996>>>>>>>>>>>
84996>>>>>>>>>>>    //***
84996>>>>>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
84996>>>>>>>>>>>    //*** Purpose : Returns the version information of the
84996>>>>>>>>>>>    //***           Pervasive.SQL Local Engine
84996>>>>>>>>>>>
84996>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
84998>>>>>>>>>>>
84998>>>>>>>>>>>        Local String  sDriverID
84998>>>>>>>>>>>        Local String  sVersion
84998>>>>>>>>>>>        Local String  sVoid
84998>>>>>>>>>>>        Local Integer iRetval
84998>>>>>>>>>>>
84998>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
84998>>>>>>>>>>>        // This error would otherwise be raised when we have an older
84998>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
84998>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
84999>>>>>>>>>>>        Get psDriverID To sDriverID
85000>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
85001>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
85006>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
85007>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
85009>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
85009>>>>>>>>>>>            Move "0.0.0" To sVersion
85010>>>>>>>>>>>        End
85010>>>>>>>>>>>>
85010>>>>>>>>>>>        Function_Return sVersion
85011>>>>>>>>>>>    End_Function //  PSQLLocalEngineVersion
85012>>>>>>>>>>>
85012>>>>>>>>>>>    //***
85012>>>>>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
85012>>>>>>>>>>>    //*** Purpose : Returns the version information of the
85012>>>>>>>>>>>    //***           Pervasive.SQL Server Engine
85012>>>>>>>>>>>
85012>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
85014>>>>>>>>>>>
85014>>>>>>>>>>>        Local String  sDriverID
85014>>>>>>>>>>>        Local String  sVersion
85014>>>>>>>>>>>        Local String  sVoid
85014>>>>>>>>>>>        Local Integer iRetval
85014>>>>>>>>>>>
85014>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
85014>>>>>>>>>>>        // This error would otherwise be raised when we have an older
85014>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
85014>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
85015>>>>>>>>>>>        Get psDriverID To sDriverID
85016>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
85017>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
85022>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
85023>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
85025>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
85025>>>>>>>>>>>            Move "0.0.0" To sVersion
85026>>>>>>>>>>>        End
85026>>>>>>>>>>>>
85026>>>>>>>>>>>        Function_Return sVersion
85027>>>>>>>>>>>    End_Function //  PSQLServerEngineVersion
85028>>>>>>>>>>>
85028>>>>>>>>>>>End_Class // cDfbtrdrvHandler
85029>>>>>>>>>>>
85029>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
85029>>>>>>>>>Use cSQLConnectionIniFile.inc
85029>>>>>>>>>
85029>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
85030>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
85032>>>>>>>>>        Handle hoSQLManagerMT
85032>>>>>>>>>
85032>>>>>>>>>        // Error Reporting Related
85032>>>>>>>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
85032>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
85033>>>>>>>>>
85033>>>>>>>>>        Property String Private.psUseDatabase ""
85034>>>>>>>>>
85034>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
85035>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
85036>>>>>>>>>
85036>>>>>>>>>        Property Handle phoSQLManagerMT
85037>>>>>>>>>            Move (Create(Self,RefClass(cSQLHandleManagerDUF))) to hoSQLManagerMT
85038>>>>>>>>>            Set phoSQLManagerMT to hoSQLManagerMT
85039>>>>>>>>>
85039>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
85040>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
85041>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
85042>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
85043>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
85044>>>>>>>>>
85044>>>>>>>>>        Property Boolean pbHandleQueryErrors True
85045>>>>>>>>>
85045>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
85046>>>>>>>>>        Property String[] paSQLFetchResults
85047>>>>>>>>>
85047>>>>>>>>>        // Error handling
85047>>>>>>>>>        Property Boolean pbSqlError False
85048>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
85049>>>>>>>>>        Property Boolean pbProcessingError False
85050>>>>>>>>>
85050>>>>>>>>>        // Statistics on query
85050>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
85051>>>>>>>>>        Property TimeSpan ptsQueryExec
85052>>>>>>>>>        Property TimeSpan ptsFetchResults
85053>>>>>>>>>        Property Integer piColumns 0
85054>>>>>>>>>        Property Integer piRows 0
85055>>>>>>>>>        Property Integer piRowType 0
85056>>>>>>>>>        Property String[] paQueryMessages
85057>>>>>>>>>        Property String psSQLStatementString
85058>>>>>>>>>
85058>>>>>>>>>        Property Integer[] piTableConvertExceptions
85059>>>>>>>>>
85059>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
85059>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
85059>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
85059>>>>>>>>>        Property Integer piChunkMax 500
85060>>>>>>>>>        
85060>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
85060>>>>>>>>>        Send SetupSQLKeywordArray
85061>>>>>>>>>    End_Procedure
85062>>>>>>>>>
85062>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
85062>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
85064>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
85066>>>>>>>>>            Function_Return (EQ)
85067>>>>>>>>>        End
85067>>>>>>>>>>
85067>>>>>>>>>        Function_Return (NE)
85068>>>>>>>>>    End_Function
85069>>>>>>>>>
85069>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
85069>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
85071>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) Begin
85073>>>>>>>>>            Function_Return (LT)
85074>>>>>>>>>        End
85074>>>>>>>>>>
85074>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) Begin
85076>>>>>>>>>            Function_Return (GT)
85077>>>>>>>>>        End
85077>>>>>>>>>>
85077>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) Begin
85079>>>>>>>>>            Function_Return (LT)
85080>>>>>>>>>        End
85080>>>>>>>>>>
85080>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) Begin
85082>>>>>>>>>            Function_Return (GT)
85083>>>>>>>>>        End
85083>>>>>>>>>>
85083>>>>>>>>>
85083>>>>>>>>>        Function_Return (EQ)
85084>>>>>>>>>    End_Function
85085>>>>>>>>>
85085>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
85087>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
85087>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
85088>>>>>>>>>        Integer iSize
85088>>>>>>>>>
85088>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
85089>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
85090>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
85091>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
85092>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
85093>>>>>>>>>
85093>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
85094>>>>>>>>>    End_Procedure
85095>>>>>>>>>
85095>>>>>>>>>    // Creates a struct array with all SQL keywords
85095>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
85095>>>>>>>>>    // have slightly different wording.
85095>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
85095>>>>>>>>>    // needs to be done for every keyword group below.
85095>>>>>>>>>    Procedure SetupSQLKeywordArray
85097>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
85097>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
85099>>>>>>>>>
85099>>>>>>>>>        // This should only be called once; but in case it is
85099>>>>>>>>>        // we delete the array first.
85099>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
85100>>>>>>>>>
85100>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
85100>>>>>>>>>        //
85100>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
85101>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
85102>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
85103>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
85104>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
85105>>>>>>>>>
85105>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
85106>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
85107>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
85108>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
85109>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
85110>>>>>>>>>
85110>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
85111>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
85112>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
85113>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
85114>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
85115>>>>>>>>>
85115>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
85116>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
85117>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
85118>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
85119>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
85120>>>>>>>>>
85120>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
85121>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
85122>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
85123>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
85124>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
85125>>>>>>>>>
85125>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
85126>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
85127>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
85128>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
85129>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
85130>>>>>>>>>
85130>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
85131>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
85132>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
85133>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
85134>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
85135>>>>>>>>>
85135>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
85136>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
85137>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
85138>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
85139>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
85140>>>>>>>>>
85140>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
85141>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
85142>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
85143>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
85144>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
85145>>>>>>>>>
85145>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
85146>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
85147>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
85148>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
85149>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
85150>>>>>>>>>
85150>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_RENAME"
85151>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
85152>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
85153>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
85154>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
85155>>>>>>>>>
85155>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
85156>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
85157>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
85158>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
85159>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
85160>>>>>>>>>
85160>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
85161>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
85162>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
85163>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
85164>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
85165>>>>>>>>>
85165>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
85166>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
85167>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
85168>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
85169>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
85170>>>>>>>>>
85170>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
85171>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
85172>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
85173>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
85174>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
85175>>>>>>>>>
85175>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
85176>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
85177>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
85178>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
85179>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
85180>>>>>>>>>
85180>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
85181>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
85182>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
85183>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
85184>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
85185>>>>>>>>>
85185>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
85186>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
85187>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
85188>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
85189>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
85190>>>>>>>>>
85190>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
85191>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
85192>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
85193>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
85194>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
85195>>>>>>>>>
85195>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
85196>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
85197>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
85198>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
85199>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
85200>>>>>>>>>
85200>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
85201>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
85202>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
85203>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
85204>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
85205>>>>>>>>>
85205>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
85206>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
85207>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
85208>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
85209>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
85210>>>>>>>>>
85210>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
85211>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
85212>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
85213>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
85214>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
85215>>>>>>>>>
85215>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
85216>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
85217>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
85218>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
85219>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
85220>>>>>>>>>
85220>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
85221>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
85222>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
85223>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
85224>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
85225>>>>>>>>>
85225>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
85226>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
85227>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
85228>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
85229>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
85230>>>>>>>>>
85230>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
85231>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
85232>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
85233>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
85234>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
85235>>>>>>>>>
85235>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
85236>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
85237>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
85238>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
85239>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
85240>>>>>>>>>
85240>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
85241>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
85242>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
85243>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
85244>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
85245>>>>>>>>>
85245>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
85246>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
85247>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
85248>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
85249>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
85250>>>>>>>>>
85250>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
85251>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
85252>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
85253>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
85254>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
85255>>>>>>>>>
85255>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
85256>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
85257>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
85258>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
85259>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
85260>>>>>>>>>
85260>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
85261>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
85262>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
85263>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
85264>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
85265>>>>>>>>>
85265>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
85266>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
85267>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
85268>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
85269>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
85270>>>>>>>>>
85270>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
85271>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
85272>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
85273>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
85274>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
85275>>>>>>>>>
85275>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
85275>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
85276>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
85277>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
85278>>>>>>>>>
85278>>>>>>>>>    End_Procedure
85279>>>>>>>>>
85279>>>>>>>>>End_Class
85280>>>>>>>
85280>>>>>>>
85280>>>>>>>
85280>>>>>>>
85280>>>>>>>
85280>>>>>>>
85280>>>>>>>
85280>>>>>>>// SQLConnection.ini constants:
85280>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
85280>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
85280>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
85280>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
85280>>>>>>>Define CS_SQLIniSectionName             for "Connection"
85280>>>>>>>
85280>>>>>>>// DF 19 ini-file settings:
85280>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
85280>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
85280>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
85280>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
85280>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
85280>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
85280>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
85280>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
85280>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
85280>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection"
85280>>>>>>>
85280>>>>>>>// Database Update Framework extended settings:
85280>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
85280>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
85280>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
85280>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
85280>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
85280>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
85280>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
85280>>>>>>>
85280>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
85280>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
85280>>>>>>>Define CS_SQLIniConnectionNo            for "No"
85280>>>>>>>
85280>>>>>>>Struct tSQLConnection
85280>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
85280>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
85280>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
85280>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
85280>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
85280>>>>>>>    String sDatabase                // 6. SQL Database
85280>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
85280>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
85280>>>>>>>    String sUserID                  // 9. User ID
85280>>>>>>>    String sPassword                // 10. Password
85280>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
85280>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
85280>>>>>>>    String sLongTableSpace          // 13. DB2 specific
85280>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
85280>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
85280>>>>>>>    Boolean bError                  // 16. Set to true on error.    
85280>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
85280>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
85280>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
85280>>>>>>>End_Struct
85280>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
85280>>>>>>>Use cSQLConnectionIniFile.inc
85280>>>>>>>
85280>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
85281>>>>>>>    Procedure Construct_Object
85283>>>>>>>        Forward Send Construct_Object
85285>>>>>>>        Property String psDriverID DATAFLEX_ID
85286>>>>>>>    End_Procedure
85287>>>>>>>
85287>>>>>>>    Function ServerKeyword Returns String
85289>>>>>>>        Function_Return CS_SQLIniDSNKeyword
85290>>>>>>>    End_Function
85291>>>>>>>
85291>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85293>>>>>>>        String sConnect
85293>>>>>>>
85293>>>>>>>        Move (sConnect * ServerKeyword(Self) + "=" + sServer) to sConnect
85294>>>>>>>        If (sDatabase <> "") Begin
85296>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85297>>>>>>>        End
85297>>>>>>>>
85297>>>>>>>        If (bTrusted = True) Begin
85299>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85300>>>>>>>        End
85300>>>>>>>>
85300>>>>>>>        Else Begin
85301>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85302>>>>>>>        End
85302>>>>>>>>
85302>>>>>>>        Function_Return sConnect
85303>>>>>>>    End_Function
85304>>>>>>>
85304>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85306>>>>>>>        Boolean bLoginSuccessful
85306>>>>>>>        String sDriverID
85306>>>>>>>
85306>>>>>>>        Get psDriverID to sDriverID
85307>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
85309>>>>>>>            Function_Return True
85310>>>>>>>        End
85310>>>>>>>>
85310>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
85311>>>>>>>        If (bTrusted = False) Begin
85313>>>>>>>            Login sServer sUserId sPassword sDriverID
85315>>>>>>>        End
85315>>>>>>>>
85315>>>>>>>        Else Begin
85316>>>>>>>            Login sConnectionString "" "" sDriverID
85318>>>>>>>        End
85318>>>>>>>>
85318>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
85319>>>>>>>        Function_Return bLoginSuccessful
85320>>>>>>>    End_Function
85321>>>>>>>End_Class
85322>>>>>>>
85322>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
85323>>>>>>>    Function ServerKeyword Returns String
85325>>>>>>>        Function_Return CS_SQLIniServerKeyword
85326>>>>>>>    End_Function
85327>>>>>>>End_Class
85328>>>>>>>
85328>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
85329>>>>>>>End_Class
85330>>>>>>>
85330>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
85331>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85333>>>>>>>        Boolean bLoginSuccessful
85333>>>>>>>        String sDriverID
85333>>>>>>>
85333>>>>>>>        Move False to Err
85334>>>>>>>        Get psDriverID to sDriverID
85335>>>>>>>        If (not(Uppercase(sServer) contains "DSN")) Begin
85337>>>>>>>            Move ("DSN=" + sServer) to sServer
85338>>>>>>>        End
85338>>>>>>>>
85338>>>>>>>        Login sServer sUserId sPassword sDriverID
85340>>>>>>>
85340>>>>>>>        Move (not(Err)) to bLoginSuccessful
85341>>>>>>>        Function_Return bLoginSuccessful
85342>>>>>>>    End_Function
85343>>>>>>>End_Class
85344>>>>>>>
85344>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
85345>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85347>>>>>>>        Function_Return ""
85348>>>>>>>    End_Function
85349>>>>>>>End_Class
85350>>>>>>>
85350>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
85351>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85353>>>>>>>        Boolean bLoginSuccessful
85353>>>>>>>        String sDriverID
85353>>>>>>>
85353>>>>>>>        Get psDriverID to sDriverID
85354>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
85354>>>>>>>        Move False to Err
85355>>>>>>>        If (bTrusted = False) Begin
85357>>>>>>>            Login sServer sUserId sPassword sDriverID
85359>>>>>>>        End
85359>>>>>>>>
85359>>>>>>>        Else Begin
85360>>>>>>>            Login sServer "" "" sDriverID
85362>>>>>>>        End
85362>>>>>>>>
85362>>>>>>>        Move (not(Err)) to bLoginSuccessful
85363>>>>>>>
85363>>>>>>>        Function_Return bLoginSuccessful
85364>>>>>>>    End_Function
85365>>>>>>>End_Class
85366>>>>>>>
85366>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
85367>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85369>>>>>>>        Boolean bLoginSuccessful
85369>>>>>>>        String sDriverID sErrorMsg
85369>>>>>>>        String sVal
85369>>>>>>>        Integer iPos
85369>>>>>>>
85369>>>>>>>        Get psDriverID to sDriverID
85370>>>>>>>        Move (Pos("/", sServer)) to iPos
85371>>>>>>>        If (iPos = 0) Begin
85373>>>>>>>            If (sDatabase <> "") Begin
85375>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
85376>>>>>>>            End
85376>>>>>>>>
85376>>>>>>>        End
85376>>>>>>>>
85376>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
85376>>>>>>>        Move False to Err
85377>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
85377>>>>>>>        Login sServer sUserId sPassword sDriverID
85379>>>>>>>
85379>>>>>>>        Move (not(Err)) to bLoginSuccessful
85380>>>>>>>        Function_Return bLoginSuccessful
85381>>>>>>>    End_Function
85382>>>>>>>End_Class
85383>>>>>>>
85383>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
85384>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85386>>>>>>>        Boolean bLoginSuccessful
85386>>>>>>>        String sDriverID
85386>>>>>>>
85386>>>>>>>        Get psDriverID to sDriverID
85387>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
85387>>>>>>>        Move False to Err
85388>>>>>>>        If (bTrusted = False) Begin
85390>>>>>>>            Login sServer sUserId sPassword sDriverID
85392>>>>>>>        End
85392>>>>>>>>
85392>>>>>>>        Else Begin
85393>>>>>>>            Login sServer "" "" sDriverID
85395>>>>>>>        End
85395>>>>>>>>
85395>>>>>>>        Move (not(Err)) to bLoginSuccessful
85396>>>>>>>        Function_Return bLoginSuccessful
85397>>>>>>>    End_Function
85398>>>>>>>End_Class
85399>>>>>>>
85399>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
85400>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85402>>>>>>>        Boolean bLoginSuccessful
85402>>>>>>>        String sDriverID
85402>>>>>>>
85402>>>>>>>        Get psDriverID to sDriverID
85403>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
85403>>>>>>>        Move False to Err
85404>>>>>>>        If (bTrusted = False) Begin
85406>>>>>>>            Login sServer sUserId sPassword sDriverID
85408>>>>>>>        End
85408>>>>>>>>
85408>>>>>>>        Else Begin
85409>>>>>>>            Login sServer "" "" sDriverID
85411>>>>>>>        End
85411>>>>>>>>
85411>>>>>>>        Move (not(Err)) to bLoginSuccessful
85412>>>>>>>        Function_Return bLoginSuccessful
85413>>>>>>>    End_Function
85414>>>>>>>End_Class
85415>>>>>>>
85415>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
85416>>>>>>>    Procedure Construct_Object
85418>>>>>>>        Forward Send Construct_Object
85420>>>>>>>        Property String psDriverID DATAFLEX_ID
85421>>>>>>>        Property Handle phoDriverSpecificObject
85422>>>>>>>    End_Procedure
85423>>>>>>>
85423>>>>>>>    Function CreateDriver Returns Handle
85425>>>>>>>        String sDriverID
85425>>>>>>>        Handle hoDriver hcDriverClass
85425>>>>>>>
85425>>>>>>>        Get psDriverID to sDriverID
85426>>>>>>>        Case Begin
85426>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85428>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
85429>>>>>>>                Case Break
85430>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85433>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
85434>>>>>>>                Case Break
85435>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85438>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
85439>>>>>>>                Case Break
85440>>>>>>>            Case (sDriverID = SQLFLEX)
85443>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
85444>>>>>>>                Case Break
85445>>>>>>>            Case (sDriverID = ORAFLEX)
85448>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
85449>>>>>>>                Case Break
85450>>>>>>>            Case (sDriverID = MDSPgSQL)
85453>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
85454>>>>>>>                Case Break
85455>>>>>>>            Case (sDriverID = MDSMySQL)
85458>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
85459>>>>>>>                Case Break
85460>>>>>>>            // DATAFLEX_ID = Default driver
85460>>>>>>>            Case Else  
85460>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
85461>>>>>>>                Move DATAFLEX_ID to sDriverID
85462>>>>>>>        Case End
85462>>>>>>>
85462>>>>>>>        Get Create hcDriverClass to hoDriver
85463>>>>>>>        Set psDriverID of hoDriver to sDriverID
85464>>>>>>>        Set phoDriverSpecificObject to hoDriver
85465>>>>>>>
85465>>>>>>>        Function_Return hoDriver
85466>>>>>>>    End_Procedure
85467>>>>>>>
85467>>>>>>>    Procedure DestroyDriver
85469>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
85471>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
85472>>>>>>>        End
85472>>>>>>>>
85472>>>>>>>    End_Procedure
85473>>>>>>>
85473>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85475>>>>>>>        String sConnect
85475>>>>>>>        Handle hoDriver
85475>>>>>>>
85475>>>>>>>        Get CreateDriver to hoDriver
85476>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
85477>>>>>>>        Send DestroyDriver
85478>>>>>>>        Function_Return sConnect
85479>>>>>>>    End_Function
85480>>>>>>>
85480>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85482>>>>>>>        Boolean bLoginSuccessful
85482>>>>>>>        Handle hoDriver
85482>>>>>>>
85482>>>>>>>        Get CreateDriver to hoDriver
85483>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
85484>>>>>>>        Send DestroyDriver
85485>>>>>>>        Function_Return bLoginSuccessful
85486>>>>>>>    End_Function
85487>>>>>>>
85487>>>>>>>End_Class
85488>>>>>
85488>>>>>Class cSQLConnectionIniFile is a cIniFile
85489>>>>>    Procedure Construct_Object
85491>>>>>        Forward Send Construct_Object
85493>>>>>
85493>>>>>        Property String Private_psIniFilePath
85494>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
85495>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
85496>>>>>
85496>>>>>//        { Visibility=Private }
85496>>>>>        Property Boolean pbDFConnId False
85497>>>>>
85497>>>>>        // We use Base64 coding instead of the cCryptographer class because the
85497>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
85497>>>>>//        { Visibility=Public }
85497>>>>>//        // *** You really want to change this value! ***
85497>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
85497>>>>>
85497>>>>>    End_Procedure
85498>>>>>
85498>>>>>    Procedure End_Construct_Object
85500>>>>>        Forward Send End_Construct_Object
85502>>>>>    End_Procedure
85503>>>>>
85503>>>>>    Procedure Set psIniFilePath String sPath
85505>>>>>        String sIniFile
85505>>>>>        Get vFolderFormat sPath to sPath
85506>>>>>        Set private_psIniFilePath to sPath
85507>>>>>        Get psIniFileName to sIniFile
85508>>>>>        Set psFileName to (sPath + sIniFile)
85509>>>>>    End_Procedure
85510>>>>>
85510>>>>>    Function psIniFilePath Returns String
85512>>>>>        Function_Return (private_psIniFilePath(Self))
85513>>>>>    End_Function
85514>>>>>
85514>>>>>    Procedure Set psIniFileName String sFileName
85516>>>>>        String sPath
85516>>>>>        Get psIniFilePath to sPath
85517>>>>>        Set psFileName to (sPath + sFileName)
85518>>>>>        Set private_psIniFileName to sFileName
85519>>>>>    End_Procedure
85520>>>>>
85520>>>>>    Function psIniFileName Returns String
85522>>>>>        Function_Return (private_psIniFileName(Self))
85523>>>>>    End_Function
85524>>>>>
85524>>>>>    // *** Generalized messages to Get & Set values of the ini file.
85524>>>>>    // Sets a value in the program's ini file (write)
85524>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
85524>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
85526>>>>>        String sIniFile sPath
85526>>>>>
85526>>>>>        Get psIniFilePath to sPath
85527>>>>>        Get psIniFileName to sIniFile
85528>>>>>        Move (sPath + sIniFile) to sIniFile
85529>>>>>        Set psFileName to sIniFile
85530>>>>>        Send WriteString sSection sValueName sValue
85531>>>>>    End_Procedure
85532>>>>>
85532>>>>>    // Get a value from program's ini-file (read)
85532>>>>>    // Pass a section name and the name of the value parameter & a default value.
85532>>>>>    // Returns the value
85532>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
85534>>>>>        String sValue sIniFile sPath
85534>>>>>
85534>>>>>        Get psIniFilePath to sPath
85535>>>>>        Get psIniFileName to sIniFile
85536>>>>>        Move (sPath + sIniFile) to sIniFile
85537>>>>>        Set psFileName to sIniFile
85538>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
85539>>>>>
85539>>>>>        Function_Return sValue
85540>>>>>    End_Function
85541>>>>>
85541>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
85541>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
85543>>>>>        Integer iCheckboxCol
85543>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) Begin
85545>>>>>            Function_Return (LT)
85546>>>>>        End
85546>>>>>>
85546>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) Begin
85548>>>>>            Function_Return (GT)
85549>>>>>        End
85549>>>>>>
85549>>>>>
85549>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) Begin
85551>>>>>            Function_Return (LT)
85552>>>>>        End
85552>>>>>>
85552>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) Begin
85554>>>>>            Function_Return (GT)
85555>>>>>        End
85555>>>>>>
85555>>>>>
85555>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) Begin
85557>>>>>            Function_Return (LT)
85558>>>>>        End
85558>>>>>>
85558>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) Begin
85560>>>>>            Function_Return (GT)
85561>>>>>        End
85561>>>>>>
85561>>>>>
85561>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) Begin
85563>>>>>            Function_Return (LT)
85564>>>>>        End
85564>>>>>>
85564>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) Begin
85566>>>>>            Function_Return (GT)
85567>>>>>        End
85567>>>>>>
85567>>>>>
85567>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) Begin
85569>>>>>            Function_Return (LT)
85570>>>>>        End
85570>>>>>>
85570>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) Begin
85572>>>>>            Function_Return (GT)
85573>>>>>        End
85573>>>>>>
85573>>>>>
85573>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) Begin
85575>>>>>            Function_Return (LT)
85576>>>>>        End
85576>>>>>>
85576>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) Begin
85578>>>>>            Function_Return (GT)
85579>>>>>        End
85579>>>>>>
85579>>>>>
85579>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) Begin
85581>>>>>            Function_Return (LT)
85582>>>>>        End
85582>>>>>>
85582>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) Begin
85584>>>>>            Function_Return (GT)
85585>>>>>        End
85585>>>>>>
85585>>>>>
85585>>>>>        Function_Return (EQ)
85586>>>>>    End_Function
85587>>>>>
85587>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
85589>>>>>        Handle hoSections
85589>>>>>        Integer iItems
85589>>>>>
85589>>>>>        Send ReadSections hoSections
85590>>>>>        Move (Item_Count(hoSections)) to iItems
85591>>>>>        Function_Return iItems
85592>>>>>    End_Function
85593>>>>>
85593>>>>>    // The normal connection string looks something like this;
85593>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
85593>>>>>    // ...but the full connection string looks like this;
85593>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
85593>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
85593>>>>>//        String sSection
85593>>>>>//        Integer iCount
85593>>>>>//
85593>>>>>//        Move False to Err
85593>>>>>//        Get psIniSectionName to sSection
85593>>>>>//        Get SQLIniFileNumberOfConnections to iCount
85593>>>>>//        Increment iCount
85593>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
85593>>>>>//
85593>>>>>//        Function_Return (Err = False)
85593>>>>>//    End_Function
85593>>>>>
85593>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
85595>>>>>        Integer iCount
85595>>>>>        Boolean bExists
85595>>>>>        String sSection
85595>>>>>
85595>>>>>        Move False to Err
85596>>>>>        Move 1 to iCount
85597>>>>>        Get psIniSectionName to sSection
85598>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85599>>>>>        While (bExists = True)
85603>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
85604>>>>>            Increment iCount
85605>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85606>>>>>        Loop
85607>>>>>>
85607>>>>>        Function_Return (Err = False)
85608>>>>>    End_Function
85609>>>>>
85609>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
85611>>>>>        Integer iCount
85611>>>>>        String sSection
85611>>>>>        Boolean bExists
85611>>>>>
85611>>>>>        Move False to Err
85612>>>>>        Move 1 to iCount
85613>>>>>        Get psIniSectionName to sSection
85614>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
85615>>>>>        While (bExists = True)
85619>>>>>            If (iCount = iItem) Begin
85621>>>>>                Send DeleteSection sSection
85622>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
85622>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
85623>>>>>            End
85623>>>>>>
85623>>>>>            Increment iCount
85624>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
85625>>>>>        Loop
85626>>>>>>
85626>>>>>
85626>>>>>        Function_Return (Err = False)
85627>>>>>    End_Function
85628>>>>>
85628>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
85628>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
85628>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
85630>>>>>        tSQLConnection[] SQLConnectionsArray
85630>>>>>        tSQLConnection[] SQLConnectionsArray
85631>>>>>        tSQLConnection   SQLConnection
85631>>>>>        tSQLConnection   SQLConnection
85631>>>>>        Integer iIndex
85631>>>>>
85631>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
85632>>>>>        If (iIndex = -1) Begin
85634>>>>>            Move True to SQLConnection.bError
85635>>>>>            Function_Return SQLConnection
85636>>>>>        End
85636>>>>>>
85636>>>>>
85636>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85637>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
85638>>>>>
85638>>>>>        Function_Return SQLConnection
85639>>>>>    End_Function
85640>>>>>
85640>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
85640>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
85642>>>>>        tSQLConnection[] SQLConnectionsArray
85642>>>>>        tSQLConnection[] SQLConnectionsArray
85643>>>>>        Integer iRetval iCount iSize
85643>>>>>        String sValue
85643>>>>>        Boolean bExists
85643>>>>>
85643>>>>>        Move -1 to iRetval
85644>>>>>
85644>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85645>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85646>>>>>        Decrement iSize
85647>>>>>        For iCount from 0 to iSize
85653>>>>>>
85653>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
85654>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
85655>>>>>            If (bExists) Begin
85657>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
85658>>>>>                Move iSize to iCount         // We're done!
85659>>>>>            End
85659>>>>>>
85659>>>>>        Loop
85660>>>>>>
85660>>>>>
85660>>>>>        Function_Return iRetval
85661>>>>>    End_Function
85662>>>>>
85662>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
85662>>>>>    // Used to check that ConnectionID's are unique.
85662>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
85664>>>>>        Integer iCount iSize iItems
85664>>>>>        String sValue
85664>>>>>        Boolean bExists
85664>>>>>        tSQLConnection[] SQLConnectionsArray
85664>>>>>        tSQLConnection[] SQLConnectionsArray
85665>>>>>
85665>>>>>        Move 0 to iItems
85666>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85667>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85668>>>>>        Decrement iSize
85669>>>>>        For iCount from 0 to iSize
85675>>>>>>
85675>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
85676>>>>>            Move (sValue = sConnectionID) to bExists
85677>>>>>            If (bExists) Begin
85679>>>>>                Increment iItems
85680>>>>>            End
85680>>>>>>
85680>>>>>        Loop
85681>>>>>>
85681>>>>>
85681>>>>>        Function_Return (iItems > 1)
85682>>>>>    End_Function
85683>>>>>
85683>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
85683>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
85685>>>>>        Boolean bRetval bOK
85685>>>>>        Integer iItem iSize iCount
85685>>>>>        tSQLConnection[] SQLConnectionsArray
85685>>>>>        tSQLConnection[] SQLConnectionsArray
85686>>>>>        tSQLConnection SQLConnection
85686>>>>>        tSQLConnection SQLConnection
85686>>>>>        String sConnectionString
85686>>>>>
85686>>>>>        Move False to Err
85687>>>>>        Get psConnectionString to sConnectionString
85688>>>>>
85688>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85689>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85690>>>>>        Decrement iSize
85691>>>>>        // Set all current connection to inactive.
85691>>>>>        For iCount from 0 to iSize
85697>>>>>>
85697>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
85698>>>>>        Loop
85699>>>>>>
85699>>>>>
85699>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
85700>>>>>        Move True              to SQLConnection.bEnabled
85701>>>>>        Move sConnectionString to SQLConnection.sConnectionString
85702>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
85703>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
85704>>>>>
85704>>>>>        Function_Return (bOK = True)
85705>>>>>    End_Function
85706>>>>>
85706>>>>>    // Used for updating an existing connection with new data.
85706>>>>>    // Returns True if successful.
85706>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
85708>>>>>        Boolean bRetval bOK
85708>>>>>        Integer iItem iSize iCount
85708>>>>>        tSQLConnection[] SQLConnectionsArray
85708>>>>>        tSQLConnection[] SQLConnectionsArray
85709>>>>>
85709>>>>>        Move False to Err
85710>>>>>        Move -1 to iItem
85711>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85712>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85713>>>>>        Decrement iSize
85714>>>>>        // Set all current connection to inactive.
85714>>>>>        For iCount from 0 to iSize
85720>>>>>>
85720>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
85721>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
85723>>>>>                Move iCount to iItem
85724>>>>>            End
85724>>>>>>
85724>>>>>        Loop
85725>>>>>>
85725>>>>>
85725>>>>>        If (iItem <> -1) Begin
85727>>>>>            Move True to SQLConnection.bEnabled
85728>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
85729>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
85730>>>>>        End
85730>>>>>>
85730>>>>>
85730>>>>>        Function_Return (bOK = True)
85731>>>>>    End_Function
85732>>>>>
85732>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
85734>>>>>        tSQLConnection[] SQLConnectionsArray
85734>>>>>        tSQLConnection[] SQLConnectionsArray
85735>>>>>        String sSection sValue
85735>>>>>        Integer iCount
85735>>>>>        Boolean bExists bEnabled
85735>>>>>
85735>>>>>        Get psIniSectionName to sSection
85736>>>>>        Get SectionExists sSection to bExists
85737>>>>>        If (bExists = False) Begin
85739>>>>>            Function_Return SQLConnectionsArray
85740>>>>>        End
85740>>>>>>
85740>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
85741>>>>>        If (bExists = True) Begin
85743>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
85744>>>>>>
85744>>>>>        End
85744>>>>>>
85744>>>>>
85744>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
85745>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85746>>>>>
85746>>>>>        While (bExists = True)
85750>>>>>            // We always put the enabled/active connection at the top
85750>>>>>            Move (iCount = 1) to bEnabled
85751>>>>>            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
85752>>>>>
85752>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
85753>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
85754>>>>>
85754>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
85754>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
85755>>>>>            If (sValue = "99") Begin
85757>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
85758>>>>>            End
85758>>>>>>
85758>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
85759>>>>>
85759>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
85760>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
85761>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
85763>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
85764>>>>>            End
85764>>>>>>
85764>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
85765>>>>>
85765>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
85766>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
85767>>>>>
85767>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
85768>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
85769>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
85771>>>>>                Get DecryptPassword sValue to sValue
85772>>>>>            End
85772>>>>>>
85772>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
85773>>>>>
85773>>>>>            // Here we reconstruct the connection string to be complete with all params;
85773>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
85774>>>>>
85774>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
85775>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
85776>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
85777>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
85778>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to SQLConnectionsArray[iCount].bSilentLogin
85779>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
85779>>>>>
85779>>>>>            Increment iCount
85780>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85781>>>>>        Loop
85782>>>>>>
85782>>>>>
85782>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
85782>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
85784>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
85785>>>>>        End
85785>>>>>>
85785>>>>>
85785>>>>>        Function_Return SQLConnectionsArray
85786>>>>>    End_Function
85787>>>>>
85787>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
85789>>>>>        Integer iCount iSize iItem
85789>>>>>        Boolean bIsOneActive bEnabled bExists bOK
85789>>>>>        String sConnectionString sSection sValue
85789>>>>>
85789>>>>>        // First we need to _remove_ all current connections in the ini-file, we
85789>>>>>        // do that by setting their values to "".
85789>>>>>        Move 0 to iCount
85790>>>>>        Get SQLIniFileDeleteAllConnections to bOK
85791>>>>>        If (bOK = False) Begin
85793>>>>>            Function_Return False
85794>>>>>        End
85794>>>>>>
85794>>>>>
85794>>>>>        Move False to Err
85795>>>>>        Get psIniSectionName to sSection
85796>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
85796>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
85797>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85798>>>>>        Decrement iSize
85799>>>>>
85799>>>>>        For iCount from 0 to iSize
85805>>>>>>
85805>>>>>            // DF 19 compatible settings:
85805>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
85806>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
85807>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
85808>>>>>
85808>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
85809>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
85811>>>>>                Get EncryptPassword sValue to sValue
85812>>>>>            End
85812>>>>>>
85812>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
85813>>>>>
85813>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
85815>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
85816>>>>>            End
85816>>>>>>
85816>>>>>
85816>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
85817>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
85818>>>>>
85818>>>>>            // The Database Update Framework extended settings:
85818>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
85819>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
85820>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
85821>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
85822>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
85823>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to SQLConnectionsArray[iCount].bSilentLogin
85824>>>>>        Loop
85825>>>>>>
85825>>>>>
85825>>>>>        Function_Return (bOK and Err = False)
85826>>>>>    End_Function
85827>>>>>
85827>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85827>>>>>    //
85827>>>>>    // SQL utility function that returns a database type (string) constant
85827>>>>>    // corresponding to the passed iDbType.
85827>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85829>>>>>        String sRetval
85829>>>>>        If (iDbType = EN_dbTypeMSSQL)       Move CS_dbTypeMSSQL     to sRetval
85832>>>>>        If (iDbType = EN_dbTypeMySQL)       Move CS_dbTypeMySQL     to sRetval
85835>>>>>        If (iDbType = EN_dbTypeOracle)      Move CS_dbTypeOracle    to sRetval
85838>>>>>        If (iDbType = EN_dbTypeDB2)         Move CS_dbTypeDB2       to sRetval
85841>>>>>        If (iDbType = EN_dbTypePostgre)     Move CS_dbTypePostgre   to sRetval
85844>>>>>        Function_Return sRetval
85845>>>>>    End_Function
85846>>>>>
85846>>>>>    // SQL utility function that returns a database type constant (integer)
85846>>>>>    // corresponding to the passed sDbType string constant.
85846>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
85848>>>>>        Integer iRetval
85848>>>>>        If (sDbType = CS_dbTypeMSSQL)       Move EN_dbTypeMSSQL     to iRetval
85851>>>>>        If (sDbType = CS_dbTypeMySQL)       Move EN_dbTypeMySQL     to iRetval
85854>>>>>        If (sDbType = CS_dbTypeOracle)      Move EN_dbTypeOracle    to iRetval
85857>>>>>        If (sDbType = CS_dbTypeDB2)         Move EN_dbTypeDB2       to iRetval
85860>>>>>        If (sDbType = CS_dbTypePostgre)     Move EN_dbTypePostgre   to iRetval
85863>>>>>        Function_Return iRetval
85864>>>>>    End_Function
85865>>>>>
85865>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85865>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
85865>>>>>    // the SQL Connection program's grid.
85865>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85867>>>>>        String sRetval
85867>>>>>        If (iDbType = EN_dbTypeMSSQL)       Move "EN_dbTypeMSSQL"   to sRetval
85870>>>>>        If (iDbType = EN_dbTypeMySQL)       Move "EN_dbTypeMySQL"   to sRetval
85873>>>>>        If (iDbType = EN_dbTypeOracle)      Move "EN_dbTypeOracle"  to sRetval
85876>>>>>        If (iDbType = EN_dbTypeDB2)         Move "EN_dbTypeDB2"     to sRetval
85879>>>>>        If (iDbType = EN_dbTypePostgre)     Move "EN_dbTypePostgre" to sRetval
85882>>>>>        Function_Return sRetval
85883>>>>>    End_Function
85884>>>>>
85884>>>>>    // Pass a driver id and the function will return
85884>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85884>>>>>    // quite work and always returns "MS SQL Server"
85884>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85886>>>>>        Integer iRetval
85886>>>>>        If (sDriverID = MSSQLDRV_ID)  Move EN_dbTypeMSSQL     to iRetval
85889>>>>>        If (sDriverID = SQLFLEX)      Move EN_dbTypeMSSQL     to iRetval
85892>>>>>        If (sDriverID = ODBC_DRV_ID)  Move EN_dbTypeMSSQL     to iRetval
85895>>>>>        If (sDriverID = MDSMySQL)     Move EN_dbTypeMySQL     to iRetval
85898>>>>>        If (sDriverID = ORAFLEX)      Move EN_dbTypeOracle    to iRetval
85901>>>>>        If (sDriverID = DB2_DRV_ID)   Move EN_dbTypeDB2       to iRetval
85904>>>>>        If (sDriverID = MDSPgSQL)     Move EN_dbTypePostgre   to iRetval
85907>>>>>        Function_Return iRetval
85908>>>>>    End_Function
85909>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
85909>>>>>>
85909>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
85911>>>>>>    Integer iStart iEnd
85911>>>>>>    String sRetval
85911>>>>>>
85911>>>>>>    Move (Trim(sConnect)) to sConnect
85912>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
85913>>>>>>    If (iStart = 0) Begin
85915>>>>>>        Function_Return ""
85916>>>>>>    End
85916>>>>>>>
85916>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
85917>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
85918>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
85920>>>>>>        Move (Pos(",", sRetval))          to iEnd
85921>>>>>>    End
85921>>>>>>>
85921>>>>>>    Else Begin
85922>>>>>>        Move (Pos(";", sRetval))          to iEnd
85923>>>>>>    End
85923>>>>>>>
85923>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
85925>>>>>>        Move (Pos(",", sRetval))          to iEnd
85926>>>>>>        Decrement iEnd
85927>>>>>>    End
85927>>>>>>>
85927>>>>>>    If (iEnd <> 0) Begin
85929>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
85930>>>>>>    End
85930>>>>>>>
85930>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
85931>>>>>>
85931>>>>>>    Function_Return (Trim(sRetval))
85932>>>>>>End_Function
85933>>>>>>
85933>>>>>>
85933>>>>>
85933>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85935>>>>>        String sConnect
85935>>>>>        Handle hoDriver
85935>>>>>
85935>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
85936>>>>>        Set psDriverID of hoDriver to sDriverID
85937>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
85938>>>>>        Send Destroy   of hoDriver
85939>>>>>
85939>>>>>//        Case Begin
85939>>>>>//            Case (sDriverID = MSSQLDRV_ID)
85939>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
85939>>>>>//                If (sDatabase <> "") Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85939>>>>>//                End
85939>>>>>//                If (bTrusted = True) Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85939>>>>>//                End
85939>>>>>//                Else Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85939>>>>>//                End
85939>>>>>//                Case Break
85939>>>>>//
85939>>>>>//            Case (sDriverID = ODBC_DRV_ID)
85939>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85939>>>>>//                If (sDatabase <> "") Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85939>>>>>//                End
85939>>>>>//                If (bTrusted = True) Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85939>>>>>//                End
85939>>>>>//                Else Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85939>>>>>//                End
85939>>>>>//                Case Break
85939>>>>>//
85939>>>>>//            Case (sDriverID = DB2_DRV_ID)
85939>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85939>>>>>////                If (sDatabase <> "") Begin
85939>>>>>////                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85939>>>>>////                End
85939>>>>>////                If (bTrusted = True) Begin
85939>>>>>////                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85939>>>>>////                End
85939>>>>>////                Else Begin
85939>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85939>>>>>////                End
85939>>>>>//                Case Break
85939>>>>>//
85939>>>>>//            Case (sDriverID = SQLFLEX)
85939>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
85939>>>>>//                If (sDatabase <> "") Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85939>>>>>//                End
85939>>>>>//                If (bTrusted = True) Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
85939>>>>>//                End
85939>>>>>//                Else Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85939>>>>>//                End
85939>>>>>//                Case Break
85939>>>>>//
85939>>>>>//            Case (sDriverID = ORAFLEX)
85939>>>>>//                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
85939>>>>>//                    Move (sServer + "/" + sDatabase)                  to sServer
85939>>>>>//                End
85939>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85939>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85939>>>>>//                Case Break
85939>>>>>//
85939>>>>>//            Case (sDriverID = MDSPgSQL)
85939>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85939>>>>>//                If (sDatabase <> "") Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85939>>>>>//                End
85939>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85939>>>>>//                Case Break
85939>>>>>//
85939>>>>>//            Case (sDriverID = MDSMySQL)
85939>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85939>>>>>//                If (sDatabase <> "") Begin
85939>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85939>>>>>//                End
85939>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
85939>>>>>//                Case Break
85939>>>>>//
85939>>>>>//            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
85939>>>>>//                Break
85939>>>>>//
85939>>>>>//            Case Else
85939>>>>>//                Move "" to sConnect
85939>>>>>//        Case End
85939>>>>>
85939>>>>>        Function_Return sConnect
85940>>>>>    End_Function
85941>>>>>
85941>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
85941>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
85943>>>>>        String sConnect
85943>>>>>
85943>>>>>        Case Begin
85943>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
85945>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
85946>>>>>                If (sDatabase <> "") Begin
85948>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85949>>>>>                End
85949>>>>>>
85949>>>>>                Case Break
85950>>>>>
85950>>>>>            Case (sDriverID = ODBC_DRV_ID)
85953>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85954>>>>>                If (sDatabase <> "") Begin
85956>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85957>>>>>                End
85957>>>>>>
85957>>>>>                Case Break
85958>>>>>
85958>>>>>            Case (sDriverID = DB2_DRV_ID)
85961>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85962>>>>>                If (sDatabase <> "") Begin
85964>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85965>>>>>                End
85965>>>>>>
85965>>>>>                Case Break
85966>>>>>
85966>>>>>            Case (sDriverID = ORAFLEX)
85969>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85970>>>>>                If (sDatabase <> "") Begin
85972>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85973>>>>>                End
85973>>>>>>
85973>>>>>                Case Break
85974>>>>>
85974>>>>>            Case (sDriverID = MDSPgSQL)
85977>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85978>>>>>                If (sDatabase <> "") Begin
85980>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85981>>>>>                End
85981>>>>>>
85981>>>>>                Case Break
85982>>>>>
85982>>>>>            Case (sDriverID = MDSMySQL)
85985>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85986>>>>>                If (sDatabase <> "") Begin
85988>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85989>>>>>                End
85989>>>>>>
85989>>>>>                Case Break
85990>>>>>
85990>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
85993>>>>>                Break
85994>>>>>
85994>>>>>            Case Else
85994>>>>>                Move "" to sConnect
85995>>>>>        Case End
85995>>>>>
85995>>>>>        Function_Return sConnect
85996>>>>>    End_Function
85997>>>>>
85997>>>>>    // Use Base64
85997>>>>>    Function EncryptPassword String sPassword Returns String
85999>>>>>        String sRetval sHashString
85999>>>>>//        Handle hoCryptographer
85999>>>>>//
85999>>>>>//        Get psHashString to sHashString
85999>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
85999>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
85999>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
85999>>>>>//
85999>>>>>//        Send Destroy of hoCryptographer
85999>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
86000>>>>>        Function_Return sRetval
86001>>>>>    End_Function
86002>>>>>
86002>>>>>    Function DecryptPassword String sPassword Returns String
86004>>>>>        String sRetval sHashString
86004>>>>>//        Handle hoCryptographer
86004>>>>>//
86004>>>>>//        Get psHashString to sHashString
86004>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
86004>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
86004>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
86004>>>>>//
86004>>>>>//        Send Destroy of hoCryptographer
86004>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
86005>>>>>
86005>>>>>        Function_Return sRetval
86006>>>>>    End_Function
86007>>>>>
86007>>>>>    // Returns the full path of the Application (no trailing "\")
86007>>>>>    Function ApplicationPath Returns String
86009>>>>>        String sApplicationFileName sPath
86009>>>>>        Integer iNumChars iRetval
86009>>>>>
86009>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
86010>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
86011>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
86012>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
86013>>>>>        Move (CString(sApplicationFileName)) to sPath
86014>>>>>
86014>>>>>        Function_Return sPath
86015>>>>>    End_Function
86016>>>>>
86016>>>>>End_Class
86017>>>Use cDbUpdateDatabaseDriver.pkg
86017>>>
86017>>>// The cConnection class is the new SQL connections class for DF 19.
86017>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
86017>>>
86017>>>// We're making references to this object handle so we need it defined
86017>>>// here as well as for the cDbUpdateHandler class
86017>>>
86017>>>    Global_Variable Handle ghoSQLConnectionHandler
86017>>>
86017>>>Class cSQLConnectionHandler is a cObject
86018>>>
86018>>>    Procedure Construct_Object
86020>>>        Forward Send Construct_Object
86022>>>        Move Self to ghoSQLConnectionHandler
86023>>>
86023>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
86024>>>
86024>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
86024>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
86024>>>        // methods to this class.
86024>>>        Property Boolean pbUseConnectionID True
86025>>>        Property Boolean pbToANSI          True
86026>>>        Property Boolean pbRecnum          True
86027>>>        Property Boolean pbCopyData        True
86028>>>        Property Boolean pbCompareDate_DateTime  False
86029>>>        Property Boolean pbCompareIndexAscending False
86030>>>        Property Boolean pbCompareIndexUppercase False
86031>>>
86031>>>        // Driver default value settings:
86031>>>        // Note: When the object is created the corresponding values
86031>>>        // from the driver .int files are read.
86031>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
86031>>>        Property String psDriverDefaultValueASCII    ""
86032>>>        Property String psDriverDefaultValueBinary   ""
86033>>>        Property String psDriverDefaultValueDate     ""
86034>>>        Property String psDriverDefaultValueDateTime ""
86035>>>        Property String psDriverDefaultValueNumeric  ""
86036>>>        Property String psDriverDefaultValueText     ""
86037>>>
86037>>>        // Driver "nullability" settings:
86037>>>        // Note: When the object is created the corresponding values
86037>>>        // from the driver .int files are read.
86037>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
86037>>>        Property Boolean pbDriverDefaultNullableASCII    False
86038>>>        Property Boolean pbDriverDefaultNullableBinary   False
86039>>>        Property Boolean pbDriverDefaultNullableDate     False
86040>>>        Property Boolean pbDriverDefaultNullableDateTime False
86041>>>        Property Boolean pbDriverDefaultNullableNumeric  False
86042>>>        Property Boolean pbDriverDefaultNullableText     False
86043>>>
86043>>>        // *** This is the central point of connection data for the Database Update Framework ***
86043>>>        //     It is private because the get/set version also updates the DAW/Mertech
86043>>>        //     driver interfaces.
86043>>>        //     There are also procedure/function pairs to set/get individual data members
86043>>>        //     of the struct they are all routed throu this struct property.
86043>>>        Property tSQLConnection Private.pSQLConnection
86044>>>
86044>>>    End_Procedure
86045>>>
86045>>>    Procedure End_Construct_Object
86047>>>        Boolean bReadSettings
86047>>>        tSQLConnection SQLConnection
86047>>>        tSQLConnection SQLConnection
86047>>>
86047>>>        Forward Send End_Construct_Object
86049>>>
86049>>>        // Now is the time to read and apply SQL connection settings.
86049>>>        Get SetupSQLConnection True to SQLConnection
86050>>>        Set Private.pSQLConnection to SQLConnection
86051>>>    End_Procedure
86052>>>
86052>>>    // *** Properties ***
86052>>>    // All connection related "properties" (get/set pairs) are really done by changing the
86052>>>    // private.pSQLConnection struct connection property. These "properties" are
86052>>>    // merely here for conveniance.
86052>>>    //
86052>>>    // The pSQLConnection get/set are here so we have a "central hub"
86052>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
86052>>>    // This struct property contains all the connection data.
86052>>>    //
86052>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
86054>>>        Boolean bIsDaw bIsMertech bOK
86054>>>
86054>>>        Set Private.pSQLConnection to SQLConnection
86055>>>
86055>>>        // When starting a program we might not have a connection id yet:
86055>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
86057>>>            Procedure_Return
86058>>>        End
86058>>>>
86058>>>        
86058>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
86058>>>        // be logged in already and don't want to do it again.
86058>>>        If (SQLConnection.bDAWConnection = False) Begin
86060>>>            // After we have set the class property we need to tell the DAW/Mertech
86060>>>            // driver interfaces about the change & make a new login.
86060>>>            Get SQLLogin SQLConnection to bOK
86061>>>            If (bOK = False) Begin
86063>>>                Error DFERR_PROGRAM "Login error."
86064>>>>
86064>>>            End
86064>>>>
86064>>>        End
86064>>>>
86064>>>
86064>>>        // Now is the time to setup our driver default values by reading the driver .int file:
86064>>>        Send SetupDriverDefaults SQLConnection.sDriverID
86065>>>
86065>>>    End_Procedure
86066>>>
86066>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
86066>>>    // attempt to load the driver.
86066>>>    // Returns true if the passed driver is SQL based.
86066>>>    Function IsSQLDriver String sDriverID Returns Boolean
86068>>>        Boolean bOK
86068>>>        Integer iDriver
86068>>>
86068>>>        Get IsDAWSQLDriver sDriverID to bOK
86069>>>
86069>>>        If (bOK = False) Begin
86071>>>            Get IsMertechDriver sDriverID to bOK
86072>>>        End
86072>>>>
86072>>>
86072>>>        Function_Return bOK
86073>>>    End_Function
86074>>>
86074>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
86074>>>    Procedure SetupDriverDefaults String sDriverID
86076>>>        String sAttributeValue
86076>>>        Integer iDriverID
86076>>>        Boolean bNULL bSQLDriver
86076>>>
86076>>>        Get IsSQLDriver sDriverID to bSQLDriver
86077>>>        If (bSQLDriver = False) Begin
86079>>>            Procedure_Return
86080>>>        End
86080>>>>
86080>>>
86080>>>        Get DriverIndex sDriverID to iDriverID
86081>>>
86081>>>        // Driver default values for various data types:
86081>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
86084>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
86085>>>
86085>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
86088>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
86089>>>
86089>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
86092>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
86093>>>
86093>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
86096>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
86097>>>
86097>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
86100>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
86101>>>
86101>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
86104>>>        Set psDriverDefaultValueText                                    to sAttributeValue
86105>>>
86105>>>        // The default setting for the "nullability" of newly created ASCII columns.
86105>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
86108>>>        Set pbDriverDefaultNullableASCII to bNULL
86109>>>
86109>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
86112>>>        Set pbDriverDefaultNullableBinary to bNULL
86113>>>
86113>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
86116>>>        Set pbDriverDefaultNullableDate to bNULL
86117>>>
86117>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
86120>>>        Set pbDriverDefaultNullableDateTime to bNULL
86121>>>
86121>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
86124>>>        Set pbDriverDefaultNullableNumeric to bNULL
86125>>>
86125>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
86128>>>        Set pbDriverDefaultNullableText to bNULL
86129>>>
86129>>>    End_Procedure
86130>>>
86130>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
86132>>>        Boolean bOK bIsDaw bIsMertech bTrusted
86132>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID sCheck
86132>>>        Handle hoErrorObj hoDriver hoIniFile
86132>>>        Integer iDriverID
86132>>>
86132>>>        Move False to bOK
86133>>>
86133>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
86134>>>        If (bIsDaw = False) Begin
86136>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
86137>>>            If (bIsMertech = False) Begin
86139>>>                Function_Return False
86140>>>            End
86140>>>>
86140>>>        End
86140>>>>
86140>>>
86140>>>        Move Error_Object_Id to hoErrorObj
86141>>>        Move Self to Error_Object_Id
86142>>>
86142>>>        Get phoSQLConnectionIniFile to hoIniFile
86143>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
86144>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
86145>>>        If (iDriverID = 0) Begin
86147>>>            Move hoErrorObj to Error_Object_Id
86148>>>            Function_Return False
86149>>>        End
86149>>>>
86149>>>
86149>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
86149>>>        If (bIsMertech = False) Begin
86151>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
86154>>>        End
86154>>>>
86154>>>
86154>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
86155>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
86156>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
86157>>>        Send Destroy   of hoDriver
86158>>>        Move hoErrorObj to Error_Object_Id
86159>>>
86159>>>        Function_Return bOK
86160>>>    End_Function
86161>>>
86161>>>    Function pSQLConnection Returns tSQLConnection
86163>>>        tSQLConnection SQLConnection
86163>>>        tSQLConnection SQLConnection
86163>>>        Get Private.pSQLConnection to SQLConnection
86164>>>        Function_Return SQLConnection
86165>>>    End_Function
86166>>>
86166>>>    Procedure Set psConnectionID String sValue
86168>>>        tSQLConnection SQLConnection
86168>>>        tSQLConnection SQLConnection
86168>>>        Integer iIndex
86168>>>
86168>>>        Get Private.pSQLConnection to SQLConnection
86169>>>        If (SQLConnection.sConnectionID = "") Begin
86171>>>            Move sValue to SQLConnection.sConnectionID
86172>>>        End
86172>>>>
86172>>>
86172>>>        // Else we might want to change the current connection ID
86172>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
86175>>>            Move False to Err
86176>>>            Logout SQLConnection.sDriverID
86177>>>            // This will also make a login to the new server.
86177>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
86178>>>        End
86178>>>>
86178>>>        Set pSQLConnection to SQLConnection
86179>>>    End_Procedure
86180>>>
86180>>>    Function psConnectionID Returns String
86182>>>        tSQLConnection SQLConnection
86182>>>        tSQLConnection SQLConnection
86182>>>        Get Private.pSQLConnection to SQLConnection
86183>>>        Function_Return SQLConnection.sConnectionID
86184>>>    End_Procedure
86185>>>
86185>>>    // Note: If the psDriverID + other connection properties are to be changed,
86185>>>    //       the psDriverID *must* be the first property that is changed!
86185>>>    //       Otherwise errors might be raised by the driver when e.g. the format
86185>>>    //       for a connection string has the wrong format for that driver.
86185>>>    Procedure Set psDriverID String sValue
86187>>>        tSQLConnection SQLConnection
86187>>>        tSQLConnection SQLConnection
86187>>>        Get pSQLConnection to SQLConnection
86188>>>        Move sValue        to SQLConnection.sDriverID
86189>>>        Set pSQLConnection to SQLConnection
86190>>>        If (sValue <> DATAFLEX_ID) Begin
86192>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86193>>>        End
86193>>>>
86193>>>    End_Procedure
86194>>>
86194>>>    Function psDriverID Returns String
86196>>>        tSQLConnection SQLConnection
86196>>>        tSQLConnection SQLConnection
86196>>>        Get Private.pSQLConnection to SQLConnection
86197>>>        If (SQLConnection.sDriverID = "") Begin
86199>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
86200>>>        End
86200>>>>
86200>>>        Function_Return SQLConnection.sDriverID
86201>>>    End_Function
86202>>>
86202>>>    Procedure Set psConnectionString String sValue
86204>>>        tSQLConnection SQLConnection
86204>>>        tSQLConnection SQLConnection
86204>>>        Get Private.pSQLConnection to SQLConnection
86205>>>        Move sValue        to SQLConnection.sConnectionString
86206>>>        Set pSQLConnection to SQLConnection
86207>>>    End_Procedure
86208>>>
86208>>>    Function psConnectionString Returns String
86210>>>        tSQLConnection SQLConnection
86210>>>        tSQLConnection SQLConnection
86210>>>        Get Private.pSQLConnection to SQLConnection
86211>>>        Function_Return SQLConnection.sConnectionString
86212>>>    End_Function
86213>>>
86213>>>    Procedure Set psServer String sValue
86215>>>        tSQLConnection SQLConnection
86215>>>        tSQLConnection SQLConnection
86215>>>        Get Private.pSQLConnection to SQLConnection
86216>>>        Move sValue        to SQLConnection.sServer
86217>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86218>>>        Set pSQLConnection to SQLConnection
86219>>>    End_Procedure
86220>>>
86220>>>    Function psServer Returns String
86222>>>        tSQLConnection SQLConnection
86222>>>        tSQLConnection SQLConnection
86222>>>        Get Private.pSQLConnection to SQLConnection
86223>>>        Function_Return SQLConnection.sServer
86224>>>    End_Function
86225>>>
86225>>>    Procedure Set psDatabase String sValue
86227>>>        tSQLConnection SQLConnection
86227>>>        tSQLConnection SQLConnection
86227>>>        Get Private.pSQLConnection to SQLConnection
86228>>>        Move sValue        to SQLConnection.sDatabase
86229>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86230>>>        Set pSQLConnection to SQLConnection
86231>>>    End_Procedure
86232>>>
86232>>>    Function psDatabase Returns String
86234>>>        tSQLConnection SQLConnection
86234>>>        tSQLConnection SQLConnection
86234>>>        Get Private.pSQLConnection to SQLConnection
86235>>>        Function_Return SQLConnection.sDatabase
86236>>>    End_Function
86237>>>
86237>>>    Procedure Set psUserID String sValue
86239>>>        tSQLConnection SQLConnection
86239>>>        tSQLConnection SQLConnection
86239>>>        Get Private.pSQLConnection to SQLConnection
86240>>>        Move sValue        to SQLConnection.sUserID
86241>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86242>>>        Set pSQLConnection to SQLConnection
86243>>>    End_Procedure
86244>>>
86244>>>    Function psUserID Returns String
86246>>>        tSQLConnection SQLConnection
86246>>>        tSQLConnection SQLConnection
86246>>>        Get Private.pSQLConnection to SQLConnection
86247>>>        Function_Return SQLConnection.sUserID
86248>>>    End_Function
86249>>>
86249>>>    // This is the uncrypted password
86249>>>    Procedure Set psPassword String sValue
86251>>>        tSQLConnection SQLConnection
86251>>>        tSQLConnection SQLConnection
86251>>>        Get Private.pSQLConnection to SQLConnection
86252>>>        Move sValue        to SQLConnection.sPassword
86253>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86254>>>        Set pSQLConnection to SQLConnection
86255>>>    End_Procedure
86256>>>
86256>>>    Function psPassword Returns String
86258>>>        tSQLConnection SQLConnection
86258>>>        tSQLConnection SQLConnection
86258>>>        Get Private.pSQLConnection to SQLConnection
86259>>>        Function_Return SQLConnection.sPassword
86260>>>    End_Function
86261>>>
86261>>>    Procedure Set pbTrusted Boolean bValue
86263>>>        tSQLConnection SQLConnection
86263>>>        tSQLConnection SQLConnection
86263>>>        Get Private.pSQLConnection to SQLConnection
86264>>>        Move bValue        to SQLConnection.bTrusted
86265>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86266>>>        Set pSQLConnection to SQLConnection
86267>>>    End_Procedure
86268>>>
86268>>>    Function pbTrusted Returns Boolean
86270>>>        tSQLConnection SQLConnection
86270>>>        tSQLConnection SQLConnection
86270>>>        Get Private.pSQLConnection to SQLConnection
86271>>>        Function_Return SQLConnection.bTrusted
86272>>>    End_Function
86273>>>
86273>>>    // *** All of these properties are special to the Database Update Framework ***
86273>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
86273>>>    //     the Private.pSQLConnection property is set instead of the going throu
86273>>>    //     the central pSQLConnection "hub".
86273>>>    Procedure Set pbSilentLogin Boolean bValue
86275>>>        tSQLConnection SQLConnection
86275>>>        tSQLConnection SQLConnection
86275>>>        Get Private.pSQLConnection to SQLConnection
86276>>>        Move bValue to SQLConnection.bTrusted
86277>>>        Set Private.pSQLConnection to SQLConnection
86278>>>    End_Procedure
86279>>>
86279>>>    Function pbSilentLogin Returns Boolean
86281>>>        tSQLConnection SQLConnection
86281>>>        tSQLConnection SQLConnection
86281>>>        Get Private.pSQLConnection to SQLConnection
86282>>>        Function_Return SQLConnection.bSilentLogin
86283>>>    End_Function
86284>>>
86284>>>    Procedure Set piDbType Integer iValue
86286>>>        tSQLConnection SQLConnection
86286>>>        tSQLConnection SQLConnection
86286>>>        Get Private.pSQLConnection to SQLConnection
86287>>>        Move iValue to SQLConnection.iDbType
86288>>>        Set Private.pSQLConnection to SQLConnection
86289>>>    End_Procedure
86290>>>
86290>>>    Function piDbType Returns Integer
86292>>>        tSQLConnection SQLConnection
86292>>>        tSQLConnection SQLConnection
86292>>>        Get Private.pSQLConnection to SQLConnection
86293>>>        Function_Return SQLConnection.iDbType
86294>>>    End_Function
86295>>>
86295>>>    Procedure Set psBaseTableSpace String sValue
86297>>>        tSQLConnection SQLConnection
86297>>>        tSQLConnection SQLConnection
86297>>>        Get Private.pSQLConnection to SQLConnection
86298>>>        Move sValue to SQLConnection.sBaseTableSpace
86299>>>        Set Private.pSQLConnection to SQLConnection
86300>>>    End_Procedure
86301>>>
86301>>>    Function psBaseTableSpace Returns String
86303>>>        tSQLConnection SQLConnection
86303>>>        tSQLConnection SQLConnection
86303>>>        Get Private.pSQLConnection to SQLConnection
86304>>>        Function_Return SQLConnection.sBaseTableSpace
86305>>>    End_Function
86306>>>
86306>>>    Procedure Set psIndexTableSpace String sValue
86308>>>        tSQLConnection SQLConnection
86308>>>        tSQLConnection SQLConnection
86308>>>        Get Private.pSQLConnection to SQLConnection
86309>>>        Move sValue to SQLConnection.sIndexTableSpace
86310>>>        Set Private.pSQLConnection to SQLConnection
86311>>>    End_Procedure
86312>>>
86312>>>    Function psIndexTableSpace Returns String
86314>>>        tSQLConnection SQLConnection
86314>>>        tSQLConnection SQLConnection
86314>>>        Get Private.pSQLConnection to SQLConnection
86315>>>        Function_Return SQLConnection.sIndexTableSpace
86316>>>    End_Function
86317>>>
86317>>>    Procedure Set psLongTableSpace String sValue
86319>>>        tSQLConnection SQLConnection
86319>>>        tSQLConnection SQLConnection
86319>>>        Get Private.pSQLConnection to SQLConnection
86320>>>        Move sValue to SQLConnection.sLongTableSpace
86321>>>        Set Private.pSQLConnection to SQLConnection
86322>>>    End_Procedure
86323>>>
86323>>>    Function psLongTableSpace Returns String
86325>>>        tSQLConnection SQLConnection
86325>>>        tSQLConnection SQLConnection
86325>>>        Get Private.pSQLConnection to SQLConnection
86326>>>        Function_Return SQLConnection.sLongTableSpace
86327>>>    End_Function
86328>>>
86328>>>    Procedure Set psSchema String sValue
86330>>>        tSQLConnection SQLConnection
86330>>>        tSQLConnection SQLConnection
86330>>>        Get Private.pSQLConnection to SQLConnection
86331>>>        Move sValue to SQLConnection.sSchema
86332>>>        Set Private.pSQLConnection to SQLConnection
86333>>>    End_Procedure
86334>>>
86334>>>    Function psSchema Returns String
86336>>>        tSQLConnection SQLConnection
86336>>>        tSQLConnection SQLConnection
86336>>>        Get Private.pSQLConnection to SQLConnection
86337>>>        Function_Return SQLConnection.sSchema
86338>>>    End_Function
86339>>>
86339>>>    Procedure Set pbEnabled Boolean bValue
86341>>>        tSQLConnection SQLConnection
86341>>>        tSQLConnection SQLConnection
86341>>>        Get Private.pSQLConnection to SQLConnection
86342>>>        Move bValue to SQLConnection.bEnabled
86343>>>        Set Private.pSQLConnection to SQLConnection
86344>>>    End_Procedure
86345>>>
86345>>>    Function pbEnabled Returns Boolean
86347>>>        tSQLConnection SQLConnection
86347>>>        tSQLConnection SQLConnection
86347>>>        Get Private.pSQLConnection to SQLConnection
86348>>>        Function_Return SQLConnection.bEnabled
86349>>>    End_Function
86350>>>
86350>>>
86350>>>    // ************************************
86350>>>    Function SetupSQLConnection Boolean bReadSettings Returns tSQLConnection
86352>>>        tSQLConnection SQLConnection
86352>>>        tSQLConnection SQLConnection
86352>>>
86352>>>        // If this object was created by the cDbUpdateHandler class we will
86352>>>        // deferr reading SQL connection values until later.
86352>>>        If (bReadSettings = True) Begin
86354>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
86354>>>            If (ghoConnection > 0) Begin
86356>>>                Get ReadcConnections to SQLConnection
86357>>>            End
86357>>>>
86357>>>
86357>>>            // In addition to the above; there might be other values set even if a cConnection
86357>>>            // object is used.
86357>>>            Get ReadSQLConnectionsIniSettings to SQLConnection
86358>>>        End
86358>>>>
86358>>>
86358>>>        Function_Return SQLConnection
86359>>>    End_Function
86360>>>
86360>>>    // This is for the new cConnection class used by DF 19 and up (only).
86360>>>    Function ReadcConnections Returns tSQLConnection
86362>>>        tConnection Connection
86362>>>        tConnection Connection
86362>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86362>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86362>>>        Integer iCount iSize iRetval iDbType
86362>>>        Boolean bOK bEnabled bConnected bVal
86362>>>        String sConnectionID sSchema
86362>>>
86362>>>            tConnection[] Connections
86362>>>            tConnection[] Connections
86363>>>            // - If the DF 19 cConnection class has been used in the cApplication object
86363>>>            // - and there are multiple connection id's defined for the same driver. This is
86363>>>            //   because otherwise we can't possibly know which connection id to use... So
86363>>>            //   we then generate an error and abort the program...
86363>>>            Get IsSinglecConnection (&sConnectionID) to bOK
86364>>>            If (bOK = False) Begin
86366>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
86367>>>>
86367>>>                Abort
86368>>>>
86368>>>            End 
86368>>>>
86368>>>            If (sConnectionID = "") Begin
86370>>>                Get ConnectionIDs of ghoConnection to Connections  
86371>>>                If (SizeOfArray(Connections) > 0) Begin
86373>>>                    Move Connections[0].sId to sConnectionID
86374>>>                End
86374>>>>
86374>>>            End
86374>>>>
86374>>>
86374>>>            Move 0 to iRetval
86375>>>            // DAW DF19 connection info:
86375>>>            // We first check that the connection is OK:
86375>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
86376>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
86376>>>            If (iRetval = -1) Begin
86378>>>                Function_Return SQLConnectionEmpty
86379>>>            End
86379>>>>
86379>>>
86379>>>            If (sConnectionID <> "") Begin
86381>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
86382>>>            End
86382>>>>
86382>>>            If (Connection.sId = "") Begin
86384>>>                Move True to SQLConnectionEmpty.bError
86385>>>                Function_Return SQLConnectionEmpty
86386>>>            End
86386>>>>
86386>>>
86386>>>            // DUF connection info struct property:
86386>>>            Get Private.pSQLConnection                       to SQLConnection
86387>>>
86387>>>            Move Connection.sId to sConnectionID
86388>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
86389>>>
86389>>>            If (bConnected = False) Begin
86391>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
86392>>>                If (iRetval <> 0) Begin
86394>>>                    Send UserError CS_DUF_CannotLoginToServer
86395>>>                    Send Exit_Application
86396>>>                End   
86396>>>>
86396>>>                Move True                                   to SQLConnection.bDAWConnection
86397>>>                // We need to get the DAW connection info again as it might have
86397>>>                // been changed in the DAW db login dialog.
86397>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
86398>>>            End
86398>>>>
86398>>>
86398>>>            Move True                                        to SQLConnection.bEnabled
86399>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
86400>>>
86400>>>            // Not used in DUF:
86400>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
86400>>>
86400>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
86401>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
86402>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
86403>>>            Move Connection.sId                              to SQLConnection.sConnectionID
86404>>>            Move Connection.sUID                             to SQLConnection.sUserID
86405>>>            Move Connection.sPWD                             to SQLConnection.sPassword
86406>>>
86406>>>            // Not used in DUF:
86406>>>            // Move Connection.sSection to SQLConnection.xxx
86406>>>
86406>>>            // The rest of the properties of the SQLConnection struct should have been
86406>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
86406>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
86408>>>                Get ParseKeyWord Connection.sString CS_SQLIniServerKeyword to SQLConnection.sServer
86409>>>            End
86409>>>>
86409>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
86411>>>                Get ParseKeyWord Connection.sString CS_SQLIniDSNKeyword    to SQLConnection.sServer
86412>>>            End
86412>>>>
86412>>>            Get ParseKeyWord Connection.sString CS_SQLIniDatabaseKeyword   to SQLConnection.sDatabase
86413>>>
86413>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
86413>>>            // the value from the driver id:
86413>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
86414>>>            // ...but in case it has been explicitly set in the object we use that value.
86414>>>            Get piDbType                                     to iDbType
86415>>>            If (iDbType <> SQLConnection.iDbType) Begin
86417>>>                Move iDbType to SQLConnection.iDbType
86418>>>            End
86418>>>>
86418>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
86419>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
86420>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
86421>>>            Get psSchema                                     to SQLConnection.sSchema
86422>>>
86422>>>            // We finally set the struct property to the newly fetched values.
86422>>>            Set pSQLConnection to SQLConnection
86423>>>
86423>>>        Function_Return SQLConnection
86424>>>    End_Function
86425>>>
86425>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
86425>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
86425>>>    // connection id for a particular driver.
86425>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
86425>>>    // object. We can then match a connection id from the DAW cConnect class array.
86425>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
86425>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
86425>>>    // connections of the DAW cConnect class.
86425>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
86427>>>        tConnection[] ConnIdArray
86427>>>        tConnection[] ConnIdArray
86428>>>        Integer iCount iSize iConnectionIDCounter
86428>>>        Boolean bOK bEnabled bFound
86428>>>        String sConnectionID2 sDriverID sDriverConn
86428>>>
86428>>>        Move False to bFound
86429>>>        If (ghoConnection > 0) Begin
86431>>>
86431>>>            // The property of the cDbUpdateHandler container object
86431>>>            Get psDriverID to sDriverID
86432>>>
86432>>>            Move 0 to iConnectionIDCounter
86433>>>            // This is the the DAW cConnect array with all registered connection id's.
86433>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
86434>>>            Move (SizeOfArray(ConnIdArray)) to iSize
86435>>>            Decrement iSize
86436>>>            For iCount from 0 to iSize
86442>>>>
86442>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
86443>>>                Move ConnIdArray[iCount].sId to sConnectionID2
86444>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
86445>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
86445>>>                // connection in the DAW cConnect object _and_ that there is only one!
86445>>>                If (sConnectionID = "") Begin
86447>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
86448>>>                End
86448>>>>
86448>>>                Else Begin
86449>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
86451>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
86452>>>                    End
86452>>>>
86452>>>                End
86452>>>>
86452>>>
86452>>>                If (bFound = True) Begin
86454>>>                    Increment iConnectionIDCounter
86455>>>                End
86455>>>>
86455>>>            Loop
86456>>>>
86456>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
86457>>>            If (bFound = True) Begin
86459>>>                Move sConnectionID2 to sConnectionID
86460>>>            End
86460>>>>
86460>>>        End
86460>>>>
86460>>>
86460>>>        // Special case; a cConnection object has been setup in the cApplication,
86460>>>        // but no DFConn.ini record has been created.
86460>>>        If (iSize = -1) Begin
86462>>>            Move True to bFound
86463>>>        End
86463>>>>
86463>>>
86463>>>        Function_Return bFound
86464>>>    End_Function
86465>>>
86465>>>    // Send on object creation to read the default connection string settings, and
86465>>>    // create a connection to the server.
86465>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
86467>>>        String sPath sFileName sSection sConnectionString sPassword
86467>>>        Boolean bExists
86467>>>        tSQLConnection[] SQLConnectionArray
86467>>>        tSQLConnection[] SQLConnectionArray
86468>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86468>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86468>>>        Handle hoIniFile
86468>>>        Integer iSize iCount
86468>>>
86468>>>        Get psIniFilePath to sPath
86469>>>        Get phoSQLConnectionIniFile to hoIniFile
86470>>>        If (sPath = "") Begin
86472>>>            Get ApplicationPath of hoIniFile to sPath
86473>>>            Set psIniFilePath   of hoIniFile to sPath
86474>>>        End
86474>>>>
86474>>>        Get vFolderFormat sPath to sPath
86475>>>        Get psIniFileName to sFileName
86476>>>        Get vFilePathExists (sPath + sFileName) to bExists
86477>>>
86477>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
86478>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
86479>>>        If (iSize = 0) Begin
86481>>>            // This may have been set by the "ReadcConnections" function,
86481>>>            // if a cConnection object has been setup for DataFlex 19 or later
86481>>>            // in the cApplication object.
86481>>>            Get pSQLConnection to SQLConnection
86482>>>            If (SQLConnection.sConnectionID = "") Begin
86484>>>                Function_Return SQLConnectionEmpty
86485>>>            End
86485>>>>
86485>>>            Move SQLConnection to SQLConnectionArray[0]
86486>>>        End
86486>>>>
86486>>>
86486>>>        // The first connection should be the one that is active, but just in case...
86486>>>        Decrement iSize
86487>>>        For iCount from 0 to iSize
86493>>>>
86493>>>            Move SQLConnectionArray[iCount] to SQLConnection
86494>>>            If (SQLConnection.bEnabled = True) Begin
86496>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
86497>>>            End
86497>>>>
86497>>>        Loop
86498>>>>
86498>>>
86498>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
86499>>>
86499>>>        Set pSQLConnection to SQLConnection
86500>>>        Send AutoSetConnectionID
86501>>>
86501>>>        Function_Return SQLConnection
86502>>>    End_Function
86503>>>
86503>>>    Procedure Set psIniFilePath String sPath
86505>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
86506>>>    End_Procedure
86507>>>
86507>>>    Function psIniFilePath Returns String
86509>>>        String sRetval
86509>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
86510>>>        Function_Return sRetval
86511>>>    End_Function
86512>>>
86512>>>    Procedure Set psIniFileName String sFileName
86514>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
86515>>>    End_Procedure
86516>>>
86516>>>    Function psIniFileName Returns String
86518>>>        String sRetval
86518>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
86519>>>        Function_Return sRetval
86520>>>    End_Function
86521>>>
86521>>>    // We use Base64 coding instead of the cCryptographer class because the
86521>>>    // password will get scrambled while writing/reading to/from the ini-file.
86521>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
86521>>>//    Procedure Set psHashString String sHashString
86521>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
86521>>>//    End_Procedure
86521>>>//
86521>>>//    Function psHashString Returns String
86521>>>//        String sRetval
86521>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
86521>>>//        Function_Return sRetval
86521>>>//    End_Function
86521>>>
86521>>>    Procedure Set psIniSectionName String sSection
86523>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
86524>>>    End_Procedure
86525>>>
86525>>>    Function psIniSectionName Returns String
86527>>>        String sRetval
86527>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
86528>>>        Function_Return sRetval
86529>>>    End_Function
86530>>>
86530>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
86532>>>        Handle ho
86532>>>        Get phoSQLConnectionIniFile to ho
86533>>>        Set IniFileValue of ho to sSection sValueName sValue
86534>>>    End_Procedure
86535>>>
86535>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
86537>>>        Handle ho
86537>>>        String sRetval
86537>>>        Get phoSQLConnectionIniFile to ho
86538>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
86539>>>        Function_Return sRetval
86540>>>    End_Function
86541>>>
86541>>>    Function SectionExists String sSection Returns Boolean
86543>>>        Handle ho
86543>>>        Boolean bRetval
86543>>>        Get phoSQLConnectionIniFile to ho
86544>>>        Get SectionExists of ho sSection to bRetval
86545>>>        Function_Return bRetval
86546>>>    End_Function
86547>>>
86547>>>    Function KeyExists String sSection String sKey Returns Boolean
86549>>>        Handle ho
86549>>>        Boolean bRetval
86549>>>        Get phoSQLConnectionIniFile to ho
86550>>>        Get KeyExists of ho sSection sKey to bRetval
86551>>>        Function_Return bRetval
86552>>>    End_Function
86553>>>
86553>>>    Function EncryptPassword String sPassword Returns String
86555>>>        Handle ho
86555>>>        String sRetval
86555>>>        Get phoSQLConnectionIniFile to ho
86556>>>        Get EncryptPassword of ho sPassword to sRetval
86557>>>        Function_Return sRetval
86558>>>    End_Function
86559>>>
86559>>>    Function DecryptPassword String sPassword Returns String
86561>>>        Handle ho
86561>>>        String sRetval
86561>>>        Get phoSQLConnectionIniFile to ho
86562>>>        Get DecryptPassword of ho sPassword to sRetval
86563>>>        Function_Return sRetval
86564>>>    End_Function
86565>>>
86565>>>    // *** Main Connection Message ***
86565>>>    // It will create a Connection ID for the passed driver.
86565>>>    // It will also set the psDriverID & psConnectionID of this class.
86565>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
86567>>>        Integer iResult
86567>>>        Handle hoCLI hoDriver
86567>>>        String sConnectionString sError
86567>>>        Boolean bMertech bLoginSuccessful
86567>>>
86567>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
86568>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
86569>>>        Set psDriverID of hoDriver to sDriverID
86570>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
86571>>>        If (bLoginSuccessful = False) Begin
86573>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
86574>>>>
86574>>>        End
86574>>>>
86574>>>        Send Destroy of hoDriver
86575>>>
86575>>>    End_Procedure
86576>>>
86576>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
86578>>>        Integer iRetval
86578>>>        Handle hoCLI
86578>>>        String sDriverID
86578>>>
86578>>>        Get psDriverID to sDriverID
86579>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
86580>>>        If (hoCLI <> 0) Begin
86582>>>            Set psDriverID of hoCLI to sDriverID
86583>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
86584>>>            Send Destroy of hoCLI
86585>>>        End
86585>>>>
86585>>>
86585>>>        Function_Return iRetval
86586>>>    End_Function
86587>>>
86587>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
86589>>>        Integer iResult
86589>>>        Handle hoCLI
86589>>>        String sServer sDatabase sUserID sPassword
86589>>>        tSQLConnection SQLConnection
86589>>>        tSQLConnection SQLConnection
86589>>>
86589>>>        Set psDriverID to sDriverID
86590>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
86591>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
86592>>>    End_Procedure
86593>>>
86593>>>    // This is needed when e.g. the connection id we have specified in the program code
86593>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
86593>>>    // or the one in the DataFlex Bin folder.)
86593>>>    // We then need to delete the current one before creating a new one.
86593>>>    // This is because the parameters may differ between the program code and the
86593>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
86593>>>    // when one tries to create a Connection ID that already exists.
86593>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
86595>>>        Integer iResult iDriver iNumConn iConn
86595>>>        Handle hoCLI
86595>>>        String sID
86595>>>
86595>>>        If (sDriverID = "" or sConnectionID = "") Begin
86597>>>            Procedure_Return
86598>>>        End
86598>>>>
86598>>>
86598>>>        Move 0 to iResult
86599>>>        Get Create U_cCLIHandler to hoCLI
86600>>>        If (hoCLI <> 0) Begin
86602>>>            Set psDriverID of hoCLI to sDriverID
86603>>>            Get DriverIndex sDriverID to iDriver
86604>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
86607>>>            Decrement iNumConn
86608>>>            For iConn from 0 to iNumConn
86614>>>>
86614>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
86617>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
86619>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
86620>>>                End
86620>>>>
86620>>>            Loop
86621>>>>
86621>>>            Send Destroy of hoCLI
86622>>>        End
86622>>>>
86622>>>
86622>>>    End_Procedure
86623>>>
86623>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
86625>>>        Integer iResult iDriver iNumConn iConn
86625>>>        Handle hoCLI
86625>>>        String sID sConnectionString sVal sDatabase
86625>>>        tSQLConnection SQLConnection
86625>>>        tSQLConnection SQLConnection
86625>>>        Boolean bTrusted
86625>>>
86625>>>        Move 0 to iResult
86626>>>        Get Create U_cCLIHandler to hoCLI
86627>>>        If (hoCLI <> 0) Begin
86629>>>            Set psDriverID of hoCLI to sDriverID
86630>>>            Get DriverIndex sDriverID to iDriver
86631>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
86634>>>            Decrement iNumConn
86635>>>            For iConn from 0 to iNumConn
86641>>>>
86641>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
86644>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
86646>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
86647>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
86650>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
86653>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
86654>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
86657>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
86658>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
86659>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
86660>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
86661>>>
86661>>>                    Case Begin
86661>>>                        Case (sDriverID = MSSQLDRV_ID)
86663>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
86664>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
86665>>>                            Move bTrusted                                               to SQLConnection.bTrusted
86666>>>                            Case Break
86667>>>                        Case (sDriverID = DB2_DRV_ID)
86670>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86671>>>                            Case Break
86672>>>                        Case (sDriverID = ODBC_DRV_ID)
86675>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86676>>>                            Case Break
86677>>>                        Case (sDriverID = SQLFLEX)
86680>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86681>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86682>>>                            If (SQLConnection.bTrusted = True) Begin
86684>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86685>>>                            End
86685>>>>
86685>>>                            Else Begin
86686>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86687>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86688>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86689>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86690>>>                            End
86690>>>>
86690>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86691>>>                            Case Break
86692>>>                        Case (sDriverID = MDSMySQL)
86695>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86696>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86697>>>                            If (SQLConnection.bTrusted = True) Begin
86699>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86700>>>                            End
86700>>>>
86700>>>                            Else Begin
86701>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86702>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86703>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86704>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86705>>>                            End
86705>>>>
86705>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86706>>>                            Case Break
86707>>>                        Case (sDriverID = MDSPgSQL)
86710>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86711>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86712>>>                            If (SQLConnection.bTrusted = True) Begin
86714>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86715>>>                            End
86715>>>>
86715>>>                            Else Begin
86716>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86717>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86718>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86719>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86720>>>                            End
86720>>>>
86720>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
86721>>>                            Case Break
86722>>>
86722>>>                        Case (sDriverID = ORAFLEX)
86725>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
86726>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
86727>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
86728>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
86730>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
86731>>>                            End
86731>>>>
86731>>>                            If (SQLConnection.bTrusted = True) Begin
86733>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86734>>>                            End
86734>>>>
86734>>>                            Else Begin
86735>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86736>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86737>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86738>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86739>>>                            End
86739>>>>
86739>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86740>>>                            Case Break
86741>>>                        Case Else
86741>>>                            Error ("Wrong driver ID passed:" * sDriverID)
86742>>>>
86742>>>                            Case Break
86743>>>                    Case End
86743>>>                End
86743>>>>
86743>>>            Loop
86744>>>>
86744>>>            Send Destroy of hoCLI
86745>>>        End
86745>>>>
86745>>>
86745>>>        Function_Return SQLConnection
86746>>>    End_Function
86747>>>
86747>>>    Function DriverIndex String sDriverID Returns Integer
86749>>>        String  sCurrentDriver
86749>>>        Integer iNumberOfDrivers iDriver iCount iRetval
86749>>>
86749>>>        Move 0 to iDriver
86750>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
86753>>>        For iCount from 1 to iNumberOfDrivers
86759>>>>
86759>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
86762>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
86764>>>                Function_Return iCount
86765>>>            End
86765>>>>
86765>>>        Loop
86766>>>>
86766>>>
86766>>>        // If driver not previously loaded; attempt to do so now.
86766>>>        If (iDriver = 0) Begin
86768>>>            Move 0 to LastErr
86769>>>            Load_Driver sDriverID
86770>>>            // If driver could not be loaded.
86770>>>            If (LastErr = 4255) Begin
86772>>>                Move 0 to iCount
86773>>>            End
86773>>>>
86773>>>            Function_Return iCount
86774>>>        End
86774>>>>
86774>>>        Function_Return 0
86775>>>    End_Function
86776>>>
86776>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
86776>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
86778>>>        String sRetval sDriverID sConnectionID sConnectionString sServer sDatabase sUserID sPassword
86778>>>        Boolean bTrusted bSilent
86778>>>        Integer iConnOptions
86778>>>
86778>>>        Move SQLConnection.sDriverID     to sDriverID
86779>>>        Move SQLConnection.sConnectionID to sConnectionID
86780>>>        Move SQLConnection.sServer       to sServer
86781>>>        Move SQLConnection.sDatabase     to sDatabase
86782>>>        Move SQLConnection.bTrusted      to bTrusted
86783>>>        Move SQLConnection.sUserID       to sUserID
86784>>>        Move SQLConnection.sPassword     to sPassword
86785>>>        Move SQLConnection.bSilentLogin  to bSilent
86786>>>
86786>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
86787>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
86787>>>        Send AutoSetConnectionID
86788>>>    End_Procedure
86789>>>
86789>>>    // Called when the object is constructed.
86789>>>    // It will check the psDriverID for a ConnectionID and save it
86789>>>    // as psConnectionID property. It is later used whenever a login to
86789>>>    // the database is needed.
86789>>>    Procedure AutoSetConnectionID
86791>>>        String sConnectionID sValue sDriverID sConnectionString
86791>>>        Integer iDriver iNumConn iConn iConnOptions iRetval
86791>>>        Handle hoCLI
86791>>>        Boolean bOK bSilent bMertechDriver
86791>>>
86791>>>        Get pbSilentLogin      to bSilent
86792>>>        Get psConnectionID     to sConnectionID
86793>>>        Get psConnectionString to sConnectionString
86794>>>        // Get the driver Connection ID string & set the psConnectionString property.
86794>>>        Get psDriverID to sDriverID
86795>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86796>>>        If (bOK = False) Begin
86798>>>            Procedure_Return
86799>>>        End
86799>>>>
86799>>>
86799>>>        // Mertech drivers can't use connection ID's.
86799>>>        Get IsMertechDriver sDriverID to bMertechDriver
86800>>>        If (bMertechDriver = True) Begin
86802>>>            // This ensures that the correct Server & Database attributes are set both for
86802>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
86802>>>            Get _MertechSQLManagerHandle to hoCLI
86803>>>            Procedure_Return
86804>>>        End
86804>>>>
86804>>>
86804>>>        Get DriverIndex sDriverID          to iDriver
86805>>>        // If driver not loaded; load it.
86805>>>        If (iDriver = 0) Begin
86807>>>            Load_Driver sDriverID
86808>>>            Get DriverIndex sDriverID      to iDriver
86809>>>        End
86809>>>>
86809>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
86809>>>        If (iDriver = 0) Begin
86811>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
86812>>>>
86812>>>            Procedure_Return
86813>>>        End
86813>>>>
86813>>>
86813>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
86814>>>        Set psDriverID of hoCLI            to sDriverID
86815>>>        // Delete the connection first; in case it exists
86815>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
86816>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval
86817>>>
86817>>>        Send Destroy of hoCLI
86818>>>    End_Procedure
86819>>>
86819>>>    // Returns the handle of the Mertech SQL handler.
86819>>>    // It also ensures that the correct Server & Database attributes are set both for
86819>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
86819>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
86819>>>    //       So the return value is of no use! But we don't need the handle for this class.
86819>>>    Function _MertechSQLManagerHandle Returns Handle
86821>>>        Handle hoSQLHandler
86821>>>        String sDriverID sServer sDatabase
86821>>>
86821>>>        Move 0 to hoSQLHandler
86822>>>        Get psDriverID to sDriverID
86823>>>        Get psServer   to sServer
86824>>>        Get psDatabase to sDatabase
86825>>>        // This command is used to set the server to be used when opening tables
86825>>>        SET_CURRENT_SQL_SERVER to sServer
86844>>>>
86844>>>        // This command is used to specify which server to use for embedded SQL statements,
86844>>>        // but it has been constructed rather studidly as only constants and not variables
86844>>>        // are allowed...
86844>>>        If (sDriverID = MDSPgSQL) Begin
86846>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
86862>>>        End
86862>>>>
86862>>>        If (sDriverID = MDSMySQL) Begin
86864>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
86880>>>        End
86880>>>>
86880>>>        If (sDriverID = ORAFLEX) Begin
86882>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
86898>>>        End
86898>>>>
86898>>>        If (sDriverID = SQLFLEX) Begin
86900>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
86916>>>        End
86916>>>>
86916>>>
86916>>>        // This command is used to specify which database is used for embedded SQL statements.
86916>>>        SQL_USE_DATABASE sDatabase
86930>>>>
86930>>>        SET_DATABASE_NAME to sDatabase
86944>>>>
86944>>>
86944>>>        // Can't have this here because the property is defined for the cDbUpdateFunctionLibrary class,
86944>>>        // which object may or may not have been created at this point. So don't use the return
86944>>>        // value for this function!
86944>>>        //Get phoSQLManagerMT to hoSQLHandler
86944>>>
86944>>>        Function_Return hoSQLHandler
86945>>>    End_Function
86946>>>
86946>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
86948>>>        Boolean bOK bMertechDriver
86948>>>
86948>>>        Get IsDAWSQLDriver sDriverID to bOK
86949>>>
86949>>>        If (bOK = False) Begin
86951>>>            Get IsMertechDriver sDriverID to bOK
86952>>>        End
86952>>>>
86952>>>
86952>>>        If (bOK = False) Begin
86954>>>            Get IsMertechDriver sDriverID to bMertechDriver
86955>>>            If (bMertechDriver = True) Begin
86957>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
86958>>>>
86958>>>            End
86958>>>>
86958>>>            Else Begin
86959>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
86960>>>>
86960>>>            End
86960>>>>
86960>>>            Function_Return False
86961>>>        End
86961>>>>
86961>>>
86961>>>        Function_Return True
86962>>>    End_Function
86963>>>
86963>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
86965>>>        Boolean bOK
86965>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
86966>>>        Function_Return bOK
86967>>>    End_Function
86968>>>
86968>>>    Function IsMertechDriver String sDriverID Returns Boolean
86970>>>        Boolean bOK
86970>>>        Move False to bOK
86971>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
86972>>>        Function_Return bOK
86973>>>    End_Function
86974>>>
86974>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
86976>>>        Handle hoIniFile
86976>>>        String sConnect
86976>>>
86976>>>        Get phoSQLConnectionIniFile to hoIniFile
86977>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
86978>>>
86978>>>        Function_Return sConnect
86979>>>    End_Function
86980>>>
86980>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
86980>>>    // Pass a complete driver connection string
86980>>>    // Returns the following as a struct:
86980>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
86980>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
86980>>>    //
86980>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
86982>>>        tSQLConnection SQLConnection
86982>>>        tSQLConnection SQLConnection
86982>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
86982>>>        Boolean bTrusted bSilent bOK
86982>>>        Integer iPos
86982>>>
86982>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86983>>>        If (bOK = False) Begin
86985>>>            Function_Return SQLConnection
86986>>>        End
86986>>>>
86986>>>
86986>>>        Move False to bTrusted
86987>>>        Move False to bSilent
86988>>>
86988>>>        Case Begin
86988>>>            Case (sDriverID = MSSQLDRV_ID)
86990>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
86991>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
86992>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
86993>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
86994>>>                If (bTrusted = False) Begin
86996>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
86997>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
86998>>>                End
86998>>>>
86998>>>                Case Break
86999>>>
86999>>>            Case (sDriverID = ODBC_DRV_ID)
87002>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87003>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
87004>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
87005>>>                If (bTrusted = False) Begin
87007>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
87008>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
87009>>>                End
87009>>>>
87009>>>                Case Break
87010>>>
87010>>>            Case (sDriverID = DB2_DRV_ID)
87013>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87014>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
87015>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
87016>>>                Case Break
87017>>>
87017>>>            Case (sDriverID = SQLFLEX)
87020>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
87021>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
87022>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
87023>>>                If (bTrusted = False) Begin
87025>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
87026>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
87027>>>                End
87027>>>>
87027>>>                Case Break
87028>>>
87028>>>            Case (sDriverID = ORAFLEX)
87031>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87032>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
87033>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
87035>>>                    Move (sServer + "/" + sDatabase)                                to sServer
87036>>>                End
87036>>>>
87036>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
87037>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
87038>>>                Case Break
87039>>>
87039>>>            Case (sDriverID = MDSPgSQL)
87042>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87043>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
87044>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
87045>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
87046>>>                Case Break
87047>>>
87047>>>            Case (sDriverID = MDSMySQL)
87050>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
87051>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
87052>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
87053>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
87054>>>                Case Break
87055>>>
87055>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
87058>>>                Break
87059>>>        Case End
87059>>>
87059>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
87060>>>
87060>>>        // bSilent?
87060>>>        Move (Pos(",0", sConnectionString))                                     to iPos
87061>>>        If (iPos = 0) Begin
87063>>>            Move (Pos(",1", sConnectionString))                                 to iPos
87064>>>        End
87064>>>>
87064>>>        If (iPos = 0) Move "0"                                                  to sValue
87067>>>        Else Move (Mid(sConnectionString, 1, (iPos +1)))                        to sValue
87069>>>        Move (If(sValue = 1, True, False))                                      to bSilent
87070>>>
87070>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
87071>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
87072>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
87073>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
87074>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
87075>>>        Move bTrusted                                                           to SQLConnection.bTrusted
87076>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
87077>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
87078>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
87079>>>
87079>>>        Function_Return SQLConnection
87080>>>    End_Function
87081>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
87081>>>>
87081>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
87083>>>>    Integer iStart iEnd
87083>>>>    String sRetval
87083>>>>
87083>>>>    Move (Trim(sConnect)) to sConnect
87084>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
87085>>>>    If (iStart = 0) Begin
87087>>>>        Function_Return ""
87088>>>>    End
87088>>>>>
87088>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
87089>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
87090>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
87092>>>>        Move (Pos(",", sRetval))          to iEnd
87093>>>>    End
87093>>>>>
87093>>>>    Else Begin
87094>>>>        Move (Pos(";", sRetval))          to iEnd
87095>>>>    End
87095>>>>>
87095>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
87097>>>>        Move (Pos(",", sRetval))          to iEnd
87098>>>>        Decrement iEnd
87099>>>>    End
87099>>>>>
87099>>>>    If (iEnd <> 0) Begin
87101>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
87102>>>>    End
87102>>>>>
87102>>>>    Move (Replace("=", sRetval, ""))      to sRetval
87103>>>>
87103>>>>    Function_Return (Trim(sRetval))
87104>>>>End_Function
87105>>>>
87105>>>>
87105>>>
87105>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
87105>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
87107>>>        Handle ho
87107>>>        Integer iRetval iIndex
87107>>>        Boolean bRetval bOK
87107>>>        tSQLConnection SQLConnection
87107>>>        tSQLConnection SQLConnection
87107>>>
87107>>>        Get pSQLConnection to SQLConnection
87108>>>        Get phoSQLConnectionIniFile to ho
87109>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
87110>>>        If (iIndex = -1) Begin
87112>>>            Function_Return False
87113>>>        End
87113>>>>
87113>>>
87113>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
87114>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
87115>>>        If (ghoConnection > 0) Begin
87117>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
87118>>>            If (iIndex <> -1) Begin
87120>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
87121>>>            End
87121>>>>
87121>>>        End
87121>>>>
87121>>>
87121>>>        Function_Return bRetval
87122>>>    End_Function
87123>>>
87123>>>End_Class
87124>Object oSQLConnectionHandler is a cSQLConnectionHandler
87126>    // If a file was passed on the command line - which can be done from the Studio -
87126>    // we change the ini-file path here. (The name is always the same)
87126>    Procedure End_Construct_Object
87129>        String sPath
87129>        Boolean bExists
87129>        Get psCommandLineIniFilePath of ghoApplication to sPath
87130>        If (sPath <> "") Begin
87132>            Set psIniFilePath to sPath
87133>        End
87133>        Else Begin
87134>            Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
87135>            Set psIniFilePath to sPath
87136>            Get vFolderFormat sPath to sPath
87137>            Get vFilePathExists (sPath + CS_SQLIniFileName) to bExists
87138>            Set pbIniFileExists of ghoApplication to bExists
87139>        End
87139>        Forward Send End_Construct_Object
87141>    End_Procedure
87142>End_Object
87143>
87143>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
87143>>>//****************************************************************************
87143>>>// $Module type: Class
87143>>>// $Module name: cDbUpdateFunctionLibrary
87143>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
87143>>>// Web-site    : http://www.rdctools.com
87143>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
87143>>>//
87143>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
87143>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
87143>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
87143>>>//               with the help of Sql-scripts.
87143>>>//
87143>>>// $Rev History:
87143>>>//    2014-09-05  Module header created
87143>>>//
87143>>>//****************************************************************************
87143>>>Use cApplication.pkg
87143>>>Use seq_chnl.pkg
87143>>>Use GlobalFunctionsProcedures.pkg
87143>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
87143>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
87143>>>>>// StatPnl.pkg - creates the standard status_panel object.
87143>>>>>//
87143>>>>>//
87143>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
87143>>>>>// invoke the standard status panel. The standard has always been that the package name
87143>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
87143>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
87143>>>>>// prior revisions has been replace with status panel that is part of the application.
87143>>>>>// This should work much better and faster than the old sentinel based solution.
87143>>>>>// While the way this operates has changed, the interface has not and therefore this should work
87143>>>>>// with most applications.
87143>>>>>//
87143>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
87143>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
87143>>>>>// a cleaner more robust interface.
87143>>>>>//
87143>>>>>//
87143>>>>>// Compatibility Note:
87143>>>>>//
87143>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
87143>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
87143>>>>>//
87143>>>>>// If for some reason you application will not work using this as a replacement for the old status
87143>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
87143>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
87143>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
87143>>>>>//
87143>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
87143>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
87143>>>>>//
87143>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
87143>>>>>// can still access the new object via the ghoStatusPanel handle.
87143>>>>>//
87143>>>>>//
87143>>>>>// Creating your own Status Panel objects
87143>>>>>//
87143>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
87143>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
87143>>>>>// with a different file and object name and direct your status panel request to the new object.
87143>>>>>//
87143>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
87143>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
87143>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
87143>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
87143>>>>>// e.g.
87143>>>>>//       Procedure UpdateStatusBar
87143>>>>>//           Send DoAdvance of oProgressBar
87143>>>>>//           Send ProcessEvents
87143>>>>>//       End_Procedure
87143>>>>>//
87143>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
87143>>>>>// messages this will be done for you.
87143>>>>>//
87143>>>>>// the standard Interface for status panels are:
87143>>>>>//
87143>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
87143>>>>>// Send Start_StatusPanel      - start the status panel
87143>>>>>// Send Stop_StatusPanel       - stop the status panel
87143>>>>>// Send Update_StatusPanel     - update the status panel's action area
87143>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
87143>>>>>//
87143>>>>>// Get/Set Caption_Text - updates the caption bar
87143>>>>>// Get/Set Title_Text   - updates the title area
87143>>>>>// Get/Set Message_Text - updates the Message area
87143>>>>>// Get/Set Action_Text  - updates the action area
87143>>>>>// Get/Set Button_Text  - updates the button area
87143>>>>>//
87143>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
87143>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
87143>>>>>//
87143>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
87143>>>>>Use cProcessStatusPanel.pkg
87143>>>>>Use cCJSkinFramework.pkg
87143>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cProgressBar.pkg)
87143>>>>>>>Use Windows.pkg
87143>>>>>>>Use cWinControl.pkg
87143>>>>>>>Use CommCtrl.pkg
87143>>>>>>>
87143>>>>>>>Type tPbRange
87143>>>>>>>    Field tPbRange.iLow  as DWord
87143>>>>>>>    Field tPbRange.iHigh as DWord
87143>>>>>>>End_Type
87143>>>>>>>
87143>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
87143>>>>>>>Class cProgressBar is a cWinControl
87144>>>>>>>
87144>>>>>>>    Procedure Construct_Object
87146>>>>>>>        Forward Send Construct_Object
87148>>>>>>>        Property Integer private_piMinimum
87149>>>>>>>        Property Integer private_piMaximum   100
87150>>>>>>>        Property Integer private_piAdvanceBy 10
87151>>>>>>>        Property Integer private_piPosition
87152>>>>>>>        Property Integer private_pbVertical  False
87153>>>>>>>        Property Integer private_pbSmooth    False
87154>>>>>>>        Property Integer private_piBackColor clDefault
87155>>>>>>>        Property Integer private_piBarColor  clDefault
87156>>>>>>>
87156>>>>>>>        Send Define_ToolTip_Support_Mixin
87157>>>>>>>
87157>>>>>>>        Set External_Class_Name 'cVdfProgressBar' To 'msctls_progress32'
87158>>>>>>>        Set Focus_Mode to NonFocusable
87159>>>>>>>        Set Skip_State to True
87160>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
87161>>>>>>>    End_Procedure
87162>>>>>>>
87162>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
87163>>>>>>>
87163>>>>>>>    Procedure Set piMinimum Integer iMin
87165>>>>>>>        Integer iMax
87165>>>>>>>
87165>>>>>>>        Set private_piMinimum to iMin
87166>>>>>>>        Get private_piMaximum To iMax
87167>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
87168>>>>>>>    End_Procedure
87169>>>>>>>    Function piMinimum Returns Integer
87171>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
87174>>>>>>>        Else Function_Return (private_piMinimum(self))
87176>>>>>>>    End_Function
87177>>>>>>>
87177>>>>>>>    Procedure Set piMaximum Integer iMax
87179>>>>>>>        Integer iMin
87179>>>>>>>
87179>>>>>>>        Set private_piMaximum to iMax
87180>>>>>>>        Get private_piMinimum To iMin
87181>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
87182>>>>>>>    End_Procedure
87183>>>>>>>    Function piMaximum Returns Integer
87185>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
87188>>>>>>>        Else Function_Return (private_piMaximum(self))
87190>>>>>>>    End_Function
87191>>>>>>>
87191>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
87193>>>>>>>        Set private_piAdvanceBy To iAdvanceBy
87194>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
87195>>>>>>>    End_Procedure
87196>>>>>>>    Function piAdvanceBy Returns Integer
87198>>>>>>>        Function_Return (private_piAdvanceBy(self))
87199>>>>>>>    End_Function
87200>>>>>>>
87200>>>>>>>    Procedure Set piPosition Integer iPos
87202>>>>>>>        Set private_piPosition To iPos
87203>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
87204>>>>>>>    End_Procedure
87205>>>>>>>
87205>>>>>>>    Function piPosition Returns Integer
87207>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
87210>>>>>>>        Else Function_Return (private_piPosition(self))
87212>>>>>>>    End_Function
87213>>>>>>>
87213>>>>>>>    Procedure Set pbVertical Boolean bVertical
87215>>>>>>>        If (private_pbVertical(self) <> bVertical) Begin
87217>>>>>>>            Set private_pbVertical To bVertical
87218>>>>>>>           Send DoRecreateWindow
87219>>>>>>>        End
87219>>>>>>>>
87219>>>>>>>    End_Procedure
87220>>>>>>>
87220>>>>>>>    Function pbVertical Returns Boolean
87222>>>>>>>        Function_Return (private_pbVertical(self))
87223>>>>>>>    End_Function
87224>>>>>>>
87224>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
87226>>>>>>>        If (private_pbSmooth(self) <> bSmooth) Begin
87228>>>>>>>           Set private_pbSmooth To bSmooth
87229>>>>>>>           Send DoRecreateWindow
87230>>>>>>>        End
87230>>>>>>>>
87230>>>>>>>    End_Procedure
87231>>>>>>>    Function pbSmooth Returns Boolean
87233>>>>>>>        Function_Return (private_pbSmooth(self))
87234>>>>>>>    End_Function
87235>>>>>>>
87235>>>>>>>    Procedure Set piBackColor Integer rgbColor
87237>>>>>>>        Set private_piBackColor To rgbColor
87238>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
87239>>>>>>>    End_Procedure
87240>>>>>>>    Function piBackColor Returns Integer
87242>>>>>>>        Function_Return (private_piBackColor(self))
87243>>>>>>>    End_Function
87244>>>>>>>
87244>>>>>>>    Procedure Set piBarColor Integer rgbColor
87246>>>>>>>        Set private_piBarColor To rgbColor
87247>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
87248>>>>>>>    End_Procedure
87249>>>>>>>    Function piBarColor Returns Integer
87251>>>>>>>        Function_Return (private_piBarColor(self))
87252>>>>>>>    End_Function
87253>>>>>>>
87253>>>>>>>    Procedure DoAdvance
87255>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
87256>>>>>>>    End_procedure
87257>>>>>>>
87257>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
87259>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
87260>>>>>>>    End_procedure
87261>>>>>>>
87261>>>>>>>    Procedure private_DoInitWindow
87263>>>>>>>        Set piBarColor  To (private_piBarColor(self))
87264>>>>>>>        Set piBackColor To (private_piBackColor(self))
87265>>>>>>>        Set piAdvanceBy To (private_piAdvanceBy(self))
87266>>>>>>>        Set piMinimum   To (private_piMinimum(self))
87267>>>>>>>        Set piMaximum   To (private_piMaximum(self))
87268>>>>>>>        Set piPosition  To (private_piPosition(self))
87269>>>>>>>    End_Procedure
87270>>>>>>>
87270>>>>>>>    Procedure Page_Object Integer iState
87272>>>>>>>        Handle hWnd
87272>>>>>>>
87272>>>>>>>        Get Window_Handle To hWnd
87273>>>>>>>        If (hWnd=0 and iState) Begin
87275>>>>>>>            Set Window_Style To PBS_VERTICAL (private_pbVertical(self))
87276>>>>>>>            Set Window_Style To PBS_SMOOTH   (private_pbSmooth(self))
87277>>>>>>>            Forward Send Page_Object True
87279>>>>>>>        End
87279>>>>>>>>
87279>>>>>>>        Else Forward Send Page_Object iState
87282>>>>>>>     
87282>>>>>>>        // Handle tooltip support....
87282>>>>>>>        If (iState = 0) Begin
87284>>>>>>>            Send RequestDeleteToolTip
87285>>>>>>>        End 
87285>>>>>>>>
87285>>>>>>>        Else Begin
87286>>>>>>>            Send RequestAddToolTip
87287>>>>>>>        End
87287>>>>>>>>
87287>>>>>>>    End_Procedure
87288>>>>>>>
87288>>>>>>>    Procedure Page Integer iState
87290>>>>>>>        Forward Send Page iState
87292>>>>>>>        If (iState =1) Send private_DoInitWindow
87295>>>>>>>    End_Procedure
87296>>>>>>>
87296>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
87296>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
87296>>>>>>>    // is implemented in a mixin class.
87296>>>>>>>    Procedure RequestAddToolTip
87298>>>>>>>        Send AddToolTip
87299>>>>>>>    End_Procedure  // RequestAddToolTip
87300>>>>>>>
87300>>>>>>>
87300>>>>>>>    // Called by Page_Object. Handles tooltip removal. 
87300>>>>>>>    Procedure RequestDeleteToolTip
87302>>>>>>>        Send DeleteToolTip
87303>>>>>>>    End_Procedure // RequestDeleteToolTip
87304>>>>>>>End_Class
87305>>>>>
87305>>>>>
87305>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
87305>>>>>
87305>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
87305>>>>>
87305>>>>>Object Status_Panel is a cProcessStatusPanel
87307>>>>>    Set Size to 140 222
87308>>>>>    Set Border_Style to Border_Dialog
87309>>>>>//    Set Sysmenu_Icon to False  
87309>>>>>    Set Icon to "DbUpdateFrameworkdf19.ico"
87310>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
87311>>>>>
87311>>>>>    Property Boolean Cancel_Button_Visible_State True
87313>>>>>
87313>>>>>    Procedure Activate
87316>>>>>        Integer iSizeBefore iSizeAfter
87316>>>>>        Get GuiSize to iSizeBefore
87317>>>>>        Forward Send Activate
87319>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))  
87320>>>>>    End_Procedure  
87321>>>>>    
87321>>>>>    Procedure End_Construct_Object
87324>>>>>        Forward Send End_Construct_Object
87326>>>>>        Set Label of oTitleTxt      to ""
87327>>>>>        Set Label of oTableNameTxt  to ""
87328>>>>>        Set Label of oMessageTxt    to ""
87329>>>>>        Set Label of oActionTxt     to ""
87330>>>>>    End_Procedure
87331>>>>>
87331>>>>>    Object oTitleTxt is a TextBox
87333>>>>>        Set Location to 5 21
87334>>>>>        Set Size to 8 179
87335>>>>>        Set Auto_Size_State to False
87336>>>>>        Set Justification_Mode  to jMode_Center
87337>>>>>        Set Label to "This is the Title Text"
87338>>>>>    End_Object
87339>>>>>
87339>>>>>    Object oTableNameTxt is a TextBox
87341>>>>>        Set Size to 19 204
87342>>>>>        Set Location to 18 9
87343>>>>>        Set Auto_Size_State to False
87344>>>>>        Set Justification_Mode to JMode_Left
87345>>>>>        Set Label to "This is the TableName Text"
87346>>>>>    End_Object
87347>>>>>
87347>>>>>    Object oMessageTxt is a TextBox
87349>>>>>        Set Location to 39 9
87350>>>>>        Set Size to 19 204
87351>>>>>        Set Auto_Size_State to False
87352>>>>>        Set Justification_Mode to JMode_Left
87353>>>>>        Set Label to "This is the Message text"
87354>>>>>    End_Object
87355>>>>>
87355>>>>>    Object oActionTxt is a TextBox
87357>>>>>        Set Size to 19 204
87358>>>>>        Set Location to 60 9
87359>>>>>        Set Auto_Size_State to False
87360>>>>>        Set Justification_Mode to JMode_Left
87361>>>>>        Set Label to "This is the Action Text"
87362>>>>>    End_Object
87363>>>>>
87363>>>>>    Object oStopButton is a Button
87365>>>>>        Set Location to 112 82
87366>>>>>        Set Label to C_$Cancel
87367>>>>>
87367>>>>>        Procedure OnClick
87370>>>>>            Send Close_panel
87371>>>>>        End_Procedure
87372>>>>>
87372>>>>>    End_Object
87373>>>>>
87373>>>>>    Object oPercentage_tb is a TextBox
87375>>>>>        Set Location to 74 196
87376>>>>>        Set Size to 10 25
87377>>>>>//        Set Label to "% Done"
87377>>>>>    End_Object
87378>>>>>
87378>>>>>    Object oCopyRight is a TextBox
87380>>>>>        Set Location to 129 21
87381>>>>>        Set Size to 9 197
87382>>>>>        Set FontPointHeight to 8
87383>>>>>        Set Auto_Size_State to False
87384>>>>>        Set Justification_Mode  to jMode_Center
87385>>>>>        Set Label to "Copyright 2001-2017 RDC Tools International"
87386>>>>>    End_Object
87387>>>>>
87387>>>>>    Object oProgressBar is a cProgressBar
87389>>>>>        Set Size to 10 179
87390>>>>>        Set Location to 86 22
87391>>>>>        Set pbVisible to True // default
87392>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
87393>>>>>    End_Object
87394>>>>>
87394>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
87397>>>>>        Set pbVisible of ghoProgressBar to bVisible
87398>>>>>    End_Procedure
87399>>>>>
87399>>>>>    Function Progress_Bar_Visible_State Returns Boolean
87402>>>>>        Boolean bVisible
87402>>>>>        Get pbVisible of ghoProgressBar to bVisible
87403>>>>>        Function_Return (bVisible)
87404>>>>>    End_Function
87405>>>>>
87405>>>>>    Object oProgressBarOverall is a cProgressBar
87407>>>>>        Set Size to 10 179
87408>>>>>        Set Location to 99 22
87409>>>>>        Set pbVisible to True // default
87410>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
87411>>>>>    End_Object
87412>>>>>
87412>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
87415>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
87416>>>>>    End_Procedure
87417>>>>>
87417>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
87420>>>>>        Boolean bVisible
87420>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
87421>>>>>        Function_Return (bVisible)
87422>>>>>    End_Function
87423>>>>>
87423>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
87423>>>>>    // objects defined within this instance of the status panel.
87423>>>>>
87423>>>>>    // note: all of the messages that change text should be forwarded
87423>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
87423>>>>>
87423>>>>>    Procedure Set Message_Text String sText
87426>>>>>        Set Label of oMessageTxt to sText
87427>>>>>        Forward Set Message_Text to sText
87429>>>>>    End_Procedure
87430>>>>>
87430>>>>>    Function Message_Text Returns String
87433>>>>>        Function_Return (Label(oMessageTxt))
87434>>>>>    End_Function
87435>>>>>
87435>>>>>    Procedure Set Action_Text String sText
87438>>>>>        Set Label of oActionTxt to sText
87439>>>>>        Forward Set Action_Text to sText
87441>>>>>    End_Procedure
87442>>>>>
87442>>>>>    Function Action_Text Returns String
87445>>>>>        Function_Return (Label(oActionTxt))
87446>>>>>    End_Function
87447>>>>>
87447>>>>>    Procedure Set Button_Text String sText
87450>>>>>        Set Label of oStopButton to sText
87451>>>>>        Forward Set Button_Text to sText
87453>>>>>    End_Procedure
87454>>>>>
87454>>>>>    Function Button_Text Returns String
87457>>>>>        Function_Return (Label(oStopButton))
87458>>>>>    End_Function
87459>>>>>
87459>>>>>    Procedure Set Title_Text String sText
87462>>>>>        Set Label of oTitleTxt to sText
87463>>>>>        Forward Set Title_Text to sText
87465>>>>>    End_Procedure
87466>>>>>
87466>>>>>    Function Title_Text Returns String
87469>>>>>        Function_Return (Label(oTitleTxt))
87470>>>>>    End_Function
87471>>>>>
87471>>>>>    Procedure Set TableName_Text String sText
87474>>>>>        Set Label of oTableNameTxt to sText
87475>>>>>    End_Procedure
87476>>>>>
87476>>>>>    Function TableName_Text Returns String
87479>>>>>        Function_Return (Label(oTableNameTxt))
87480>>>>>    End_Function
87481>>>>>
87481>>>>>    Procedure Set License_Text String sText
87484>>>>>//        Set Label of oLicense_txt to sText
87484>>>>>    End_Procedure
87485>>>>>
87485>>>>>    // gets called when status panel is activated passing whether a button
87485>>>>>    // should appear
87485>>>>>    Procedure EnableCancelButton Boolean bEnable
87488>>>>>        Boolean bVisible
87488>>>>>        Get Cancel_Button_Visible_State to bVisible
87489>>>>>        If (bEnable = False) Begin
87491>>>>>            Set Visible_State of oStopButton to bVisible
87492>>>>>        End
87492>>>>>>
87492>>>>>        Set Enabled_State of oStopButton to bEnable
87493>>>>>    End_Procedure
87494>>>>>
87494>>>>>    Procedure Reset_StatusPanel
87497>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
87498>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
87499>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
87500>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
87501>>>>>    End_Procedure
87502>>>>>
87502>>>>>//    Object oProgressBar is a cProgressBar
87502>>>>>//        Move Self to ghoProgressBar
87502>>>>>//        Set Location to 1 25
87502>>>>>//        Set Size to 9 173
87502>>>>>//        Set piMinimum        to 0
87502>>>>>//        Set piMaximum        to 2000
87502>>>>>//        Set piAdvanceBy      to 100
87502>>>>>//        Set pbSmooth to True
87502>>>>>//
87502>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
87502>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
87502>>>>>//        // color will show correctly.
87502>>>>>//        Procedure Page Integer iPageObject
87502>>>>>//            Handle hWin
87502>>>>>//            Forward Send Page iPageObject
87502>>>>>//            If (ghoSkinFramework <> 0) Begin
87502>>>>>//                Get Window_Handle to hWin
87502>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
87502>>>>>//            End
87502>>>>>//        End_Procedure
87502>>>>>//    End_Object
87502>>>>>
87502>>>>>End_Object
87503>>>>>
87503>>>Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
87503>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
87503>>>Use cSQLConnectionHandler.pkg
87503>>>Use vWin32fh.pkg
87503>>>
87503>>>//
87503>>>Class cDbUpdateFunctionLibrary is a cObject
87504>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
87505>>>>
87505>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
87507>>>>    Integer iStart iEnd
87507>>>>    String sRetval
87507>>>>
87507>>>>    Move (Trim(sConnect)) to sConnect
87508>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
87509>>>>    If (iStart = 0) Begin
87511>>>>        Function_Return ""
87512>>>>    End
87512>>>>>
87512>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
87513>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
87514>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
87516>>>>        Move (Pos(",", sRetval))          to iEnd
87517>>>>    End
87517>>>>>
87517>>>>    Else Begin
87518>>>>        Move (Pos(";", sRetval))          to iEnd
87519>>>>    End
87519>>>>>
87519>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
87521>>>>        Move (Pos(",", sRetval))          to iEnd
87522>>>>        Decrement iEnd
87523>>>>    End
87523>>>>>
87523>>>>    If (iEnd <> 0) Begin
87525>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
87526>>>>    End
87526>>>>>
87526>>>>    Move (Replace("=", sRetval, ""))      to sRetval
87527>>>>
87527>>>>    Function_Return (Trim(sRetval))
87528>>>>End_Function
87529>>>>
87529>>>>
87529>>>
87529>>>    Procedure Construct_Object
87531>>>        Handle ho
87531>>>        Forward Send Construct_Object
87533>>>
87533>>>        Move Self to ghoDbUpdateFunctionLibrary
87534>>>
87534>>>        Send CreateDbUpdateLibraryProperties
87535>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
87535>>>        // we will create one as it is used for all ConnectionID, ConnectionString
87535>>>        // etc settings.
87535>>>        If (ghoSQLConnectionHandler = 0) Begin
87537>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
87538>>>            Set phoSQLConnectionHandler to ho
87539>>>        End
87539>>>>
87539>>>
87539>>>    End_Procedure
87540>>>
87540>>>    Procedure End_Construct_Object
87542>>>        Forward Send End_Construct_Object
87544>>>    End_Procedure
87545>>>
87545>>>    // *** SQL Messages for making changes to the SQL back-end ***
87545>>>    //
87545>>>
87545>>>    // Function for creating a new *Database*.
87545>>>    // Note: This is for creating SQL DATABASES - not tables!
87545>>>    // Returns True if successful.
87545>>>    // ToDo: Only works for MS-SQL...
87545>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
87547>>>        String sSQL sSQL1 sConnectionID sConnectionString sCreateDatabaseKeyWord sSelectFromWhereName
87547>>>        Handle hConnection hStmt hoSQLManager
87547>>>        Integer iFetchResult iDbType
87547>>>        Boolean bOK bMertechDriver
87547>>>
87547>>>        Get piDbType to iDbType
87548>>>        If (iDbType <> EN_DbTypeMSSQL) Begin
87550>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
87551>>>>
87551>>>            Function_Return False
87552>>>        End
87552>>>>
87552>>>
87552>>>        Get IsMertechDriver sDriverID to bMertechDriver
87553>>>        If (bMertechDriver = False) Begin
87555>>>            Get phoSQLManager to hoSQLManager
87556>>>        End
87556>>>>
87556>>>        Else Begin
87557>>>            Get _MertechSQLManagerHandle to hoSQLManager
87558>>>        End
87558>>>>
87558>>>
87558>>>        Get psConnectionID     to sConnectionID
87559>>>        Get psConnectionString to sConnectionString
87560>>>        Move 0 to LastErr
87561>>>
87561>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87562>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
87563>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
87564>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
87566>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
87567>>>>
87567>>>            Function_Return False
87568>>>        End
87568>>>>
87568>>>
87568>>>        Get SqlOpen of hConnection to hStmt
87569>>>
87569>>>        If (hStmt = 0) Begin
87571>>>            Send SqlDisconnect of hoSQLManager
87572>>>            Error DFERR_PROGRAM CS_SQLConnectError
87573>>>>
87573>>>            Function_Return False
87574>>>        End
87574>>>>
87574>>>
87574>>>        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
87575>>>        Get _SqlSelectFromWhereName to sSelectFromWhereName
87576>>>        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
87577>>>
87577>>>        // Check if database exists
87577>>>        Send SqlExecDirect of hStmt sSQL
87578>>>        Get SqlFetch of hStmt to iFetchResult
87579>>>        Send SqlClose of hStmt
87580>>>        Send SqlDisconnect of hConnection
87581>>>
87581>>>        // If database already exists we're out of here!
87581>>>        // Note that we return True as this is not an error.
87581>>>        If (iFetchResult > 0) Begin
87583>>>            Function_Return True
87584>>>        End
87584>>>>
87584>>>
87584>>>        // Database doesn't exist, create it.
87584>>>        If (iFetchResult = 0) Begin
87586>>>            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
87587>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87588>>>
87588>>>            Send SqlUtilExecuteQuery sSQL1 sDriverID
87589>>>
87589>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
87590>>>            If (LastErr = CLIERR_GENERAL_ERROR) Begin
87592>>>               Function_Return False
87593>>>            End
87593>>>>
87593>>>
87593>>>            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
87593>>>            Sleep 1
87594>>>            Send SqlUtilExecuteQuery sSQL sDriverID
87595>>>        End
87595>>>>
87595>>>
87595>>>        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
87595>>>        // the one we just created.
87595>>>        If (bUpdateConnectionString = True) Begin
87597>>>            Set psDatabase to sDatabase
87598>>>            //...and perhaps also the SQLConnections.ini file setting.
87598>>>            If (bPermanantly = True) Begin
87600>>>                If (ghoSQLConnectionHandler <> 0) Begin
87602>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
87603>>>                End
87603>>>>
87603>>>            End
87603>>>>
87603>>>        End
87603>>>>
87603>>>
87603>>>        Function_Return (Err = False)
87604>>>    End_Function
87605>>>
87605>>>    // Converts from SQL to Embedded (DataFlex .dat files).
87605>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
87605>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
87605>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
87605>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
87605>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
87607>>>        Handle hToTable
87607>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bCopyData
87607>>>        String sDriverID sPhysicalName sRootName sDisplayName sEmpty sConnectionID sConnectionString
87607>>>        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase
87607>>>        tSQLConnection SQLConnection
87607>>>        tSQLConnection SQLConnection
87607>>>        Integer iPos iMaxRecords
87607>>>
87607>>>        Get psDriverID to sDriverID
87608>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87609>>>        If (bExists = False) Begin
87611>>>            Function_Return False
87612>>>        End
87612>>>>
87612>>>
87612>>>        If (num_arguments > 1) Begin
87614>>>            Move bCpyDat to bCopyData
87615>>>        End
87615>>>>
87615>>>        Else Begin
87616>>>            Move False to bCopyData
87617>>>        End
87617>>>>
87617>>>
87617>>>        Open hTable
87619>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87622>>>        If (bOpened = False) Begin
87624>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
87625>>>>
87625>>>            Function_Return False
87626>>>        End
87626>>>>
87626>>>        Move 0 to hToTable
87627>>>
87627>>>        Move 16711679 to iMaxRecords
87628>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87631>>>        Move (Pos(".", sDisplayName)) to iPos
87632>>>        If (iPos > 0) Begin
87634>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
87635>>>        End
87635>>>>
87635>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87638>>>        Get _TableNameOnly sRootName                 to sRootName
87639>>>        Move (sRootName + ".dat")                    to sPhysicalName
87640>>>
87640>>>        If (ghoProgressBar <> 0) Begin
87642>>>            Send DoAdvance of ghoProgressBar
87643>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
87644>>>        End
87644>>>>
87644>>>
87644>>>        Move False to Err
87645>>>
87645>>>        Structure_Start hToTable DATAFLEX_ID
87646>>>            Structure_Copy hTable to hToTable
87647>>>
87647>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
87650>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
87653>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
87656>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
87659>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
87662>>>
87662>>>        Structure_End hToTable
87664>>>
87664>>>        Move (not(Err)) to bOK
87665>>>        If (bOK = True and bCopyData = True) Begin
87667>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
87668>>>        End
87668>>>>
87668>>>
87668>>>        Get IsMertechDriver sDriverID to bMertechDriver
87669>>>        If (bMertechDriver = True) Begin
87671>>>            Open hTable
87673>>>        End
87673>>>>
87673>>>
87673>>>        // This must be after copying data...
87673>>>        If (Err = False) Begin
87675>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87678>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87681>>>        End
87681>>>>
87681>>>        Move (not(Err)) to bOK
87682>>>
87682>>>        Function_Return (bOK = True)
87683>>>    End_Function
87684>>>
87684>>>    // Creates an SQL Table at the SQL end by its filelist number;
87684>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
87684>>>    Function SqlTableCreate Integer hTable Returns Boolean
87686>>>        String sTableName sSQLString sPath sVal sCreateTable sDriverID
87686>>>        Integer iRetval iDbType
87686>>>        Boolean bExists bOK
87686>>>
87686>>>        Get psDriverID to sDriverID
87687>>>        Get UtilTableHandleToString hTable to sTableName
87688>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87689>>>        If (bExists = True) Begin
87691>>>            Function_Return False
87692>>>        End
87692>>>>
87692>>>
87692>>>        Get psDataPathFirstPart to sPath
87693>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
87694>>>
87694>>>        Get piDbType to iDbType
87695>>>        Get _SqlProperTableName sTableName to sTableName
87696>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
87697>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
87698>>>
87698>>>        Move False to Err
87699>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87700>>>
87700>>>        Function_Return (Err = False)
87701>>>    End_Function
87702>>>
87702>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
87702>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
87702>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
87704>>>        String sSQLString sPath sVal sCreateTable sDriverID
87704>>>        Integer iRetval iDbType
87704>>>        Boolean bExists bOK
87704>>>
87704>>>        Get psDriverID to sDriverID
87705>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87706>>>        If (bExists = True) Begin
87708>>>            Function_Return False
87709>>>        End
87709>>>>
87709>>>
87709>>>        Get psDataPathFirstPart to sPath
87710>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
87711>>>        If (bExists = True) Begin
87713>>>            // ToDo: What should we do if an .int file already exists?
87713>>>        End
87713>>>>
87713>>>
87713>>>        Get piDbType to iDbType
87714>>>        Get _SqlProperTableName sTableName to sTableName
87715>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
87716>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
87717>>>
87717>>>        Move False to Err
87718>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87719>>>
87719>>>        Function_Return (Err = False)
87720>>>    End_Function
87721>>>
87721>>>    // First deletes the data cache file and then drops the passed SQL table.
87721>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
87721>>>    //       else try using the SqlTableRemoveByTableName message.
87721>>>    Function SqlTableRemove Integer hTable Returns Boolean
87723>>>        String sSQLString sPath sDropTable sTableName sDriverID
87723>>>        Integer iRetval iDbType
87723>>>        Boolean bExists bMertechDriver bOK
87723>>>
87723>>>        Get psDriverID to sDriverID
87724>>>        Get IsMertechDriver sDriverID to bMertechDriver
87725>>>        Get UtilTableHandleToString hTable to sTableName
87726>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87727>>>        If (bExists = False) Begin
87729>>>            Function_Return False
87730>>>        End
87730>>>>
87730>>>
87730>>>        Get psDataPathFirstPart to sPath
87731>>>        Get UtilDeleteCacheFile sTableName to iRetval
87732>>>
87732>>>        Get piDbType to iDbType
87733>>>        Get _SqlProperTableName sTableName to sTableName
87734>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
87735>>>        Move (sDropTable * String(sTableName)) to sSQLString
87736>>>
87736>>>        Move False to Err
87737>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87738>>>
87738>>>        // We also need to remove the cache-file since the table has been changed
87738>>>        Get UtilDeleteCacheFile sTableName to bOK
87739>>>
87739>>>        Function_Return (Err = False)
87740>>>    End_Function
87741>>>
87741>>>    // First deletes the data cache file and then drops the passed data table.
87741>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
87743>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
87743>>>        Integer iRetval iDbType
87743>>>        Boolean bMertechDriver bOK
87743>>>
87743>>>        Get psDriverID to sDriverID
87744>>>        Get IsMertechDriver sDriverID to bMertechDriver
87745>>>        Get psDataPathFirstPart to sPath
87746>>>        Get UtilDeleteCacheFile sTableName to iRetval
87747>>>
87747>>>        Get piDbType to iDbType
87748>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
87749>>>        Get psSchema to sSchema
87750>>>        If (sSchema = "") Begin
87752>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
87753>>>        End
87753>>>>
87753>>>        Move (Uppercase(sTableName)) to sVal
87754>>>        If (not(sVal contains (sSchema + "."))) Begin
87756>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
87757>>>        End
87757>>>>
87757>>>        Move (sDropTable * String(sTableName)) to sSQLString
87758>>>
87758>>>        Move False to Err
87759>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87760>>>
87760>>>        // We also need to remove the cache-file since the table has been changed
87760>>>        Get UtilDeleteCacheFile sTableName to bOK
87761>>>
87761>>>        Function_Return (Err = False)
87762>>>    End_Function
87763>>>
87763>>>    // *** Sql View Messages ***
87763>>>
87763>>>    // First deletes the data cache file and then drops the passed Sql data view.
87763>>>    Function SqlViewRemove String sDataView Returns Boolean
87765>>>        String sDriverID sSQLString sPath sDropViewKeyWord
87765>>>        Integer iRetval
87765>>>        Boolean bMertechDriver bOK
87765>>>
87765>>>        Get psDriverID to sDriverID
87766>>>        Get IsMertechDriver sDriverID to bMertechDriver
87767>>>        Get UtilDeleteCacheFile sDataView to iRetval
87768>>>
87768>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
87769>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
87770>>>        Set psSQLStatementString to sSQLString
87771>>>
87771>>>        // As we don't check if the view exist or not, it might happen
87771>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
87771>>>        Move False to Err
87772>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87773>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87774>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87775>>>        Move 0 to LastErr
87776>>>
87776>>>        // We also need to remove the cache-file since the table has been changed
87776>>>        Get UtilDeleteCacheFile sDataView to bOK
87777>>>
87777>>>        Function_Return (Err = False)
87778>>>    End_Function
87779>>>
87779>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
87781>>>        Boolean bOK
87781>>>        Integer iDbType 
87781>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
87781>>>        
87781>>>        Get psDriverID to sDriverID
87782>>>        Get piDbType   to iDbType
87783>>>        
87783>>>        Case Begin
87783>>>            Case (iDbType = EN_DbTypeDB2)
87785>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
87786>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
87787>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
87788>>>            Break
87789>>>
87789>>>            Case (iDbType = EN_DbTypeMSSQL)
87792>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
87793>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
87794>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
87795>>>            Break
87796>>>
87796>>>            Case (iDbType = EN_DbTypeOracle)
87799>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
87800>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
87801>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
87802>>>            Break
87803>>>
87803>>>            Case (iDbType = EN_DbTypePostgre)
87806>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
87807>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
87808>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
87809>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
87810>>>            Break
87811>>>
87811>>>            Case (iDbType = EN_DbTypeMySQL)
87814>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
87815>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
87816>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
87817>>>            Break
87818>>>        Case End   
87818>>>        
87818>>>        Move False to Err
87819>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
87820>>>        Move (Err = False) to bOK
87821>>>        
87821>>>        Function_Return bOK
87822>>>    End_Function
87823>>>    
87823>>>     // *** Sql Column Messages ***
87823>>>    //
87823>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
87823>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
87825>>>        Integer iColumn iDbType iLength iDecimals
87825>>>        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
87825>>>        String sTableName sDriverID sUpdate sSet sNoCountOn
87825>>>        Boolean bExists bOK bInitializeValue
87825>>>
87825>>>        Get psDriverID to sDriverID
87826>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
87827>>>        If (bOK = False) Begin
87829>>>            Function_Return False
87830>>>        End
87830>>>>
87830>>>
87830>>>        Get UtilTableHandleToString hTable to sTableName
87831>>>        If (sTableName = "") Begin
87833>>>            Function_Return False
87834>>>        End
87834>>>>
87834>>>
87834>>>        If (num_arguments > 3) Begin
87836>>>            Move iLen     to iLength
87837>>>            Move iDec     to iDecimals
87838>>>            Move bInitVal to bInitializeValue
87839>>>            Move sColVal  to sColumnValue
87840>>>        End
87840>>>>
87840>>>
87840>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
87841>>>
87841>>>        Function_Return (bOK = True)
87842>>>    End_Function
87843>>>
87843>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
87843>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
87845>>>        Integer iColumn iDbType iLength iDecimals iDriver
87845>>>        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
87845>>>        String sDriverID sUpdate sSet sNoCountOn sNotNull
87845>>>        Boolean bExists bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
87845>>>        Handle hTable
87845>>>
87845>>>        Get psDriverID to sDriverID
87846>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
87847>>>        If (bOK = False) Begin
87849>>>            Function_Return False
87850>>>        End
87850>>>>
87850>>>
87850>>>        Get UtilTableNameToHandle sTableName to hTable
87851>>>        If (hTable = 0) Begin
87853>>>            Get NextFreeFilelistSlot to hTable
87854>>>        End 
87854>>>>
87854>>>
87854>>>        Get piDbType to iDbType
87855>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
87855>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
87856>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
87858>>>            Function_Return False
87859>>>        End
87859>>>>
87859>>>
87859>>>        Get DriverIndex sDriverID to iDriver
87860>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
87863>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
87866>>>
87866>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
87867>>>        If (num_arguments > 3) Begin
87869>>>            Move iLen     to iLength
87870>>>            Move iDec     to iDecimals
87871>>>            Move bInitVal to bInitializeValue
87872>>>            Move sColVal  to sColumnValue
87873>>>        End
87873>>>>
87873>>>
87873>>>        Get _SqlProperTableName sTableName   to sTableName
87874>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
87875>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
87876>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
87877>>>
87877>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
87878>>>        If (bFixed = False) Begin
87880>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
87881>>>        End
87881>>>>
87881>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
87882>>>
87882>>>        Move False to Err
87883>>>        Send SqlUtilExecuteQuery sStmt sDriverID
87884>>>
87884>>>        If (bInitializeValue = True and Err = False) Begin
87886>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
87887>>>        End
87887>>>>
87887>>>
87887>>>        If (Err = False) Begin
87889>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
87890>>>        End
87890>>>>
87890>>>
87890>>>        Move (not(Err)) to bRetval
87891>>>
87891>>>        // We also need to remove the cache-file since the table has been changed
87891>>>        Get UtilDeleteCacheFile sTableName to bOK
87892>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
87895>>>
87895>>>        Function_Return bRetval
87896>>>    End_Function
87897>>>    
87897>>>    // To update all current rows for a table column with a common value.
87897>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
87899>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
87899>>>        Boolean bRetval bSQLDriver 
87899>>>        Integer iCurrErr
87899>>>        
87899>>>        Move False to bRetval
87900>>>        Get psDriverID to sDriverID
87901>>>        Get IsSQLDriver sDriverID to bSQLDriver
87902>>>        If (bSQLDriver = False) Begin
87904>>>            Function_Return bRetval
87905>>>        End
87905>>>>
87905>>>        Get UtilTableHandleToString hTable to sTableName
87906>>>        
87906>>>        Move Err to iCurrErr
87907>>>        Move False to Err
87908>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
87909>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
87910>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
87911>>>        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
87912>>>        Send SqlUtilExecuteQuery sStmt sDriverID
87913>>>        Move (Err = False) to bRetval
87914>>>        Move iCurrErr to Err
87915>>>        
87915>>>        Function_Return bRetval
87916>>>    End_Function
87917>>>
87917>>>    // The fourth & fifth arguments are optional, depending on the iDataType
87917>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
87917>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
87919>>>        Integer iColumn iDbType iLength iDecimals
87919>>>        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sTableName sNotNull
87919>>>        Boolean bExists bOK bFixed
87919>>>
87919>>>        Get psDriverID to sDriverID
87920>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
87921>>>        If (bOK = False) Begin
87923>>>            Function_Return False
87924>>>        End
87924>>>>
87924>>>
87924>>>        Get UtilTableHandleToString hTable to sTableName
87925>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
87926>>>
87926>>>        Function_Return (Err = False)
87927>>>    End_Function
87928>>>
87928>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
87928>>>    // The fourth & fifth arguments are optional, depending on the iDataType
87928>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
87928>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
87930>>>        Integer iColumn iDbType iLength iDecimals
87930>>>        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sNotNull
87930>>>        Boolean bExists bOK bFixed
87930>>>        Handle hTable
87930>>>
87930>>>        Get psDriverID to sDriverID
87931>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
87932>>>        If (bOK = False) Begin
87934>>>            Function_Return False
87935>>>        End
87935>>>>
87935>>>
87935>>>        Get UtilTableNameToHandle sTableName to hTable
87936>>>        If (hTable = 0) Begin
87938>>>            Get NextFreeFilelistSlot to hTable
87939>>>        End
87939>>>>
87939>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
87940>>>        If (bExists = True) Begin
87942>>>            Function_Return False
87943>>>        End
87943>>>>
87943>>>
87943>>>        If (num_arguments > 3) Begin
87945>>>            Move iLen to iLength
87946>>>        End
87946>>>>
87946>>>        If (num_arguments > 4) Begin
87948>>>            Move iDec to iDecimals
87949>>>        End
87949>>>>
87949>>>
87949>>>        Get piDbType to iDbType
87950>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
87951>>>
87951>>>        Move False to Err
87952>>>        Get _SqlProperTableName sTableName    to sTableName
87953>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
87954>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
87955>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
87956>>>
87956>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
87957>>>        If (bFixed = False) Begin
87959>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
87960>>>        End
87960>>>>
87960>>>
87960>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
87961>>>        Send SqlUtilExecuteQuery sStmt sDriverID
87962>>>
87962>>>        // We also need to remove the cache-file since the table has been changed
87962>>>        Get UtilDeleteCacheFile sTableName to bOK
87963>>>
87963>>>        Function_Return (Err = False)
87964>>>    End_Function
87965>>>
87965>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
87967>>>        Boolean bOK bErr bIsSQLDriver
87967>>>        String sDriverID
87967>>>
87967>>>        Get psDriverID to sDriverID
87968>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
87969>>>        If (bIsSQLDriver = False) Begin
87971>>>            Function_Return False
87972>>>        End
87972>>>>
87972>>>
87972>>>        Move Err to bErr
87973>>>        Move False to bErr
87974>>>
87974>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
87974>>>        // inserts randomly character(10) and spaces, so we correct from that here:
87974>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
87975>>>
87975>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
87978>>>        Move (not(Err)) to bOK
87979>>>        Move bErr to Err
87980>>>
87980>>>        Function_Return bOK
87981>>>    End_Function
87982>>>
87982>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
87984>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
87984>>>        String sDriverID
87984>>>
87984>>>        Get psDriverID to sDriverID
87985>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
87986>>>        If (bIsSQLDriver = False) Begin
87988>>>            Function_Return False
87989>>>        End
87989>>>>
87989>>>
87989>>>        Move Err to bErr
87990>>>        Move False to bErr
87991>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
87994>>>        If (bNullable = bCurrentState) Begin
87996>>>            Function_Return True
87997>>>        End
87997>>>>
87997>>>
87997>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88000>>>        If (bOpen = False) Begin
88002>>>            Get AutoConnectionIDLogin to bOK
88003>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88004>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
88005>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88006>>>            Open hTable
88008>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88009>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
88010>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88011>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88014>>>        End
88014>>>>
88014>>>        If (bOpen = True) Begin
88016>>>            Structure_Start hTable sDriverID
88017>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
88020>>>            Structure_End hTable
88022>>>        End
88022>>>>
88022>>>
88022>>>        Move (not(Err)) to bOK
88023>>>        Move bErr to Err
88024>>>
88024>>>        Function_Return bOK
88025>>>    End_Function
88026>>>
88026>>>    // Drop column by its table handle
88026>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
88028>>>        Integer iColumn idbType
88028>>>        String sDriverID sStmt sAlterTable sDropColumn sVal sTableName
88028>>>        Boolean bExists bOK
88028>>>
88028>>>        Get psDriverID to sDriverID
88029>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88030>>>        If (bOK = False) Begin
88032>>>            Function_Return False
88033>>>        End
88033>>>>
88033>>>
88033>>>        Get UtilTableHandleToString hTable to sTableName
88034>>>        If (sTableName = "") Begin
88036>>>            Function_Return False
88037>>>        End
88037>>>>
88037>>>
88037>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
88038>>>
88038>>>        Function_Return (bOK = True)
88039>>>    End_Function
88040>>>
88040>>>    // Drop column by its table name as a string.
88040>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
88042>>>        Integer iColumn iDbType iDriver
88042>>>        String sDriverID sStmt sAlterTable sDropColumn sVal
88042>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
88042>>>        Handle hTable
88042>>>
88042>>>        Get psDriverID to sDriverID
88043>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88044>>>        If (bOK = False) Begin
88046>>>            Function_Return False
88047>>>        End
88047>>>>
88047>>>
88047>>>        Get DriverIndex sDriverID to iDriver
88048>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88051>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
88054>>>
88054>>>        Get UtilTableNameToHandle sTableName to hTable
88055>>>        If (hTable <> 0) Begin
88057>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
88058>>>            If (bExists = False) Begin
88060>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88063>>>                Function_Return False
88064>>>            End
88064>>>>
88064>>>        End
88064>>>>
88064>>>
88064>>>        Get piDbType to iDbType
88065>>>        If (iDbType = EN_DbTypeMSSQL) Begin
88067>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
88068>>>            Get UtilDeleteCacheFile sTableName to bOK
88069>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88072>>>            Function_Return bOK
88073>>>        End
88073>>>>
88073>>>
88073>>>        Move False to Err
88074>>>        Get _SqlProperTableName sTableName    to sTableName
88075>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88076>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
88077>>>
88077>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
88078>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88079>>>        Move (not(Err)) to bRetval
88080>>>
88080>>>        // We also need to remove the cache-file since the table has been changed
88080>>>        Get UtilDeleteCacheFile sTableName to bOK
88081>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88084>>>
88084>>>        Function_Return bRetval
88085>>>    End_Function
88086>>>
88086>>>    // Rename a field/column by table handle (filelist number)
88086>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
88088>>>        Integer iColumn idbType
88088>>>        String sDriverID sTableName sStmt sAlterTable sRenameColumn sVal sColumnKeyWord
88088>>>        Boolean bExists bOK
88088>>>
88088>>>        Get psDriverID to sDriverID
88089>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88090>>>        If (bOK = False) Begin
88092>>>            Function_Return False
88093>>>        End
88093>>>>
88093>>>
88093>>>        Get UtilTableHandleToString hTable to sTableName
88094>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
88095>>>
88095>>>        Function_Return (Err = False)
88096>>>    End_Function
88097>>>
88097>>>    // Rename a field/column by table name.
88097>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
88099>>>        Integer iColumn iDbType iDataType
88099>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
88099>>>        Boolean bExists bOK bRetval
88099>>>        Handle hTable
88099>>>
88099>>>        Move sTableName to sOrgTableName
88100>>>        Get psDriverID to sDriverID
88101>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88102>>>        If (bOK = False) Begin
88104>>>            Function_Return False
88105>>>        End
88105>>>>
88105>>>
88105>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
88106>>>        If (sVal = "") Begin
88108>>>            Function_Return False
88109>>>        End
88109>>>>
88109>>>
88109>>>        Get piDbType to iDbType
88110>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
88111>>>        Get _SqlProperTableName sTableName     to sTableName
88112>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
88113>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
88114>>>
88114>>>        Case Begin
88114>>>            Case (iDbType = EN_dbTypeMSSQL)
88116>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
88117>>>                Case Break
88118>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
88118>>>            Case (iDbType = EN_dbTypeOracle)
88121>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88122>>>                Case Break
88123>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
88123>>>            Case (iDbType = EN_dbTypeDB2)
88126>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88127>>>                Case Break
88128>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
88128>>>            Case (iDbType = EN_dbTypePostgre)
88131>>>                Move sOrgTableName to sTableName
88132>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
88133>>>                Case Break
88134>>>            Case (iDbType = EN_dbTypeMySQL)
88137>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
88137>>>                Move sOrgTableName to sTableName
88138>>>                Get psDatabase to sDatabase
88139>>>                Get UtilTableNameToHandle sTableName to hTable
88140>>>                If (hTable = 0) Begin
88142>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
88143>>>                    If (bOK = False) Begin
88145>>>                        Function_Return False
88146>>>                    End
88146>>>>
88146>>>                    Get NextFreeFilelistSlot to hTable
88147>>>                End
88147>>>>
88147>>>                Else Begin
88148>>>                    Open hTable
88150>>>                End
88150>>>>
88150>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
88151>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
88152>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
88153>>>                Case Break
88154>>>            Case Else
88154>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
88155>>>        Case End
88155>>>
88155>>>        Move False to Err
88156>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88157>>>        Move (Err = False) to bRetval
88158>>>        // We also need to remove the cache-file since the table has been changed
88158>>>        Get UtilDeleteCacheFile sTableName to bOK
88159>>>
88159>>>        Function_Return bRetval
88160>>>    End_Function
88161>>>
88161>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
88163>>>        Handle hoSQLHandler hSQLConnect hStmt
88163>>>        Boolean bMertechDriver
88163>>>        Integer iNumCols iCount iSQLType iDataType
88163>>>        String sValue
88163>>>
88163>>>        Get IsMertechDriver sDriverID to bMertechDriver
88164>>>        If (bMertechDriver = False) Begin
88166>>>            Get phoSQLManager to hoSQLHandler
88167>>>        End
88167>>>>
88167>>>        Else Begin
88168>>>            Get _MertechSQLManagerHandle to hoSQLHandler
88169>>>        End
88169>>>>
88169>>>
88169>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
88170>>>        If (hSQLConnect <> 0) Begin
88172>>>            Get SQLOpen of hSQLConnect to hStmt
88173>>>            If (hStmt <> 0) Begin
88175>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
88176>>>
88176>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
88177>>>                For iCount from 1 to iNumCols
88183>>>>
88183>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
88184>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
88186>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
88187>>>                        Move iNumCols to iCount // We're out of here
88188>>>                    End
88188>>>>
88188>>>                Loop
88189>>>>
88189>>>
88189>>>                Send SQLClose of hStmt
88190>>>            End
88190>>>>
88190>>>            Send SQLDisconnect of hSQLConnect
88191>>>        End
88191>>>>
88191>>>
88191>>>        Function_Return iDataType
88192>>>    End_Function
88193>>>
88193>>>
88193>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
88193>>>    // the DbUpdateVersion database revision in.
88193>>>    // Also pass the file number of the current (embedded?) table number used in development.
88193>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
88193>>>    Function SqlCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
88195>>>        Boolean bOK bOpened
88195>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt sDropColumn
88195>>>
88195>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88198>>>        Get _TableNameOnly sTableName to sTableName
88199>>>        If (sTableName = "") Begin
88201>>>            Function_Return False
88202>>>        End
88202>>>>
88202>>>
88202>>>        // This just creates the table and a "dummy" column.
88202>>>        Get SqlTableCreate hTable sDriverID to bOK
88203>>>        If (bOK = False) Begin
88205>>>            Function_Return False
88206>>>        End
88206>>>>
88206>>>
88206>>>        Close hTable
88207>>>        Move False to Err
88208>>>
88208>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
88209>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
88210>>>        Move "Decimal" to sDataType
88211>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
88212>>>
88212>>>        // Adds the "sColumnName" passed to the function
88212>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
88213>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88214>>>
88214>>>        // Now we can delete the dummy column:
88214>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
88215>>>
88215>>>        // Finally, we attach to the newly created table.
88215>>>        If (Err = False) Begin
88217>>>            Get ApiTableAttachToSQL hTable True to bOK
88218>>>        End
88218>>>>
88218>>>        Open hTable
88220>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88223>>>
88223>>>        Function_Return (Err = False and bOK = True and bOpened = True)
88224>>>    End_Function
88225>>>
88225>>>    // Checks if a column/field name exists in a SQL table definition
88225>>>    // Returns True if it does
88225>>>    // Sample:
88225>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
88225>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
88227>>>        Integer iNumColumns iColumn
88227>>>        String sColumn sDriverID
88227>>>        String[] sColumnsArray
88228>>>        Boolean bExists bOK
88228>>>
88228>>>        Move False to bExists
88229>>>        Get AutoConnectionIDLogin to bOK
88230>>>        Get psDriverID to sDriverID
88231>>>
88231>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
88232>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
88233>>>        Decrement iNumColumns
88234>>>        For iColumn from 0 to iNumColumns
88240>>>>
88240>>>            Move sColumnsArray[iColumn] to sColumn
88241>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
88243>>>                Move True to bExists
88244>>>                Move iNumColumns to iColumn // We're out of here
88245>>>            End
88245>>>>
88245>>>        Loop
88246>>>>
88246>>>
88246>>>        Function_Return bExists
88247>>>    End_Function
88248>>>
88248>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
88250>>>        Integer iNumColumns iColumn iDFType iNativeType
88250>>>        Boolean bOpened bOK
88250>>>        String sColumnName sNativeTypeName
88250>>>
88250>>>        Get AutoConnectionIDLogin to bOK
88251>>>        Get OpenTableExclusive hTable to bOK
88252>>>        If (bOK = False) Begin
88254>>>            Function_Return False
88255>>>        End
88255>>>>
88255>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88258>>>        If (bOpened = False) Begin
88260>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
88261>>>>
88261>>>            Function_Return False
88262>>>        End
88262>>>>
88262>>>
88262>>>        Move False to Err
88263>>>
88263>>>        Structure_Start hTable
88264>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
88267>>>
88267>>>            For iColumn from 1 to iNumColumns
88273>>>>
88273>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
88276>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
88279>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
88282>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
88285>>>
88285>>>                Case Begin
88285>>>                    Case (iDFType = DF_DATE)
88287>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
88289>>>                            // Convert datetime to date
88289>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
88292>>>                        End
88292>>>>
88292>>>                        Case Break
88293>>>                    Case (iDFType = DF_DATETIME)
88296>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
88298>>>                            // Convert datetime to datetime2
88298>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
88301>>>                        End
88301>>>>
88301>>>                        Case Break
88302>>>                    Case (iDFType = DF_ASCII)
88305>>>                        If (iNativeType = SQL_CHAR) Begin
88307>>>                            // Convert char to varchar
88307>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
88310>>>                        End
88310>>>>
88310>>>                        Case Break
88311>>>                    Case (iDFType = DF_TEXT)
88314>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
88316>>>                            // Convert text to varchar(max)
88316>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
88319>>>                        End
88319>>>>
88319>>>                        Case Break
88320>>>                    Case (iDFType = DF_BINARY)
88323>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
88325>>>                            // Convert image to varbinary(max)
88325>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
88328>>>                        End
88328>>>>
88328>>>                        Case Break
88329>>>                Case End
88329>>>            Loop
88330>>>>
88330>>>        Structure_End hTable
88332>>>
88332>>>        Function_Return (Err = False)
88333>>>    End_Function
88334>>>
88334>>>    // Does three things with auxilirary files;
88334>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
88334>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
88334>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
88334>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
88336>>>        String sDataPath sDDSrcPath sVal sDriverID
88336>>>        Boolean bOK bExists bMertechDriver
88336>>>        Integer iCount iItems iCh iPos
88336>>>
88336>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
88336>>>        If (sTableName contains ".") Begin
88338>>>            Move (Pos(".", sTableName)) to iPos
88339>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
88340>>>        End
88340>>>>
88340>>>
88340>>>        Get psDriverID to sDriverID
88341>>>        Get psDataPathFirstPart to sDataPath
88342>>>        Get vFolderExists sDataPath to bOK
88343>>>        If (bOK = False) Begin
88345>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
88346>>>>
88346>>>            Function_Return False
88347>>>        End
88347>>>>
88347>>>
88347>>>        Get IsMertechDriver sDriverID to bMertechDriver
88348>>>        // First delete the cache file:
88348>>>        Get UtilDeleteCacheFile sTableName to bOK
88349>>>
88349>>>        Get Seq_New_Channel to iCh
88350>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
88352>>>            Function_Return False
88353>>>        End
88353>>>>
88353>>>
88353>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
88354>>>        If (bExists = False) Begin
88356>>>            Function_Return False
88357>>>        End
88357>>>>
88357>>>
88357>>>        // Add the new column name to the .tag file:
88357>>>        Append_Output channel iCh (sDataPath + sTableName + ".tag")
88359>>>            Writeln channel iCh sColumnName
88362>>>        Close_Output
88363>>>
88363>>>        // If in development environment; output new .fd file:
88363>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88364>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88365>>>        If (iCount > 1) Begin
88367>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88368>>>        End
88368>>>>
88368>>>        Get vFolderExists sDDSrcPath to bExists
88369>>>        If (bExists = True) Begin
88371>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
88372>>>            Move False to Err
88373>>>            Get AutoConnectionIDLogin to bOK
88374>>>            If (hTable <> 0) Begin
88376>>>                Open hTable
88378>>>            End
88378>>>>
88378>>>            Else Begin
88379>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
88380>>>            End
88380>>>>
88380>>>
88380>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
88383>>>            If (bOK = True) Begin
88385>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88387>>>            End
88387>>>>
88387>>>            If (Err = True) Begin
88389>>>                Move False to bOK
88390>>>            End
88390>>>>
88390>>>        End
88390>>>>
88390>>>
88390>>>        Function_Return (bOK = True)
88391>>>    End_Function
88392>>>
88392>>>    // The table must already exist in the filelist for this function to work.
88392>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
88392>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
88394>>>        Boolean bOK bExists bUseConnectionID bMertech
88394>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
88394>>>        String[] sIndexArray
88395>>>        Integer iCount iCh iSize
88395>>>
88395>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
88396>>>        Get psConnectionString to sConnectionString
88397>>>
88397>>>        Move CS_ANSI_Txt to sANSI_OEM
88398>>>        If (bANSI = False) Begin
88400>>>            Move CS_OEM_Txt to sANSI_OEM
88401>>>        End
88401>>>>
88401>>>
88401>>>        Get psDataPathFirstPart to sDataPath
88402>>>        Get vFolderExists sDataPath to bOK
88403>>>        If (bOK = False) Begin
88405>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
88406>>>>
88406>>>            Function_Return False
88407>>>        End
88407>>>>
88407>>>        Get vFolderFormat sDataPath to sDataPath
88408>>>
88408>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
88411>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
88414>>>        Get _TableNameOnly sRootName to sDatabaseName
88415>>>        Move sLogicalName  to sPhysicalFileName
88416>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
88417>>>
88417>>>        Get IsMertechDriver sDriverID to bMertech
88418>>>        If (bMertech = True) Begin
88420>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
88420>>>            // Else it will create an error in the error log (although it won't do anything...)
88420>>>            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
88420>>>            Function_Return (bOK = True)
88421>>>        End
88421>>>>
88421>>>
88421>>>        Get psSchema hTable to sSchemaName
88422>>>        If (sSchemaName = "") Begin
88424>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
88425>>>        End
88425>>>>
88425>>>
88425>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
88425>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
88426>>>        If (bExists = True) Begin
88428>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
88429>>>        End
88429>>>>
88429>>>
88429>>>        Get UtilDeleteCacheFile sRootName to bOK
88430>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
88431>>>
88431>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
88432>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
88437>>>            If (bUseConnectionID = True) Begin
88439>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
88446>>>            End
88446>>>>
88446>>>            Else Begin
88447>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
88454>>>            End
88454>>>>
88454>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
88459>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
88464>>>            // There seems to be a new order how these are set from DF19.
88464>>>            If (bSysFile = True) Begin
88466>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
88471>>>            End
88471>>>>
88471>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
88476>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
88481>>>            If (bSysFile = True) Begin
88483>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
88488>>>            End
88488>>>>
88488>>>
88488>>>            If (bSysFile = False) Begin
88490>>>                Move (SizeOfArray(sIndexArray)) to iSize
88491>>>                Move (SortArray(sIndexArray)) to sIndexArray
88492>>>                If (iSize > 0) Begin
88494>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
88497>>>                    Writeln channel iCh // Just an empty line
88499>>>                End
88499>>>>
88499>>>                Decrement iSize
88500>>>                For iCount from 0 to iSize
88506>>>>
88506>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
88509>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
88512>>>                    Writeln channel iCh
88514>>>                Loop
88515>>>>
88515>>>            End
88515>>>>
88515>>>        Send Seq_Close_Channel iCh
88516>>>
88516>>>        // Wait a sec for Windows to finish writing the file:
88516>>>        Sleep 1
88517>>>
88517>>>        Function_Return (bOK = True)
88518>>>    End_Function
88519>>>
88519>>>    // Message for changing .int files to use connection ID's
88519>>>    //
88519>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
88519>>>    // OR changes an existing connection id to a new id.
88519>>>    // Pass the full path to the data folder and the name of the connection id (string value).
88519>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
88519>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
88521>>>        String sFileName sDriverID sDriverFile sConnectionString
88521>>>        String[] sFilesData
88522>>>        Boolean bExists bOK bCancel
88522>>>        Integer iSize iCount
88522>>>
88522>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
88523>>>        Move (SizeOfArray(sFilesData))    to iSize
88524>>>        If (iSize = 0) Begin    
88526>>>            If (ghoStatusPanel <> 0) Begin
88528>>>                If (Active_State(ghoStatusPanel)) Begin
88530>>>                    Send Stop_StatusPanel of ghoStatusPanel
88531>>>                End
88531>>>>
88531>>>            End
88531>>>>
88531>>>            Send Info_Box "No .int files found! Nothing was changed."
88532>>>            Procedure_Return
88533>>>        End
88533>>>>
88533>>>
88533>>>        Move (Trim(sConnectionID)) to sConnectionID
88534>>>        Get vFolderFormat sDataPath to sDataPath
88535>>>        Decrement iSize
88536>>>        For iCount from 0 to iSize
88542>>>>
88542>>>            Move sFilesData[iCount] to sFileName
88543>>>            // This makes sure that we also can change an existing connection id to something new:
88543>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
88544>>>            If (ghoStatusPanel <> 0) Begin
88546>>>                If (Active_State(ghoStatusPanel)) Begin
88548>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
88549>>>                    If (bCancel = True) Begin
88551>>>                        Send Deactivate of ghoStatusPanel
88552>>>                        Procedure_Return
88553>>>                    End
88553>>>>
88553>>>                End
88553>>>>
88553>>>            End
88553>>>>
88553>>>        Loop
88554>>>>
88554>>>
88554>>>        Get psDriverID to sDriverID
88555>>>
88555>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
88555>>>        Move "" to sFileName
88556>>>        If (sDriverID = MSSQLDRV_ID) Begin
88558>>>            Move "MSSQLDrv.int" to sFileName
88559>>>        End
88559>>>>
88559>>>        If (sDriverID = DB2_DRV_ID) Begin
88561>>>            Move "DB2_Drv.int" to sFileName
88562>>>        End
88562>>>>
88562>>>        If (sDriverID = ODBC_DRV_ID) Begin
88564>>>            Move "ODBC_Drv.int" to sFileName
88565>>>        End
88565>>>>
88565>>>        If (sFileName <> "") Begin
88567>>>            Move "" to sDriverFile
88568>>>            Get_File_Path sFileName to sDriverFile
88569>>>            If (sDriverFile <> "") Begin
88571>>>                Get psConnectionString to sConnectionString
88572>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
88573>>>            End
88573>>>>
88573>>>        End
88573>>>>
88573>>>    End_Procedure
88574>>>
88574>>>    // Checks if the database exists in SQL. Returns = True if it does.
88574>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
88576>>>        String[] sDatabaseArray
88577>>>        String sVal sServer sDriverID
88577>>>        Integer iCount iSize iPos
88577>>>        Boolean bExists
88577>>>        tSQLConnection SQLConnection
88577>>>        tSQLConnection SQLConnection
88577>>>
88577>>>        Move False to bExists
88578>>>        Get psDriverID to sDriverID
88579>>>        // DB2 doesn't need to have a "Database" name, so we always return True.
88579>>>        If (sDriverID = DB2_DRV_ID) Begin
88581>>>            Function_Return bExists
88582>>>        End
88582>>>>
88582>>>
88582>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
88583>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
88585>>>            Function_Return False
88586>>>        End
88586>>>>
88586>>>
88586>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
88587>>>        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
88588>>>        If (sServer contains "/") Begin
88590>>>            Move (Pos("/", sServer)) to iPos
88591>>>            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
88592>>>        End
88592>>>>
88592>>>
88592>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
88593>>>        Decrement iSize
88594>>>        For iCount from 0 to iSize
88600>>>>
88600>>>            Move sDatabaseArray[iCount] to sVal
88601>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
88603>>>                Move True to bExists
88604>>>            End
88604>>>>
88604>>>        Loop
88605>>>>
88605>>>
88605>>>        Function_Return bExists
88606>>>    End_Function
88607>>>
88607>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
88607>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
88609>>>        String sTableName sVal
88609>>>        Boolean bExists
88609>>>        String[] sTablesArray
88610>>>        Integer iSize iCount
88610>>>
88610>>>        Move False to bExists
88611>>>        Get UtilTableHandleToString hTable to sTableName
88612>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
88613>>>        Move (SizeOfArray(sTablesArray)) to iSize
88614>>>        Decrement iSize
88615>>>        For iCount from 0 to iSize
88621>>>>
88621>>>            Move sTablesArray[iCount] to sVal
88622>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
88624>>>                Move True to bExists
88625>>>                Move iSize to iCount // We're done!
88626>>>            End
88626>>>>
88626>>>        Loop
88627>>>>
88627>>>
88627>>>        Function_Return bExists
88628>>>    End_Function
88629>>>
88629>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
88629>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
88631>>>        String sVal
88631>>>        Boolean bExists
88631>>>        String[] sTablesArray
88632>>>        Integer iSize iCount
88632>>>
88632>>>        Move False to bExists
88633>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
88634>>>        Move (SizeOfArray(sTablesArray)) to iSize
88635>>>        Decrement iSize
88636>>>        For iCount from 0 to iSize
88642>>>>
88642>>>            Move sTablesArray[iCount] to sVal
88643>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
88645>>>                Move True to bExists
88646>>>                Move iSize to iCount // We're done!
88647>>>            End
88647>>>>
88647>>>        Loop
88648>>>>
88648>>>
88648>>>        Function_Return bExists
88649>>>    End_Function
88650>>>
88650>>>    // ToDo: This index name function needs to be finished...
88650>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
88652>>>        String sStmt sSchema sTableName sDriverID
88652>>>        Boolean bExists
88652>>>
88652>>>        Get psDriverID to sDriverID
88653>>>        Get psSchema to sSchema
88654>>>        Get UtilTableHandleToString hTable to sTableName
88655>>>
88655>>>        Function_Return bExists
88656>>>    End_Function
88657>>>
88657>>>    // Function creates the passed Sql script as a ".sql" file in the workspace's
88657>>>    // Home folder, if no path was specified for the filename.
88657>>>    // Mostly for debugging purposes. E.g. to recreate a Sql script that has been
88657>>>    // compiled into the program, when the program is run at other location.
88657>>>//    Function SqlUtilCreateScriptAsFile String sSQLScript String sFileName Returns String
88657>>>//        String sRetval sPath
88657>>>//        Integer iCh
88657>>>//
88657>>>//        Get ParseFolderName sFileName to sPath
88657>>>//        If (Trim(sPath) = "") Begin
88657>>>//            Get psHome of (phoWorkspace(ghoApplication)) to sPath
88657>>>//        End
88657>>>//        Get vFolderFormat sPath to sPath
88657>>>//        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
88657>>>//            Write channel iCh sSQLScript
88657>>>//        Send Seq_Close_Channel iCh
88657>>>//
88657>>>//        Function_Return (sPath + sFileName)
88657>>>//    End_Function
88657>>>
88657>>>    // Enumerate SQL Servers.
88657>>>    // Pass a driver id. Returns a string array.
88657>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
88657>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
88657>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
88659>>>        String[] sReturnArray
88660>>>        Handle hoSQLHandler
88660>>>        String sServer
88660>>>        Integer iCount iNumItems iDataSourceType
88660>>>        Boolean bOK
88660>>>
88660>>>        If (num_arguments > 1) Begin
88662>>>            Move iDatSrcType to iDataSourceType
88663>>>        End
88663>>>>
88663>>>
88663>>>        Case Begin
88663>>>            Case (sDriverID = MSSQLDRV_ID)
88665>>>                Get phoMSSQLHandler to hoSQLHandler
88666>>>                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
88667>>>                    If (iNumItems = 0) Begin
88669>>>                        Get EnumerateServers of hoSQLHandler to iNumItems
88670>>>                    End
88670>>>>
88670>>>                For iCount from 0 to (iNumItems - 1)
88676>>>>
88676>>>                    Get String_Value of hoSQLHandler item iCount to sServer
88677>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
88678>>>                Loop
88679>>>>
88679>>>                Case Break
88680>>>
88680>>>            Case (sDriverID = DB2_DRV_ID)
88683>>>                Get phoDB2SQLHandler to hoSQLHandler
88684>>>                Send SeedDataSources of hoSQLHandler
88685>>>                Move 0 to iCount
88686>>>                Repeat
88686>>>>
88686>>>                    Get DataSources of hoSQLHandler to sServer
88687>>>                    If (sServer <> "") Begin
88689>>>                        Move (Replace(",", sServer, "")) to sServer
88690>>>                        Move sServer to sReturnArray[iCount]
88691>>>                    End
88691>>>>
88691>>>                    Increment iCount
88692>>>                Until (sServer = "")
88694>>>                Case Break
88695>>>
88695>>>            Case (sDriverID = ODBC_DRV_ID)
88698>>>                Get phoODBCSQLHandler to hoSQLHandler
88699>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
88700>>>                Move 0 to iCount
88701>>>                Repeat
88701>>>>
88701>>>                    Get DataSources of hoSQLHandler to sServer
88702>>>                    If (sServer <> "") Begin
88704>>>                        Move (Replace(",", sServer, ", ")) to sServer
88705>>>                        Move sServer to sReturnArray[iCount]
88706>>>                    End
88706>>>>
88706>>>                    Increment iCount
88707>>>                Until (sServer = "")
88709>>>                Case Break
88710>>>
88710>>>            Case (sDriverID = SQLFLEX)
88713>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
88714>>>                Case Break
88715>>>
88715>>>            Case (sDriverID = ORAFLEX)
88718>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
88719>>>                Case Break
88720>>>
88720>>>            // There appearantly is no way to enumerate servers for this backend.
88720>>>            Case (sDriverID = MDSPgSQL)
88723>>>                Move "localhost" to sReturnArray[0]
88724>>>                Case Break
88725>>>
88725>>>            // There appearantly is no way to enumerate servers for this backend.
88725>>>            Case (sDriverID = MDSMySQL)
88728>>>                Move "localhost" to sReturnArray[0]
88729>>>                Case Break
88730>>>
88730>>>            Case Else
88730>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
88731>>>>
88731>>>        Case End
88731>>>
88731>>>        Function_Return sReturnArray
88732>>>    End_Function
88733>>>
88733>>>    // Returns all databases as a string array for the passed driver id.
88733>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
88735>>>        String[] sReturnArray
88736>>>        String sUserID sPassword
88736>>>        Boolean bOK
88736>>>
88736>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88737>>>        If (bOK = False) Begin
88739>>>            Function_Return sReturnArray
88740>>>        End
88740>>>>
88740>>>
88740>>>        Case Begin
88740>>>            Case (sDriverID = MSSQLDRV_ID)
88742>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
88743>>>                Case Break
88744>>>            Case (sDriverID = DB2_DRV_ID)
88747>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
88748>>>                Case Break
88749>>>
88749>>>            // Enumeration of ODBC databases should be irrelevant as the database
88749>>>            // should have been specified when the ODBC source was setup with the ODBC manager.
88749>>>            Case (sDriverID = ODBC_DRV_ID)
88752>>>                Case Break
88753>>>
88753>>>            Case (sDriverID = SQLFLEX)
88756>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
88757>>>                Case Break
88758>>>
88758>>>            Case (sDriverID = MDSPgSQL)
88761>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
88762>>>                Case Break
88763>>>
88763>>>            Case (sDriverID = MDSMySQL)
88766>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
88767>>>                Case Break
88768>>>
88768>>>            Case (sDriverID = ORAFLEX)
88771>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
88772>>>                Case Break
88773>>>
88773>>>            Case Else
88773>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
88774>>>>
88774>>>        Case End
88774>>>
88774>>>        Function_Return sReturnArray
88775>>>    End_Function
88776>>>
88776>>>    // Returns all table spaces as a string array for the passed driver id.
88776>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
88778>>>        String[] sReturnArray
88779>>>        String sServer sUserID sPassword
88779>>>        Boolean bOK
88779>>>
88779>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88780>>>        If (bOK = False) Begin
88782>>>            Function_Return sReturnArray
88783>>>        End
88783>>>>
88783>>>
88783>>>        Case Begin
88783>>>            Case (sDriverID = DB2_DRV_ID)
88785>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
88786>>>                Case Break
88787>>>
88787>>>            Case (sDriverID = MDSPgSQL)
88790>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
88791>>>                Case Break
88792>>>
88792>>>            Case (sDriverID = ORAFLEX)
88795>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
88796>>>                Case Break
88797>>>
88797>>>            Case Else
88797>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
88798>>>>
88798>>>                Case Break
88799>>>        Case End
88799>>>
88799>>>        Function_Return sReturnArray
88800>>>    End_Function
88801>>>
88801>>>    // Returns all schemas as a string array for the passed driver id.
88801>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
88803>>>        String[] sReturnArray
88804>>>        Boolean bOK
88804>>>
88804>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88805>>>        If (bOK = False) Begin
88807>>>            Function_Return sReturnArray
88808>>>        End
88808>>>>
88808>>>
88808>>>        Case Begin
88808>>>            Case (sDriverID = DB2_DRV_ID)
88810>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
88811>>>                Case Break
88812>>>
88812>>>            Case (sDriverID = MDSPgSQL)
88815>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
88816>>>                Case Break
88817>>>
88817>>>            Case (sDriverID = ORAFLEX)
88820>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
88821>>>                Case Break
88822>>>
88822>>>            Case Else
88822>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
88823>>>>
88823>>>                Case Break
88824>>>        Case End
88824>>>
88824>>>        Function_Return sReturnArray
88825>>>    End_Function
88826>>>
88826>>>    // Returns a string array with all tables for the current database.
88826>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
88828>>>        String[] sReturnArray sArray
88830>>>        String sServer sDatabase sConnectionString sSelect sSchema
88830>>>        Integer iSize iCount
88830>>>        Boolean bOK
88830>>>
88830>>>        If (sDriverID = DATAFLEX_ID) Begin
88832>>>            Function_Return sArray
88833>>>        End
88833>>>>
88833>>>
88833>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88834>>>        If (bOK = False) Begin
88836>>>            Function_Return sReturnArray
88837>>>        End
88837>>>>
88837>>>
88837>>>        Get psConnectionString to sConnectionString
88838>>>        Get psDatabase to sDatabase
88839>>>        Get psSchema   to sSchema
88840>>>
88840>>>        Case Begin
88840>>>            Case (sDriverID = MSSQLDRV_ID)
88842>>>                Get _SqlTableArrayDAW to sReturnArray
88843>>>                Case Break
88844>>>
88844>>>            Case (sDriverID = DB2_DRV_ID)
88847>>>                Get _SqlTableArrayDAW to sReturnArray
88848>>>                Case Break
88849>>>
88849>>>            Case (sDriverID = ODBC_DRV_ID)
88852>>>                Get _SqlTableArrayDAW to sReturnArray
88853>>>                Case Break
88854>>>
88854>>>            Case (sDriverID = SQLFLEX)
88857>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
88858>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
88859>>>                Case Break
88860>>>
88860>>>            Case (sDriverID = MDSMySQL)
88863>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
88864>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
88865>>>                Case Break
88866>>>
88866>>>            Case (sDriverID = MDSPgSQL)
88869>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
88870>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
88871>>>                Case Break
88872>>>
88872>>>            Case (sDriverID = ORAFLEX)
88875>>>                Move "SELECT table_name from user_tables" to sSelect
88876>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
88877>>>                Move (SizeOfArray(sArray)) to iSize
88878>>>                Decrement iSize
88879>>>                For iCount from 0 to iSize
88885>>>>
88885>>>                    If (not(sArray[iCount] contains "$")) Begin
88887>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
88888>>>                    End
88888>>>>
88888>>>                Loop
88889>>>>
88889>>>                Case Break
88890>>>
88890>>>            Case Else
88890>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
88891>>>>
88891>>>                Case Break
88892>>>        Case End
88892>>>
88892>>>        Function_Return sReturnArray
88893>>>    End_Function
88894>>>
88894>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
88894>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
88896>>>        String[] sReturnArray
88897>>>        String sServer sConnectionString sSelect sSchema
88897>>>        Boolean bOK
88897>>>
88897>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88898>>>        If (bOK = False) Begin
88900>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
88901>>>>
88901>>>            Function_Return sReturnArray
88902>>>        End
88902>>>>
88902>>>
88902>>>        Get psConnectionString to sConnectionString
88903>>>        Get psSchema to sSchema
88904>>>
88904>>>        Case Begin
88904>>>            Case (sDriverID = MSSQLDRV_ID)
88906>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
88907>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
88908>>>                Case Break
88909>>>
88909>>>            Case (sDriverID = DB2_DRV_ID)
88912>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
88913>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
88914>>>                Case Break
88915>>>
88915>>>            Case (sDriverID = SQLFLEX)
88918>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
88919>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
88920>>>                Case Break
88921>>>
88921>>>            Case (sDriverID = MDSMySQL)
88924>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
88925>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
88926>>>                Case Break
88927>>>
88927>>>            Case (sDriverID = MDSPgSQL)
88930>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
88931>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
88932>>>                Case Break
88933>>>
88933>>>            Case (sDriverID = ORAFLEX)
88936>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
88937>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
88938>>>                Case Break
88939>>>
88939>>>            Case Else
88939>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
88940>>>>
88940>>>                Case Break
88941>>>        Case End
88941>>>
88941>>>        Function_Return sReturnArray
88942>>>    End_Function
88943>>>
88943>>>
88943>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
88943>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
88945>>>        String[] sReturnArray sReturnArray2
88947>>>        String sServer sConnectionString sSelect sSchema
88947>>>        Boolean bOK
88947>>>        Integer iCount iSize
88947>>>
88947>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88948>>>        If (bOK = False) Begin
88950>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
88951>>>>
88951>>>            Function_Return sReturnArray
88952>>>        End
88952>>>>
88952>>>
88952>>>        Get psConnectionString to sConnectionString
88953>>>        Get psSchema to sSchema
88954>>>
88954>>>        Case Begin
88954>>>            Case (sDriverID = MSSQLDRV_ID)
88956>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
88957>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
88958>>>                Case Break
88959>>>
88959>>>            Case (sDriverID = DB2_DRV_ID)
88962>>>                Error "Not implemented yet! The select statement has not been finalized."
88963>>>>
88963>>>//                Move () to sSelect
88963>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
88963>>>                Case Break
88964>>>
88964>>>            Case (sDriverID = SQLFLEX)
88967>>>                Error "Not implemented yet! The select statement has not been finalized."
88968>>>>
88968>>>//                Move () to sSelect
88968>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
88968>>>                Case Break
88969>>>
88969>>>            Case (sDriverID = MDSMySQL)
88972>>>                Error "Not implemented yet! The select statement has not been finalized."
88973>>>>
88973>>>//                Move () to sSelect
88973>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
88973>>>                Case Break
88974>>>
88974>>>            Case (sDriverID = MDSPgSQL)
88977>>>                Error "Not implemented yet! The select statement has not been finalized."
88978>>>>
88978>>>//                Move () to sSelect
88978>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
88978>>>                Case Break
88979>>>
88979>>>            Case (sDriverID = ORAFLEX)
88982>>>                Error "Not implemented yet! The select statement has not been finalized."
88983>>>>
88983>>>//                Move () to sSelect
88983>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
88983>>>                Case Break
88984>>>
88984>>>            Case Else
88984>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
88985>>>>
88985>>>                Case Break
88986>>>        Case End
88986>>>
88986>>>        Move (SizeOfArray(sReturnArray)) to iSize
88987>>>        Decrement iSize
88988>>>        For iCount from 0 to iSize
88994>>>>
88994>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
88996>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
88997>>>            End
88997>>>>
88997>>>        Loop
88998>>>>
88998>>>
88998>>>        Function_Return sReturnArray2
88999>>>    End_Function
89000>>>
89000>>>    // Returns a string array with all table names the passed table handle has relation ships with.
89000>>>    // The format of the array is "TableName.FieldName"
89000>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
89002>>>        String[] sFileNameArray sFieldNameArray
89004>>>        tSQLRelation[] sRelationsArray
89004>>>        tSQLRelation[] sRelationsArray
89005>>>        String sServer sConnectionString sSelect sSchema sFileName sFieldName sVal
89005>>>        Boolean bOK
89005>>>        Integer iCount iSize iLength iPos
89005>>>        Integer iFileNumber iFieldNumber
89005>>>
89005>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89006>>>        If (bOK = False) Begin
89008>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
89009>>>>
89009>>>            Function_Return sRelationsArray
89010>>>        End
89010>>>>
89010>>>
89010>>>        Get psConnectionString to sConnectionString
89011>>>        Get psSchema to sSchema
89012>>>
89012>>>        Case Begin
89012>>>            Case (sDriverID = MSSQLDRV_ID)
89014>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
89015>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
89016>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89017>>>                Case Break
89018>>>
89018>>>            Case (sDriverID = DB2_DRV_ID)
89021>>>                Error "Not implemented yet! The select statement has not been finalized."
89022>>>>
89022>>>//                Move () to sSelect
89022>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
89022>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89022>>>                Case Break
89023>>>
89023>>>            Case (sDriverID = SQLFLEX)
89026>>>                Error "Not implemented yet! The select statement has not been finalized."
89027>>>>
89027>>>//                Move () to sSelect
89027>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89027>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89027>>>                Case Break
89028>>>
89028>>>            Case (sDriverID = MDSMySQL)
89031>>>                Error "Not implemented yet! The select statement has not been finalized."
89032>>>>
89032>>>//                Move () to sSelect
89032>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89032>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89032>>>                Case Break
89033>>>
89033>>>            Case (sDriverID = MDSPgSQL)
89036>>>                Error "Not implemented yet! The select statement has not been finalized."
89037>>>>
89037>>>//                Move () to sSelect
89037>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
89037>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89037>>>                Case Break
89038>>>
89038>>>            Case (sDriverID = ORAFLEX)
89041>>>                Error "Not implemented yet! The select statement has not been finalized."
89042>>>>
89042>>>//                Move () to sSelect
89042>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
89042>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
89042>>>                Case Break
89043>>>
89043>>>            Case Else
89043>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
89044>>>>
89044>>>                Case Break
89045>>>        Case End
89045>>>
89045>>>        Move (Length(sTableName)) to iLength
89046>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
89047>>>        Move (SizeOfArray(sFileNameArray)) to iSize
89048>>>        Decrement iSize
89049>>>        For iCount from 0 to iSize
89055>>>>
89055>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
89057>>>                Move sFileNameArray[iCount]         to sFileName
89058>>>                Move sFieldNameArray[iCount]        to sFieldName
89059>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
89060>>>                Move sFileName  to sRelationsArray[iCount].sFileName
89061>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
89062>>>            End
89062>>>>
89062>>>        Loop
89063>>>>
89063>>>
89063>>>        Function_Return sRelationsArray
89064>>>    End_Function
89065>>>
89065>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
89067>>>        tSQLLoggedInUser[] SQLLoggedInUser
89067>>>        tSQLLoggedInUser[] SQLLoggedInUser
89068>>>        String[] sUsers sPrograms
89070>>>        String sSelect
89070>>>        Integer iSize iCount
89070>>>
89070>>>        Case Begin
89070>>>            Case (sDriverID = MSSQLDRV_ID)
89072>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
89073>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
89074>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
89075>>>                Case Break
89076>>>            Case (sDriverID = SQLFLEX)
89079>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
89080>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
89081>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
89082>>>                Case Break
89083>>>            Case Else
89083>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
89084>>>>
89084>>>        Case End
89084>>>
89084>>>        Move (SizeOfArray(sUsers)) to iSize
89085>>>        Decrement iSize
89086>>>        For iCount from 0 to iSize
89092>>>>
89092>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
89093>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
89094>>>        Loop
89095>>>>
89095>>>
89095>>>        Function_Return SQLLoggedInUser
89096>>>    End_Function
89097>>>
89097>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
89097>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
89097>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
89099>>>        String[] sFilesData
89100>>>        Boolean bExists
89100>>>        Integer iCh
89100>>>        String sFileName sExt
89100>>>
89100>>>        Get vFolderExists sDataPath to bExists
89101>>>        If (bExists = True) Begin
89103>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
89104>>>            Move ("dir:" + sDataPath)      to sDataPath
89105>>>            Get Seq_New_Channel to iCh  // get free channel for input
89106>>>            Direct_Input channel iCh sDataPath
89108>>>                Repeat
89108>>>>
89108>>>                    Readln channel iCh sFileName
89110>>>                    Get ParseFileExtension sFileName to sExt
89111>>>                    If (Uppercase(sExt) = "INT") Begin
89113>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
89115>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
89116>>>                        End
89116>>>>
89116>>>                    End
89116>>>>
89116>>>                Until (SeqEof = True)
89118>>>            Close_Input channel iCh
89120>>>        End
89120>>>>
89120>>>        Function_Return sFilesData
89121>>>    End_Function
89122>>>
89122>>>    // Returns a handle to the SQL server associated with the passed driver ID.
89122>>>    // Pass e.g. the psServer property to determine the current connection server.
89122>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
89122>>>    // This handle can be used to obtain attributes about the server, such as default
89122>>>    // column types.
89122>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
89124>>>        Handle hDatabase
89124>>>        Integer iDriver iServers iCount
89124>>>        String sValue
89124>>>
89124>>>        If (sServer = "") Begin
89126>>>            Function_Return 0
89127>>>        End
89127>>>>
89127>>>
89127>>>        Get DriverIndex sDriverID to iDriver
89128>>>        If (iDriver = 0) Begin
89130>>>            Function_Return 0
89131>>>        End
89131>>>>
89131>>>
89131>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
89134>>>        For iCount from 1 to iServers
89140>>>>
89140>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
89143>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
89145>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
89148>>>            End
89148>>>>
89148>>>        Loop
89149>>>>
89149>>>
89149>>>        Function_Return hDatabase
89150>>>    End_Function
89151>>>
89151>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
89153>>>        String sConnectionString sMessage
89153>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
89153>>>        Integer i iMsgs iFetchResult iResultCount iRowType iRows iErr iMessage iLastErr
89153>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
89156>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
89156>>>        TimeSpan tsQuery tsFetch
89156>>>        tSqlErrorArray aSqlErrorArray
89156>>>        tSqlErrorArray aSqlErrorArray
89156>>>        Boolean bOK bMertechDriver bShowProgress
89156>>>        tSQLConnection SQLConnection
89156>>>        tSQLConnection SQLConnection
89156>>>
89156>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89157>>>        If (bOK = False) Begin
89159>>>            Procedure_Return
89160>>>        End
89160>>>>
89160>>>
89160>>>        If (num_arguments > 2) Begin
89162>>>            Move bShowProgr to bShowProgress
89163>>>        End
89163>>>>
89163>>>
89163>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89164>>>
89164>>>        Get IsMertechDriver sDriverID to bMertechDriver
89165>>>        If (bMertechDriver = True) Begin
89167>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
89168>>>        End
89168>>>>
89168>>>        If (bMertechDriver = False) Begin
89170>>>            Get phoSQLManager to hoSqlHandler
89171>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
89172>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
89173>>>        End
89173>>>>
89173>>>
89173>>>        If (hoSQLConnect <> 0) Begin
89175>>>            Get SqlOpen of hoSQLConnect to hoStmt
89176>>>            If (hoStmt <> 0) Begin
89178>>>                // record starting date/time stamp
89178>>>                Move (CurrentDateTime()) to dtQueryExecStart
89179>>>                // turn on error handling if enabled
89179>>>                If (pbHandleQueryErrors(Self)) Begin
89181>>>                    Set pbSqlError to False
89182>>>                    Set paSqlErrorArray to aSqlErrorArray
89183>>>                    Move Error_Object_Id to hoError
89184>>>                    Move Self to Error_Object_Id
89185>>>                End
89185>>>>
89185>>>
89185>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
89185>>>                Set psSQLStatementString to sStmt
89186>>>                Send SqlExecDirect of hoStmt sStmt
89187>>>
89187>>>                If (pbHandleQueryErrors(Self)) Begin
89189>>>                    Move hoError to Error_Object_Id
89190>>>                End
89190>>>>
89190>>>
89190>>>                Move 0 to iMsgs
89191>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
89191>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
89191>>>                If (bMertechDriver = False) Begin
89193>>>                    Move Err to iErr
89194>>>                    Move LastErr to iLastErr
89195>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
89196>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
89197>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
89198>>>                    Send _SqlColumnInfo hoStmt
89199>>>                    Send Ignore_Error of Error_Object_Id 12289
89200>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89201>>>                    Repeat
89201>>>>
89201>>>                        Get SqlFetch of hoStmt to iFetchResult
89202>>>                        If (iFetchResult <> 0) Begin
89204>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
89205>>>                        End
89205>>>>
89205>>>                    Until (iFetchResult = 0)
89207>>>                    Send Trap_Error of Error_Object_Id 12289
89208>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
89209>>>                    Move iErr to Err
89210>>>                    Move iLastErr to LastErr
89211>>>                    Set paSQLFetchResults to aSQLFetchResults
89212>>>                End
89212>>>>
89212>>>
89212>>>                Set piRows    to iRows
89213>>>                Set piRowType to iRowType
89214>>>                Move (CurrentDateTime()) to dtQueryExecEnd
89215>>>                Move (CurrentDateTime()) to dtFetchStart
89216>>>
89216>>>                If (iMsgs <> 0) Begin
89218>>>                    If (ghoDbUpdateHandler > 0) Begin
89220>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89221>>>                    End
89221>>>>
89221>>>                    For i from 1 to iMsgs
89227>>>>
89227>>>                        Get SqlGetMessage of hoStmt i to sMessage
89228>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
89229>>>                        If (bShowProgress = True) Begin
89231>>>                            If (Active_State(ghoStatusPanel)) Begin
89233>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
89234>>>                            End
89234>>>>
89234>>>                            Else Begin
89235>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
89237>>>                            End
89237>>>>
89237>>>                        End
89237>>>>
89237>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
89238>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
89239>>>                    Loop
89240>>>>
89240>>>                    If (ghoDbUpdateHandler > 0) Begin
89242>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89243>>>                    End
89243>>>>
89243>>>                    Set paQueryMessages to sMsg
89244>>>                End
89244>>>>
89244>>>                Move (CurrentDateTime()) to dtFetchEnd
89245>>>            End
89245>>>>
89245>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
89246>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
89247>>>            Set ptsQueryExec to tsQuery
89248>>>            Set ptsFetchResults to tsFetch
89249>>>            Send SqlClose of hoStmt
89250>>>        End
89250>>>>
89250>>>
89250>>>        Send SqlDisconnect of hoSQLConnect
89251>>>    End_Procedure
89252>>>
89252>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
89252>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
89252>>>    // Returns False if no error occured.
89252>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
89254>>>        Boolean bOK bShowProgress
89254>>>        tSQLScriptArray SQLScriptArray
89254>>>        tSQLScriptArray SQLScriptArray
89254>>>        Integer iOut iRows iCount
89254>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
89254>>>        TimeSpan tsTotalTime
89254>>>        String sMessage
89254>>>
89254>>>        Move (CurrentDateTime()) to dtTotalQueryStart
89255>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
89256>>>        If (SQLScriptArray.bError = True) Begin
89258>>>            Function_Return False
89259>>>        End
89259>>>>
89259>>>
89259>>>        If (num_arguments > 3) Begin
89261>>>            Move bShowProgr to bShowProgress
89262>>>        End
89262>>>>
89262>>>
89262>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89263>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
89264>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89265>>>
89265>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
89267>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
89268>>>>
89268>>>        End
89268>>>>
89268>>>
89268>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
89269>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
89270>>>        Set ptsTotalQueryTime to tsTotalTime
89271>>>
89271>>>        Function_Return bOK
89272>>>    End_Procedure
89273>>>
89273>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
89273>>>//        String sRootName
89273>>>//        Boolean bOK
89273>>>//
89273>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89273>>>//        Move (sRootName contains sDriverID) to bOK
89273>>>//
89273>>>//        Function_Return bOK
89273>>>//    End_Function
89273>>>
89273>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
89273>>>//        String sDriverID sRootName sDisplayName sSchema sVal
89273>>>//        Integer iDbType
89273>>>//        Boolean bOK
89273>>>//
89273>>>//        Get UtilIsFilelistEntryDriverBased to bOK
89273>>>//        If (bOK = True) Begin
89273>>>//            Function_Return False
89273>>>//        End
89273>>>//
89273>>>//        Get psDriverID to sDriverID
89273>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89273>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
89273>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89273>>>//
89273>>>//        Get psDriverID to sDriverID
89273>>>//        Get piDbType   to iDbType
89273>>>//        Get psSchema   to sSchema
89273>>>//        If (sSchema = "") Begin
89273>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
89273>>>//        End
89273>>>//
89273>>>//        Move (Uppercase(sDisplayName)) to sVal
89273>>>//        If (not(sVal contains (sSchema + "."))) Begin
89273>>>//            If (iDbType = EN_dbTypeDB2) Begin
89273>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
89273>>>//            End
89273>>>//            Else Begin
89273>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
89273>>>//            End
89273>>>//        End
89273>>>//
89273>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89273>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89273>>>//
89273>>>//        Function_Return True
89273>>>//    End_Function
89273>>>
89273>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
89273>>>    // from the passed filelist.
89273>>>    // Returns the number of tables affected.
89273>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
89275>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
89275>>>        Integer iRetval
89275>>>        Handle hTable
89275>>>
89275>>>        // We first save the current filelist as the passed filelist name
89275>>>        // may come from another workspace, to restore it when we're ready.
89275>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
89278>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
89281>>>        Move 0 to hTable
89282>>>        Move 0 to iRetval
89283>>>
89283>>>        Repeat
89283>>>>
89283>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89286>>>            If (hTable <> 0) Begin
89288>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89291>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89294>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89297>>>                Move (Uppercase(sRootName)) to sVal
89298>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
89300>>>                    // Prefixes:
89300>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
89301>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
89302>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
89303>>>                    // Suffixes:
89303>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
89304>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
89305>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
89306>>>
89306>>>                    // Change Filelist entry:
89306>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
89309>>>
89309>>>                    Move (Lowercase(sDisplayName)) to sVal
89310>>>                    If (sVal contains "dbo.") Begin
89312>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
89313>>>
89313>>>                        // Change Filelist entry:
89313>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
89316>>>                    End
89316>>>>
89316>>>                    Increment iRetval
89317>>>                End
89317>>>>
89317>>>            End
89317>>>>
89317>>>        Until (hTable = 0)
89319>>>
89319>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
89322>>>
89322>>>        Function_Return iRetval
89323>>>    End_Function
89324>>>
89324>>>    // To open all Sql based tables in Filelist.cfg
89324>>>    Procedure SqlUtilOpenAllTables
89326>>>        Handle hTable
89326>>>        String sRoot sDriverID
89326>>>        Boolean bOK
89326>>>
89326>>>        Move 0 to hTable
89327>>>        Move "" to sDriverID
89328>>>        Get AutoConnectionIDLogin to bOK
89329>>>
89329>>>        Repeat
89329>>>>
89329>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89332>>>            If (hTable > 0) Begin
89334>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89337>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
89339>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
89342>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
89344>>>                        Open hTable
89346>>>                    End
89346>>>>
89346>>>                End
89346>>>>
89346>>>            End
89346>>>>
89346>>>
89346>>>        Until (hTable = 0)
89348>>>    End_Procedure
89349>>>
89349>>>    // This function allows you to put an Sql script in a CM Image. It makes it easier to
89349>>>    // copy and paste between a DataFlex program and an Sql Editor.
89349>>>    Function SqlUtilLoadImageFile String sFileName Returns String
89351>>>        Integer iChannel iPos
89351>>>        String sTextValue sLine sPath
89351>>>        Boolean bSeqEof
89351>>>
89351>>>        Move "" to sTextValue
89352>>>        Get ParseFolderName sFileName to sPath
89353>>>        If (Trim(sPath) = "") Begin
89355>>>            Get psDataPathFirstPart to sPath
89356>>>            Move (sPath + sFileName) to sFileName
89357>>>        End
89357>>>>
89357>>>
89357>>>        Get Seq_New_Channel to iChannel
89358>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89360>>>            Error DFERR_PROGRAM "No channel available..."
89361>>>>
89361>>>        End
89361>>>>
89361>>>        Else Begin
89362>>>            Direct_Input channel iChannel sFileName
89364>>>            Move (SeqEof) to bSeqEof
89365>>>            If (bSeqEof = True) Begin
89367>>>                Send Seq_Release_Channel iChannel
89368>>>                Set psSQLStatementString to ""
89369>>>                Error DFERR_PROGRAM ("The Sql script file:\n" + sFileName + "\nCould not be found.")
89370>>>>
89370>>>                Function_Return ""
89371>>>            End
89371>>>>
89371>>>
89371>>>            While (not(bSeqEof))
89375>>>                Readln channel iChannel sLine
89377>>>                Move (Pos("/", sLine)) to iPos
89378>>>                Move (SeqEol) to bSeqEof
89379>>>                If (not(bSeqEof) and iPos <> 1) Begin
89381>>>                    Move (sTextValue + sLine + Character(13)) to sTextValue
89382>>>                End
89382>>>>
89382>>>            Loop
89383>>>>
89383>>>            Send Seq_Release_Channel iChannel
89384>>>        End
89384>>>>
89384>>>
89384>>>        Set psSQLStatementString to sTextValue
89385>>>        Function_Return sTextValue
89386>>>    End_Function
89387>>>
89387>>>    // Reads an Sql script that have been compiled into the program as an "image" (/MyImageName) and returns the full script as a string.
89387>>>    // Usage: Get SqlUtilReadScriptFromCMImage of ghoDbUpdateFunctionLibrary CreatevwWorkflowInbox.n
89387>>>    //
89387>>>    // This is a trick to use an old DataFlex feature/syntax to include "image names" at the top
89387>>>    // of a file. Each such section must end with a "/*".
89387>>>    // Note: Sql script files remarks/comments cannot be handled by the DataFlex compiler. All Sql comment
89387>>>    //       sections in the "xxx.pkg.sql" file _must_ be removed.
89387>>>//    Function SqlUtilReadScriptFromCMImage Integer iImg Returns tSQLScriptResult
89387>>>//        Integer iChannel iPos
89387>>>//        String sTextValue sLine
89387>>>//        Boolean bSeqEof
89387>>>//        tSQLScriptResult SqlScriptResult
89387>>>//
89387>>>//        Move "" to sTextValue
89387>>>//
89387>>>//        Get Seq_New_Channel to iChannel
89387>>>//        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89387>>>//            Error DFERR_PROGRAM "No channel available..."
89387>>>//            Function_Return ""
89387>>>//        End
89387>>>//
89387>>>//        Get SqlUtilCheckScriptSize False "" iImg True to SqlScriptResult
89387>>>//
89387>>>//        Direct_Input channel iChannel ("image: " + String(iImg))
89387>>>//        Move (SeqEof) to bSeqEof
89387>>>//        While (not(bSeqEof))
89387>>>//            Readln channel iChannel sLine
89387>>>//            Move (SeqEol) to bSeqEof
89387>>>//            If (not(bSeqEof)) Begin
89387>>>//                Move (Trim(sLine)) to sLine
89387>>>//                If (Left(sLine, 2) <> (Character(47) + Character(47))) Begin // ASCII 47 = "/" (Comments)
89387>>>//                    Move (sTextValue + sLine + character(13)) to sTextValue
89387>>>//                End
89387>>>//            End
89387>>>//        Loop
89387>>>//        Send Seq_Release_Channel iChannel
89387>>>//
89387>>>//        Set psSQLStatementString to sTextValue
89387>>>//        Move sTextValue to SqlScriptResult.sSQLScript
89387>>>//        Function_Return SqlScriptResult
89387>>>//    End_Function
89387>>>
89387>>>//    Function SqlUtilSchemaName Handle hTable Returns String
89387>>>//        String sRetval sDriverID
89387>>>//        String sTableName
89387>>>//        Integer iDbType iIndex
89387>>>//        Boolean bOK
89387>>>//
89387>>>//        Get psDriverID to sDriverID
89387>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
89387>>>//        If (hTable = 0 or bOK = False) Begin
89387>>>//            Function_Return ""
89387>>>//        End
89387>>>//
89387>>>//        Move False to Err
89387>>>//        Get UtilTableHandleToString hTable to sTableName
89387>>>//        Get piDbType to iDbType
89387>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
89387>>>//        If (iIndex = -1) Begin
89387>>>//            Function_Return ""
89387>>>//        End
89387>>>//
89387>>>//        Function_Return sRetval
89387>>>//    End_Function
89387>>>
89387>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
89389>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
89389>>>        Boolean bOpened bOK bMertech
89389>>>        
89389>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89392>>>        Get _TableNameOnly sRootName to sDatabaseName
89393>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
89393>>>        // which makes the program unable to run because they can't be opened.
89393>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
89393>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
89393>>>        // proper .int files for the two tables.
89393>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
89395>>>            Function_Return True
89396>>>        End                     
89396>>>>
89396>>>        
89396>>>        Move CS_OEM_Txt  to sOrgFormat
89397>>>        Move CS_ANSI_Txt to sNewFormat
89398>>>        Get AutoConnectionIDLogin to bOK
89399>>>        Send Ignore_Error of Error_Object_Id DFERR_MISSING_VALUE
89400>>>        Open hTable
89402>>>        Send Trap_Error of Error_Object_Id DFERR_MISSING_VALUE
89403>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89406>>>
89406>>>        // ToDo: What to do if we cannot open the table?!
89406>>>        If (bOpened = False) Begin
89408>>>            Function_Return False
89409>>>        End
89409>>>>
89409>>>
89409>>>        Get psDriverID to sDriverID
89410>>>        Get IsMertechDriver sDriverID to bMertech
89411>>>        If (bMertech = True) Begin
89413>>>            Get psDataPathFirstPart to sDataPath
89414>>>            Get vFolderExists sDataPath to bOK
89415>>>            If (bOK = False) Begin
89417>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
89418>>>>
89418>>>                Function_Return False
89419>>>            End
89419>>>>
89419>>>            Get vFolderFormat sDataPath to sDataPath
89420>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89423>>>            Get _TableNameOnly sRootName to sDatabaseName
89424>>>            Move sDatabaseName to sPhysicalFileName
89425>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
89426>>>            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
89427>>>            Function_Return (bOK = True)
89428>>>        End
89428>>>>
89428>>>
89428>>>        Move False to Err
89429>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
89432>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
89433>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
89433>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
89433>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
89434>>>
89434>>>        Structure_Start hTable
89435>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
89438>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
89441>>>        Structure_End hTable (DF_STRUCTEND_OPT_IN_PLACE ior DF_STRUCTEND_OPT_FORCE)
89443>>>
89443>>>        Function_Return (Err = False)
89444>>>    End_Function
89445>>>
89445>>>    // Checks if the passed Table;
89445>>>    // 1) Already has a Filelist entry that points to SQL and
89445>>>    // 2) It has an .int file.
89445>>>    // If both is True it should already be connected to SQL
89445>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
89447>>>        Boolean bExists bRootName
89447>>>        String sRootName sDataPath
89447>>>        Integer iCount
89447>>>
89447>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89450>>>        Move (sRootName contains sDriverID) to bRootName
89451>>>
89451>>>        Get psDataPathFirstPart to sDataPath
89452>>>        Get vFolderExists sDataPath to bExists
89453>>>        If (bExists = False) Begin
89455>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
89455>>>            Function_Return False
89456>>>        End
89456>>>>
89456>>>
89456>>>        Get vFolderFormat sDataPath to sDataPath
89457>>>        Get _TableNameOnly sRootName to sRootName
89458>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
89459>>>
89459>>>        Function_Return (bRootName = True and bExists = True)
89460>>>    End_Function
89461>>>
89461>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
89463>>>        Boolean bViewTableType bOpen bMertechDriver bOK
89463>>>        Integer hoSQLHandler
89463>>>        Integer iTableCount iNumTables iPos iTableIndex
89463>>>        String sTableName sOwner sTableType sLogin sEnumTableName sEnumSchemaName sCurrent_Login
89463>>>        Handle hoCliHandler
89463>>>        tSQLConnection SQLConnection
89463>>>        tSQLConnection SQLConnection
89463>>>
89463>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89466>>>        If (bOpen = False) Begin
89468>>>            Get AutoConnectionIDLogin to bOK
89469>>>            Open hTable
89471>>>        End
89471>>>>
89471>>>
89471>>>        Get pSQLConnection to SQLConnection
89472>>>        Get phoCLIHandler to hoCliHandler
89473>>>        Set psDriverID of hoCliHandler to sDriverID
89474>>>
89474>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
89477>>>        Get _TableNameOnly sTableName to sTableName
89478>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
89481>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
89482>>>
89482>>>        For iTableCount from 1 to iNumTables
89488>>>>
89488>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
89489>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
89490>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
89492>>>                Get TableType of hoCliHandler iTableCount to sTableType
89493>>>                Move iNumTables to iTableCount // We're done.
89494>>>            End
89494>>>>
89494>>>        Loop
89495>>>>
89495>>>
89495>>>        Move (sTableType = "VIEW") to bViewTableType
89496>>>        If (bOpen = False) Begin
89498>>>            Close hTable
89499>>>        End
89499>>>>
89499>>>
89499>>>        Function_Return bViewTableType
89500>>>    End_Function
89501>>>
89501>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
89501>>>    //
89501>>>    // SQL utility function that returns a database type (string) constant
89501>>>    // corresponding to the passed iDbType.
89501>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
89503>>>        String sRetval
89503>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
89504>>>        Function_Return sRetval
89505>>>    End_Function
89506>>>
89506>>>    // SQL utility function that returns a database type constant (integer)
89506>>>    // corresponding to the passed sDbType string constant.
89506>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
89508>>>        Integer iRetval
89508>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
89509>>>        Function_Return iRetval
89510>>>    End_Function
89511>>>
89511>>>    // Pass an integer DbType and function returns the database type integer as a string value.
89511>>>    // Used e.g. when reading a connection ini-file to display the database type in
89511>>>    // the SQL Connection program's grid.
89511>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
89513>>>        String sRetval
89513>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
89514>>>        Function_Return sRetval
89515>>>    End_Function
89516>>>
89516>>>    // Pass a driver name as a string and the function will return
89516>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
89516>>>    // quite work and always returns "MS SQL Server"
89516>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
89518>>>        Integer iRetval
89518>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
89519>>>        Function_Return iRetval
89520>>>    End_Function
89521>>>
89521>>>    // *** Helper Functions ***
89521>>>    // They all start with an underscore: "_" in the function name.
89521>>>    //
89521>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
89521>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
89521>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
89521>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
89523>>>        Integer iChannel iArgumentSize iOut iChunk iPointer iCount iSize
89523>>>        Number nByteCount
89523>>>        String sCharacter sSQLScript
89523>>>        Boolean bSeqEof
89523>>>        tSQLScriptArray SqlScriptArray
89523>>>        tSQLScriptArray SqlScriptArray
89523>>>        UChar[] uCharData
89524>>>
89524>>>        Move False to Err
89525>>>        Get Seq_New_Channel to iChannel
89526>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89528>>>            Error DFERR_PROGRAM 'No channel available...'
89529>>>>
89529>>>            Move True to SqlScriptArray.bError
89530>>>            Function_Return SqlScriptArray
89531>>>        End
89531>>>>
89531>>>
89531>>>        // First decide the size of the script
89531>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
89533>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
89535>>>        Close_Input channel iChannel
89537>>>
89537>>>        Move (SizeOfArray(uCharData)) to nByteCount
89538>>>        If (nByteCount  < 1) Begin
89540>>>            Send Seq_Release_Channel iChannel
89541>>>            Move True to SqlScriptArray.bError
89542>>>            Function_Return SqlScriptArray
89543>>>        End
89543>>>>
89543>>>
89543>>>        // If necessary change the string argument_size
89543>>>        Get_Argument_Size to iArgumentSize
89544>>>        If (nByteCount >= iArgumentSize) Begin
89546>>>            Move (nByteCount + 2048) to nByteCount
89547>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
89548>>>>
89548>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
89549>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
89550>>>        End
89550>>>>
89550>>>        Else Begin
89551>>>            Move False to SqlScriptArray.bArgumentSizeChanged
89552>>>        End
89552>>>>
89552>>>
89552>>>        // Read the script file from memory line-by-line
89552>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
89554>>>            Move 0 to iCount
89555>>>            Repeat
89555>>>>
89555>>>                Readln channel iChannel sSQLScript
89557>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
89558>>>                Increment iCount
89559>>>            Until (SeqEof = True)
89561>>>        Close_Input channel iChannel
89563>>>        Send Seq_Release_Channel iChannel
89564>>>
89564>>>        // Finally "sanitize" the script by removing all comments.
89564>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
89565>>>
89565>>>        Function_Return SqlScriptArray
89566>>>    End_Function
89567>>>
89567>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
89569>>>        String sSQLVal sStmt sCR sDebugFileName sTmp sGOKeyWord sNoCountKeyWord sMessage sExportFile
89569>>>        Handle hoSql hoSQLConnect hoStmt hoError
89569>>>        Integer i iMsgs iFetchResult iResultCount iRows iRowType iCount iChunkCounter iChunkMax iPos iOut iNextSet iMessage
89569>>>        String[] sMsg aSQLQueryMessages
89571>>>        DateTime dtQueryExecStart dtQueryExecEnd
89571>>>        TimeSpan tsQuery
89571>>>        tSqlErrorArray aSqlErrorArray
89571>>>        tSqlErrorArray aSqlErrorArray
89571>>>        tSQLConnection SQLConnection
89571>>>        tSQLConnection SQLConnection
89571>>>        Boolean bOK bMertechDriver bShowProgress
89571>>>
89571>>>        If (num_arguments > 4) Begin
89573>>>            Move bShowProgr to bShowProgress
89574>>>        End
89574>>>>
89574>>>        Get IsMertechDriver sDriverID to bMertechDriver
89575>>>        If (bMertechDriver = False) Begin
89577>>>            Get phoSQLManager to hoSql
89578>>>        End
89578>>>>
89578>>>        Else Begin
89579>>>            Get _MertechSQLManagerHandle to hoSql
89580>>>        End
89580>>>>
89580>>>
89580>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
89581>>>        // There seems to be a problem to pass strings when their value gets really big, aka
89581>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
89581>>>        // or later SqlExecDirect stops working correctly with no error messages!
89581>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
89581>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
89581>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
89581>>>        Get piChunkMax to iChunkMax
89582>>>        Move 0 to iChunkCounter
89583>>>        Move "" to sStmt
89584>>>
89584>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
89585>>>        Move (Character(13) + Character(10)) to sCR
89586>>>
89586>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89587>>>
89587>>>        If (bMertechDriver = True) Begin
89589>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
89590>>>        End
89590>>>>
89590>>>        If (bMertechDriver = False) Begin
89592>>>            Get phoSQLManager  to hoSQL
89593>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
89594>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
89595>>>        End
89595>>>>
89595>>>
89595>>>        If (hoSQLConnect <> 0) Begin
89597>>>            Move False to Err
89598>>>            Get SqlOpen of hoSQLConnect to hoStmt
89599>>>            If (hoStmt <> 0) Begin
89601>>>
89601>>>                // If the embedded resource should be written as a script file to disk:
89601>>>                If (bCreateScriptFile = True) Begin
89603>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
89604>>>                    Get vFolderFormat sExportFile to sExportFile
89605>>>                    Move (sExportFile + sMemFileName) to sExportFile
89606>>>                    Get Seq_New_Channel to iOut
89607>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89609>>>                        Direct_Output channel iOut sExportFile
89611>>>                    End
89611>>>>
89611>>>                End
89611>>>>
89611>>>
89611>>>                // Record starting date/time stamp
89611>>>                Move (CurrentDateTime()) to dtQueryExecStart
89612>>>                // Turn on error handling if enabled
89612>>>                If (pbHandleQueryErrors(Self)) Begin
89614>>>                    Set pbSqlError to False
89615>>>                    Set paSqlErrorArray to aSqlErrorArray
89616>>>                    Move Error_Object_Id to hoError
89617>>>                    Move Self to Error_Object_Id
89618>>>                End
89618>>>>
89618>>>
89618>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
89619>>>                Decrement iRows
89620>>>                Move (sNoCountKeyWord + sCR) to sStmt
89621>>>
89621>>>                For iCount from 0 to iRows
89627>>>>
89627>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
89628>>>
89628>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
89630>>>                        If (sSQLVal <> "") Begin
89632>>>                            Move (sSQLVal + sCR) to sSQLVal
89633>>>                        End
89633>>>>
89633>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
89634>>>                    End
89634>>>>
89634>>>
89634>>>                    // - Each time we encounter a "GO" statement we execute it,
89634>>>                    // or if at the very end of the script.
89634>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
89636>>>
89636>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
89636>>>                        // instead of all in one go.
89636>>>                        Send SqlExecDirect of hoStmt sStmt
89637>>>
89637>>>                        If (bCreateScriptFile = True) Begin
89639>>>                            Write channel iOut sStmt
89641>>>                        End
89641>>>>
89641>>>                        Move "" to sStmt
89642>>>                        Move 0 to iChunkCounter
89643>>>                    End
89643>>>>
89643>>>                    Increment iChunkCounter
89644>>>                Loop
89645>>>>
89645>>>
89645>>>                Repeat
89645>>>>
89645>>>                    If (pbHandleQueryErrors(Self)) Begin
89647>>>                        Move hoError to Error_Object_Id
89648>>>                    End
89648>>>>
89648>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
89649>>>
89649>>>                    Send _SqlColumnInfo hoStmt
89650>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
89651>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
89652>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
89653>>>                    Set piRows    to iRows
89654>>>                    Set piRowType to iRowType
89655>>>
89655>>>                    If (iMsgs <> 0) Begin
89657>>>                        If (ghoDbUpdateHandler > 0) Begin
89659>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89660>>>                        End
89660>>>>
89660>>>                        For i from 1 to iMsgs
89666>>>>
89666>>>                            Get SqlGetMessage of hoStmt i to sMessage
89667>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
89668>>>                            If (bShowProgress = True) Begin
89670>>>                                If (Active_State(ghoStatusPanel)) Begin
89672>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
89673>>>                                End
89673>>>>
89673>>>                                Else Begin
89674>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
89676>>>                                End
89676>>>>
89676>>>                            End
89676>>>>
89676>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
89677>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
89678>>>                        Loop
89679>>>>
89679>>>
89679>>>
89679>>>                        If (ghoDbUpdateHandler > 0) Begin
89681>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89682>>>                        End
89682>>>>
89682>>>                        Set paQueryMessages to sMsg
89683>>>                    End
89683>>>>
89683>>>
89683>>>                    Get SQLNextResultSet of hoStmt to iNextSet
89684>>>                Until (iNextSet = 0)
89686>>>
89686>>>                Move (CurrentDateTime()) to dtQueryExecEnd
89687>>>            End
89687>>>>
89687>>>
89687>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
89688>>>            Set ptsQueryExec to tsQuery
89689>>>            Send SqlClose of hoStmt
89690>>>
89690>>>            If (bCreateScriptFile = True) Begin
89692>>>                Close_Output channel iOut
89694>>>                Send Seq_Release_Channel iOut
89695>>>            End
89695>>>>
89695>>>        End
89695>>>>
89695>>>        Send SqlDisconnect of hoSQLConnect
89696>>>
89696>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
89697>>>    End_Function
89698>>>
89698>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
89698>>>    // for DAW drivers.
89698>>>    // Returns: A string array.
89698>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
89700>>>        String[] sReturnArray
89701>>>        String sValue sPrevious
89701>>>        Handle hoSQLHandler hoSQLConnect hstmt
89701>>>        Integer iFetchResult iRows
89701>>>        tSQLConnection SQLConnection
89701>>>        tSQLConnection SQLConnection
89701>>>
89701>>>        Get phoSQLManager to hoSQLHandler
89702>>>
89702>>>        If (hoSQLHandler <> 0) Begin
89704>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89705>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
89706>>>
89706>>>            If (hoSQLConnect <> 0) Begin
89708>>>                Get SQLOpen of hoSQLConnect to hstmt
89709>>>                If (hstmt <> 0) Begin
89711>>>                    Send SqlExecDirect of hstmt sStmt
89712>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
89713>>>                    Repeat
89713>>>>
89713>>>                        Get SQLFetch of hstmt to iFetchResult
89714>>>                        If (iFetchResult <> 0) Begin
89716>>>                            Get SQLColumnValue of hstmt iColumn to sValue
89717>>>                            If (sValue <> sPrevious) Begin
89719>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
89720>>>                            End
89720>>>>
89720>>>                            Move sValue to sPrevious
89721>>>                        End
89721>>>>
89721>>>                    Until (iFetchResult = 0)
89723>>>                    Send SQLClose of hstmt
89724>>>                End
89724>>>>
89724>>>                Send SQLDisconnect of hoSQLConnect
89725>>>            End
89725>>>>
89725>>>        End
89725>>>>
89725>>>
89725>>>        Function_Return sReturnArray
89726>>>    End_Function
89727>>>
89727>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
89727>>>    // for Mertech drivers.
89727>>>    // Returns: A string array.
89727>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
89729>>>        String[] sReturnArray
89730>>>        String sValue sUserID sPassword
89730>>>        Handle hoSQLHandler hoSQLConnect hStmt
89730>>>        Integer iFetchResult iRows
89730>>>        tSQLConnection SQLConnection
89730>>>        tSQLConnection SQLConnection
89730>>>
89730>>>        Get _MertechSQLManagerHandle to hoSQLHandler
89731>>>
89731>>>        If (hoSQLHandler <> 0) Begin
89733>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89734>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
89735>>>
89735>>>            If (hoSQLConnect <> 0) Begin
89737>>>                Get SQLOpen of hoSQLConnect to hStmt
89738>>>                If (hStmt <> 0) Begin
89740>>>                    Send SqlExecDirect of hStmt sStmt
89741>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
89742>>>                    Repeat
89742>>>>
89742>>>                        Get SQLFetch of hStmt to iFetchResult
89743>>>                        If (iFetchResult <> 0) Begin
89745>>>                            Get SQLColumnValue of hStmt 1 to sValue
89746>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
89747>>>                        End
89747>>>>
89747>>>                    Until (iFetchResult = 0)
89749>>>                    Send SQLClose of hStmt
89750>>>                End
89750>>>>
89750>>>                Send SQLDisconnect of hoSQLConnect
89751>>>            End
89751>>>>
89751>>>        End
89751>>>>
89751>>>
89751>>>        Function_Return sReturnArray
89752>>>    End_Function
89753>>>
89753>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
89753>>>    // will be used.
89753>>>    Function SqlUtilBackupDatabaseToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
89755>>>        Boolean bOK bExists bShowProgress
89755>>>        String sStatement sDriverID
89755>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
89755>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
89755>>>        Integer iDbType
89755>>>
89755>>>        If (sDatabase = "") Begin
89757>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
89758>>>>
89758>>>            Function_Return False
89759>>>        End
89759>>>>
89759>>>        If (sBackupName = "") Begin
89761>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
89762>>>>
89762>>>            Function_Return False
89763>>>        End
89763>>>>
89763>>>
89763>>>        // Create backup-folder if it doesn't exist
89763>>>        Get vFolderExists sPath to bExists
89764>>>        If (bExists = False) Begin
89766>>>            Get vCreateDirectory sPath to bOK
89767>>>            If (bOK = False) Begin
89769>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
89770>>>>
89770>>>                Function_Return False
89771>>>            End
89771>>>>
89771>>>        End
89771>>>>
89771>>>        // Make sure the path ends with a back-slash
89771>>>        If (sPath <> "") Begin
89773>>>            Get vFolderFormat sPath to sPath
89774>>>        End
89774>>>>
89774>>>
89774>>>        Get psDriverID to sDriverID
89775>>>        Get piDbType   to iDbType
89776>>>        If (num_arguments > 3) Begin
89778>>>            Move bShowProg to bShowProgress
89779>>>        End
89779>>>>
89779>>>
89779>>>        Case Begin
89779>>>            Case (iDbType = EN_DbTypeMSSQL)
89781>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
89781>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
89781>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
89782>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
89783>>>
89783>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
89784>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
89785>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
89786>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
89787>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
89788>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
89789>>>                Case Break
89790>>>            Case Else
89790>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
89791>>>        Case End
89791>>>
89791>>>        Function_Return bOK
89792>>>    End_Function
89793>>>
89793>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
89793>>>    // that "fits" in the max allowed length for table names.
89793>>>    // Max number of characters allowed for table names;
89793>>>    // IBM DB2      = 128
89793>>>    // MS-SQL       = 128
89793>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
89793>>>    // MySQL        = 64
89793>>>    // PostgreSQL   = 64
89793>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
89795>>>        String sGUIDName
89795>>>        Integer iDbType iLength
89795>>>        
89795>>>        Get piDbType to iDbType
89796>>>        Move (RandomHexUUID()) to sGUIDName
89797>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
89798>>>        Move (Length(sGUIDName)) to iLength
89799>>>        
89799>>>        Case Begin
89799>>>            Case (iDbType = EN_DbTypeDB2)
89801>>>            If (iLength > 128) Begin
89803>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89804>>>            End
89804>>>>
89804>>>            Case Break
89805>>>
89805>>>            Case (iDbType = EN_DbTypeMSSQL)
89808>>>            If (iLength > 128) Begin
89810>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89811>>>            End
89811>>>>
89811>>>            Case Break
89812>>>
89812>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
89815>>>            If (iLength > 128) Begin
89817>>>                Move (Left(sGUIDName, 128)) to sGUIDName
89818>>>            End
89818>>>>
89818>>>            Case Break
89819>>>
89819>>>            Case (iDbType = EN_DbTypeMySQL)
89822>>>            If (iLength > 64) Begin
89824>>>                Move (Left(sGUIDName, 64)) to sGUIDName
89825>>>            End
89825>>>>
89825>>>            Case Break
89826>>>
89826>>>            Case (iDbType = EN_DbTypePostgre)
89829>>>            If (iLength > 64) Begin
89831>>>                Move (Left(sGUIDName, 64)) to sGUIDName
89832>>>            End
89832>>>>
89832>>>        Case End
89832>>>       
89832>>>        Function_Return sGUIDName   
89833>>>    End_Function
89834>>>       
89834>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
89834>>>    // Pass the memory resource file reference and the filename to be created,
89834>>>    // including full path.
89834>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
89836>>>        String sText
89836>>>        Integer iCh iSize iArgSize
89836>>>
89836>>>        Move ("Resource:" + sMemFileName) to sMemFileName
89837>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
89838>>>            Get_Channel_Size iCh to iSize
89839>>>            Get_Argument_Size to iArgSize
89840>>>            If (iSize > iArgSize) Begin
89842>>>                Set_Argument_Size iSize
89843>>>>
89843>>>            End
89843>>>>
89843>>>            Read_Block channel iCh sText iSize
89845>>>        Send Seq_Close_Channel iCh
89846>>>
89846>>>        Get Seq_Open_Output_Channel sFileName to iCh
89847>>>            Write channel iCh sText
89849>>>        Send Seq_Close_Channel iCh
89850>>>
89850>>>        If (iSize <> iArgSize) Begin
89852>>>            Set_Argument_Size iArgSize
89853>>>>
89853>>>        End
89853>>>>
89853>>>
89853>>>        // Wait for file to be written to disk.
89853>>>        Sleep 2
89854>>>    End_Procedure
89855>>>
89855>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
89857>>>        String sNotNull sRetval sDefaultValue
89857>>>        Boolean bOK
89857>>>
89857>>>        Get IsSQLDriver sDriverID to bOK
89858>>>        If (bOK = False) Begin
89860>>>            Function_Return ""
89861>>>        End
89861>>>>
89861>>>
89861>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
89862>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
89863>>>
89863>>>        Case Begin
89863>>>            Case (iDbType = EN_dbTypeMSSQL)
89865>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
89866>>>                Case Break
89867>>>            Case (iDbType = EN_dbTypeMySQL)
89870>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
89871>>>                Case Break
89872>>>            Case (iDbType = EN_dbTypePostgre)
89875>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
89876>>>                Case Break
89877>>>            Case (iDbType = EN_dbTypeDB2)
89880>>>                Move (String(sNotNull))                                     to sRetval
89881>>>                Case Break
89882>>>
89882>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
89882>>>            // ToDo: We need to look deeper into how Oracle handles NULL
89882>>>            Case (iDbType = EN_dbTypeOracle)
89885>>>                Move  ""                                                    to sRetval
89886>>>                Case Break
89887>>>
89887>>>            Case Else
89887>>>                Move  ""                                                    to sRetval
89888>>>        Case End
89888>>>
89888>>>        Function_Return sRetval
89889>>>    End_Function
89890>>>
89890>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
89892>>>        String[] sReturnArray
89893>>>        String sValue sUserID sPassword
89893>>>        Handle hoSQLHandler hoSQLConnect hStmt
89893>>>        Integer iFetchResult iRetval
89893>>>        tSQLConnection SQLConnection
89893>>>        tSQLConnection SQLConnection
89893>>>
89893>>>        Get _MertechSQLManagerHandle to hoSQLHandler
89894>>>        If (hoSQLHandler <> 0) Begin
89896>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89897>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
89898>>>            If (hoSQLConnect <> 0) Begin
89900>>>                Get SQLOpen of hoSQLConnect to hStmt
89901>>>                If (hStmt <> 0) Begin
89903>>>                    Send SQLSetProcedureName of hStmt sStmt
89904>>>                    If (sArgument <> "") Begin
89906>>>                        Send SqlSetArgument  of hStmt 1 sArgument
89907>>>                    End
89907>>>>
89907>>>                    Send SQLCall of hStmt
89908>>>
89908>>>                    Get SqlReturnValue       of hStmt to iRetval
89909>>>                    If (iRetval = 0) Begin
89911>>>                        Repeat
89911>>>>
89911>>>                            Get SQLFetch of hStmt to iFetchResult
89912>>>                            If (iFetchResult <> 0) Begin
89914>>>                                Get SQLColumnValue of hStmt 1 to sValue
89915>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
89916>>>                            End
89916>>>>
89916>>>                        Until (iFetchResult = 0)
89918>>>                        Send SQLClose of hStmt
89919>>>                    End
89919>>>>
89919>>>                End
89919>>>>
89919>>>                Send SQLDisconnect of hoSQLConnect
89920>>>            End
89920>>>>
89920>>>        End
89920>>>>
89920>>>
89920>>>        Function_Return sReturnArray
89921>>>    End_Function
89922>>>
89922>>>    // Returns the index for the passed sTableName
89922>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
89922>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
89924>>>        Integer iIndex iSize iCount
89924>>>        String[] sTablesArray
89925>>>        String sVal sConnectionString
89925>>>
89925>>>        Move -1 to iIndex
89926>>>        Get psConnectionString to sConnectionString
89927>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
89928>>>        Move (SizeOfArray(sTablesArray)) to iSize
89929>>>        Decrement iSize
89930>>>        For iCount from 0 to iSize
89936>>>>
89936>>>            Move sTablesArray[iCount] to sVal
89937>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
89939>>>                Move iCount to iIndex // We found it!
89940>>>                Move iSize to iCount  // End the loop
89941>>>            End
89941>>>>
89941>>>        Loop
89942>>>>
89942>>>
89942>>>        Function_Return iIndex
89943>>>    End_Function
89944>>>
89944>>>    // Helper function that builds a string like;
89944>>>    // "SELECT name from [Master].[sys].[databases] where name"
89944>>>    Function _SqlSelectFromWhereName Returns String
89946>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
89946>>>
89946>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
89947>>>        Get _SqlFindKeyWord CI_SQLName         to sName
89948>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
89949>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
89950>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
89951>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
89952>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
89953>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
89954>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
89955>>>        Function_Return sRetval
89956>>>    End_Function
89957>>>
89957>>>    // Helper function to create a SQL statement like;
89957>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
89957>>>    // Used for checking if an index exists.
89957>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
89959>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
89959>>>
89959>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
89960>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
89961>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
89962>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
89963>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
89964>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
89965>>>        Get _SqlFindKeyWord CI_SQLName to sName
89966>>>
89966>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
89967>>>
89967>>>        Function_Return sRetval
89968>>>    End_Function
89969>>>
89969>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
89969>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
89969>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
89971>>>        String sRetval
89971>>>        If (iLength <> 0) Begin
89973>>>            Move ("(" + String(iLength)) to sRetval
89974>>>            If (iDecimals <> 0) Begin
89976>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
89977>>>            End
89977>>>>
89977>>>            Move (sRetval + ")") to sRetval
89978>>>        End
89978>>>>
89978>>>        Function_Return sRetval
89979>>>    End_Function
89980>>>
89980>>>    Procedure _SqlColumnInfo Handle hoStmt
89982>>>        Integer i iCols iItem
89982>>>        tSqlColumnNew[] aQueryColumns
89982>>>        tSqlColumnNew[] aQueryColumns
89983>>>
89983>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
89984>>>        For i from 1 to iCols
89990>>>>
89990>>>            Move (SizeOfArray(aQueryColumns)) to iItem
89991>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
89992>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
89993>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
89994>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
89995>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
89996>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
89997>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
89998>>>        Loop
89999>>>>
89999>>>        Set piColumns to iCols
90000>>>        Set paQueryColumns to aQueryColumns
90001>>>    End_Procedure
90002>>>
90002>>>    // Checks that the passed sDriverID is defined.
90002>>>    // Also checks if the driver has been loaded; else it gets loaded.
90002>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
90004>>>        Boolean bOK
90004>>>        Integer iDriver
90004>>>
90004>>>        If (sDriverID = DATAFLEX_ID) Begin
90006>>>            Function_Return False
90007>>>        End
90007>>>>
90007>>>
90007>>>        Get IsDAWSQLDriver sDriverID to bOK
90008>>>
90008>>>        If (bOK = False) Begin
90010>>>            Get IsMertechDriver sDriverID to bOK
90011>>>        End
90011>>>>
90011>>>
90011>>>        If (bOK = False) Begin
90013>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
90014>>>>
90014>>>            Function_Return False
90015>>>        End
90015>>>>
90015>>>
90015>>>        Get DriverIndex sDriverID to iDriver
90016>>>        If (iDriver = 0) Begin
90018>>>            Load_Driver sDriverID
90019>>>        End
90019>>>>
90019>>>
90019>>>        Function_Return True
90020>>>    End_Function
90021>>>
90021>>>    // Checks that the length parameter has been passed correctly.
90021>>>    // This is only of concern for certain SQL data types.
90021>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
90023>>>        Integer iLength
90023>>>        Boolean bOK bCheckTypeLength
90023>>>
90023>>>        If (num_arguments > 1) Begin
90025>>>            Move iLen to iLength
90026>>>        End
90026>>>>
90026>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
90027>>>
90027>>>        If (bCheckTypeLength = True) Begin
90029>>>            Move (iLength > 0) to bOK
90030>>>        End
90030>>>>
90030>>>
90030>>>        Function_Return (bOK = True)
90031>>>    End_Function
90032>>>
90032>>>    Function _SqlProperTableName String sTableName Returns String
90034>>>        String sVal sSchema sDriverID sValue
90034>>>        Handle hTable
90034>>>        Integer iDbType
90034>>>
90034>>>        If (Trim(sTableName) = "") Begin
90036>>>            Function_Return ""
90037>>>        End
90037>>>>
90037>>>
90037>>>        Get psDriverID to sDriverID
90038>>>        Get piDbType   to iDbType
90039>>>        If (iDbType = EN_dbTypeOracle) Begin
90041>>>            Get psUserID to sSchema
90042>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
90042>>>            Move (Uppercase(sSchema)) to sSchema
90043>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
90044>>>            Function_Return sTableName
90045>>>        End
90045>>>>
90045>>>        If (iDbType = EN_DbTypeMySQL) Begin
90047>>>            Get psDatabase to sVal
90048>>>            Move (sVal + "." + sTableName) to sTableName
90049>>>            Function_Return sTableName
90050>>>        End
90050>>>>
90050>>>        If (iDbType = EN_DbTypePostgre) Begin
90052>>>            Move ('"' + sTableName + '"') to sTableName
90053>>>            Function_Return sTableName
90054>>>        End
90054>>>>
90054>>>
90054>>>        Get psSchema to sSchema
90055>>>        If (sSchema = "") Begin
90057>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90058>>>        End
90058>>>>
90058>>>
90058>>>        Move (Uppercase(sTableName)) to sVal
90059>>>        If (not(sVal contains (sSchema + "."))) Begin
90061>>>            If (iDbType = EN_dbTypeDB2) Begin
90063>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
90064>>>            End
90064>>>>
90064>>>            Else Begin
90065>>>                Move (sSchema + "." + sTableName) to sTableName
90066>>>            End
90066>>>>
90066>>>        End
90066>>>>
90066>>>
90066>>>        Function_Return sTableName
90067>>>    End_Function
90068>>>
90068>>>    // SQL column names can be case-sensitive. This function is used to check that
90068>>>    // the passed sFieldName has the correct spelling.
90068>>>    // Used with Embedded SQL statement calls.
90068>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
90068>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
90070>>>        String sRetval sValue sConnectionString sDriverID
90070>>>        String[] sColumnNamesArray
90071>>>        Integer iCount iColumns
90071>>>
90071>>>        Move "" to sRetval
90072>>>        Get psDriverID to sDriverID
90073>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
90074>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
90075>>>        Decrement iColumns
90076>>>
90076>>>        For iCount from 0 to iColumns
90082>>>>
90082>>>            Move sColumnNamesArray[iCount] to sValue
90083>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
90085>>>                Move sValue to sRetval
90086>>>                Move iColumns to iCount // We're done.
90087>>>            End
90087>>>>
90087>>>        Loop
90088>>>>
90088>>>
90088>>>        Function_Return sRetval
90089>>>    End_Function
90090>>>
90090>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
90092>>>        String[] sReturnArray
90093>>>        Handle hoSQLHandler
90093>>>        Integer iCount iSize iItem
90093>>>        String sServer sUser sPassword
90093>>>        tSQLConnection SQLConnection
90093>>>        tSQLConnection SQLConnection
90093>>>
90093>>>        Get phoMSSQLHandler to hoSQLHandler
90094>>>        Send Delete_Data    of hoSQLHandler
90095>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
90096>>>
90096>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90097>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
90098>>>        Decrement iSize
90099>>>
90099>>>        For iCount from 0 to iSize
90105>>>>
90105>>>            Get String_Value of hoSQLHandler item iCount to sServer
90106>>>            Move (Trim(sServer)) to sReturnArray[iItem]
90107>>>            Increment iItem
90108>>>        Loop
90109>>>>
90109>>>
90109>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90110>>>
90110>>>        Function_Return sReturnArray
90111>>>    End_Function
90112>>>
90112>>>    Function _SqlTableArrayDAW Returns String[]
90114>>>        String[] sReturnArray
90115>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
90115>>>        Handle hoSQLHandler
90115>>>        Integer iCount iSize iItem
90115>>>        Boolean bOK
90115>>>        tSQLConnection SQLConnection
90115>>>        tSQLConnection SQLConnection
90115>>>
90115>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90116>>>        If (SQLConnection.sConnectionString = "") Begin
90118>>>            Function_Return sReturnArray
90119>>>        End
90119>>>>
90119>>>
90119>>>        Move SQLConnection.sSchema      to sDefSchema
90120>>>        Move (Uppercase(sDefSchema))    to sDefSchema
90121>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
90122>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
90123>>>
90123>>>        Get phoCLIHandler to hoSQLHandler
90124>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
90125>>>        Send Delete_Data  of hoSQLHandler
90126>>>
90126>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90127>>>        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
90128>>>        Move False to Err
90129>>>        Decrement iSize
90130>>>
90130>>>        For iCount from 0 to iSize
90136>>>>
90136>>>            Get TableName    of hoSQLHandler iCount to sTable
90137>>>            Get TableType    of hoSQLHandler iCount to sTableType
90138>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
90139>>>            Get TableComment of hoSQLHandler iCount to sComment
90140>>>            Move (Trim(sTable)) to sTable
90141>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
90143>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
90144>>>            End
90144>>>>
90144>>>            Else Begin
90145>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
90146>>>            End
90146>>>>
90146>>>            If (bOK = True) Begin
90148>>>                Move sTable to sReturnArray[iItem]
90149>>>                Increment iItem
90150>>>            End
90150>>>>
90150>>>        Loop
90151>>>>
90151>>>
90151>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90152>>>
90152>>>        Function_Return sReturnArray
90153>>>    End_Function
90154>>>
90154>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
90156>>>        String[] sReturnArray
90157>>>        String sValue
90157>>>        Handle hoSQLHandler hoSQLConnect hStmt
90157>>>        Integer iRetval iCols iFetchResult
90157>>>        tSQLConnection SQLConnection
90157>>>        tSQLConnection SQLConnection
90157>>>
90157>>>        Get phoSQLManager to hoSQLHandler
90158>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90159>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
90160>>>
90160>>>        If (hoSQLConnect <> 0) Begin
90162>>>            Get SqlOpen of hoSQLConnect to hStmt
90163>>>            If (hStmt <> 0) Begin
90165>>>                Send SqlSetProcedurename of hStmt sStmt
90166>>>                If (sArgument <> "") Begin
90168>>>                    Send SqlSetArgument  of hStmt 1 sArgument
90169>>>                End
90169>>>>
90169>>>
90169>>>                Send SqlCall             of hStmt
90170>>>                Get SqlReturnValue       of hStmt to iRetval
90171>>>                If (iRetval = 0) Begin
90173>>>                    Repeat
90173>>>>
90173>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
90174>>>                        If (iCols > 0) Begin
90176>>>                            Repeat
90176>>>>
90176>>>                                Get SqlFetch of hStmt to iFetchResult
90177>>>                                If (iFetchResult <> 0) Begin
90179>>>                                    Get SqlColumnValue of hStmt 1 to sValue
90180>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
90181>>>                                End
90181>>>>
90181>>>                            Until (iFetchResult = 0)
90183>>>                        End
90183>>>>
90183>>>                        Get SqlNextResultSet of hStmt to iRetval
90184>>>                    Until (iRetval = 0)
90186>>>                    Send SqlClose of hStmt
90187>>>                End
90187>>>>
90187>>>            End
90187>>>>
90187>>>            Send SqlDisconnect of hoSQLConnect
90188>>>        End
90188>>>>
90188>>>        Function_Return sReturnArray
90189>>>    End_Function
90190>>>
90190>>>    Function _SqlDatabasesArrayDB2 Returns String[]
90192>>>        String[] sReturnArray
90193>>>        String sDataSource
90193>>>        Handle hoSQLHandler
90193>>>        Integer iItem
90193>>>
90193>>>        Get phoDB2SQLHandler to hoSQLHandler
90194>>>        Send SeedDataSources of hoSQLHandler
90195>>>
90195>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90196>>>
90196>>>        Repeat
90196>>>>
90196>>>            Get DataSources of hoSQLHandler to sDataSource
90197>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
90198>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
90199>>>            Increment iItem
90200>>>        Until (sDataSource = "")
90202>>>
90202>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90203>>>
90203>>>        Function_Return sReturnArray
90204>>>    End_Function
90205>>>
90205>>>    Function _SqlDatabasesArrayODBC Returns String[]
90207>>>        String[] sReturnArray
90208>>>        String sDataSource
90208>>>        Handle hoSQLHandler
90208>>>        Integer iItem
90208>>>
90208>>>        Get phoODBCSQLHandler to hoSQLHandler
90209>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90210>>>
90210>>>        Send SeedDataSources of hoSQLHandler
90211>>>
90211>>>        Repeat
90211>>>>
90211>>>            Get DataSources of hoSQLHandler to sDataSource
90212>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
90214>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
90215>>>                Increment iItem
90216>>>            End
90216>>>>
90216>>>        Until (sDataSource = "")
90218>>>
90218>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90219>>>
90219>>>        Function_Return sReturnArray
90220>>>    End_Function
90221>>>
90221>>>    // We might have a split Sql script where the info about which database to use is
90221>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
90221>>>    // insert it for scriplets to come after the first one.
90221>>>    Function _SqlFormatStatement String sStmt Returns String
90223>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
90223>>>        Integer iStart iEnd iDbType
90223>>>        Boolean bOK
90223>>>
90223>>>        Get piDbType to iDbType
90224>>>        Get psDriverID to sDriverID
90225>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
90226>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
90227>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
90228>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
90229>>>        Move (Replaces(" ", sStmt, "")) to sTmp
90230>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
90232>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
90233>>>            Move (Pos("]", sTmp)) to iEnd
90234>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
90235>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
90236>>>            Set Private.psUseDatabase to sUseDatabase
90237>>>        End
90237>>>>
90237>>>        Else Begin
90238>>>            Move (Uppercase(sStmt)) to sTmp
90239>>>
90239>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
90239>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
90241>>>                Get Private.psUseDatabase to sUseDatabase
90242>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
90243>>>            End
90243>>>>
90243>>>
90243>>>            // This is a bit special to place here but was done so because it was easier that way.
90243>>>            // We will get an error when trying to create a view if it already exists.
90243>>>            // So to avoid such errors; we first remove it & then recreate it.
90243>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
90246>>>                // Make sure we only have one space between statements/words.
90246>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
90247>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
90248>>>                Move (Trim(sTmp)) to sTmp
90249>>>                Move (Pos(" ", sTmp)) to iEnd
90250>>>                Move (Left(sTmp, iEnd)) to sTmp
90251>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
90253>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
90254>>>                End
90254>>>>
90254>>>                Move (Trim(sTmp)) to sTmp
90255>>>                // Remove data view as it already exists!
90255>>>                Get SqlViewRemove sDriverID sTmp to bOK
90256>>>            End
90256>>>>
90256>>>        End
90256>>>>
90256>>>
90256>>>        Function_Return sStmt
90257>>>    End_Function
90258>>>
90258>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
90258>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
90260>>>        String sRetval
90260>>>        Integer iDbType iSize iItem iIndex
90260>>>        tSQLKeyWords[] SQLKeywordArray
90260>>>        tSQLKeyWords[] SQLKeywordArray
90261>>>        tSQLKeyWords   SQLKeyWords
90261>>>        tSQLKeyWords   SQLKeyWords
90261>>>
90261>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
90261>>>        Get piDbType to iDbType
90262>>>        Move iDbType             to SQLKeyWords.iSQLDbType
90263>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
90264>>>
90264>>>        Get paSQLKeywordArray to SQLKeywordArray
90265>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
90266>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
90267>>>
90267>>>        Function_Return sRetval
90268>>>    End_Function
90269>>>
90269>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
90269>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
90271>>>        String[] sSQLScriptArray
90272>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
90272>>>        Integer iCh iSize iArgSize iPos iCount
90272>>>        Boolean bCommentStart bCommentEnd bDashComment
90272>>>
90272>>>        Move False to bCommentStart
90273>>>        Move False to bCommentEnd
90274>>>        Move False to bDashComment
90275>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
90276>>>        Move "*/"  to sCommentEnd
90277>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
90278>>>
90278>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
90279>>>        Decrement iSize
90280>>>        Move "" to sText
90281>>>
90281>>>        For iCount from 0 to iSize
90287>>>>
90287>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
90288>>>            Move (Trim(sLine)) to sTmp
90289>>>            If (sTmp <> "") Begin
90291>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
90292>>>                If (bCommentStart = False) Begin
90294>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
90295>>>                    If (bCommentStart = False) Begin
90297>>>                    End
90297>>>>
90297>>>                End
90297>>>>
90297>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
90298>>>                If (bCommentEnd = True) Begin
90300>>>                    Move False to bCommentStart
90301>>>                End
90301>>>>
90301>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
90303>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
90304>>>                End
90304>>>>
90304>>>            End
90304>>>>
90304>>>        Loop
90305>>>>
90305>>>
90305>>>        // Update the retval struct array:
90305>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
90306>>>        Function_Return SqlScriptArray
90307>>>    End_Function
90308>>>    
90308>>>
90308>>>    // *** Database API Functions: ***
90308>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
90308>>>    // make changes/updates to the database.
90308>>>    //
90308>>>    //
90308>>>    // This might not do what you think - Here's what it does:
90308>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
90308>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
90308>>>    // to the SQL table.
90308>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
90308>>>    // already exists in SQL.
90308>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
90308>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
90308>>>    // restructuring an existing table.
90308>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
90310>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
90310>>>        String sDriverID sTableName sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
90310>>>        Handle hToTable
90310>>>        Integer iPos
90310>>>
90310>>>        Move True to bUseConnectionID
90311>>>        If (num_arguments > 1) Begin
90313>>>            Move bUseConnID to bUseConnectionID
90314>>>        End
90314>>>>
90314>>>
90314>>>        Get psDriverID to sDriverID
90315>>>        // If the table doesn't exist on the SQL back-end we do nothing.
90315>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
90316>>>        If (bExists = False) Begin
90318>>>            Function_Return False
90319>>>        End
90319>>>>
90319>>>
90319>>>        Get UtilTableIsAlias hTable to bIsAlias
90320>>>        
90320>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90321>>>        If (bOK = False) Begin
90323>>>            Function_Return False
90324>>>        End
90324>>>>
90324>>>
90324>>>        // Then we need to check that the function hasn't been called before; which in case
90324>>>        // we do nothing
90324>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
90325>>>        If (bExists = True) Begin
90327>>>            Function_Return False
90328>>>        End
90328>>>>
90328>>>
90328>>>        Get psConnectionID     to sConnectionID
90329>>>        Get psConnectionString to sConnectionString
90330>>>        If (sConnectionID = "" or sConnectionString = "") Begin
90332>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
90333>>>>
90333>>>            Function_Return False
90334>>>        End
90334>>>>
90334>>>
90334>>>        Get psSchema to sSchema
90335>>>        If (sSchema = "") Begin
90337>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90338>>>        End
90338>>>>
90338>>>
90338>>>        Get IsMertechDriver sDriverID to bMertechDriver
90339>>>
90339>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
90339>>>        // was a programmer's error and we adjust for it here.
90339>>>        If (bMertechDriver = True) Begin
90341>>>            Move False to bUseConnectionID
90342>>>        End
90342>>>>
90342>>>
90342>>>        // If we should use a connection id we need to check it exists;
90342>>>        // else we create it before attempting creating the table
90342>>>        If (bUseConnectionID = True) Begin
90344>>>            Get AutoConnectionIDLogin to bOK
90345>>>            If (bOk = False) Begin
90347>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
90348>>>>
90348>>>                Function_Return False
90349>>>            End
90349>>>>
90349>>>        End
90349>>>>
90349>>>
90349>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90352>>>        Get _TableNameOnly sRootName to sRootName
90353>>>        If (sRootName = "") Begin
90355>>>            Function_Return False
90356>>>        End
90356>>>>
90356>>>        Move (sRootName + ".int")                    to sPhysicalName
90357>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90360>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName  
90363>>>
90363>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
90363>>>        // because then the table should not be visible to users.
90363>>>        Move (Pos("@", sDisplayName)) to iPos
90364>>>        If (iPos <> 1) Begin
90366>>>            If (sDisplayName contains ".") Begin
90368>>>                Move (Pos(".", sDisplayName)) to iPos
90369>>>                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
90370>>>                Move (sSchema + "." + sDisplayName)       to sDisplayName
90371>>>            End
90371>>>>
90371>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
90373>>>                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
90374>>>            End
90374>>>>
90374>>>        End
90374>>>>
90374>>>
90374>>>        If (bIsAlias = False) Begin
90376>>>            Get OpenTableExclusive hTable to bOpened
90377>>>            If (bOpened = False) Begin
90379>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
90380>>>>
90380>>>                Function_Return False
90381>>>            End
90381>>>>
90381>>>        End
90381>>>>
90381>>>
90381>>>        If (ghoProgressBar <> 0) Begin
90383>>>            Send DoAdvance of ghoProgressBar
90384>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
90385>>>        End
90385>>>>
90385>>>        // Note: The hToTable will get changed by the Structure_xxx command...
90385>>>        Move hTable to hToTable
90386>>>        Move False to Err
90387>>>
90387>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
90387>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
90387>>>        // a proper and updated .int file.
90387>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
90390>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
90391>>>        
90391>>>        If (bIsAlias = False) Begin
90393>>>            Structure_Start hToTable sDriverID
90394>>>                If (bUseConnectionID = True) Begin
90396>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
90399>>>                End
90399>>>>
90399>>>                Else Begin
90400>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
90403>>>                End
90403>>>>
90403>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
90406>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
90406>>>                Move False to Err
90407>>>                Move 0 to LastErr
90408>>>            Structure_End hToTable
90410>>>        End
90410>>>>
90410>>>
90410>>>        Move (not(Err)) to bOK
90411>>>        If (bOK = True) Begin
90413>>>            // The attributes set above will always trigger an error
90413>>>            // We also adjust the Filelist entries
90413>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
90416>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90419>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
90422>>>
90422>>>            // This pseudo updates the .int file to make it up-to-date with the SQL back-end.
90422>>>            Get SqlUtilUpdateIntFile hTable to bOK
90423>>>        End
90423>>>>
90423>>>
90423>>>        Function_Return (bOK = True)
90424>>>    End_Function
90425>>>
90425>>>    // Sample usage:
90425>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
90425>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
90425>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
90427>>>        Boolean bOK
90427>>>
90427>>>        Get AutoConnectionIDLogin to bOK
90428>>>        Move False to Err
90429>>>        Get OpenTableExclusive hTable to bOK
90430>>>        If (bOK = False) Begin
90432>>>            Function_Return False
90433>>>        End
90433>>>>
90433>>>        Structure_Start hTable
90434>>>            Set_Attribute iAttribute of hTable to iValue
90437>>>        Structure_End hTable
90439>>>
90439>>>        Function_Return (Err = False)
90440>>>    End_Function
90441>>>
90441>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
90441>>>    // or to change the filelist slot names.
90441>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
90443>>>        Boolean bExists
90443>>>        Integer iPos
90443>>>        
90443>>>        Move False to Err
90444>>>        Get UtilTableNumberIsInUse hTable to bExists
90445>>>        If (bExists = False) Begin
90447>>>            Function_Return False
90448>>>        End
90448>>>>
90448>>>
90448>>>        If (ghoProgressBar <> 0) Begin
90450>>>            Send DoAdvance of ghoProgressBar
90451>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
90452>>>        End
90452>>>>
90452>>>        // If all strings are empty it means that we should remove this entry from filelist.
90452>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
90454>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
90457>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
90460>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
90463>>>            Function_Return (Err = False) // And we're done.
90464>>>        End
90464>>>>
90464>>>
90464>>>        If (sDriverID <> DATAFLEX_ID) Begin
90466>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
90469>>>        End
90469>>>>
90469>>>        Else Begin
90470>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90473>>>        End
90473>>>>
90473>>>
90473>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
90476>>>
90476>>>        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
90478>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
90481>>>        End
90481>>>>
90481>>>        Else Begin
90482>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
90485>>>        End
90485>>>>
90485>>>
90485>>>        Function_Return (Err = False)
90486>>>    End_Function
90487>>>
90487>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
90489>>>        Boolean bOK
90489>>>
90489>>>        Get AutoConnectionIDLogin to bOK
90490>>>        Move False to Err
90491>>>        Get OpenTableExclusive hTable to bOK
90492>>>        If (bOK = False) Begin
90494>>>            Function_Return False
90495>>>        End
90495>>>>
90495>>>
90495>>>        Structure_Start hTable
90496>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
90499>>>        Structure_End hTable
90501>>>
90501>>>        Function_Return (Err = False)
90502>>>    End_Function
90503>>>
90503>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
90505>>>        Boolean bOK
90505>>>
90505>>>        Move False to Err
90506>>>        Get AutoConnectionIDLogin to bOK
90507>>>        Open hToTable
90509>>>        Get OpenTableExclusive hTable to bOK
90510>>>        If (bOK = False) Begin
90512>>>            Function_Return False
90513>>>        End
90513>>>>
90513>>>
90513>>>        Structure_Start hTable
90514>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
90517>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
90520>>>        Structure_End hTable
90522>>>
90522>>>        Function_Return (Err = False)
90523>>>    End_Function
90524>>>
90524>>>    Procedure ApiTableConvertAllAddException Integer hTable
90526>>>        Integer[] iTableConvertExceptions
90527>>>        Get piTableConvertExceptions to iTableConvertExceptions
90528>>>        Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
90529>>>        Set piTableConvertExceptions to iTableConvertExceptions
90530>>>    End_Procedure
90531>>>
90531>>>    Procedure ApiTableConvertALLToSql
90533>>>        Integer[] iTablesArray
90534>>>        Integer iSize iCount
90534>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
90534>>>        String sDriverID
90534>>>
90534>>>        Get psDriverID to sDriverID
90535>>>        Get pbUseConnectionID to bUseConnectionID
90536>>>        Get pbToANSI          to bToANSI
90537>>>        Get pbRecnum          to bRecnum
90538>>>        Get pbCopyData        to bCopyData
90539>>>        If (ghoDbUpdateHandler > 0) Begin
90541>>>            Get pbContinueOnError to bContinueOnError
90542>>>        End
90542>>>>
90542>>>
90542>>>        Get _AllTablesToConvert to iTablesArray
90543>>>        Move (SizeOfArray(iTablesArray)) to iSize
90544>>>        Decrement iSize
90545>>>        For iCount from 0 to iSize
90551>>>>
90551>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
90552>>>            // Probably the right logic here is to just continue trying to convert every table even
90552>>>            // if there was an error converting one table...
90552>>>            //If (bContinueOnError = False and bOK = False) Break
90552>>>        Loop
90553>>>>
90553>>>
90553>>>    End_Procedure
90554>>>
90554>>>    Procedure ApiTableAttachALLToSql 
90556>>>        Integer[] iTablesArray
90557>>>        Integer iSize iCount
90557>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
90557>>>        String sDriverID
90557>>>
90557>>>        Get psDriverID to sDriverID
90558>>>        Get pbUseConnectionID to bUseConnectionID
90559>>>        Get pbToANSI          to bToANSI
90560>>>        Get pbRecnum          to bRecnum
90561>>>        Get pbCopyData        to bCopyData
90562>>>        If (ghoDbUpdateHandler > 0) Begin
90564>>>            Get pbContinueOnError to bContinueOnError
90565>>>        End
90565>>>>
90565>>>
90565>>>        Get _AllTablesToConvert to iTablesArray
90566>>>        Move (SizeOfArray(iTablesArray)) to iSize
90567>>>        Decrement iSize
90568>>>        For iCount from 0 to iSize
90574>>>>
90574>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
90575>>>        Loop
90576>>>>
90576>>>
90576>>>    End_Procedure
90577>>>
90577>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
90579>>>        Handle hToTable hoLogFile
90579>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
90579>>>        String sPhysicalName sRootName sLogicalName sDisplayName sEmpty sConnectionID sConnectionString
90579>>>        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
90579>>>        tSQLConnection SQLConnection
90579>>>        tSQLConnection SQLConnection
90579>>>
90579>>>        Get UtilTableIsAlias hTable to bIsAlias 
90580>>>        // If this is an Alias file there is nothing to convert to SQL.
90580>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
90580>>>        If (bIsAlias = True) Begin   
90582>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90585>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
90587>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName) 
90590>>>                Get psConnectionID to sConnectionID
90591>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
90592>>>            End
90592>>>>
90592>>>            Function_Return True
90593>>>        End
90593>>>>
90593>>>        
90593>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90596>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90599>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
90602>>>
90602>>>        If (ghoProgressBar <> 0) Begin
90604>>>            Send DoAdvance of ghoProgressBar
90605>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sLogicalName) * "Number:" * String(hTable))
90606>>>        End  
90606>>>>
90606>>>        
90606>>>        // Marco Kuipers suggestion;
90606>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
90606>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
90606>>>        // table again.
90606>>>        Get UtilTableIsSQL hTable to bOK
90607>>>        If (bOK = False) Begin
90609>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists 
90610>>>            If (bExists = True) Begin
90612>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
90613>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
90614>>>                Get phoLogFile to hoLogFile
90615>>>                If (hoLogFile <> 0) Begin
90617>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
90618>>>                    Send LogError sWarning False
90619>>>                End                                        
90619>>>>
90619>>>                Else Begin
90620>>>                    Error DFERR_PROGRAM sWarning
90621>>>>
90621>>>                End
90621>>>>
90621>>>            End
90621>>>>
90621>>>        End
90621>>>>
90621>>>        
90621>>>        // Does the rootname contain a driver?
90621>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
90623>>>            // Does the table already exist as an SQL table?
90623>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
90624>>>            // It can happen that the table is missing from Filelist.cfg but still
90624>>>            // exist on the SQL side, in case we want to search for the table by its name.
90624>>>            If (bExists = False) Begin
90626>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
90627>>>            End
90627>>>>
90627>>>            If (bExists = True) Begin
90629>>>                Set TableName_Text of ghoStatusPanel to ""
90630>>>                Function_Return False
90631>>>            End
90631>>>>
90631>>>        End
90631>>>>
90631>>>
90631>>>        Move CS_ANSI_Txt to sANSI_OEM
90632>>>        If (bToAnsi = False) Begin
90634>>>            Move CS_OEM_Txt to sANSI_OEM
90635>>>        End
90635>>>>
90635>>>
90635>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
90636>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
90636>>>        // passed as True, we adjust for that here.
90636>>>        Get IsMertechDriver sDriverID to bMertechDriver
90637>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
90639>>>            Move False to bUseConnectionID
90640>>>        End
90640>>>>
90640>>>
90640>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90641>>>        Move SQLConnection.sSchema           to sSchema
90642>>>        If (sSchema = "") Begin
90644>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema 
90645>>>            Move (Lowercase(sSchema))        to sSchema
90646>>>        End
90646>>>>
90646>>>
90646>>>        If (sDriverID = ORAFLEX) Begin
90648>>>            Move SQLConnection.sUserID       to sSchema
90649>>>        End
90649>>>>
90649>>>
90649>>>        Move SQLConnection.sDatabase         to sDatabase
90650>>>        Move SQLConnection.sConnectionID     to sConnectionID
90651>>>        Move SQLConnection.sConnectionString to sConnectionString
90652>>>        If (sConnectionID = "" or sConnectionString = "") Begin
90654>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
90655>>>>
90655>>>            Function_Return False
90656>>>        End
90656>>>>
90656>>>
90656>>>        Get AutoConnectionIDLogin to bOK
90657>>>        Open hTable
90659>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
90662>>>        If (bOpened = False) Begin
90664>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
90665>>>>
90665>>>            Function_Return False
90666>>>        End
90666>>>>
90666>>>
90666>>>        If (ghoProgressBar <> 0) Begin
90668>>>            Send DoAdvance of ghoProgressBar
90669>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
90670>>>        End  
90670>>>>
90670>>>        
90670>>>        Move 0 to hToTable
90671>>>        Get _TableNameOnly sRootName                 to sRootName
90672>>>        Move (sRootName + ".int")                    to sPhysicalName
90673>>>
90673>>>        Case Begin
90673>>>            Case (sDriverID = MSSQLDRV_ID)
90675>>>                Case Break
90676>>>            Case (sDriverID = ODBC_DRV_ID)
90679>>>                Case Break
90680>>>            Case (sDriverID = DB2_DRV_ID)
90683>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
90684>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
90685>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
90686>>>                Case Break
90687>>>            Case (sDriverID = ORAFLEX)
90690>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
90691>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
90692>>>                Case Break
90693>>>            Case (sDriverID = MDSMySQL)
90696>>>                Case Break
90697>>>            Case (sDriverID = MDSPgSQL)
90700>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
90701>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
90702>>>                Case Break
90703>>>            Case (sDriverID = DATAFLEX_ID)
90706>>>                Case Break
90707>>>            Case Else
90707>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
90708>>>>
90708>>>                Case Break
90709>>>        Case End
90709>>>
90709>>>        Move False to Err
90710>>>        
90710>>>        If (bIsAlias = False) Begin
90712>>>    
90712>>>            If (bMertechDriver = True) Begin
90714>>>                // Note: This function also sets the Err flag.
90714>>>                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
90715>>>            End
90715>>>>
90715>>>    
90715>>>            If (bMertechDriver = False) Begin
90717>>>                Structure_Start hToTable sDriverID
90718>>>                    Structure_Copy hTable to hToTable
90719>>>    
90719>>>                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
90722>>>    
90722>>>                    If (sDriverID <> DATAFLEX_ID) Begin
90724>>>                        If (bUseConnectionID = True) Begin
90726>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
90729>>>                        End
90729>>>>
90729>>>                        Else Begin
90730>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
90733>>>                        End
90733>>>>
90733>>>    
90733>>>                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
90736>>>                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
90739>>>    
90739>>>                        If (sSchema <> "") Begin
90741>>>                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
90744>>>                        End
90744>>>>
90744>>>    
90744>>>                        If (sDriverID = DB2_DRV_ID) Begin
90746>>>                            If (sLongTableSpace <> "") Begin
90748>>>                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
90751>>>                            End
90751>>>>
90751>>>                            If (sBaseTableSpace <> "") Begin
90753>>>                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
90756>>>                            End
90756>>>>
90756>>>                            If (sIndexTableSpace <> "") Begin
90758>>>                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
90761>>>                            End
90761>>>>
90761>>>                        End
90761>>>>
90761>>>                    End
90761>>>>
90761>>>    
90761>>>                Structure_End hToTable
90763>>>            End
90763>>>>
90763>>>    
90763>>>            Move (not(Err)) to bOK
90764>>>            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
90766>>>                If (bIsAlias = False) Begin
90768>>>                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
90769>>>                    If (ghoDbUpdateHandler > 0) Begin
90771>>>                        Get pbContinueOnError to bContinueOnError
90772>>>                    End
90772>>>>
90772>>>                    // If the data copy failed we will keep the newly created SQL table but
90772>>>                    // rename it by adding a GUID at the end of the table name
90772>>>                    // - or as much as "fit" because different SQL back-ends have
90772>>>                    // different rules how long a table name can be.
90772>>>                    // The new table will probably contain data but something went
90772>>>                    // wrong while converting the data from embedded to SQL.
90772>>>                    If (bOK = False and bContinueOnError = False) Begin
90774>>>                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
90775>>>                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
90776>>>                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
90777>>>>
90777>>>                    End
90777>>>>
90777>>>                End
90777>>>>
90777>>>            End
90777>>>>
90777>>>        End
90777>>>>
90777>>>        
90777>>>        If (bMertechDriver = True) Begin
90779>>>            Open hTable
90781>>>        End
90781>>>>
90781>>>
90781>>>        // This must be after copying data...
90781>>>        If (Err = False) Begin
90783>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
90786>>>            // We also adjust the display name by prefixing it by the schema name;
90786>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
90788>>>                // The max length for the display_name is 31 characters...
90788>>>                If (Length(sSchema + "." + sDisplayName) < 31) Begin
90790>>>                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
90793>>>                End
90793>>>>
90793>>>            End
90793>>>>
90793>>>        End
90793>>>>
90793>>>        
90793>>>        Close hTable
90794>>>        Move (not(Err)) to bOK
90795>>>        Function_Return (bOK = True)
90796>>>    End_Function  
90797>>>    
90797>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
90797>>>    // It will first drop all indicies, copy the data and then recreate indicies.
90797>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
90797>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
90799>>>        Boolean bOpened bOK
90799>>>        Integer hToTable iIndex iCount iRetval iVoid iOrgFreq
90799>>>        String sErrorFile sEmpty sPath
90799>>>
90799>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
90802>>>        Get AutoConnectionIDLogin to bOK
90803>>>        If (sDriverID = DATAFLEX_ID) Begin
90805>>>            Send IncreaseSortBufferSize
90806>>>//            Send SetAllIndexesToBatch hToTable
90806>>>        End
90806>>>>
90806>>>
90806>>>        Move False to Err
90807>>>        Open sPhysicalName as hToTable
90809>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
90812>>>        If (bOpened = False) Begin
90814>>>            Function_Return False
90815>>>        End
90815>>>>
90815>>>
90815>>>        If (ghoStatusPanel <> 0) Begin
90817>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
90818>>>        End
90818>>>>
90818>>>
90818>>>        Move "" to sEmpty
90819>>>        Move False to Err
90820>>>        Move True to bOK
90821>>>
90821>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
90824>>>//        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
90824>>>        If (sDriverID <> DATAFLEX_ID) Begin
90826>>>            // Remove all indices to speed up copying of data:
90826>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
90831>>>            If (iRetval <> 0) Begin
90833>>>                Error DFERR_PROGRAM ("Failed dropping indices for table:" * sRootName)
90834>>>>
90834>>>                Function_Return False
90835>>>            End
90835>>>>
90835>>>        End
90835>>>>
90835>>>
90835>>>        Move (sRootName + ".err") to sErrorFile
90836>>>        Move 0 to iIndex
90837>>>        Move False to Err
90838>>>
90838>>>        Copy_Records hFromTable to hToTable using 0 Callback Self
90841>>>
90841>>>        If (Err = False) Begin
90843>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
90844>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
90845>>>        End
90845>>>>
90845>>>
90845>>>        If (sDriverID <> DATAFLEX_ID) Begin
90847>>>            // Recreate indices:
90847>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
90852>>>        End
90852>>>>
90852>>>
90852>>>        Close hToTable
90853>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
90856>>>
90856>>>        If (bOK = True) Begin
90858>>>            Move (not(Err)) to bOK
90859>>>        End
90859>>>>
90859>>>
90859>>>        If (ghoStatusPanel <> 0) Begin
90861>>>            Set TableName_Text of ghoStatusPanel to ""
90862>>>            Set Message_Text   of ghoStatusPanel to ""
90863>>>            Set Action_Text    of ghoStatusPanel to ""
90864>>>        End
90864>>>>
90864>>>
90864>>>        Function_Return (bOK = True)
90865>>>    End_Function
90866>>>
90866>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
90866>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
90866>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
90868>>>        Handle hFile
90868>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
90868>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
90868>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened
90868>>>        tSQLConnection SQLConnection
90868>>>        tSQLConnection SQLConnection
90868>>>        tAPIColumn[] aColumns
90868>>>        tAPIColumn[] aColumns
90869>>>        tColumnType ColumnType
90869>>>        tColumnType ColumnType
90869>>>        
90869>>>        // First check if the passed filenumber already exists; in case we do nothing
90869>>>        Get UtilTableExists hTable to bOk
90870>>>        If (bOk = True) Begin
90872>>>            Function_Return False
90873>>>        End
90873>>>>
90873>>>        
90873>>>        Move sLogicalName to sTableName
90874>>>        If (ghoProgressBar <> 0) Begin
90876>>>            Send DoAdvance of ghoProgressBar
90877>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable))
90878>>>        End
90878>>>>
90878>>>
90878>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
90879>>>        Get psDriverID to sDriverID
90880>>>        Get IsSQLDriver sDriverID to bSqlDriver
90881>>>        Get piDbType to iDbType
90882>>>
90882>>>        // If no columns passed in, we need to create a "dummy" column 
90882>>>        Move False to bDeleteDummy 
90883>>>        If (Num_Arguments = 8) Begin
90885>>>            Move aColumnIn to aColumns
90886>>>        End
90886>>>>
90886>>>        If ((SizeOfArray(aColumns)) = 0) Begin
90888>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
90889>>>            Move ColumnType.iType to iDataType
90890>>>            If (bRecnum = False) Begin
90892>>>                Move C_tAPIColumn_Identity to iIdentityType
90893>>>            End                                            
90893>>>>
90893>>>            Else Begin
90894>>>                Move C_tAPIColumn_None     to iIdentityType
90895>>>            End
90895>>>>
90895>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
90896>>>            Move True to bDeleteDummy 
90897>>>        End  
90897>>>>
90897>>>        
90897>>>        // If columns have been passed as an array we need to check if an identity column
90897>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
90897>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be 
90897>>>        // two identity columns and SQL doesn't like that and throws an error.
90897>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
90899>>>            Move (SizeOfArray(aColumns)) to iSize
90900>>>            Decrement iSize
90901>>>            for iCount from 0 to iSize
90907>>>>
90907>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
90909>>>                    Move False to bRecnum  
90910>>>                    Move iSize to iCount
90911>>>                End
90911>>>>
90911>>>            Loop
90912>>>>
90912>>>        End
90912>>>>
90912>>>        
90912>>>        // If this is a SQL based driver we also check if the table exists
90912>>>        // in the SQL back end; in case we do nothing.
90912>>>        If (bSqlDriver = True) Begin
90914>>>            // Get all connection properties
90914>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90915>>>            Move SQLConnection.sSchema to sSchema
90916>>>            If (sSchema = "") Begin
90918>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
90919>>>            End   
90919>>>>
90919>>>
90919>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
90920>>>            // It can happen that the table is missing from Filelist.cfg but still
90920>>>            // exist on the SQL side, in case we want to search for the table by its name.
90920>>>            If (bExists = False) Begin
90922>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
90923>>>            End
90923>>>>
90923>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
90923>>>            // we will just add it to Filelist.cfg
90923>>>            If (bExists = True) Begin
90925>>>                If (bExistsInFilelist = False) Begin
90927>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
90929>>>                        Move (sDriverID + ":" + sRootName) to sRootName
90930>>>                    End
90930>>>>
90930>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
90933>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
90936>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName                        
90939>>>                    Move False to bSysFile
90940>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
90941>>>                End
90941>>>>
90941>>>                Function_Return False
90942>>>            End
90942>>>>
90942>>>        End
90942>>>>
90942>>>
90942>>>        Move CS_ANSI_Txt to sANSI_OEM
90943>>>        If (num_arguments > 6) Begin
90945>>>            If (bANSI = False) Begin
90947>>>                Move CS_OEM_Txt to sANSI_OEM
90948>>>            End
90948>>>>
90948>>>        End
90948>>>>
90948>>>
90948>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
90948>>>        // is a programmer's error and we auto-correct for it here.
90948>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
90948>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
90948>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
90948>>>        // set it back and use a Mertech function to convert it to SQL.
90948>>>        Get IsMertechDriver sDriverID to bMertechDriver
90949>>>        If (bMertechDriver = True) Begin
90951>>>            If (bUseConnectionID = True) Begin
90953>>>                Move False to bUseConnectionID
90954>>>            End
90954>>>>
90954>>>            Move sDriverID to sOriginalDriverID
90955>>>            Move DATAFLEX_ID to sDriverID
90956>>>        End
90956>>>>
90956>>>
90956>>>        Move False to Err
90957>>>        If (sDriverID = DATAFLEX_ID) Begin
90959>>>            Move sRootName to sPhysicalFile
90960>>>        End
90960>>>>
90960>>>
90960>>>        If (sDriverID <> DATAFLEX_ID) Begin
90962>>>            Move SQLConnection.sConnectionID to sConnectionID
90963>>>
90963>>>            // If DAW driver and we should use a connection id we need to
90963>>>            // check if the connection ID exists; else we create it before attempting creating the table
90963>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
90965>>>                Get IsConnectionID sConnectionID sDriverID to bExists
90966>>>                If (bExists = False) Begin
90968>>>                    Get UtilCreateConnectionID sConnectionID to bOk
90969>>>                    If (bOk = False) Begin
90971>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
90972>>>>
90972>>>                        Function_Return False
90973>>>                    End
90973>>>>
90973>>>                End
90973>>>>
90973>>>            End
90973>>>>
90973>>>
90973>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
90975>>>                Move (sTableName + ".int") to sPhysicalFile
90976>>>            End                                            
90976>>>>
90976>>>            Else Begin
90977>>>                Move (sRootName + ".int") to sPhysicalFile
90978>>>            End
90978>>>>
90978>>>            Move (Uppercase(sDisplayName)) to sVal
90979>>>            If (not(sVal contains (sSchema + "."))) Begin
90981>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
90982>>>            End
90982>>>>
90982>>>        End
90982>>>>
90982>>>        Move False to Err
90983>>>        Move 0 to hFile
90984>>>
90984>>>        Structure_Start hFile sDriverID
90985>>>            If (sDriverID <> DATAFLEX_ID) Begin
90987>>>                If (bUseConnectionID = True) Begin
90989>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
90992>>>                End
90992>>>>
90992>>>                Else Begin
90993>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
90996>>>                End
90996>>>>
90996>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
90999>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
91002>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
91005>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
91008>>>
91008>>>                If (sSchema <> "") Begin
91010>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
91013>>>                End
91013>>>>
91013>>>
91013>>>                If (sDriverID = DB2_DRV_ID) Begin
91015>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
91017>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
91020>>>                    End
91020>>>>
91020>>>                End
91020>>>>
91020>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
91022>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
91024>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
91027>>>                    End
91027>>>>
91027>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
91029>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
91032>>>                    End
91032>>>>
91032>>>                End
91032>>>>
91032>>>            End
91032>>>>
91032>>>
91032>>>            Set_Attribute DF_FILE_PHYSICAL_NAME                of hFile to sPhysicalFile
91035>>>            Send ApiColumnsAddToTable hFile aColumns True
91036>>>        Structure_End hFile
91038>>>
91038>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
91038>>>        If (bMertechDriver = True) Begin
91040>>>            Move sOriginalDriverID to sDriverID
91041>>>            If (not(sVal contains (sSchema + "."))) Begin
91043>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
91044>>>            End
91044>>>>
91044>>>            // Note: This function also sets the Err flag.
91044>>>            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
91045>>>        End
91045>>>>
91045>>>
91045>>>        Move (not(Err)) to bOK
91046>>>        If (bOk = True) Begin
91048>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
91050>>>                Move (sDriverID + ":" + sRootName) to sRootName
91051>>>            End
91051>>>>
91051>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
91054>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91057>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91060>>>
91060>>>            // Lastly we remove the temporary column we created above, if all went well.
91060>>>            If (bDeleteDummy) Begin
91062>>>                Get ApiColumnRemove hTable "temp" to bOk
91063>>>            End
91063>>>>
91063>>>        End
91063>>>>
91063>>>        
91063>>>        Close hTable
91064>>>        Function_Return (bOK = True)
91065>>>    End_Function
91066>>>
91066>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
91068>>>        Boolean bExists
91068>>>
91068>>>        Move False to Err
91069>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
91072>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
91075>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
91078>>>
91078>>>        Function_Return (Err = False)
91079>>>    End_Function
91080>>>
91080>>>    // ToDo: Needs to be revised
91080>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
91082>>>        Handle hTable
91082>>>        String sDEFName sDataPath sDriverID
91082>>>        Boolean bExists
91082>>>
91082>>>        // Do nothing if MSSQL Driver.
91082>>>//        Get IsMSSQLDriver to bExists
91082>>>//        If (bExists = True) Begin
91082>>>//            Procedure_Return
91082>>>//        End
91082>>>
91082>>>        Get psDataPathFirstPart to sDataPath
91083>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
91084>>>        If (bExists = True) Begin
91086>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
91086>>>            // still be missing from the filelist and needs to be added.
91086>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
91087>>>            If (bExists = True) Begin
91089>>>                Procedure_Return
91090>>>            End
91090>>>>
91090>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
91090>>>            Else Begin
91091>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
91094>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
91097>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
91100>>>                Procedure_Return
91101>>>            End
91101>>>>
91101>>>        End
91101>>>>
91101>>>
91101>>>        Move (sPath + sFileName + ".def") to sDEFName
91102>>>        Move 0 to hTable
91103>>>        Move False to Err
91104>>>
91104>>>        Structure_Start hTable DATAFLEX_ID
91105>>>            Load_Def sDEFName Onto hTable
91106>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
91109>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
91111>>>
91111>>>        Move iFilelistSlot to hTable
91112>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
91115>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
91118>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91121>>>
91121>>>    End_Procedure
91122>>>
91122>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
91124>>>        Boolean bTmp bErr bOK
91124>>>        String sTableName sDisplayName sFileName sDBOKeyWord sVal
91124>>>
91124>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
91124>>>        Move Err to bTmp
91125>>>        Move False to Err
91126>>>
91126>>>        Get AutoConnectionIDLogin to bOK
91127>>>        // First get the info for the current filelist slot:
91127>>>        Open iFromFileSlot
91129>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
91132>>>        If (bOK = True) Begin
91134>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
91137>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
91140>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
91143>>>
91143>>>            //...then move it.
91143>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
91146>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
91149>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
91152>>>
91152>>>            //...and finally remove the old filelist values.
91152>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
91155>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
91158>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
91161>>>        End
91161>>>>
91161>>>        Close iFromFileSlot
91162>>>
91162>>>        Move Err to bErr
91163>>>        Move bTmp to Err
91164>>>        Function_Return (bErr = False)
91165>>>    End_Function
91166>>>
91166>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
91168>>>        Handle hTable
91168>>>        Boolean bOK
91168>>>
91168>>>        Get AutoConnectionIDLogin to bOK
91169>>>        Move False to Err
91170>>>        Open hTableFrom Mode DF_EXCLUSIVE
91172>>>        If (hTableTo > 0) Begin
91174>>>            Open hTableTo
91176>>>        End
91176>>>>
91176>>>        Move hTableFrom to hTable
91177>>>
91177>>>        Structure_Start hTable
91178>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
91181>>>            If (iColumnTo <> 0) Begin
91183>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
91186>>>            End
91186>>>>
91186>>>        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE
91188>>>
91188>>>        Close hTableFrom
91189>>>        If (hTableTo > 0) Begin
91191>>>            Close hTableTo
91192>>>        End
91192>>>>
91192>>>
91192>>>        Function_Return (Err = False)
91193>>>    End_Function
91194>>>
91194>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
91194>>>    Function ApiTableRemove Handle hTable Returns Boolean
91196>>>        String sTableName sDriverID
91196>>>        Boolean bOk
91196>>>        String sDataPath
91196>>>
91196>>>        Get AutoConnectionIDLogin to bOK
91197>>>        Move False to Err
91198>>>        Get psDriverID to sDriverID
91199>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
91200>>>        If (sTableName = "") Begin
91202>>>            Function_Return False
91203>>>        End
91203>>>>
91203>>>
91203>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
91204>>>        Delete_db sTableName
91205>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
91206>>>
91206>>>        If (sDriverID <> DATAFLEX_ID) Begin
91208>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
91209>>>            Get psDataPathFirstPart to sDataPath
91210>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
91211>>>        End
91211>>>>
91211>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
91211>>>        If (hTable <> 0) Begin
91213>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
91216>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
91219>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
91222>>>        End
91222>>>>
91222>>>        
91222>>>        Close hTable
91223>>>        Function_Return (hTable <> 0)
91224>>>    End_Function
91225>>>
91225>>>    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
91227>>>        Handle hTable
91227>>>        Boolean bOK
91227>>>
91227>>>        Get AutoConnectionIDLogin to bOK
91228>>>        Move False to Err
91229>>>        Open hTableTo Mode DF_EXCLUSIVE
91231>>>        Move hTableTo to hTable
91232>>>
91232>>>        Structure_Start hTable
91233>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
91236>>>        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE
91238>>>
91238>>>        Close hTableTo
91239>>>        Function_Return (Err = False)
91240>>>    End_Function
91241>>>
91241>>>    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
91243>>>        String sPhysicalName sDataPath sDriverID
91243>>>        Boolean bOK bExists
91243>>>        Integer iRetval
91243>>>
91243>>>        Move False to Err
91244>>>        Get psDataPathFirstPart to sDataPath
91245>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
91248>>>
91248>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91251>>>        Close hTable
91252>>>        If (sDriverID = DATAFLEX_ID) Begin
91254>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
91255>>>            If (bExists = True) Begin
91257>>>                If (Uppercase(sPhysicalName) = Uppercase(sRootName)) Begin
91259>>>                    Function_Return False
91260>>>                End
91260>>>>
91260>>>            End
91260>>>>
91260>>>            Copy_db (sDataPath + sPhysicalName) to (sDataPath + sRootName)
91263>>>        End
91263>>>>
91263>>>
91263>>>        If (sDriverID <> DATAFLEX_ID) Begin
91265>>>            Move (sDriverID + ":" + sRootName) to sRootName
91266>>>        End
91266>>>>
91266>>>
91266>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
91269>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91272>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91275>>>
91275>>>        // We need a short break here before attempting to delete the physical file or Windows
91275>>>        // might report "File in use..." and the deletion will fail.
91275>>>        Sleep 2
91276>>>        If (sDriverID = DATAFLEX_ID) Begin
91278>>>            Get vDeleteFile (sDataPath + sPhysicalName + ".*") to bOK
91279>>>        End
91279>>>>
91279>>>
91279>>>        Function_Return (Err = False)
91280>>>    End_Function
91281>>>
91281>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
91283>>>        Move False to Err
91284>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91287>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91290>>>
91290>>>        Function_Return (Err = False)
91291>>>    End_Function                        
91292>>>    
91292>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
91292>>>    // Note that it first removes any driver prefixes in the rootname.
91292>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
91294>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
91294>>>        Boolean bTheSame bIsSQL 
91294>>>        Handle hTable
91294>>>        
91294>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91294>>>        Move APITableInfo.iTableNumber      to hTable
91295>>>        Get UtilTableIsSQL hTable           to bIsSQL
91296>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
91297>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo  
91300>>>        Get _TableNameOnly sRootNameTo                to sRootNameTo
91301>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
91304>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
91307>>>        
91307>>>        If (bCompareFilelistUppercase = True) Begin
91309>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bTheSame                  
91310>>>        End
91310>>>>
91310>>>        Else Begin
91311>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bTheSame                  
91312>>>        End
91312>>>>
91312>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
91312>>>            
91312>>>        Function_Return bTheSame
91313>>>    End_Function  
91314>>>    
91314>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
91316>>>        Handle hFile hTable 
91316>>>        String sTableName sLogicalName sDisplayName 
91316>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
91316>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
91316>>>        Boolean bOk bExists bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened bSameColumnDefinitions
91316>>>        Boolean bUseConnectionID bToANSI bRecnum bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase bExistingTable
91316>>>        Boolean bIsSame bSameTableNames bIsOpen bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
91316>>>        tSQLConnection SQLConnection  
91316>>>        tSQLConnection SQLConnection  
91316>>>        tColumnType    ColumnType
91316>>>        tColumnType    ColumnType
91316>>>        tAPITable      APITableFrom APITableTo
91316>>>        tAPITable      APITableFrom APITableTo
91316>>>        
91316>>>        // We don't allow update of the framework's DbVersion table.
91316>>>        If (Uppercase(sTableName) = "DBVERSION") Begin
91318>>>            Function_Return False
91319>>>        End
91319>>>>
91319>>>        
91319>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
91320>>>        Get piDbType                            to iDbType
91321>>>        Get pbUseConnectionID                   to bUseConnectionID
91322>>>        Get pbRecnum                            to bRecnum
91323>>>        Get pbToANSI                            to bToANSI
91324>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
91325>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
91326>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase 
91327>>>        
91327>>>        Move CS_ANSI_Txt to sANSI_OEM
91328>>>        If (bToANSI = False) Begin
91330>>>            Move CS_OEM_Txt to sANSI_OEM
91331>>>        End
91331>>>>
91331>>>        Move APITableNameInfoFrom.sRootName  to sTableName
91332>>>        Get _TableNameOnly sTableName        to sTableName
91333>>>        If (sDriverIDFrom = DATAFLEX_ID) Begin
91335>>>            Move sTableName to sPhysicalFile
91336>>>        End
91336>>>>
91336>>>
91336>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
91336>>>        // is a programmer's error and we auto-correct for it here.
91336>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
91336>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
91336>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
91336>>>        // set it back and use a Mertech function to convert it to SQL.
91336>>>        Get IsMertechDriver sDriverIDFrom to bMertechDriver
91337>>>        If (bMertechDriver = True) Begin
91339>>>            If (bUseConnectionID = True) Begin
91341>>>                Move False to bUseConnectionID
91342>>>            End
91342>>>>
91342>>>            Move sDriverIDFrom to sOriginalDriverID
91343>>>            Move DATAFLEX_ID to sDriverIDFrom
91344>>>        End
91344>>>>
91344>>>        
91344>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
91345>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
91346>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
91347>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
91348>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
91349>>>        Move APITableNameInfoFrom.sRootName     to sRootName
91350>>>        Move APITableNameInfoFrom.sLogicalName  to sLogicalName
91351>>>        Move APITableNameInfoFrom.sDisplayName  to sDisplayName
91352>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
91353>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
91354>>>        
91354>>>        // 'To' table properties:
91354>>>        Get UtilTableIsAlias hTable             to bIsAliasTo
91355>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
91356>>>        If (bIsSQLTableTo = False) Begin
91358>>>            Move DATAFLEX_ID to sDriverIDTo
91359>>>        End                                
91359>>>>
91359>>>        Else Begin
91360>>>            Move sDriverIDFrom to sDriverIDTo
91361>>>        End
91361>>>>
91361>>>        
91361>>>        // Does the 'To' table exist in Filelist.cfg _and_ on disk (embedded) or on the SQL back-end.
91361>>>        Get UtilTableExists  hTable             to bExistingTable
91362>>>        If (bExistingTable = False and bIsSQLTableFrom = True and bMertechDriver = False) Begin
91364>>>            Move True                           to bIsSQLTableTo 
91365>>>            Move sDriverIDFrom                  to sDriverIDTo   
91366>>>        End
91366>>>>
91366>>>        // Does table exist in Filelist.cfg:
91366>>>        Get UtilTableNumberIsInUse hTable       to bExistsInFilelist 
91367>>>
91367>>>        If (bIsSQLTableFrom = False and sDriverIDFrom <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverIDFrom)) Begin
91369>>>            Move (sDriverIDFrom + ":" + sRootName) to sRootName
91370>>>        End
91370>>>>
91370>>>
91370>>>        If (ghoProgressBar <> 0) Begin
91372>>>            Send DoAdvance of ghoProgressBar   
91373>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sTableName) * "Number:" * String(hTable))
91374>>>        End   
91374>>>>
91374>>>        
91374>>>        // a) The table is an Alias table:
91374>>>        //
91374>>>        // If this is an Alias file the Logical or Display name might have changed. Other than that
91374>>>        // there is nothing that can be updated for an Alias table.
91374>>>        // But we change all three attributes in case this is a new Alias table.
91374>>>        If (bIsAliasFrom = True) Begin           
91376>>>            // ToDo: The first param needs to be paramerized:
91376>>>            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
91377>>>            If (bSameTableNames = True) Begin
91379>>>                Function_Return True
91380>>>            End
91380>>>>
91380>>>            Else Begin 
91381>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
91383>>>                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sTableName
91386>>>                End                                                           
91386>>>>
91386>>>                Else Begin
91387>>>                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName  
91390>>>                End
91390>>>>
91390>>>                Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91393>>>                Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName                        
91396>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
91398>>>                    Get SqlUtilCreateIntFile hTable sDriverIDFrom sConnectionID True False to bOk
91399>>>                End
91399>>>>
91399>>>            End  
91399>>>>
91399>>>            Function_Return True
91400>>>        End                                                           
91400>>>>
91400>>>        
91400>>>        Move hTable         to APITableTo.ApiTableInfo.iTableNumber
91401>>>        If (bIsSQLTableTo = True) Begin
91403>>>            Move sRootName  to APITableTo.ApiTableInfo.sRootName
91404>>>        End 
91404>>>>
91404>>>        Else Begin
91405>>>            Move sTableName to APITableTo.ApiTableInfo.sRootName
91406>>>        End
91406>>>>
91406>>>        
91406>>>        Move sLogicalName   to APITableTo.ApiTableInfo.sLogicalName
91407>>>        Move sDisplayName   to APITableTo.ApiTableInfo.sDisplayName
91408>>>        Move bIsAliasTo     to APITableTo.ApiTableInfo.bIsAlias
91409>>>        Move bIsSQLTableTo  to APITableTo.ApiTableInfo.bIsSQL
91410>>>        
91410>>>        // b) Table exists in Filelist.cfg. We will then compare & check the Filelist.cfg entries for differences.
91410>>>        If (bExistsInFilelist = True) Begin
91412>>>            // ToDo: The first param needs to be paramerized:
91412>>>            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
91413>>>            If (bSameTableNames = False) Begin
91415>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
91417>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
91420>>>                End
91420>>>>
91420>>>                Else Begin
91421>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to APITableFrom.ApiTableInfo.sRootName
91424>>>                End
91424>>>>
91424>>>                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableFrom.ApiTableInfo.sLogicalName
91427>>>                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableFrom.ApiTableInfo.sDisplayName                        
91430>>>            End  
91430>>>>
91430>>>        End                                     
91430>>>>
91430>>>        
91430>>>        // c) Both exists in Filelist.cfg and the table exists on disk (embedded) or as an SQL table. 
91430>>>        //    We then check for differences.
91430>>>        If (bExistingTable = True) Begin 
91432>>>            Get UtilColumnsStructFill  hTable to APITableTo.aApiColumns
91433>>>            Get UtilIndexesStructFill  hTable to APITableTo.aApiIndexes
91434>>>            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
91435>>>        
91435>>>            Move False to bFilelistError
91436>>>            Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
91437>>>            // If there was a "Filelist" error (aka the logical names for the 'From' and 'To' tables weren't the same,
91437>>>            // we will _not_ attempt to make any table changes. An error has by now been generated and will
91437>>>            // appear in the logfile.
91437>>>            // Of course, if the tables were the same we also do nothing.
91437>>>            If (bFilelistError = True or bIsSame = True) Begin
91439>>>                Set TableName_Text of ghoStatusPanel to ""
91440>>>                Function_Return True
91441>>>            End
91441>>>>
91441>>>        End
91441>>>>
91441>>>        
91441>>>        // d) Create as new Table?
91441>>>        //
91441>>>        Move False to Err
91442>>>        If (bExistingTable = False) Begin
91444>>>            Get ApiTableCreate hTable sRootName sDisplayName sTableName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
91445>>>            Function_Return bOk // And we're done.
91446>>>        End
91446>>>>
91446>>>        
91446>>>        // e) If we got this far we need to Update the table:
91446>>>        //    This is the last case (a-e).
91446>>>        If (ghoProgressBar <> 0) Begin
91448>>>            Send DoAdvance of ghoProgressBar   
91449>>>            Set TableName_Text of ghoStatusPanel to ("Updating Table:" * String(sTableName) * "Number:" * String(hTable))
91450>>>        End
91450>>>>
91450>>>        
91450>>>        // If an SQL 'To' table we fetch the connection details for login & Schema:
91450>>>        If (bIsSQLTableTo = True) Begin
91452>>>
91452>>>            // Get connection properties
91452>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91453>>>            Move SQLConnection.sSchema to sSchema
91454>>>            If (sSchema = "") Begin
91456>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
91457>>>            End                                            
91457>>>>
91457>>>            Move SQLConnection.sConnectionID to sConnectionID
91458>>>
91458>>>            // If a DAW driver and using a connection id we need to check if it exists;
91458>>>            // else we create it before attempting creating the table
91458>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
91460>>>                Get IsConnectionID sConnectionID sDriverIDFrom to bExists
91461>>>                If (bExists = False) Begin
91463>>>                    Get UtilCreateConnectionID sConnectionID to bOk
91464>>>                    If (bOk = False) Begin
91466>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
91467>>>>
91467>>>                        Function_Return False
91468>>>                    End
91468>>>>
91468>>>                End
91468>>>>
91468>>>            End
91468>>>>
91468>>>
91468>>>            Move (sTableName + ".int") to sPhysicalFile
91469>>>            Move (Uppercase(sDisplayName)) to sVal
91470>>>            // Pre-face the DisplayName with the schema name;
91470>>>            // that is how DAW's tools does it.
91470>>>            If (not(sVal contains (sSchema + "."))) Begin
91472>>>                Move (Lowercase(sSchema) + "." + sLogicalName) to sDisplayName
91473>>>            End
91473>>>>
91473>>>        End 
91473>>>>
91473>>>        
91473>>>        Open hTable Mode DF_EXCLUSIVE
91475>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91478>>>        If (bOpened = False) Begin
91480>>>            Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
91481>>>            Function_Return False
91482>>>        End
91482>>>>
91482>>>                
91482>>>        Move False to Err
91483>>>        Move hTable to hFile
91484>>>
91484>>>        // This will create new columns or update existing ones.     
91484>>>        Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
91485>>>                
91485>>>        If (bOk = True) Begin             
91487>>>            If (bExistingTable = False) Begin
91489>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
91491>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
91494>>>                End                                                            
91494>>>>
91494>>>                Else Begin
91495>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91498>>>                End
91498>>>>
91498>>>                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91501>>>                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName 
91504>>>                If (bIsSQLTableTo = True) Begin
91506>>>                    Get SqlUtilUpdateIntFile hTable to bOk
91507>>>                End
91507>>>>
91507>>>            End
91507>>>>
91507>>>
91507>>>            // Compare Indexes and if different; either create or change them 
91507>>>            Get UtilIndexesStructFill hTable to APITableTo.aApiIndexes
91508>>>            Get UtilIndexesCompare hTable APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
91509>>>            If (bIsSame = False) Begin
91511>>>                Get UtilIndexesUpdate hFile APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
91512>>>            End
91512>>>>
91512>>>            
91512>>>            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
91513>>>            Get UtilRelationsCompare hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
91514>>>            If (bIsSame = False) Begin
91516>>>                Get UtilRelationsUpdate hFile APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
91517>>>            End
91517>>>>
91517>>>        End
91517>>>>
91517>>>        
91517>>>        Close hTable
91518>>>        Set TableName_Text of ghoStatusPanel to ""
91519>>>
91519>>>        Function_Return (bOK = True)
91520>>>    End_Function                                                                                                        
91521>>>
91521>>>    // *** Field/Column Level Functions: ***
91521>>>    //
91521>>>    // Adds a column name to the passed table number.
91521>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
91523>>>        Integer iColumn iCount iFile iPrecision
91523>>>        Boolean bExists bOK bInitializeValue bRetval
91523>>>        String sDdSrcPath sTableName sColumnValue
91523>>>
91523>>>        Get UtilColumnExists hTable sFieldName to bExists  
91524>>>        Move False to Err
91525>>>        If (bExists = True) Begin
91527>>>            Function_Return False
91528>>>        End 
91528>>>>
91528>>>        If (num_arguments > 4) Begin
91530>>>            Move iPrec to iPrecision
91531>>>        End
91531>>>>
91531>>>        If (num_arguments > 6) Begin
91533>>>            Move bInitVal to bInitializeValue
91534>>>            Move sColVal  to sColumnValue
91535>>>        End
91535>>>>
91535>>>        If (iType < -1490) Begin
91537>>>            Move (iType + 1500) to iType
91538>>>        End
91538>>>>
91538>>>        
91538>>>        Get AutoConnectionIDLogin to bOK
91539>>>        Move False to Err
91540>>>        // Structure_start will change the value of hTable...
91540>>>        Move hTable to iFile
91541>>>        Open iFile Mode DF_EXCLUSIVE
91543>>>
91543>>>        Structure_Start iFile
91544>>>            Move 0 to iColumn
91545>>>            Create_Field hTable At iColumn
91546>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
91549>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
91552>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to iLength
91555>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
91558>>>        Structure_End iFile
91560>>>
91560>>>        // If in development environment; create .fd file:
91560>>>        Open hTable
91562>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
91563>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
91564>>>        If (iCount > 1) Begin
91566>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
91567>>>        End
91567>>>>
91567>>>        Get vFolderExists sDDSrcPath to bExists
91568>>>        If (bExists = True) Begin
91570>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
91571>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
91574>>>            Get _TableNameOnly sTableName to sTableName
91575>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
91577>>>        End
91577>>>>
91577>>>        
91577>>>        // Check for a default value
91577>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
91579>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
91580>>>        End
91580>>>>
91580>>>        Close hTable
91581>>>
91581>>>        Function_Return (Err = False)
91582>>>    End_Function   
91583>>>    
91583>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean 
91583>>>//        Integer iColumn iCount iFile
91583>>>//        Boolean bExists bOK  
91583>>>//        String sDdSrcPath sTableName
91583>>>//    
91583>>>//        Get AutoConnectionIDLogin to bOK
91583>>>//        Move False to Err   
91583>>>//        
91583>>>//        // Structure_start will change the value of hTable...
91583>>>//        Move hTable to iFile
91583>>>//        Open iFile Mode DF_EXCLUSIVE
91583>>>//        
91583>>>//        Structure_Start iFile
91583>>>//            Send ApiColumnsAddToTable iFile aColumns False
91583>>>//        Structure_End iFile
91583>>>//        
91583>>>//        // If in development environment; create .fd file:
91583>>>//        Open hTable
91583>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
91583>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
91583>>>//        If (iCount > 1) Begin
91583>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath    
91583>>>//        End 
91583>>>//        Get vFolderExists sDDSrcPath to bExists
91583>>>//        If (bExists = True) Begin                                   
91583>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath 
91583>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
91583>>>//            Get _TableNameOnly sTableName to sTableName 
91583>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
91583>>>//        End
91583>>>//        Close hTable
91583>>>//
91583>>>//        Function_Return (Err = False)
91583>>>//    End_Function
91583>>>
91583>>>    // To update all records for a table column with a fixed value.
91583>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
91585>>>        Integer iRecs iCurrErr iField iRecord
91585>>>        Boolean bRetval bOpen
91585>>>        
91585>>>        Move 0 to iRecs                
91586>>>        Move False to bRetval 
91587>>>        Move Err to iCurrErr
91588>>>        Move False to Err
91589>>>        
91589>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91592>>>        If (bOpen = False) Begin
91594>>>            Open hTable
91596>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91599>>>            If (bOpen = False) Begin
91601>>>                Function_Return bRetval
91602>>>            End
91602>>>>
91602>>>        End
91602>>>>
91602>>>        
91602>>>        Field_Map hTable sFieldName to iField
91604>>>        If (iField <> 0) Begin
91606>>>            Clear hTable
91607>>>            Repeat
91607>>>>
91607>>>                Vfind hTable 0 GT
91609>>>                If (Found) Begin
91611>>>                    If (ghoStatusPanel <> 0) Begin
91613>>>                        Get_Field_Value hTable 0 to iRecord
91616>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
91617>>>                    End
91617>>>>
91617>>>                    Reread hTable
91621>>>                        Set_Field_Value hTable iField to sColumnValue
91624>>>                        SaveRecord hTable
91625>>>                    Unlock   
91626>>>>
91626>>>                End
91626>>>>
91626>>>           Until (not(Found))
91628>>>        End
91628>>>>
91628>>>        
91628>>>        Move (Err = False) to bRetval
91629>>>        Move iCurrErr to Err
91630>>>        
91630>>>        Function_Return bRetval
91631>>>    End_Function  
91632>>>    
91632>>>    Procedure ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating
91634>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
91634>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen
91634>>>        String sFieldName sDriverID sTableName
91634>>>        
91634>>>        Get psDriverID to sDriverID                      
91635>>>        Get piDbType to iDbType
91636>>>        Get UtilTableHandleToString hTable to sTableName
91637>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
91638>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver                     
91639>>>        Get UtilTableIsSQL hTable to bIsSqlTable 
91640>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
91642>>>            Move True to bIsSqlTable
91643>>>        End
91643>>>>
91643>>>        Move False to bIsOpen
91644>>>        If (hTable > 0) Begin
91646>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91649>>>        End
91649>>>>
91649>>>        If (bIsOpen = True) Begin
91651>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
91654>>>        End 
91654>>>>
91654>>>        Else Begin
91655>>>            Move True to bRecnumTable
91656>>>        End
91656>>>>
91656>>>        
91656>>>        Move (SizeOfArray(aColumns)) to iSize
91657>>>        Decrement iSize
91658>>>        for iCount from 0 to iSize   
91664>>>>
91664>>>            Move aColumns[iCount].sFieldName to sFieldName
91665>>>            If (hTable > 0) Begin    
91667>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91668>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
91669>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
91672>>>                Move (Trim(sFieldName) <> "") to bFieldExists
91673>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91674>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
91675>>>            End
91675>>>>
91675>>>            Else Begin
91676>>>                Move False to bFieldExists
91677>>>            End
91677>>>>
91677>>>            
91677>>>            If (bFieldExists = False) Begin 
91679>>>                Move 0 to iColumn
91680>>>                Create_Field hTable At iColumn                                                   
91681>>>            End  
91681>>>>
91681>>>            Else Begin
91682>>>                Move iCount to iColumn
91683>>>            End
91683>>>>
91683>>>            
91683>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
91684>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName                             
91687>>>
91687>>>            Move aColumns[iCount].iType to iType
91688>>>            Move (not(iType < -1490)) to bNativeType
91689>>>            If (iType < -1490) Begin
91691>>>                Move (iType + 1500) to iType
91692>>>            End
91692>>>>
91692>>>            
91692>>>            If (bIsSqlTable = True) Begin
91694>>>                If (aColumns[iCount].bIsSQLType = True) Begin
91696>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
91697>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iDataFlexType
91700>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType  
91703>>>                End
91703>>>>
91703>>>                Else Begin
91704>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
91707>>>                End
91707>>>>
91707>>>            End
91707>>>>
91707>>>            Else Begin
91708>>>                If (bCreating = False) Begin
91710>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
91711>>>                End
91711>>>>
91711>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
91714>>>            End
91714>>>>
91714>>>            
91714>>>            Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
91717>>>            Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
91720>>>            
91720>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
91722>>>                If (bRecnumTable = False) Begin
91724>>>                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True 
91727>>>                End
91727>>>>
91727>>>                
91727>>>                Move 0 to iIndex 
91728>>>                Create_Index hTable at iIndex
91729>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
91732>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn  
91735>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
91738>>>                
91738>>>                // If we have an identity table - we must create a primary_key table. 
91738>>>                If (bIsSqlTable = True) Begin
91740>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True     
91743>>>                End
91743>>>>
91743>>>            End
91743>>>>
91743>>>        Loop
91744>>>>
91744>>>    End_Procedure
91745>>>
91745>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
91747>>>        Integer iCount iSize iColumn iType iIndex iColumnsToSize hFile
91747>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsSame bOK bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen
91747>>>        String sFieldName sTableName sDriverTo
91747>>>        
91747>>>        Move False to Err
91748>>>        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
91749>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
91750>>>        If (bIsSQLTableTo = False) Begin
91752>>>            Move DATAFLEX_ID to sDriverTo
91753>>>        End                            
91753>>>>
91753>>>        Else Begin
91754>>>            Get psDriverID to sDriverTo
91755>>>        End
91755>>>>
91755>>>        Get UtilTableHandleToString hTable to sTableName
91756>>>        
91756>>>        Move (SizeOfArray(aColumnsFrom)) to iSize 
91757>>>        Move (SizeOfArray(aColumnsTo)) to iColumnsToSize
91758>>>        Get OpenTableExclusive hTable to bOpened
91759>>>        
91759>>>        Decrement iSize
91760>>>        For iCount from 0 to iSize   
91766>>>>
91766>>>            Move aColumnsFrom[iCount].sFieldName   to sFieldName
91767>>>            Move aColumnsFrom[iCount].iFieldNumber to iColumn
91768>>>            If (hTable > 0) Begin                       
91770>>>                Move False to bFieldExists
91771>>>                If (iCount < iColumnsToSize) Begin
91773>>>                    Move aColumnsTo[iCount].sFieldName to sFieldName
91774>>>                    Move (Trim(sFieldName) <> "") to bFieldExists
91775>>>                End
91775>>>>
91775>>>            End
91775>>>>
91775>>>            Else Begin
91776>>>                Move False to bFieldExists
91777>>>            End
91777>>>>
91777>>>            
91777>>>            If (bFieldExists = True) Begin     
91779>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91780>>>                Get UtilColumnCompare sDriverIDFrom bIsSQLTableFrom bIsSQLTableTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DateTime to bIsSame
91781>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91782>>>                If (bIsSame = False) Begin  
91784>>>                    // ToDo: We might need to set more properties for the field than what currently is set...
91784>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91785>>>                    Get ApiColumnChangeByColumnNumber sDriverIDFrom bIsSQLTableFrom hTable bIsSQLTableTo aColumnsFrom[iCount].sFieldName aColumnsFrom[iCount].iFieldNumber aColumnsFrom[iCount].iType aColumnsFrom[iCount].iLength aColumnsFrom[iCount].iPrecision aColumnsFrom[iCount].iOptions to bOK
91786>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
91787>>>                End
91787>>>>
91787>>>            End
91787>>>>
91787>>>            
91787>>>            If (bFieldExists = False) Begin  
91789>>>                Move False to bIsOpen
91790>>>                If (hTable > 0) Begin        
91792>>>                    Close hTable
91793>>>                    Open hTable Mode DF_EXCLUSIVE
91795>>>                    Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91798>>>                End
91798>>>>
91798>>>                If (bIsOpen = True) Begin
91800>>>                    Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
91803>>>                End 
91803>>>>
91803>>>                Else Begin
91804>>>                    Move True to bRecnumTable
91805>>>                End
91805>>>>
91805>>>
91805>>>                Move hTable to hFile
91806>>>                Structure_Start hFile sDriverIDFrom
91807>>>                    Move aColumnsFrom[iCount].iFieldNumber to iColumn
91808>>>                    Create_Field hFile At iColumn                                                   
91809>>>                    Set_Attribute DF_FIELD_NAME   of hFile iColumn to aColumnsFrom[iCount].sFieldName                                 
91812>>>//                    If (bIsSQLTable = True) Begin
91812>>>//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength - aColumnsFrom[iCount].iPrecision)
91812>>>                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to aColumnsFrom[iCount].iLength
91815>>>//                    End
91815>>>//                    Else Begin
91815>>>//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength + aColumnsFrom[iCount].iPrecision)
91815>>>//                    End
91815>>>                    
91815>>>                    If (aColumnsFrom[iCount].iPrecision > 0) Begin
91817>>>                        Set_Attribute DF_FIELD_PRECISION of hFile iColumn to aColumnsFrom[iCount].iPrecision
91820>>>                    End
91820>>>>
91820>>>                    
91820>>>                    Move aColumnsFrom[iCount].iType to iType
91821>>>                    Move (not(iType < -1490)) to bNativeType
91822>>>                    If (iType < -1490) Begin
91824>>>                        Move (iType + 1500) to iType
91825>>>                    End
91825>>>>
91825>>>                    // ToDo: This test is not enough. Do check for bSQLTableFrom
91825>>>                    If (bIsSQLTableTo = True) Begin
91827>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
91830>>>                    End
91830>>>>
91830>>>                    Else Begin
91831>>>                        Set_Attribute DF_FIELD_TYPE of hFile iColumn to iType
91834>>>                    End
91834>>>>
91834>>>                    
91834>>>                    If (aColumnsFrom[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
91836>>>                        If (bRecnumTable = False) Begin
91838>>>                            Set_Attribute DF_FIELD_IS_IDENTITY     of hFile iColumn to True 
91841>>>                        End
91841>>>>
91841>>>                        // If we have an identity table - we must create a primary_key table. 
91841>>>                        Move 0 to iIndex 
91842>>>                        Create_Index hFile at iIndex
91843>>>                        Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
91846>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn  
91849>>>                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile iIndex to 1
91852>>>                        If (bIsSQLDriver = True) Begin
91854>>>                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True     
91857>>>                        End
91857>>>>
91857>>>                    End  
91857>>>>
91857>>>                Structure_End hFile
91859>>>    
91859>>>            End
91859>>>>
91859>>>        Loop
91860>>>>
91860>>>            
91860>>>        Function_Return (Err = False)
91861>>>    End_Function
91862>>>
91862>>>    // Changes a field type, length and precision for the passed table number and field name
91862>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
91864>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
91864>>>        Boolean bOK bIsSqlTable  
91864>>>        String sFieldNameTo
91864>>>
91864>>>        If (num_arguments > 4) Begin
91866>>>            Move iPrec to iPrecFrom
91867>>>        End
91867>>>>
91867>>>        If (iTypeFrom < -1490) Begin
91869>>>            Move (iTypeFrom + 1500) to iTypeFrom
91870>>>        End
91870>>>>
91870>>>        
91870>>>        Get AutoConnectionIDLogin to bOK
91871>>>        Move False to Err
91872>>>        Get OpenTableExclusive hTable to bOK
91873>>>        If (bOK = False) Begin
91875>>>            Function_Return False
91876>>>        End  
91876>>>>
91876>>>        
91876>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91877>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
91878>>>        Field_Map hTable sFieldNameFrom to iColumn
91880>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91881>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
91882>>>        If (Err = True) Begin
91884>>>            Function_Return False
91885>>>        End
91885>>>>
91885>>>        
91885>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
91888>>>        Get UtilTableIsSQL hTable to bIsSqlTable
91889>>>        If (bIsSqlTable = False) Begin
91891>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
91894>>>        End
91894>>>>
91894>>>        Else Begin
91895>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
91898>>>        End 
91898>>>>
91898>>>        // Let the driver decide the other values;
91898>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
91901>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
91904>>>        
91904>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
91906>>>            Function_Return False
91907>>>        End
91907>>>>
91907>>>
91907>>>        Structure_Start hTable      
91908>>>            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
91911>>>            If (bIsSqlTable = False) Begin
91913>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
91916>>>            End
91916>>>>
91916>>>            Else Begin
91917>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
91920>>>                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
91923>>>            End
91923>>>>
91923>>>            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
91926>>>            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
91929>>>        Structure_End hTable
91931>>>
91931>>>        Function_Return (Err = False)
91932>>>    End_Function
91933>>>
91933>>>    // Changes a field type, length and precision for the passed table number and field name
91933>>>    Function ApiColumnChangeByColumnNumber String sDriverID Boolean bIsSQLTableFrom Handle hTable Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
91935>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType
91935>>>        Boolean bOK bIsSQL bCompareDate_DateTime bSkip
91935>>>        String sFieldNameTo    
91935>>>        tColumnType ColumnType
91935>>>        tColumnType ColumnType
91935>>>        
91935>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
91936>>>        Get piDbType to iDbType
91937>>>        If (num_arguments > 4) Begin
91939>>>            Move iPrec to iPrecFrom                                    
91940>>>            Move iOpt  to iOptionFrom
91941>>>        End
91941>>>>
91941>>>        If (iTypeFrom < -1490) Begin
91943>>>            Move (iTypeFrom + 1500) to iTypeFrom
91944>>>        End
91944>>>>
91944>>>        
91944>>>        Get UtilTableIsSql hTable to bIsSQL
91945>>>        Get AutoConnectionIDLogin to bOK
91946>>>        Move False to Err
91947>>>        Get OpenTableExclusive hTable to bOK
91948>>>        If (bOK = False) Begin
91950>>>            Function_Return False
91951>>>        End  
91951>>>>
91951>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
91954>>>        
91954>>>        If (bIsSQLTableTo = True) Begin
91956>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
91959>>>        End
91959>>>>
91959>>>        Else Begin
91960>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
91963>>>        End
91963>>>>
91963>>>        
91963>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
91966>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
91969>>>        Get_Attribute DF_FIELD_IS_IDENTITY          of hTable iColumn to iOptionTo
91972>>>        
91972>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
91972>>>        // data types between Embedded and SQL.
91972>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
91974>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iTypeFrom
91975>>>        End
91975>>>>
91975>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
91978>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeTo   iLengthTo   to iTypeTo
91979>>>        End
91979>>>>
91979>>>        
91979>>>        
91979>>>        If (bCompareDate_DateTime = False) Begin
91981>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
91982>>>            If (bSkip = True) Begin
91984>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
91986>>>                    Function_Return False
91987>>>                End
91987>>>>
91987>>>            End
91987>>>>
91987>>>        End
91987>>>>
91987>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
91990>>>            Function_Return False
91991>>>        End
91991>>>>
91991>>>
91991>>>        Structure_Start hTable      
91992>>>            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
91995>>>            If (bIsSQLTableTo = False) Begin
91997>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
92000>>>            End
92000>>>>
92000>>>            Else Begin
92001>>>                Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iDataFlexType
92002>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iDataFlexType
92005>>>                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
92008>>>            End
92008>>>>
92008>>>            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
92011>>>            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
92014>>>            
92014>>>            If (bIsSQL = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
92016>>>                Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
92019>>>            End
92019>>>>
92019>>>        Structure_End hTable
92021>>>
92021>>>        Function_Return (Err = False)
92022>>>    End_Function
92023>>>
92023>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
92025>>>        Boolean bOK
92025>>>
92025>>>        Get AutoConnectionIDLogin to bOK
92026>>>        Move False to Err
92027>>>        Get OpenTableExclusive hTable to bOK
92028>>>        If (bOK = False) Begin
92030>>>            Function_Return False
92031>>>        End
92031>>>>
92031>>>
92031>>>        Structure_Start hTable
92032>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
92035>>>        Structure_End hTable
92037>>>
92037>>>        Function_Return (Err = False)
92038>>>    End_Function
92039>>>
92039>>>    // To move an existing field to another position in a table.
92039>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Returns Boolean
92041>>>        String sColumn sDriverID
92041>>>        Integer iType iLength iPrecision
92041>>>        Boolean bOK
92041>>>
92041>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92044>>>        If (sDriverID = DFBTRDRV_ID) Begin
92046>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
92047>>>>
92047>>>            Function_Return False
92048>>>        End
92048>>>>
92048>>>
92048>>>        Close hTable
92049>>>        Get AutoConnectionIDLogin to bOK
92050>>>        Get OpenTableExclusive hTable to bOK
92051>>>        If (bOK = False) Begin
92053>>>            Function_Return False
92054>>>        End
92054>>>>
92054>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
92057>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
92060>>>
92060>>>        If (iType <> DF_DATE) Begin
92062>>>            Get_Attribute DF_FIELD_LENGTH of hTable iOld to iLength
92065>>>        End
92065>>>>
92065>>>
92065>>>        If (iType = DF_BCD) Begin
92067>>>            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
92070>>>        End
92070>>>>
92070>>>        Move False to Err
92071>>>
92071>>>        Structure_Start hTable
92072>>>            Delete_Field hTable iOld
92073>>>            Create_Field hTable At iNew
92074>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
92077>>>            Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
92080>>>
92080>>>            If (iType <> DF_DATE) Begin
92082>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
92085>>>            End
92085>>>>
92085>>>
92085>>>            If (iType = DF_BCD) Begin
92087>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
92090>>>            End
92090>>>>
92090>>>
92090>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
92093>>>        Structure_End hTable
92095>>>
92095>>>        Function_Return (Err = False)
92096>>>    End_Function
92097>>>
92097>>>    // Deletes a column name for the passed table number (and column number).
92097>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
92099>>>        Integer iColumn
92099>>>        Boolean bOK
92099>>>
92099>>>        Get AutoConnectionIDLogin to bOK 
92100>>>        Move False to Err
92101>>>        Close hTable
92102>>>        Get OpenTableExclusive hTable to bOK
92103>>>        If (bOK = False) Begin
92105>>>            Function_Return False
92106>>>        End
92106>>>>
92106>>>        
92106>>>        If (not(Err)) Begin
92108>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92109>>>            Field_Map hTable sFieldName to iColumn
92111>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92112>>>            If (Err = True) Begin
92114>>>                Function_Return False
92115>>>            End
92115>>>>
92115>>>            Move False to Err
92116>>>    
92116>>>            Structure_Start hTable
92117>>>                Delete_Field hTable iColumn
92118>>>            Structure_End hTable
92120>>>        End  
92120>>>>
92120>>>        Else Begin
92121>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
92122>>>>
92122>>>        End
92122>>>>
92122>>>
92122>>>        Function_Return (Err = False)
92123>>>    End_Function
92124>>>
92124>>>    // Renames a field for the passed table number & old field name & new field name
92124>>>    // Returns True if no errors occured.
92124>>>    // Sample usage:
92124>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
92124>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
92126>>>        Integer iField
92126>>>        Boolean bOK
92126>>>
92126>>>        Get AutoConnectionIDLogin to bOK
92127>>>        Move False to Err
92128>>>        Get OpenTableExclusive hTable to bOK
92129>>>        If (bOK = False) Begin
92131>>>            Function_Return False
92132>>>        End
92132>>>>
92132>>>
92132>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92133>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92134>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
92135>>>        Structure_Start hTable
92136>>>            Field_Map hTable sOldFieldName to iField
92138>>>            If (iField > 0) Begin
92140>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
92143>>>            End
92143>>>>
92143>>>            Else Begin
92144>>>                Move 0 to LastErr
92145>>>                Move False to Err
92146>>>            End
92146>>>>
92146>>>        Structure_End hTable
92148>>>
92148>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
92149>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
92150>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92151>>>
92151>>>        Function_Return (Err = False)
92152>>>    End_Function
92153>>>
92153>>>    // *** Index Level Functions: ***
92153>>>    //
92153>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
92153>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
92153>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
92153>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
92155>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
92155>>>        String sDriverID
92155>>>        Boolean bOK
92155>>>
92155>>>        Get AutoConnectionIDLogin to bOK
92156>>>        Move -1 to iSegment1
92157>>>        Move -1 to iSegment2
92158>>>        Move -1 to iSegment3
92159>>>        Move -1 to iSegment4
92160>>>        Move -1 to iSegment5
92161>>>        Move -1 to iSegment6
92162>>>        Move -1 to iSegment7
92163>>>        Move -1 to iSegment8
92164>>>        Move -1 to iSegment9
92165>>>        Move -1 to iSegment10
92166>>>
92166>>>        If (num_arguments > 3) Begin
92168>>>            Move iSgmnt1 to iSegment1
92169>>>        End
92169>>>>
92169>>>        If (num_arguments > 4) Begin
92171>>>            Move iSgmnt2 to iSegment2
92172>>>        End
92172>>>>
92172>>>        If (num_arguments > 5) Begin
92174>>>            Move iSgmnt3 to iSegment3
92175>>>        End
92175>>>>
92175>>>        If (num_arguments > 6) Begin
92177>>>            Move iSgmnt4 to iSegment4
92178>>>        End
92178>>>>
92178>>>        If (num_arguments > 7) Begin
92180>>>            Move iSgmnt5 to iSegment5
92181>>>        End
92181>>>>
92181>>>        If (num_arguments > 8) Begin
92183>>>            Move iSgmnt6 to iSegment6
92184>>>        End
92184>>>>
92184>>>        If (num_arguments > 9) Begin
92186>>>            Move iSgmnt7 to iSegment7
92187>>>        End
92187>>>>
92187>>>        If (num_arguments > 10) Begin
92189>>>            Move iSgmnt8 to iSegment8
92190>>>        End
92190>>>>
92190>>>        If (num_arguments > 11) Begin
92192>>>            Move iSgmnt9 to iSegment9
92193>>>        End
92193>>>>
92193>>>        If (num_arguments > 12) Begin
92195>>>            Move iSgmnt10 to iSegment10
92196>>>        End
92196>>>>
92196>>>
92196>>>        Move False to Err
92197>>>        Move hTable to iTableNo
92198>>>        Get OpenTableExclusive hTable to bOK
92199>>>        If (bOK = False) Begin
92201>>>            Function_Return False
92202>>>        End
92202>>>>
92202>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92205>>>
92205>>>        // We start by deleting the index
92205>>>        Structure_Start hTable sDriverID
92206>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92207>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
92208>>>            Delete_Index iTableNo iIndex
92209>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92210>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
92211>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
92213>>>
92213>>>        Move False to Err
92214>>>        Move iTableNo to hTable
92215>>>        Get OpenTableExclusive hTable to bOK
92216>>>        If (bOK = False) Begin
92218>>>            Function_Return False
92219>>>        End
92219>>>>
92219>>>
92219>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
92220>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92220>>>        Structure_Start hTable sDriverID
92221>>>            Create_Index hTable At iIndex
92222>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
92225>>>
92225>>>            If (iSgmnt1 <> -1) Begin
92227>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
92230>>>            End
92230>>>>
92230>>>            If (iSegment2 <> -1) Begin
92232>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
92235>>>            End
92235>>>>
92235>>>            If (iSegment3 <> -1) Begin
92237>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
92240>>>            End
92240>>>>
92240>>>            If (iSegment4 <> -1) Begin
92242>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
92245>>>            End
92245>>>>
92245>>>            If (iSegment5 <> -1) Begin
92247>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
92250>>>            End
92250>>>>
92250>>>            If (iSegment6 <> -1) Begin
92252>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
92255>>>            End
92255>>>>
92255>>>            If (iSegment7 <> -1) Begin
92257>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
92260>>>            End
92260>>>>
92260>>>            If (iSegment8 <> -1) Begin
92262>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
92265>>>            End
92265>>>>
92265>>>            If (iSegment9 <> -1) Begin
92267>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
92270>>>            End
92270>>>>
92270>>>            If (iSegment10 <> -1) Begin
92272>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
92275>>>            End
92275>>>>
92275>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
92277>>>
92277>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
92278>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
92278>>>
92278>>>        Function_Return (Err = False)
92279>>>    End_Function
92280>>>
92280>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex Integer iIndex tAPIIndexSegment[] aIndexSegments Returns Boolean 
92282>>>        String[] aFields
92283>>>        Integer iCount iSize iMax iTableNo iField iSegments
92283>>>        String sDriverID
92283>>>        Boolean bOK 
92283>>>
92283>>>        Move (SizeOfArray(aIndexSegments)) to iSize
92284>>>        If (iSize = 0) Begin
92286>>>            Function_Return False                                                            
92287>>>        End
92287>>>>
92287>>>        Decrement iSize
92288>>>        
92288>>>        Move hTable to iTableNo
92289>>>        Get AutoConnectionIDLogin to bOK
92290>>>        Move False to Err
92291>>>        Get OpenTableExclusive hTable to bOK
92292>>>        If (bOK = False) Begin
92294>>>            Function_Return False
92295>>>        End
92295>>>>
92295>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92298>>>        
92298>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER 
92299>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
92300>>>        Send Ignore_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
92301>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92302>>>        // We will only attempt to delete the index in case it exists.
92302>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
92305>>>        If (iSegments > 0) Begin
92307>>>            // We start by deleting the index
92307>>>            Structure_Start hTable sDriverID 
92308>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92309>>>                Delete_Index iTableNo iIndex
92310>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92311>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE
92313>>>        End
92313>>>>
92313>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER 
92314>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
92315>>>        Send Trap_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
92316>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92317>>>        
92317>>>        Move False to Err
92318>>>        Move 0 to LastErr
92319>>>        Move iTableNo to hTable
92320>>>        Get OpenTableExclusive hTable to bOK
92321>>>        If (bOK = False) Begin
92323>>>            Function_Return False
92324>>>        End
92324>>>>
92324>>>    
92324>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
92325>>>        Structure_Start hTable sDriverID
92326>>>            Create_Index hTable At iIndex
92327>>>            Set_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndex.sSQLIndexName
92330>>>            Set_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
92333>>>            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndex.bIsPrimaryKey
92336>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iSize + 1)
92339>>>            for iCount from 0 to iSize
92345>>>>
92345>>>                Move aIndexSegments[iCount].iFieldNumber to iField
92346>>>                If (iField <> -1) Begin 
92348>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iCount + 1) to iField
92351>>>                End
92351>>>>
92351>>>            Loop
92352>>>>
92352>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
92354>>>
92354>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
92355>>>        Function_Return (Err = False)
92356>>>    End_Function
92357>>>    
92357>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
92359>>>        Boolean bOK
92359>>>
92359>>>        Get AutoConnectionIDLogin to bOK
92360>>>        Move False to Err
92361>>>        Get OpenTableExclusive hTable to bOK
92362>>>        If (bOK = False) Begin
92364>>>            Function_Return False
92365>>>        End
92365>>>>
92365>>>        Structure_Start hTable
92366>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
92369>>>        Structure_End hTable
92371>>>
92371>>>        Function_Return (Err = False)
92372>>>    End_Function
92373>>>
92373>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
92375>>>        Integer iCase
92375>>>        Boolean bOK
92375>>>
92375>>>        If (bUppercase = True) Begin
92377>>>            Move DF_CASE_IGNORED to iCase
92378>>>        End
92378>>>>
92378>>>        Else Begin
92379>>>            Move DF_CASE_USED to iCase
92380>>>        End
92380>>>>
92380>>>
92380>>>        Get AutoConnectionIDLogin to bOK
92381>>>        Move False to Err
92382>>>        Get OpenTableExclusive hTable to bOK
92383>>>        If (bOK = False) Begin
92385>>>            Function_Return False
92386>>>        End
92386>>>>
92386>>>        Structure_Start hTable
92387>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
92390>>>        Structure_End hTable
92392>>>
92392>>>        Function_Return (Err = False)
92393>>>    End_Function
92394>>>
92394>>>    // To delete an index
92394>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
92396>>>        Integer iTableNo iNumSegments
92396>>>        String sDriverID
92396>>>        Boolean bOK
92396>>>
92396>>>        Get AutoConnectionIDLogin to bOK
92397>>>        Move False to Err
92398>>>        Move hTable to iTableNo
92399>>>        Get OpenTableExclusive hTable to bOK
92400>>>        If (bOK = False) Begin
92402>>>            Function_Return False
92403>>>        End
92403>>>>
92403>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92406>>>
92406>>>        // Check to see if the index exists or not...
92406>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92409>>>        If (iNumSegments = 0) Begin
92411>>>            Function_Return False
92412>>>        End
92412>>>>
92412>>>
92412>>>        Structure_Start hTable sDriverID
92413>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
92414>>>            Delete_Index iTableNo iIndex
92415>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
92416>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
92418>>>
92418>>>        Function_Return (Err = False)
92419>>>    End_Function
92420>>>
92420>>>    // Delete an Index Segment
92420>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
92422>>>        Boolean bOK bSQLDriver bIndexTemporary
92422>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
92422>>>        Integer iIndexType
92422>>>        String sDriverID 
92422>>>
92422>>>        Get AutoConnectionIDLogin to bOK
92423>>>        Move False to Err
92424>>>    
92424>>>        Get OpenTableExclusive hTable to bOK
92425>>>        If (bOK = False) Begin
92427>>>            Function_Return False
92428>>>        End
92428>>>>
92428>>>        
92428>>>        // Check to see if the index exists or not...
92428>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92431>>>        If (iNumSegments = 0) Begin
92433>>>            Function_Return False
92434>>>        End
92434>>>>
92434>>>        
92434>>>        Move False to bIndexTemporary
92435>>>        Get psDriverID to sDriverID
92436>>>        Get IsSQLDriver sDriverID to bSQLDriver
92437>>>        If (bSQLDriver) Begin
92439>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
92442>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
92445>>>                Move True to bIndexTemporary
92446>>>        End
92446>>>>
92446>>>    
92446>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
92446>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
92448>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92451>>>            If (iSegment = iNumSegments) Begin
92453>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
92456>>>            End
92456>>>>
92456>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
92459>>>                For iCurSegment from iSegment to (iNumSegments - 1)
92465>>>>
92465>>>                    //*** Move index segment attributes
92465>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
92468>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
92471>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
92474>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
92477>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
92480>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
92483>>>                Loop
92484>>>>
92484>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
92487>>>            End
92487>>>>
92487>>>        End
92487>>>>
92487>>>
92487>>>        Else Begin
92488>>>           Structure_Start hTable
92489>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92492>>>               If (iSegment = iNumSegments) Begin
92494>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
92497>>>               End
92497>>>>
92497>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
92500>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
92506>>>>
92506>>>                       //*** Move index segment attributes
92506>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
92509>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
92512>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
92515>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
92518>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
92521>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
92524>>>                   Loop
92525>>>>
92525>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
92528>>>               End
92528>>>>
92528>>>           Structure_End hTable
92530>>>        End
92530>>>>
92530>>>        
92530>>>        Function_Return (Err = False)
92531>>>    End_Function
92532>>>    
92532>>>    // Add/Insert an Index Segment
92532>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
92534>>>        Boolean bOK bSQLDriver bIndexTemporary
92534>>>        Integer iSQLType iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
92534>>>        Integer iIndexType
92534>>>        String sDriverId
92534>>>        
92534>>>        Get AutoConnectionIDLogin to bOK
92535>>>        Move False to Err
92536>>>    
92536>>>        Get OpenTableExclusive hTable to bOK
92537>>>        If (bOK = False) Begin
92539>>>            Function_Return False
92540>>>        End
92540>>>>
92540>>>        
92540>>>        Move False to bIndexTemporary
92541>>>        // Check to see if the index exists or not...
92541>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92544>>>        If (iNumSegments = 0) Begin
92546>>>            Function_Return False
92547>>>        End
92547>>>>
92547>>>    
92547>>>        Get psDriverID to sDriverID
92548>>>        Get IsSQLDriver sDriverID to bSQLDriver
92549>>>        If (bSQLDriver) Begin
92551>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
92554>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
92557>>>                Move True to bIndexTemporary
92558>>>        End
92558>>>>
92558>>>
92558>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
92558>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
92560>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92563>>>    
92563>>>           If (iSegment > iNumSegments) Begin
92565>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
92568>>>               Move (iNumSegments + 1) to iCurSegment
92569>>>           End
92569>>>>
92569>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
92572>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
92575>>>               Move iNumSegments to iCurSegment
92576>>>           
92576>>>               While (iCurSegment > iSegment)
92580>>>                   //*** Move index segment attributes
92580>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
92583>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
92586>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
92589>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
92592>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
92595>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
92598>>>                   Decrement iCurSegment
92599>>>               End
92600>>>>
92600>>>           
92600>>>               //*** Now set new segment attributes
92600>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
92603>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
92606>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
92609>>>           End
92609>>>>
92609>>>        End
92609>>>>
92609>>>        
92609>>>        Else Begin
92610>>>           Structure_Start hTable
92611>>>              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92614>>>           
92614>>>              If (iSegment > iNumSegments) Begin
92616>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
92619>>>                  Move (iNumSegments + 1) to iCurSegment
92620>>>              End
92620>>>>
92620>>>              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
92623>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
92626>>>                  Move iNumSegments to iCurSegment
92627>>>              
92627>>>                  While (iCurSegment > iSegment)
92631>>>                      //*** Move index segment attributes
92631>>>                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
92634>>>                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
92637>>>                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
92640>>>                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
92643>>>                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
92646>>>                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
92649>>>                      Decrement iCurSegment
92650>>>                  End
92651>>>>
92651>>>              
92651>>>                  //*** Now set new segment attributes
92651>>>                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
92654>>>                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
92657>>>                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
92660>>>              End
92660>>>>
92660>>>           Structure_End hTable
92662>>>        End
92662>>>>
92662>>>        
92662>>>        Function_Return (Err = False)
92663>>>    End_Function
92664>>>    
92664>>>    // Returns an SQL Driver ID if it appears as a prefix for the passed sRootName
92664>>>    // If no driver found the DATAFLEX_ID is returned
92664>>>//    Function UtilDriverIDFromRootName String sRootName Returns String
92664>>>//        String sDriverID
92664>>>//        Integer iPos
92664>>>//        Move (Pos(":", sRootName)) to iPos
92664>>>//        If (iPos <> 0) Begin
92664>>>//            Move (Left(sRootName, (iPos -1))) to sDriverID
92664>>>//        End
92664>>>//        Else Begin
92664>>>//            Move DATAFLEX_ID to sDriverID
92664>>>//        End
92664>>>//        Function_Return sDriverID
92664>>>//    End_Function              
92664>>>    
92664>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
92664>>>    // Note that it first removes any driver prefixes in the rootname.
92664>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfoFrom tAPITableNameInfo APITableInfoTo Returns Boolean
92666>>>        Boolean bTheSame 
92666>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
92666>>>        
92666>>>        Get _TableNameOnly APITableInfoFrom.sRootName to sRootNameFrom
92667>>>        Get _TableNameOnly APITableInfoTo.sRootName   to sRootNameTo                                    
92668>>>        Move APITableInfoFrom.sLogicalName            to sLogicalNameFrom
92669>>>        Move APITableInfoTo.sLogicalName              to sLogicalNameTo
92670>>>        Move APITableInfoFrom.sDisplayName            to sDisplayNameFrom
92671>>>        Move APITableInfoTo.sDisplayName              to sDisplayNameTo
92672>>>        If (bCompareFilelistUppercase = True) Begin
92674>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bTheSame
92675>>>        End
92675>>>>
92675>>>        Else Begin
92676>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bTheSame                  
92677>>>        End
92677>>>>
92677>>>            
92677>>>        Function_Return bTheSame
92678>>>    End_Function                
92679>>>    
92679>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
92681>>>        Handle hTableFrom hTableTo 
92681>>>        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
92681>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase 
92681>>>        String sRootName sDriverID
92681>>>
92681>>>        Move False to bFilelistError
92682>>>        Move True to bIsSame
92683>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
92684>>>        Get pbCompareIndexAscending to bCompareIndexAscending
92685>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
92686>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
92687>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo          
92688>>>        
92688>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
92689>>>        Get _TableNameOnly sRootName             to sRootName
92690>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
92691>>>
92691>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
92691>>>        // bCodeGenerateMode = True = Code Generation mode.
92691>>>        If (bCodeGenerateMode = True) Begin
92693>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
92693>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
92695>>>                Function_Return False
92696>>>            End
92696>>>>
92696>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
92697>>>            If (bIsSame = False) Begin   
92699>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
92700>>>                Move True to bFilelistError
92701>>>                Function_Return False
92702>>>            End
92702>>>>
92702>>>        End
92702>>>>
92702>>>        
92702>>>        If (bCodeGenerateMode = False) Begin
92704>>>            // Then we want to create this table
92704>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
92706>>>                Function_Return False
92707>>>            End
92707>>>>
92707>>>                
92707>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
92708>>>            If (bIsSame = False) Begin
92710>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
92711>>>>
92711>>>                Move True to bFilelistError
92712>>>                Function_Return False
92713>>>            End
92713>>>>
92713>>>        End
92713>>>>
92713>>>
92713>>>        // Check columns:                        
92713>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
92714>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
92715>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom 
92716>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
92717>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverID
92718>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns  
92719>>>        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bIsSame
92720>>>        If (bIsSame = False) Begin
92722>>>            Function_Return False
92723>>>        End
92723>>>>
92723>>>        
92723>>>        // ...then check indexes:
92723>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
92724>>>        Get UtilIndexesCompare    hTableFrom APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
92725>>>        If (bIsSame = False) Begin
92727>>>            Function_Return False
92728>>>        End
92728>>>>
92728>>>        
92728>>>        // ...and finally relationships:
92728>>>        Get UtilRelationStructFill hTableFrom to APITableTo.aApiRelations
92729>>>        Get UtilRelationsCompare      hTableFrom APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
92730>>>        
92730>>>        Function_Return (bIsSame = True)
92731>>>    End_Function
92732>>>    
92732>>>    // Similar to UtilTableCompare, but takes two tAPITable struct arrays as parameters and a apitableboolean struct as params.
92732>>>    Function UtilTableCompare_Ex tAPITable CompareTableFrom tAPITable CompareTableTo tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
92734>>>        Handle hTableFrom hTableTo 
92734>>>        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
92734>>>        tAPITableNameInfo APITableInfoFrom APITableInfoTo
92734>>>        tAPITableNameInfo APITableInfoFrom APITableInfoTo
92734>>>        tAPIIndex[]    aIndexesFrom   aIndexesTo
92734>>>        tAPIIndex[]    aIndexesFrom   aIndexesTo
92736>>>        tAPIColumn[]   aColumnsFrom   aColumnsTo
92736>>>        tAPIColumn[]   aColumnsFrom   aColumnsTo
92738>>>        tAPIRelation[] aRelationsFrom aRelationsTo        
92738>>>        tAPIRelation[] aRelationsFrom aRelationsTo        
92740>>>        String sRootName sDriverID
92740>>>        
92740>>>        If (CompareTableFrom.ApiTableInfo.iTableNumber < 0 or CompareTableTo.ApiTableInfo.iTableNumber < 0) Begin
92742>>>            Move True to bFilelistError
92743>>>            Function_Return False    
92744>>>        End 
92744>>>>
92744>>>        
92744>>>        Move True  to bIsSame 
92745>>>        Move False to bFilelistError
92746>>>        
92746>>>        Move CompareTableFrom.ApiTableInfo  to APITableInfoFrom
92747>>>        Move CompareTableFrom.aApiColumns   to aColumnsFrom
92748>>>        Move CompareTableFrom.aApiIndexes   to aIndexesFrom
92749>>>        Move CompareTableFrom.aApiRelations to aRelationsFrom  
92750>>>        Move APITableInfoFrom.iTableNumber  to hTableFrom 
92751>>>        Move APITableInfoFrom.bIsSQL        to bIsSQLFrom         
92752>>>        Move APITableInfoFrom.sDriverID     to sDriverID
92753>>>        
92753>>>        Move CompareTableTo.ApiTableInfo    to APITableInfoTo
92754>>>        Move CompareTableTo.aApiColumns     to aColumnsTo
92755>>>        Move CompareTableTo.aApiIndexes     to aIndexesTo
92756>>>        Move CompareTableTo.aApiRelations   to aRelationsTo
92757>>>        Move APITableInfoTo.iTableNumber    to hTableTo          
92758>>>        Move APITableInfoTo.bIsSQL          to bIsSQLTo
92759>>>        
92759>>>        Move APITableInfoTo.sRootName       to sRootName
92760>>>        Get _TableNameOnly sRootName        to sRootName
92761>>>
92761>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
92761>>>        // bCodeGenerateMode = True = Code Generation mode.
92761>>>        If (bCodeGenerateMode = True) Begin
92763>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
92763>>>            If (Trim(APITableInfoTo.sLogicalName) = "") Begin
92765>>>                Function_Return False
92766>>>            End                                                                    
92766>>>>
92766>>>            Move (Uppercase(APITableInfoFrom.sLogicalName) = Uppercase(APITableInfoTo.sLogicalName)) to bIsSame
92767>>>            If (bIsSame = False) Begin
92769>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableInfoFrom.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableInfoTo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
92770>>>                Move True to bFilelistError
92771>>>                Function_Return False
92772>>>            End
92772>>>>
92772>>>        End
92772>>>>
92772>>>        
92772>>>        If (bCodeGenerateMode = False) Begin
92774>>>            If (Trim(Uppercase(APITableInfoTo.sLogicalName)) = "") Begin
92776>>>                // Then we might want to create this table
92776>>>                Function_Return False
92777>>>            End
92777>>>>
92777>>>            
92777>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableInfoFrom APITableInfoTo to bIsSame
92778>>>            If (bIsSame = False) Begin
92780>>>                Function_Return False
92781>>>            End
92781>>>>
92781>>>        End
92781>>>>
92781>>>
92781>>>        // Check columns:         
92781>>>        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom aColumnsTo CompareTableBooleans.bCompareDate_DateTime to bIsSame
92782>>>        If (bIsSame = False) Begin
92784>>>            Function_Return False
92785>>>        End
92785>>>>
92785>>>        
92785>>>        // ...then check indexes:
92785>>>        Get UtilIndexesCompare hTableFrom aIndexesFrom aIndexesTo CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
92786>>>        If (bIsSame = False) Begin
92788>>>            Function_Return False
92789>>>        End
92789>>>>
92789>>>        
92789>>>        // ...and finally relationships:
92789>>>        Get UtilRelationsCompare hTableFrom aRelationsFrom aRelationsTo to bIsSame
92790>>>        
92790>>>        Function_Return (bIsSame = True)
92791>>>    End_Function
92792>>>    
92792>>>    // Compare multiple columns. (For 'From' & 'To' tables)
92792>>>    Function UtilColumnsCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
92794>>>        Boolean bIsSame        
92794>>>        Integer iCount iSize iSizeFrom iSizeTo iColumn iType iLength
92794>>>        String sColumnNameFrom sColumnNameTo
92794>>>        
92794>>>        Move True to bIsSame
92795>>>        Move (SizeOfArray(aColumnsFrom)) to iSizeFrom
92796>>>        Move (SizeOfArray(aColumnsTo))   to iSizeTo
92797>>>        If (iSizeFrom <> iSizeTo) Begin
92799>>>            Function_Return False
92800>>>        End          
92800>>>>
92800>>>        Move (iSizeFrom max iSizeTo)     to iSize 
92801>>>        Set piMaximum of ghoProgressBar  to iSize
92802>>>        
92802>>>        Decrement iSize
92803>>>        for iCount from 0 to iSize       
92809>>>>
92809>>>            Set piPosition of ghoProgressBar to iCount
92810>>>            If (iCount <= iSizeFrom and iCount <= iSizeTo) Begin
92812>>>                Get UtilColumnCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DataTime to bIsSame
92813>>>            End 
92813>>>>
92813>>>            Else Begin
92814>>>                Move False to bIsSame
92815>>>            End
92815>>>>
92815>>>            
92815>>>            If (bIsSame = False) Begin
92817>>>                Function_Return False
92818>>>            End
92818>>>>
92818>>>        Loop
92819>>>>
92819>>>        
92819>>>        Function_Return (bIsSame = True)
92820>>>    End_Function
92821>>>    
92821>>>    // Compares a single column (For 'From' & 'To' tables)
92821>>>    Function UtilColumnCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn aColumnsFrom tAPIColumn aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
92823>>>        Boolean bIsSame 
92823>>>        Integer iFromType iToType iDbType                    
92823>>>        tColumnType ColumnType
92823>>>        tColumnType ColumnType
92823>>>        
92823>>>        Get piDbType to iDbType
92824>>>        Move (aColumnsFrom.iFieldNumber <> 0 and aColumnsTo.iFieldNumber <> 0) to bIsSame
92825>>>        // Check that _both_ field_number and field_name are the same
92825>>>        // else they needs to be changed...                                  
92825>>>        If (bIsSame = False) Begin
92827>>>            Move (aColumnsFrom.iFieldNumber = aColumnsTo.iFieldNumber) to bIsSame
92828>>>        End
92828>>>>
92828>>>        If (bIsSame = False) Begin
92830>>>            Function_Return False
92831>>>        End
92831>>>>
92831>>>        Move (aColumnsFrom.sFieldName = aColumnsTo.sFieldName) to bIsSame
92832>>>        If (bIsSame = False) Begin
92834>>>            Function_Return False
92835>>>        End
92835>>>>
92835>>>        
92835>>>        Move aColumnsFrom.iType to iFromType
92836>>>        Move aColumnsTo.iType   to iToType
92837>>>        
92837>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
92837>>>        // data types between Embedded and SQL.
92837>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
92839>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iFromType aColumnsFrom.iLength to iFromType
92840>>>        End
92840>>>>
92840>>>        Else If (bIsSQLFrom = False and bIsSQLTo = True) Begin
92843>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iToType   aColumnsFrom.iLength to iToType
92844>>>        End
92844>>>>
92844>>>        
92844>>>        // *** THIS NEEDS TO BE REDONE ***
92844>>>        
92844>>>        // Make Date and DateTime comparison?
92844>>>        If (bCompareDate_DataTime = True and iFromType = DF_DATE or iFromType = DF_DATETIME or iFromType = SQL_TYPE_TIMESTAMP or iFromType = SQL_TYPE_TIMESTAMP2) Begin
92846>>>            Move (iFromType = iToType) to bIsSame
92847>>>            If (bIsSame = False) Begin
92849>>>                Function_Return False
92850>>>            End
92850>>>>
92850>>>        End
92850>>>>
92850>>>        
92850>>>        // This is when checking for other field types than dates...
92850>>>//        If (bCompareDate_DataTime = False and iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
92850>>>            Move (iFromType = iToType) to bIsSame
92851>>>            If (bIsSame = False) Begin
92853>>>                Function_Return False
92854>>>            End
92854>>>>
92854>>>//        End
92854>>>        
92854>>>        // If the field is of Date type (any of them) we don't compare length & precision.
92854>>>        If (iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
92856>>>            Move (aColumnsFrom.iLength = aColumnsTo.iLength) to bIsSame
92857>>>            If (bIsSame = False) Begin
92859>>>                Function_Return False
92860>>>            End                                               
92860>>>>
92860>>>            Move (aColumnsFrom.iPrecision = aColumnsTo.iPrecision) to bIsSame
92861>>>            If (bIsSame = False) Begin
92863>>>                Function_Return False
92864>>>            End                                               
92864>>>>
92864>>>        End
92864>>>>
92864>>>        
92864>>>        Move (aColumnsFrom.iOptions = aColumnsTo.iOptions) to bIsSame
92865>>>        If (bIsSame = False) Begin
92867>>>            Function_Return False
92868>>>        End                                               
92868>>>>
92868>>>
92868>>>        Function_Return True
92869>>>    End_Function
92870>>>    
92870>>>    // Compares multiple indexes for a 'From' and a 'To' table.
92870>>>    Function UtilIndexesCompare Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
92872>>>        Boolean bIsSame bDAWSQLDriver 
92872>>>        Integer iCount iSize iSizeFrom iSizeTo iSegment iNumSegments iColumn
92872>>>        String sIndexNameFrom sIndexNameTo sDriverID sColumnNameFrom
92872>>>        
92872>>>        Move True to bIsSame
92873>>>        Get psDriverID to sDriverID
92874>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
92875>>>        
92875>>>        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
92876>>>        Move (SizeOfArray(aIndexesTo))   to iSizeTo  
92877>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
92879>>>            Function_Return True
92880>>>        End
92880>>>>
92880>>>        If (iSizeFrom <> iSizeTo) Begin
92882>>>            Function_Return False
92883>>>        End          
92883>>>>
92883>>>        Move (iSizeFrom max iSizeTo) to iSize
92884>>>
92884>>>        Decrement iSize
92885>>>        For iCount from 0 to iSize 
92891>>>>
92891>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92892>>>            Get UtilIndexCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
92893>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92894>>>            If (bIsSame = False) Begin
92896>>>                Function_Return False
92897>>>            End
92897>>>>
92897>>>        Loop
92898>>>>
92898>>>        
92898>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92899>>>        Function_Return bIsSame
92900>>>    End_Function
92901>>>    
92901>>>    // Compares a single index for a 'From' and a 'To' table.
92901>>>    Function UtilIndexCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
92903>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
92903>>>        String sDriverID  
92903>>>        Integer iSegment
92903>>>        
92903>>>        Move True to bIsSame
92904>>>        Get psDriverID to sDriverID
92905>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
92906>>>        Get IsSQLDriver sDriverID to bIsSqlTable
92907>>>        If (bIsSqlTable = True) Begin
92909>>>            Get UtilTableIsSQL hTable to bIsSqlTable
92910>>>        End
92910>>>>
92910>>>        
92910>>>        Move True to bIsSame
92911>>>        If (bIsSqlTable = True) Begin
92913>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
92914>>>            If (bIsSame = False) Begin
92916>>>                Function_Return False
92917>>>            End
92917>>>>
92917>>>            Move (aIndexFrom.bIsPrimaryKey = aIndexTo.bIsPrimaryKey) to bIsSame
92918>>>            If (bIsSame = False) Begin
92920>>>                Function_Return False
92921>>>            End
92921>>>>
92921>>>            Move (aIndexFrom.sSQLIndexName = aIndexTo.sSQLIndexName) to bIsSame
92922>>>            If (bIsSame = False) Begin
92924>>>                Function_Return False
92925>>>            End
92925>>>>
92925>>>        End
92925>>>>
92925>>>        
92925>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92926>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
92927>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92928>>>        If (bIsSame = False) Begin
92930>>>            Function_Return False
92931>>>        End                      
92931>>>>
92931>>>        
92931>>>        Get UtilIndexSegmentsCompare aIndexFrom aIndexTo bCompareIndexUppercase bCompareIndexAscending to iSegment
92932>>>        If (iSegment = -1) Begin
92934>>>            Move True to bIsSame
92935>>>        End  
92935>>>>
92935>>>        Else Begin                                                         
92936>>>            Move True to aIndexTo.bShouldChange
92937>>>            Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
92938>>>        End
92938>>>>
92938>>>        
92938>>>        Function_Return (bIsSame = True)
92939>>>    End_Function
92940>>>    
92940>>>    // Compares each segment for the passed index.
92940>>>    // Returns -1 if same; else returns the index segment that differs.
92940>>>    Function UtilIndexSegmentsCompare tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
92942>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment                                                
92942>>>        Boolean bIsSame
92942>>>        
92942>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92943>>>        Move (SizeOfArray(aIndexFrom.IndexSegmentArray)) to iNumSegmentsFrom
92944>>>        Move (SizeOfArray(aIndexTo.IndexSegmentArray))   to iNumSegmentsTo
92945>>>        Move (iNumSegmentsFrom max iNumSegmentsTo)       to iNumSegments
92946>>>        
92946>>>        Decrement iNumSegments
92947>>>        for iSegment from 0 to iNumSegments  
92953>>>>
92953>>>            Move False to bIsSame
92954>>>            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
92956>>>                Get UtilIndexSegmentCompare aIndexFrom.IndexSegmentArray[iSegment] aIndexTo.IndexSegmentArray[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
92957>>>            End
92957>>>>
92957>>>            If (bIsSame = False) Begin
92959>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92960>>>                Move True to aIndexTo.bShouldChange
92961>>>                Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
92962>>>                Function_Return iSegment
92963>>>            End
92963>>>>
92963>>>        Loop             
92964>>>>
92964>>>        
92964>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92965>>>        Function_Return -1 // This means bIsSame = True
92966>>>    End_Function
92967>>>    
92967>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
92969>>>        Integer iNumSegments iSegment                                                
92969>>>        Boolean bIsSame
92969>>>
92969>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
92970>>>        If (bIsSame = False) Begin
92972>>>            Function_Return False
92973>>>        End
92973>>>>
92973>>>        If (bCompareIndexUppercase = True) Begin
92975>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
92976>>>            If (bIsSame = False) Begin
92978>>>                Function_Return False
92979>>>            End
92979>>>>
92979>>>        End
92979>>>>
92979>>>        If (bCompareIndexAscending = True) Begin
92981>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
92982>>>            If (bIsSame = False) Begin
92984>>>                Function_Return False
92985>>>            End
92985>>>>
92985>>>        End
92985>>>>
92985>>>        
92985>>>        Function_Return True
92986>>>    End_Function
92987>>>    
92987>>>    // This is the same as the UtilIndexCompare function _except_ it only checks if the Index type and number are equal or not.
92987>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
92989>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
92989>>>        Integer iCount iSize iSegment iNumSegments iIndexSegment
92989>>>        String sDriverID 
92989>>>        
92989>>>        Move True to bIsSame
92990>>>        Get psDriverID to sDriverID
92991>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
92992>>>        Get IsSQLDriver sDriverID to bIsSqlTable
92993>>>        If (bIsSqlTable = True) Begin
92995>>>            Get UtilTableIsSQL hTable to bIsSqlTable
92996>>>        End
92996>>>>
92996>>>        
92996>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92997>>>        Move True to bIsSame
92998>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
93000>>>            // Don't think we should do this. Or should we?
93000>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
93000>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
93001>>>            If (bIsSame = False) Begin
93003>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
93004>>>                Function_Return False
93005>>>            End
93005>>>>
93005>>>        End
93005>>>>
93005>>>        
93005>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
93006>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93007>>>        If (bIsSame = False) Begin
93009>>>            Function_Return False
93010>>>        End                      
93010>>>>
93010>>>        
93010>>>        Function_Return bIsSame
93011>>>    End_Function
93012>>>    
93012>>>    // Compares multiple relationships for a 'From' and a 'To' table
93012>>>    Function UtilRelationsCompare Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
93014>>>        Boolean bIsSame
93014>>>        Integer iSize iCount
93014>>>        
93014>>>        Move True to bIsSame
93015>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
93016>>>        Decrement iSize
93017>>>        For iCount from 0 to iSize   
93023>>>>
93023>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93024>>>            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
93025>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93026>>>            If (bIsSame = False) Begin
93028>>>                Function_Return False
93029>>>            End
93029>>>>
93029>>>        Loop
93030>>>>
93030>>>        
93030>>>        Function_Return bIsSame
93031>>>    End_Function
93032>>>
93032>>>    // Compares a single relationship for a 'From' and a 'To' table
93032>>>    Function UtilRelationCompare Handle hTable tAPIRelation aRelationsFrom tAPIRelation aRelationsTo Returns Boolean
93034>>>        Boolean bIsSame
93034>>>        Integer iSize iCount
93034>>>        
93034>>>        Move True to bIsSame
93035>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93036>>>        Move (aRelationsFrom.hTableFrom = aRelationsTo.hTableFrom) to bIsSame
93037>>>        If (bIsSame = False) Begin
93039>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93040>>>            Function_Return False
93041>>>        End
93041>>>>
93041>>>        Move (aRelationsFrom.hTableTo = aRelationsTo.hTableTo) to bIsSame
93042>>>        If (bIsSame = False) Begin
93044>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93045>>>            Function_Return False
93046>>>        End
93046>>>>
93046>>>        Move (aRelationsFrom.iColumnFrom = aRelationsTo.iColumnFrom) to bIsSame
93047>>>        If (bIsSame = False) Begin
93049>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93050>>>            Function_Return False
93051>>>        End
93051>>>>
93051>>>        
93051>>>        Move (aRelationsFrom.iColumnTo = aRelationsTo.iColumnTo) to bIsSame
93052>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93053>>>
93053>>>        Function_Return bIsSame
93054>>>    End_Function
93055>>>
93055>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
93055>>>    // already exists. Instead it checks if the table needs to be updated with any of the struct arrays,
93055>>>    // for fields, indexes or relations.
93055>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
93057>>>        Boolean bIsSame bOK
93057>>>        Integer iSize iCount 
93057>>>        
93057>>>        Move True to bOK
93058>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
93059>>>        Decrement iSize
93060>>>        for iCount from 0 to iSize
93066>>>>
93066>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93067>>>            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
93068>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93069>>>            If (bIsSame = False) Begin
93071>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93072>>>                Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo to bOK
93073>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
93074>>>            End
93074>>>>
93074>>>        Loop
93075>>>>
93075>>>        
93075>>>        Function_Return bOK
93076>>>    End_Function
93077>>>    
93077>>>    Function UtilIndexesUpdate Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
93079>>>        Boolean bIsSame bOK
93079>>>        Integer iSizeFrom iSizeTo iCount iIndexSegment                   
93079>>>        String sIndexFields
93079>>>        
93079>>>        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
93080>>>        Move (SizeOfArray(aIndexesTo))   to iSizeTo 
93081>>>        Decrement iSizeTo
93082>>>        Decrement iSizeFrom
93083>>>        for iCount from 0 to iSizeFrom
93089>>>>
93089>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93090>>>            Get UtilIndexTypeNumberCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] to bIsSame
93091>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93092>>>            If (bIsSame = False and iSizeTo <> 0 and iCount <= iSizeTo) Begin
93094>>>                Get APIIndexCreateByFieldNames hTable iCount aIndexesFrom[iCount] aIndexesFrom[iCount].IndexSegmentArray to bOK
93095>>>            End
93095>>>>
93095>>>            If (bIsSame = True) Begin
93097>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT 
93098>>>                Move 0 to iIndexSegment
93099>>>                Get UtilIndexSegmentsCompare aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to iIndexSegment
93100>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
93101>>>                If (iIndexSegment <> -1) Begin
93103>>>                    Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount].iIndexNumber aIndexesFrom[iCount].IndexSegmentArray to bOK
93104>>>                End
93104>>>>
93104>>>            End
93104>>>>
93104>>>        Loop
93105>>>>
93105>>>    
93105>>>        Function_Return bOK
93106>>>    End_Function  
93107>>>    
93107>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
93107>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
93107>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
93107>>>//        String sFieldName sDriverID
93107>>>//        
93107>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93107>>>//        If (bIsOpen = False) Begin
93107>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93107>>>//            Open hTable
93107>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93107>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93107>>>//            If (bIsOpen = False) Begin
93107>>>//                Function_Return False
93107>>>//            End
93107>>>//        End
93107>>>//
93107>>>//        Move True to bEqual
93107>>>//        Get psDriverID to sDriverID
93107>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
93107>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
93107>>>//        Move (SizeOfArray(aColumns)) to iSize
93107>>>//        Decrement iSize   
93107>>>//        
93107>>>//        For iCount from 0 to iSize
93107>>>//            Move 0 to iOptions    
93107>>>//            Move False to bIdentityKey
93107>>>//            Move aColumns[iCount].sFieldName to sFieldName               
93107>>>//            
93107>>>//            // We need to use the column name - not the column integer as
93107>>>//            // the order does not need to be the same, and the logic should still work.
93107>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
93107>>>//            If (iColumn > 0) Begin
93107>>>//                If (bDawSqlDriver = True) Begin
93107>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
93107>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
93107>>>//                    If (iType <> aColumns[iCount].iType) Begin
93107>>>//                        Move False to bEqual
93107>>>//                    End
93107>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
93107>>>//                    If (bIdentityKey = True) Begin
93107>>>//                        Move C_tAPIColumn_Identity to iOptions
93107>>>//                    End
93107>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
93107>>>//                        Move False to bEqual
93107>>>//                    End
93107>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
93107>>>//                End
93107>>>//                Else Begin
93107>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
93107>>>//                    If (iType <> aColumns[iCount].iType) Begin
93107>>>//                        Move False to bEqual
93107>>>//                    End
93107>>>//                End
93107>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
93107>>>//                If (iLength <> aColumns[iCount].iLength) Begin
93107>>>//                    Move False to bEqual
93107>>>//                End
93107>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
93107>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
93107>>>//                    Move False to bEqual
93107>>>//                End
93107>>>//                If (bEqual = False) Begin
93107>>>//                    Function_Return False
93107>>>//                End
93107>>>//            End
93107>>>//                    
93107>>>//            Else Begin
93107>>>//                Function_Return False
93107>>>//            End
93107>>>//        Loop
93107>>>//        
93107>>>//        Function_Return bEqual
93107>>>//    End_Function  
93107>>>    
93107>>>    // To fill a complete Table structure (tAPITable) with data.
93107>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
93107>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
93107>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
93107>>>    Function UtilTableStructFill Boolean bStatusPanel Boolean bFromTables Returns tAPITable[]
93109>>>        tAPIColumn[]    aApiColumns   
93109>>>        tAPIColumn[]    aApiColumns   
93110>>>        tAPIIndex[]     aApiIndexes   
93110>>>        tAPIIndex[]     aApiIndexes   
93111>>>        tAPIRelation[]  aApiRelations 
93111>>>        tAPIRelation[]  aApiRelations 
93112>>>        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
93112>>>        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
93114>>>        Handle hTable
93114>>>        Integer iCount iPos 
93114>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
93114>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID
93114>>>        
93114>>>        Move 0 to hTable    
93115>>>        If (bFromTables = True) Begin
93117>>>            Set Message_Text of ghoStatusPanel to "Reading 'From' Table Structure:"
93118>>>        End 
93118>>>>
93118>>>        Else Begin
93119>>>            Set Message_Text of ghoStatusPanel to "Reading 'To' Table Structure:"
93120>>>        End
93120>>>>
93120>>>        Get UtilFilelistNoOfTables to iCount
93121>>>        Set piMaximum of ghoProgressBarOverall to iCount
93122>>>        Move 0 to iCount                                
93123>>>        
93123>>>        Repeat
93123>>>>
93123>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93126>>>            If (hTable > 0 and hTable <> 50) Begin           
93128>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable    to sRootName   
93131>>>                Get _TableNameOnly sRootName                 to sTableName
93132>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName   
93135>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
93138>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bIsOpen
93139>>>                Get_Attribute DF_FILE_DRIVER       of hTable to sDriverID
93142>>>                Set piPosition of ghoProgressBarOverall to iCount
93143>>>                Set Action_Text of ghoStatusPanel  to (sTableName * "Number:" * String(hTable))
93144>>>                
93144>>>                Get UtilColumnsStructFill  hTable to aApiColumns
93145>>>                Get UtilIndexesStructFill  hTable to aApiIndexes
93146>>>                Get UtilRelationStructFill hTable to aApiRelations
93147>>>                Get UtilTableIsAlias       hTable to bIsAlias  
93148>>>                Get UtilTableIsSQL         hTable to bIsSQL
93149>>>                
93149>>>                Move hTable                                  to aApiTables[iCount].ApiTableInfo.iTableNumber
93150>>>                Move sRootName                               to aApiTables[iCount].ApiTableInfo.sRootName
93151>>>                Move sLogicalName                            to aApiTables[iCount].ApiTableInfo.sLogicalName
93152>>>                Move sDisplayName                            to aApiTables[iCount].ApiTableInfo.sDisplayName
93153>>>                Move sDriverID                               to aApiTables[iCount].ApiTableInfo.sDriverID
93154>>>                Move bIsAlias                                to aApiTables[iCount].ApiTableInfo.bIsAlias
93155>>>                Move bIsSQL                                  to aApiTables[iCount].ApiTableInfo.bIsSQL
93156>>>                Move aApiColumns                             to aApiTables[iCount].aApiColumns
93157>>>                Move aApiIndexes                             to aApiTables[iCount].aApiIndexes
93158>>>                Move aApiRelations                           to aApiTables[iCount].aApiRelations
93159>>>                Increment iCount
93160>>>            End     
93160>>>>
93160>>>            
93160>>>            If (bStatusPanel = True) Begin
93162>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
93163>>>                If (bUserCancel = True) Begin
93165>>>                    Send Stop_StatusPanel of ghoStatusPanel
93166>>>                    Function_Return aApiTablesEmpty
93167>>>                End
93167>>>>
93167>>>            End
93167>>>>
93167>>>
93167>>>        Until (hTable = 0)    
93169>>>    
93169>>>        Function_Return aApiTables    
93170>>>    End_Function
93171>>>
93171>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
93173>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
93173>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
93173>>>        tAPIColumn[] APIColumns APIColumnsEmpty
93173>>>        tAPIColumn[] APIColumns APIColumnsEmpty
93175>>>        String sDriverID sFieldName sRootName sLogicalName sValue
93175>>>        
93175>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
93176>>>        Get piDbType to iDbType
93177>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93180>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
93183>>>        Open hTable
93185>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93188>>>        If (bIsOpen = False) Begin
93190>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93191>>>            Open hTable
93193>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93194>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93197>>>            If (bIsOpen = False) Begin
93199>>>                Set Error_Report_Mode to DUF_ERROR_REPORT 
93200>>>                Function_Return APIColumnsEmpty
93201>>>            End
93201>>>>
93201>>>        End
93201>>>>
93201>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93204>>>        Get IsSQLDriver    sDriverID to bSqlDriver
93205>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver       
93206>>>        
93206>>>        If (sDriverID <> DATAFLEX_ID) Begin
93208>>>            Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
93209>>>            If (bIsSqlTable = True) Begin
93211>>>                Get UtilTableExists hTable to bExists
93212>>>                If (bExists = False) Begin
93214>>>                    Function_Return APIColumnsEmpty
93215>>>                End
93215>>>>
93215>>>            End                                    
93215>>>>
93215>>>        End
93215>>>>
93215>>>        
93215>>>        Move 0 to iCount
93216>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
93219>>>        Set piMaximum of ghoProgressBar to iNumColumns
93220>>>        
93220>>>        for iColumn from 1 to iNumColumns
93226>>>>
93226>>>            Move 0 to iOptions       
93227>>>            Move False to bIdentityKey         
93228>>>            Move False to Err
93229>>>            Move 0     to LastErr     
93230>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
93231>>>            Set piPosition of ghoProgressBar to iColumn
93232>>>            If (bDawSqlDriver = True) Begin
93234>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE   
93235>>>                If (bIsSqlTable = True) Begin
93237>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
93240>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
93243>>>                End
93243>>>>
93243>>>                Else Begin
93244>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType 
93247>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
93248>>>                End
93248>>>>
93248>>>                
93248>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
93248>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
93251>>>                Move (iCheckFieldNumber >= 0) to bExists
93252>>>                If (bExists = False) Begin
93254>>>                    Move 0 to APIColumns[iCount].iType
93255>>>                End
93255>>>>
93255>>>                If (bExists = True) Begin
93257>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey                
93260>>>                End
93260>>>>
93260>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
93261>>>                If (bIdentityKey = True) Begin
93263>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
93264>>>                End
93264>>>>
93264>>>            End
93264>>>>
93264>>>            Else Begin
93265>>>                Move False to Err
93266>>>                Move 0     to LastErr
93267>>>                If (bIsSqlTable = True) Begin
93269>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
93272>>>                End
93272>>>>
93272>>>                Else Begin
93273>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
93276>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
93277>>>                End
93277>>>>
93277>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
93277>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists           
93278>>>                If (bExists = False) Begin
93280>>>                    Move 0 to APIColumns[iCount].iType
93281>>>                End
93281>>>>
93281>>>            End
93281>>>>
93281>>>            
93281>>>            If (bExists = True) Begin                                                          
93283>>>                Move iColumn to APIColumns[iCount].iFieldNumber
93284>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
93287>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems. 
93287>>>//                If (bIsSqlTable = True) Begin
93287>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
93287>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
93287>>>//                End
93287>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
93290>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
93293>>>                
93293>>>                // If the length was zero we might have an Overlap(!) field.
93293>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
93293>>>                If (APIColumns[iCount].iLength = 0) Begin
93295>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
93298>>>                    If (iType = DF_OVERLAP) Begin
93300>>>                        Move 0 to APIColumns[iCount].iFieldNumber
93301>>>                        Move 0 to APIColumns[iCount].iLength
93302>>>                        Move 0 to APIColumns[iCount].iOptions
93303>>>                        Move 0 to APIColumns[iCount].iPrecision
93304>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
93305>>>                        Move "" to APIColumns[iCount].sFieldName
93306>>>                        Decrement iCount
93307>>>                    End                                                          
93307>>>>
93307>>>                End
93307>>>>
93307>>>            End
93307>>>>
93307>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
93308>>>            If (bUserCancel = True) Begin
93310>>>                Send Stop_StatusPanel of ghoStatusPanel
93311>>>                Send Info_Box "Process interrupted..."
93312>>>                Function_Return APIColumnsEmpty
93313>>>            End
93313>>>>
93313>>>            Increment iCount
93314>>>        Loop
93315>>>>
93315>>>        
93315>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93316>>>        Function_Return APIColumns                          
93317>>>    End_Function        
93318>>>    
93318>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
93320>>>        tAPIIndex[] APIIndexes
93320>>>        tAPIIndex[] APIIndexes
93321>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn iIndexType iCase
93321>>>        String sDriverID
93321>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsPrimaryKey
93321>>>        
93321>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93322>>>        Get psDriverID to sDriverID
93323>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver 
93324>>>        Get UtilTableIsSQL hTable to bIsSQLTable
93325>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93328>>>        If (bIsOpen = False) Begin
93330>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93331>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93332>>>            Open hTable
93334>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93335>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93336>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93339>>>            If (bIsOpen = False) Begin
93341>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
93342>>>                Function_Return APIIndexes
93343>>>            End
93343>>>>
93343>>>        End
93343>>>>
93343>>>        
93343>>>        Move 0 to iCount
93344>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
93347>>>        for iIndex from 1 to iIndexes                                              
93353>>>>
93353>>>            // This is a test that the index exists as there might be "holes" aka the index
93353>>>            // numbers doesn not need to be consequitive:
93353>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
93356>>>            If (iNumSegments > 0) Begin
93358>>>            
93358>>>                Move iIndex to APIIndexes[iCount].iIndexNumber    
93359>>>                If (bIsSQLTable = True) Begin
93361>>>                    Get_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndexes[iCount].sSQLIndexName
93364>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
93367>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsPrimaryKey
93370>>>                End
93370>>>>
93370>>>    
93370>>>                Move 0 to iSegmentCount
93371>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments       
93374>>>                for iSegment from 1 to iNumSegments     
93380>>>>
93380>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
93383>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
93384>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
93387>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
93390>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
93393>>>                    Increment iSegmentCount
93394>>>                Loop                                                                                       
93395>>>>
93395>>>            End
93395>>>>
93395>>>    
93395>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93396>>>            Increment iCount
93397>>>        Loop                              
93398>>>>
93398>>>        
93398>>>        Function_Return APIIndexes
93399>>>    End_Function
93400>>>    
93400>>>    Function UtilRelationStructFill Handle hTable Returns tAPIRelation[]
93402>>>        tAPIRelation[] APIRelations
93402>>>        tAPIRelation[] APIRelations
93403>>>        Integer iColumn iNumColumns iCount
93403>>>        Handle hParent 
93403>>>        Boolean bIsOpen
93403>>>        
93403>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93404>>>        Move 0 to iCount
93405>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93408>>>        If (bIsOpen = False) Begin
93410>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93411>>>            Open hTable
93413>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93414>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93417>>>            If (bIsOpen = False) Begin
93419>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
93420>>>                Function_Return APIRelations
93421>>>            End
93421>>>>
93421>>>        End
93421>>>>
93421>>>
93421>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
93424>>>        For iColumn from 1 to iNumColumns
93430>>>>
93430>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
93433>>>            If (hParent <> 0) Begin
93435>>>                Move (String(hTable))  to APIRelations[iCount].hTableFrom
93436>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APIRelations[iCount].sLogicalNameFrom
93439>>>                Move (String(iColumn)) to APIRelations[iCount].iColumnFrom                          
93440>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to APIRelations[iCount].sFieldNameFrom
93443>>>
93443>>>                Move (String(hParent)) to APIRelations[iCount].hTableTo
93444>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent to APIRelations[iCount].sLogicalNameTo
93447>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to APIRelations[iCount].iColumnTo
93450>>>                Get_Attribute DF_FIELD_NAME of hTable APIRelations[iCount].iColumnTo to APIRelations[iCount].sFieldNameTo
93453>>>                Increment iCount
93454>>>            End         
93454>>>>
93454>>>        Loop                                                    
93455>>>>
93455>>>        
93455>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93456>>>        Function_Return APIRelations
93457>>>    End_Function
93458>>>    
93458>>>    // Checks if a field name exists in a table definition
93458>>>    // Returns True if it does
93458>>>    // Sample:
93458>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
93458>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
93460>>>        Integer iNumColumns iColumn
93460>>>        String sColumn
93460>>>        Boolean bExists bOK bOpen
93460>>>
93460>>>        Get AutoConnectionIDLogin to bOK
93461>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93462>>>        Open hTable
93464>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93465>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
93468>>>        If (bOpen = False) Begin
93470>>>            Function_Return False
93471>>>        End
93471>>>>
93471>>>
93471>>>        Move False to bExists
93472>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
93475>>>        for iColumn from 1 to iNumColumns
93481>>>>
93481>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
93484>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
93486>>>                Move iNumColumns to iColumn
93487>>>                Move True to bExists
93488>>>            End
93488>>>>
93488>>>        Loop
93489>>>>
93489>>>        Close hTable
93490>>>
93490>>>        Function_Return bExists
93491>>>    End_Function
93492>>>    
93492>>>    // Returns the field/column number for the passed FieldName as an integer.
93492>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
93494>>>        Integer iNumColumns iColumn iRetval
93494>>>        String sColumn
93494>>>        Boolean bExists bOK bOpen
93494>>>
93494>>>        Get AutoConnectionIDLogin to bOK
93495>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93496>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93497>>>        Open hTable
93499>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93500>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
93503>>>        If (bOpen = False) Begin
93505>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93506>>>            Function_Return False
93507>>>        End
93507>>>>
93507>>>        
93507>>>        Move 0 to iColumn                  
93508>>>        Move 0 to iRetval
93509>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
93512>>>        for iColumn from 1 to iNumColumns
93518>>>>
93518>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
93521>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
93523>>>                Move iColumn to iRetval
93524>>>                Move iNumColumns to iColumn
93525>>>            End
93525>>>>
93525>>>        Loop
93526>>>>
93526>>>        Close hTable
93527>>>
93527>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93528>>>        Function_Return iRetval
93529>>>    End_Function
93530>>>
93530>>>    // Checks if the current psConnectionID is logged in; if not
93530>>>    // attempts to make a login.
93530>>>    // Because
93530>>>    // Returns True if already logged in or the new login was successful.
93530>>>    // *** Utility Messages ***
93530>>>    //
93530>>>    //
93530>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
93530>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
93530>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
93530>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
93532>>>        Boolean bError bFound
93532>>>
93532>>>        Move False to Err
93533>>>        Open CodeMast
93535>>>        Open CodeType
93537>>>
93537>>>        If (bCodeType = True) Begin
93539>>>            Clear CodeType
93540>>>            Move sTypeValue to CODETYPE.Type
93541>>>            Find eq CODETYPE.Type
93542>>>>
93542>>>            Move (Found = True) to bFound
93543>>>            If (bFound = True) Begin
93545>>>                Reread CodeType
93549>>>            End
93549>>>>
93549>>>            If (bFound = False) Begin
93551>>>                Clear CodeType
93552>>>            End
93552>>>>
93552>>>                Move sTypeValue to CODETYPE.Type
93553>>>                Move sValue2    to CODETYPE.Description
93554>>>                Move sValue3    to CODETYPE.Comment
93555>>>                SaveRecord CODETYPE
93556>>>            If (bFound = True) Begin
93558>>>                Unlock
93559>>>>
93559>>>            End
93559>>>>
93559>>>        End
93559>>>>
93559>>>
93559>>>        If (bCodeType = False) Begin
93561>>>            Clear CODEMAST
93562>>>            Move sTypeValue to CODEMAST.Type
93563>>>            Move sValue2    to CODEMAST.Code
93564>>>            Find eq CODEMAST.Code
93565>>>>
93565>>>            Move (Found = True) to bFound
93566>>>            If (bFound = True) Begin
93568>>>                Reread CODEMAST
93572>>>            End
93572>>>>
93572>>>            If (bFound = False) Begin
93574>>>                Clear CODEMAST
93575>>>            End
93575>>>>
93575>>>                Move sTypeValue to CODEMAST.Type
93576>>>                Move sValue2    to CODEMAST.Code
93577>>>                Move sValue3    to CODEMAST.Description
93578>>>                SaveRecord CODEMAST
93579>>>            If (bFound = True) Begin
93581>>>            Unlock
93582>>>>
93582>>>            End
93582>>>>
93582>>>        End
93582>>>>
93582>>>
93582>>>        Close CodeMast
93583>>>        Close CodeType
93584>>>
93584>>>        Function_Return (Err = False)
93585>>>    End_Function
93586>>>
93586>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
93586>>>    // CodeType and then spins through all CodeMast records to change all related records.
93586>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
93588>>>        Boolean bFound
93588>>>
93588>>>        Move False to Err
93589>>>        Open CodeMast
93591>>>        Open CodeType
93593>>>
93593>>>        Clear CodeType
93594>>>        Move sFromValue to CODETYPE.Type
93595>>>        Find eq CODETYPE.Type
93596>>>>
93596>>>        If (Found = True) Begin
93598>>>            Reread CODETYPE
93602>>>                Move sToValue to CODETYPE.Type
93603>>>                SaveRecord CODETYPE
93604>>>            Unlock
93605>>>>
93605>>>        End
93605>>>>
93605>>>
93605>>>        Clear CODEMAST
93606>>>        Find gt CODEMAST by Recnum
93607>>>>
93607>>>        While (Found = True)
93611>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
93612>>>            If (bFound = True) Begin
93614>>>                Reread CODEMAST
93618>>>                    Move sToValue to CODEMAST.Type
93619>>>                    SaveRecord CODEMAST
93620>>>                Unlock
93621>>>>
93621>>>            End
93621>>>>
93621>>>            Find gt CODEMAST by Recnum
93622>>>>
93622>>>        Loop
93623>>>>
93623>>>
93623>>>        Close CodeMast
93624>>>        Close CodeType
93625>>>
93625>>>        Function_Return (Err = False)
93626>>>    End_Function
93627>>>
93627>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
93627>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
93629>>>        Boolean bError bFound
93629>>>
93629>>>        Move False to Err
93630>>>        Open CodeMast
93632>>>
93632>>>        Clear CODEMAST
93633>>>        Move sTypeValue to CODEMAST.Type
93634>>>        Move sValue2    to CODEMAST.Code
93635>>>        Find eq CODEMAST.Code
93636>>>>
93636>>>        Move (Found = True) to bFound
93637>>>        If (bFound = True) Begin
93639>>>            Delete CODEMAST
93640>>>        End
93640>>>>
93640>>>
93640>>>        Close CodeMast
93641>>>
93641>>>        Function_Return (Err = False)
93642>>>    End_Function
93643>>>
93643>>>    // Note:
93643>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
93643>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
93643>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
93643>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
93643>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
93643>>>    Function UtilTableHandleToString Handle hTable Returns String
93645>>>        String sTableName
93645>>>        Boolean bOpen bExists bRecnum bOK
93645>>>
93645>>>        Get UtilTableNumberIsInUse hTable to bExists
93646>>>        If (bExists = False) Begin
93648>>>            Function_Return ""
93649>>>        End
93649>>>>
93649>>>
93649>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93650>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
93653>>>        If (bOpen = False) Begin
93655>>>            Get AutoConnectionIDLogin to bOK
93656>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93657>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
93658>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
93659>>>            Open hTable
93661>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
93662>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
93663>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
93664>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
93667>>>        End
93667>>>>
93667>>>        If (bOpen = True) Begin
93669>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
93670>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
93673>>>            // If blank it is an embedded table:
93673>>>            If (sTableName = "") Begin
93675>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
93678>>>                Move 0 to LastErr
93679>>>                Move False to Err
93680>>>            End
93680>>>>
93680>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
93681>>>        End
93681>>>>
93681>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93682>>>
93682>>>        Function_Return sTableName
93683>>>    End_Function
93684>>>
93684>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
93684>>>    // Returns 0 if unsuccessful.
93684>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
93684>>>    Function UtilTableNameToHandle String sTableName Returns Integer
93686>>>        String sValue sPrefixTableName sDriverID
93686>>>        Handle hTable hRetval
93686>>>
93686>>>        Get psDriverID to sDriverID
93687>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
93689>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
93690>>>        End
93690>>>>
93690>>>        Move 0 to hTable
93691>>>        Move 0 to hRetval
93692>>>        Repeat
93692>>>>
93692>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93695>>>            If (hTable <> 0) Begin
93697>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
93700>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
93702>>>                    Move hTable to hRetval
93703>>>                    Move 0 to hTable
93704>>>                End
93704>>>>
93704>>>            End
93704>>>>
93704>>>        Until (hTable = 0)
93706>>>
93706>>>        Function_Return hRetval
93707>>>    End_Function
93708>>>
93708>>>    // Check if the file exists in the Data folder,
93708>>>    // else creates it from memory as it has been compiled into the program as a resource:
93708>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
93710>>>        String sPath sDataPath
93710>>>        Boolean bExists
93710>>>
93710>>>        Get psDataPathFirstPart to sPath
93711>>>        Move (sPath + sFileName) to sFileName
93712>>>        Get vFilePathExists sFileName to bExists
93713>>>
93713>>>        If (bExists = False) Begin
93715>>>            // Read from memory & create file on disk.
93715>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
93716>>>            Get vFilePathExists sFileName to bExists
93717>>>        End
93717>>>>
93717>>>        Function_Return bExists
93718>>>    End_Function
93719>>>
93719>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
93719>>>    // The reciprocal function of UtilColumnTypeToInteger.
93719>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
93721>>>        tColumnType RetvalType
93721>>>        tColumnType RetvalType
93721>>>
93721>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
93722>>>        Function_Return RetvalType.iType
93723>>>    End_Function
93724>>>
93724>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
93724>>>    // The reciprocal function of UtilColumnTypeToString.
93724>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
93726>>>        tColumnType RetvalType
93726>>>        tColumnType RetvalType
93726>>>        String sValue
93726>>>
93726>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
93727>>>        Function_Return RetvalType.sType
93728>>>    End_Function
93729>>>
93729>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
93731>>>        tColumnType RetvalType 
93731>>>        tColumnType RetvalType 
93731>>>        Integer iRetval
93731>>>        
93731>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
93732>>>        Move RetvalType.iDataFlexType to iRetval
93733>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
93735>>>            If (iLength <= 255) Begin
93737>>>                Move DF_ASCII to iRetval
93738>>>            End
93738>>>>
93738>>>        End                             
93738>>>>
93738>>>        Function_Return iRetval
93739>>>    End_Function
93740>>>
93740>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
93742>>>        tColumnType RetvalType
93742>>>        tColumnType RetvalType
93742>>>        String sValue
93742>>>
93742>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
93743>>>        Function_Return RetvalType.sPrecision
93744>>>    End_Function
93745>>>
93745>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
93747>>>        tColumnType RetvalType
93747>>>        tColumnType RetvalType
93747>>>        String sValue
93747>>>
93747>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
93748>>>        Function_Return RetvalType.bFixedSize
93749>>>    End_Function
93750>>>
93750>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
93752>>>        tColumnType RetvalType
93752>>>        tColumnType RetvalType
93752>>>        String sValue
93752>>>        Integer iRetval iPos
93752>>>
93752>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
93753>>>        Move RetvalType.sPrecision to sValue
93754>>>        Move (Pos(".", sValue)) to iPos
93755>>>        If (iPos <> 0) Begin
93757>>>            Move (Left(sValue, (iPos -1))) to iRetval
93758>>>        End
93758>>>>
93758>>>        Else Begin
93759>>>            Move sValue to iRetval
93760>>>        End
93760>>>>
93760>>>        Function_Return iRetval
93761>>>    End_Function
93762>>>
93762>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
93764>>>        tColumnType RetvalType
93764>>>        tColumnType RetvalType
93764>>>        String sValue
93764>>>        Integer iRetval iPos
93764>>>
93764>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
93765>>>        Move RetvalType.sPrecision to sValue
93766>>>        Move (Pos(".", sValue)) to iPos
93767>>>        If (iPos = 0) Begin
93769>>>            Function_Return 0
93770>>>        End
93770>>>>
93770>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
93771>>>
93771>>>        Function_Return iRetval
93772>>>    End_Function
93773>>>
93773>>>    // The default value used for a datatype as specified in the driver int file.
93773>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
93775>>>        String sRetval sServer
93775>>>        tColumnType RetvalType
93775>>>        tColumnType RetvalType
93775>>>        Integer iDriver iDataFlexType
93775>>>        Handle hDatabase
93775>>>
93775>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
93776>>>        Move RetvalType.iDataFlexType to iDataFlexType
93777>>>        Get DriverIndex sDriverID to iDriver
93778>>>        Get psServer to sServer
93779>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
93780>>>        If (hDatabase = 0) Begin
93782>>>            Function_Return ""
93783>>>        End
93783>>>>
93783>>>
93783>>>        Case Begin
93783>>>            Case (iDataFlexType = DF_ASCII)
93785>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
93788>>>                Case Break
93789>>>            Case (iDataFlexType = DF_BCD)
93792>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
93795>>>                Case Break
93796>>>            Case (iDataFlexType = DF_BINARY)
93799>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
93802>>>                Case Break
93803>>>            Case (iDataFlexType = DF_DATE)
93806>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
93809>>>                Case Break
93810>>>            Case (iDataFlexType = DF_DATETIME)
93813>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
93816>>>                Case Break
93817>>>            Case (iDataFlexType = DF_TEXT)
93820>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
93823>>>                Case Break
93824>>>            Case Else
93824>>>                Move "" to sRetval
93825>>>        Case End
93825>>>
93825>>>        Function_Return sRetval
93826>>>    End_Function 
93827>>>    
93827>>>    Procedure Set DF_DATABASE_DEFAULT_DEFAULT_DATE_DUF String sDateValue
93829>>>        String sDriverID sRetval sServer
93829>>>        tColumnType RetvalType
93829>>>        tColumnType RetvalType
93829>>>        Integer iDbType iDriver iDataFlexType
93829>>>        Handle hDatabase
93829>>>        
93829>>>        Get psDriverID to sDriverID
93830>>>        Get piDbType   to iDbType
93831>>>        Get DriverIndex sDriverID to iDriver
93832>>>        Get psServer to sServer
93833>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
93834>>>        If (hDatabase = 0) Begin
93836>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database."
93837>>>>
93837>>>            Procedure_Return
93838>>>        End                      
93838>>>>
93838>>>        
93838>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
93841>>>
93841>>>    End_Procedure
93842>>>
93842>>>    Procedure Set DF_DATABASE_DEFAULT_DEFAULT_DATETIME_DUF String sDateValue
93844>>>        String sDriverID sRetval sServer
93844>>>        tColumnType RetvalType
93844>>>        tColumnType RetvalType
93844>>>        Integer iDbType iDriver iDataFlexType
93844>>>        Handle hDatabase
93844>>>        
93844>>>        Get psDriverID to sDriverID
93845>>>        Get piDbType   to iDbType
93846>>>        Get DriverIndex sDriverID to iDriver
93847>>>        Get psServer to sServer
93848>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
93849>>>        If (hDatabase = 0) Begin
93851>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
93852>>>>
93852>>>            Procedure_Return
93853>>>        End                      
93853>>>>
93853>>>        
93853>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
93856>>>
93856>>>    End_Procedure
93857>>>
93857>>>    // Returns a struct array with the default column types for the SQL back-end and how they
93857>>>    // are mapped to the standard DataFlex data types.
93857>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
93857>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
93859>>>        tColumnType[] ColumnTypeArray EmptyArray
93859>>>        tColumnType[] ColumnTypeArray EmptyArray
93861>>>        String sDataType
93861>>>        Integer iDataType iDriverID iCount  
93861>>>        Boolean bSQLDriver
93861>>>
93861>>>        Move 0 to iCount
93862>>>        Get DriverIndex sDriverID to iDriverID
93863>>>        Get IsSQLDriver sDriverID to bSQLDriver
93864>>>        If (bSQLDriver = False) Begin
93866>>>            Function_Return EmptyArray
93867>>>        End
93867>>>>
93867>>>
93867>>>        // DF_ASCII
93867>>>        If (sDriverID = ODBC_DRV_ID) Begin
93869>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
93872>>>        End
93872>>>>
93872>>>        Else Begin
93873>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
93876>>>        End
93876>>>>
93876>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
93877>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
93878>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
93879>>>        Move sDataType   to ColumnTypeArray[iCount].sType
93880>>>        Move iDataType   to ColumnTypeArray[iCount].iType
93881>>>        Increment iCount
93882>>>
93882>>>        // DF_BINARY
93882>>>        If (sDriverID = ODBC_DRV_ID) Begin
93884>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
93887>>>        End
93887>>>>
93887>>>        Else Begin
93888>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
93891>>>        End
93891>>>>
93891>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
93892>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
93893>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
93894>>>        Move sDataType   to ColumnTypeArray[iCount].sType
93895>>>        Move iDataType   to ColumnTypeArray[iCount].iType
93896>>>        Increment iCount
93897>>>
93897>>>        // DF_DATE
93897>>>        If (sDriverID = ODBC_DRV_ID) Begin
93899>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
93902>>>        End
93902>>>>
93902>>>        Else Begin
93903>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
93906>>>        End
93906>>>>
93906>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
93907>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
93908>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
93909>>>        Move sDataType   to ColumnTypeArray[iCount].sType
93910>>>        Move iDataType   to ColumnTypeArray[iCount].iType
93911>>>        Increment iCount
93912>>>
93912>>>        // DF_DATETIME
93912>>>        If (sDriverID = ODBC_DRV_ID) Begin
93914>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
93917>>>        End
93917>>>>
93917>>>        Else Begin
93918>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
93921>>>        End
93921>>>>
93921>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
93922>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
93923>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
93924>>>        Move sDataType   to ColumnTypeArray[iCount].sType
93925>>>        Move iDataType   to ColumnTypeArray[iCount].iType
93926>>>        Increment iCount
93927>>>
93927>>>        // DF_NUMERIC
93927>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
93927>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
93927>>>        // we make them here all "Numeric"... 
93927>>>        Case Begin
93927>>>            Case (sDriverID = MSSQLDRV_ID)
93929>>>                Move SQL_NUMERIC to iDataType 
93930>>>                Move "numeric"   to sDataType
93931>>>                Case Break
93932>>>            Case (sDriverID = DB2_DRV_ID)
93935>>>                Move SQL_NUMERIC to iDataType
93936>>>                Move "NUMERIC"   to sDataType
93937>>>                Case Break                   
93938>>>            Case (sDriverID = SQLFLEX)
93941>>>                Move eSQLServer_NUMERIC to iDataType
93942>>>                Move "numeric"   to sDataType
93943>>>                Case Break                   
93944>>>            Case (sDriverID = MDSMySQL)
93947>>>                Move eMySQL_DECIMAL to iDataType
93948>>>                Move "decimal"   to sDataType
93949>>>                Case Break       
93950>>>            Case (sDriverID = ORAFLEX)
93953>>>                Move eOracle_NUMBER to iDataType
93954>>>                Move "NUMBER"   to sDataType
93955>>>                Case Break       
93956>>>            Case (sDriverID = MDSPgSQL)
93959>>>                Move ePgSQL_FLOAT4 to iDataType
93960>>>                Move "decimal"   to sDataType
93961>>>                Case Break       
93962>>>            Case Else
93962>>>                Move DF_BCD      to iDataType
93963>>>                Move "Numeric"   to sDataType
93964>>>        Case End
93964>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
93965>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
93966>>>        Move sDataType   to ColumnTypeArray[iCount].sType
93967>>>        Move iDataType   to ColumnTypeArray[iCount].iType
93968>>>        Increment iCount
93969>>>
93969>>>        // DF_TEXT
93969>>>        If (sDriverID = ODBC_DRV_ID) Begin
93971>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
93974>>>        End
93974>>>>
93974>>>        Else Begin
93975>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
93978>>>        End
93978>>>>
93978>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
93979>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
93980>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
93981>>>        Move sDataType   to ColumnTypeArray[iCount].sType
93982>>>        Move iDataType   to ColumnTypeArray[iCount].iType
93983>>>
93983>>>        Function_Return ColumnTypeArray
93984>>>    End_Function 
93985>>>    
93985>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
93987>>>        tColumnType[] ColumnTypeArray
93987>>>        tColumnType[] ColumnTypeArray
93988>>>        tColumnType   ColumnType 
93988>>>        tColumnType   ColumnType 
93988>>>        Integer iCount iSize
93988>>>        
93988>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
93989>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
93990>>>        Decrement iSize
93991>>>        
93991>>>        for iCount from 0 to iSize
93997>>>>
93997>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
93999>>>                Move ColumnTypeArray[iCount].bFixedSize     to ColumnType.bFixedSize
94000>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
94001>>>                Move ColumnTypeArray[iCount].iType          to ColumnType.iType
94002>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
94003>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
94004>>>                Move ColumnTypeArray[iCount].sType          to ColumnType.sType
94005>>>                Move iSize to iCount
94006>>>            End
94006>>>>
94006>>>        Loop
94007>>>>
94007>>>        
94007>>>        Function_Return ColumnType
94008>>>    End_Function
94009>>>
94009>>>    // Returns a struct with the default column types for the SQL back-end and how they
94009>>>    // are mapped to a framework DataFlex data type.
94009>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
94011>>>        tColumnType ColumnType
94011>>>        tColumnType ColumnType
94011>>>        String sDataType
94011>>>        Integer iDriverID iDataType iCount
94011>>>
94011>>>        Move 0 to iCount
94012>>>        Get DriverIndex sDriverID to iDriverID
94013>>>            
94013>>>        Case Begin
94013>>>            // DF_ASCII
94013>>>            Case (iType = DF_ASCII_DUF)
94015>>>                If (sDriverID = ODBC_DRV_ID) Begin
94017>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
94020>>>                End
94020>>>>
94020>>>                Else Begin
94021>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType 
94024>>>                End
94024>>>>
94024>>>                Move DF_ASCII    to ColumnType.iDataFlexType
94025>>>                Move "ASCII"     to ColumnType.sDataFlexType
94026>>>                Move sDataType   to ColumnType.sType
94027>>>                Move DF_ASCII    to ColumnType.iType
94028>>>                Move False       to ColumnType.bFixedSize
94029>>>                Case Break
94030>>>                
94030>>>            // DF_BINARY
94030>>>            Case (iType = DF_BINARY_DUF)
94033>>>                If (sDriverID = ODBC_DRV_ID) Begin
94035>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
94038>>>                End
94038>>>>
94038>>>                Else Begin
94039>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
94042>>>                End
94042>>>>
94042>>>                Move DF_BINARY   to ColumnType.iDataFlexType
94043>>>                Move "Binary"    to ColumnType.sDataFlexType
94044>>>                Move sDataType   to ColumnType.sType
94045>>>                Move DF_BINARY   to ColumnType.iType
94046>>>                Move False       to ColumnType.bFixedSize
94047>>>                Case Break
94048>>>    
94048>>>            // DF_DATE
94048>>>            Case (iType = DF_DATE_DUF)
94051>>>                If (sDriverID = ODBC_DRV_ID) Begin
94053>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
94056>>>                End
94056>>>>
94056>>>                Else Begin
94057>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
94060>>>                End
94060>>>>
94060>>>                Move DF_DATE     to ColumnType.iDataFlexType
94061>>>                Move "Date"      to ColumnType.sDataFlexType
94062>>>                Move sDataType   to ColumnType.sType
94063>>>                Move DF_DATE     to ColumnType.iType
94064>>>                Move True        to ColumnType.bFixedSize
94065>>>                Case Break
94066>>>    
94066>>>            // DF_DATETIME       
94066>>>            Case (iType = DF_DATETIME_DUF)
94069>>>                If (sDriverID = ODBC_DRV_ID) Begin
94071>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
94074>>>                End
94074>>>>
94074>>>                Else Begin
94075>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
94078>>>                End
94078>>>>
94078>>>                Move DF_DATETIME to ColumnType.iDataFlexType
94079>>>                Move "DateTime"  to ColumnType.sDataFlexType
94080>>>                Move sDataType   to ColumnType.sType
94081>>>                Move DF_DATETIME to ColumnType.iType
94082>>>                Move True        to ColumnType.bFixedSize
94083>>>                Case Break
94084>>>    
94084>>>            // DF_NUMERIC
94084>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
94084>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
94084>>>            // we make them here all "Numeric"...
94084>>>            // If (sDriverID = ODBC_DRV_ID) Begin
94084>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
94084>>>            // End
94084>>>            // Else Begin
94084>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
94084>>>            // End 
94084>>>            // ToDo: How should we find the best "Numeric" data type here?
94084>>>            Case (iType = DF_BCD_DUF)
94087>>>                Move DF_BCD      to ColumnType.iDataFlexType
94088>>>                Move "Numeric"   to ColumnType.sDataFlexType
94089>>>                Move "Numeric"   to ColumnType.sType
94090>>>                Move SQL_NUMERIC to ColumnType.iType
94091>>>                Move False       to ColumnType.bFixedSize
94092>>>                Case Break
94093>>>                
94093>>>            // DF_TEXT
94093>>>            Case (iType = DF_TEXT_DUF)
94096>>>                If (sDriverID = ODBC_DRV_ID) Begin
94098>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
94101>>>                End
94101>>>>
94101>>>                Else Begin
94102>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
94105>>>                End
94105>>>>
94105>>>                Move DF_TEXT     to ColumnType.iDataFlexType
94106>>>                Move "Text"      to ColumnType.sDataFlexType
94107>>>                Move sDataType   to ColumnType.sType
94108>>>                Move DF_TEXT     to ColumnType.iType
94109>>>                Move False       to ColumnType.bFixedSize
94110>>>                Case Break
94111>>>                
94111>>>            Case Else
94111>>>                Move -1999       to ColumnType.iDataFlexType
94112>>>                Move "Undefined" to ColumnType.sDataFlexType
94113>>>                Move "Undefined" to ColumnType.sType
94114>>>                Move -1999       to ColumnType.iType
94115>>>                Move True        to ColumnType.bFixedSize
94116>>>
94116>>>        Case End
94116>>>
94116>>>        Function_Return ColumnType
94117>>>    End_Function
94118>>>
94118>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
94120>>>        String sDataPath sDriverID
94120>>>        Boolean bMertechDriver bOK
94120>>>        Integer iPos
94120>>>
94120>>>        If (sTableName contains ".") Begin
94122>>>            Move (Pos(".", sTableName)) to iPos
94123>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
94124>>>        End
94124>>>>
94124>>>
94124>>>        Get psDriverID to sDriverID
94125>>>        Get psDataPathFirstPart to sDataPath
94126>>>        Get IsMertechDriver sDriverID to bMertechDriver
94127>>>        // First delete the cache file:
94127>>>        If (bMertechDriver = False) Begin
94129>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
94130>>>        End
94130>>>>
94130>>>        Else Begin
94131>>>            Get _MertechDeleteTDFile sTableName to bOK
94132>>>        End
94132>>>>
94132>>>
94132>>>        Function_Return bOK
94133>>>    End_Function
94134>>>
94134>>>    // Changes source code files.
94134>>>    // Pass a file name with full path and a value to search for, together with the value
94134>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
94134>>>    // to use a Connection ID.
94134>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
94134>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
94134>>>    // Returns True if no errors occured.
94134>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
94136>>>        Integer iCh iRow iItems iCount
94136>>>        String sValue sRow
94136>>>        String[] sFileArray
94137>>>        Boolean bExists bIsActive
94137>>>
94137>>>        Move False to Err
94138>>>        Move 0 to iRow
94139>>>
94139>>>        If (ghoStatusPanel <> 0) Begin
94141>>>            Get Active_state of ghoStatusPanel to bIsActive
94142>>>        End
94142>>>>
94142>>>
94142>>>        Get vFilePathExists sFileName to bExists
94143>>>        If (bExists = False) Begin
94145>>>            If (bShowResult = True) Begin                  
94147>>>                If (bIsActive = True) Begin
94149>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
94150>>>                End 
94150>>>>
94150>>>                Else Begin
94151>>>                    Showln "File does not exist: " sFileName
94154>>>                End
94154>>>>
94154>>>            End
94154>>>>
94154>>>            Function_Return False
94155>>>        End
94155>>>>
94155>>>
94155>>>        Get Seq_Open_Input_Channel sFileName to iCh
94156>>>        If (iCh < 1) Begin
94158>>>            Function_Return False
94159>>>        End
94159>>>>
94159>>>
94159>>>        If (bShowResult = True) Begin      
94161>>>            If (ghoStatusPanel <> 0) Begin
94163>>>                Get Active_state of ghoStatusPanel to bIsActive
94164>>>                If (bIsActive = True) Begin
94166>>>                    Set Message_Text of ghoStatusPanel to sFileName
94167>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo)) 
94168>>>                    Send DoAdvance of ghoProgressBar
94169>>>                End
94169>>>>
94169>>>            End
94169>>>>
94169>>>            Else Begin
94170>>>                Showln ""
94172>>>                Showln "sFileName = " sFileName
94175>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
94180>>>            End
94180>>>>
94180>>>        End
94180>>>>
94180>>>
94180>>>        While (not(SeqEof))
94184>>>            Readln channel iCh sRow
94186>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
94188>>>//                If (bShowResult = True) Begin  
94188>>>//                    If (bIsActive = True) Begin
94188>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
94188>>>//                    End
94188>>>//                    Else Begin
94188>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
94188>>>//                    End
94188>>>//                End
94188>>>                // Change the whole line to the new connection id:
94188>>>                Move sChangeTo to sRow
94189>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
94189>>>            End
94189>>>>
94189>>>            Move sRow to sFileArray[iRow]
94190>>>            Increment iRow
94191>>>        End
94192>>>>
94192>>>        Send Seq_Close_Channel iCh
94193>>>
94193>>>        Sleep 1 // Wait for Windows to close the file
94194>>>
94194>>>        Get Seq_Open_Output_Channel sFileName to iCh
94195>>>        If (iCh < 1) Begin
94197>>>            Function_Return False
94198>>>        End
94198>>>>
94198>>>        Move (SizeOfArray(sFileArray)) to iItems
94199>>>        Decrement iItems
94200>>>
94200>>>        For iCount from 0 to iItems
94206>>>>
94206>>>            Move sFileArray[iCount] to sValue
94207>>>            Writeln channel iCh sValue
94210>>>        Loop
94211>>>>
94211>>>        Send Seq_Close_Channel iCh
94212>>>
94212>>>        Function_Return (Err = False)
94213>>>    End_Function
94214>>>
94214>>>    // This might be needed by API-methods when a connection id is to be used and
94214>>>    // the connection ID hasn't been established with the driver's CLI interface.
94214>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
94214>>>    Function UtilCreateConnectionID String sConnectionID Returns Boolean
94216>>>        String sConnectionString sDriverID
94216>>>        Boolean bOK bSilent bDawDriver
94216>>>        Handle hoCLI
94216>>>
94216>>>        Move False to bOK
94217>>>        Get psDriverID to sDriverID
94218>>>        Get IsDAWSQLDriver sDriverID to bDawDriver
94219>>>        If (bDawDriver = False) Begin
94221>>>            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
94222>>>>
94222>>>            Function_Return False
94223>>>        End
94223>>>>
94223>>>
94223>>>        Get psConnectionString to sConnectionString
94224>>>        Get pbSilentLogin      to bSilent
94225>>>
94225>>>        Get phoCLIHandler to hoCLI
94226>>>        If (hoCLI <> 0) Begin
94228>>>            Set psDriverID of hoCLI to sDriverID
94229>>>            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
94230>>>        End
94230>>>>
94230>>>
94230>>>        Function_Return (bOK = False)
94231>>>    End_Function
94232>>>
94232>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
94232>>>    // and opens it in "notepad.exe".
94232>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
94232>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
94232>>>    Procedure UtilShowErrorList
94234>>>        tSqlErrorArray aSqlErrorArray
94234>>>        tSqlErrorArray aSqlErrorArray
94234>>>        Integer iRows iCount iCh iErrorNum
94234>>>        String sPath sFileName sErrorTxt sStatement
94234>>>
94234>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
94235>>>        Get vFolderFormat sPath to sPath
94236>>>        Move "SQLErrorLog.txt"  to sFileName
94237>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
94238>>>            Get paSqlErrorArray to aSqlErrorArray
94239>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
94240>>>            If (iRows > 0) Begin
94242>>>                Decrement iRows
94243>>>                for iCount from 0 to iRows
94249>>>>
94249>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
94250>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
94251>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
94252>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
94258>>>                    Writeln channel iCh "SQL Statement: " sStatement
94262>>>                Loop
94263>>>>
94263>>>            End
94263>>>>
94263>>>        Send Seq_Close_Channel iCh
94264>>>
94264>>>        If (iRows > 0) Begin
94266>>>            Runprogram Background "Notepad.exe" (sPath + sFileName)
94267>>>        End
94267>>>>
94267>>>    End_Procedure
94268>>>    
94268>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
94268>>>    // and the table needs to exist as an SQL table.
94268>>>    Function UtilTableIsSql Handle hTable Returns Boolean
94270>>>        String sRootName sLogicalName sDriverID
94270>>>        Boolean bIsSQL
94270>>>        
94270>>>        Move False to bIsSQL
94271>>>        If (hTable > 0) Begin
94273>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94276>>>            Move (sRootName contains ":") to bIsSQL
94277>>>            If (bIsSQL = True) Begin               
94279>>>                Get psDriverID to sDriverID
94280>>>                Get _TableNameOnly sRootName to sRootName
94281>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
94282>>>            End
94282>>>>
94282>>>        End
94282>>>>
94282>>>
94282>>>        Function_Return bIsSQL
94283>>>    End_Function
94284>>>
94284>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
94286>>>        Boolean bIsSQL
94286>>>        Move (sRootName contains ":") to bIsSQL
94287>>>        Function_Return bIsSQL
94288>>>    End_Function
94289>>>
94289>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
94289>>>    // An Alias file/table is a filelist number that share the same Physical filename
94289>>>    // but the Logical name is different.
94289>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
94289>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
94289>>>//        String sPhysicalName sPhysicalNameCompare
94289>>>//        Boolean bWasOpen bOpened bOK
94289>>>//        Integer iCount 
94289>>>//        
94289>>>//        Move 0 to iCount    
94289>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
94289>>>//        If (bWasOpen = False) Begin
94289>>>//            Open hTable
94289>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
94289>>>//            If (bOpened = False) Begin
94289>>>//                Function_Return False
94289>>>//            End  
94289>>>//        End
94289>>>//        
94289>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
94289>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
94289>>>//        If (bWasOpen = False and bOpened = True) Begin
94289>>>//            Close hTable
94289>>>//        End
94289>>>//
94289>>>//        Move 0 to hTable
94289>>>//        Repeat
94289>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94289>>>//            If (hTable > 0 and hTable <> 50) Begin
94289>>>//                Open hTable
94289>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
94289>>>//                If (bOpened = True) Begin
94289>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
94289>>>//                    Close hTable
94289>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
94289>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
94289>>>//                        Increment iCount 
94289>>>//                    End
94289>>>//                End
94289>>>//            End
94289>>>//        Until (hTable = 0)
94289>>>//        
94289>>>//        If (iCount > 1) Begin
94289>>>//            Function_Return True
94289>>>//        End
94289>>>//
94289>>>//        Function_Return False
94289>>>//    End_Function  
94289>>>
94289>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
94291>>>        String sPhysicalName sPhysicalNameCompare
94291>>>        Integer iCount iMaster iAlias iInTable
94291>>>        
94291>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
94294>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
94295>>>        Move hTable to iInTable
94296>>>        Move 0 to hTable                      
94297>>>        Move 0 to iCount    
94298>>>        
94298>>>        Repeat
94298>>>>
94298>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94301>>>            If (hTable > 0 and hTable <> 50) Begin
94303>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
94306>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
94307>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
94309>>>                
94309>>>                    If (iCount = 0) Begin
94311>>>                        Move hTable to iMaster
94312>>>                    End
94312>>>>
94312>>>                    If (iCount > 0) Begin
94314>>>                        Move hTable to iAlias
94315>>>                    End
94315>>>>
94315>>>                    Increment iCount 
94316>>>                End
94316>>>>
94316>>>            End
94316>>>>
94316>>>        Until (hTable = 0)
94318>>>        
94318>>>        If (iCount > 1) Begin
94320>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
94321>>>        End
94321>>>>
94321>>>
94321>>>        Function_Return False
94322>>>    End_Function  
94323>>>    
94323>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
94323>>>//        String sDDSrcPath sDataPath sLogicalName
94323>>>//        Boolean bOK bExists
94323>>>//        
94323>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath  
94323>>>//        If (Right(sDataPath, 1) = "\") Begin
94323>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
94323>>>//        End
94323>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
94323>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
94323>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
94323>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
94323>>>//        
94323>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94323>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
94323>>>//        
94323>>>//        Function_Return bExists
94323>>>//    End_Function  
94323>>>
94323>>>    // To Open a table with any driver.
94323>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
94323>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
94323>>>    //
94323>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
94323>>>    // The found flag is still used to indicate if the open was successful or not. The function
94323>>>    // returns a True if successful (table could be opened).
94323>>>    //
94323>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
94323>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
94323>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
94323>>>    // set properly we can open the table.
94323>>>    //
94323>>>    // DAW Driver Syntax:
94323>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
94323>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
94323>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
94323>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
94323>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
94323>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
94323>>>    //
94323>>>    // DAW Driver Sample:
94323>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
94323>>>    //
94323>>>    // Mertech Driver Samples:
94323>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
94323>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
94323>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
94323>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
94323>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
94325>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
94325>>>        Boolean bOpen bMertechDriver bOK
94325>>>        Integer iRetval
94325>>>        tSQLConnection SQLConnection
94325>>>        tSQLConnection SQLConnection
94325>>>
94325>>>        Move sTableName to sTableNameOrg
94326>>>        If (hTable > 0) Begin
94328>>>//        If (hTable > 0 and Trim(sTableName) = "") Begin
94328>>>            Send Ignore_Error of Error_Object_Id 20529
94329>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94330>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
94331>>>            Open hTable
94333>>>            Send Trap_Error of Error_Object_Id 20529
94334>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
94335>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND  
94336>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
94339>>>            If (bOpen = True) Begin
94341>>>                Function_Return True
94342>>>            End
94342>>>>
94342>>>        End
94342>>>>
94342>>>
94342>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94343>>>        Move SQLConnection.sDriverID to sDriverID
94344>>>        Get IsMertechDriver sDriverID to bMertechDriver
94345>>>        Move SQLConnection.sConnectionString to sConnection
94346>>>        Move SQLConnection.sSchema to sSchema
94347>>>        If (sSchema = "") Begin
94349>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
94350>>>        End
94350>>>>
94350>>>
94350>>>        // We need to remove the ".int" part of the table name because
94350>>>        // the table name after the "#" in the connection syntax below wants the
94350>>>        // "bare" table name without any extension.
94350>>>        If (sDriverID <> DATAFLEX_ID) Begin
94352>>>            If (Lowercase(sTableName) contains ".int") Begin
94354>>>                Get ParseFileExtension sTableName to sExt
94355>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
94356>>>            End
94356>>>>
94356>>>            Else Begin
94357>>>                Move sTableName to sTableNameShort
94358>>>                Move (Append(sTableName, ".int")) to sTableName
94359>>>            End
94359>>>>
94359>>>            If (bMertechDriver = False) Begin
94361>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
94362>>>                Move sConnection to sTableName
94363>>>            End
94363>>>>
94363>>>        End
94363>>>>
94363>>>
94363>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
94364>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
94365>>>        If (hTable = 0) Begin
94367>>>            Get NextFreeFilelistSlot to hTable
94368>>>        End
94368>>>>
94368>>>
94368>>>        Case Begin
94368>>>            Case (sDriverID = MSSQLDRV_ID)
94370>>>                // If not df_exclusive mode, we use the "Open As" syntax.
94370>>>                If (iMode <> DF_EXCLUSIVE) Begin
94372>>>                    Open sTableName as hTable
94374>>>                End
94374>>>>
94374>>>                Else Begin
94375>>>                    Get OpenTableExclusive hTable to bOK
94376>>>                    If (bOK = False) Begin
94378>>>                        Function_Return False
94379>>>                    End
94379>>>>
94379>>>                End
94379>>>>
94379>>>                Case Break
94380>>>
94380>>>            Case (sDriverID = DB2_DRV_ID)
94383>>>                // If not df_exclusive mode, we use the "Open As" syntax.
94383>>>                If (iMode <> DF_EXCLUSIVE) Begin
94385>>>                    Open sTableName as hTable
94387>>>                End
94387>>>>
94387>>>                Else Begin
94388>>>                    Get OpenTableExclusive hTable to bOK
94389>>>                    If (bOK = False) Begin
94391>>>                        Function_Return False
94392>>>                    End
94392>>>>
94392>>>                End
94392>>>>
94392>>>                Case Break
94393>>>
94393>>>            Case (sDriverID = ODBC_DRV_ID)
94396>>>                // If not df_exclusive mode, we use the "Open As" syntax.
94396>>>                If (iMode <> DF_EXCLUSIVE) Begin
94398>>>                    Open sTableName as hTable
94400>>>                End
94400>>>>
94400>>>                Else Begin
94401>>>                    Get OpenTableExclusive hTable to bOK
94402>>>                    If (bOK = False) Begin
94404>>>                        Function_Return False
94405>>>                    End
94405>>>>
94405>>>                End
94405>>>>
94405>>>                Case Break
94406>>>
94406>>>            Case (sDriverID = SQLFLEX)
94409>>>                // ToDo: What is the <owner>? Same as Schema?
94409>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
94409>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
94410>>>                // If not df_exclusive mode, we use the "Open As" syntax.
94410>>>                If (iMode <> DF_EXCLUSIVE) Begin
94412>>>                    Open sTableName as hTable
94414>>>                End
94414>>>>
94414>>>                Else Begin
94415>>>                    Get OpenTableExclusive hTable to bOK
94416>>>                    If (bOK = False) Begin
94418>>>                        Function_Return False
94419>>>                    End
94419>>>>
94419>>>                End
94419>>>>
94419>>>                Case Break
94420>>>
94420>>>            Case (sDriverID = MDSMySQL)
94423>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
94423>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
94424>>>                // If not df_exclusive mode, we use the "Open As" syntax.
94424>>>                If (iMode <> DF_EXCLUSIVE) Begin
94426>>>                    Open sTableName as hTable
94428>>>                End
94428>>>>
94428>>>                Else Begin
94429>>>                    Get OpenTableExclusive hTable to bOK
94430>>>                    If (bOK = False) Begin
94432>>>                        Function_Return False
94433>>>                    End
94433>>>>
94433>>>                End
94433>>>>
94433>>>                Case Break
94434>>>
94434>>>            Case (sDriverID = MDSPgSQL)
94437>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
94437>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
94438>>>                // If not df_exclusive mode, we use the "Open As" syntax.
94438>>>                If (iMode <> DF_EXCLUSIVE) Begin
94440>>>                    Open sTableName as hTable
94442>>>                End
94442>>>>
94442>>>                Else Begin
94443>>>                    Get OpenTableExclusive hTable to bOK
94444>>>                    If (bOK = False) Begin
94446>>>                        Function_Return False
94447>>>                    End
94447>>>>
94447>>>                End
94447>>>>
94447>>>                Case Break
94448>>>
94448>>>            Case (sDriverID = ORAFLEX)
94451>>>                // ToDo: What is the <owner>? Same as Schema?
94451>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
94451>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
94452>>>                // If not df_exclusive mode, we use the "Open As" syntax.
94452>>>                If (iMode <> DF_EXCLUSIVE) Begin
94454>>>                    Open sTableName as hTable
94456>>>                End
94456>>>>
94456>>>                Else Begin
94457>>>                    Get OpenTableExclusive hTable to bOK
94458>>>                    If (bOK = False) Begin
94460>>>                        Function_Return False
94461>>>                    End
94461>>>>
94461>>>                End
94461>>>>
94461>>>                Case Break
94462>>>
94462>>>            Case (sDriverID = DATAFLEX_ID)
94465>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
94467>>>                    Open sTableName as hTable
94469>>>                End
94469>>>>
94469>>>                Else If (iMode = DF_EXCLUSIVE) Begin
94472>>>                    Get OpenTableExclusive hTable to bOK
94473>>>                    If (bOK = False) Begin
94475>>>                        Function_Return False
94476>>>                    End
94476>>>>
94476>>>                End
94476>>>>
94476>>>                Else Begin
94477>>>                    Open hTable
94479>>>                End
94479>>>>
94479>>>                Case Break
94480>>>
94480>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
94480>>>
94480>>>            Case Else
94480>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
94481>>>>
94481>>>        Case End
94481>>>
94481>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
94482>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
94483>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
94485>>>            Move False to Found
94486>>>        End
94486>>>>
94486>>>        // If open failed, the Err is set to true,
94486>>>        // but we don't want that because it could end our loop.
94486>>>        Move False to Err
94487>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
94490>>>
94490>>>        Function_Return bOpen
94491>>>    End_Function
94492>>>
94492>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
94492>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
94492>>>    // if it is an SQL table
94492>>>    Function UtilTableExists Handle hTable Returns Boolean
94494>>>        Boolean bExists bIsSQLTable
94494>>>        String sDataPath sRootName
94494>>>        
94494>>>        Get UtilTableNumberIsInUse hTable to bExists
94495>>>        If (bExists = False) Begin
94497>>>            Function_Return False
94498>>>        End
94498>>>>
94498>>>        
94498>>>        Move False to bIsSQLTable
94499>>>        If (hTable > 0) Begin
94501>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94504>>>            Move (sRootName contains ":") to bIsSQLTable
94505>>>        End
94505>>>>
94505>>>        If (bIsSQLTable = True) Begin
94507>>>            Get UtilTableIsSQL hTable to bExists
94508>>>            Function_Return bExists
94509>>>        End
94509>>>>
94509>>>        Else Begin
94510>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
94511>>>            Get vFolderFormat sDataPath to sDataPath
94512>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
94513>>>        End
94513>>>>
94513>>>        
94513>>>        Function_Return bExists
94514>>>    End_Function               
94515>>>    
94515>>>    // Pass a table handle
94515>>>    // Returns True if the table exists in filelist.cfg.
94515>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
94517>>>        Handle hTable
94517>>>        Boolean bFound
94517>>>
94517>>>        Move False to bFound
94518>>>        Move 0 to hTable
94519>>>        Repeat
94519>>>>
94519>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94522>>>            If (hTable > 0) Begin
94524>>>                If (hTable = hCheckTable) Begin
94526>>>                    Move True to bFound
94527>>>                End
94527>>>>
94527>>>            End
94527>>>>
94527>>>            If (bFound = True) Break
94530>>>        Until (hTable = 0)
94532>>>
94532>>>        Function_Return (bFound = True)
94533>>>    End_Function
94534>>>
94534>>>    // Number of tables in Filelist.cfg. Returns integger
94534>>>    Function UtilFilelistNoOfTables Returns Integer
94536>>>        Handle hTable
94536>>>        Integer iRetval
94536>>>
94536>>>        Move 0 to hTable         
94537>>>        Move 0 to iRetval
94538>>>        
94538>>>        Repeat
94538>>>>
94538>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94541>>>            If (hTable > 0) Begin
94543>>>                Increment iRetval
94544>>>            End
94544>>>>
94544>>>        Until (hTable = 0)
94546>>>
94546>>>        Function_Return iRetval
94547>>>    End_Function
94548>>>
94548>>>    // Pass a table's logical name
94548>>>    // Returns True if the table exists in filelist.cfg.
94548>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
94550>>>        Handle hTable
94550>>>        Boolean bFound                           
94550>>>        String sCompareTable
94550>>>
94550>>>        Move False to bFound
94551>>>        Move 0 to hTable
94552>>>        Repeat
94552>>>>
94552>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94555>>>            If (hTable > 0) Begin
94557>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
94560>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
94562>>>                    Move True to bFound
94563>>>                End
94563>>>>
94563>>>            End
94563>>>>
94563>>>            If (bFound = True) Break
94566>>>        Until (hTable = 0)
94568>>>
94568>>>        Function_Return (bFound = True)
94569>>>    End_Function    
94570>>>    
94570>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
94572>>>        Boolean bOK bRecnum bToAnsi
94572>>>        Integer iCh                   
94572>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
94572>>>        
94572>>>        If (Trim(sDataPath) = "") Begin
94574>>>            Function_Return False
94575>>>        End
94575>>>>
94575>>>        
94575>>>        Move False to Err
94576>>>        Get psDriverID     to sDriverID
94577>>>        Get psConnectionID to sConnectionID
94578>>>        Get psSchema       to sSchemaName
94579>>>        Get True           to bRecnum
94580>>>        Get pbToANSI       to bToAnsi
94581>>>        Move CS_ANSI_Txt to sANSI_OEM
94582>>>        If (bToAnsi = False) Begin
94584>>>            Move CS_OEM_Txt to sANSI_OEM
94585>>>        End
94585>>>>
94585>>>        
94585>>>        Get vFolderFormat sDataPath to sDataPath
94586>>>        Move "CodeMast.int"         to sFileName
94587>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
94588>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
94591>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
94594>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
94597>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
94600>>>            Writeln channel iCh ("")
94603>>>            Writeln channel iCh ("RECNUM_TABLE YES")
94606>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
94609>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
94612>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
94615>>>            Writeln channel iCh ("")
94618>>>            Writeln channel iCh ("INDEX_NUMBER 1")
94621>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
94624>>>            Writeln channel iCh ("")
94627>>>        Send Seq_Close_Channel iCh
94628>>>        
94628>>>        Get vFolderFormat sDataPath to sDataPath
94629>>>        Move "CodeType.int"         to sFileName
94630>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
94631>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
94634>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
94637>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
94640>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
94643>>>            Writeln channel iCh ("")
94646>>>            Writeln channel iCh ("RECNUM_TABLE YES")
94649>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
94652>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
94655>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
94658>>>            Writeln channel iCh ("")
94661>>>            Writeln channel iCh ("INDEX_NUMBER 0")
94664>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
94667>>>            Writeln channel iCh ("")
94670>>>            Writeln channel iCh ("INDEX_NUMBER 1")
94673>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
94676>>>            Writeln channel iCh ("")
94679>>>        Send Seq_Close_Channel iCh
94680>>>    
94680>>>        Function_Return (Err = False)
94681>>>    End_Function
94682>>>
94682>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
94684>>>        String  sRetval sColumnName
94684>>>        String[] sOverlapFieldsArray
94685>>>        Integer iType iColumn iColumns
94685>>>        Boolean bOpen bOverlap
94685>>>
94685>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
94688>>>        If (bOpen = False) Begin
94690>>>            Open hTable
94692>>>        End
94692>>>>
94692>>>
94692>>>        Move "" to sRetval
94693>>>
94693>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
94696>>>
94696>>>        for iColumn from 0 to iColumns
94702>>>>
94702>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
94705>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
94707>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
94710>>>                If (bOverlap) Begin
94712>>>                    If (sRetval <> "") Begin
94714>>>                        Append sRetval ","
94715>>>                    End
94715>>>>
94715>>>                    Append sRetval iColumn
94716>>>                End
94716>>>>
94716>>>            End
94716>>>>
94716>>>        Loop
94717>>>>
94717>>>
94717>>>        If (bOpen = False) Begin
94719>>>            Close hTable
94720>>>        End
94720>>>>
94720>>>
94720>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
94721>>>
94721>>>        Function_Return sOverlapFieldsArray
94722>>>    End_Function
94723>>>
94723>>>    // Returns a struct array with all data types for the passed driver & dbtype.
94723>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
94725>>>        tColumnType[] ColumnType
94725>>>        tColumnType[] ColumnType
94726>>>
94726>>>        Case Begin
94726>>>            Case (iDbType = EN_dbTypeDataFlex)
94728>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
94729>>>                Case Break
94730>>>
94730>>>            Case (iDbType = EN_DbTypeDB2)
94733>>>                Get _UtilEnumerateDB2Types to ColumnType
94734>>>                Case Break
94735>>>
94735>>>            Case (iDbType = EN_DbTypeMSSQL)
94738>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
94739>>>                Case Break
94740>>>
94740>>>            Case (sDriverID = MDSMySQL)
94743>>>                Get _UtilEnumerateMySQLTypes to ColumnType
94744>>>                Case Break
94745>>>
94745>>>            Case (sDriverID = ORAFLEX)
94748>>>                Get _UtilEnumerateOracleTypes to ColumnType
94749>>>                Case Break
94750>>>
94750>>>            Case (sDriverID = MDSPgSQL)
94753>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
94754>>>                Case Break
94755>>>        Case End
94755>>>
94755>>>        Function_Return ColumnType
94756>>>    End_Function 
94757>>>    
94757>>>    Function UtilEnumerateMSSQLODBCDrivers Returns String
94759>>>        Handle hoRegistry hoODBCDriverNames
94759>>>        Boolean bExists bKeyOpened
94759>>>        String sKey
94759>>>        String[] sDrivers
94760>>>        Integer iDriverNames iDriverName
94760>>>        
94760>>>        Get Create (RefClass (cRegistry)) to hoRegistry
94761>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
94762>>>        Set pfAccessRights of hoRegistry to Key_Read
94763>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
94764>>>        Get KeyExists of hoRegistry sKey to bExists
94765>>>        If (bExists) Begin
94767>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
94768>>>            If (bKeyOpened) Begin
94770>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
94771>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
94772>>>                If (iDriverNames > 0) Begin
94774>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
94775>>>                    Decrement iDriverNames
94776>>>                    for iDriverName from 0 to iDriverNames
94782>>>>
94782>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
94783>>>                      Loop
94784>>>>
94784>>>                End
94784>>>>
94784>>>                Send CloseKey of hoRegistry
94785>>>            End
94785>>>>
94785>>>        End
94785>>>>
94785>>>        Send Destroy of hoRegistry
94786>>>        
94786>>>        Function_Return sDrivers
94787>>>    End_Function
94788>>>
94788>>>    // DataFlex Embedded Database Data Types:
94788>>>    // Helper function for UtilEnumerateColumnTypes
94788>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
94790>>>        tColumnType[] ColumnType
94790>>>        tColumnType[] ColumnType
94791>>>        Integer i
94791>>>
94791>>>        Move DF_ASCII           to ColumnType[i].iType
94792>>>        Move "ASCII"            to ColumnType[i].sType
94793>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
94794>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
94795>>>        Move "254"              to ColumnType[i].sPrecision
94796>>>        Increment i
94797>>>
94797>>>        Move DF_BCD             to ColumnType[i].iType
94798>>>        Move "Numeric"          to ColumnType[i].sType
94799>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94800>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
94801>>>        Move "14.8"             to ColumnType[i].sPrecision
94802>>>        Increment i
94803>>>
94803>>>        Move DF_DATE            to ColumnType[i].iType
94804>>>        Move "Date"             to ColumnType[i].sType
94805>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
94806>>>        Move "Date"             to ColumnType[i].sDataFlexType
94807>>>        Move "6.0"              to ColumnType[i].sPrecision
94808>>>        Move True               to ColumnType[i].bFixedSize
94809>>>        Increment i
94810>>>
94810>>>        Move DF_TEXT            to ColumnType[i].iType
94811>>>        Move "Text"             to ColumnType[i].sType
94812>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94813>>>        Move "Text"             to ColumnType[i].sDataFlexType
94814>>>        Move "16384"            to ColumnType[i].sPrecision
94815>>>        Increment i
94816>>>
94816>>>        Move DF_BINARY          to ColumnType[i].iType
94817>>>        Move "Binary"           to ColumnType[i].sType
94818>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
94819>>>        Move "Binary"           to ColumnType[i].sDataFlexType
94820>>>        Move "16384"            to ColumnType[i].sPrecision
94821>>>        Increment i
94822>>>
94822>>>        Move DF_DATETIME        to ColumnType[i].iType
94823>>>        Move "DateTime"         to ColumnType[i].sType
94824>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94825>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
94826>>>        Move "23"               to ColumnType[i].sPrecision
94827>>>        Move True               to ColumnType[i].bFixedSize
94828>>>        Increment i
94829>>>
94829>>>        Move DF_OVERLAP         to ColumnType[i].iType
94830>>>        Move "Overlap"          to ColumnType[i].sType
94831>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
94832>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
94833>>>        Move "0.0"              to ColumnType[i].sPrecision
94834>>>
94834>>>        Function_Return ColumnType
94835>>>    End_Function
94836>>>
94836>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
94838>>>        tColumnType[] ColumnType
94838>>>        tColumnType[] ColumnType
94839>>>        Integer i
94839>>>
94839>>>        Move SQL_DBCLOB         to ColumnType[i].iType
94840>>>        Move "DBCLOB"           to ColumnType[i].sType
94841>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94842>>>        Move "Text"             to ColumnType[i].sDataFlexType
94843>>>        Move "16384"            to ColumnType[i].sPrecision
94844>>>        Increment i
94845>>>
94845>>>        Move SQL_BIGINT         to ColumnType[i].iType
94846>>>        Move "BIGINT"           to ColumnType[i].sType
94847>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94848>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
94849>>>        Move "14.0"             to ColumnType[i].sPrecision
94850>>>        Increment i
94851>>>
94851>>>        Move SQL_BLOB           to ColumnType[i].iType
94852>>>        Move "BLOB"             to ColumnType[i].sType
94853>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
94854>>>        Move "BINARY"           to ColumnType[i].sDataFlexType
94855>>>        Move "16384"            to ColumnType[i].sPrecision
94856>>>        Increment i
94857>>>
94857>>>        Move SQL_CHAR           to ColumnType[i].iType
94858>>>        Move "CHAR"             to ColumnType[i].sType
94859>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
94860>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
94861>>>        Move "254"              to ColumnType[i].sPrecision
94862>>>        Increment i
94863>>>
94863>>>        // ToDo: We need to change the sType when using this!
94863>>>        Move SQL_CHARBIT            to ColumnType[i].iType
94864>>>        Move "CHAR FOR BIT DATA"    to ColumnType[i].sType
94865>>>        Move DF_BINARY              to ColumnType[i].iDataFlexType
94866>>>        Move "Binary"               to ColumnType[i].sDataFlexType
94867>>>        Move "254"                  to ColumnType[i].sPrecision
94868>>>        Increment i
94869>>>
94869>>>        Move SQL_DATE           to ColumnType[i].iType
94870>>>        Move "DATE"             to ColumnType[i].sType
94871>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
94872>>>        Move "Date"             to ColumnType[i].sDataFlexType
94873>>>        Move "6.0"              to ColumnType[i].sPrecision
94874>>>        Move True               to ColumnType[i].bFixedSize
94875>>>        Increment i
94876>>>
94876>>>        Move SQL_CLOB           to ColumnType[i].iType
94877>>>        Move "CLOB"             to ColumnType[i].sType
94878>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94879>>>        Move "Text"             to ColumnType[i].sDataFlexType
94880>>>        Move "16384"            to ColumnType[i].sPrecision
94881>>>        Increment i
94882>>>
94882>>>        Move SQL_DECIMAL        to ColumnType[i].iType
94883>>>        Move "DECIMAL"          to ColumnType[i].sType
94884>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94885>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
94886>>>        Move "14.8"             to ColumnType[i].sPrecision
94887>>>        Increment i
94888>>>
94888>>>        Move SQL_DOUBLE         to ColumnType[i].iType
94889>>>        Move "DOUBLE"           to ColumnType[i].sType
94890>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94891>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
94892>>>        Move "14.8"             to ColumnType[i].sPrecision
94893>>>        Increment i
94894>>>
94894>>>        Move SQL_FLOAT          to ColumnType[i].iType
94895>>>        Move "FLOAT"            to ColumnType[i].sType
94896>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94897>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
94898>>>        Move "14.8"             to ColumnType[i].sPrecision
94899>>>        Increment i
94900>>>
94900>>>        Move SQL_GRAPHIC        to ColumnType[i].iType
94901>>>        Move "GRAPHIC"          to ColumnType[i].sType
94902>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
94903>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
94904>>>        Move "255"              to ColumnType[i].sPrecision
94905>>>        Increment i
94906>>>
94906>>>        Move SQL_INTEGER        to ColumnType[i].iType
94907>>>        Move "INTEGER"          to ColumnType[i].sType
94908>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94909>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
94910>>>        Move "9.0"              to ColumnType[i].sPrecision
94911>>>        Increment i
94912>>>
94912>>>        Move SQL_LONGVARCHAR    to ColumnType[i].iType
94913>>>        Move "LONG VARCHAR"     to ColumnType[i].sType
94914>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94915>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
94916>>>        Move "32000"            to ColumnType[i].sPrecision
94917>>>        Increment i
94918>>>
94918>>>        Move SQL_LONGVARCHARBIT to ColumnType[i].iType
94919>>>        Move "LONG VARCHAR BIT" to ColumnType[i].sType
94920>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94921>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
94922>>>        Move "32000"            to ColumnType[i].sPrecision
94923>>>        Increment i
94924>>>
94924>>>        Move SQL_LONGVARGRAPHIC to ColumnType[i].iType
94925>>>        Move "LONG VARGRAPHIC"  to ColumnType[i].sType
94926>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94927>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
94928>>>        Move "32000"            to ColumnType[i].sPrecision
94929>>>        Increment i
94930>>>
94930>>>        Move SQL_NUMERIC        to ColumnType[i].iType
94931>>>        Move "NUMERIC"          to ColumnType[i].sType
94932>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94933>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
94934>>>        Move "14.8"             to ColumnType[i].sPrecision
94935>>>        Increment i
94936>>>
94936>>>        Move SQL_REAL           to ColumnType[i].iType
94937>>>        Move "REAL"             to ColumnType[i].sType
94938>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94939>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
94940>>>        Move "14.8"             to ColumnType[i].sPrecision
94941>>>        Increment i
94942>>>
94942>>>        Move SQL_SMALLINT       to ColumnType[i].iType
94943>>>        Move "SMALLINT"         to ColumnType[i].sType
94944>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
94945>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
94946>>>        Move "5.0"              to ColumnType[i].sPrecision
94947>>>        Increment i
94948>>>
94948>>>        Move SQL_TIME           to ColumnType[i].iType
94949>>>        Move "TIME"             to ColumnType[i].sType
94950>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
94951>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
94952>>>        Move "19.0"             to ColumnType[i].sPrecision
94953>>>        Move True               to ColumnType[i].bFixedSize
94954>>>        Increment i
94955>>>
94955>>>        Move SQL_TIMESTAMP      to ColumnType[i].iType
94956>>>        Move "TIMESTAMP"        to ColumnType[i].sType
94957>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94958>>>        Move "DATETIME"         to ColumnType[i].sDataFlexType
94959>>>        Move "23.6"             to ColumnType[i].sPrecision
94960>>>        Move True               to ColumnType[i].bFixedSize
94961>>>        Increment i
94962>>>
94962>>>        Move SQL_VARCHAR        to ColumnType[i].iType
94963>>>        Move "VARCHAR"          to ColumnType[i].sType
94964>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94965>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
94966>>>        Move "16384"            to ColumnType[i].sPrecision
94967>>>        Increment i
94968>>>
94968>>>        // ToDo: We need to change the sType when using this!
94968>>>        Move SQL_VARCHARBIT         to ColumnType[i].iType
94969>>>        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sType
94970>>>        Move DF_TEXT                to ColumnType[i].iDataFlexType
94971>>>        Move "TEXT"                 to ColumnType[i].sDataFlexType
94972>>>        Move "16384"                to ColumnType[i].sPrecision
94973>>>        Increment i
94974>>>
94974>>>        Move SQL_VARGRAPHIC     to ColumnType[i].iType
94975>>>        Move "VARGRAPHIC"       to ColumnType[i].sType
94976>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94977>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
94978>>>        Move "16384"            to ColumnType[i].sPrecision
94979>>>
94979>>>        Move SQL_XML            to ColumnType[i].iType
94980>>>        Move "XML"              to ColumnType[i].sType
94981>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
94982>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
94983>>>        Move "16384"            to ColumnType[i].sPrecision
94984>>>
94984>>>        Function_Return ColumnType
94985>>>    End_Function
94986>>>
94986>>>    // Microsoft SQL Server Database Data Types:
94986>>>    // Helper function for UtilEnumerateColumnTypes
94986>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
94988>>>        tColumnType[] ColumnType
94988>>>        tColumnType[] ColumnType
94989>>>        Integer i
94989>>>
94989>>>        If (sDriverID = MSSQLDRV_ID) Begin
94991>>>            Move SQL_BIGINT         to ColumnType[i].iType
94992>>>            Move "bigint"           to ColumnType[i].sType
94993>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
94994>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
94995>>>            Move "14.0"             to ColumnType[i].sPrecision
94996>>>            Move True               to ColumnType[i].bFixedSize
94997>>>            Increment i
94998>>>
94998>>>            Move SQL_BINARY         to ColumnType[i].iType
94999>>>            Move "binary"           to ColumnType[i].sType
95000>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
95001>>>            Move "Binary"           to ColumnType[i].sDataFlexType
95002>>>            Move "8000"             to ColumnType[i].sPrecision
95003>>>            Increment i
95004>>>
95004>>>            Move SQL_BIT            to ColumnType[i].iType
95005>>>            Move "bit"              to ColumnType[i].sType
95006>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
95007>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
95008>>>            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
95009>>>            Move True               to ColumnType[i].bFixedSize
95010>>>            Increment i
95011>>>
95011>>>            Move SQL_CHAR           to ColumnType[i].iType
95012>>>            Move "char"             to ColumnType[i].sType
95013>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95014>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95015>>>            Move "8000"             to ColumnType[i].sPrecision
95016>>>            Increment i
95017>>>
95017>>>            Move SQL_DATE           to ColumnType[i].iType
95018>>>            Move "date"             to ColumnType[i].sType
95019>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
95020>>>            Move "Date"             to ColumnType[i].sDataFlexType
95021>>>            Move "6.0"              to ColumnType[i].sPrecision
95022>>>            Move True               to ColumnType[i].bFixedSize
95023>>>            Increment i
95024>>>
95024>>>            Move SQL_DATETIME       to ColumnType[i].iType
95025>>>            Move "datetime"         to ColumnType[i].sType
95026>>>            Move DF_DATETIME        to ColumnType[i].iDataFlexType
95027>>>            Move "DateTime"         to ColumnType[i].sDataFlexType
95028>>>            Move "23.3"             to ColumnType[i].sPrecision
95029>>>            Move True               to ColumnType[i].bFixedSize
95030>>>            Increment i
95031>>>
95031>>>            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iType
95032>>>            Move "datetime2"         to ColumnType[i].sType
95033>>>            Move DF_DATETIME         to ColumnType[i].iDataFlexType
95034>>>            Move "DateTime"          to ColumnType[i].sDataFlexType
95035>>>            Move "23.6"              to ColumnType[i].sPrecision
95036>>>            Move True                to ColumnType[i].bFixedSize
95037>>>            Increment i
95038>>>
95038>>>            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iType
95039>>>            Move "datetimeoffset"       to ColumnType[i].sType
95040>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
95041>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
95042>>>            Move "34.0"                 to ColumnType[i].sPrecision
95043>>>            Move True                   to ColumnType[i].bFixedSize
95044>>>            Increment i
95045>>>
95045>>>            Move SQL_DECIMAL        to ColumnType[i].iType
95046>>>            Move "decimal"          to ColumnType[i].sType
95047>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95048>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95049>>>            Move "14.8"             to ColumnType[i].sPrecision
95050>>>            Increment i
95051>>>
95051>>>            Move SQL_FLOAT          to ColumnType[i].iType
95052>>>            Move "float"            to ColumnType[i].sType
95053>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95054>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95055>>>            Move "14.8"             to ColumnType[i].sPrecision
95056>>>            Increment i
95057>>>
95057>>>            Move SQL_INTEGER        to ColumnType[i].iType
95058>>>            Move "int"              to ColumnType[i].sType
95059>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95060>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95061>>>            Move "8.0"              to ColumnType[i].sPrecision
95062>>>            Move True               to ColumnType[i].bFixedSize
95063>>>            Increment i
95064>>>
95064>>>            Move SQL_TYPE_MONEY     to ColumnType[i].iType
95065>>>            Move "money"            to ColumnType[i].sType
95066>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95067>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95068>>>            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
95069>>>            Increment i
95070>>>
95070>>>            Move SQL_WCHAR          to ColumnType[i].iType
95071>>>            Move "nchar"            to ColumnType[i].sType
95072>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95073>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95074>>>            Move "4000"             to ColumnType[i].sPrecision
95075>>>            Increment i
95076>>>
95076>>>            Move SQL_WLONGVARCHAR   to ColumnType[i].iType
95077>>>            Move "ntext"            to ColumnType[i].sType
95078>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95079>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95080>>>            Move "16384"            to ColumnType[i].sPrecision
95081>>>            Increment i
95082>>>
95082>>>            Move SQL_NUMERIC        to ColumnType[i].iType
95083>>>            Move "numeric"          to ColumnType[i].sType
95084>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95085>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95086>>>            Move "14.8"             to ColumnType[i].sPrecision
95087>>>            Increment i
95088>>>
95088>>>            Move SQL_WVARCHAR       to ColumnType[i].iType
95089>>>            Move "nvarchar"         to ColumnType[i].sType
95090>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95091>>>            Move "Text"             to ColumnType[i].sDataFlexType
95092>>>            Move "4000"             to ColumnType[i].sPrecision
95093>>>            Increment i
95094>>>
95094>>>            Move SQL_VARCHARMAX     to ColumnType[i].iType
95095>>>            Move "nvarchar(max)"    to ColumnType[i].sType
95096>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95097>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95098>>>            Move "16384"            to ColumnType[i].sPrecision
95099>>>            Move True               to ColumnType[i].bFixedSize
95100>>>            Increment i
95101>>>
95101>>>            Move SQL_REAL           to ColumnType[i].iType
95102>>>            Move "real"             to ColumnType[i].sType
95103>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95104>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
95105>>>            Move "14.8"             to ColumnType[i].sPrecision
95106>>>            Increment i
95107>>>
95107>>>            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iType
95108>>>            Move "smalldatetime"        to ColumnType[i].sType
95109>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
95110>>>            Move "DATETIME"             to ColumnType[i].sDataFlexType
95111>>>            Move "23.0"                 to ColumnType[i].sPrecision
95112>>>            Move True                   to ColumnType[i].bFixedSize
95113>>>            Increment i
95114>>>
95114>>>            Move SQL_SMALLINT       to ColumnType[i].iType
95115>>>            Move "smallint"         to ColumnType[i].sType
95116>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95117>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
95118>>>            Move "4.0"              to ColumnType[i].sPrecision
95119>>>            Move True               to ColumnType[i].bFixedSize
95120>>>            Increment i
95121>>>
95121>>>            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iType
95122>>>            Move "smallmoney"        to ColumnType[i].sType
95123>>>            Move DF_BCD              to ColumnType[i].iDataFlexType
95124>>>            Move "NUMERIC"           to ColumnType[i].sDataFlexType
95125>>>            Move "10.0"              to ColumnType[i].sPrecision
95126>>>            Increment i
95127>>>
95127>>>            Move SQL_TEXT           to ColumnType[i].iType
95128>>>            Move "text"             to ColumnType[i].sType
95129>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95130>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95131>>>            Move "8000"             to ColumnType[i].sPrecision
95132>>>            Move True               to ColumnType[i].bFixedSize
95133>>>            Increment i
95134>>>
95134>>>            Move SQL_TIME           to ColumnType[i].iType
95135>>>            Move "time"             to ColumnType[i].sType
95136>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
95137>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
95138>>>            Move "19.0"             to ColumnType[i].sPrecision
95139>>>            Move True               to ColumnType[i].bFixedSize
95140>>>            Increment i
95141>>>
95141>>>            Move SQL_TINYINT        to ColumnType[i].iType
95142>>>            Move "tinyint"          to ColumnType[i].sType
95143>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95144>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
95145>>>            Move "2.0"              to ColumnType[i].sPrecision
95146>>>            Move True               to ColumnType[i].bFixedSize
95147>>>            Increment i
95148>>>
95148>>>            Move SQL_GUID           to ColumnType[i].iType
95149>>>            Move "uniqueidentifier" to ColumnType[i].sType
95150>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
95151>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
95152>>>            Move "36"               to ColumnType[i].sPrecision
95153>>>            Move True               to ColumnType[i].bFixedSize
95154>>>            Increment i
95155>>>
95155>>>            Move SQL_VARBINARY      to ColumnType[i].iType
95156>>>            Move "varbinary"        to ColumnType[i].sType
95157>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
95158>>>            Move "BINARY"           to ColumnType[i].sDataFlexType
95159>>>            Move "16384"            to ColumnType[i].sPrecision
95160>>>            Increment i
95161>>>
95161>>>            Move SQL_LONGVARBINARY  to ColumnType[i].iType
95162>>>            Move "varbinary(max)"   to ColumnType[i].sType
95163>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
95164>>>            Move "BINARY"           to ColumnType[i].sDataFlexType
95165>>>            Move "16384"            to ColumnType[i].sPrecision
95166>>>            Move True               to ColumnType[i].bFixedSize
95167>>>            Increment i
95168>>>
95168>>>            Move SQL_VARCHAR        to ColumnType[i].iType
95169>>>            Move "varchar"          to ColumnType[i].sType
95170>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
95171>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95172>>>            Move "8000"             to ColumnType[i].sPrecision
95173>>>            Increment i
95174>>>
95174>>>            Move SQL_LONGVARCHAR    to ColumnType[i].iType
95175>>>            Move "varchar(max)"     to ColumnType[i].sType
95176>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95177>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95178>>>            Move "16384"            to ColumnType[i].sPrecision
95179>>>            Move True               to ColumnType[i].bFixedSize
95180>>>            Increment i
95181>>>
95181>>>            Move SQL_SS_XML         to ColumnType[i].iType
95182>>>            Move "xml"              to ColumnType[i].sType
95183>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95184>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95185>>>            Move "16384"            to ColumnType[i].sPrecision
95186>>>            Increment i
95187>>>
95187>>>            Move SQL_TYPE_DATE      to ColumnType[i].iType
95188>>>            Move "DATE"             to ColumnType[i].sType
95189>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
95190>>>            Move "date"             to ColumnType[i].sDataFlexType
95191>>>            Move "6.0"              to ColumnType[i].sPrecision
95192>>>            Move True               to ColumnType[i].bFixedSize
95193>>>            Increment i
95194>>>
95194>>>            Move SQL_TYPE_TIME      to ColumnType[i].iType
95195>>>            Move "time"             to ColumnType[i].sType
95196>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
95197>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
95198>>>            Move "8.7"              to ColumnType[i].sPrecision
95199>>>            Move True               to ColumnType[i].bFixedSize
95200>>>            Increment i
95201>>>
95201>>>            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iType
95202>>>            Move "datetime"         to ColumnType[i].sType
95203>>>            Move DF_DATETIME        to ColumnType[i].iDataFlexType
95204>>>            Move "DateTime"         to ColumnType[i].sDataFlexType
95205>>>            Move "23.6"             to ColumnType[i].sPrecision
95206>>>            Move True               to ColumnType[i].bFixedSize
95207>>>            Increment i
95208>>>
95208>>>        End
95208>>>>
95208>>>
95208>>>        // Mertech SQLFlex driver
95208>>>        If (sDriverID = SQLFLEX) Begin
95210>>>            Move eSQLServer_BIGINT  to ColumnType[i].iType
95211>>>            Move "BigInt"           to ColumnType[i].sType
95212>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95213>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95214>>>            Move "14.0"             to ColumnType[i].sPrecision
95215>>>            Move True               to ColumnType[i].bFixedSize
95216>>>            Increment i
95217>>>
95217>>>            Move eSQLServer_BINARY  to ColumnType[i].iType
95218>>>            Move "Binary"           to ColumnType[i].sType
95219>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
95220>>>            Move "Binary"           to ColumnType[i].sDataFlexType
95221>>>            Move "8000"             to ColumnType[i].sPrecision
95222>>>            Increment i
95223>>>
95223>>>            Move eSQLServer_BIT     to ColumnType[i].iType
95224>>>            Move "Bit"              to ColumnType[i].sType
95225>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
95226>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
95227>>>            Move "1.0"              to ColumnType[i].sPrecision
95228>>>            Move True               to ColumnType[i].bFixedSize // In SQL allows 1, 0, or "NULL"
95229>>>            Increment i
95230>>>
95230>>>            Move eSQLServer_CHAR    to ColumnType[i].iType
95231>>>            Move "Char"             to ColumnType[i].sType
95232>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95233>>>            Move "Text"             to ColumnType[i].sDataFlexType
95234>>>            Move "8000"             to ColumnType[i].sPrecision
95235>>>            Increment i
95236>>>
95236>>>            Move eSQLServer_DATE    to ColumnType[i].iType
95237>>>            Move "Date"             to ColumnType[i].sType
95238>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
95239>>>            Move "Date"             to ColumnType[i].sDataFlexType
95240>>>            Move "6.0"              to ColumnType[i].sPrecision
95241>>>            Move True               to ColumnType[i].bFixedSize
95242>>>            Increment i
95243>>>
95243>>>            Move eSQLServer_DATETIME    to ColumnType[i].iType
95244>>>            Move "DateTime"             to ColumnType[i].sType
95245>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
95246>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
95247>>>            Move "23.3"                 to ColumnType[i].sPrecision
95248>>>            Move True                   to ColumnType[i].bFixedSize
95249>>>            Increment i
95250>>>
95250>>>            Move eSQLServer_DATETIME2   to ColumnType[i].iType
95251>>>            Move "DateTime2"            to ColumnType[i].sType
95252>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
95253>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
95254>>>            Move "23.6"                 to ColumnType[i].sPrecision
95255>>>            Move True                   to ColumnType[i].bFixedSize
95256>>>            Increment i
95257>>>
95257>>>            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iType
95258>>>            Move "DateTimeOffest"           to ColumnType[i].sType
95259>>>            Move DF_DATETIME                to ColumnType[i].iDataFlexType
95260>>>            Move "DateTime"                 to ColumnType[i].sDataFlexType
95261>>>            Move "23.0"                     to ColumnType[i].sPrecision
95262>>>            Move True                       to ColumnType[i].bFixedSize
95263>>>            Increment i
95264>>>
95264>>>            Move eSQLServer_DECIMAL to ColumnType[i].iType
95265>>>            Move "Decimal"          to ColumnType[i].sType
95266>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95267>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95268>>>            Move "14.8"             to ColumnType[i].sPrecision
95269>>>            Increment i
95270>>>
95270>>>            Move eSQLServer_DOUBLE  to ColumnType[i].iType
95271>>>            Move "Double"           to ColumnType[i].sType
95272>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95273>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95274>>>            Move "14.8"             to ColumnType[i].sPrecision
95275>>>            Increment i
95276>>>
95276>>>            Move eSQLServer_FLOAT   to ColumnType[i].iType
95277>>>            Move "Float"            to ColumnType[i].sType
95278>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95279>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95280>>>            Move "14.8"             to ColumnType[i].sPrecision
95281>>>            Increment i
95282>>>
95282>>>            Move eSQLServer_INT     to ColumnType[i].iType
95283>>>            Move "Int"              to ColumnType[i].sType
95284>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95285>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95286>>>            Move "11.0"             to ColumnType[i].sPrecision
95287>>>            Increment i
95288>>>
95288>>>            Move eSQLServer_NCHAR   to ColumnType[i].iType
95289>>>            Move "Nchar"            to ColumnType[i].sType
95290>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95291>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95292>>>            Move "4000"             to ColumnType[i].sPrecision
95293>>>            Increment i
95294>>>
95294>>>            Move eSQLServer_NTEXT   to ColumnType[i].iType
95295>>>            Move "Ntext"            to ColumnType[i].sType
95296>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95297>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95298>>>            Move "16384"            to ColumnType[i].sPrecision
95299>>>            Increment i
95300>>>
95300>>>            Move eSQLServer_NUMERIC to ColumnType[i].iType
95301>>>            Move "Numeric"          to ColumnType[i].sType
95302>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95303>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95304>>>            Move "14.8"             to ColumnType[i].sPrecision
95305>>>            Increment i
95306>>>
95306>>>            Move eSQLServer_NVARCHAR    to ColumnType[i].iType
95307>>>            Move "NvarChar"             to ColumnType[i].sType
95308>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
95309>>>            Move "Text"                 to ColumnType[i].sDataFlexType
95310>>>            Move "4000"                 to ColumnType[i].sPrecision
95311>>>            Increment i
95312>>>
95312>>>            Move eSQLServer_NVARCHARMAX to ColumnType[i].iType
95313>>>            Move "NvarCharMax"          to ColumnType[i].sType
95314>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
95315>>>            Move "Text"                 to ColumnType[i].sDataFlexType
95316>>>            Move "16384"                to ColumnType[i].sPrecision
95317>>>            Move True                   to ColumnType[i].bFixedSize
95318>>>            Increment i
95319>>>
95319>>>            Move eSQLServer_REAL    to ColumnType[i].iType
95320>>>            Move "Real"             to ColumnType[i].sType
95321>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95322>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
95323>>>            Move "14.8"             to ColumnType[i].sPrecision
95324>>>            Increment i
95325>>>
95325>>>            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iType
95326>>>            Move "SmallDateTime"            to ColumnType[i].sType
95327>>>            Move DF_DATETIME                to ColumnType[i].iDataFlexType
95328>>>            Move "DATETIME"                 to ColumnType[i].sDataFlexType
95329>>>            Move "23.0"                     to ColumnType[i].sPrecision
95330>>>            Move True                       to ColumnType[i].bFixedSize
95331>>>            Increment i
95332>>>
95332>>>            Move eSQLServer_SMALLINT    to ColumnType[i].iType
95333>>>            Move "SmallInt"             to ColumnType[i].sType
95334>>>            Move DF_BCD                 to ColumnType[i].iDataFlexType
95335>>>            Move "NUMERIC"              to ColumnType[i].sDataFlexType
95336>>>            Move "6.0"                  to ColumnType[i].sPrecision
95337>>>            Increment i
95338>>>
95338>>>            Move eSQLServer_TEXT    to ColumnType[i].iType
95339>>>            Move "Text"             to ColumnType[i].sType
95340>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95341>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95342>>>            Move "8000"             to ColumnType[i].sPrecision
95343>>>            Move True               to ColumnType[i].bFixedSize
95344>>>            Increment i
95345>>>
95345>>>            Move eSQLServer_TIME    to ColumnType[i].iType
95346>>>            Move "Time"             to ColumnType[i].sType
95347>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
95348>>>            Move "Date"             to ColumnType[i].sDataFlexType
95349>>>            Move "16.0"             to ColumnType[i].sPrecision
95350>>>            Move True               to ColumnType[i].bFixedSize
95351>>>            Increment i
95352>>>
95352>>>            Move eSQLServer_TIMESTAMP   to ColumnType[i].iType
95353>>>            Move "TimeStamp"            to ColumnType[i].sType
95354>>>            Move DF_ASCII               to ColumnType[i].iDataFlexType
95355>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
95356>>>            Move "8.0"                  to ColumnType[i].sPrecision
95357>>>            Move True                   to ColumnType[i].bFixedSize
95358>>>            Increment i
95359>>>
95359>>>            Move eSQLServer_TINYINT to ColumnType[i].iType
95360>>>            Move "TinyInt"          to ColumnType[i].sType
95361>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
95362>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
95363>>>            Move "3.0"              to ColumnType[i].sPrecision
95364>>>            Increment i
95365>>>
95365>>>            Move eSQLServer_GUID    to ColumnType[i].iType
95366>>>            Move "UniqueIdentifier" to ColumnType[i].sType
95367>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
95368>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
95369>>>            Move "38"               to ColumnType[i].sPrecision
95370>>>            Move True               to ColumnType[i].bFixedSize
95371>>>            Increment i
95372>>>
95372>>>            Move eSQLServer_VARBINARY   to ColumnType[i].iType
95373>>>            Move "VarBinary"            to ColumnType[i].sType
95374>>>            Move DF_BINARY              to ColumnType[i].iDataFlexType
95375>>>            Move "BINARY"               to ColumnType[i].sDataFlexType
95376>>>            Move "8000"                 to ColumnType[i].sPrecision
95377>>>            Increment i
95378>>>
95378>>>            Move eSQLServer_VARBINARYMAX to ColumnType[i].iType
95379>>>            Move "VarBinary(Max)"        to ColumnType[i].sType
95380>>>            Move DF_BINARY               to ColumnType[i].iDataFlexType
95381>>>            Move "BINARY"                to ColumnType[i].sDataFlexType
95382>>>            Move "16384"                 to ColumnType[i].sPrecision
95383>>>            Move True                    to ColumnType[i].bFixedSize
95384>>>            Increment i
95385>>>
95385>>>            Move eSQLServer_VARCHAR to ColumnType[i].iType
95386>>>            Move "VarChar"          to ColumnType[i].sType
95387>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
95388>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95389>>>            Move "8000"             to ColumnType[i].sPrecision
95390>>>            Increment i
95391>>>
95391>>>            Move eSQLServer_VARCHARMAX  to ColumnType[i].iType
95392>>>            Move "VarChar(Max)"         to ColumnType[i].sType
95393>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
95394>>>            Move "TEXT"                 to ColumnType[i].sDataFlexType
95395>>>            Move "16384"                to ColumnType[i].sPrecision
95396>>>            Move True                   to ColumnType[i].bFixedSize
95397>>>            Increment i
95398>>>
95398>>>            Move eSQLServer_SQLVARIANT  to ColumnType[i].iType
95399>>>            Move "SQL_Variant"          to ColumnType[i].sType
95400>>>            Move DF_BINARY              to ColumnType[i].iDataFlexType
95401>>>            Move "Binary"               to ColumnType[i].sDataFlexType
95402>>>            Move "8016"                 to ColumnType[i].sPrecision
95403>>>            Move True                   to ColumnType[i].bFixedSize
95404>>>            Increment i
95405>>>
95405>>>            Move eSQLServer_XML     to ColumnType[i].iType
95406>>>            Move "XML"              to ColumnType[i].sType
95407>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
95408>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
95409>>>            Move "16384"            to ColumnType[i].sPrecision
95410>>>        End
95410>>>>
95410>>>
95410>>>        Function_Return ColumnType
95411>>>    End_Function
95412>>>
95412>>>    // MySQL Data Types
95412>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
95414>>>        tColumnType[] ColumnType
95414>>>        tColumnType[] ColumnType
95415>>>        Integer i
95415>>>
95415>>>        Move eMySQL_LONGLONG    to ColumnType[i].iType
95416>>>        Move "bigint"           to ColumnType[i].sType
95417>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95418>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95419>>>        Move "14.0"             to ColumnType[i].sPrecision
95420>>>        Increment i
95421>>>
95421>>>        Move eMySQL_BIT         to ColumnType[i].iType
95422>>>        Move "bit"              to ColumnType[i].sType
95423>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95424>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95425>>>        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
95426>>>        Move True               to ColumnType[i].bFixedSize
95427>>>        Increment i
95428>>>
95428>>>        Move eMySQL_BLOB        to ColumnType[i].iType
95429>>>        Move "blob"             to ColumnType[i].sType
95430>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95431>>>        Move "BINARY"           to ColumnType[i].sDataFlexType
95432>>>        Move "16384"            to ColumnType[i].sPrecision
95433>>>        Increment i
95434>>>
95434>>>        Move eMySQL_STRING      to ColumnType[i].iType
95435>>>        Move "char"             to ColumnType[i].sType
95436>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95437>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
95438>>>        Move "254"              to ColumnType[i].sPrecision
95439>>>        Increment i
95440>>>
95440>>>        Move eMySQL_DATE        to ColumnType[i].iType
95441>>>        Move "date"             to ColumnType[i].sType
95442>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
95443>>>        Move "Date"             to ColumnType[i].sDataFlexType
95444>>>        Move "6.0"              to ColumnType[i].sPrecision
95445>>>        Move True               to ColumnType[i].bFixedSize
95446>>>        Increment i
95447>>>
95447>>>        Move eMySQL_DATETIME    to ColumnType[i].iType
95448>>>        Move "datetime"         to ColumnType[i].sType
95449>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
95450>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
95451>>>        Move "23.0"             to ColumnType[i].sPrecision
95452>>>        Move True               to ColumnType[i].bFixedSize
95453>>>        Increment i
95454>>>
95454>>>        Move eMySQL_DECIMAL     to ColumnType[i].iType
95455>>>        Move "decimal"          to ColumnType[i].sType
95456>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95457>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95458>>>        Move "14.8"             to ColumnType[i].sPrecision
95459>>>        Increment i
95460>>>
95460>>>        Move eMySQL_DOUBLE      to ColumnType[i].iType
95461>>>        Move "double"           to ColumnType[i].sType
95462>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95463>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95464>>>        Move "14.8"             to ColumnType[i].sPrecision
95465>>>        Increment i
95466>>>
95466>>>        Move eMySQL_ENUM        to ColumnType[i].iType
95467>>>        Move "enum"             to ColumnType[i].sType
95468>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95469>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95470>>>        Move "254"              to ColumnType[i].sPrecision
95471>>>        Increment i
95472>>>
95472>>>        Move eMySQL_FLOAT       to ColumnType[i].iType
95473>>>        Move "float"            to ColumnType[i].sType
95474>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95475>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95476>>>        Move "14.8"             to ColumnType[i].sPrecision
95477>>>        Increment i
95478>>>
95478>>>        Move eMySQL_INT24       to ColumnType[i].iType
95479>>>        Move "int"              to ColumnType[i].sType
95480>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95481>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
95482>>>        Move "11.0"             to ColumnType[i].sPrecision
95483>>>        Increment i
95484>>>
95484>>>        Move eMySQL_LONG_BLOB   to ColumnType[i].iType
95485>>>        Move "longblob"         to ColumnType[i].sType
95486>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95487>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95488>>>        Move "16384"            to ColumnType[i].sPrecision
95489>>>        Increment i
95490>>>
95490>>>        Move eMySQL_LONG_TEXT   to ColumnType[i].iType
95491>>>        Move "longtext"         to ColumnType[i].sType
95492>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95493>>>        Move "Text"             to ColumnType[i].sDataFlexType
95494>>>        Move "16384"            to ColumnType[i].sPrecision
95495>>>        Increment i
95496>>>
95496>>>        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iType
95497>>>        Move "mediumblob"       to ColumnType[i].sType
95498>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95499>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95500>>>        Move "16384"            to ColumnType[i].sPrecision
95501>>>        Increment i
95502>>>
95502>>>        Move eMySQL_INT24       to ColumnType[i].iType
95503>>>        Move "mediumint"        to ColumnType[i].sType
95504>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95505>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95506>>>        Move "9.0"              to ColumnType[i].sPrecision
95507>>>
95507>>>        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iType
95508>>>        Move "mediumtext"       to ColumnType[i].sType
95509>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95510>>>        Move "Text"             to ColumnType[i].sDataFlexType
95511>>>        Move "16384"            to ColumnType[i].sPrecision
95512>>>        Increment i
95513>>>
95513>>>        Move eMySQL_SET         to ColumnType[i].iType
95514>>>        Move "set"              to ColumnType[i].sType
95515>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95516>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95517>>>        Move "254"              to ColumnType[i].sPrecision
95518>>>        Increment i
95519>>>
95519>>>        Move eMySQL_SHORT       to ColumnType[i].iType
95520>>>        Move "smallint"         to ColumnType[i].sType
95521>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95522>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95523>>>        Move "6.0"              to ColumnType[i].sPrecision
95524>>>        Increment i
95525>>>
95525>>>        Move eMySQL_TEXT        to ColumnType[i].iType
95526>>>        Move "text"             to ColumnType[i].sType
95527>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95528>>>        Move "Text"             to ColumnType[i].sDataFlexType
95529>>>        Move "16384"            to ColumnType[i].sPrecision
95530>>>        Increment i
95531>>>
95531>>>        Move eMySQL_TIME        to ColumnType[i].iType
95532>>>        Move "time"             to ColumnType[i].sType
95533>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95534>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95535>>>        Move "10.0"             to ColumnType[i].sPrecision
95536>>>        Move True               to ColumnType[i].bFixedSize
95537>>>        Increment i
95538>>>
95538>>>        Move eMySQL_TIMESTAMP   to ColumnType[i].iType
95539>>>        Move "timestamp"        to ColumnType[i].sType
95540>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
95541>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
95542>>>        Move "23.0"             to ColumnType[i].sPrecision
95543>>>        Move True               to ColumnType[i].bFixedSize
95544>>>        Increment i
95545>>>
95545>>>        Move eMySQL_TINY_BLOB   to ColumnType[i].iType
95546>>>        Move "tinyblob"         to ColumnType[i].sType
95547>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95548>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95549>>>        Move "254"              to ColumnType[i].sPrecision
95550>>>        Increment i
95551>>>
95551>>>        Move eMySQL_TINY        to ColumnType[i].iType
95552>>>        Move "tinyint"          to ColumnType[i].sType
95553>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95554>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95555>>>        Move "4.0"              to ColumnType[i].sPrecision
95556>>>        Increment i
95557>>>
95557>>>        Move eMySQL_TINY_TEXT   to ColumnType[i].iType
95558>>>        Move "tinytext"         to ColumnType[i].sType
95559>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95560>>>        Move "Text"             to ColumnType[i].sDataFlexType
95561>>>        Move "254"              to ColumnType[i].sPrecision
95562>>>        Increment i
95563>>>
95563>>>        Move eMySQL_VAR_STRING  to ColumnType[i].iType
95564>>>        Move "varchar"          to ColumnType[i].sType
95565>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95566>>>        Move "Text"             to ColumnType[i].sDataFlexType
95567>>>        Move "16384"            to ColumnType[i].sPrecision
95568>>>        Increment i
95569>>>
95569>>>        Move eMySQL_YEAR        to ColumnType[i].iType
95570>>>        Move "year"             to ColumnType[i].sType
95571>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95572>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
95573>>>        Move "4.0"              to ColumnType[i].sPrecision
95574>>>        Move True               to ColumnType[i].bFixedSize
95575>>>        Increment i
95576>>>
95576>>>        Function_Return ColumnType
95577>>>    End_Function
95578>>>
95578>>>    // Oracle Data Types
95578>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
95580>>>        tColumnType[] ColumnType
95580>>>        tColumnType[] ColumnType
95581>>>        Integer i
95581>>>
95581>>>        Move eOracle_BLOB       to ColumnType[i].iType
95582>>>        Move "BLOB"             to ColumnType[i].sType
95583>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95584>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95585>>>        Move "16384"            to ColumnType[i].sPrecision
95586>>>        Increment i
95587>>>
95587>>>        Move eOracle_CHAR       to ColumnType[i].iType
95588>>>        Move "CHAR"             to ColumnType[i].sType
95589>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95590>>>        Move "Text"             to ColumnType[i].sDataFlexType
95591>>>        Move "2000"             to ColumnType[i].sPrecision
95592>>>        Increment i
95593>>>
95593>>>        Move eOracle_CLOB       to ColumnType[i].iType
95594>>>        Move "CLOB"             to ColumnType[i].sType
95595>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95596>>>        Move "Text"             to ColumnType[i].sDataFlexType
95597>>>        Move "16384"            to ColumnType[i].sPrecision
95598>>>        Increment i
95599>>>
95599>>>        Move eOracle_DATE       to ColumnType[i].iType
95600>>>        Move "DATE"             to ColumnType[i].sType
95601>>>        Move DF_Date            to ColumnType[i].iDataFlexType
95602>>>        Move "Date"             to ColumnType[i].sDataFlexType
95603>>>        Move "6.0"              to ColumnType[i].sPrecision
95604>>>        Move True               to ColumnType[i].bFixedSize
95605>>>        Increment i
95606>>>
95606>>>        Move eOracle_FLOAT      to ColumnType[i].iType
95607>>>        Move "FLOAT"            to ColumnType[i].sType
95608>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95609>>>        Move "Number"           to ColumnType[i].sDataFlexType
95610>>>        Move "14.8"             to ColumnType[i].sPrecision
95611>>>        Increment i
95612>>>
95612>>>        Move eOracle_INT        to ColumnType[i].iType
95613>>>        Move "INT"              to ColumnType[i].sType
95614>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95615>>>        Move "Number"           to ColumnType[i].sDataFlexType
95616>>>        Move "14.0"             to ColumnType[i].sPrecision
95617>>>        Increment i
95618>>>
95618>>>        Move eOracle_INTERVALDS to ColumnType[i].iType
95619>>>        Move "INTERVALDAYTOSEC" to ColumnType[i].sType
95620>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
95621>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
95622>>>        Move "23.0"             to ColumnType[i].sPrecision
95623>>>        Move True               to ColumnType[i].bFixedSize
95624>>>        Increment i
95625>>>
95625>>>        Move eOracle_INTERVALYM  to ColumnType[i].iType
95626>>>        Move "INTERVALYEARTOMON" to ColumnType[i].sType
95627>>>        Move DF_DATETIME         to ColumnType[i].iDataFlexType
95628>>>        Move "DateTime"          to ColumnType[i].sDataFlexType
95629>>>        Move "23.0"              to ColumnType[i].sPrecision
95630>>>        Move True                to ColumnType[i].bFixedSize
95631>>>        Increment i
95632>>>
95632>>>        Move eOracle_RAW        to ColumnType[i].iType
95633>>>        Move "LONG"             to ColumnType[i].sType
95634>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95635>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95636>>>        Move "16384"            to ColumnType[i].sPrecision
95637>>>        Increment i
95638>>>
95638>>>        Move eOracle_LONGRAW    to ColumnType[i].iType
95639>>>        Move "LONG RAW"         to ColumnType[i].sType
95640>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95641>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95642>>>        Move "16384"            to ColumnType[i].sPrecision
95643>>>        Increment i
95644>>>
95644>>>        Move eOracle_NCHAR      to ColumnType[i].iType
95645>>>        Move "NCHAR"            to ColumnType[i].sType
95646>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95647>>>        Move "Text"             to ColumnType[i].sDataFlexType
95648>>>        Move "2000"             to ColumnType[i].sPrecision
95649>>>        Increment i
95650>>>
95650>>>        Move eOracle_NCLOB      to ColumnType[i].iType
95651>>>        Move "NCLOB"            to ColumnType[i].sType
95652>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95653>>>        Move "Text"             to ColumnType[i].sDataFlexType
95654>>>        Move "16384"            to ColumnType[i].sPrecision
95655>>>        Increment i
95656>>>
95656>>>        Move eOracle_NUMBER     to ColumnType[i].iType
95657>>>        Move "NUMBER"           to ColumnType[i].sType
95658>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95659>>>        Move "Number"           to ColumnType[i].sDataFlexType
95660>>>        Move "14.8"             to ColumnType[i].sPrecision
95661>>>        Increment i
95662>>>
95662>>>        Move eOracle_NVARCHAR2  to ColumnType[i].iType
95663>>>        Move "NVARCHAR2"        to ColumnType[i].sType
95664>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95665>>>        Move "Text"             to ColumnType[i].sDataFlexType
95666>>>        Move "4000"             to ColumnType[i].sPrecision
95667>>>        Increment i
95668>>>
95668>>>        Move eOracle_RAW        to ColumnType[i].iType
95669>>>        Move "RAW"              to ColumnType[i].sType
95670>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95671>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95672>>>        Move "2000"             to ColumnType[i].sPrecision
95673>>>        Increment i
95674>>>
95674>>>        Move eOracle_ROWID      to ColumnType[i].iType
95675>>>        Move "ROWID"            to ColumnType[i].sType
95676>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95677>>>        Move "Text"             to ColumnType[i].sDataFlexType
95678>>>        Move "16384"            to ColumnType[i].sPrecision
95679>>>        Increment i
95680>>>
95680>>>        Move eOracle_TIMESTAMP  to ColumnType[i].iType
95681>>>        Move "TimeStamp"        to ColumnType[i].sType
95682>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
95683>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
95684>>>        Move "11.0"             to ColumnType[i].sPrecision
95685>>>        Move True               to ColumnType[i].bFixedSize
95686>>>        Increment i
95687>>>
95687>>>        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iType
95688>>>        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sType
95689>>>        Move DF_DATETIME            to ColumnType[i].iDataFlexType
95690>>>        Move "DateTime"             to ColumnType[i].sDataFlexType
95691>>>        Move "13.0"                 to ColumnType[i].sPrecision
95692>>>        Move True                   to ColumnType[i].bFixedSize
95693>>>        Increment i
95694>>>
95694>>>        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iType
95695>>>        Move "TIMEZONETIMEZONE"     to ColumnType[i].sType
95696>>>        Move DF_DATETIME            to ColumnType[i].iDataFlexType
95697>>>        Move "DateTime"             to ColumnType[i].sDataFlexType
95698>>>        Move "11.0"                 to ColumnType[i].sPrecision
95699>>>        Move True                   to ColumnType[i].bFixedSize
95700>>>        Increment i
95701>>>
95701>>>        Move eOracle_VARCHAR2   to ColumnType[i].iType
95702>>>        Move "VARCHAR"          to ColumnType[i].sType
95703>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95704>>>        Move "Text"             to ColumnType[i].sDataFlexType
95705>>>        Move "16384"            to ColumnType[i].sPrecision
95706>>>
95706>>>        Function_Return ColumnType
95707>>>    End_Function
95708>>>
95708>>>    // PostgreSQL Data Types
95708>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
95710>>>        tColumnType[] ColumnType
95710>>>        tColumnType[] ColumnType
95711>>>        Integer i
95711>>>
95711>>>        Move ePgSQL_INT8        to ColumnType[i].iType
95712>>>        Move "bigint"           to ColumnType[i].sType
95713>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95714>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95715>>>        Move "14.0"             to ColumnType[i].sPrecision
95716>>>        Move True               to ColumnType[i].bFixedSize
95717>>>        Increment i
95718>>>
95718>>>        Move ePgSQL_BIT         to ColumnType[i].iType
95719>>>        Move "bit"              to ColumnType[i].sType
95720>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95721>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95722>>>        Move "16384"            to ColumnType[i].sPrecision
95723>>>        Increment i
95724>>>
95724>>>        Move ePgSQL_BOOL        to ColumnType[i].iType
95725>>>        Move "boolean"          to ColumnType[i].sType
95726>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95727>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95728>>>        Move "1"                to ColumnType[i].sPrecision
95729>>>        Increment i
95730>>>
95730>>>        Move ePgSQL_BYTEA       to ColumnType[i].iType
95731>>>        Move "bytea"            to ColumnType[i].sType
95732>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95733>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95734>>>        Move "16384"            to ColumnType[i].sPrecision
95735>>>        Increment i
95736>>>
95736>>>        Move ePgSQL_CHAR        to ColumnType[i].iType
95737>>>        Move "char"             to ColumnType[i].sType
95738>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95739>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95740>>>        Move "2000"             to ColumnType[i].sPrecision
95741>>>        Increment i
95742>>>
95742>>>        Move ePgSQL_CITEXT      to ColumnType[i].iType
95743>>>        Move "citext"           to ColumnType[i].sType
95744>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95745>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95746>>>        Move "254"              to ColumnType[i].sPrecision
95747>>>        Increment i
95748>>>
95748>>>        Move ePgSQL_DATE        to ColumnType[i].iType
95749>>>        Move "date"             to ColumnType[i].sType
95750>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
95751>>>        Move "Date"             to ColumnType[i].sDataFlexType
95752>>>        Move "6.0"              to ColumnType[i].sPrecision
95753>>>        Move True               to ColumnType[i].bFixedSize
95754>>>        Increment i
95755>>>
95755>>>        Move ePgSQL_FLOAT4      to ColumnType[i].iType
95756>>>        Move "decimal"          to ColumnType[i].sType
95757>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95758>>>        Move "Decimal"          to ColumnType[i].sDataFlexType
95759>>>        Move "14.8"             to ColumnType[i].sPrecision
95760>>>        Increment i
95761>>>
95761>>>        Move ePgSQL_FLOAT8      to ColumnType[i].iType
95762>>>        Move "double"           to ColumnType[i].sType
95763>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95764>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95765>>>        Move "22"               to ColumnType[i].sPrecision
95766>>>        Increment i
95767>>>
95767>>>        Move ePgSQL_INT4        to ColumnType[i].iType
95768>>>        Move "integer"          to ColumnType[i].sType
95769>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95770>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95771>>>        Move "8.0"              to ColumnType[i].sPrecision
95772>>>        Increment i
95773>>>
95773>>>        Move ePgSQL_MONEY       to ColumnType[i].iType
95774>>>        Move "money"            to ColumnType[i].sType
95775>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95776>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95777>>>        Move "8.0"              to ColumnType[i].sPrecision
95778>>>        Increment i
95779>>>
95779>>>        Move ePgSQL_OID         to ColumnType[i].iType
95780>>>        Move "oid"              to ColumnType[i].sType
95781>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
95782>>>        Move "Binary"           to ColumnType[i].sDataFlexType
95783>>>        Move "16384"            to ColumnType[i].sPrecision
95784>>>        Increment i
95785>>>
95785>>>        Move ePgSQL_FLOAT4      to ColumnType[i].iType
95786>>>        Move "real"             to ColumnType[i].sType
95787>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95788>>>        Move "Real"             to ColumnType[i].sDataFlexType
95789>>>        Move "6.6"              to ColumnType[i].sPrecision
95790>>>        Increment i
95791>>>
95791>>>        Move ePgSQL_REGPROC     to ColumnType[i].iType
95792>>>        Move "regproc"          to ColumnType[i].sType
95793>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95794>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95795>>>        Move "64"               to ColumnType[i].sPrecision
95796>>>        Increment i
95797>>>
95797>>>        Move ePgSQL_INT2        to ColumnType[i].iType
95798>>>        Move "smallint"         to ColumnType[i].sType
95799>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
95800>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
95801>>>        Move "6.0"              to ColumnType[i].sPrecision
95802>>>        Increment i
95803>>>
95803>>>        Move ePgSQL_TEXT        to ColumnType[i].iType
95804>>>        Move "text"             to ColumnType[i].sType
95805>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95806>>>        Move "Text"             to ColumnType[i].sDataFlexType
95807>>>        Move "16384"            to ColumnType[i].sPrecision
95808>>>        Increment i
95809>>>
95809>>>        Move ePgSQL_TIME        to ColumnType[i].iType
95810>>>        Move "time"             to ColumnType[i].sType
95811>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95812>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
95813>>>        Move "15.0"             to ColumnType[i].sPrecision
95814>>>        Increment i
95815>>>
95815>>>        Move ePgSQL_TIMESTAMP   to ColumnType[i].iType
95816>>>        Move "timestamp"        to ColumnType[i].sType
95817>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
95818>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
95819>>>        Move "23.0"             to ColumnType[i].sPrecision
95820>>>        Move True               to ColumnType[i].bFixedSize
95821>>>        Increment i
95822>>>
95822>>>        Move ePgSQL_UUID        to ColumnType[i].iType
95823>>>        Move "uuid"             to ColumnType[i].sType
95824>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
95825>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
95826>>>        Move "40"               to ColumnType[i].sPrecision
95827>>>        Move True               to ColumnType[i].bFixedSize
95828>>>        Increment i
95829>>>
95829>>>        Move ePgSQL_VARCHAR     to ColumnType[i].iType
95830>>>        Move "varchar"          to ColumnType[i].sType
95831>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
95832>>>        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
95833>>>        Move "16384"            to ColumnType[i].sPrecision
95834>>>        Increment i
95835>>>
95835>>>        Function_Return ColumnType
95836>>>    End_Function
95837>>>
95837>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
95837>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
95839>>>        Integer iValue iSize iCount iStart iDriverID
95839>>>        tColumnType[] ColumnTypeArray
95839>>>        tColumnType[] ColumnTypeArray
95840>>>        tColumnType RetvalType
95840>>>        tColumnType RetvalType
95840>>>        String sValue  
95840>>>        Boolean bFrameworkDataFlexType
95840>>>
95840>>>        Move "Undefined" to RetvalType.sType
95841>>>        Move -1999       to RetvalType.iType
95842>>>
95842>>>        Move 0 to iStart
95843>>>        Move (Uppercase(sType)) to sType
95844>>>        Move (iType <= -1490) to bFrameworkDataFlexType
95845>>>        If (bFrameworkDataFlexType = True) Begin
95847>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
95848>>>            Function_Return RetvalType
95849>>>        End
95849>>>>
95849>>>
95849>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
95850>>>
95850>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
95851>>>        Decrement iSize
95852>>>
95852>>>        for iCount from iStart to iSize
95858>>>>
95858>>>            Move ColumnTypeArray[iCount].iType to iValue
95859>>>            Move ColumnTypeArray[iCount].sType to sValue
95860>>>            If (bIntegerInputType = True) Begin
95862>>>                If (iValue = iType) Begin
95864>>>                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
95865>>>                    Move iType                                  to RetvalType.iType
95866>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
95867>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
95868>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
95869>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
95870>>>                    Move iSize to iCount // We're done!
95871>>>                End
95871>>>>
95871>>>            End
95871>>>>
95871>>>            Else Begin
95872>>>                Move (Uppercase(sValue)) to sValue
95873>>>                If (sValue = sType) Begin
95875>>>                    Move sType                                  to RetvalType.sType
95876>>>                    Move ColumnTypeArray[iCount].iType          to RetvalType.iType
95877>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
95878>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
95879>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
95880>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
95881>>>                    Move iSize to iCount // We're done!
95882>>>                End
95882>>>>
95882>>>            End
95882>>>>
95882>>>        Loop            
95883>>>>
95883>>>        
95883>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
95883>>>        // In which case we search for a match in DataFlex standard types:
95883>>>        If (RetvalType.sType = "Undefined") Begin
95885>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
95886>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
95887>>>            Decrement iSize
95888>>>    
95888>>>            for iCount from iStart to iSize
95894>>>>
95894>>>                Move ColumnTypeArray[iCount].iType to iValue
95895>>>                Move ColumnTypeArray[iCount].sType to sValue
95896>>>                If (iValue = iType) Begin
95898>>>                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
95899>>>                    Move iType                                  to RetvalType.iType
95900>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
95901>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
95902>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
95903>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
95904>>>                    Move iSize to iCount // We're done!
95905>>>                End
95905>>>>
95905>>>            Loop    
95906>>>>
95906>>>        End
95906>>>>
95906>>>
95906>>>        Function_Return RetvalType
95907>>>    End_Function
95908>>>
95908>>>    Function _AllTablesToConvert Returns Integer[]
95910>>>        Integer[] iTableConvertExceptions iTablesArray
95912>>>        Handle hTable
95912>>>        Integer iIndex
95912>>>        String sTableName
95912>>>        Boolean bFlexErrs
95912>>>
95912>>>        // a) Get the exception table array the developer has specified
95912>>>        Get piTableConvertExceptions to iTableConvertExceptions
95913>>>
95913>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
95913>>>        Repeat
95913>>>>
95913>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95916>>>            If (hTable <> 0) Begin
95918>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
95921>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
95922>>>                If (bFlexErrs = False) Begin
95924>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
95926>>>                        Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
95927>>>                        If (iIndex = -1) Begin
95929>>>                            Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
95930>>>                        End
95930>>>>
95930>>>                    End
95930>>>>
95930>>>                End
95930>>>>
95930>>>            End
95930>>>>
95930>>>        Until (hTable = 0)
95932>>>
95932>>>        Move 0 to hTable
95933>>>
95933>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
95933>>>        Repeat
95933>>>>
95933>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95936>>>            If (hTable > 0) Begin
95938>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
95941>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
95942>>>                If (bFlexErrs = False) Begin
95944>>>                    Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
95945>>>                    If (iIndex = -1) Begin
95947>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
95948>>>                    End
95948>>>>
95948>>>                End
95948>>>>
95948>>>            End
95948>>>>
95948>>>        Until (hTable = 0)
95950>>>
95950>>>        Function_Return iTablesArray
95951>>>    End_Function
95952>>>
95952>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[] 
95954>>>        tAPIColumn NewAPIColumn 
95954>>>        tAPIColumn NewAPIColumn 
95954>>>        
95954>>>        Move sFieldName to NewAPIColumn.sFieldName
95955>>>        Move iType      to NewAPIColumn.iType
95956>>>        Move iLength    to NewAPIColumn.iLength
95957>>>        Move iPrecision to NewAPIColumn.iPrecision
95958>>>        Move iOptions   to NewAPIColumn.iOptions
95959>>>        
95959>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
95960>>>        
95960>>>        Function_Return aCurrent
95961>>>    End_Function
95962>>>
95962>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
95964>>>        String sRetval sFieldName
95964>>>        Integer iCount iSize
95964>>>        
95964>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
95965>>>        Decrement iSize
95966>>>        for iCount from 0 to iSize
95972>>>>
95972>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
95973>>>            Move (sRetval * (String(sFieldName))) to sRetval
95974>>>        Loop                                                
95975>>>>
95975>>>        Move (Trim(sRetval)) to sRetval
95976>>>        
95976>>>        Function_Return sRetval
95977>>>    End_Function
95978>>>
95978>>>    // *** Miscellaneous other functions ***
95978>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
95978>>>    //
95978>>>
95978>>>    // Callback functionality used when e.g. calling driver functions directly.
95978>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
95980>>>        Integer iRetval iPos iPerc
95980>>>        String sVal1 sVal2
95980>>>        Number nReady nTotal
95980>>>
95980>>>        Send DoAdvance of ghoProgressBar
95981>>>
95981>>>        If (sCallback_Text contains "Copy records") Begin
95983>>>            Move CS_SQLCopyingData to sCallback_Text
95984>>>        End
95984>>>>
95984>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
95986>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
95987>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
95988>>>        End
95988>>>>
95988>>>        If (sCallback_Text contains "Creating index") Begin
95990>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
95991>>>        End
95991>>>>
95991>>>
95991>>>        Case Begin
95991>>>            Case (iCallback_Type = DF_Message_Text)
95993>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
95993>>>                Set Action_Text  of ghoStatusPanel to ""
95994>>>                Case Break
95995>>>            Case (iCallback_Type = DF_Message_Heading_1)
95998>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
95999>>>                Set Action_Text  of ghoStatusPanel to ""
96000>>>                Case Break
96001>>>            Case (iCallback_Type = DF_Message_Heading_2)
96004>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
96005>>>                Set Action_Text  of ghoStatusPanel to ""
96006>>>                Case Break
96007>>>            Case (iCallback_Type = DF_Message_Heading_3)
96010>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
96011>>>                Set Action_Text  of ghoStatusPanel to ""
96012>>>                Case Break
96013>>>            Case (iCallback_Type = DF_Message_Heading_4)
96016>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
96017>>>                Set Action_Text  of ghoStatusPanel to ""
96018>>>                Case Break
96019>>>            Case (iCallback_Type = DF_Message_Heading_5)
96022>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
96023>>>                Set Action_Text  of ghoStatusPanel to ""
96024>>>                Case Break
96025>>>            Case (iCallback_Type = DF_Message_Warning)
96028>>>                Send None
96029>>>                Case Break
96030>>>            Case (iCallback_Type = DF_Message_Progress_Title)
96033>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
96034>>>                Set Action_Text  of ghoStatusPanel to ""
96035>>>                Case Break
96036>>>            Case (iCallback_Type = DF_Message_Progress_Value)
96039>>>                //*** Interpret numbers
96039>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
96040>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
96041>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
96042>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
96043>>>                Case Break
96044>>>            Case Else
96044>>>                Set Message_Text to ""
96045>>>                Set Action_Text  to ""
96046>>>        Case End
96046>>>
96046>>>        Send ProcessEvents of ghoStatusPanel
96047>>>        Function_Return False
96048>>>    End_Function
96049>>>
96049>>>    Procedure IncreaseSortBufferSize
96051>>>        String sNull
96051>>>        Integer iSortBufferSize
96051>>>        Boolean bBufferSet
96051>>>
96051>>>        Move "" to sNull
96052>>>        Move (1024 * 128) to iSortBufferSize
96053>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback Self Passing sNull sNull iSortBufferSize Result bBufferSet
96058>>>
96058>>>    End_Procedure
96059>>>
96059>>>    Procedure SetAllIndexesToBatch Handle hTable
96061>>>        Integer iLastIndex iIndex iNumSegments iIndexType
96061>>>        String sTable
96061>>>        Boolean bOK
96061>>>        
96061>>>        If (hTable > 0) Begin
96063>>>            Close hTable
96064>>>            Get OpenTableExclusive hTable to bOK
96065>>>            If (bOK = False) Begin
96067>>>                Function_Return False
96068>>>            End
96068>>>>
96068>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
96071>>>            for iIndex from 1 to iLastIndex
96077>>>>
96077>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96080>>>                If (iNumSegments > 0) Begin
96082>>>                    Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
96085>>>                End
96085>>>>
96085>>>            Loop
96086>>>>
96086>>>            Close hTable
96087>>>        End
96087>>>>
96087>>>    End_Procedure
96088>>>
96088>>>    Function NextFreeFilelistSlot Returns Handle
96090>>>        Handle hTable
96090>>>
96090>>>        Move 0 to hTable
96091>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
96094>>>
96094>>>        Function_Return hTable
96095>>>    End_Function
96096>>>
96096>>>    // For debugging purposes. To print Sql statements as they are build...
96096>>>    Procedure DebugPrint String sStmt String sFileName
96098>>>        Integer iCh
96098>>>        Get Seq_Append_Output_Channel sFileName to iCh
96099>>>            Write channel iCh sStmt
96101>>>        Send Seq_Close_Channel iCh
96102>>>    End_Procedure
96103>>>
96103>>>    // Returns the integer number for the passed Driver ID that is
96103>>>    // needed by some database API calls.
96103>>>    Function DriverIndex String sDriverID Returns Integer
96105>>>        String  sCurrentDriver
96105>>>        Integer iNumberOfDrivers iDriver iCount
96105>>>
96105>>>        Move 0 to iDriver
96106>>>
96106>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
96109>>>        for iCount from 1 to iNumberOfDrivers
96115>>>>
96115>>>
96115>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
96118>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
96120>>>                Move iCount to iDriver
96121>>>            End
96121>>>>
96121>>>        Loop
96122>>>>
96122>>>
96122>>>        // In case it was not found, it wasn't loaded so we do that now.
96122>>>        If (iDriver = 0) Begin
96124>>>            Move False to Err
96125>>>            Load_Driver sDriverID
96126>>>            If (Err = False) Begin
96128>>>                Move 1 to iDriver
96129>>>            End
96129>>>>
96129>>>        End
96129>>>>
96129>>>
96129>>>        Function_Return iDriver
96130>>>    End_Function
96131>>>
96131>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE  
96131>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
96131>>>    //       so in that case we "cheat" and report those tables were opened OK.
96131>>>    Function OpenTableExclusive Handle hTable Returns Boolean
96133>>>        Integer iMode
96133>>>        Boolean bOpened bCodeMasterType                        
96133>>>        String sTableName
96133>>>        
96133>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96134>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
96137>>>        If (bOpened) Begin
96139>>>            If (IsDebuggerPresent()) Begin
96141>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
96144>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
96146>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
96147>>>                    Function_Return True
96148>>>                End
96148>>>>
96148>>>            End
96148>>>>
96148>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
96151>>>            If (iMode=DF_EXCLUSIVE) Begin
96153>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
96154>>>                Function_Return True
96155>>>            End
96155>>>>
96155>>>            Close hTable
96156>>>        End
96156>>>>
96156>>>        Else Begin
96157>>>            Open hTable
96159>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
96162>>>            If (bOpened and IsDebuggerPresent()) Begin
96164>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
96167>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
96169>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
96170>>>                    Function_Return True
96171>>>                End
96171>>>>
96171>>>            End
96171>>>>
96171>>>            
96171>>>        End
96171>>>>
96171>>>
96171>>>        Open hTable Mode DF_EXCLUSIVE
96173>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
96176>>>
96176>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96177>>>        Function_Return bOpened
96178>>>    End_Function
96179>>>    
96179>>>    Function AutoConnectionIDLogin Returns Boolean
96181>>>        String sConnectionID sConnectionString sDriverID
96181>>>        Boolean bExists bOK bDAWDriver bSQLDriver
96181>>>        Handle hoCLI hoDriver
96181>>>        Integer iRetval
96181>>>        tSQLConnection SQLConnection
96181>>>        tSQLConnection SQLConnection
96181>>>        
96181>>>        Get psDriverID to sDriverID
96182>>>        Get IsSQLDriver sDriverID to bSQLDriver
96183>>>        If (bSQLDriver = False) Begin
96185>>>            Function_Return True
96186>>>        End                     
96186>>>>
96186>>>        
96186>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
96187>>>        Move SQLConnection.sDriverID                  to sDriverID
96188>>>        Move SQLConnection.sConnectionString          to sConnectionString
96189>>>        Get IsDAWSQLDriver sDriverID to bOK
96190>>>        If (bOK = True) Begin
96192>>>//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
96192>>>        End
96192>>>>
96192>>>        If (bOK = False) Begin
96194>>>            Get _MertechSQLManagerHandle to hoCLI
96195>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
96196>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
96197>>>            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
96199>>>                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
96200>>>                Send Destroy of hoDriver
96201>>>            End
96201>>>>
96201>>>            Function_Return False
96202>>>        End
96202>>>>
96202>>>
96202>>>        Move SQLConnection.sConnectionID to sConnectionID
96203>>>
96203>>>        Get IsConnectionID sConnectionID sDriverID to bExists
96204>>>        If (bExists = False) Begin
96206>>>            // We always start by deleting the current connection - if any - because the
96206>>>            // login details my have changed.
96206>>>            Get phoCLIHandler to hoCLI
96207>>>            Set psDriverID    of hoCLI to sDriverID
96208>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
96209>>>            Get UtilCreateConnectionID sConnectionID to bOk
96210>>>            If (bOk = False) Begin
96212>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
96213>>>>
96213>>>                Function_Return False
96214>>>            End
96214>>>>
96214>>>            Move bOK to bExists
96215>>>        End
96215>>>>
96215>>>
96215>>>        Function_Return (bExists = True)
96216>>>    End_Function
96217>>>
96217>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
96217>>>    // Returns: False if nobody else is running
96217>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
96217>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
96217>>>    //      tables are not locked as DataFlex tables are.
96217>>>    Function IsDatabaseInUse Returns Boolean
96219>>>        Handle  hTable
96219>>>        Integer iTemp
96219>>>        String  sRootName sOrgOpenPath sOrgFileList
96219>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
96219>>>
96219>>>        Get AutoConnectionIDLogin to bOK
96220>>>        Move 0 to hTable
96221>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
96224>>>        Move False to bErr
96225>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
96226>>>
96226>>>        Repeat
96226>>>>
96226>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
96229>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
96230>>>
96230>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
96230>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
96231>>>            Move False to bOpen
96232>>>
96232>>>            // Don't bother about FlexErrs (Normally table 50)
96232>>>            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
96234>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96235>>>                Open hTable
96237>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
96240>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96241>>>                If (bOpen = True) Begin
96243>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
96243>>>                    Get UtilTableIsAlias hTable to bAlias
96244>>>                    If (bAlias = False) Begin 
96246>>>                        Close hTable
96247>>>                        Get OpenTableExclusive hTable to bOpen
96248>>>                        If (bOpen = False) Begin
96250>>>                            Move True to bErr
96251>>>                        End
96251>>>>
96251>>>                    End
96251>>>>
96251>>>                End 
96251>>>>
96251>>>                Close hTable
96252>>>            End
96252>>>>
96252>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
96255>>>            If (bErr = True ) Break
96258>>>        Until (not(hTable))
96260>>>
96260>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
96261>>>        Move False to Err
96262>>>
96262>>>        Function_Return bErr
96263>>>    End_Function
96264>>>
96264>>>    // Checks if the passed connection id exists in the CLI interface.
96264>>>    // This might be needed by API-methods when a connection id is to be used and
96264>>>    // the connection id hasn't been established with the driver's CLI interface.
96264>>>    // NOTE: Only applicable for DAW drivers.
96264>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
96266>>>        String sID sConnString
96266>>>        Integer iDriver iNumConn iCount
96266>>>        Handle hoCLI
96266>>>        Boolean bOK
96266>>>
96266>>>        Get IsDAWSQLDriver sDriverID to bOK
96267>>>        If (bOK = False) Begin
96269>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
96270>>>>
96270>>>            Function_Return False
96271>>>        End
96271>>>>
96271>>>
96271>>>        Move False to bOK
96272>>>        Get phoCLIHandler to hoCLI
96273>>>        If (hoCLI <> 0) Begin
96275>>>            Set psDriverID of hoCLI to sDriverID
96276>>>            Get DriverIndex of hoCLI sDriverID to iDriver
96277>>>
96277>>>            // If driver not loaded; load it.
96277>>>            If (iDriver = 0) Begin
96279>>>                Load_Driver sDriverID
96280>>>                Get DriverIndex sDriverID to iDriver
96281>>>            End
96281>>>>
96281>>>            If (iDriver <> 0) Begin
96283>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
96286>>>                Decrement iNumConn
96287>>>                for iCount from 0 to iNumConn
96293>>>>
96293>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
96296>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
96299>>>                    If (sID = sConnectionID) Move True to bOK
96302>>>                Loop
96303>>>>
96303>>>            End
96303>>>>
96303>>>        End
96303>>>>
96303>>>
96303>>>        Function_Return bOK
96304>>>    End_Function
96305>>>
96305>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
96307>>>        Boolean bOK
96307>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
96308>>>        Function_Return bOK
96309>>>    End_Function
96310>>>
96310>>>    Function IsMertechDriver String sDriverID Returns Boolean
96312>>>        Boolean bOK
96312>>>        Move False to bOK
96313>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
96314>>>        Function_Return bOK
96315>>>    End_Function
96316>>>
96316>>>    Function IsMSSQLDriver Returns Boolean
96318>>>        Handle ho
96318>>>        Integer iDriverIndex
96318>>>
96318>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
96319>>>
96319>>>        Function_Return (iDriverIndex <> 0)
96320>>>    End_Function
96321>>>
96321>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
96321>>>    // attempt to load the driver.
96321>>>    // Returns true if the passed driver is SQL based.
96321>>>    Function IsSQLDriver String sDriverID Returns Boolean
96323>>>        Boolean bOK
96323>>>        Integer iDriver
96323>>>
96323>>>        Get IsDAWSQLDriver sDriverID to bOK
96324>>>
96324>>>        If (bOK = False) Begin
96326>>>            Get IsMertechDriver sDriverID to bOK
96327>>>        End
96327>>>>
96327>>>
96327>>>        Function_Return bOK
96328>>>    End_Function
96329>>>
96329>>>    // *** Error Handler ***
96329>>>    //
96329>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
96329>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
96329>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
96331>>>        String sText
96331>>>        Integer iSize iErrorMode
96331>>>        tSqlErrorArray aSqlErrorArray
96331>>>        tSqlErrorArray aSqlErrorArray
96331>>>
96331>>>        If (pbProcessingError(Self)) Begin
96333>>>            Procedure_Return
96334>>>        End
96334>>>>
96334>>>
96334>>>        Get Error_Report_Mode to iErrorMode
96335>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
96337>>>            Procedure_Return
96338>>>        End
96338>>>>
96338>>>
96338>>>        Set pbProcessingError to True
96339>>>        Set pbSqlError to True
96340>>>        Get paSqlErrorArray      to aSqlErrorArray
96341>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
96342>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
96343>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
96344>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
96345>>>        Set paSqlErrorArray      to aSqlErrorArray
96346>>>        Set pbProcessingError to False
96347>>>    End_Procedure
96348>>>
96348>>>    // *** Miscellanous Helper Functions ***
96348>>>    //
96348>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
96348>>>    // returns the table name only; stripped of any path or filename extension.
96348>>>    Function _TableNameOnly String sName Returns String
96350>>>        String sPath sExt
96350>>>
96350>>>        Get ParseFolderName sName to sPath
96351>>>        If (sPath <> "") Begin
96353>>>            Move (Replace(sPath, sName, "")) to sName
96354>>>        End
96354>>>>
96354>>>        Get ParseFileExtension sName to sExt
96355>>>        If (sExt <> "") Begin
96357>>>            Move (Replace(("." + sExt), sName, "")) to sName
96358>>>        End
96358>>>>
96358>>>
96358>>>        Function_Return sName
96359>>>    End_Function
96360>>>
96360>>>    // Returns the first datapath found in the psDataPath property.
96360>>>    // The returned path always ends with a "\"
96360>>>    Function psDataPathFirstPart Returns String
96362>>>        String sDataPath
96362>>>        Integer iCount
96362>>>
96362>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
96363>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
96364>>>        If (iCount > 1) Begin
96366>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
96367>>>        End
96367>>>>
96367>>>        If (sDataPath <> "") Begin
96369>>>            Get vFolderFormat sDataPath to sDataPath
96370>>>        End
96370>>>>
96370>>>
96370>>>        Function_Return sDataPath
96371>>>    End_Function
96372>>>
96372>>>    // *** Property Messages ***
96372>>>    //
96372>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
96372>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
96372>>>    //
96372>>>
96372>>>    Function pSQLConnection Returns tSQLConnection
96374>>>        tSQLConnection SQLConnection
96374>>>        tSQLConnection SQLConnection
96374>>>        If (ghoSQLConnectionHandler = 0) Begin
96376>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
96376>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96377>>>>
96377>>>            Function_Return
96378>>>        End
96378>>>>
96378>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
96379>>>        Function_Return SQLConnection
96380>>>    End_Function
96381>>>
96381>>>    Procedure Set psServer String sValue
96383>>>        If (ghoSQLConnectionHandler = 0) Begin
96385>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
96385>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96386>>>>
96386>>>            Procedure_Return
96387>>>        End
96387>>>>
96387>>>        Set psServer of ghoSQLConnectionHandler to sValue
96388>>>    End_Procedure
96389>>>
96389>>>    Function psServer Returns String
96391>>>        String sValue
96391>>>        If (ghoSQLConnectionHandler = 0) Begin
96393>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96394>>>>
96394>>>            Function_Return
96395>>>        End
96395>>>>
96395>>>        Get psServer of ghoSQLConnectionHandler to sValue
96396>>>        Function_Return sValue
96397>>>    End_Function
96398>>>
96398>>>    Procedure Set psDatabase String sValue
96400>>>        If (ghoSQLConnectionHandler = 0) Begin
96402>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96403>>>>
96403>>>            Procedure_Return
96404>>>        End
96404>>>>
96404>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
96405>>>    End_Procedure
96406>>>
96406>>>    Function psDatabase Returns String
96408>>>        String sValue
96408>>>        If (ghoSQLConnectionHandler = 0) Begin
96410>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96411>>>>
96411>>>            Function_Return
96412>>>        End
96412>>>>
96412>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
96413>>>        Function_Return sValue
96414>>>    End_Function
96415>>>
96415>>>    Procedure Set psUserID String sValue
96417>>>        If (ghoSQLConnectionHandler = 0) Begin
96419>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96420>>>>
96420>>>            Function_Return
96421>>>        End
96421>>>>
96421>>>        Set psUserID of ghoSQLConnectionHandler to sValue
96422>>>    End_Procedure
96423>>>
96423>>>    Function psUserID Returns String
96425>>>        String sValue
96425>>>        If (ghoSQLConnectionHandler = 0) Begin
96427>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96428>>>>
96428>>>            Function_Return
96429>>>        End
96429>>>>
96429>>>        Get psUserID of ghoSQLConnectionHandler to sValue
96430>>>        Function_Return sValue
96431>>>    End_Function
96432>>>
96432>>>    Procedure Set psPassword String sValue
96434>>>        If (ghoSQLConnectionHandler = 0) Begin
96436>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96437>>>>
96437>>>            Procedure_Return
96438>>>        End
96438>>>>
96438>>>        Set psPassword of ghoSQLConnectionHandler to sValue
96439>>>    End_Procedure
96440>>>
96440>>>    Function psPassword Returns String
96442>>>        String sValue
96442>>>        If (ghoSQLConnectionHandler = 0) Begin
96444>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96445>>>>
96445>>>            Function_Return
96446>>>        End
96446>>>>
96446>>>        Get psPassword of ghoSQLConnectionHandler to sValue
96447>>>        Function_Return sValue
96448>>>    End_Function
96449>>>
96449>>>    Procedure Set pbTrusted Boolean bValue
96451>>>        If (ghoSQLConnectionHandler = 0) Begin
96453>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96454>>>>
96454>>>            Procedure_Return
96455>>>        End
96455>>>>
96455>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
96456>>>    End_Procedure
96457>>>
96457>>>    Function pbTrusted Returns Boolean
96459>>>        Boolean bValue
96459>>>        If (ghoSQLConnectionHandler = 0) Begin
96461>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96462>>>>
96462>>>            Function_Return
96463>>>        End
96463>>>>
96463>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
96464>>>        Function_Return bValue
96465>>>    End_Function
96466>>>
96466>>>    Procedure Set pbSilentLogin Boolean bValue
96468>>>        If (ghoSQLConnectionHandler = 0) Begin
96470>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96471>>>>
96471>>>            Procedure_Return
96472>>>        End
96472>>>>
96472>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
96473>>>    End_Procedure
96474>>>
96474>>>    Function pbSilentLogin Returns Boolean
96476>>>        Boolean bValue
96476>>>        If (ghoSQLConnectionHandler = 0) Begin
96478>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96479>>>>
96479>>>            Function_Return
96480>>>        End
96480>>>>
96480>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
96481>>>        Function_Return bValue
96482>>>    End_Function
96483>>>
96483>>>    Procedure Set psConnectionID String sValue
96485>>>        If (ghoSQLConnectionHandler = 0) Begin
96487>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96488>>>>
96488>>>            Procedure_Return
96489>>>        End
96489>>>>
96489>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
96490>>>    End_Procedure
96491>>>
96491>>>    Function psConnectionID Returns String
96493>>>        String sValue
96493>>>        If (ghoSQLConnectionHandler = 0) Begin
96495>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96496>>>>
96496>>>            Function_Return
96497>>>        End
96497>>>>
96497>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
96498>>>        Function_Return sValue
96499>>>    End_Function
96500>>>
96500>>>    Procedure Set psConnectionString String sValue
96502>>>        If (ghoSQLConnectionHandler = 0) Begin
96504>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96505>>>>
96505>>>            Procedure_Return
96506>>>        End
96506>>>>
96506>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
96507>>>    End_Procedure
96508>>>
96508>>>    Function psConnectionString Returns String
96510>>>        String sValue
96510>>>        If (ghoSQLConnectionHandler = 0) Begin
96512>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96513>>>>
96513>>>            Function_Return
96514>>>        End
96514>>>>
96514>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
96515>>>        Function_Return sValue
96516>>>    End_Function
96517>>>
96517>>>    // The normal connection string looks something like this;
96517>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
96517>>>    // ...and the full connection string looks like this;
96517>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
96517>>>    Function psFullConnectionString Returns String
96519>>>        String sConnectionID sConnectionString
96519>>>        If (ghoSQLConnectionHandler = 0) Begin
96521>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96522>>>>
96522>>>            Function_Return
96523>>>        End
96523>>>>
96523>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
96524>>>        Move (Trim(sConnectionID)) to sConnectionID
96525>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
96526>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
96527>>>    End_Function
96528>>>
96528>>>    Function piConnectionOptions Returns Integer
96530>>>        Integer iValue
96530>>>        If (ghoSQLConnectionHandler = 0) Begin
96532>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96533>>>>
96533>>>            Function_Return
96534>>>        End
96534>>>>
96534>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
96535>>>        Function_Return iValue
96536>>>    End_Function
96537>>>
96537>>>    Procedure Set psSchema String sValue
96539>>>        tSQLConnection SQLConnection
96539>>>        tSQLConnection SQLConnection
96539>>>        If (ghoSQLConnectionHandler = 0) Begin
96541>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96542>>>>
96542>>>            Procedure_Return
96543>>>        End
96543>>>>
96543>>>        Set psSchema of ghoSQLConnectionHandler to sValue
96544>>>    End_Procedure
96545>>>
96545>>>    Function psSchema Returns String
96547>>>        String sRetval
96547>>>        If (ghoSQLConnectionHandler = 0) Begin
96549>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96550>>>>
96550>>>            Function_Return
96551>>>        End
96551>>>>
96551>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
96552>>>        Function_Return sRetval
96553>>>    End_Function
96554>>>
96554>>>    Procedure Set psBaseTableSpace String sValue
96556>>>        String sRetval
96556>>>        If (ghoSQLConnectionHandler = 0) Begin
96558>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96559>>>>
96559>>>            Procedure_Return
96560>>>        End
96560>>>>
96560>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
96561>>>    End_Procedure
96562>>>
96562>>>    Function psBaseTableSpace Returns String
96564>>>        String sRetval
96564>>>        If (ghoSQLConnectionHandler = 0) Begin
96566>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96567>>>>
96567>>>            Function_Return
96568>>>        End
96568>>>>
96568>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
96569>>>        Function_Return sRetval
96570>>>    End_Function
96571>>>
96571>>>    Procedure Set psLongTableSpace String sValue
96573>>>        If (ghoSQLConnectionHandler = 0) Begin
96575>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96576>>>>
96576>>>            Procedure_Return
96577>>>        End
96577>>>>
96577>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
96578>>>    End_Procedure
96579>>>
96579>>>    Function psLongTableSpace Returns String
96581>>>        String sRetval
96581>>>        If (ghoSQLConnectionHandler = 0) Begin
96583>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96584>>>>
96584>>>            Function_Return
96585>>>        End
96585>>>>
96585>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
96586>>>        Function_Return sRetval
96587>>>    End_Function
96588>>>
96588>>>    Procedure Set psIndexTableSpace String sValue
96590>>>        If (ghoSQLConnectionHandler = 0) Begin
96592>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96593>>>>
96593>>>            Procedure_Return
96594>>>        End
96594>>>>
96594>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
96595>>>    End_Procedure
96596>>>
96596>>>    Function psIndexTableSpace Returns String
96598>>>        String sRetval
96598>>>        If (ghoSQLConnectionHandler = 0) Begin
96600>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96601>>>>
96601>>>            Function_Return
96602>>>        End
96602>>>>
96602>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
96603>>>        Function_Return sRetval
96604>>>    End_Function
96605>>>
96605>>>    Procedure Set pbUseConnectionID Boolean bState
96607>>>        If (ghoSQLConnectionHandler = 0) Begin
96609>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96610>>>>
96610>>>            Procedure_Return
96611>>>        End
96611>>>>
96611>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
96612>>>    End_Procedure
96613>>>
96613>>>    Function pbUseConnectionID Returns Boolean
96615>>>        Boolean bState
96615>>>        If (ghoSQLConnectionHandler = 0) Begin
96617>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96618>>>>
96618>>>            Function_Return
96619>>>        End
96619>>>>
96619>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
96620>>>        Function_Return bState
96621>>>    End_Function
96622>>>
96622>>>    Procedure Set pbToANSI Boolean bState
96624>>>        If (ghoSQLConnectionHandler = 0) Begin
96626>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96627>>>>
96627>>>            Procedure_Return
96628>>>        End
96628>>>>
96628>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
96629>>>    End_Procedure
96630>>>
96630>>>    Function pbToANSI Returns Boolean
96632>>>        Boolean bState
96632>>>        If (ghoSQLConnectionHandler = 0) Begin
96634>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96635>>>>
96635>>>            Function_Return
96636>>>        End
96636>>>>
96636>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
96637>>>        Function_Return bState
96638>>>    End_Function
96639>>>
96639>>>    Procedure Set pbRecnum Boolean bState
96641>>>        If (ghoSQLConnectionHandler = 0) Begin
96643>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96644>>>>
96644>>>            Procedure_Return
96645>>>        End
96645>>>>
96645>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
96646>>>    End_Procedure
96647>>>
96647>>>    Function pbRecnum Returns Boolean
96649>>>        Boolean bState
96649>>>        If (ghoSQLConnectionHandler = 0) Begin
96651>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96652>>>>
96652>>>            Function_Return
96653>>>        End
96653>>>>
96653>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
96654>>>        Function_Return bState
96655>>>    End_Function
96656>>>
96656>>>    Procedure Set pbCopyData Boolean bState
96658>>>        If (ghoSQLConnectionHandler = 0) Begin
96660>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96661>>>>
96661>>>            Procedure_Return
96662>>>        End
96662>>>>
96662>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
96663>>>    End_Procedure
96664>>>
96664>>>    Function pbCopyData Returns Boolean
96666>>>        Boolean bState
96666>>>        If (ghoSQLConnectionHandler = 0) Begin
96668>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96669>>>>
96669>>>            Function_Return
96670>>>        End
96670>>>>
96670>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
96671>>>        Function_Return bState
96672>>>    End_Function
96673>>>
96673>>>    Procedure Set pbCompareDate_DateTime Boolean bState
96675>>>        If (ghoSQLConnectionHandler = 0) Begin
96677>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96678>>>>
96678>>>            Procedure_Return
96679>>>        End
96679>>>>
96679>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
96680>>>    End_Procedure
96681>>>
96681>>>    Function pbCompareDate_DateTime Returns Boolean
96683>>>        Boolean bState
96683>>>        If (ghoSQLConnectionHandler = 0) Begin
96685>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96686>>>>
96686>>>            Function_Return
96687>>>        End
96687>>>>
96687>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
96688>>>        Function_Return bState
96689>>>    End_Function
96690>>>
96690>>>    Procedure Set pbCompareIndexAscending Boolean bState
96692>>>        If (ghoSQLConnectionHandler = 0) Begin
96694>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96695>>>>
96695>>>            Procedure_Return
96696>>>        End
96696>>>>
96696>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
96697>>>    End_Procedure
96698>>>
96698>>>    Function pbCompareIndexAscending Returns Boolean
96700>>>        Boolean bState
96700>>>        If (ghoSQLConnectionHandler = 0) Begin
96702>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96703>>>>
96703>>>            Function_Return
96704>>>        End
96704>>>>
96704>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
96705>>>        Function_Return bState
96706>>>    End_Function
96707>>>
96707>>>    Procedure Set pbCompareIndexUppercase Boolean bState
96709>>>        If (ghoSQLConnectionHandler = 0) Begin
96711>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96712>>>>
96712>>>            Procedure_Return
96713>>>        End
96713>>>>
96713>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
96714>>>    End_Procedure
96715>>>
96715>>>    Function pbCompareIndexUppercase Returns Boolean
96717>>>        Boolean bState
96717>>>        If (ghoSQLConnectionHandler = 0) Begin
96719>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
96720>>>>
96720>>>            Function_Return
96721>>>        End
96721>>>>
96721>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
96722>>>        Function_Return bState
96723>>>    End_Function
96724>>>
96724>>>    Procedure Set psDriverDefaultValueASCII String sValue
96726>>>        If (ghoSQLConnectionHandler = 0) Begin
96728>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96729>>>>
96729>>>            Procedure_Return
96730>>>        End
96730>>>>
96730>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
96731>>>    End_Procedure
96732>>>
96732>>>    Function psDriverDefaultValueASCII Returns String
96734>>>        String sRetval
96734>>>        If (ghoSQLConnectionHandler = 0) Begin
96736>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96737>>>>
96737>>>            Function_Return
96738>>>        End
96738>>>>
96738>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
96739>>>        Function_Return sRetval
96740>>>    End_Function
96741>>>
96741>>>    Procedure Set psDriverDefaultValueBinary String sValue
96743>>>        If (ghoSQLConnectionHandler = 0) Begin
96745>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96746>>>>
96746>>>            Procedure_Return
96747>>>        End
96747>>>>
96747>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
96748>>>    End_Procedure
96749>>>
96749>>>    Function psDriverDefaultValueBinary Returns String
96751>>>        String sRetval
96751>>>        If (ghoSQLConnectionHandler = 0) Begin
96753>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96754>>>>
96754>>>            Function_Return
96755>>>        End
96755>>>>
96755>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
96756>>>        Function_Return sRetval
96757>>>    End_Function
96758>>>
96758>>>    Procedure Set psDriverDefaultValueDate String sValue
96760>>>        If (ghoSQLConnectionHandler = 0) Begin
96762>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96763>>>>
96763>>>            Procedure_Return
96764>>>        End
96764>>>>
96764>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
96765>>>    End_Procedure
96766>>>
96766>>>    Function psDriverDefaultValueDate Returns String
96768>>>        String sRetval
96768>>>        If (ghoSQLConnectionHandler = 0) Begin
96770>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96771>>>>
96771>>>            Function_Return
96772>>>        End
96772>>>>
96772>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
96773>>>        Function_Return sRetval
96774>>>    End_Function
96775>>>
96775>>>    Procedure Set psDriverDefaultValueDateTime String sValue
96777>>>        If (ghoSQLConnectionHandler = 0) Begin
96779>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96780>>>>
96780>>>            Procedure_Return
96781>>>        End
96781>>>>
96781>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
96782>>>    End_Procedure
96783>>>
96783>>>    Function psDriverDefaultValueDateTime Returns String
96785>>>        String sRetval
96785>>>        If (ghoSQLConnectionHandler = 0) Begin
96787>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96788>>>>
96788>>>            Function_Return
96789>>>        End
96789>>>>
96789>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
96790>>>        Function_Return sRetval
96791>>>    End_Function
96792>>>
96792>>>    Procedure Set psDriverDefaultValueNumeric String sValue
96794>>>        If (ghoSQLConnectionHandler = 0) Begin
96796>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96797>>>>
96797>>>            Procedure_Return
96798>>>        End
96798>>>>
96798>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
96799>>>    End_Procedure
96800>>>
96800>>>    Function psDriverDefaultValueNumeric Returns String
96802>>>        String sRetval
96802>>>        If (ghoSQLConnectionHandler = 0) Begin
96804>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96805>>>>
96805>>>            Function_Return
96806>>>        End
96806>>>>
96806>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
96807>>>        Function_Return sRetval
96808>>>    End_Function
96809>>>
96809>>>    Procedure Set psDriverDefaultValueText String sValue
96811>>>        If (ghoSQLConnectionHandler = 0) Begin
96813>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96814>>>>
96814>>>            Procedure_Return
96815>>>        End
96815>>>>
96815>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
96816>>>    End_Procedure
96817>>>
96817>>>    Function psDriverDefaultValueText Returns String
96819>>>        String sRetval
96819>>>        If (ghoSQLConnectionHandler = 0) Begin
96821>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96822>>>>
96822>>>            Function_Return
96823>>>        End
96823>>>>
96823>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
96824>>>        Function_Return sRetval
96825>>>    End_Function
96826>>>
96826>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
96828>>>        If (ghoSQLConnectionHandler = 0) Begin
96830>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96831>>>>
96831>>>            Procedure_Return
96832>>>        End
96832>>>>
96832>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
96833>>>    End_Procedure
96834>>>
96834>>>    Function pbDriverDefaultNullableASCII Returns Boolean
96836>>>        Boolean bState
96836>>>        If (ghoSQLConnectionHandler = 0) Begin
96838>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96839>>>>
96839>>>            Function_Return
96840>>>        End
96840>>>>
96840>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
96841>>>        Function_Return bState
96842>>>    End_Function
96843>>>
96843>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
96845>>>        If (ghoSQLConnectionHandler = 0) Begin
96847>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96848>>>>
96848>>>            Procedure_Return
96849>>>        End
96849>>>>
96849>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
96850>>>    End_Procedure
96851>>>
96851>>>    Function pbDriverDefaultNullableBinary Returns Boolean
96853>>>        Boolean bState
96853>>>        If (ghoSQLConnectionHandler = 0) Begin
96855>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96856>>>>
96856>>>            Function_Return
96857>>>        End
96857>>>>
96857>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
96858>>>        Function_Return bState
96859>>>    End_Function
96860>>>
96860>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
96862>>>        If (ghoSQLConnectionHandler = 0) Begin
96864>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96865>>>>
96865>>>            Procedure_Return
96866>>>        End
96866>>>>
96866>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
96867>>>    End_Procedure
96868>>>
96868>>>    Function pbDriverDefaultNullableDate Returns Boolean
96870>>>        Boolean bState
96870>>>        If (ghoSQLConnectionHandler = 0) Begin
96872>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96873>>>>
96873>>>            Function_Return
96874>>>        End
96874>>>>
96874>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
96875>>>        Function_Return bState
96876>>>    End_Function
96877>>>
96877>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
96879>>>        If (ghoSQLConnectionHandler = 0) Begin
96881>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96882>>>>
96882>>>            Procedure_Return
96883>>>        End
96883>>>>
96883>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
96884>>>    End_Procedure
96885>>>
96885>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
96887>>>        Boolean bState
96887>>>        If (ghoSQLConnectionHandler = 0) Begin
96889>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96890>>>>
96890>>>            Function_Return
96891>>>        End
96891>>>>
96891>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
96892>>>        Function_Return bState
96893>>>    End_Function
96894>>>
96894>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
96896>>>        If (ghoSQLConnectionHandler = 0) Begin
96898>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96899>>>>
96899>>>            Procedure_Return
96900>>>        End
96900>>>>
96900>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
96901>>>    End_Procedure
96902>>>
96902>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
96904>>>        Boolean bState
96904>>>        If (ghoSQLConnectionHandler = 0) Begin
96906>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96907>>>>
96907>>>            Function_Return
96908>>>        End
96908>>>>
96908>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
96909>>>        Function_Return bState
96910>>>    End_Function
96911>>>
96911>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
96913>>>        If (ghoSQLConnectionHandler = 0) Begin
96915>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96916>>>>
96916>>>            Procedure_Return
96917>>>        End
96917>>>>
96917>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
96918>>>    End_Procedure
96919>>>
96919>>>    Function pbDriverDefaultNullableText Returns Boolean
96921>>>        Boolean bState
96921>>>        If (ghoSQLConnectionHandler = 0) Begin
96923>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
96924>>>>
96924>>>            Function_Return
96925>>>        End
96925>>>>
96925>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
96926>>>        Function_Return bState
96927>>>    End_Function
96928>>>
96928>>>    // Note: If the psDriverID + other connection properties are to be changed,
96928>>>    //       the psDriverID *must* be the first property that gets changed!
96928>>>    //       Otherwise errors might be raised by the driver when e.g. the format
96928>>>    //       for a connection string has the wrong format for that driver.
96928>>>    Procedure Set psDriverID String sValue
96930>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96931>>>        Delegate Set psDriverID to sValue
96933>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96934>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
96935>>>    End_Procedure
96936>>>
96936>>>    Function psDriverID Returns String
96938>>>        String sDriverID
96938>>>
96938>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96939>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
96939>>>        Delegate Get psDriverID to sDriverID
96941>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96942>>>        Move False to Err
96943>>>
96943>>>        // ...and in case it didn't use property of this class. Then the library is
96943>>>        // probably used as "utilites" from a special made program and
96943>>>        // the ghoSQLConnectionHandler must have been setup
96943>>>        If (sDriverID = "") Begin
96945>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
96946>>>        End
96946>>>>
96946>>>        Function_Return sDriverID
96947>>>    End_Function
96948>>>
96948>>>    Procedure Set piDbType Integer iValue
96950>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96951>>>        Delegate Set piDbType to iValue
96953>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96954>>>        Set piDbType of ghoSQLConnectionHandler to iValue
96955>>>    End_Procedure
96956>>>
96956>>>    Function piDbType Returns String
96958>>>        Integer iRetval
96958>>>
96958>>>//        Move False to Err
96958>>>//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96958>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
96958>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96958>>>//        Delegate Get piDbType to iRetval
96958>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
96958>>>//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96958>>>
96958>>>        // ...and in case it didn't use property of this class. Then the library is
96958>>>        // probably used as "utilites" from a special made program and
96958>>>        // the ghoSQLConnectionHandler must have been setup
96958>>>//        If (Err = True) Begin
96958>>>            Get piDbType of ghoSQLConnectionHandler to iRetval
96959>>>//        End
96959>>>
96959>>>//        Move False to Err
96959>>>        Function_Return iRetval
96960>>>    End_Function  
96961>>>    
96961>>>    Function phoLogFile Returns Handle
96963>>>        Handle hoLogFile
96963>>>        
96963>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96964>>>        Delegate Get phoLogFile to hoLogFile
96966>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96967>>>
96967>>>        Function_Return hoLogFile
96968>>>    End_Function
96969>>>
96969>>>    Function pnCurrentVersionUpdate Returns Number
96971>>>        Number nCurrentVersionUpdate
96971>>>
96971>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96972>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
96974>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96975>>>
96975>>>        Function_Return nCurrentVersionUpdate
96976>>>    End_Function
96977>>>    
96977>>>    Procedure LogError String sText Boolean bError
96979>>>        Handle hoLogFile 
96979>>>        Number nCurrentVersionUpdate
96979>>>        
96979>>>        Get phoLogFile to hoLogFile
96980>>>        If (hoLogFile = 0) Begin
96982>>>            Procedure_Return
96983>>>        End 
96983>>>>
96983>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
96984>>>        
96984>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96985>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
96986>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96987>>>    End_Procedure        
96988>>>    
96988>>>    Function pbContinueOnError Returns Boolean
96990>>>        Boolean bContinueOnError
96990>>>        If (ghoDbUpdateHandler > 0) Begin
96992>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
96993>>>        End
96993>>>>
96993>>>        Function_Return bContinueOnError
96994>>>    End_Function
96995>>>
96995>>>    // Messages not available in pre DF18 versions:
96995>>>
96995>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer 
96997>>>        Integer iMax iPos 
96997>>>        String sName 
96997>>>        
96997>>>        Move (Lowercase(sField)) to sField
96998>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax 
97001>>>        for iPos from 0 to iMax 
97007>>>>
97007>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName 
97010>>>            Move (Lowercase(sName)) to sName 
97011>>>            If (sName = sField) Begin
97013>>>                Function_Return iPos 
97014>>>            End
97014>>>>
97014>>>        Loop
97015>>>>
97015>>>        Function_Return -1 
97016>>>    End_Function
97017>>>
97017>>>
97017>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
97017>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
97017>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
97017>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
97017>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
97017>>>    //   ALTER TABLE MyTable
97017>>>    //       REBUILD
97017>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
97019>>>        Boolean bOK
97019>>>
97019>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
97021>>>            Function_Return False
97022>>>        End
97022>>>>
97022>>>
97022>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
97022>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
97023>>>
97023>>>        Function_Return (bOK = True)
97024>>>    End_Function
97025>>>
97025>>>
97025>>>    // *** Helper functions with compiled sql script code ***
97025>>>    //
97025>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
97025>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
97025>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
97025>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
97025>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
97025>>>    //   ALTER TABLE MyTable
97025>>>    //       REBUILD
97025>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
97027>>>        tSQLScriptArray SQLScriptArray
97027>>>        tSQLScriptArray SQLScriptArray
97027>>>        String sDriverID sVal
97027>>>        Boolean bOK
97027>>>        Integer iSize iCount
97027>>>
97027>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
97029>>>            Function_Return False
97030>>>        End
97030>>>>
97030>>>
97030>>>        Get psDriverID to sDriverID
97031>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
97032>>>        If (SQLScriptArray.bError = True) Begin
97034>>>            Function_Return False
97035>>>        End
97035>>>>
97035>>>
97035>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
97036>>>        Decrement iSize
97037>>>
97037>>>        for iCount from 0 to iSize
97043>>>>
97043>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
97045>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
97046>>>            End
97046>>>>
97046>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
97048>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
97049>>>            End
97049>>>>
97049>>>        Loop
97050>>>>
97050>>>
97050>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
97051>>>
97051>>>        Function_Return (bOK = True)
97052>>>    End_Function
97053>>>
97053>>>    // *** Helper functions for Mertech Drivers ***
97053>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
97053>>>    // and commands that the Studio editor knows nothing about.
97053>>>    Function _MertechDeleteTDFile String sTableName Returns Integer
97055>>>        Integer iRetval
97055>>>        String sPath
97055>>>
97055>>>            SQL_GET_LOCAL_TD_PATH to sPath
97069>>>>
97069>>>        If (sPath = "" or sTableName = "") Begin
97071>>>            Function_Return 0
97072>>>        End
97072>>>>
97072>>>
97072>>>        Get vFolderFormat sPath to sPath
97073>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
97074>>>        Function_Return iRetval
97075>>>    End_Function
97076>>>
97076>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
97078>>>        Move False to Err
97079>>>            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to False
97082>>>            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to False
97085>>>            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to False
97088>>>            OUTPUT_INT_FILE for hTable to (sDataPath + sPhysicalFileName)
97109>>>>
97109>>>        Function_Return (Err = False)
97110>>>    End_Function
97111>>>
97111>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
97113>>>        Integer iNumItems iCount
97113>>>        String[] sReturnArray
97114>>>        String sServer
97114>>>
97114>>>        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
97115>>>        For iCount from 1 to iNumItems
97121>>>>
97121>>>            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
97122>>>            Move sServer to sReturnArray[iCount -1]
97123>>>        Loop
97124>>>>
97124>>>
97124>>>        Function_Return sReturnArray
97125>>>    End_Function
97126>>>
97126>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
97128>>>        String[] sReturnArray
97129>>>        String sServer
97129>>>
97129>>>        GET_CURRENT_SQL_SERVER to sServer
97149>>>>
97149>>>        Move sServer to sReturnArray[0]
97150>>>
97150>>>        Function_Return sReturnArray
97151>>>    End_Function
97152>>>
97152>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
97154>>>        Handle hoSQLHandler hoSQLConnect
97154>>>
97154>>>        Move 0 to hoSQLConnect
97155>>>            Get _MertechSQLManagerHandle to hoSQLHandler
97156>>>            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
97157>>>
97157>>>        Function_Return hoSQLConnect
97158>>>    End_Function
97159>>>
97159>>>    // Returns the handle of the Mertech SQL handler.
97159>>>    // It also ensures that the correct Server & Database attributes are set both for
97159>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
97159>>>    Function _MertechSQLManagerHandle Returns Handle
97161>>>        Handle hoSQLHandler
97161>>>        String sDriverID sServer sDatabase
97161>>>
97161>>>        Move 0 to hoSQLHandler
97162>>>        Get psDriverID to sDriverID
97163>>>        Get psServer   to sServer
97164>>>        Get psDatabase to sDatabase
97165>>>        // This command is used to set the server to be used when opening tables
97165>>>        SET_CURRENT_SQL_SERVER            to sServer
97184>>>>
97184>>>        // This command is used to specify which server to use for embedded SQL statements,
97184>>>        // but it has been constructed rather studidly as only constants and not variables
97184>>>        // are allowed...
97184>>>        If (sDriverID = MDSPgSQL) Begin
97186>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
97202>>>        End
97202>>>>
97202>>>        If (sDriverID = MDSMySQL) Begin
97204>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
97220>>>        End
97220>>>>
97220>>>        If (sDriverID = ORAFLEX) Begin
97222>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
97238>>>        End
97238>>>>
97238>>>        If (sDriverID = SQLFLEX) Begin
97240>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
97256>>>        End
97256>>>>
97256>>>
97256>>>        // This command is used to specify which database is used for SQL statements only.
97256>>>        SQL_USE_DATABASE sDatabase
97270>>>>
97270>>>        SET_DATABASE_NAME to sDatabase
97284>>>>
97284>>>
97284>>>        Get phoSQLManagerMT to hoSQLHandler
97285>>>
97285>>>        Function_Return hoSQLHandler
97286>>>    End_Function
97287>>>
97287>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
97287>>>    // macro-commands <sigh!>
97287>>>    // Note: The function sets the Err flag.
97287>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
97289>>>        Move False to Err
97290>>>
97290>>>            MERTECH_WARNING_MESSAGE Disabled
97299>>>>
97299>>>            SET_DATABASE_NAME to sDatabase
97313>>>>
97313>>>            If (sBaseTableSpace <> "") Begin
97315>>>                SET_DEFAULT_TABLESPACE to sBaseTableSpace
97328>>>>
97328>>>            End
97328>>>>
97328>>>            If (sIndexTableSpace <> "") Begin
97330>>>                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
97343>>>>
97343>>>            End
97343>>>>
97343>>>            CREATE_TABLE_FROM_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_NOT_NULL sRootName
97365>>>>
97365>>>            If (bCopyData = True) Begin
97367>>>                COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
97382>>>>
97382>>>            End
97382>>>>
97382>>>
97382>>>        Function_Return (Err = False)
97383>>>    End_Function
97384>>>
97384>>>End_Class
97385>// Needs to be after the cSQLConnectionHandler object
97385>Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
97387>End_Object
97388>
97388>Object oToolTipController is a cToolTipController
97390>    Move Self to ghoToolTipController
97391>    Set pbBalloonStyle to False
97392>    Set piIcon to TTI_INFO
97393>    Set psTitle to "Information"
97394>    Set piMaxWidth to 400
97395>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
97396>End_Object
97397>
97397>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oEditContextMenu.pkg)
97397>>>Use cCJStandardMenuItemClasses.pkg
97397>>>
97397>>>Object oEditContextMenu is a cCJContextMenu
97399>>>    
97399>>>    Move Self to Default_Form_Floating_Menu_ID
97400>>>    
97400>>>    Object oUndoMenuItem is a cCJUndoMenuItem
97402>>>    End_Object
97403>>>    
97403>>>    Object oCutMenuItem is a cCJCutMenuItem
97405>>>        Set pbControlBeginGroup to True
97406>>>    End_Object
97407>>>    
97407>>>    Object oCopyMenuItem is a cCJCopyMenuItem
97409>>>    End_Object
97410>>>
97410>>>    Object oPasteMenuItem is a cCJPasteMenuItem
97412>>>    End_Object
97413>>>
97413>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
97415>>>    End_Object
97416>>>
97416>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
97418>>>        Set pbControlBeginGroup to True
97419>>>    End_Object
97420>>>
97420>>>End_Object
97421>>>
97421>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oDEOEditContextMenu17.pkg)
97421>>>Use Windows.pkg
97421>>>Use cCJStandardMenuItemClasses.pkg
97421>>>Use cCJDeoMenuItemClasses.pkg
97421>>>
97421>>>
97421>>>Object oDEOEditContextMenu17 is a cCJContextMenu
97423>>>    
97423>>>    Move Self to Default_dbFloating_Menu_ID
97424>>>    
97424>>>    Object oUndoMenuItem is a cCJUndoMenuItem
97426>>>    End_Object
97427>>>    
97427>>>    Object oCutMenuItem is a cCJCutMenuItem
97429>>>        Set pbControlBeginGroup to True
97430>>>    End_Object
97431>>>    
97431>>>    Object oCopyMenuItem is a cCJCopyMenuItem
97433>>>    End_Object
97434>>>
97434>>>    Object oPasteMenuItem is a cCJPasteMenuItem
97436>>>    End_Object
97437>>>
97437>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
97439>>>    End_Object
97440>>>
97440>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
97442>>>        Set pbControlBeginGroup to True
97443>>>    End_Object
97444>>>
97444>>>    Object oPromptMenuItem is a cCJPromptMenuItem
97446>>>        Set pbControlBeginGroup to True
97447>>>    End_Object
97448>>>
97448>>>    Object oFindNextMenu is a cCJFindNextMenuItem
97450>>>        Set pbControlBeginGroup to True
97451>>>    End_Object
97452>>>
97452>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
97454>>>    End_Object
97455>>>
97455>>>    Object oClearMenuItem is a cCJClearMenuItem
97457>>>        Set pbControlBeginGroup to True
97458>>>    End_Object
97459>>>
97459>>>    Object oClearAllMenu is a cCJClearAllMenuItem
97461>>>    End_Object
97462>>>
97462>>>    Object oSaveMenu is a cCJSaveMenuItem
97464>>>    End_Object
97465>>>    
97465>>>    Object oDeleteMenu is a cCJDeleteMenuItem
97467>>>    End_Object
97468>>>
97468>>>    Object oRememberitem is a cCJRememberFieldMenuItem
97470>>>        Set pbControlBeginGroup to True
97471>>>    End_Object
97472>>>
97472>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
97474>>>    End_Object
97475>>>
97475>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
97477>>>    End_Object
97478>>>
97478>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
97480>>>    End_Object
97481>>>
97481>>>End_Object
97482>
97482>Object oMain is a Panel
97484>    Set Label to (psProduct(ghoApplication))
97485>    Set Location to 105 166
97486>    Set Size to 196 493
97487>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
97488>    Set Icon to "SQLConnections.ico"
97489>
97489>    Object oCommandBarSystem is a cCJCommandBarSystem
97491>        Set pbTimerUpdate to True
97492>            Set pbAutoResizeIcons to True
97493>
97493>        Procedure OnCreateCommandBars
97496>            Handle hoOptions
97496>            Get OptionsObject to hoOptions
97497>            Forward Send OnCreateCommandBars
97499>        End_Procedure
97500>
97500>        Object oStatusBar is a cCJStatusBar
97502>
97502>            Object oStatusPane1 is a cCJStatusBarPane
97504>                Set pbStyleStretch to True
97505>            End_Object
97506>
97506>            Object oStatusPane2 is a cCJStatusBarPane
97508>                Set phoViewPane to Self
97509>                Set pbStyleStretch to True
97510>                Set piTextColor to clRed
97511>            End_Object
97512>
97512>        End_Object
97513>
97513>    End_Object
97514>
97514>    Object oClientArea is a ClientArea
97516>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StdAbout.pkg)
97516>>>//************************************************************************
97516>>>// Confidential Trade Secret.
97516>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
97516>>>// as an unpublished work.  All rights reserved.
97516>>>// DataFlex is a registered trademark of Data Access Corporation.
97516>>>//
97516>>>//************************************************************************
97516>>>//************************************************************************
97516>>>//
97516>>>// $File name  : StdAbout.pkg
97516>>>// $File title : Standard about object package for VDF
97516>>>// Notice      :
97516>>>// $Author(s)  : John Tuohy
97516>>>//
97516>>>// $Rev History
97516>>>//
97516>>>// JT 06/27/97   File created
97516>>>//************************************************************************
97516>>>
97516>>>// This provides a quick and simple way to create an about package for a program.
97516>>>// You need to create a message inside you client area called Activate_About.
97516>>>// Within this message you should send the message DoAbout passing needed
97516>>>// string information.
97516>>>//
97516>>>//       Procedure Activate_About
97516>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
97516>>>//       End_Procedure
97516>>>//    where: sTitle =     Name of application. If none provided, uses caption
97516>>>//                        bar title
97516>>>//           sVersion   = Version Line. If none provided, will be blank
97516>>>//           sCopyRight = Copyright Line. If none provided, will be blank
97516>>>//           sAuthor    = Author name, blank if none provided
97516>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
97516>>>//                        is used.
97516>>>// It is expected that you will place this in your own object package. For
97516>>>// example an order about package may look like this:
97516>>>//
97516>>>//   // OrderAbout.pkg
97516>>>//   Use StdAbout.pkg
97516>>>//   Procedure Activate_About
97516>>>//      String sTitle sCopyright sVersion sAuthor
97516>>>//      Move "My Order Entry System" to sTitle
97516>>>//      Move "Version 2.1" to sVersion
97516>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
97516>>>//      Move "John Smith"  to sAuthor
97516>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
97516>>>//   end_procedure
97516>>>//   // end of file.
97516>>>
97516>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DfAbout.pkg)
97516>>>>>//************************************************************************
97516>>>>>// Confidential Trade Secret.
97516>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
97516>>>>>// as an unpublished work.  All rights reserved.
97516>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
97516>>>>>//
97516>>>>>//************************************************************************
97516>>>>>//************************************************************************
97516>>>>>//
97516>>>>>// $File name  : DfAbout.pkg
97516>>>>>// $File title : About class support
97516>>>>>// Notice      :
97516>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
97516>>>>>//
97516>>>>>// $Rev History
97516>>>>>//
97516>>>>>// NGS 08/16/2013 Improved by using a cRichEdit object were the params gets added to.
97516>>>>>//                The objects that previously were popupated with values from the params,
97516>>>>>//                and their corresponding "Procedure Set..." messages, were removed as
97516>>>>>//                the edit object is used instead.
97516>>>>>//                The number of params to the DoAbout procedure was increased to ten, so
97516>>>>>//                it is easier to add whatever extra text strings needed/wanted.
97516>>>>>//                The StdAbout.pkg was also changed for this to work. It allows for an extra
97516>>>>>//                five new params to be passed, but these new params are all optional.
97516>>>>>//                So the interface will work exactly as before - if no extra parameters are passed.
97516>>>>>//                Also added an extra bitmap object to show the "Powered By Visual DataFlex" logo, in
97516>>>>>//                the lower left corner of the About object, beneath the "main" About bitmap.
97516>>>>>//                Note: It is assumed that the bitmap "PoweredByVisualDataFlex.bmp" exists.
97516>>>>>//                The background was changed to clWhite for easier usage of bitmaps. Just set the background
97516>>>>>//                color of your bitmap to white and the bitmap will not look jagged.
97516>>>>>//                If an Internet address is passed as one of the params, it will be underlined and clickable.
97516>>>>>//                An e-mail address can also be passed; e.g. "E-mail: mailto:mail@myemailaccount.com" and will
97516>>>>>//                also be clickable.
97516>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
97516>>>>>//                Windows for the size first.
97516>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
97516>>>>>//                with anchor technique. Removed unnessary property in the
97516>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
97516>>>>>//                object To better look in Windows XP. Repositioned the close
97516>>>>>//                button in the sysinfo dialog To line up with the display area
97516>>>>>//                Replaced obsolete code and techniques. Removed dead code.
97516>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
97516>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
97516>>>>>//                the global Workspace object, if it is present
97516>>>>>// JJT 11/05/98   Added version information
97516>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
97516>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
97516>>>>>//                workspace package.
97516>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
97516>>>>>//                class can create this object.
97516>>>>>//                Cleaned up the interface (used correct classes and messages)
97516>>>>>//                Added workspace reporting support To sys-info.
97516>>>>>//                Turned off wrapping in the sys-info editor.
97516>>>>>// KR  ??/??/96   File created
97516>>>>>//************************************************************************
97516>>>>>Use LanguageText.pkg
97516>>>>>Use Windows.pkg
97516>>>>>Use DFbitmap.pkg
97516>>>>>Use GlobalFunctionsProcedures.pkg
97516>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cRichEdit.pkg)
97516>>>>>>>use Windows.pkg
97516>>>>>>>Use cEdit_Mixin.pkg
97516>>>>>>>
97516>>>>>>>// DFO: cRichEdit.Dfo
97516>>>>>>>// DFC: cRichEdit.Dfc
97516>>>>>>>
97516>>>>>>>// constants used for RichEdit Properties
97516>>>>>>>// peAlignment 
97516>>>>>>>Enum_List 
97516>>>>>>>    Define alLeft   for 1 
97516>>>>>>>    Define alRight  for 2 
97516>>>>>>>    Define alCenter for 3 
97516>>>>>>>End_Enum_List 
97516>>>>>>>
97516>>>>>>>// peBullets 
97516>>>>>>>Enum_List 
97516>>>>>>>    Define buNone 
97516>>>>>>>    Define buBullets 
97516>>>>>>>    Define buArabicNumbers 
97516>>>>>>>    Define buLowerLetters 
97516>>>>>>>    Define buUpperLetters 
97516>>>>>>>    Define buLowerRomans 
97516>>>>>>>    Define buUpperRomans 
97516>>>>>>>End_Enum_List 
97516>>>>>>>
97516>>>>>>>// peBulletStyle 
97516>>>>>>>Enum_List 
97516>>>>>>>    Define busRightParen   for 0 
97516>>>>>>>    Define busEncloseParen for 256 
97516>>>>>>>    Define busPeriod       for 512 
97516>>>>>>>    Define busNumberOnly   for 768 
97516>>>>>>>    Define busNoDisplay    for 1024 
97516>>>>>>>End_Enum_List
97516>>>>>>>    
97516>>>>>>>// peLineSpacingType
97516>>>>>>>Enum_List 
97516>>>>>>>    Define lstSingle
97516>>>>>>>    Define lstSingleAndOneHalf
97516>>>>>>>    Define lstDouble
97516>>>>>>>End_Enum_List
97516>>>>>>>
97516>>>>>>>Class cRichEdit Is A DFBaseRichEdit
97517>>>>>>>
97517>>>>>>>    Procedure Construct_Object
97519>>>>>>>        Forward Send Construct_Object
97521>>>>>>>        Send Define_cEdit_Mixin
97522>>>>>>>
97522>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
97523>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
97524>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
97525>>>>>>>
97525>>>>>>>    End_Procedure // Construct_Object
97526>>>>>>>
97526>>>>>>>    Import_Class_Protocol cEdit_Mixin
97527>>>>>>>    
97527>>>>>>>    Procedure ToggleBold
97529>>>>>>>        Set pbBold to (not(pbBold(self))) 
97530>>>>>>>    end_procedure
97531>>>>>>>    
97531>>>>>>>    Procedure ToggleItalics
97533>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
97534>>>>>>>    end_procedure
97535>>>>>>>    
97535>>>>>>>    Procedure ToggleUnderline
97537>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
97538>>>>>>>    end_procedure
97539>>>>>>>
97539>>>>>>>End_Class
97540>>>>>>>
97540>>>>>Use cTextEdit.pkg
97540>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\gFormatNumbers.pkg)
97540>>>>>>>//****************************************************************************//
97540>>>>>>>//                                                                            //
97540>>>>>>>// $File name  : gFormatNumbers.pkg                                           //
97540>>>>>>>// $File title : Globals for formating numbers and currency                   //
97540>>>>>>>// Notice      :                                                              //
97540>>>>>>>// $Author(s)  : John Tuohy                                                   //
97540>>>>>>>//                                                                            //
97540>>>>>>>// Confidential Trade Secret.                                                 //
97540>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
97540>>>>>>>// All Rights reserved                                                        //
97540>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
97540>>>>>>>// $Rev History                                                               //
97540>>>>>>>//                                                                            //
97540>>>>>>>// 25.08.99 Created                                                           //
97540>>>>>>>//****************************************************************************//
97540>>>>>>>
97540>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cFormatter.pkg)
97540>>>>>>>>>//****************************************************************************//
97540>>>>>>>>>//                                                                            //
97540>>>>>>>>>// $File name  : cFormatter.pkg                                               //
97540>>>>>>>>>// $File title : cFormatter class (private class)                             //
97540>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
97540>>>>>>>>>//                                                                            //
97540>>>>>>>>>// Confidential Trade Secret.                                                 //
97540>>>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
97540>>>>>>>>>// All Rights reserved                                                        //
97540>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
97540>>>>>>>>>//                                                                            //
97540>>>>>>>>>// $Rev History                                                               //
97540>>>>>>>>>//                                                                            //
97540>>>>>>>>>// 25.08.99 Created                                                           //
97540>>>>>>>>>//****************************************************************************//
97540>>>>>>>>>use VDFBase.pkg
97540>>>>>>>>>
97540>>>>>>>>>Class cFormatter is an cObject
97541>>>>>>>>>
97541>>>>>>>>>    Procedure Construct_object
97543>>>>>>>>>        Integer iCh
97543>>>>>>>>>        forward send construct_object
97545>>>>>>>>>        Property String  psCurrencySymbol
97546>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
97547>>>>>>>>>
97547>>>>>>>>>        Property string  psLeft
97548>>>>>>>>>        Property string  psright
97549>>>>>>>>>        Property integer pbThousandsSep
97550>>>>>>>>>        Property integer piPoints
97551>>>>>>>>>
97551>>>>>>>>>        Property string  psCurPosLeft
97552>>>>>>>>>        Property string  psCurPosright
97553>>>>>>>>>        Property integer pbCurPosThousandsSep
97554>>>>>>>>>        Property integer piCurPosPoints
97555>>>>>>>>>
97555>>>>>>>>>        Property string  psCurNegLeft
97556>>>>>>>>>        Property string  psCurNegright
97557>>>>>>>>>        Property integer pbCurNegThousandsSep
97558>>>>>>>>>        Property integer piCurNegPoints
97559>>>>>>>>>
97559>>>>>>>>>        Property string  psNumPosLeft
97560>>>>>>>>>        Property string  psNumPosright
97561>>>>>>>>>        Property integer pbNumPosThousandsSep
97562>>>>>>>>>        Property integer piNumPosPoints
97563>>>>>>>>>
97563>>>>>>>>>        Property string  psNumNegLeft
97564>>>>>>>>>        Property string  psNumNegright
97565>>>>>>>>>        Property integer pbNumNegThousandsSep
97566>>>>>>>>>        Property integer piNumNegPoints
97567>>>>>>>>>
97567>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" true  // currency
97568>>>>>>>>>        Send SetFormat  ",#.*"           false // numeric
97569>>>>>>>>>
97569>>>>>>>>>    end_procedure
97570>>>>>>>>>
97570>>>>>>>>>    // internal
97570>>>>>>>>>    // parse passed format string and set temporary properties with result
97570>>>>>>>>>    //
97570>>>>>>>>>    Procedure ParseFormat string sFmt
97572>>>>>>>>>
97572>>>>>>>>>        string sLeft sRight sDigit
97572>>>>>>>>>        integer bSep iPos i iDigits
97572>>>>>>>>>
97572>>>>>>>>>        // replace any literals. A "/" followed by anything.
97572>>>>>>>>>        // some literals are special. $ . , / #
97572>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
97573>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
97574>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
97575>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
97576>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
97577>>>>>>>>>        Move (Character(9)) to sDigit
97578>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
97579>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
97580>>>>>>>>>
97580>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
97581>>>>>>>>>        If bSep Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
97584>>>>>>>>>
97584>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(self))) to sFmt // replace any $ with currency symbol
97585>>>>>>>>>
97585>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
97586>>>>>>>>>
97586>>>>>>>>>        // Move all the special literals back into place before parsing
97586>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
97587>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
97588>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
97589>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
97590>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
97591>>>>>>>>>
97591>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
97593>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
97594>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
97596>>>>>>>>>               Move -2 to iDigits
97597>>>>>>>>>               increment i
97598>>>>>>>>>            end
97598>>>>>>>>>>
97598>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
97602>>>>>>>>>                 Increment i
97603>>>>>>>>>            end
97604>>>>>>>>>>
97604>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
97605>>>>>>>>>            If (iDigits=0) Move (i-1) to iDigits
97608>>>>>>>>>            //
97608>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
97609>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
97613>>>>>>>>>                 increment i
97614>>>>>>>>>            end
97615>>>>>>>>>>
97615>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
97616>>>>>>>>>        end
97616>>>>>>>>>>
97616>>>>>>>>>        else begin                             // we have no decinal
97617>>>>>>>>>            Move 0 to iDigits                  // so points is none
97618>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
97619>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
97621>>>>>>>>>                Move sFmt to sLeft
97622>>>>>>>>>                Move ""   to sRight
97623>>>>>>>>>            end
97623>>>>>>>>>>
97623>>>>>>>>>            else begin
97624>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
97625>>>>>>>>>                Move 1 to i
97626>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
97630>>>>>>>>>                    Increment i
97631>>>>>>>>>                end
97632>>>>>>>>>>
97632>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
97633>>>>>>>>>            end
97633>>>>>>>>>>
97633>>>>>>>>>        end
97633>>>>>>>>>>
97633>>>>>>>>>        // set temporary format properties and exit
97633>>>>>>>>>        Set pbThousandsSep to bSep
97634>>>>>>>>>        set psLeft         to sLeft
97635>>>>>>>>>        set psRight        to sRight
97636>>>>>>>>>        Set piPoints       to iDigits
97637>>>>>>>>>     End_procedure
97638>>>>>>>>>
97638>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
97638>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
97638>>>>>>>>>    //
97638>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
97638>>>>>>>>>    //
97638>>>>>>>>>    Procedure SetFormat string sFmt integer bCurrency
97640>>>>>>>>>        string sPos sNeg
97640>>>>>>>>>        integer iPos
97640>>>>>>>>>
97640>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
97641>>>>>>>>>        If iPos begin
97643>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
97644>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
97645>>>>>>>>>        end
97645>>>>>>>>>>
97645>>>>>>>>>        else Begin
97646>>>>>>>>>            Move sFmt         to sPos
97647>>>>>>>>>            Move ("-" + sFmt) to sNeg
97648>>>>>>>>>        end
97648>>>>>>>>>>
97648>>>>>>>>>        Send ParseFormat sPos
97649>>>>>>>>>        If bCurrency begin
97651>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(self))
97652>>>>>>>>>            set psCurPosLeft         to (psLeft(self))
97653>>>>>>>>>            set psCurPosRight        to (psRight(self))
97654>>>>>>>>>            Set piCurPosPoints       to (piPoints(self))
97655>>>>>>>>>        End
97655>>>>>>>>>>
97655>>>>>>>>>        else Begin
97656>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(self))
97657>>>>>>>>>            set psNumPosLeft         to (psLeft(self))
97658>>>>>>>>>            set psNumPosRight        to (psRight(self))
97659>>>>>>>>>            Set piNumPosPoints       to (piPoints(self))
97660>>>>>>>>>        end
97660>>>>>>>>>>
97660>>>>>>>>>
97660>>>>>>>>>        Send ParseFormat sNeg
97661>>>>>>>>>        If bCurrency begin
97663>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(self))
97664>>>>>>>>>            set psCurNegLeft         to (psLeft(self))
97665>>>>>>>>>            set psCurNegRight        to (psRight(self))
97666>>>>>>>>>            Set piCurNegPoints       to (piPoints(self))
97667>>>>>>>>>        End
97667>>>>>>>>>>
97667>>>>>>>>>        else Begin
97668>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(self))
97669>>>>>>>>>            set psNumNegLeft         to (psLeft(self))
97670>>>>>>>>>            set psNumNegRight        to (psRight(self))
97671>>>>>>>>>            Set piNumNegPoints       to (piPoints(self))
97672>>>>>>>>>        end
97672>>>>>>>>>>
97672>>>>>>>>>    End_procedure
97673>>>>>>>>>
97673>>>>>>>>>    // low level formatting. Pass parameters
97673>>>>>>>>>    Function Format_Num number nNumber integer iPoints integer bSep ;                       string sPrefix string sSuffix returns string
97675>>>>>>>>>        string  sLeft sRight sNumber sSep sDec
97675>>>>>>>>>        integer bIsNegative iDec iLen iCh
97675>>>>>>>>>
97675>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
97678>>>>>>>>>        Move (Character(iCh)) to sDec
97679>>>>>>>>>
97679>>>>>>>>>        Move (abs(nNumber)) to sNumber
97680>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
97681>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
97682>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
97683>>>>>>>>>        // format for decimal separator
97683>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+repeat("0",iPoints),iPoints)) to sRight
97686>>>>>>>>>
97686>>>>>>>>>        // format for thousand sep.
97686>>>>>>>>>        If bSep Begin
97688>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
97691>>>>>>>>>            Move (Character(iCh)) to sSep
97692>>>>>>>>>            Move (Length(sLeft)) to iLen
97693>>>>>>>>>            While (iLen>3)
97697>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
97698>>>>>>>>>                Move (iLen-3) to iLen
97699>>>>>>>>>            End
97700>>>>>>>>>>
97700>>>>>>>>>        End
97700>>>>>>>>>>
97700>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
97700>>>>>>>>>        If (iPoints>0 OR (iPoints=-2 AND sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
97703>>>>>>>>>        Function_return (sPrefix + sLeft+ sSuffix)
97704>>>>>>>>>    End_Function
97705>>>>>>>>>
97705>>>>>>>>>    // Public: Format for currency
97705>>>>>>>>>    //
97705>>>>>>>>>    Function FormatCur number nNumber integer iPoints returns string
97707>>>>>>>>>        string  sLeft sRight
97707>>>>>>>>>        integer bSep
97707>>>>>>>>>        If (nNumber<0) Begin
97709>>>>>>>>>            get pbCurNegThousandsSep to bSep
97710>>>>>>>>>            get psCurNegLeft         to sLeft
97711>>>>>>>>>            get psCurNegRight        to sRight
97712>>>>>>>>>            If (iPoints=-1) get piCurNegPoints       to iPoints
97715>>>>>>>>>        end
97715>>>>>>>>>>
97715>>>>>>>>>        Else Begin
97716>>>>>>>>>            get pbCurPosThousandsSep to bSep
97717>>>>>>>>>            get psCurPosLeft         to sLeft
97718>>>>>>>>>            get psCurPosRight        to sRight
97719>>>>>>>>>            If (iPoints=-1) get piCurPosPoints       to iPoints
97722>>>>>>>>>        end
97722>>>>>>>>>>
97722>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
97723>>>>>>>>>    End_function
97724>>>>>>>>>
97724>>>>>>>>>    // Public: Format for numeric
97724>>>>>>>>>    //
97724>>>>>>>>>    Function FormatNum number nNumber integer iPoints returns string
97726>>>>>>>>>        string  sLeft sRight
97726>>>>>>>>>        integer bSep
97726>>>>>>>>>        If (nNumber<0) Begin
97728>>>>>>>>>            get pbNumNegThousandsSep to bSep
97729>>>>>>>>>            get psNumNegLeft         to sLeft
97730>>>>>>>>>            get psNumNegRight        to sRight
97731>>>>>>>>>            If (iPoints=-1) get piNumNegPoints       to iPoints
97734>>>>>>>>>        end
97734>>>>>>>>>>
97734>>>>>>>>>        Else Begin
97735>>>>>>>>>            get pbNumPosThousandsSep to bSep
97736>>>>>>>>>            get psNumPosLeft         to sLeft
97737>>>>>>>>>            get psNumPosRight        to sRight
97738>>>>>>>>>            If (iPoints=-1) get piNumPosPoints       to iPoints
97741>>>>>>>>>        end
97741>>>>>>>>>>
97741>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
97742>>>>>>>>>    End_function
97743>>>>>>>>>
97743>>>>>>>>>
97743>>>>>>>>>    // Public: Format passing format string
97743>>>>>>>>>    //
97743>>>>>>>>>    Function FormatVal number nNumber string sFmt returns string
97745>>>>>>>>>        integer iPos bIsNeg
97745>>>>>>>>>        string  sLeft sRight
97745>>>>>>>>>        integer iPoints bSep
97745>>>>>>>>>        Move (nNumber<0) to bIsNeg
97746>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
97747>>>>>>>>>        Case Begin
97747>>>>>>>>>            Case (iPos and Not(bIsNeg))      Move (left(sFmt,iPos-1))    to sFmt
97750>>>>>>>>>            Case (iPos and bIsNeg)           Move (mid(sFmt,255,iPos+1)) to sFmt
97754>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) Move sFmt                   to sFmt
97758>>>>>>>>>            Case else                        Move ("-" + sFmt)           to sFmt
97760>>>>>>>>>        case end
97760>>>>>>>>>        Send ParseFormat sFmt
97761>>>>>>>>>        get pbThousandsSep to bSep
97762>>>>>>>>>        get psLeft         to sLeft
97763>>>>>>>>>        get psRight        to sRight
97764>>>>>>>>>        get piPoints       to iPoints
97765>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
97766>>>>>>>>>    end_function
97767>>>>>>>>>
97767>>>>>>>>>End_Class
97768>>>>>>>
97768>>>>>>>// for now, this object is private. All access is through the following
97768>>>>>>>// global functions
97768>>>>>>>
97768>>>>>>>//Object oFmt is a cFormatter
97768>>>>>>>//end_object
97768>>>>>>>
97768>>>>>>>Global_variable handle ghoFormatter
97768>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
97769>>>>>>>
97769>>>>>>>Function FormatNumber Global number nNum integer iPoints returns string
97771>>>>>>>    Function_return (FormatNum(ghoFormatter, nNum,iPoints))
97772>>>>>>>end_function
97773>>>>>>>
97773>>>>>>>Function FormatCurrency Global number nNum integer iPoints returns string
97775>>>>>>>    Function_return (FormatCur(ghoFormatter, nNum,iPoints))
97776>>>>>>>end_function
97777>>>>>>>
97777>>>>>>>Function FormatValue Global number nNum string sFmt returns string
97779>>>>>>>    Function_return (FormatVal(ghoFormatter, nNum,sFmt))
97780>>>>>>>end_function
97781>>>>>>>
97781>>>>>>>Procedure SetCurrencyFormat Global string sFmt
97783>>>>>>>    Send SetFormat of ghoFormatter sFmt True
97784>>>>>>>end_function
97785>>>>>>>
97785>>>>>>>Procedure SetNumberFormat Global string sFmt
97787>>>>>>>    Send SetFormat of ghoFormatter sFmt False
97788>>>>>>>end_function
97789>>>>>>>
97789>>>>>Use MapiDllCalls.Pkg
Including file: MapiDllCalls.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiDllCalls.Pkg)
97789>>>>>>>Use MapiConstants.Pkg
Including file: MapiConstants.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiConstants.Pkg)
97789>>>>>>>>>Type MapiSession
97789>>>>>>>>>   Field MapiSession.SessionID As Integer
97789>>>>>>>>>End_type // MapiSession
97789>>>>>>>>>
97789>>>>>>>>>Type MapiMessagePointer
97789>>>>>>>>>   Field MapiMessagePointer.lppMessage As Pointer
97789>>>>>>>>>End_Type // MapiMessagePointer
97789>>>>>>>>>
97789>>>>>>>>>Type MapiRecipPointer
97789>>>>>>>>>   Field MapiRecipPointer.lppRecip As Pointer
97789>>>>>>>>>End_Type // MapiRecipPointer
97789>>>>>>>>>
97789>>>>>>>>>Type MapiNewRecipsPointer
97789>>>>>>>>>   Field MapiNewRecipsPointer.lppNewRecips As Pointer
97789>>>>>>>>>End_Type // MapiNewRecipsPointer
97789>>>>>>>>>
97789>>>>>>>>>Type MapiNewRecipsCounter
97789>>>>>>>>>   Field MapiNewRecipsCounter.lpnNewRecips As Integer
97789>>>>>>>>>End_Type // MapiNewRecipsCounter
97789>>>>>>>>>
97789>>>>>>>>>Type MapiFileDesc
97789>>>>>>>>>   Field MapiFileDesc.ulReserved As Integer      // Reserved for future use (must be 0)
97789>>>>>>>>>   Field MapiFileDesc.flFlags As Integer         // Flags
97789>>>>>>>>>   Field MapiFileDesc.nPosition As Integer       // character in text to be replaced by attachment
97789>>>>>>>>>   Field MapiFileDesc.lpszPathName As Pointer    // Full path name of attachment file
97789>>>>>>>>>   Field MapiFileDesc.lpszFileName As Pointer    // Original file name (optional)
97789>>>>>>>>>   Field MapiFileDesc.lpFileType As Pointer     // Attachment file type (can be lpMapiFileTagExt)
97789>>>>>>>>>End_Type // MapiFileDesc
97789>>>>>>>>>
97789>>>>>>>>>Define MAPI_OLE        For |CI$00000001
97789>>>>>>>>>Define MAPI_OLE_STATIC For |CI$00000002
97789>>>>>>>>>
97789>>>>>>>>>Define MAPI_NOATTACHMENT_POSITION For |CI$FFFFFFFF
97789>>>>>>>>>
97789>>>>>>>>>Type MapiFileTagExt
97789>>>>>>>>>   Field MapiFileTagExt.ulReserved As Integer  // Reserved, must be zero.
97789>>>>>>>>>   Field MapiFileTagExt.cbTag As Integer       // Size (in bytes) of
97789>>>>>>>>>   Field MapiFileTagExt.lpTag As Pointer       // X.400 OID for this attachment type
97789>>>>>>>>>   Field MapiFileTagExt.cbEncoding As Integer  // Size (in bytes) of
97789>>>>>>>>>   Field MapiFileTagExt.lpEncoding As Pointer  // X.400 OID for this attachment's encoding
97789>>>>>>>>>End_Type // MapiFileTagExt
97789>>>>>>>>>
97789>>>>>>>>>Type MapiRecipDesc
97789>>>>>>>>>   Field MapiRecipDesc.ulReserved As Integer   // Reserved for future use
97789>>>>>>>>>   Field MapiRecipDesc.ulRecipClass As Integer // Recipient class
97789>>>>>>>>>                                               // MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG
97789>>>>>>>>>   Field MapiRecipDesc.lpszName As Pointer     // Recipient name
97789>>>>>>>>>   Field MapiRecipDesc.lpszAddress As Pointer  // Recipient address (optional)
97789>>>>>>>>>   Field MapiRecipDesc.ulEIDSize As Pointer    // Count in bytes of size of pEntryID
97789>>>>>>>>>   Field MapiRecipDesc.lpEntryID As Pointer    // System-specific recipient reference
97789>>>>>>>>>End_Type // MapiRecipDesc
97789>>>>>>>>>
97789>>>>>>>>>Define MAPI_ORIG   For 0 // Recipient is message originator
97789>>>>>>>>>Define MAPI_TO     For 1 // Recipient is a primary recipient
97789>>>>>>>>>Define MAPI_CC     For 2 // Recipient is a copy recipient
97789>>>>>>>>>Define MAPI_BCC    For 3 // Recipient is blind copy recipient
97789>>>>>>>>>
97789>>>>>>>>>Type MapiMessage
97789>>>>>>>>>   Field MapiMessage.ulReserved As Integer                   // Reserved for future use (M.B. 0)
97789>>>>>>>>>   Field MapiMessage.lpszSubject As Pointer                  // Message Subject
97789>>>>>>>>>   Field MapiMessage.lpszNoteText As Pointer                 // Message Text
97789>>>>>>>>>   Field MapiMessage.lpszMessageType As Pointer              // Message Class
97789>>>>>>>>>   Field MapiMessage.lpszDateReceived As Pointer             // in YYYY/MM/DD HH:MM format
97789>>>>>>>>>   Field MapiMessage.lpszConversationID As Pointer           // conversation thread ID
97789>>>>>>>>>   Field MapiMessage.flFlags As Integer                      // unread,return receipt
97789>>>>>>>>>   Field MapiMessage.lpOriginator As Pointer                 // Originator descriptor
97789>>>>>>>>>   Field MapiMessage.nRecipCount As Integer                  // Number of recipients
97789>>>>>>>>>   Field MapiMessage.lpRecips As Pointer                     // Recipient descriptors
97789>>>>>>>>>   Field MapiMessage.nFileCount As Integer                   // # of file attachments
97789>>>>>>>>>   Field MapiMessage.lpFiles As Pointer                      // Attachment descriptors
97789>>>>>>>>>End_Type // MapiMessage
97789>>>>>>>>>
97789>>>>>>>>>Define MAPI_UNREAD            For |CI$00000001
97789>>>>>>>>>Define MAPI_RECEIPT_REQUESTED For |CI$00000002
97789>>>>>>>>>Define MAPI_SENT              For |CI$00000004
97789>>>>>>>>>
97789>>>>>>>>>// MAPILogon() flags.
97789>>>>>>>>>Define MAPI_LOGON_UI         For |CI$00000001 // Display logon UI
97789>>>>>>>>>Define MAPI_PASSWORD_UI      For |CI$00020000 // prompt for password only
97789>>>>>>>>>Define MAPI_NEW_SESSION      For |CI$00000002 // Don't use shared session
97789>>>>>>>>>Define MAPI_FORCE_DOWNLOAD   For |CI$00001000 // Get new mail before return
97789>>>>>>>>>Define MAPI_ALLOW_OTHERS     For |CI$00000008 // Make this a shared session
97789>>>>>>>>>Define MAPI_EXPLICIT_PROFILE For |CI$00000010 // Don't use default profile
97789>>>>>>>>>Define MAPI_EXTENDED         For |CI$00000020 // Extended MAPI Logon
97789>>>>>>>>>Define MAPI_USE_DEFAULT      For |CI$00000040 // Use default profile in logon
97789>>>>>>>>>
97789>>>>>>>>>Define MAPI_SIMPLE_DEFAULT  For (MAPI_LOGON_UI + MAPI_FORCE_DOWNLOAD + MAPI_ALLOW_OTHERS)
97789>>>>>>>>>Define MAPI_SIMPLE_EXPLICIT For (MAPI_NEW_SESSION + MAPI_FORCE_DOWNLOAD + MAPI_EXPLICIT_PROFILE)
97789>>>>>>>>>
97789>>>>>>>>>// MAPILogoff() flags.
97789>>>>>>>>>Define MAPI_LOGOFF_SHARED For |CI$00000001 // Close all shared sessions
97789>>>>>>>>>Define MAPI_LOGOFF_UI     For |CI$00000002 // It's OK to present UI
97789>>>>>>>>>
97789>>>>>>>>>// MAPISendMail() flags.
97789>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
97789>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
97789>>>>>>>>>
97789>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Display a send note UI
97789>>>>>>>>>Define MAPI_USE_DEFAULT For |CI$00000040 // Use default profile in logon
97789>>>>>>>>>
97789>>>>>>>>>// MAPIFindNext() flags.
97789>>>>>>>>>Define MAPI_UNREAD_ONLY    For |CI$00000020 // Only unread messages
97789>>>>>>>>>Define MAPI_GUARANTEE_FIFO For |CI$00000100 // use date order
97789>>>>>>>>>Define MAPI_LONG_MSGID     For |CI$00004000 // allow 512 char returned ID
97789>>>>>>>>>
97789>>>>>>>>>// MAPIReadMail() flags.
97789>>>>>>>>>Define MAPI_PEEK            For |CI$00000080 // Do not mark as read.
97789>>>>>>>>>Define MAPI_SUPPRESS_ATTACH For |CI$00000800 // header + body, no files
97789>>>>>>>>>Define MAPI_ENVELOPE_ONLY   For |CI$00000040 // Only header information
97789>>>>>>>>>Define MAPI_BODY_AS_FILE    For |CI$00000200
97789>>>>>>>>>
97789>>>>>>>>>// MAPISaveMail() flags.
97789>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
97789>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
97789>>>>>>>>>Define MAPI_LONG_MSGID  For |CI$00004000 // allow 512 char returned ID
97789>>>>>>>>>
97789>>>>>>>>>// MAPIAddress() flags.
97789>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
97789>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
97789>>>>>>>>>
97789>>>>>>>>>// MAPIDetails() flags.
97789>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
97789>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
97789>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
97789>>>>>>>>>
97789>>>>>>>>>// MAPIResolveName() flags.
97789>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
97789>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
97789>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Prompt for choices if ambiguous
97789>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
97789>>>>>>>>>
97789>>>>>>>>>Define SUCCESS_SUCCESS                 For 0
97789>>>>>>>>>Define MAPI_USER_ABORT                 For 1
97789>>>>>>>>>Define MAPI_E_USER_ABORT               For MAPI_USER_ABORT
97789>>>>>>>>>Define MAPI_E_FAILURE                  For 2
97789>>>>>>>>>Define MAPI_E_LOGON_FAILURE            For 3
97789>>>>>>>>>Define MAPI_E_LOGIN_FAILURE            For MAPI_E_LOGON_FAILURE
97789>>>>>>>>>Define MAPI_E_DISK_FULL                For 4
97789>>>>>>>>>Define MAPI_E_INSUFFICIENT_MEMORY      For 5
97789>>>>>>>>>Define MAPI_E_ACCESS_DENIED            For 6
97789>>>>>>>>>Define MAPI_E_TOO_MANY_SESSIONS        For 8
97789>>>>>>>>>Define MAPI_E_TOO_MANY_FILES           For 9
97789>>>>>>>>>Define MAPI_E_TOO_MANY_RECIPIENTS      For 10
97789>>>>>>>>>Define MAPI_E_ATTACHMENT_NOT_FOUND     For 11
97789>>>>>>>>>Define MAPI_E_ATTACHMENT_OPEN_FAILURE  For 12
97789>>>>>>>>>Define MAPI_E_ATTACHMENT_WRITE_FAILURE For 13
97789>>>>>>>>>Define MAPI_E_UNKNOWN_RECIPIENT        For 14
97789>>>>>>>>>Define MAPI_E_BAD_RECIPTYPE            For 15
97789>>>>>>>>>Define MAPI_E_NO_MESSAGES              For 16
97789>>>>>>>>>Define MAPI_E_INVALID_MESSAGE          For 17
97789>>>>>>>>>Define MAPI_E_TEXT_TOO_LARGE           For 18
97789>>>>>>>>>Define MAPI_E_INVALID_SESSION          For 19
97789>>>>>>>>>Define MAPI_E_TYPE_NOT_SUPPORTED       For 20
97789>>>>>>>>>Define MAPI_E_AMBIGUOUS_RECIPIENT      For 21
97789>>>>>>>>>Define MAPI_E_AMBIG_RECIP              For MAPI_E_AMBIGUOUS_RECIPIENT
97789>>>>>>>>>Define MAPI_E_MESSAGE_IN_USE           For 22
97789>>>>>>>>>Define MAPI_E_NETWORK_FAILURE          For 23
97789>>>>>>>>>Define MAPI_E_INVALID_EDITFIELDS       For 24
97789>>>>>>>>>Define MAPI_E_INVALID_RECIPS           For 25
97789>>>>>>>>>Define MAPI_E_NOT_SUPPORTED            For 26
97789>>>>>>>Use WinKern.pkg
97789>>>>>>>
97789>>>>>>>External_Function MAPILogon "MAPILogon" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszProfileName ;   Pointer lpszPassword ;   Integer flFlags ;   Integer ulReserved ;   Pointer lplhSession ;   Returns Integer
97790>>>>>>>External_Function MAPILogoff "MAPILogoff" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
97791>>>>>>>External_Function MAPIFindNext "MAPIFindNext" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageType ;   Pointer lpszSeedMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
97792>>>>>>>External_Function MAPIFreeBuffer "MAPIFreeBuffer" Mapi32.Dll ;   Pointer pv ;   Returns Integer
97793>>>>>>>External_Function MAPIReadMail "MAPIReadMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppMessage ;   Returns Integer
97794>>>>>>>External_Function MAPIAddress "MAPIAddress" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszCaption ;   Integer nEditFields ;   Pointer lpszLabels ;   Integer nRecips ;   Pointer lpRecips ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpnNewRecips ;   Pointer lppNewRecips ;   Returns Integer
97795>>>>>>>External_Function MAPIResolveName "MAPIResolveName" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszName ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppRecip ;   Returns Integer
97796>>>>>>>External_Function MAPISendMail "MAPISendMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
97797>>>>>>>External_Function MAPISaveMail "MAPISaveMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
97798>>>>>>>External_Function MAPIDeleteMail "MAPIDeleteMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
97799>>>>>>>External_Function MAPISendDocuments "MAPISendDocuments" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszDelimChar ;   Pointer lpszFullPaths ;   Pointer lpszFileNames ;   Integer ulReserved ;   Returns Integer
97800>>>>>>>External_Function MAPIDetails "MAPIDetails" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpRecip ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
97801>>>>>>>
97801>>>>>>>External_Function ShellExecute "ShellExecuteA" Shell32.Dll ;   Handle hwnd ;   String sOperation ;   String sFile ;   String sParameters ;   String sDirectory ;   Integer nShowCmd ;   Returns VOID_TYPE
97802>>>>>Use DFBTRDRV.PKG
97802>>>>>Use MSSqldrv.pkg
97802>>>>>Use db2_drv.pkg
97802>>>>>Use odbc_drv.pkg
97802>>>>>Use seq_chnl.pkg
97802>>>>>Use Std_help.pkg
Including file: Std_help.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Std_help.pkg)
97802>>>>>>>// STD_HELP.PKG
97802>>>>>>>//
97802>>>>>>>// Global Help Object
97802>>>>>>>//
97802>>>>>>>//  Creates all Help Support required to access WINDOWs help system
97802>>>>>>>//  with DataFlex. Creates a global object named Help_Object.
97802>>>>>>>//
97802>>>>>>>//  9/19/97 JJT - Modified to define stadnard help Ids if they are undefined
97802>>>>>>>
97802>>>>>>>use DFHlpSys.pkg // Context Sensitive Help Support for Windows and HTML
Including file: Dfhlpsys.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfhlpsys.pkg)
97802>>>>>>>>>//************************************************************************
97802>>>>>>>>>//
97802>>>>>>>>>// Confidential Trade Secret.
97802>>>>>>>>>// Copyright (c) 1997-2002 Data Access Corporation, Miami Florida
97802>>>>>>>>>// as an unpublished work.  All rights reserved.
97802>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
97802>>>>>>>>>//
97802>>>>>>>>>//***********************************************************************/
97802>>>>>>>>>
97802>>>>>>>>>//************************************************************************
97802>>>>>>>>>// DFHlpSys.pkg
97802>>>>>>>>>//  12-07-1994 : Created
97802>>>>>>>>>//  8/29/2002  : major changes
97802>>>>>>>>>//
97802>>>>>>>>>// Author: John J. Tuohy
97802>>>>>>>>>//
97802>>>>>>>>>// This package loads support the windows help and html help. It used to define
97802>>>>>>>>>// a bunch of desktop help messages, but as of 8.3 those have been moved into
97802>>>>>>>>>// objects via a dfbase mixin. The only reason this package remains here is that
97802>>>>>>>>>// std_help.pkg calls it.
97802>>>>>>>>>//************************************************************************
97802>>>>>>>>>
97802>>>>>>>>>use DFHlpCl.pkg    // Define the Help_System Class for windows
Including file: Dfhlpcl.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfhlpcl.pkg)
97802>>>>>>>>>>>//************************************************************************
97802>>>>>>>>>>>//
97802>>>>>>>>>>>// Confidential Trade Secret.
97802>>>>>>>>>>>// Copyright 1997-2001 Data Access Corporation, Miami FL, USA
97802>>>>>>>>>>>// All Rights reserved
97802>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//************************************************************************
97802>>>>>>>>>>>//
97802>>>>>>>>>>>// $File name  : DFHlpCl.pkg
97802>>>>>>>>>>>// $File title : HelpSystem class support
97802>>>>>>>>>>>// Notice      :
97802>>>>>>>>>>>// $Author(s)  : John Tuohy
97802>>>>>>>>>>>//
97802>>>>>>>>>>>// $Rev History
97802>>>>>>>>>>>//
97802>>>>>>>>>>>// 07/19/01 SWB - added support for the Application object's psHelpFile
97802>>>>>>>>>>>//                to override any value in the global Workspace object
97802>>>>>>>>>>>// 11/17/97 JJT - added missing set help_filename method.
97802>>>>>>>>>>>// 10/15/97 JJT - changed define_symbol to define
97802>>>>>>>>>>>// 6/27/97  JJT - Modified low level help calls to work better in 95 help.
97802>>>>>>>>>>>// 07/23/96 JJT - New Class names
97802>>>>>>>>>>>// 01/27/96 JJT - Changed to from DAF to DF
97802>>>>>>>>>>>// 02/14/95 JJT - Added DFGSINI for 3.01/3.05 dual support of .ini name
97802>>>>>>>>>>>//                and section name.
97802>>>>>>>>>>>//************************************************************************
97802>>>>>>>>>>>// VDF8 changes
97802>>>>>>>>>>>// 10/23/2001 JJT - use ReadString instead of System_profile_string
97802>>>>>>>>>>>//************************************************************************
97802>>>>>>>>>>>
97802>>>>>>>>>>>// Help System Package
97802>>>>>>>>>>>//
97802>>>>>>>>>>>// Public Properties that should be set:
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//     Property String  Help_Filename   (Help_File_Default(self))
97802>>>>>>>>>>>//     Property Integer Help_Id_General 0
97802>>>>>>>>>>>//     Property Integer Help_Id_Index   0
97802>>>>>>>>>>>//     Property Integer Help_Id_Keys    0
97802>>>>>>>>>>>//     Property Integer Help_Id_Files   0
97802>>>>>>>>>>>//     Property Integer Help_Id_Errors  0
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//
97802>>>>>>>>>>>// Public messsages which are sent to this object:
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//    procedure View_Context_KeyWord_Help integer Obj
97802>>>>>>>>>>>//    procedure View_Context_ID_Help      integer Obj
97802>>>>>>>>>>>//    procedure View_Context_Help         integer Obj
97802>>>>>>>>>>>//    procedure View_Help_for_help        integer Obj
97802>>>>>>>>>>>//    procedure View_help_index           integer Obj
97802>>>>>>>>>>>//    procedure View_Keys_Help            integer Obj
97802>>>>>>>>>>>//    procedure View_File_Help            integer Obj
97802>>>>>>>>>>>//    procedure View_Error_Help           integer Obj
97802>>>>>>>>>>>//    procedure View_Help_on_Topic        integer Obj
97802>>>>>>>>>>>//
97802>>>>>>>>>>>// Protected Messages:
97802>>>>>>>>>>>//        These messages invoke the Window's help system and are not
97802>>>>>>>>>>>//        directly sent by outside objects. They are sent by public
97802>>>>>>>>>>>//        "view_xxx" messages and might be used if you are creating
97802>>>>>>>>>>>//        a sub-class of an object-class.
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//    Procedure Exec_System_Context_Help  integer Context_id
97802>>>>>>>>>>>//    Procedure Exec_System_Help          string  Keyword
97802>>>>>>>>>>>//    Procedure Exec_Context_Help         string  Context
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//    Functions for converting DF help IDs to windows Help Ids
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//        Any of these can return either a string or an integer.
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//    Function System_Help_Context_id Integer ID Returns String
97802>>>>>>>>>>>//           Convert a DF help context id into a windows id. By default,
97802>>>>>>>>>>>//           just return the same value (a one to one match). This is called
97802>>>>>>>>>>>//           by View_Context_id_help and View_Context_Help
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//    Function System_Help_File_Id Integer File# Integer Field# Returns String
97802>>>>>>>>>>>//           Convert file and field into a help id. By default it returns the
97802>>>>>>>>>>>//           file#. Called by View_File_Help.
97802>>>>>>>>>>>//
97802>>>>>>>>>>>//    Function System_Help_Error_id Integer Id Returns String
97802>>>>>>>>>>>//           Convert an error message into an ID. Right now it returns the
97802>>>>>>>>>>>//           the general error context id property, Help_id_errors. This
97802>>>>>>>>>>>//           will invoke general error help. If you want error support at the
97802>>>>>>>>>>>//           error# level you will have to determine the program to help
97802>>>>>>>>>>>//           interface yourself. Errors have a very large range and it is
97802>>>>>>>>>>>//           therefore hard to come up with an automatic numbering scheme.
97802>>>>>>>>>>>//           Called by View_Error_Help.
97802>>>>>>>>>>>
97802>>>>>>>>>>>
97802>>>>>>>>>>>Use Windows.pkg
97802>>>>>>>>>>>Use WinHlp.pkg // low level help call to windows API provides global message gDoWinHelp
97802>>>>>>>>>>>Use HelpSystemConstants.pkg // constants used by help system
97802>>>>>>>>>>>
97802>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
97802>>>>>>>>>>>Register_function peHelpType  returns integer
97802>>>>>>>>>>>
97802>>>>>>>>>>>class HelpSystem is an cObject
97803>>>>>>>>>>>
97803>>>>>>>>>>>    register_function Help_File_Default returns string
97803>>>>>>>>>>>
97803>>>>>>>>>>>    procedure Construct_Object
97805>>>>>>>>>>>       Forward send Construct_Object
97807>>>>>>>>>>>
97807>>>>>>>>>>>       // Help file name only. If set, this overrides all other settings.
97807>>>>>>>>>>>       Property String psHelpFile
97808>>>>>>>>>>>
97808>>>>>>>>>>>       // Help_FileName
97808>>>>>>>>>>>       //   full path name of Help file. The default value grabs its value
97808>>>>>>>>>>>       //   from .ini or environment settings. See functiob Help_file_Default
97808>>>>>>>>>>>       //
97808>>>>>>>>>>>       Property String  Private.Help_Filename (Help_File_Default(self))
97809>>>>>>>>>>>
97809>>>>>>>>>>>       // The following properties are the default values for the help files
97809>>>>>>>>>>>       // IDs for the various subjects. Setting these requires an agreement
97809>>>>>>>>>>>       // between the DF help system and the help file.
97809>>>>>>>>>>>       //
97809>>>>>>>>>>>       Property Integer Help_Id_General  0
97810>>>>>>>>>>>       Property Integer Help_Id_Index    0
97811>>>>>>>>>>>       Property Integer Help_Id_Keys     0
97812>>>>>>>>>>>       Property Integer Help_Id_Files    0
97813>>>>>>>>>>>       Property Integer Help_Id_Errors   0
97814>>>>>>>>>>>
97814>>>>>>>>>>>       // this is now the default help object
97814>>>>>>>>>>>       Move self to Help_Object_id
97815>>>>>>>>>>>    End_Procedure
97816>>>>>>>>>>>
97816>>>>>>>>>>>   // New rules for VDF8:
97816>>>>>>>>>>>   // 1. If psHelpFile exists, find the file in the file path and use it
97816>>>>>>>>>>>   // 2. If application object exists and help type is windows, use psHelpFile from there, find in file path and use it.
97816>>>>>>>>>>>   // 3. If no help file exists, use thge old private help name (which gets the full name from the registry -only if no app object)
97816>>>>>>>>>>>   //    Last method is deprecated and only used for old applications
97816>>>>>>>>>>>   //
97816>>>>>>>>>>>   Function Help_filename returns string
97818>>>>>>>>>>>        string sHelpName
97818>>>>>>>>>>>        // If ghoWorkSpace Get Help_FileName of ghoWorkSpace to sHelpName // removed for VDF8
97818>>>>>>>>>>>
97818>>>>>>>>>>>        // If an Application object is used, take the name from there.
97818>>>>>>>>>>>        Get psHelpFile to sHelpName
97819>>>>>>>>>>>        If (sHelpName="" AND ghoApplication AND peHelpType(ghoApplication)=htWinHelp) Begin
97821>>>>>>>>>>>            Get psHelpFile of ghoApplication To sHelpName
97822>>>>>>>>>>>            //Move (psHelpPath(phoWorkspace(ghoApplication)) -"\" -sHelpName) To sHelpName
97822>>>>>>>>>>>        End
97822>>>>>>>>>>>>
97822>>>>>>>>>>>        If (sHelpName<>"") begin
97824>>>>>>>>>>>            Get_File_Path sHelpName To sHelpName
97825>>>>>>>>>>>            Function_Return sHelpName
97826>>>>>>>>>>>        end
97826>>>>>>>>>>>>
97826>>>>>>>>>>>        // if not set anywhere (and ideally it is) we use this.
97826>>>>>>>>>>>        Get Private.Help_FileName to sHelpName
97827>>>>>>>>>>>        Function_Return sHelpName
97828>>>>>>>>>>>    End_Function
97829>>>>>>>>>>>
97829>>>>>>>>>>>    Procedure Set Help_FileName string sName
97831>>>>>>>>>>>        Set Private.Help_FileName to sName
97832>>>>>>>>>>>    End_Procedure
97833>>>>>>>>>>>
97833>>>>>>>>>>>
97833>>>>>>>>>>>
97833>>>>>>>>>>>    // Consider this message PRIVATE in that it should only be changed
97833>>>>>>>>>>>    // by a sub-class and not an object. It is called in construct_object
97833>>>>>>>>>>>    // before it knows about object augmentations!!!!
97833>>>>>>>>>>>    //
97833>>>>>>>>>>>    //  Sets the Help_file_name by looking at the .INI file for:
97833>>>>>>>>>>>    //        HELP_DIR    - help directory (will check environment variable
97833>>>>>>>>>>>    //                      windir if not found - avoid this usage). If not
97833>>>>>>>>>>>    //                      blank append "\" as required.
97833>>>>>>>>>>>    //
97833>>>>>>>>>>>    //        HELP_FILE   - help file name. If blank uses the default help
97833>>>>>>>>>>>    //                      file name
97833>>>>>>>>>>>    //
97833>>>>>>>>>>>    Function Help_File_Default Returns String
97835>>>>>>>>>>>       String HelpFileDir HelpFileName sSubKey
97835>>>>>>>>>>>       // if using the application object we expect the help name to be
97835>>>>>>>>>>>       // defined in the application object or directly in the help object. No Exceptions
97835>>>>>>>>>>>       If (ghoApplication) function_return ""
97838>>>>>>>>>>>
97838>>>>>>>>>>>       // else if no application (and hence no WS) use an old deprecated method of checking
97838>>>>>>>>>>>       // for the module name in local_machine.
97838>>>>>>>>>>>       Get Module_name of Desktop to sSubKey
97839>>>>>>>>>>>       Get_Profile_String sSubKey HELP_DIR to HelpFileDir
97842>>>>>>>>>>>       Get_Profile_String sSubKey HELP_FILE to HelpFileName
97845>>>>>>>>>>>       // if dir exists, sure it has a "\" at the end. If no directory the
97845>>>>>>>>>>>       // dir must be blank so current directory is searched
97845>>>>>>>>>>>       If ( (HelpFileDir<>'') AND (Right(HelpFileDir,1)<>"\") ) ;          Move (HelpFileDir - '\') to HelpFileDir
97848>>>>>>>>>>>       If HelpFileName eq '' Move DEFAULT_HELP_FILENAME to HelpFileName
97851>>>>>>>>>>>       Function_Return (HelpFileDir - HelpFileName)
97852>>>>>>>>>>>    End_Function
97853>>>>>>>>>>>
97853>>>>>>>>>>>    // The System_Help_xxxx messages convert a DF help integer ID into
97853>>>>>>>>>>>    // a context value that can be used by the windows help system. If
97853>>>>>>>>>>>    // you return a number or a string. Numbers will get used for context ID
97853>>>>>>>>>>>    // help, non-numbers get used for keyword context help
97853>>>>>>>>>>>
97853>>>>>>>>>>>    // By default return ID passed. This creates a direct mapping between
97853>>>>>>>>>>>    // context IDs in your object and the context IDs in windows help.
97853>>>>>>>>>>>    //
97853>>>>>>>>>>>    Function System_Help_Context_id Integer ID Returns String
97855>>>>>>>>>>>       Function_Return ID
97856>>>>>>>>>>>    End_Function // System_Help_Context_id
97857>>>>>>>>>>>
97857>>>>>>>>>>>    // Returns the file# which assumes that we have a direct mapping between
97857>>>>>>>>>>>    // the file number and a window's help context_id. We are ignoring field#
97857>>>>>>>>>>>    // in this case (although your augmentation would not have to). If the
97857>>>>>>>>>>>    // file# is 0, return a the HELP_ID context id.
97857>>>>>>>>>>>    //
97857>>>>>>>>>>>    Function System_Help_File_Id Integer File# Integer Field# Returns String
97859>>>>>>>>>>>       String rVal
97859>>>>>>>>>>>       if File# eq 0 Move (Help_id_files(self)) to rVal
97862>>>>>>>>>>>       Else Move File# to rVal
97864>>>>>>>>>>>       Function_Return Rval
97865>>>>>>>>>>>    End_Function // System_Help_File_id
97866>>>>>>>>>>>
97866>>>>>>>>>>>    // Convert an error id into a help context id. Return the general
97866>>>>>>>>>>>    // Help id property value. We do this because error number have
97866>>>>>>>>>>>    // a rather large range (1-9000) and just using the number would consume
97866>>>>>>>>>>>    // too much of the context id space.
97866>>>>>>>>>>>    //
97866>>>>>>>>>>>    Function System_Help_Error_id Integer Id Returns String
97868>>>>>>>>>>>       Function_Return (Help_Id_Errors(self))
97869>>>>>>>>>>>    End_Function // System_Help_Error_id
97870>>>>>>>>>>>
97870>>>>>>>>>>>    // Use this if you want your help context to be keyword based
97870>>>>>>>>>>>    //
97870>>>>>>>>>>>    procedure View_Context_KeyWord_Help integer Obj
97872>>>>>>>>>>>       String Context
97872>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of obj HELP_CONTEXT_KEYWORD to Context
97875>>>>>>>>>>>       Send Exec_System_Help Context
97876>>>>>>>>>>>    end_procedure
97877>>>>>>>>>>>
97877>>>>>>>>>>>    // Use this if you want your help context to be ID based
97877>>>>>>>>>>>    //
97877>>>>>>>>>>>    procedure View_Context_ID_Help integer Obj
97879>>>>>>>>>>>       Integer Context_ID
97879>>>>>>>>>>>       String Context
97879>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of Obj HELP_CONTEXT_ID to Context_ID
97882>>>>>>>>>>>       Get System_Help_Context_id Context_Id to Context
97883>>>>>>>>>>>       Send Exec_Context_Help Context
97884>>>>>>>>>>>    end_procedure
97885>>>>>>>>>>>
97885>>>>>>>>>>>    // Use this is you want the object requesting help to support either
97885>>>>>>>>>>>    // keyword or context ID help (it will use whatever it finds first).
97885>>>>>>>>>>>    //
97885>>>>>>>>>>>    procedure View_Context_Help integer Obj
97887>>>>>>>>>>>       String Context
97887>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of obj HELP_CONTEXT_ID_OR_KEY to Context
97890>>>>>>>>>>>       if (left(context,1)) in '0123456789' ;          Get System_Help_Context_id Context to Context
97893>>>>>>>>>>>       Send Exec_Context_Help Context
97894>>>>>>>>>>>    end_procedure
97895>>>>>>>>>>>
97895>>>>>>>>>>>    Procedure View_Help_for_Help Integer obj
97897>>>>>>>>>>>        Send Exec_System_Help HELP_FOR_HELP_STRING
97898>>>>>>>>>>>    end_procedure
97899>>>>>>>>>>>
97899>>>>>>>>>>>    Procedure View_Help_Index integer obj
97901>>>>>>>>>>>       Send Exec_Context_Help (Help_id_index(self))
97902>>>>>>>>>>>    End_Procedure // View_help_index
97903>>>>>>>>>>>
97903>>>>>>>>>>>    procedure View_Keys_Help Integer Obj
97905>>>>>>>>>>>        Send Exec_Context_Help (Help_id_keys(self))
97906>>>>>>>>>>>    end_procedure
97907>>>>>>>>>>>
97907>>>>>>>>>>>    Procedure View_File_Help Integer Obj
97909>>>>>>>>>>>       String Context FilFld
97909>>>>>>>>>>>       Integer File# Field# Dot
97909>>>>>>>>>>>       If Obj gt 0 Begin
97911>>>>>>>>>>>          // This should return the file and field as a string in
97911>>>>>>>>>>>          // FFF.fff format (F=File, f=format).
97911>>>>>>>>>>>          Get Help_Context of Obj HELP_CONTEXT_DATAFILE to FilFld
97912>>>>>>>>>>>          // Parse FilFld into File# and Field#.
97912>>>>>>>>>>>          Pos '.' in FilFld to Dot
97914>>>>>>>>>>>>
97914>>>>>>>>>>>          if Dot ne 0 begin
97916>>>>>>>>>>>             Left FilFld to File#  (dot-1)
97918>>>>>>>>>>>>
97918>>>>>>>>>>>             Mid  FilFld to Field# 255 (dot+1)
97921>>>>>>>>>>>>
97921>>>>>>>>>>>          End
97921>>>>>>>>>>>>
97921>>>>>>>>>>>       End
97921>>>>>>>>>>>>
97921>>>>>>>>>>>       Get System_Help_File_id File# Field# to Context
97922>>>>>>>>>>>       Send Exec_Context_Help Context
97923>>>>>>>>>>>    End_Procedure // View_File_Help
97924>>>>>>>>>>>
97924>>>>>>>>>>>    //  View help on an error. Current version uses context id help.
97924>>>>>>>>>>>    //  The error number should be in global integer last_err
97924>>>>>>>>>>>    //
97924>>>>>>>>>>>    procedure View_Error_Help Integer Obj
97926>>>>>>>>>>>        String Context
97926>>>>>>>>>>>        If Obj gt 0 ;           Get Help_Context of obj HELP_CONTEXT_ERROR to Context
97929>>>>>>>>>>>        if (left(context,1)) in '0123456789' ;           Get System_Help_Error_id Context to Context
97932>>>>>>>>>>>        Send Exec_Context_Help Context
97933>>>>>>>>>>>    end_procedure
97934>>>>>>>>>>>
97934>>>>>>>>>>>    // View list of help topics.
97934>>>>>>>>>>>    //
97934>>>>>>>>>>>    Procedure View_Help_on_Topic Integer obj
97936>>>>>>>>>>>        Send Exec_System_Help HELP_ON_TOPIC_STRING
97937>>>>>>>>>>>    end_procedure
97938>>>>>>>>>>>
97938>>>>>>>>>>>    // Request context help. If context is a number assume that it is
97938>>>>>>>>>>>    // context id help, else assume it is keyword help.
97938>>>>>>>>>>>    //
97938>>>>>>>>>>>    Procedure Exec_Context_Help string Context
97940>>>>>>>>>>>       if (left(context,1)) in '0123456789' ;    // if first character is a          Send Exec_System_Context_Help Context  // numeric we assume ID help
97943>>>>>>>>>>>       else ;                                    // otherwise we assume key-          Send Exec_System_Help Context          // word help.
97945>>>>>>>>>>>    End_Procedure // Exec_Context_Help
97946>>>>>>>>>>>
97946>>>>>>>>>>>    // NOTE: the following two messages are the only messages that directly make calls
97946>>>>>>>>>>>    //       to the windows API. This is important. These two messages could be changed
97946>>>>>>>>>>>    //       to call other help systems (e.g. HTML help) and the rest of the high level
97946>>>>>>>>>>>    //       program remains the same. These are the only two messages that are
97946>>>>>>>>>>>    //       expected to be windows help centric.
97946>>>>>>>>>>>
97946>>>>>>>>>>>    // Get Context Id help for passed ID. Use help file as defined
97946>>>>>>>>>>>    // in Help_filename. If id is 0 use general help id (which must be
97946>>>>>>>>>>>    // defined.
97946>>>>>>>>>>>    //
97946>>>>>>>>>>>    Procedure Exec_System_Context_Help integer Context_id
97948>>>>>>>>>>>        If Context_Id eq 0 ; // if zero, see if we have a contents page            Move (Help_Id_General(self)) to Context_id
97951>>>>>>>>>>>        If Context_Id eq 0 ; // if still zero, jump to the topics popup dialog            Send Exec_System_Help HELP_ON_TOPIC_STRING
97954>>>>>>>>>>>        Else ;            Send gDoWinHelp WH_INTCONTEXT (Help_Filename(self)) Context_Id
97956>>>>>>>>>>>    end_procedure
97957>>>>>>>>>>>
97957>>>>>>>>>>>    // Get keyword help for passed keyword. Use help file as defined
97957>>>>>>>>>>>    // in help_filename.
97957>>>>>>>>>>>    //
97957>>>>>>>>>>>    procedure Exec_System_Help string Keyword
97959>>>>>>>>>>>        If Keyword eq HELP_FOR_HELP_STRING ;            Send gDoWinHelp WH_HELPONHELP
97962>>>>>>>>>>>        else if (Keyword eq HELP_ON_TOPIC_STRING OR KeyWord="");            Send gDoWinHelp WH_FINDER (Help_Filename(self))
97966>>>>>>>>>>>        else ;            Send gDoWinHelp WH_STRINGCONTEXT (Help_Filename(self)) KeyWord
97968>>>>>>>>>>>    end_procedure
97969>>>>>>>>>>>
97969>>>>>>>>>>>end_class
97970>>>>>>>>>use cHtmlHelp.pkg //  Define the help class for Html
97970>>>>>>>
97970>>>>>>>
97970>>>>>>>// This file needs to be provided by the developer. It will contain
97970>>>>>>>// symbolic replacements for the ID integer values used to access the
97970>>>>>>>// the windows help file's topics.
97970>>>>>>>//
97970>>>>>>>use Help_ids.inc
Including file: Help_ids.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Help_ids.inc)
97970>>>>>>>>>// Help_ids.inc
97970>>>>>>>>>//
97970>>>>>>>>>// Context ids. This uses help file Developer5.chm.
97970>>>>>>>>>//
97970>>>>>>>>>// This is a sample version. YOU must supply
97970>>>>>>>>>// the ID values
97970>>>>>>>>>
97970>>>>>>>>>//  Generic Context Ids
97970>>>>>>>>>//
97970>>>>>>>>>Define SQLConnectionsProgram for 0
97970>>>>>>>>>
97970>>>>>>>>>// It is expected that file-names ids will be the same as their
97970>>>>>>>>>// filenumber.
97970>>>>>>>>>
97970>>>>>>>>>
97970>>>>>>>>>//  View and selection-list specific context ids
97970>>>>>>>>>//
97970>>>>>>>>>//..........add view, object, selection-list ids here....
97970>>>>>>>
97970>>>>>>>// If the following are not defined in help_ids.inc,
97970>>>>>>>//  create default 0 values for them
97970>>>>>>>Define GeneralHelpId    for    0
97970>>>>>>>Define KeysHelpId       for    0
97970>>>>>>>Define FileHelpId       for    0
97970>>>>>>>Define ErrorHelpId      for    0  // probably not used in VDF
97970>>>>>>>Define IndexHelpId      for    0  // probably not used in VDF
97970>>>>>>>
97970>>>>>>>object Help_Object is a HelpSystem // global windows HLP help object
97972>>>>>>>
97972>>>>>>>   Set Help_Id_General to GeneralHelpId    // these should all be defined
97973>>>>>>>   Set Help_Id_Index   to IndexHelpId      // in help_ids.inc.
97974>>>>>>>   Set Help_Id_Keys    to KeysHelpId       //
97975>>>>>>>   Set Help_Id_Files   to FileHelpId       //
97976>>>>>>>   Set Help_Id_Errors  to ErrorHelpId      //
97977>>>>>>>
97977>>>>>>>end_object
97978>>>>>>>
97978>>>>>>>Object oHtmlHelp is a cHtmlHelp // this also defines ghoHtmlHelp
97980>>>>>>>End_Object
97981>>>>>
97981>>>>>Register_Function phoWorkspace Returns Handle
97981>>>>>Register_Function Help_filename Returns String
97981>>>>>Register_Function GetHelpFile Returns String
97981>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
97981>>>>>
97981>>>>>// Use of Mertech drivers:
97981>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
97981>>>>>    Use mertech.inc
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>// *** Constant Declarations: ***
97981>>>>>//
97981>>>>>
97981>>>>>// NOTE: These text constants should be added to the various "Language_xxx.inc" files:
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>
97981>>>>>// System icon menu constants. If the upper left hand
97981>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
97981>>>>>    Define SC_RESTORE  for |CI$F120
97981>>>>>    Define SC_MOVE     for |CI$F010
97981>>>>>    Define SC_SIZE     for |CI$F000
97981>>>>>    Define SC_MINIMIZE for |CI$F020
97981>>>>>    Define SC_MAXIMIZE for |CI$F030
97981>>>>>    Define SC_CLOSE    for |CI$F060
97981>>>>>    Define SC_KEYMENU  for |CI$F100
97981>>>>>    Define SC_NEXTWINDOW for |CI$F040
97981>>>>>    Define SC_PREVWINDOW for |CI$F050
97981>>>>>
97981>>>>>// *** Struct Declarations: ***
97981>>>>>Struct tWinMemoryStatusEx
97981>>>>>    UInteger dwLength
97981>>>>>    UInteger dwMemoryLoad
97981>>>>>    UBigInt ullTotalPhys
97981>>>>>    UBigInt ullAvailPhys
97981>>>>>    UBigInt ullTotalPageFile
97981>>>>>    UBigInt ullAvailPageFile
97981>>>>>    UBigInt ullTotalVirtual
97981>>>>>    UBigInt ullAvailVirtual
97981>>>>>    UBigInt ullAvailExtendedVirtual
97981>>>>>End_Struct
97981>>>>>
97981>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
97981>>>>>Type MEMORYSTATUS
97981>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
97981>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
97981>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
97981>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
97981>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
97981>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
97981>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
97981>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
97981>>>>>End_Type
97981>>>>>
97981>>>>>// *** External Function calls: ***
97981>>>>>//
97981>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
97982>>>>>
97982>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
97983>>>>>
97983>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
97984>>>>>
97984>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
97985>>>>>
97985>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
97986>>>>>
97986>>>>>// *** Global/Desktop Function Declarations: ***
97986>>>>>
97986>>>>>Function ComputerName for Desktop Returns String
97988>>>>>    String sName
97988>>>>>    Get_Environment "COMPUTERNAME" to sName
97989>>>>>>
97989>>>>>    Function_Return sName
97990>>>>>End_Function
97991>>>>>
97991>>>>>Function Network_User_Name for cDesktop Returns String
97993>>>>>    String sName
97993>>>>>    Get_Environment "USERNAME" to sName
97994>>>>>>
97994>>>>>    Function_Return sName
97995>>>>>End_Function
97996>>>>>
97996>>>>>// *** Class Declarations: ***
97996>>>>>//
97996>>>>>Class cBitmapContainerVDFLink is a BitmapContainer
97997>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
97999>>>>>        Send Mouse_Up iWindowNumber iPosition
98000>>>>>    End_Procedure
98001>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
98003>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
98005>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
98006>>>>>    End_Procedure
98007>>>>>End_Class
98008>>>>>
98008>>>>>Class cCopyEditorContentButton is a Button
98009>>>>>    Procedure Construct_Object
98011>>>>>        Forward Send Construct_Object
98013>>>>>        Property Handle phoEditorHandle
98014>>>>>        Set psToolTip to C_$DescCopy
98015>>>>>    End_Procedure
98016>>>>>
98016>>>>>    Procedure CopyToWindowsClipboard
98018>>>>>        String sValue
98018>>>>>        Handle hoEditor
98018>>>>>        Boolean bCanCopy
98018>>>>>        Address aEditorAddress
98018>>>>>
98018>>>>>        Get phoEditorHandle to hoEditor
98019>>>>>        Send Select_All of hoEditor
98020>>>>>        Get CanCopy of hoEditor to bCanCopy
98021>>>>>        If (bCanCopy = True) Begin
98023>>>>>            Get paValue of hoEditor to aEditorAddress
98024>>>>>            Move aEditorAddress to sValue
98025>>>>>            Send Copy   of hoEditor
98026>>>>>            // Remove the selection after text is copied to the clipboard.
98026>>>>>            Send Beginning_of_Data of hoEditor
98027>>>>>            Send Info_Box C_$CopyToClipboard_Text
98028>>>>>        End
98028>>>>>>
98028>>>>>    End_Procedure
98029>>>>>End_Class
98030>>>>>
98030>>>>>Class SysinfoDisplay is a cTextEdit
98031>>>>>    Procedure Construct_Object
98033>>>>>        Forward Send Construct_Object
98035>>>>>
98035>>>>>        Set Size to 104 247
98036>>>>>        Set Location to 4 6
98037>>>>>        Set Border_Style to Border_None
98038>>>>>        Set peAnchors to anAll
98039>>>>>        Set Read_Only_State to True
98040>>>>>        Set pbWrap to True
98041>>>>>    End_Procedure
98042>>>>>
98042>>>>>    // Augmented class message to adjust certain text strings that are wrong...
98042>>>>>
98042>>>>>    Procedure AppendTextLn String sText
98044>>>>>        String sWorkspaceWSFile
98044>>>>>
98044>>>>>        // Only works for English:
98044>>>>>        If (ghoApplication > 0) Begin
98046>>>>>            If (sText contains "Workspace Name") Begin
98048>>>>>                Move "Workspace Config Filename:" to sText
98049>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
98050>>>>>                Move (sText * sWorkspaceWSFile) to sText
98051>>>>>            End
98051>>>>>>
98051>>>>>        End
98051>>>>>>
98051>>>>>        Send AppendText sText
98052>>>>>        Send AppendText (character(10))
98053>>>>>    End_Procedure
98054>>>>>
98054>>>>>    //****************************************************************************
98054>>>>>    // $Module type: PROCEDURE
98054>>>>>    // $Module name: Show_Current_Directory
98054>>>>>    // $Author     : VOO
98054>>>>>    // Created     : 06-10-96 @ 15:24
98054>>>>>    //
98054>>>>>    // Description
98054>>>>>    //    This method will show the name Of the current directory in the system
98054>>>>>    //    information box
98054>>>>>    //
98054>>>>>    // $Rev History
98054>>>>>    //    06-10-96  Module header created
98054>>>>>    //****************************************************************************
98054>>>>>    Procedure Show_Current_Directory
98056>>>>>        String sDir
98056>>>>>
98056>>>>>        Get_Current_Directory To sDir
98057>>>>>
98057>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
98058>>>>>    End_Procedure
98059>>>>>
98059>>>>>    Procedure Show_Windows_Directory
98061>>>>>        String sWindir
98061>>>>>
98061>>>>>        Get_Windows_Directory To sWindir
98062>>>>>
98062>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
98063>>>>>    End_Procedure
98064>>>>>
98064>>>>>    Procedure Show_Current_User
98066>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
98067>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
98068>>>>>    End_Procedure
98069>>>>>
98069>>>>>    Procedure Show_Number_Format
98071>>>>>        Integer iFormat
98071>>>>>        String sFormatText
98071>>>>>
98071>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
98074>>>>>        Move (Character (iFormat)) To sFormatText
98075>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
98076>>>>>
98076>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
98079>>>>>        Move (Character (iFormat)) to sFormatText
98080>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
98081>>>>>    End_Procedure
98082>>>>>
98082>>>>>    Procedure Show_Filelist_Name
98084>>>>>        String sFilename
98084>>>>>
98084>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
98087>>>>>
98087>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
98088>>>>>    End_Procedure
98089>>>>>
98089>>>>>    Procedure Show_Lock_Delay
98091>>>>>        Integer iLockdelay
98091>>>>>
98091>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
98094>>>>>
98094>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
98095>>>>>    End_Procedure
98096>>>>>
98096>>>>>    Procedure Show_Lock_Timeout
98098>>>>>        Integer iLockTimeout
98098>>>>>
98098>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
98101>>>>>
98101>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
98102>>>>>    End_Procedure
98103>>>>>
98103>>>>>    Procedure Show_Screen_Size
98105>>>>>        Integer iYscreensize iXscreensize
98105>>>>>
98105>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
98106>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
98107>>>>>
98107>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
98108>>>>>    End_Procedure
98109>>>>>
98109>>>>>    Procedure Show_Page_Size
98111>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
98112>>>>>    End_procedure
98113>>>>>
98113>>>>>    Procedure Show_Date
98115>>>>>        Date dToday
98115>>>>>
98115>>>>>        Sysdate dToday
98116>>>>>
98116>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
98117>>>>>    End_procedure
98118>>>>>
98118>>>>>    Procedure Show_Date_Format
98120>>>>>        Integer iDateFormat
98120>>>>>        String sDateFormat
98120>>>>>
98120>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
98123>>>>>        Case Begin
98123>>>>>            Case (iDateFormat = DF_DATE_USA)
98125>>>>>                Move C_$USA To sDateFormat
98126>>>>>                Case Break
98127>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
98130>>>>>                Move C_$European To sDateFormat
98131>>>>>                Case Break
98132>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
98135>>>>>                Move C_$Military To sDateFormat
98136>>>>>                Case Break
98137>>>>>            Case Else
98137>>>>>                Move C_$UnknownDateType To sDateFormat
98138>>>>>                Case Break
98139>>>>>        Case End
98139>>>>>
98139>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
98140>>>>>    End_Procedure
98141>>>>>
98141>>>>>    // 2013-08-14 NGS
98141>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
98141>>>>>    Procedure Show_Systemresources
98143>>>>>        tWinMemoryStatusEx MemoryStatusInfo
98143>>>>>        tWinMemoryStatusEx MemoryStatusInfo
98143>>>>>        Integer iRetval
98143>>>>>        Number nValue
98143>>>>>        String sValue
98143>>>>>
98143>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
98144>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
98145>>>>>        If (iRetval = 0) Begin
98147>>>>>            Move (ShowLastError ()) to iRetval
98148>>>>>            Procedure_Return
98149>>>>>        End
98149>>>>>>
98149>>>>>
98149>>>>>        Send AppendTextLn ""
98150>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
98151>>>>>
98151>>>>>        // Show memory in Gigabytes:
98151>>>>>        Move (nValue/1024/1024/1024) to nValue
98152>>>>>        Move (Round(nValue)) to nValue
98153>>>>>        Get FormatNumber nValue 2 to sValue
98154>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
98155>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
98156>>>>>
98156>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
98156>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
98157>>>>>        Move (Round(nValue)) to nValue
98158>>>>>        Get FormatNumber nValue 0 to sValue
98159>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
98160>>>>>
98160>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
98160>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
98161>>>>>        Move (Round(nValue)) to nValue
98162>>>>>        Get FormatNumber nValue 0 to sValue
98163>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
98164>>>>>
98164>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
98164>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
98165>>>>>        Move (Round(nValue)) to nValue
98166>>>>>        Get FormatNumber nValue 0 to sValue
98167>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
98168>>>>>
98168>>>>>        // Add an empty row after the memory information:
98168>>>>>        Send AppendTextLn ""
98169>>>>>    End_Procedure
98170>>>>>
98170>>>>>    Procedure Show_Registration
98172>>>>>        String sRegName
98172>>>>>        Integer iSN iUsersMax iUserCount
98172>>>>>
98172>>>>>        Registration sRegName iSN
98173>>>>>>
98173>>>>>        Get_Licensed_Max_Users to iUsersMax
98174>>>>>        Get_Current_User_Count to iUserCount
98175>>>>>
98175>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
98176>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
98177>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
98178>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
98179>>>>>    End_Procedure
98180>>>>>
98180>>>>>    //****************************************************************************
98180>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
98180>>>>>    // To the workspace object passing the an object and message To send back
98180>>>>>    // To this object. It is expected that the workspace object will send this
98180>>>>>    // message for every line Of information it wants displayed (passing the
98180>>>>>    // information To be displayed
98180>>>>>    //****************************************************************************
98180>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
98180>>>>>
98180>>>>>    Procedure Show_ServicePack
98182>>>>>        String sKey sVersion sDataFlex
98182>>>>>        Handle hoRegistry
98182>>>>>        Boolean bExists bOpened
98182>>>>>
98182>>>>>        Move "DataFlex"        to sDataFlex
98183>>>>>
98183>>>>>        Get Create U_cRegistry to hoRegistry
98184>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
98185>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
98186>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
98187>>>>>
98187>>>>>        If (bExists) Begin
98189>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
98190>>>>>        End
98190>>>>>>
98190>>>>>        Else Begin
98191>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
98192>>>>>        End
98192>>>>>>
98192>>>>>        Get KeyExists of hoRegistry sKey to bExists
98193>>>>>        If (bExists) Begin
98195>>>>>            Get OpenKey of hoRegistry sKey to bOpened
98196>>>>>            If (bOpened) Begin
98198>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
98199>>>>>                If (bExists) Begin
98201>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
98202>>>>>                End
98202>>>>>>
98202>>>>>                Send CloseKey of hoRegistry
98203>>>>>            End
98203>>>>>>
98203>>>>>        End
98203>>>>>>
98203>>>>>        Send Destroy of hoRegistry
98204>>>>>
98204>>>>>        If (sVersion <> "") Begin
98206>>>>>           Send AppendTextLn sVersion
98207>>>>>           Send AppendTextLn ""
98208>>>>>        End
98208>>>>>>
98208>>>>>    End_Procedure
98209>>>>>
98209>>>>>    Procedure Show_WorkspaceInformation
98211>>>>>        Integer hoWorkspace
98211>>>>>
98211>>>>>        If (ghoApplication <> 0) Begin
98213>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
98214>>>>>            If (hoWorkspace <> 0) Begin
98216>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
98217>>>>>            End
98217>>>>>>
98217>>>>>        End
98217>>>>>>
98217>>>>>    End_Procedure
98218>>>>>
98218>>>>>    //****************************************************************************
98218>>>>>    // If connection ids are used, we will send the message EnumerateConnections
98218>>>>>    // to the connection manager object passing the an object and message to send
98218>>>>>    // back to this object. It is expected that the connection manager object will
98218>>>>>    // send this message for every line Of information it wants displayed (passing
98218>>>>>    // the information To be displayed
98218>>>>>    //****************************************************************************
98218>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
98218>>>>>
98218>>>>>    Procedure Show_ConnectionIdInformation
98220>>>>>        If (ghoConnection > 0) Begin
98222>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
98223>>>>>            Send AppendTextLn ""
98224>>>>>        End
98224>>>>>>
98224>>>>>    End_Procedure
98225>>>>>
98225>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
98227>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
98228>>>>>    End_Function
98229>>>>>
98229>>>>>    Procedure Show_Versions
98231>>>>>        Integer iVersion iRevision iBuild
98231>>>>>
98231>>>>>        Version_information iVersion iRevision iBuild
98233>>>>>
98233>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
98234>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
98235>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
98236>>>>>    End_Procedure
98237>>>>>
98237>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
98239>>>>>        Boolean bOK
98239>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
98240>>>>>        Function_Return bOK
98241>>>>>    End_Function
98242>>>>>
98242>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
98244>>>>>        Boolean bOK
98244>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MySQLFlex) to bOK
98245>>>>>        Function_Return bOK
98246>>>>>    End_Function
98247>>>>>
98247>>>>>    //***
98247>>>>>    //*** BW
98247>>>>>    //*** Procedure: Show_Drivers
98247>>>>>    //*** Purpose  : Show loaded database drivers
98247>>>>>    //***
98247>>>>>
98247>>>>>    Procedure Show_Drivers
98249>>>>>        String sDriverID sVersion sClient sMertechSQLFlexVersion sValue
98249>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
98249>>>>>        Handle hoCLIHandler hoBtrvHandler
98249>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
98249>>>>>
98249>>>>>        Move False to bStudioLicense
98250>>>>>
98250>>>>>        Get Create U_cCLIHandler      to hoCLIHandler
98251>>>>>        Get Create U_cDFBtrDrvHandler to hoBtrvHandler
98252>>>>>
98252>>>>>        // For testing purposes:
98252>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98252>>>>>//        Load_Driver MSSQLDRV_ID
98252>>>>>//        Load_Driver ODBC_DRV_ID
98252>>>>>//        Load_Driver DB2_DRV_ID
98252>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98252>>>>>//
98252>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
98252>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98252>>>>>//            Load_Driver SQLFLEX
98252>>>>>//            Load_Driver MDSPgSQL
98252>>>>>//            Load_Driver MDSMySQL
98252>>>>>//            Load_Driver ORAFLEX
98252>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98252>>>>>//        #ENDIF
98252>>>>>        Move False to Err
98253>>>>>
98253>>>>>        // Loop through all loaded drivers.
98253>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
98256>>>>>        If (iNumberOfDrivers > 1) Begin
98258>>>>>            Send AppendTextLn ""
98259>>>>>        End
98259>>>>>>
98259>>>>>        For iDriver from 1 to iNumberOfDrivers
98265>>>>>>
98265>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
98265>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
98265>>>>>            // would be thrown, so we safeguard from that here.
98265>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
98266>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
98269>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
98270>>>>>            Get IsDAWSQLDriver sDriverID to bIsDAWDriver
98271>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
98272>>>>>
98272>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
98274>>>>>
98274>>>>>                // Pervasive/Btrieve database
98274>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
98276>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
98277>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
98278>>>>>                    If (sClient <> "0.0.0") Begin
98280>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
98281>>>>>                    End
98281>>>>>>
98281>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
98282>>>>>                    If (sClient <> "0.0.0") Begin
98284>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
98285>>>>>                    End
98285>>>>>>
98285>>>>>                End
98285>>>>>>
98285>>>>>
98285>>>>>                Else Begin
98286>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
98287>>>>>                    Move 0 to iNumServers
98288>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
98290>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
98293>>>>>                    End
98293>>>>>>
98293>>>>>
98293>>>>>                    If (bIsDAWDriver = True) Begin
98295>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
98297>>>>>                            // This info is only available for the MS SQL driver:
98297>>>>>                            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient
98300>>>>>                            If (iClient = 13) Move C_$SQLSERVER2016DRVRSTR              to sClient
98303>>>>>                            If (iClient = 12) Move C_$SQLSERVER2014DRVRSTR              to sClient
98306>>>>>                            If (iClient = 11) Move C_$SQL_Server_Native_Client_11_0     to sClient
98309>>>>>                            If (iClient = 10) Move C_$SQL_Server_Native_Client_10_0     to sClient
98312>>>>>                            If (iClient = 9)  Move C_$SQL_Native_Client                 to sClient
98315>>>>>                            If (iClient = 8)  Move C_$SQL_Server_SQL_Server_2000_client to sClient
98318>>>>>                            If (sClient <> "") Begin
98320>>>>>                                Move ("    " + sClient) to sClient
98321>>>>>                            End
98321>>>>>>
98321>>>>>                        End
98321>>>>>>
98321>>>>>
98321>>>>>                        Get CKRevision of hoCLIHandler to sVersion
98322>>>>>                    End
98322>>>>>>
98322>>>>>
98322>>>>>                    If (bIsMertechDriver = True) Begin
98324>>>>>                        GET_DRIVER_REVISION to sVersion
98337>>>>>>
98337>>>>>                    End
98337>>>>>>
98337>>>>>
98337>>>>>                    // If the serialnumber is = 0, it means that the
98337>>>>>                    // Studio licens is in use and there is no
98337>>>>>                    // number of max users defined because the driver is
98337>>>>>                    // relying on the info from the VDF license.
98337>>>>>                    If (bStudioLicense = False) Begin
98339>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
98340>>>>>                        Move (iSerialNo = 0) to bStudioLicense
98341>>>>>                    End
98341>>>>>>
98341>>>>>                End
98341>>>>>>
98341>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
98342>>>>>                If (iNumServers <> 0) Begin
98344>>>>>                    For iCount from 1 to iNumServers
98350>>>>>>
98350>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
98353>>>>>                        Send AppendTextLn ("    " + "Server/DSN:" * sValue)
98354>>>>>                    Loop
98355>>>>>>
98355>>>>>                End
98355>>>>>>
98355>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
98357>>>>>                    Send AppendTextLn sClient
98358>>>>>                End
98358>>>>>>
98358>>>>>            End
98358>>>>>>
98358>>>>>        Loop
98359>>>>>>
98359>>>>>
98359>>>>>        Send AppendTextLn ""
98360>>>>>        If (bStudioLicense = False) Begin
98362>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
98363>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
98364>>>>>        End
98364>>>>>>
98364>>>>>        Else Begin
98365>>>>>            Send AppendTextLn C_$VDF_Studio_License_Text
98366>>>>>        End
98366>>>>>>
98366>>>>>        Send Destroy of hoCLIHandler
98367>>>>>        Send Destroy of hoBtrvHandler
98368>>>>>    End_Procedure
98369>>>>>
98369>>>>>    Procedure Show_HelpFile
98371>>>>>        String sHelpFile
98371>>>>>        Integer eHelpType
98371>>>>>
98371>>>>>        If (ghoApplication <> 0) Begin
98373>>>>>            Get peHelpType Of ghoApplication To eHelpType
98374>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
98376>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
98377>>>>>            End
98377>>>>>>
98377>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
98380>>>>>                Get Help_filename Of Help_object_id To sHelpFile
98381>>>>>            End
98381>>>>>>
98381>>>>>            Else Begin
98382>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
98383>>>>>            End
98383>>>>>>
98383>>>>>
98383>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
98384>>>>>        End
98384>>>>>>
98384>>>>>    End_Procedure
98385>>>>>
98385>>>>>    Procedure Show_EnterAsTab
98387>>>>>        Boolean bEnterKeyAsTabKey
98387>>>>>        String sText
98387>>>>>
98387>>>>>        If (ghoApplication <> 0) Begin
98389>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
98390>>>>>            If (bEnterKeyAsTabKey) Begin
98392>>>>>                Move "True" To sText
98393>>>>>            End
98393>>>>>>
98393>>>>>            Else Begin
98394>>>>>                Move "False" To sText
98395>>>>>            End
98395>>>>>>
98395>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
98396>>>>>        End
98396>>>>>>
98396>>>>>    End_Procedure
98397>>>>>
98397>>>>>    //****************************************************************************
98397>>>>>    // $Module type: PROCEDURE
98397>>>>>    // $Module name: Add_Focus
98397>>>>>    // $Author     : VOO
98397>>>>>    // Created     : 24-09-96 @ 19:43
98397>>>>>    //
98397>>>>>    // Description
98397>>>>>    //    During activation we will remove the old information and add the newly
98397>>>>>    //    found systeminformation
98397>>>>>    //
98397>>>>>    // $Rev History
98397>>>>>    //    24-09-96  Module header created
98397>>>>>    //****************************************************************************
98397>>>>>    Procedure Add_Focus Integer hoRoot
98399>>>>>        Forward Send Add_Focus hoRoot
98401>>>>>
98401>>>>>        Send Delete_Data
98402>>>>>
98402>>>>>        Set Changed_State To False
98403>>>>>        Set Read_Only_State To True
98404>>>>>
98404>>>>>        Send Show_Registration
98405>>>>>        Send Show_Drivers
98406>>>>>        Send AppendTextLn ""
98407>>>>>
98407>>>>>        Send Show_ServicePack
98408>>>>>        If (ghoApplication <> 0) Begin
98410>>>>>            Send Show_WorkSpaceInformation
98411>>>>>            Send Show_HelpFile
98412>>>>>            Send AppendTextLn ""
98413>>>>>        End
98413>>>>>>
98413>>>>>        Else Begin
98414>>>>>            Send AppendTextLn ""
98415>>>>>        End
98415>>>>>>
98415>>>>>
98415>>>>>        If (ghoConnection <> 0) Begin
98417>>>>>            Send Show_ConnectionIdInformation
98418>>>>>        End
98418>>>>>>
98418>>>>>
98418>>>>>        Send Show_Current_User
98419>>>>>        Send Show_Windows_Directory
98420>>>>>        Send Show_Current_Directory
98421>>>>>
98421>>>>>        // This is already shown in the workspace details,
98421>>>>>        // unless no workspace object is present:
98421>>>>>        If (ghoApplication = 0) Begin
98423>>>>>            Send Show_Filelist_Name
98424>>>>>        End
98424>>>>>>
98424>>>>>
98424>>>>>        If (ghoApplication <> 0) Begin
98426>>>>>            Send AppendTextLn ""
98427>>>>>            Send Show_EnterAsTab
98428>>>>>        End
98428>>>>>>
98428>>>>>
98428>>>>>        Send Show_Versions
98429>>>>>        Send Show_Screen_Size
98430>>>>>        Send Show_Page_Size
98431>>>>>        Send Show_Number_Format
98432>>>>>        Send Show_Date_Format
98433>>>>>        Send Show_Lock_Delay
98434>>>>>        Send Show_Lock_Timeout
98435>>>>>        Send Show_Date
98436>>>>>        Send Show_Systemresources
98437>>>>>        Send Beginning_of_Data
98438>>>>>
98438>>>>>        Set Icon to 'default.ico'
98439>>>>>    End_Procedure
98440>>>>>End_Class
98441>>>>>
98441>>>>>//****************************************************************************
98441>>>>>// $Module type: OBJECT
98441>>>>>// $Module name: Sysinfo_Dialog
98441>>>>>// $Author     : VOO
98441>>>>>// Created     : 24-09-96 @ 18:47
98441>>>>>//
98441>>>>>// Description
98441>>>>>//    This object shows the systeminformation on the screen
98441>>>>>//
98441>>>>>// $Rev History
98441>>>>>//    24-09-96  Module header created
98441>>>>>//****************************************************************************
98441>>>>>Class SysInfoDialog is a ModalPanel
98442>>>>>    Procedure Construct_Object
98444>>>>>        Forward Send Construct_Object
98446>>>>>
98446>>>>>        Set Label to C_$SystemInformation
98447>>>>>        Set Size to 140 267
98448>>>>>        Set Locate_Mode to CENTER_ON_PARENT
98449>>>>>        Set Border_Style to Border_Thick
98450>>>>>        Set Sysmenu_Icon to False
98451>>>>>
98451>>>>>        // "+1" will make the panel to paint correctly.
98451>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
98452>>>>>
98452>>>>>        // 2014-09-14 NGS
98452>>>>>        // Added a container object around the cTexteditor
98452>>>>>        // object to get a border around the text.
98452>>>>>        Object oSysinfoDisplayContainer is a Container3d
98454>>>>>            Set Location to 2 4
98455>>>>>            Set Size to 110 255
98456>>>>>            Set Border_Style to Border_ClientEdge
98457>>>>>            Set Color to clWhite
98458>>>>>            Set peAnchors to anAll
98459>>>>>
98459>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
98461>>>>>            End_Object
98462>>>>>
98462>>>>>        End_Object
98463>>>>>
98463>>>>>        Object oCloseButton is a Button
98465>>>>>            Set Label to C_$Close
98466>>>>>            Set Location to 120 210
98467>>>>>            Set Message item 0 to msg_Close_Panel
98468>>>>>            Set Default_State To True
98469>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
98469>>>>>            // and changes its peAnchors, we might as well prepare this object
98469>>>>>            // for that situation.
98469>>>>>            Set peAnchors to anBottomRight
98470>>>>>        End_Object
98471>>>>>
98471>>>>>        Object oCopyButton is a cCopyEditorContentButton
98473>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
98474>>>>>            Set Size to 14 50
98475>>>>>            Set Location to 120 158
98476>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
98476>>>>>            // we might as well prepare the object for it.
98476>>>>>            Set peAnchors to anBottomRight
98477>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
98478>>>>>        End_Object
98479>>>>>
98479>>>>>        On_Key kCancel Send Close_Panel
98480>>>>>    End_Procedure
98481>>>>>
98481>>>>>    Procedure Page Integer iPageObject
98483>>>>>        Handle hMenu
98483>>>>>        Integer iPrevState
98483>>>>>
98483>>>>>        Forward Send Page iPageObject
98485>>>>>
98485>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
98485>>>>>        //
98485>>>>>    End_Procedure
98486>>>>>
98486>>>>>End_Class
98487>>>>>
98487>>>>>Class cAboutEdit is an cRichEdit
98488>>>>>    Procedure Construct_Object
98490>>>>>        Forward Send Construct_Object
98492>>>>>
98492>>>>>        Set Size to 57 153
98493>>>>>        Set Location to 8 60
98494>>>>>
98494>>>>>        Set Read_Only_State to True
98495>>>>>        Set Skip_State to True
98496>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
98496>>>>>        // or 1/20 of a printer's point.
98496>>>>>//        Set piFontSize    to (9 * 20)
98496>>>>>        Set piRightMargin to (0.1 * 1440)
98497>>>>>        Set Border_Style  to Border_None
98498>>>>>    End_Procedure
98499>>>>>
98499>>>>>    // Adds a line of text to the edit object
98499>>>>>    Procedure Add_Line String sVal
98501>>>>>        String sText
98501>>>>>        Address aAddress
98501>>>>>        Get paValue to aAddress
98502>>>>>        Move aAddress to sText
98503>>>>>        Move (sText + String(sVal)) to sVal
98504>>>>>        GetAddress of sVal to aAddress
98505>>>>>        Set paValue to aAddress
98506>>>>>    End_Procedure
98507>>>>>
98507>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
98507>>>>>    // Note that we use the paValue interface,
98507>>>>>    // because the object isn't paged yet when we add the
98507>>>>>    // values and the COM edit object needs to be paged
98507>>>>>    // for the "Set Value" interface to be used.
98507>>>>>    Procedure Add_LineLn String sVal
98509>>>>>        String sText
98509>>>>>        Address aAddress
98509>>>>>        Get paValue to aAddress
98510>>>>>        Move aAddress to sText
98511>>>>>        Move (sText + String(sVal) + Character(10) + Character(13)) to sVal
98512>>>>>        GetAddress of sVal to aAddress
98513>>>>>        Set paValue to aAddress
98514>>>>>    End_Procedure
98515>>>>>
98515>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
98517>>>>>        String sLinkText
98517>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
98518>>>>>        Send Show_HomePage sLinkText
98519>>>>>    End_Procedure
98520>>>>>
98520>>>>>End_Class
98521>>>>>
98521>>>>>// Purpose:
98521>>>>>//
98521>>>>>// Ken Ross 12/17/96 5:16PM
98521>>>>>//
98521>>>>>Class AboutDialog is a ModalPanel
98522>>>>>    Procedure Construct_Object
98524>>>>>
98524>>>>>        Forward Send Construct_Object
98526>>>>>
98526>>>>>        Set Label to C_$About
98527>>>>>        Set Size to 96 230
98528>>>>>        Set Locate_Mode To CENTER_ON_PARENT
98529>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
98530>>>>>//        Set Sysmenu_Icon to True
98530>>>>>
98530>>>>>        Object oSysInfoDialog is a SysInfoDialog
98532>>>>>        End_Object
98533>>>>>
98533>>>>>        Object oBox is a Container3d
98535>>>>>            Set Border_Style to Border_Normal
98536>>>>>            Set Size to 70 220
98537>>>>>            Set Location to 4 5
98538>>>>>            Set Color to clWhite
98539>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
98539>>>>>            // we might as well prepare the object for it.
98539>>>>>            Set peAnchors to anAll
98540>>>>>
98540>>>>>            Object oAboutGraphic is a BitmapContainer
98542>>>>>                Set Border_Style To Border_None
98543>>>>>                Set Bitmap_Style to Bitmap_Center
98544>>>>>                Set Color to clWhite
98545>>>>>                Set Size to 45 50
98546>>>>>                Set Location to 0 3
98547>>>>>            End_Object
98548>>>>>
98548>>>>>            Object oPoweredByVDFGraphic is a cBitmapContainerVDFLink
98550>>>>>                Set Border_Style to Border_None
98551>>>>>                Set Bitmap_Style to Bitmap_Center
98552>>>>>                Set Color to clWhite
98553>>>>>                Set Size to 30 55 //28 50
98554>>>>>                Set Location to 44 3
98555>>>>>            End_Object
98556>>>>>
98556>>>>>            Object oInfoList_Editor is an cAboutEdit
98558>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
98558>>>>>                // we might as well prepare the object for it.
98558>>>>>                Set peAnchors to anAll
98559>>>>>            End_Object
98560>>>>>
98560>>>>>            // These objects are here for backwards compatability only.
98560>>>>>            // They are not used.
98560>>>>>            Object oProductName is a TextBox
98562>>>>>                Set Label To C_$ProductName
98563>>>>>                Set Size To 10 45
98564>>>>>                Set Location To 8 53
98565>>>>>                Set Visible_State to False
98566>>>>>                Set Focus_Mode to NonFocusable
98567>>>>>            End_Object
98568>>>>>
98568>>>>>            Object oVersion is a TextBox
98570>>>>>                Set Label To C_$Version
98571>>>>>                Set Size To 10 25
98572>>>>>                Set Location To 21 53
98573>>>>>                Set Visible_State to False
98574>>>>>                Set Focus_Mode to NonFocusable
98575>>>>>            End_Object
98576>>>>>
98576>>>>>            Object oCopyright is a TextBox
98578>>>>>                Set Label To C_$Copyright
98579>>>>>                Set Size To 10 31
98580>>>>>                Set Location To 34 53
98581>>>>>                Set Visible_State to False
98582>>>>>                Set Focus_Mode to NonFocusable
98583>>>>>            End_Object
98584>>>>>
98584>>>>>            Object oAuthor is a TextBox
98586>>>>>                Set Label To C_$Author
98587>>>>>                Set Size To 10 22
98588>>>>>                Set Location To 46 53
98589>>>>>                Set Visible_State to False
98590>>>>>                Set Focus_Mode to NonFocusable
98591>>>>>            End_Object
98592>>>>>
98592>>>>>        End_Object
98593>>>>>
98593>>>>>        Object oOKButton Is A Button
98595>>>>>            On_Item C_$Close Send Close_Panel
98596>>>>>            Set Location to 78 176
98597>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
98597>>>>>            // we might as well prepare the object for it.
98597>>>>>            Set peAnchors to anBottomRight
98598>>>>>        End_Object
98599>>>>>
98599>>>>>        Object oSysInfoButton Is A Button
98601>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
98602>>>>>            Set Location to 78 123
98603>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
98603>>>>>            // we might as well prepare the object for it.
98603>>>>>            Set peAnchors to anBottomRight
98604>>>>>        End_Object
98605>>>>>
98605>>>>>        Object oCopyButton is a cCopyEditorContentButton
98607>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
98608>>>>>            Set Size to 14 50
98609>>>>>            Set Location to 78 70
98610>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
98610>>>>>            // we might as well prepare the object for it.
98610>>>>>            Set peAnchors to anBottomRight
98611>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
98612>>>>>        End_Object
98613>>>>>
98613>>>>>        On_Key Kcancel Send KeyAction of oOKButton
98614>>>>>        Set Logo    to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
98615>>>>>//        Set LogoVDF to "PoweredByDataFlex.bmp"
98615>>>>>        Set LogoVDF to "PoweredByOrange.bmp"
98616>>>>>    End_Procedure
98617>>>>>
98617>>>>>    Procedure Page Integer iPageObject
98619>>>>>        Handle hMenu
98619>>>>>        Integer iPrevState
98619>>>>>
98619>>>>>        Forward Send Page iPageObject
98621>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
98621>>>>>//        Set Icon to "ActionAbout.ico"
98621>>>>>
98621>>>>>        // Shadow upper left corner menu items: (icon menu items)
98621>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
98622>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
98623>>>>>        // The "Move" menu command may come in handy to have.
98623>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
98623>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
98624>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
98625>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
98626>>>>>        // The "Close" menu command may be good to have.
98626>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
98626>>>>>    End_Procedure
98627>>>>>
98627>>>>>    Procedure Set ProductName String sText
98629>>>>>        Set Value of oProductName to sText
98630>>>>>    End_Procedure
98631>>>>>
98631>>>>>    Procedure Set Copyright String sText
98633>>>>>        Set Value of oCopyright to sText
98634>>>>>    End_Procedure
98635>>>>>
98635>>>>>    Procedure Set Author String sText
98637>>>>>        Set Value of oAuthor to sText
98638>>>>>    End_Procedure
98639>>>>>
98639>>>>>    Procedure Set Version String sVersion
98641>>>>>        Handle hoVersionInfo
98641>>>>>        Boolean bIncluded
98641>>>>>        Integer iMajor iMinor iRelease iBuild
98641>>>>>        Date dCompileDate
98641>>>>>
98641>>>>>        If (sVersion = "") Begin
98643>>>>>            // This automatically shows the program version of the program, if available.
98643>>>>>            // It will be displayed as the second item in the edit object.
98643>>>>>            If (ghoApplication <> 0) Begin
98645>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
98646>>>>>                If (hoVersionInfo <> 0) Begin
98648>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
98649>>>>>                    If (bIncluded) Begin
98651>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
98652>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
98653>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
98654>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
98655>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
98656>>>>>                    End
98656>>>>>>
98656>>>>>                End
98656>>>>>>
98656>>>>>            End
98656>>>>>>
98656>>>>>        End
98656>>>>>>
98656>>>>>
98656>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
98656>>>>>        Get GetCompileDate to dCompileDate
98657>>>>>        If (sVersion <> "") Begin
98659>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
98660>>>>>        End
98660>>>>>>
98660>>>>>    End_Procedure
98661>>>>>
98661>>>>>    Function GetCompileDate Returns Date
98663>>>>>        Date dCompileDate
98663>>>>>        String sAppFilename sData sCompileDate
98663>>>>>        Integer iChannel iPos iDateFormat
98663>>>>>
98663>>>>>        // Get full path to the current running executable
98663>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
98664>>>>>
98664>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
98664>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
98665>>>>>        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
98667>>>>>        Read_Block channel iChannel sData 75            // The compile information we're interested in
98669>>>>>        Send Seq_Close_Channel iChannel
98670>>>>>
98670>>>>>        // The data is padded with Character(0)s. Strip them out
98670>>>>>        Move (CString(sData)) to sData
98671>>>>>
98671>>>>>        // The compile date is after the first ", ", so string parsing is required
98671>>>>>        Move (Pos(", ", sData)) to iPos
98672>>>>>        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
98673>>>>>        // If the current date format is non US, we need to temporary
98673>>>>>        // change the format and then move the string to the date variable.
98673>>>>>        Get_Attribute DF_DATE_FORMAT        to iDateFormat
98676>>>>>        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
98679>>>>>        Move (Date(sCompileDate))           to dCompileDate
98680>>>>>        Set_Attribute DF_DATE_FORMAT        to iDateFormat // Reset date format
98683>>>>>
98683>>>>>        Function_Return dCompileDate
98684>>>>>    End_Function
98685>>>>>
98685>>>>>    Procedure Add_LineLn String sValue
98687>>>>>        Send Add_LineLn of oInfoList_Editor sValue
98688>>>>>    End_Procedure
98689>>>>>
98689>>>>>    Procedure Add_Line String sValue
98691>>>>>        Send Add_Line of oInfoList_Editor sValue
98692>>>>>    End_Procedure
98693>>>>>
98693>>>>>    Procedure Set Logo string sLogo
98695>>>>>        // Square bitmaps of 80x80 work best
98695>>>>>        Set Bitmap of oAboutGraphic to sLogo
98696>>>>>    End_Procedure
98697>>>>>
98697>>>>>    Procedure Set LogoVDF String sLogo
98699>>>>>        Set Bitmap of oPoweredByVDFGraphic to sLogo
98700>>>>>    End_Procedure
98701>>>>>
98701>>>>>    Procedure Show_Sysinfo
98703>>>>>        Send Popup_Modal of oSysinfoDialog
98704>>>>>    End_Procedure
98705>>>>>
98705>>>>>    Procedure Show_HomePage String sWebpage
98707>>>>>        Handle hWnd hInstance
98707>>>>>        Get Window_Handle to hWnd
98708>>>>>        Move (ShellExecute(hWnd, "open", (Trim(sWebpage)), "", "", 1)) to hInstance
98709>>>>>    End_Procedure
98710>>>>>
98710>>>>>//    Procedure End_Construct_Object
98710>>>>>//        Handle hoVersionInfo
98710>>>>>//        Boolean bIncluded
98710>>>>>//        Integer iMajor iMinor iRelease iBuild
98710>>>>>//        String sLabel sVersion
98710>>>>>//
98710>>>>>//        If (sVersion = "") Begin
98710>>>>>//            // This automatically shows the program version of the program, if available.
98710>>>>>//            // It will be displayed as the last item in the edit object.
98710>>>>>//            If (ghoApplication <> 0) Begin
98710>>>>>//                Get phoVersionInfo of ghoApplication to hoVersionInfo
98710>>>>>//                If (hoVersionInfo <> 0) Begin
98710>>>>>//                    Get pbIncluded of hoVersionInfo to bIncluded
98710>>>>>//                    If (bIncluded) Begin
98710>>>>>//                        Get piVersionMajor of hoVersionInfo to iMajor
98710>>>>>//                        Get piVersionMinor of hoVersionInfo to iMinor
98710>>>>>//                        Get piVersionRelease of hoVersionInfo to iRelease
98710>>>>>//                        Get piVersionBuild of hoVersionInfo to iBuild
98710>>>>>//                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
98710>>>>>//                        Set Version to sLabel
98710>>>>>//                    End
98710>>>>>//                End
98710>>>>>//            End
98710>>>>>//        End
98710>>>>>//
98710>>>>>//        Forward Send End_Construct_Object
98710>>>>>//    End_Procedure
98710>>>>>
98710>>>>>End_Class
98711>>>
98711>>>// *************************************************************************
98711>>>//  Public message. This is the default message. It is expected that you will
98711>>>//   create your own message to override this
98711>>>// *************************************************************************
98711>>>
98711>>>Procedure Activate_About
98714>>>   Send DoAbout "" "" "" "" ""
98715>>>End_Procedure
98716>>>
98716>>>// *************************************************************************
98716>>>//  Public message. It is expected that you will send this message (most
98716>>>//  likely from Activate_About. This creates an about object, activates it
98716>>>//  and destroys it when done. It is not exepected that you will augment this.
98716>>>// *************************************************************************
98716>>>// Sample usage:
98716>>>//   The first two params will automatically be filled from the application settings if not provided.
98716>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
98716>>>
98716>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;                  String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
98719>>>        Integer hoObj hoMain iArgs
98719>>>        String sValue
98719>>>
98719>>>        // Create object
98719>>>        Object About is an AboutDialog
98721>>>            // Uncomment these two lines if you would like to have a resizable About object.
98721>>>//            Set Border_Style to Border_Thick
98721>>>//            Set peAnchors to anAll
98721>>>
98721>>>            // Add checking for the number of arguments passed to avoid runtime errors
98721>>>            // if one of them is not passed. This makes the interface
98721>>>            // more flexible.
98721>>>            Move num_arguments to iArgs
98722>>>
98722>>>            // If no title is passed use the label of the main panel (if a main panel exists).
98722>>>            If (iArgs > 0 and sTitle = "") Begin
98724>>>                Get Main_Window of Desktop to hoMain
98725>>>                If hoMain Get Label of hoMain to sValue
98728>>>            End
98728>>>>
98728>>>            Else If (iArgs > 0 and sTitle <> "") Begin
98731>>>                Move sTitle to sValue
98732>>>            End
98732>>>>
98732>>>            Else If (iArgs = 0) Begin
98735>>>                Get Main_Window of Desktop to hoMain
98736>>>                If hoMain Get Label of hoMain to sValue
98739>>>            End
98739>>>>
98739>>>
98739>>>            If (sValue <> "") Send Add_LineLn sValue
98742>>>            Move "" to sValue
98743>>>
98743>>>            // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
98743>>>            // For this to work the Project Properties Version must have been set in the Studio.
98743>>>            If (iArgs < 2) Begin
98745>>>                Move "" to sValue
98746>>>            End
98746>>>>
98746>>>            Else Begin
98747>>>                Move sVersion to sValue
98748>>>            End
98748>>>>
98748>>>            Set Version to sValue
98749>>>
98749>>>            If (iArgs > 2 and sCopyRight <> "") Send Add_LineLn sCopyRight
98752>>>
98752>>>            // If only the five "standard" params were passed we don't add an extra linefeed;
98752>>>            // else we do.
98752>>>            If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
98754>>>                Send Add_Line sAuthor
98755>>>            End
98755>>>>
98755>>>            Else If (iArgs > 5 and sAuthor <> "") Begin
98758>>>                Send Add_LineLn sAuthor
98759>>>            End
98759>>>>
98759>>>
98759>>>            // Square bitmaps of 80x80 works best
98759>>>            If (iArgs > 4 and sBitmap <> "") Begin
98761>>>               Set Logo to sBitMap
98762>>>            End
98762>>>>
98762>>>
98762>>>            // Here starts handling of the five optional params:
98762>>>            If (iArgs = 6 and sParam6  <> "") Begin
98764>>>                Send Add_Line sParam6
98765>>>            End
98765>>>>
98765>>>            Else If (iArgs > 6 and sParam6  <> "") Begin
98768>>>                Send Add_LineLn sParam6
98769>>>            End
98769>>>>
98769>>>
98769>>>            If (iArgs = 7 and sParam7  <> "") Begin
98771>>>                Send Add_Line sParam7
98772>>>            End
98772>>>>
98772>>>            Else If (iArgs > 7 and sParam7  <> "") Begin
98775>>>                Send Add_LineLn sParam7
98776>>>            End
98776>>>>
98776>>>
98776>>>            If (iArgs = 8 and sParam8  <> "") Begin
98778>>>                Send Add_Line sParam8
98779>>>            End
98779>>>>
98779>>>            Else If (iArgs > 8 and sParam8  <> "") Begin
98782>>>                Send Add_LineLn sParam8
98783>>>            End
98783>>>>
98783>>>
98783>>>            If (iArgs = 9 and sParam9  <> "") Begin
98785>>>                Send Add_Line sParam9
98786>>>            End
98786>>>>
98786>>>            Else If (iArgs > 9 and sParam9  <> "") Begin
98789>>>                Send Add_LineLn sParam9
98790>>>            End
98790>>>>
98790>>>
98790>>>            If (iArgs = 10 and sParam10 <> "") Begin
98792>>>                Send Add_Line sParam10
98793>>>            End
98793>>>>
98793>>>
98793>>>            Move Self to hoObj
98794>>>        End_Object
98795>>>
98795>>>        Send Popup   of hoObj // Popup the about object
98796>>>        Send Destroy of hoObj // When done, it will be destroyed
98797>>>End_Procedure
98798>        Use ManageSQLConnections.vw
Including file: ManageSQLConnections.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ManageSQLConnections.vw)
98798>>>Use DFClient.pkg
98798>>>Use cCJCommandBarSystem.pkg
98798>>>Use cCJGrid.pkg
98798>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridColumnRowIndicator.pkg)
98798>>>>>Use cCJGridColumn.pkg
98798>>>>>
98798>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
98799>>>>>    
98799>>>>>    Procedure Construct_Object
98801>>>>>        Forward Send Construct_Object
98803>>>>>    
98803>>>>>        Property Integer piImage 0
98804>>>>>        
98804>>>>>        Set psCaption to ""
98805>>>>>        Set piWidth to 20
98806>>>>>        Set pbResizable to False
98807>>>>>        Set pbEditable to False
98808>>>>>        Set pbFocusable to False
98809>>>>>        Set pbAllowDrag to False
98810>>>>>        Set psToolTip to "Row Indicator"
98811>>>>>//        Set Color to (RGB(217,222,243))   //JVH
98811>>>>>    End_Procedure
98812>>>>>    
98812>>>>>    Procedure OnCreateColumn
98814>>>>>        Integer iImage
98814>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
98816>>>>>        Set piImage to iImage
98817>>>>>    End_Procedure
98818>>>>>            
98818>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
98820>>>>>        Integer iImage iFocusedRow
98820>>>>>        Handle hoDataSource
98820>>>>>        
98820>>>>>        Get phoDataSource to hoDataSource
98821>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
98822>>>>>        Move -1 to iImage
98823>>>>>        If (iRow = iFocusedRow) Begin
98825>>>>>            Get piImage to iImage
98826>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
98827>>>>>        End
98827>>>>>>
98827>>>>>    End_Procedure
98828>>>>>
98828>>>>>End_Class
98829>>>Use cCJGridColumn.pkg
98829>>>Use cSQLConnectionButton.pkg
Including file: cSQLConnectionButton.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionButton.pkg)
98829>>>>>Use cButtonDPI.pkg
Including file: cButtonDPI.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButtonDPI.pkg)
98829>>>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
98829>>>>>>>Class cButtonDPI is a Button
98830>>>>>>>    Procedure Construct_Object 
98832>>>>>>>        Integer iIconSize
98832>>>>>>>        Forward Send Construct_Object
98834>>>>>>>        Get GetCorrectIconSize to iIconSize
98835>>>>>>>        Set piImageSize to iIconSize
98836>>>>>>>    End_Procedure
98837>>>>>>>
98837>>>>>>>    // Returns: DPI setting as an integer.
98837>>>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
98837>>>>>>>    //                      iDPI=120 is "Medium setting" 125%
98837>>>>>>>    //                      iDPI= 144 is "Large setting" 150%
98837>>>>>>>    Function GetCurrentDPI Returns Integer
98839>>>>>>>        Handle hDC
98839>>>>>>>        Integer iPixelsX
98839>>>>>>>        Move (GetDC(0)) to hDC
98840>>>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
98841>>>>>>>        Move (ReleaseDC(0, hDC)) to hDC
98842>>>>>>>        Function_Return iPixelsX
98843>>>>>>>    End_Function  
98844>>>>>>>    
98844>>>>>>>    Function GetCorrectIconSize Returns Integer
98846>>>>>>>        Integer iPixelsX iIndex iSize 
98846>>>>>>>        Integer[] iaSizes
98847>>>>>>>        
98847>>>>>>>        Move 16 to iaSizes[0]
98848>>>>>>>        Move 24 to iaSizes[1]
98849>>>>>>>        Move 32 to iaSizes[2]
98850>>>>>>>        Move 48 to iaSizes[3]
98851>>>>>>>        Move 64 to iaSizes[4]
98852>>>>>>>        
98852>>>>>>>        Get piImageSize to iSize  // the "100%" size
98853>>>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
98854>>>>>>>        Move (0 max iIndex) to iIndex
98855>>>>>>>        Get GetCurrentDPI to iPixelsX
98856>>>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
98856>>>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
98856>>>>>>>        // will increment iIndex as many times as we need here.
98856>>>>>>>        Case Begin
98856>>>>>>>            Case (iPixelsX > 144)
98858>>>>>>>                Increment iIndex
98859>>>>>>>            Case (iPixelsX = 144)
98862>>>>>>>                Increment iIndex
98863>>>>>>>            Case (iPixelsX = 120)
98866>>>>>>>                Increment iIndex  
98867>>>>>>>        Case End
98867>>>>>>>        Move (iIndex min 4) to iIndex
98868>>>>>>>        Function_Return iaSizes[iIndex]
98869>>>>>>>    End_Function
98870>>>>>>>    
98870>>>>>>>//    Function GetCorrectIconSize Returns Integer
98870>>>>>>>//        Integer iPixelsX iRetval
98870>>>>>>>//        Get GetCurrentDPI to iPixelsX
98870>>>>>>>//        Case Begin
98870>>>>>>>//            Case (iPixelsX < 120)
98870>>>>>>>//                Move 16 to iRetval
98870>>>>>>>//                Case Break
98870>>>>>>>//            Case (iPixelsX = 120)
98870>>>>>>>//                Move 24 to iRetval
98870>>>>>>>//                Case Break
98870>>>>>>>//            Case (iPixelsX = 144)
98870>>>>>>>//                Move 32 to iRetval
98870>>>>>>>//                Case Break
98870>>>>>>>//            Case (iPixelsX > 144)
98870>>>>>>>//                Move 48 to iRetval
98870>>>>>>>//                Case Break
98870>>>>>>>//        Case End                
98870>>>>>>>//        Function_Return iRetval
98870>>>>>>>//    End_Function
98870>>>>>>>
98870>>>>>>>End_Class
98871>>>>>
98871>>>>>// New button class so we constantly can display the ini-filename in the status_help area:
98871>>>>>Class cSQLConnectionButton is a cButtonDPI
98872>>>>>    Procedure Construct_Object 
98874>>>>>        Forward Send Construct_Object
98876>>>>>    End_Procedure
98877>>>>>
98877>>>>>    Procedure End_Construct_Object
98879>>>>>        String sLabel sImage
98879>>>>>        Forward Send End_Construct_Object
98881>>>>>        Get psImage to sImage
98882>>>>>        If (sImage = "") Begin
98884>>>>>            Get Label to sLabel
98885>>>>>            Move (Replace("&", sLabel, "")) to sLabel
98886>>>>>            Move (Replace("...", sLabel, "")) to sLabel
98887>>>>>            Set psImage to ("Action" + sLabel + ".ico")
98888>>>>>        End
98888>>>>>>
98888>>>>>    End_Procedure
98889>>>>>
98889>>>>>    Function Status_Help String Item# Returns String
98891>>>>>        String sRetval
98891>>>>>        Delegate Get IniFileName to sRetval
98893>>>>>        Function_Return sRetval
98894>>>>>    End_Function
98895>>>>>
98895>>>>>End_Class
98896>>>
98896>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
98896>>>>>Use Windows.pkg
98896>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridPromptList.pkg)
98896>>>>>>>Use Windows.pkg
98896>>>>>>>Use cCJGrid.pkg
98896>>>>>>>
98896>>>>>>>
98896>>>>>>>
98896>>>>>>>Class cCJGridPromptList is a cCJGrid
98897>>>>>>>
98897>>>>>>>    Procedure Construct_Object
98899>>>>>>>        Forward Send Construct_Object
98901>>>>>>>
98901>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
98902>>>>>>>        Property Boolean Private_pbAutoOrdering True
98903>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
98904>>>>>>>        Property Integer peUpdateMode umPromptValue
98905>>>>>>>        Property Integer piUpdateColumn 0
98906>>>>>>>        Property Integer piInitialColumn -1
98907>>>>>>>        Property String  psSeedValue ''
98908>>>>>>>        Property Handle phmPromptUpdateCallback 0
98909>>>>>>>        Property Integer phoInvokingObject
98910>>>>>>>        
98910>>>>>>>        Property Boolean pbStoredAutoSeed
98911>>>>>>>        Property Boolean pbStoredAutoOrdering
98912>>>>>>>        Property Boolean pbStoredAutoSearch
98913>>>>>>>        Property Integer peStoredUpdateMode
98914>>>>>>>        Property Integer piStoredUpdateColumn
98915>>>>>>>        Property Integer piStoredInitialColumn
98916>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
98917>>>>>>>        Property Boolean pbStoredSelectionEnable
98918>>>>>>>        Property Boolean pbStoredMultipleSelection
98919>>>>>>>
98919>>>>>>>        // internally set by list
98919>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
98919>>>>>>>        Property Boolean pbCanceled
98920>>>>>>>        Property Integer[] pSelectedRows
98921>>>>>>>
98921>>>>>>>        Property Boolean pbNeedsNewOrdering
98922>>>>>>>        Property Boolean pbRequestSearch
98923>>>>>>>        Property tGridKeyPair[] pSearchKeys
98924>>>>>>>        
98924>>>>>>>        // these properties makes a prompt list a prompt list
98924>>>>>>>        // and should not be changed.
98924>>>>>>>        Set pbEditOnKeyNavigation to False
98925>>>>>>>        Set pbEditOnClick to False
98926>>>>>>>        Set pbReadOnly to True
98927>>>>>>>        Set pbFocusSubItems to True
98928>>>>>>>        
98928>>>>>>>        // these could maybe be changed
98928>>>>>>>        Set pbShadeSortColumn to True
98929>>>>>>>        Set pbHeaderReorders to True
98930>>>>>>>        Set pbHeaderTogglesDirection to True
98931>>>>>>>        Set pbHeaderSelectsColumn to True
98932>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
98933>>>>>>>        Set piFocusCellBackColor to clNone
98934>>>>>>>        Set piFocusCellForeColor to clNone
98935>>>>>>>        Set piFocusCellRectangleColor to clBlack
98936>>>>>>>        Set pbUseFocusCellRectangle to False
98937>>>>>>>        Set pbSelectionEnable to True
98938>>>>>>>        
98938>>>>>>>        On_Key kEnter Send Ok
98939>>>>>>>        On_Key kCancel Send Cancel
98940>>>>>>>
98940>>>>>>>    End_Procedure
98941>>>>>>>    
98941>>>>>>>    // reorder list automatically on column change
98941>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
98941>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
98943>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
98944>>>>>>>        Set pbFocusSubItems to bAutoOrder
98945>>>>>>>    End_Procedure
98946>>>>>>>    
98946>>>>>>>    Function pbAutoOrdering Returns Boolean
98948>>>>>>>        Boolean bAutoOrder
98948>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
98949>>>>>>>        Function_Return bAutoOrder
98950>>>>>>>    End_Function
98951>>>>>>>
98951>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
98951>>>>>>>    Procedure OnIdle
98953>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
98953>>>>>>>        Handle hoCol
98953>>>>>>>        Integer iKy1 iKy2 iCol
98953>>>>>>>
98953>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
98954>>>>>>>        If bNeedsReorder Begin
98956>>>>>>>            Get SelectedColumn to iCol
98957>>>>>>>            If (iCol<>-1) Begin
98959>>>>>>>                
98959>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
98960>>>>>>>                Set pbHeaderTogglesDirection to False
98961>>>>>>>                Send HeaderReorder iCol
98962>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
98963>>>>>>>                
98963>>>>>>>                Set pbNeedsNewOrdering to False
98964>>>>>>>            End
98964>>>>>>>>
98964>>>>>>>        End
98964>>>>>>>>
98964>>>>>>>        
98964>>>>>>>        Get pbRequestSearch to bSearch
98965>>>>>>>        If bSearch Begin
98967>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
98968>>>>>>>        End
98968>>>>>>>>
98968>>>>>>>        
98968>>>>>>>        Forward Send OnIdle
98970>>>>>>>    End_Procedure
98971>>>>>>>    
98971>>>>>>>    Procedure OnStoreDefaults
98973>>>>>>>        Integer iVal
98973>>>>>>>        Boolean bVal
98973>>>>>>>
98973>>>>>>>        Get pbAutoSeed to bVal           
98974>>>>>>>        Set pbStoredAutoSeed to bVal           
98975>>>>>>>        
98975>>>>>>>        Get pbAutoOrdering to bVal        
98976>>>>>>>        Set pbStoredAutoOrdering to bVal      
98977>>>>>>>        
98977>>>>>>>        Get pbAutoSearch to bVal         
98978>>>>>>>        Set pbStoredAutoSearch to bVal         
98979>>>>>>>        
98979>>>>>>>        Get peUpdateMode to iVal
98980>>>>>>>        Set peStoredUpdateMode to iVal
98981>>>>>>>        
98981>>>>>>>        Get piUpdateColumn to iVal       
98982>>>>>>>        Set piStoredUpdateColumn to iVal       
98983>>>>>>>
98983>>>>>>>        Get piInitialColumn to iVal       
98984>>>>>>>        Set piStoredInitialColumn to iVal       
98985>>>>>>>
98985>>>>>>>        Get phmPromptUpdateCallback to iVal       
98986>>>>>>>        Set phmStoredPromptUpdateCallback to iVal       
98987>>>>>>>
98987>>>>>>>        Get pbSelectionEnable to bVal
98988>>>>>>>        Set pbStoredSelectionEnable to bVal
98989>>>>>>>        
98989>>>>>>>        Get pbMultipleSelection to bVal
98990>>>>>>>        Set pbStoredMultipleSelection to bVal
98991>>>>>>>        
98991>>>>>>>    End_Procedure
98992>>>>>>>
98992>>>>>>>    Procedure OnRestoreDefaults
98994>>>>>>>        Integer iVal
98994>>>>>>>        Boolean bVal
98994>>>>>>>
98994>>>>>>>        Get pbStoredAutoSeed to bVal           
98995>>>>>>>        Set pbAutoSeed to bVal           
98996>>>>>>>        
98996>>>>>>>        Get pbStoredAutoOrdering to bVal        
98997>>>>>>>        Set pbAutoOrdering to bVal      
98998>>>>>>>        
98998>>>>>>>        Get pbStoredAutoSearch to bVal         
98999>>>>>>>        Set pbAutoSearch to bVal         
99000>>>>>>>        
99000>>>>>>>        Get peStoredUpdateMode to iVal
99001>>>>>>>        Set peUpdateMode to iVal
99002>>>>>>>        
99002>>>>>>>        Get piStoredInitialColumn to iVal       
99003>>>>>>>        Set piInitialColumn to iVal       
99004>>>>>>>        
99004>>>>>>>        Get phmStoredPromptUpdateCallback to iVal       
99005>>>>>>>        Set phmPromptUpdateCallback to iVal       
99006>>>>>>>
99006>>>>>>>        Get pbStoredSelectionEnable to bVal
99007>>>>>>>        Set pbSelectionEnable to bVal
99008>>>>>>>        
99008>>>>>>>        Get pbStoredMultipleSelection to bVal
99009>>>>>>>        Set pbMultipleSelection to bVal
99010>>>>>>>
99010>>>>>>>    End_Procedure
99011>>>>>>>    
99011>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
99011>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
99011>>>>>>>    // Suitable for augmentation
99011>>>>>>>    Procedure OnSeedData
99013>>>>>>>        Integer iUpdateColumn iSortColumn
99013>>>>>>>        Boolean bSeed bAuto
99013>>>>>>>        String sValue
99013>>>>>>>        Handle hoCol
99013>>>>>>>
99013>>>>>>>        Get piUpdateColumn to iUpdateColumn
99014>>>>>>>        Get psSeedValue to sValue
99015>>>>>>>        Get pbAutoSeed to bSeed
99016>>>>>>>        Get piSortColumn to iSortColumn
99017>>>>>>>        Get pbAutoOrdering to bAuto
99018>>>>>>>        // if not yet sorted and this is auto ordering we will
99018>>>>>>>        // sort the data for the search column. We do this to make the
99018>>>>>>>        // column search GE logic work properly. 
99018>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
99020>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
99021>>>>>>>            Send SortGridByColumn hoCol False
99022>>>>>>>        End
99022>>>>>>>>
99022>>>>>>>
99022>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
99024>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0  
99025>>>>>>>        End
99025>>>>>>>>
99025>>>>>>>        Else Begin
99026>>>>>>>            Send MovetoFirstRow
99027>>>>>>>        End
99027>>>>>>>>
99027>>>>>>>
99027>>>>>>>    End_Function
99028>>>>>>>
99028>>>>>>>    Procedure OnMoveValueOutByValue
99030>>>>>>>        String sValue
99030>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
99030>>>>>>>        Integer iRow iCol
99030>>>>>>>        Integer[] SelRowsIndexes
99031>>>>>>>
99031>>>>>>>        Get phoInvokingObject to hoInvokingObject
99032>>>>>>>        Get pSelectedRows to SelRowsIndexes
99033>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
99035>>>>>>>            Get piUpdateColumn to iCol
99036>>>>>>>            Get ColumnObject iCol to hoCol
99037>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
99038>>>>>>>            Set Value of hoInvokingObject to sValue
99039>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
99040>>>>>>>        End
99040>>>>>>>>
99040>>>>>>>    End_Procedure
99041>>>>>>>
99041>>>>>>>    Procedure OnMoveValueOutByCustom
99043>>>>>>>    End_Procedure
99044>>>>>>>
99044>>>>>>>    // augment to popup a search window when allowed
99044>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
99046>>>>>>>        Boolean bSubFocus bAutoSearch bChar
99046>>>>>>>        Integer iVal
99046>>>>>>>        
99046>>>>>>>        Get pbFocusSubItems to bSubFocus
99047>>>>>>>        Get pbAutoSearch to bAutoSearch
99048>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
99050>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
99052>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
99054>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
99055>>>>>>>                Move (iVal<>0) to bChar
99056>>>>>>>            End
99056>>>>>>>>
99056>>>>>>>            If bChar Begin
99058>>>>>>>                // this can get called multiple times before a search dialog pops up
99058>>>>>>>                Send AddToSearchKeys llKeyCode llShift
99059>>>>>>>            End
99059>>>>>>>>
99059>>>>>>>        End
99059>>>>>>>>
99059>>>>>>>    End_Procedure
99060>>>>>>>    
99060>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
99062>>>>>>>        Boolean bAutoSearch
99062>>>>>>>        Integer iKeyCode iShiftCode
99062>>>>>>>        Get pbAutoSearch to bAutoSearch
99063>>>>>>>        If bAutoSearch Begin
99065>>>>>>>            // this can get called multiple times before a search dialog pops up
99065>>>>>>>            Get piLastKey to iKeyCode
99066>>>>>>>            Get piLastKey2 to iShiftCode
99067>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
99068>>>>>>>        End
99068>>>>>>>>
99068>>>>>>>        Move True to llCancel
99069>>>>>>>    End_Procedure  // OnComRequestEdit
99070>>>>>>>    
99070>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
99072>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
99073>>>>>>>        Forward Send OnComRowDblClick llRow llItem
99075>>>>>>>    End_Procedure
99076>>>>>>>    
99076>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
99078>>>>>>>        Send Ok
99079>>>>>>>    End_Procedure
99080>>>>>>>    
99080>>>>>>>    
99080>>>>>>>    // we don't want a menu for prompt lists
99080>>>>>>>    Function CreateContextMenu Returns Handle
99082>>>>>>>        Function_Return 0
99083>>>>>>>    End_Function
99084>>>>>>>
99084>>>>>>>    // if we use auto-ordering, change the order when the column changes
99084>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
99086>>>>>>>        Boolean bAutoOrder
99086>>>>>>>        Forward Send ColumnChanged iOld iNew
99088>>>>>>>        Get pbAutoOrdering to bAutoOrder
99089>>>>>>>        If bAutoOrder Begin
99091>>>>>>>            // will be reordered in idle event
99091>>>>>>>            Set pbNeedsNewOrdering to True
99092>>>>>>>        End
99092>>>>>>>>
99092>>>>>>>    End_Procedure
99093>>>>>>>    
99093>>>>>>>
99093>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
99095>>>>>>>        Integer eMode
99095>>>>>>>        Integer[] SelRowsIndexes
99096>>>>>>>        Set pbCanceled to True // assume cancel unless changed
99097>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
99098>>>>>>>        Get peUpdateMode to eMode
99099>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
99101>>>>>>>            Send OnStoreDefaults
99102>>>>>>>        End
99102>>>>>>>>
99102>>>>>>>        Send InitializePromptList
99103>>>>>>>        Forward Send Add_Focus hoParent
99105>>>>>>>        Send LoadData
99106>>>>>>>        Set psSeedValue to ""
99107>>>>>>>    End_Procedure
99108>>>>>>>    
99108>>>>>>>    // called before the list is activated. 
99108>>>>>>>    Procedure InitializePromptList
99110>>>>>>>        Integer hoInvokingObject
99110>>>>>>>        Boolean bAutoColumn bAutoSeed 
99110>>>>>>>        Integer i iOldMode eUpdateMode
99110>>>>>>>        String sValue
99110>>>>>>>        
99110>>>>>>>        Get peUpdateMode to eUpdateMode
99111>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
99113>>>>>>>            Get Focus of Desktop to hoInvokingObject
99114>>>>>>>            If (hoInvokingObject<=Desktop) Begin
99116>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
99117>>>>>>>>
99117>>>>>>>                Procedure_Return
99118>>>>>>>            End
99118>>>>>>>>
99118>>>>>>>
99118>>>>>>>            Set phoInvokingObject to hoInvokingObject
99119>>>>>>>
99119>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
99120>>>>>>>            Get peUpdateMode to eUpdateMode
99121>>>>>>>        End
99121>>>>>>>>
99121>>>>>>>
99121>>>>>>>        Send ClearSearchRequest // clear the search keys
99122>>>>>>>        Set pbNeedsNewOrdering to False
99123>>>>>>>
99123>>>>>>>        Get pbAutoSeed to bAutoSeed
99124>>>>>>>
99124>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
99126>>>>>>>            Get Value of hoInvokingObject to sValue
99127>>>>>>>            Set psSeedValue to sValue
99128>>>>>>>        End
99128>>>>>>>>
99128>>>>>>>        
99128>>>>>>>    End_Procedure
99129>>>>>>>    
99129>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
99129>>>>>>>    Procedure LoadData
99131>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
99131>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
99131>>>>>>>        Integer eUpdateMode
99131>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder 
99131>>>>>>>        
99131>>>>>>>        Get phoDataSource to hoDataSource
99132>>>>>>>        Get peUpdateMode to eUpdateMode
99133>>>>>>>        Get phoInvokingObject to hoInvokingObject
99134>>>>>>>        Get pbAutoSeed to bAutoSeed
99135>>>>>>>        Get piInitialColumn to iInitialColumn
99136>>>>>>>        Get piUpdateColumn to iUpdateColumn
99137>>>>>>>        Get RowCount of hoDataSource to iRows
99138>>>>>>>        
99138>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
99138>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
99138>>>>>>>        If (iInitialColumn=-1) Begin
99140>>>>>>>            Move iUpdateColumn to iInitialColumn
99141>>>>>>>        End
99141>>>>>>>>
99141>>>>>>>        If (iInitialColumn>=0) Begin
99143>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
99144>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
99145>>>>>>>        End
99145>>>>>>>>
99145>>>>>>>        Send OnSeedData // find a good starting place for the row
99146>>>>>>>        Get pbFocusSubItems to bSubFocus
99147>>>>>>>        If bSubFocus Begin
99149>>>>>>>            // if column focus, which is normal, go to initialcolumn       
99149>>>>>>>            If hoInitialColumn Begin
99151>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
99152>>>>>>>            End
99152>>>>>>>>
99152>>>>>>>            Else Begin
99153>>>>>>>                Send MoveToFirstEnterableColumn
99154>>>>>>>            End
99154>>>>>>>>
99154>>>>>>>        End
99154>>>>>>>>
99154>>>>>>>
99154>>>>>>>    End_Procedure
99155>>>>>>>    
99155>>>>>>>    // This is only called in a successful close
99155>>>>>>>    Procedure ClosePromptList
99157>>>>>>>        Handle hoDataSource hoInvokingObject
99157>>>>>>>        Handle hmCallBack
99157>>>>>>>        Integer iRow eUpdateMode
99157>>>>>>>        Integer[] SelRowsIndexes
99158>>>>>>>        
99158>>>>>>>        Get phoDataSource to hoDataSource
99159>>>>>>>        Get phoInvokingObject to hoInvokingObject
99160>>>>>>>        
99160>>>>>>>        If (pbMultipleSelection(Self)) Begin
99162>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
99163>>>>>>>        End
99163>>>>>>>>
99163>>>>>>>        Else Begin
99164>>>>>>>            Get SelectedRow of hoDataSource to iRow
99165>>>>>>>            If (iRow<>-1) Begin
99167>>>>>>>                Move iRow to SelRowsIndexes[0]
99168>>>>>>>            End
99168>>>>>>>>
99168>>>>>>>        End
99168>>>>>>>>
99168>>>>>>>        
99168>>>>>>>        Set pbCanceled to False
99169>>>>>>>        Set pSelectedRows to SelRowsIndexes
99170>>>>>>>        
99170>>>>>>>        Get peUpdateMode to eUpdateMode
99171>>>>>>>        // if non-invoking there is by definition, no move value out
99171>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
99173>>>>>>>            
99173>>>>>>>            If (eUpdateMode=umPromptValue) Begin
99175>>>>>>>                Send OnMoveValueOutByValue
99176>>>>>>>            End
99176>>>>>>>>
99176>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
99179>>>>>>>                Send OnMoveValueOutByCustom
99180>>>>>>>            End
99180>>>>>>>>
99180>>>>>>>                Get phmPromptUpdateCallback to hmCallBack
99181>>>>>>>                If hmCallBack Begin
99183>>>>>>>                    Send hmCallBack of hoInvokingObject Self
99184>>>>>>>                End
99184>>>>>>>>
99184>>>>>>>        End
99184>>>>>>>>
99184>>>>>>>
99184>>>>>>>        Send Close_Panel
99185>>>>>>>    End_Procedure
99186>>>>>>>
99186>>>>>>>    // augment to send OnRestoreDefaults.
99186>>>>>>>    Procedure Release_Focus
99188>>>>>>>        Integer eUpdateMode
99188>>>>>>>        Get peUpdateMode to eUpdateMode
99189>>>>>>>        Forward Send Release_Focus
99191>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
99193>>>>>>>            Send OnRestoreDefaults
99194>>>>>>>        End
99194>>>>>>>>
99194>>>>>>>    End_Procedure
99195>>>>>>>    
99195>>>>>>>    Function SelectedRowIds Returns RowID[]
99197>>>>>>>        RowID[] SelectedRowids
99198>>>>>>>        Integer[] SelectedRows
99199>>>>>>>        Integer i iRows
99199>>>>>>>        Handle hoDataSource
99199>>>>>>>        Get phoDataSource to hoDataSource
99200>>>>>>>        Get pSelectedRows to SelectedRows
99201>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
99202>>>>>>>        For i from 0 to (iRows-1)
99208>>>>>>>>
99208>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
99209>>>>>>>        Loop
99210>>>>>>>>
99210>>>>>>>        Function_Return SelectedRowids
99211>>>>>>>    End_Function
99212>>>>>>>
99212>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
99214>>>>>>>        String[] SelectedValues
99215>>>>>>>        Integer[] SelectedRows
99216>>>>>>>        Integer i iRows
99216>>>>>>>        Handle hoCol
99216>>>>>>>        Get ColumnObject iCol to hoCol
99217>>>>>>>        Get pSelectedRows to SelectedRows
99218>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
99219>>>>>>>        For i from 0 to (iRows-1)
99225>>>>>>>>
99225>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
99226>>>>>>>        Loop
99227>>>>>>>>
99227>>>>>>>        Function_Return SelectedValues
99228>>>>>>>    End_Function
99229>>>>>>>
99229>>>>>>>    Procedure Ok Returns Integer
99231>>>>>>>        Send ClosePromptList
99232>>>>>>>    End_Procedure
99233>>>>>>>
99233>>>>>>>    Procedure Cancel Returns Integer
99235>>>>>>>        Send Close_Panel
99236>>>>>>>    End_Procedure
99237>>>>>>>        
99237>>>>>>>    Procedure Search
99239>>>>>>>        Send Activate // give focus back to list so focus things are correct
99240>>>>>>>        Send Request_Search 0 0
99241>>>>>>>    End_Procedure
99242>>>>>>>    
99242>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
99242>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
99242>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
99242>>>>>>>    Procedure Request_SearchEx
99244>>>>>>>        tGridKeyPair[] Keys
99244>>>>>>>        tGridKeyPair[] Keys
99245>>>>>>>        Integer iCol
99245>>>>>>>        Handle hoCol hoSearchDialog 
99245>>>>>>>        Boolean bOk
99245>>>>>>>        String sValue
99245>>>>>>>
99245>>>>>>>        Get piSortColumn to iCol
99246>>>>>>>        If (iCol<>-1) Begin
99248>>>>>>>            Get ColumnObject iCol to hoCol
99249>>>>>>>                Get pSearchKeys to Keys
99250>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
99251>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
99252>>>>>>>            If bOk Begin
99254>>>>>>>               Send RequestFindColumnValue iCol sValue True 0  
99255>>>>>>>            End
99255>>>>>>>>
99255>>>>>>>            Send Destroy of hoSearchDialog
99256>>>>>>>        End
99256>>>>>>>>
99256>>>>>>>        Send ClearSearchRequest // clear the search keys
99257>>>>>>>    End_Procedure
99258>>>>>>>    
99258>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
99258>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
99260>>>>>>>        tGridKeyPair[] Keys
99260>>>>>>>        tGridKeyPair[] Keys
99261>>>>>>>        tGridKeyPair KeyPair
99261>>>>>>>        tGridKeyPair KeyPair
99261>>>>>>>        Set pbRequestSearch to True
99262>>>>>>>        Move iKeyCode to KeyPair.KeyCode
99263>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
99264>>>>>>>        Get pSearchKeys to Keys                
99265>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
99266>>>>>>>        Set pSearchKeys to Keys                
99267>>>>>>>    End_Procedure
99268>>>>>>>
99268>>>>>>>    Procedure ClearSearchRequest
99270>>>>>>>        tGridKeyPair[] SearchKeys
99270>>>>>>>        tGridKeyPair[] SearchKeys
99271>>>>>>>        Set pSearchKeys to SearchKeys
99272>>>>>>>        Set pbRequestSearch to False
99273>>>>>>>    End_Procedure
99274>>>>>>>    
99274>>>>>>>End_Class
99275>>>>>Use cDbUpdateFunctionLibrary.pkg
99275>>>>>Use MSSqldrv.pkg
99275>>>>>Use db2_drv.pkg
99275>>>>>Use odbc_drv.pkg
99275>>>>>
99275>>>>>Object oDatabaseSelection_sl is a ModalPanel
99277>>>>>    Set Label to "SQL Database Selection"
99278>>>>>    Set Size to 121 183
99279>>>>>    Set piMinSize to 89 170
99280>>>>>    Set Location to 2 2
99281>>>>>    Set Border_Style to Border_Thick
99282>>>>>
99282>>>>>    Property String[] psTheData
99284>>>>>
99284>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
99286>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
99288>>>>>        End_Object
99289>>>>>    End
99289>>>>>>
99289>>>>>
99289>>>>>    Object oSelList is a cCJGridPromptList
99291>>>>>        Set Size to 89 167
99292>>>>>        Set Location to 6 6
99293>>>>>        Set peAnchors to anAll
99294>>>>>        Set pbAllowColumnRemove to False
99295>>>>>        Set pbUseAlternateRowBackgroundColor to True
99296>>>>>        Set pbGrayIfDisable to False
99297>>>>>        Set pbHeaderReorders to False
99298>>>>>        Set pbHeaderSelectsColumn to False
99299>>>>>        Set pbHeaderTogglesDirection to False
99300>>>>>        Set pbShadeSortColumn to False
99301>>>>>        Set piFocusCellBackColor to clDkGray
99302>>>>>
99302>>>>>        Object oName is a cCJGridColumn
99304>>>>>            Set piWidth to 334
99305>>>>>            Set psCaption to "Database Name"
99306>>>>>        End_Object
99307>>>>>
99307>>>>>        Procedure Activating
99310>>>>>            tDataSourceRow[] MyData
99310>>>>>            tDataSourceRow[] MyData
99311>>>>>            Handle hoDataSource
99311>>>>>            String[] sTheData
99312>>>>>            Integer iCount iSize
99312>>>>>
99312>>>>>            Send Cursor_Wait of Cursor_Control
99313>>>>>            Forward Send Activating
99315>>>>>
99315>>>>>            Get psTheData to sTheData
99316>>>>>            Move (SizeOfArray(sTheData)) to iSize
99317>>>>>            Decrement iSize
99318>>>>>            For iCount from 0 to iSize
99324>>>>>>
99324>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
99325>>>>>            Loop
99326>>>>>>
99326>>>>>
99326>>>>>            Get phoDataSource to hoDataSource
99327>>>>>            Send InitializeData of hoDataSource MyData
99328>>>>>            Send Cursor_Ready of Cursor_Control
99329>>>>>        End_Procedure
99330>>>>>
99330>>>>>    End_Object
99331>>>>>
99331>>>>>    Object oOK_Btn is a Button
99333>>>>>        Set Label    to "&OK"
99334>>>>>        Set Location to 100 68
99335>>>>>        Set peAnchors To anBottomRight
99336>>>>>
99336>>>>>        Procedure OnClick
99339>>>>>            Send Ok of oSelList
99340>>>>>        End_Procedure
99341>>>>>
99341>>>>>    End_Object
99342>>>>>
99342>>>>>    Object oCancel_Btn is a Button
99344>>>>>        Set Label    to "&Cancel"
99345>>>>>        Set Location to 100 123
99346>>>>>        Set peAnchors to anBottomRight
99347>>>>>
99347>>>>>        Procedure OnClick
99350>>>>>            Send Close_Panel
99351>>>>>        End_Procedure
99352>>>>>
99352>>>>>    End_Object
99353>>>>>
99353>>>>>    Procedure Page Integer iPageObject
99356>>>>>        Set Icon to "DatabaseLookup.ico"
99357>>>>>        Forward Send Page iPageObject
99359>>>>>    End_Procedure
99360>>>>>
99360>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99361>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99362>>>>>End_Object
99363>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ServerSelection.dg)
99363>>>>>Use Windows.pkg
99363>>>>>Use cCJGridPromptList.pkg
99363>>>>>Use cDbUpdateFunctionLibrary.pkg
99363>>>>>Use MSSqldrv.pkg
99363>>>>>Use db2_drv.pkg
99363>>>>>Use odbc_drv.pkg
99363>>>>>
99363>>>>>Object oServerSelection_sl is a ModalPanel
99365>>>>>    Set Size to 148 274
99366>>>>>    Set Label to "Database Server/DSN Selection"
99367>>>>>    Set piMinSize to 89 211
99368>>>>>    Set Location to 2 2
99369>>>>>    Set Border_Style to Border_Thick
99370>>>>>
99370>>>>>    Property String[] psTheData
99372>>>>>
99372>>>>>    Object oSelList is a cCJGridPromptList
99374>>>>>        Set Size to 115 264
99375>>>>>        Set Location to 6 6
99376>>>>>        Set peAnchors to anAll
99377>>>>>        Set pbAllowColumnRemove to False
99378>>>>>        Set pbUseAlternateRowBackgroundColor to True
99379>>>>>        Set pbGrayIfDisable to False
99380>>>>>        Set pbHeaderReorders to False
99381>>>>>        Set pbHeaderSelectsColumn to False
99382>>>>>        Set pbHeaderTogglesDirection to False
99383>>>>>        Set pbShadeSortColumn to False
99384>>>>>        Set piFocusCellBackColor to clDkGray
99385>>>>>
99385>>>>>        Object oName is a cCJGridColumn
99387>>>>>            Set piWidth to 528
99388>>>>>            Set psCaption to "Name"
99389>>>>>        End_Object
99390>>>>>
99390>>>>>        Procedure Activating
99393>>>>>            tDataSourceRow[] MyData
99393>>>>>            tDataSourceRow[] MyData
99394>>>>>            Handle hoDataSource
99394>>>>>            String[] sTheData
99395>>>>>            Integer iCount iSize
99395>>>>>
99395>>>>>            Send Cursor_Wait of Cursor_Control
99396>>>>>            Get psTheData to sTheData
99397>>>>>            Move (SizeOfArray(sTheData)) to iSize
99398>>>>>            Decrement iSize
99399>>>>>            For iCount from 0 to iSize
99405>>>>>>
99405>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
99406>>>>>            Loop
99407>>>>>>
99407>>>>>
99407>>>>>            Forward Send Activating
99409>>>>>
99409>>>>>            Get phoDataSource to hoDataSource
99410>>>>>            Send InitializeData of hoDataSource MyData
99411>>>>>            Send Cursor_Ready of Cursor_Control
99412>>>>>        End_Procedure
99413>>>>>
99413>>>>>    End_Object
99414>>>>>
99414>>>>>    Object oOK_Btn is a Button
99416>>>>>        Set Label    to "&OK"
99417>>>>>        Set Location to 130 165
99418>>>>>        Set peAnchors To anBottomRight
99419>>>>>
99419>>>>>        Procedure OnClick
99422>>>>>            Send Ok of oSelList
99423>>>>>        End_Procedure
99424>>>>>
99424>>>>>    End_Object
99425>>>>>
99425>>>>>    Object oCancel_Btn is a Button
99427>>>>>        Set Label    to "&Cancel"
99428>>>>>        Set Location to 130 220
99429>>>>>        Set peAnchors to anBottomRight
99430>>>>>
99430>>>>>        Procedure OnClick
99433>>>>>            Send Close_Panel
99434>>>>>        End_Procedure
99435>>>>>
99435>>>>>    End_Object
99436>>>>>
99436>>>>>    Procedure Page Integer iPageObject
99439>>>>>        Set Icon to "ServerLookup.ico"
99440>>>>>        Forward Send Page iPageObject
99442>>>>>    End_Procedure
99443>>>>>
99443>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99444>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99445>>>>>End_Object
99446>>>Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
99446>>>>>Use Windows.pkg
99446>>>>>Use Cursor.pkg
99446>>>>>Use cButtonDPI.pkg
99446>>>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
99446>>>>>>>Use Windows.pkg
99446>>>>>>>
99446>>>>>>>// Used by the "Page" message below to show
99446>>>>>>>// a rectangle around ComboForm and Checkbox objects.
99446>>>>>>>    Define WM_CHANGEUISTATE for |CI$0127
99446>>>>>>>    Define WM_UPDATEUISTATE for |CI$0128
99446>>>>>>>    Define WM_QUERYUISTATE  for |CI$0129
99446>>>>>>>    Define UIS_SET          for 1
99446>>>>>>>    Define UIS_CLEAR        for 2
99446>>>>>>>    Define UIS_INITIALIZE   for 3
99446>>>>>>>    Define UISF_HIDEFOCUS   for |CI$1
99446>>>>>>>    Define UISF_HIDEACCEL   for |CI$2
99446>>>>>>>    Define UISF_ACTIVE      for |CI$4
99446>>>>>>>
99446>>>>>>>Class cSQLCheckBox is a CheckBox
99447>>>>>>>    Procedure Construct_Object
99449>>>>>>>        Forward Send Construct_Object
99451>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
99451>>>>>>>        Property Integer piItem
99452>>>>>>>    End_Procedure
99453>>>>>>>
99453>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
99455>>>>>>>    End_Procedure
99456>>>>>>>
99456>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
99458>>>>>>>        Integer iItem
99458>>>>>>>        Get piItem to iItem
99459>>>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
99460>>>>>>>    End_Procedure
99461>>>>>>>
99461>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
99463>>>>>>>        Boolean bState
99463>>>>>>>        Integer iItem
99463>>>>>>>        Get piItem to iItem
99464>>>>>>>        Get Checked_State to bState
99465>>>>>>>        Move bState to sConnectionData[iItem]
99466>>>>>>>    End_Procedure
99467>>>>>>>
99467>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
99467>>>>>>>    // The bug being that the focus rectangle doesn't show.
99467>>>>>>>    Procedure Page Integer iPageObject
99469>>>>>>>        Handle hWnd
99469>>>>>>>        Integer iRet iState iMajorVersion
99469>>>>>>>
99469>>>>>>>        Forward Send Page iPageObject
99471>>>>>>>
99471>>>>>>>        If (iPageObject) Begin
99473>>>>>>>            Get Window_Handle to hWnd
99474>>>>>>>            If (hWnd) Begin
99476>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
99477>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
99479>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
99480>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
99481>>>>>>>                End
99481>>>>>>>>
99481>>>>>>>            End
99481>>>>>>>>
99481>>>>>>>        End
99481>>>>>>>>
99481>>>>>>>    End_Procedure
99482>>>>>>>
99482>>>>>>>End_Class
99483>>>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
99483>>>>>>>Use Windows.pkg
99483>>>>>>>
99483>>>>>>>// Used by the "Page" message below to show
99483>>>>>>>// a rectangle around ComboForm and Checkbox objects.
99483>>>>>>>
99483>>>>>>>Class cSQLComboForm is a ComboForm
99484>>>>>>>    Procedure Construct_Object
99486>>>>>>>        Forward Send Construct_Object
99488>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
99488>>>>>>>        Property Integer piItem
99489>>>>>>>    End_Procedure
99490>>>>>>>
99490>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
99492>>>>>>>    End_Procedure
99493>>>>>>>
99493>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
99495>>>>>>>        Integer iItem
99495>>>>>>>        Get piItem to iItem
99496>>>>>>>        Set Value to sConnectionData[iItem]
99497>>>>>>>    End_Procedure
99498>>>>>>>
99498>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
99500>>>>>>>        String sValue
99500>>>>>>>        Integer iItem
99500>>>>>>>        Get piItem to iItem
99501>>>>>>>        Get Value to sValue
99502>>>>>>>        Move sValue to sConnectionData[iItem]
99503>>>>>>>    End_Procedure
99504>>>>>>>
99504>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
99504>>>>>>>    // The bug being that the focus rectangle doesn't show.
99504>>>>>>>    Procedure Page Integer iPageObject
99506>>>>>>>        Handle hWnd
99506>>>>>>>        Integer iRet iState iMajorVersion
99506>>>>>>>
99506>>>>>>>        Forward Send Page iPageObject
99508>>>>>>>
99508>>>>>>>        If (iPageObject) Begin
99510>>>>>>>            Get Window_Handle to hWnd
99511>>>>>>>            If (hWnd) Begin
99513>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
99514>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
99516>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
99517>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
99518>>>>>>>                End
99518>>>>>>>>
99518>>>>>>>            End
99518>>>>>>>>
99518>>>>>>>        End
99518>>>>>>>>
99518>>>>>>>    End_Procedure
99519>>>>>>>
99519>>>>>>>End_Class
99520>>>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLForm.pkg)
99520>>>>>>>Use Windows.pkg
99520>>>>>>>
99520>>>>>>>Class cSQLForm is a Form
99521>>>>>>>    Procedure Construct_Object
99523>>>>>>>        Forward Send Construct_Object
99525>>>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
99525>>>>>>>        Property Integer piItem
99526>>>>>>>    End_Procedure
99527>>>>>>>
99527>>>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
99529>>>>>>>    End_Procedure
99530>>>>>>>
99530>>>>>>>    Procedure ReadConnectionData String[] sConnectionData
99532>>>>>>>        Integer iItem
99532>>>>>>>        Get piItem to iItem
99533>>>>>>>        Set Value to sConnectionData[iItem]
99534>>>>>>>    End_Procedure
99535>>>>>>>
99535>>>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
99537>>>>>>>        String sValue
99537>>>>>>>        Integer iItem
99537>>>>>>>        Get piItem to iItem
99538>>>>>>>        Get Value to sValue
99539>>>>>>>        Move sValue to sConnectionData[iItem]
99540>>>>>>>    End_Procedure
99541>>>>>>>
99541>>>>>>>End_Class
99542>>>>>Use cSQLConnectionHandler.pkg
99542>>>>>Use cDbUpdateFunctionLibrary.pkg
99542>>>>>Use cDbUpdateDatabaseDriver.pkg
99542>>>>>Use DatabaseSelection.dg
99542>>>>>Use ServerSelection.dg
99542>>>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
99542>>>>>>>Use Windows.pkg
99542>>>>>>>Use cCJGridPromptList.pkg
99542>>>>>>>Use cDbUpdateFunctionLibrary.pkg
99542>>>>>>>
99542>>>>>>>Object oTableSpaceSelection_sl is a ModalPanel
99544>>>>>>>    Set Size to 118 177
99545>>>>>>>    Set Label to "SQL Tablespace Selection"
99546>>>>>>>    Set piMinSize to 89 177
99547>>>>>>>    Set Location to 2 2
99548>>>>>>>    Set Border_Style to Border_Thick
99549>>>>>>>
99549>>>>>>>    Property String[] psTheData
99551>>>>>>>
99551>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
99553>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
99555>>>>>>>        End_Object
99556>>>>>>>    End
99556>>>>>>>>
99556>>>>>>>
99556>>>>>>>    Object oSelList is a cCJGridPromptList
99558>>>>>>>        Set Size to 89 167
99559>>>>>>>        Set Location to 6 6
99560>>>>>>>        Set peAnchors to anAll
99561>>>>>>>        Set pbAllowColumnRemove to False
99562>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
99563>>>>>>>        Set pbGrayIfDisable to False
99564>>>>>>>        Set pbHeaderReorders to False
99565>>>>>>>        Set pbHeaderSelectsColumn to False
99566>>>>>>>        Set pbHeaderTogglesDirection to False
99567>>>>>>>        Set pbShadeSortColumn to False
99568>>>>>>>        Set piFocusCellBackColor to clDkGray
99569>>>>>>>
99569>>>>>>>        Object oName is a cCJGridColumn
99571>>>>>>>            Set piWidth to 334
99572>>>>>>>            Set psCaption to "Table Space Name"
99573>>>>>>>        End_Object
99574>>>>>>>
99574>>>>>>>        Procedure Activating
99577>>>>>>>            tDataSourceRow[] MyData
99577>>>>>>>            tDataSourceRow[] MyData
99578>>>>>>>            Handle hoDataSource
99578>>>>>>>            String[] sTheData
99579>>>>>>>            Integer iCount iSize
99579>>>>>>>
99579>>>>>>>            Send Cursor_Wait of Cursor_Control
99580>>>>>>>            Forward Send Activating
99582>>>>>>>
99582>>>>>>>            Get psTheData to sTheData
99583>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
99584>>>>>>>            Decrement iSize
99585>>>>>>>            For iCount from 0 to iSize
99591>>>>>>>>
99591>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
99592>>>>>>>            Loop
99593>>>>>>>>
99593>>>>>>>
99593>>>>>>>            Get phoDataSource to hoDataSource
99594>>>>>>>            Send InitializeData of hoDataSource MyData
99595>>>>>>>            Send Cursor_Ready of Cursor_Control
99596>>>>>>>        End_Procedure
99597>>>>>>>
99597>>>>>>>    End_Object
99598>>>>>>>
99598>>>>>>>    Object oOK_Btn is a Button
99600>>>>>>>        Set Label    to "&OK"
99601>>>>>>>        Set Location to 100 68
99602>>>>>>>        Set peAnchors To anBottomRight
99603>>>>>>>
99603>>>>>>>        Procedure OnClick
99606>>>>>>>            Send Ok of oSelList
99607>>>>>>>        End_Procedure
99608>>>>>>>
99608>>>>>>>    End_Object
99609>>>>>>>
99609>>>>>>>    Object oCancel_Btn is a Button
99611>>>>>>>        Set Label    to "&Cancel"
99612>>>>>>>        Set Location to 100 123
99613>>>>>>>        Set peAnchors to anBottomRight
99614>>>>>>>
99614>>>>>>>        Procedure OnClick
99617>>>>>>>            Send Close_Panel
99618>>>>>>>        End_Procedure
99619>>>>>>>
99619>>>>>>>    End_Object
99620>>>>>>>
99620>>>>>>>    Procedure Page Integer iPageObject
99623>>>>>>>        Set Icon to "DatabaseLookup.ico"
99624>>>>>>>        Forward Send Page iPageObject
99626>>>>>>>    End_Procedure
99627>>>>>>>
99627>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99628>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99629>>>>>>>End_Object
99630>>>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SchemasSelection.dg)
99630>>>>>>>Use Windows.pkg
99630>>>>>>>Use cCJGridPromptList.pkg
99630>>>>>>>Use cDbUpdateFunctionLibrary.pkg
99630>>>>>>>
99630>>>>>>>Object oSchemasSelection_sl is a ModalPanel
99632>>>>>>>    Set Size to 118 177
99633>>>>>>>    Set Label to "SQL Schemas Selection"
99634>>>>>>>    Set piMinSize to 89 177
99635>>>>>>>    Set Location to 2 2
99636>>>>>>>    Set Border_Style to Border_Thick
99637>>>>>>>
99637>>>>>>>    Property String[] psTheData
99639>>>>>>>
99639>>>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
99641>>>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
99643>>>>>>>        End_Object
99644>>>>>>>    End
99644>>>>>>>>
99644>>>>>>>
99644>>>>>>>    Object oSelList is a cCJGridPromptList
99646>>>>>>>        Set Size to 89 167
99647>>>>>>>        Set Location to 6 6
99648>>>>>>>        Set peAnchors to anAll
99649>>>>>>>        Set pbAllowColumnRemove to False
99650>>>>>>>        Set pbUseAlternateRowBackgroundColor to True
99651>>>>>>>        Set pbGrayIfDisable to False
99652>>>>>>>        Set pbHeaderReorders to False
99653>>>>>>>        Set pbHeaderSelectsColumn to False
99654>>>>>>>        Set pbHeaderTogglesDirection to False
99655>>>>>>>        Set pbShadeSortColumn to False
99656>>>>>>>        Set piFocusCellBackColor to clDkGray
99657>>>>>>>
99657>>>>>>>        Object oName is a cCJGridColumn
99659>>>>>>>            Set piWidth to 334
99660>>>>>>>            Set psCaption to "Schema Name"
99661>>>>>>>        End_Object
99662>>>>>>>
99662>>>>>>>        Procedure Activating
99665>>>>>>>            tDataSourceRow[] MyData
99665>>>>>>>            tDataSourceRow[] MyData
99666>>>>>>>            Handle hoDataSource
99666>>>>>>>            String[] sTheData
99667>>>>>>>//            String sDriverID sConnectionString
99667>>>>>>>            Integer iCount iSize iDbType
99667>>>>>>>
99667>>>>>>>            Send Cursor_Wait of Cursor_Control
99668>>>>>>>            Forward Send Activating
99670>>>>>>>
99670>>>>>>>//            Get psDriverID to sDriverID
99670>>>>>>>//            Get psConnectionString to sConnectionString
99670>>>>>>>//            Get piDbType to iDbType
99670>>>>>>>            Get psTheData to sTheData
99671>>>>>>>
99671>>>>>>>            Move (SizeOfArray(sTheData)) to iSize
99672>>>>>>>            Decrement iSize
99673>>>>>>>            For iCount from 0 to iSize
99679>>>>>>>>
99679>>>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
99680>>>>>>>            Loop
99681>>>>>>>>
99681>>>>>>>
99681>>>>>>>            Get phoDataSource to hoDataSource
99682>>>>>>>            Send InitializeData of hoDataSource MyData
99683>>>>>>>            Send Cursor_Ready of Cursor_Control
99684>>>>>>>        End_Procedure
99685>>>>>>>
99685>>>>>>>    End_Object
99686>>>>>>>
99686>>>>>>>    Object oOK_Btn is a Button
99688>>>>>>>        Set Label    to "&OK"
99689>>>>>>>        Set Location to 100 68
99690>>>>>>>        Set peAnchors To anBottomRight
99691>>>>>>>
99691>>>>>>>        Procedure OnClick
99694>>>>>>>            Send Ok of oSelList
99695>>>>>>>        End_Procedure
99696>>>>>>>
99696>>>>>>>    End_Object
99697>>>>>>>
99697>>>>>>>    Object oCancel_Btn is a Button
99699>>>>>>>        Set Label    to "&Cancel"
99700>>>>>>>        Set Location to 100 123
99701>>>>>>>        Set peAnchors to anBottomRight
99702>>>>>>>
99702>>>>>>>        Procedure OnClick
99705>>>>>>>            Send Close_Panel
99706>>>>>>>        End_Procedure
99707>>>>>>>
99707>>>>>>>    End_Object
99708>>>>>>>
99708>>>>>>>    Procedure Page Integer iPageObject
99711>>>>>>>        Set Icon to "DatabaseLookup.ico"
99712>>>>>>>        Forward Send Page iPageObject
99714>>>>>>>    End_Procedure
99715>>>>>>>
99715>>>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
99716>>>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
99717>>>>>>>End_Object
99718>>>>>
99718>>>>>Define CS_LoadingServers        for "Enumerating servers..."
99718>>>>>Define CS_LoadingDatabases      for "Enumerating databases..."
99718>>>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
99718>>>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
99718>>>>>Define CS_LoginAttempt          for "Connecting..."
99718>>>>>Define CS_LoginSuccessful       for "Login successful!"
99718>>>>>Define CS_LoginFailed           for "Login failed!"
99718>>>>>Define CS_DF_File_Schema        for "Schema"
99718>>>>>Define CS_DF_File_Owner         for "Owner"
99718>>>>>
99718>>>>>Object oSQLMaintainConnections_dg is a ModalPanel
99720>>>>>    Set Label to "Edit SQL Connection"
99721>>>>>    Set Size to 261 410
99722>>>>>    Set Location to 4 6
99723>>>>>    Set Locate_Mode to Center_On_Parent
99724>>>>>    Set Border_Style to Border_Thick
99725>>>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
99726>>>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
99727>>>>>
99727>>>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
99729>>>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
99731>>>>>    Property Boolean pbChanged   False // If any change was made to the data.
99733>>>>>    Property Handle phoDialogCommandbar
99735>>>>>    Property tSQLConnection pSQLConnectionData
99737>>>>>    Property tDataSourceRow[] pTheData
99739>>>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
99741>>>>>    Property String psUncryptedPw     // Used if  pbDFConnId = True to temporary save the un-encrypted password.
99743>>>>>
99743>>>>>    Object oDbType_cf is a cSQLComboForm
99745>>>>>        Set Size to 11 120
99746>>>>>        Set Location to 11 86
99747>>>>>        Set Label_Col_Offset to 2
99748>>>>>        Set Label_Justification_Mode to JMode_Right
99749>>>>>        Set Label to "Database Type"
99750>>>>>        Set Entry_State to False
99751>>>>>        Set Combo_Sort_State to False
99752>>>>>        Set piItem to 3
99753>>>>>
99753>>>>>        Procedure Combo_Fill_List
99756>>>>>            Send Combo_Add_Item CS_dbTypeMSSQL
99757>>>>>            Send Combo_Add_Item CS_dbTypeMySQL
99758>>>>>            Send Combo_Add_Item CS_dbTypeOracle
99759>>>>>            Send Combo_Add_Item CS_dbTypeDB2
99760>>>>>            Send Combo_Add_Item CS_dbTypePostgre
99761>>>>>        End_Procedure
99762>>>>>
99762>>>>>        Procedure OnChange
99765>>>>>            Integer iDbType
99765>>>>>            String sDriverID
99765>>>>>
99765>>>>>            Get SelectedDbType to iDbType
99766>>>>>            Send Refill_Comboform of oDriverID_cf iDbType
99767>>>>>            Get Value of oDriverID_cf to sDriverID
99768>>>>>            If (sDriverID = "") Begin
99770>>>>>                Move MSSQLDRV_ID to sDriverID
99771>>>>>            End
99771>>>>>>
99771>>>>>            Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99772>>>>>        End_Procedure
99773>>>>>
99773>>>>>        Function SelectedDbType Returns Integer
99776>>>>>            Integer iRetval
99776>>>>>            String sDbType
99776>>>>>
99776>>>>>            Get Value to sDbType
99777>>>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
99778>>>>>
99778>>>>>            Function_Return iRetval
99779>>>>>        End_Function
99780>>>>>
99780>>>>>    End_Object
99781>>>>>
99781>>>>>    Object oDriverID_cf is a cSQLComboForm
99783>>>>>        Set Size to 11 120
99784>>>>>        Set Location to 24 86
99785>>>>>        Set Label_Col_Offset to 2
99786>>>>>        Set Label_Justification_Mode to JMode_Right
99787>>>>>        Set Label to "Driver ID"
99788>>>>>        Set psToolTip to "Depending on the database type selected and if Mertech drivers have been installed, the comboform list will vary."
99789>>>>>        Set Entry_State to False
99790>>>>>        Set Combo_Sort_State to False
99791>>>>>        Set piItem to 4
99792>>>>>
99792>>>>>        Procedure Refill_Comboform Integer iDbType
99795>>>>>            String sValue
99795>>>>>            Send Combo_Delete_Data
99796>>>>>            Case Begin
99796>>>>>                Case (iDbType = EN_dbTypeMSSQL)
99798>>>>>                    Send Combo_Add_Item MSSQLDRV_ID
99799>>>>>                    Send Combo_Add_Item SQLFLEX
99800>>>>>                    Move MSSQLDRV_ID to sValue
99801>>>>>                    Case Break
99802>>>>>                Case (iDbType = EN_dbTypeMySQL)
99805>>>>>                    Send Combo_Add_Item ODBC_DRV_ID
99806>>>>>                    Send Combo_Add_Item MDSMySQL
99807>>>>>                    Move MDSMySQL to sValue
99808>>>>>                    Case Break
99809>>>>>                Case (iDbType = EN_dbTypeOracle)
99812>>>>>                    Send Combo_Add_Item ODBC_DRV_ID
99813>>>>>                    Send Combo_Add_Item ORAFLEX
99814>>>>>                    Move ORAFLEX to sValue
99815>>>>>                    Case Break
99816>>>>>                Case (iDbType = EN_dbTypeDB2)
99819>>>>>                    Send Combo_Add_Item DB2_DRV_ID
99820>>>>>                    Move DB2_DRV_ID to sValue
99821>>>>>                    Case Break
99822>>>>>                Case (iDbType = EN_dbTypePostgre)
99825>>>>>                    Send Combo_Add_Item ODBC_DRV_ID
99826>>>>>                    Send Combo_Add_Item MDSPgSQL
99827>>>>>                    Move MDSPgSQL to sValue
99828>>>>>                    Case Break
99829>>>>>                Case Else
99829>>>>>                    Send Combo_Add_Item DATAFLEX_ID
99830>>>>>                    Move DATAFLEX_ID to sValue
99831>>>>>//                Case (iDbType = EN_dbTypeMSSQL)
99831>>>>>//                    Send Combo_Add_Item (MSSQLDRV_ID * "- (DAW)")
99831>>>>>//                    Send Combo_Add_Item (SQLFLEX * "- (Mertech)")
99831>>>>>//                    Move (MSSQLDRV_ID * "- (DAW)") to sValue
99831>>>>>//                    Case Break
99831>>>>>//                Case (iDbType = EN_dbTypeMySQL)
99831>>>>>//                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
99831>>>>>//                    Send Combo_Add_Item (MDSMySQL * "- (Mertech)")
99831>>>>>//                    Move (MDSMySQL * "- (Mertech)") to sValue
99831>>>>>//                    Case Break
99831>>>>>//                Case (iDbType = EN_dbTypeOracle)
99831>>>>>//                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
99831>>>>>//                    Send Combo_Add_Item (ORAFLEX * "- (Mertech)")
99831>>>>>//                    Move (ORAFLEX * "- (Mertech)") to sValue
99831>>>>>//                    Case Break
99831>>>>>//                Case (iDbType = EN_dbTypeDB2)
99831>>>>>//                    Send Combo_Add_Item (DB2_DRV_ID * "- (DAW)")
99831>>>>>//                    Move (DB2_DRV_ID * "- (DAW)") to sValue
99831>>>>>//                    Case Break
99831>>>>>//                Case (iDbType = EN_dbTypePostgre)
99831>>>>>//                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
99831>>>>>//                    Send Combo_Add_Item (MDSPgSQL * "- (Mertech)")
99831>>>>>//                    Move (MDSPgSQL * "- (Mertech)") to sValue
99831>>>>>//                    Case Break
99831>>>>>//                Case Else
99831>>>>>//                    Send Combo_Add_Item (DATAFLEX_ID * "- (DAW)")
99831>>>>>//                    Move (DATAFLEX_ID * "- (DAW)") to sValue
99831>>>>>            Case End
99831>>>>>            Set Value to sValue
99832>>>>>        End_Procedure
99833>>>>>
99833>>>>>        Procedure OnChange
99836>>>>>            String sDriverID
99836>>>>>            Integer iDbType iPos
99836>>>>>
99836>>>>>            Get Value to sDriverID
99837>>>>>            Move (Pos("-", sDriverID)) to iPos
99838>>>>>            Move (Left(sDriverID, (iPos - 2))) to sDriverID
99839>>>>>            If (sDriverID = "") Begin
99841>>>>>                Move MSSQLDRV_ID to sDriverID
99842>>>>>            End
99842>>>>>>
99842>>>>>            Get SelectedDbType of oDbType_cf to iDbType
99843>>>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99845>>>>>        End_Procedure
99846>>>>>
99846>>>>>    End_Object
99847>>>>>
99847>>>>>    Object oConnectionID_fm is a cSQLForm
99849>>>>>        Set Size to 13 120
99850>>>>>        Set Location to 37 86
99851>>>>>        Set Label to "Connection ID"
99852>>>>>        Set Label_Col_Offset to 2
99853>>>>>        Set Label_Justification_Mode to JMode_Right
99854>>>>>        Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
99855>>>>>        Set piItem to 2
99856>>>>>    End_Object
99857>>>>>
99857>>>>>    Object oEnabled_cb is a cSQLCheckBox
99859>>>>>        Set Auto_Size_State to False
99860>>>>>        Set Size to 9 38
99861>>>>>        Set Location to 39 216
99862>>>>>        Set Label to "Enabled"
99863>>>>>        Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
99864>>>>>        Set piItem to 1
99865>>>>>
99865>>>>>        Procedure OnChange
99868>>>>>            Boolean bChecked bNew
99868>>>>>            tSQLConnection SQLConnection
99868>>>>>            tSQLConnection SQLConnection
99868>>>>>
99868>>>>>            Get pbNew to bNew
99869>>>>>            Get Checked_State to bChecked
99870>>>>>            If (bNew = False and bChecked = True) Begin
99872>>>>>                Get pSQLConnectionData to SQLConnection
99873>>>>>                Move True to SQLConnection.bEnabled
99874>>>>>// ToDo: Should we really do this?
99874>>>>>//                Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
99874>>>>>            End
99874>>>>>>
99874>>>>>
99874>>>>>        End_Procedure
99875>>>>>    End_Object
99876>>>>>
99876>>>>>    Object oSettings_grp is a Group
99878>>>>>        Set Size to 166 389
99879>>>>>        Set Location to 59 11
99880>>>>>        Set Label to "Connection String Details"
99881>>>>>        Set peAnchors to anTopLeftRight
99882>>>>>
99882>>>>>        Object oServer_fm is a cSQLForm
99884>>>>>            Set Size to 13 120
99885>>>>>            Set Location to 14 74
99886>>>>>            Set Label to "Server"
99887>>>>>            Set Label_Col_Offset to 2
99888>>>>>            Set Label_Justification_Mode to JMode_Right
99889>>>>>            Set Prompt_Button_Mode to PB_PromptOn
99890>>>>>            Set Prompt_Object to (oServerSelection_sl(Self))
99891>>>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
99892>>>>>            Set peAnchors to anTopLeftRight
99893>>>>>            Set piItem to 5
99894>>>>>
99894>>>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
99896>>>>>
99896>>>>>            Procedure Prompt
99899>>>>>                String sDriverID sValue
99899>>>>>                String[] sTheData
99900>>>>>                Integer iDbType iODBCType iRadio iPos
99900>>>>>                Handle ho
99900>>>>>
99900>>>>>                Get Prompt_Object to ho
99901>>>>>                If (ho = 0) Begin
99903>>>>>                    Procedure_Return
99904>>>>>                End
99904>>>>>>
99904>>>>>
99904>>>>>                Set Label of oServersInfo_tb to CS_LoadingServers
99905>>>>>                Send Cursor_Wait of Cursor_Control
99906>>>>>                Get SelectedDbType of oDbType_cf to iDbType
99907>>>>>                Get Value of oDriverID_cf to sDriverID
99908>>>>>                Get Current_Radio of oODBC_rgp to iRadio
99909>>>>>                If (iRadio = 0) Move SQL_FETCH_USER     to iODBCType
99912>>>>>                If (iRadio = 1) Move SQL_FETCH_SYSTEM   to iODBCType
99915>>>>>                If (iRadio = 2) Move SQL_FETCH_ALL      to iODBCType
99918>>>>>
99918>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
99919>>>>>                Load_Driver sDriverID
99920>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
99921>>>>>                If (LastErr = 4255) Begin
99923>>>>>                    Send Cursor_Ready of Cursor_Control
99924>>>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
99925>>>>>                    Procedure_Return
99926>>>>>                End
99926>>>>>>
99926>>>>>
99926>>>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
99927>>>>>                Set psTheData  of ho to sTheData
99928>>>>>                Set Label of oServersInfo_tb to ""
99929>>>>>
99929>>>>>                Forward Send Prompt
99931>>>>>
99931>>>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
99931>>>>>                // We need to remove those parts from the comma and to the end of string.
99931>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
99933>>>>>                    Get Value to sValue
99934>>>>>                    Move (Pos(",", sValue)) to iPos
99935>>>>>                    Move (Left(sValue, (iPos - 1))) to sValue
99936>>>>>                    Set Value to sValue
99937>>>>>                End
99937>>>>>>
99937>>>>>            End_Procedure
99938>>>>>
99938>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99941>>>>>                String sLabel
99941>>>>>                Handle ho
99941>>>>>
99941>>>>>                Get phoPromptObject to ho
99942>>>>>                Set Prompt_Button_Mode to PB_PromptOn
99943>>>>>                Case Begin
99943>>>>>                    Case (iDbType = EN_dbTypeDB2)
99945>>>>>                        Move "DSN" to sLabel
99946>>>>>                        Case Break
99947>>>>>                    Case (iDbType = EN_dbTypeMSSQL)
99950>>>>>                        Move "Server" to sLabel
99951>>>>>                        Case Break
99952>>>>>                    Case (iDbType = EN_dbTypeMySQL)
99955>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
99957>>>>>                            Move "ODBC Data Source" to sLabel
99958>>>>>                        End
99958>>>>>>
99958>>>>>                        Else Begin
99959>>>>>                            Move "DSN" to sLabel
99960>>>>>                        End
99960>>>>>>
99960>>>>>                        Case Break
99961>>>>>                    Case (iDbType = EN_dbTypeOracle)
99964>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
99966>>>>>                            Move "ODBC Data Source" to sLabel
99967>>>>>                        End
99967>>>>>>
99967>>>>>                        Else Begin
99968>>>>>                            Move "Server" to sLabel
99969>>>>>                        End
99969>>>>>>
99969>>>>>                        Case Break
99970>>>>>                    Case (iDbType = EN_dbTypePostgre)
99973>>>>>                        If (sDriverID = ODBC_DRV_ID) Begin
99975>>>>>                            Move "ODBC Data Source" to sLabel
99976>>>>>                        End
99976>>>>>>
99976>>>>>                        Else Begin
99977>>>>>                            Move "Server" to sLabel
99978>>>>>                        End
99978>>>>>>
99978>>>>>                        Case Break
99979>>>>>                    Case Else
99979>>>>>                Case End
99979>>>>>
99979>>>>>                Set Prompt_Object to ho
99980>>>>>                Set Label to sLabel
99981>>>>>            End_Procedure
99982>>>>>
99982>>>>>        End_Object
99983>>>>>
99983>>>>>        Object oServersInfo_tb is a TextBox
99985>>>>>            Set Auto_Size_State to False
99986>>>>>            Set Size to 9 100
99987>>>>>            Set Location to 18 262
99988>>>>>            Set TextColor to clGreen
99989>>>>>            Set Justification_Mode to JMode_Right
99990>>>>>            Set peAnchors to anTopRight
99991>>>>>        End_Object
99992>>>>>
99992>>>>>        Object oSilentLogin_fm is a cSQLCheckBox
99994>>>>>            Set Auto_Size_State to False
99995>>>>>            Set Size to 9 51
99996>>>>>            Set Location to 17 205
99997>>>>>            Set Label to "Silent Login"
99998>>>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
99999>>>>>            Set peAnchors to anTopRight
100000>>>>>            Set piItem to 15
100001>>>>>        End_Object
100002>>>>>
100002>>>>>        Object oODBC_rgp is a RadioGroup
100004>>>>>            Set Location to 31 75
100005>>>>>            Set Size to 25 298
100006>>>>>            Set Label to "Show ODBC Data Source"
100007>>>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
100007>>>>>
100007>>>>>            Object oRadio1 is a Radio
100009>>>>>                Set Label to "User data"
100010>>>>>                Set Size to 10 49
100011>>>>>                Set Location to 10 5
100012>>>>>            End_Object
100013>>>>>
100013>>>>>            Object oRadio2 is a Radio
100015>>>>>                Set Label to "System data"
100016>>>>>                Set Size to 10 55
100017>>>>>                Set Location to 10 64
100018>>>>>            End_Object
100019>>>>>
100019>>>>>            Object oRadio3 is a Radio
100021>>>>>                Set Label to "Both"
100022>>>>>                Set Size to 10 28
100023>>>>>                Set Location to 11 130
100024>>>>>            End_Object
100025>>>>>
100025>>>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
100028>>>>>                Forward Send Notify_Select_State iToItem iFromItem
100030>>>>>            End_Procedure
100031>>>>>
100031>>>>>            Object oFileDSN_btn is a cButtonDPI
100033>>>>>                Set Size to 13 62
100034>>>>>                Set Location to 8 168
100035>>>>>                Set Label to "Select File DSN..."
100036>>>>>
100036>>>>>                Procedure OnClick
100039>>>>>                    String sFileName
100039>>>>>                    Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
100040>>>>>                    If (sFileName <> "") Begin
100042>>>>>                        Set Value of oServer_fm to sFileName
100043>>>>>                    End
100043>>>>>>
100043>>>>>                End_Procedure
100044>>>>>
100044>>>>>                Set Current_Radio to 2
100045>>>>>            End_Object
100046>>>>>
100046>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100049>>>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
100050>>>>>            End_Procedure
100051>>>>>
100051>>>>>            Object oODBCAdmin_btn is a cButtonDPI
100053>>>>>                Set Size to 13 55
100054>>>>>                Set Location to 8 234
100055>>>>>                Set Label to "ODBC Admin"
100056>>>>>                Procedure OnClick
100059>>>>>                    Handle hWnd
100059>>>>>                    Get Window_Handle to hWnd
100060>>>>>                    If (hWnd <> 0) Begin
100062>>>>>                        ODBCManager hWnd
100067>>>>>                    End
100067>>>>>>
100067>>>>>                    Else Begin
100068>>>>>                        Send Stop_Box "Could not get a Windows handle.."
100069>>>>>                    End
100069>>>>>>
100069>>>>>                End_Procedure
100070>>>>>            End_Object
100071>>>>>
100071>>>>>        End_Object
100072>>>>>
100072>>>>>        Object oTrusted_cb is a cSQLCheckBox
100074>>>>>            Set Size to 10 50
100075>>>>>            Set Location to 65 74
100076>>>>>            Set Label to "Use Trusted Connection"
100077>>>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
100078>>>>>            Set piItem to 8
100079>>>>>
100079>>>>>            Procedure OnChange
100082>>>>>                Boolean bChecked
100082>>>>>                Get Checked_State to bChecked
100083>>>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
100084>>>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
100085>>>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
100086>>>>>            End_Procedure
100087>>>>>
100087>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100090>>>>>                Boolean bChecked
100090>>>>>
100090>>>>>                Get Checked_State to bChecked
100091>>>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
100093>>>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
100094>>>>>                    If (bChecked = True) Begin
100096>>>>>                        Set Checked_State to False
100097>>>>>                    End
100097>>>>>>
100097>>>>>                End
100097>>>>>>
100097>>>>>                Else Begin
100098>>>>>                    Set Enabled_State to True
100099>>>>>                End
100099>>>>>>
100099>>>>>
100099>>>>>                Send OnChange
100100>>>>>            End_Procedure
100101>>>>>
100101>>>>>        End_Object
100102>>>>>
100102>>>>>        Object oUserID_fm is a cSQLForm
100104>>>>>            Set Size to 13 120
100105>>>>>            Set Location to 76 74
100106>>>>>            Set Label to "User ID"
100107>>>>>            Set Label_Col_Offset to 2
100108>>>>>            Set Label_Justification_Mode to JMode_Right
100109>>>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
100110>>>>>            Set piItem to 9
100111>>>>>        End_Object
100112>>>>>
100112>>>>>        Object oPassword_fm is a cSQLForm
100114>>>>>            Set Size to 13 91
100115>>>>>            Set Location to 76 270
100116>>>>>            Set Label to "Password"
100117>>>>>            Set Label_Col_Offset to 2
100118>>>>>            Set Label_Justification_Mode to JMode_Right
100119>>>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
100120>>>>>            Set piItem to 10
100121>>>>>            Set Password_State to True
100122>>>>>        End_Object
100123>>>>>
100123>>>>>        Object oViewPassword_btn is a cButtonDPI
100125>>>>>            Set Size to 13 19
100126>>>>>            Set Location to 76 365
100127>>>>>            Set psToolTip to "Toggle password"  
100128>>>>>            Set psImage to "PasswordView.ico"
100129>>>>>        
100129>>>>>            Procedure OnClick         
100132>>>>>                Handle ho       
100132>>>>>                Boolean bState   
100132>>>>>                Integer iRetval  
100132>>>>>                
100132>>>>>                Move (oPassword_fm(Self)) to ho
100133>>>>>                Get Password_State of ho item 0 to bState
100134>>>>>                Send Page_Object   of ho False
100135>>>>>                Set Password_State of ho item 0 to (not(bState)) 
100136>>>>>                Send Page_Object   of ho True  
100137>>>>>                // Finally we need to add the object to the focus tree again or else it will get invisible.
100137>>>>>                Get msg_Add_Focus  of ho (Parent(ho)) to iRetVal
100138>>>>>            End_Procedure
100139>>>>>        
100139>>>>>        End_Object
100140>>>>>
100140>>>>>        Object oLoginInfo_tb is a TextBox
100142>>>>>            Set Auto_Size_State to False
100143>>>>>            Set Size to 9 64
100144>>>>>            Set Location to 95 203
100145>>>>>            Set TextColor to clGreen
100146>>>>>            Set Justification_Mode to JMode_Right
100147>>>>>        End_Object
100148>>>>>
100148>>>>>        Object oCheckLogin_btn is a cButtonDPI
100150>>>>>            Set Size to 13 91
100151>>>>>            Set Location to 92 270
100152>>>>>            Set Label to "Check &Login"
100153>>>>>            Set psImage to "ActionLogin.ico"
100154>>>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
100155>>>>>
100155>>>>>            Procedure OnClick
100158>>>>>                String sConnectionString sServer sDatabase sUserId sPassword sDriverID sCheck
100158>>>>>                Boolean bTrusted bLoginSuccessful bMertechDriver
100158>>>>>                Integer iStart iDriverID
100158>>>>>                Handle hoErrorObj hoDriver
100158>>>>>
100158>>>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
100159>>>>>                Move Error_Object_Id to hoErrorObj
100160>>>>>                Move Self to Error_Object_Id
100161>>>>>                Move False to Err
100162>>>>>
100162>>>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
100163>>>>>                Send PumpMsgQueue
100164>>>>>
100164>>>>>                Get Checked_State of oTrusted_cb to bTrusted
100165>>>>>                Get Value of oDriverID_cf to sDriverID
100166>>>>>                Get Value of oServer_fm   to sServer
100167>>>>>                Get Value of oDatabase_fm to sDatabase
100168>>>>>                Get Value of oUserID_fm   to sUserId
100169>>>>>                Get Value of oPassword_fm to sPassword
100170>>>>>
100170>>>>>                If (sServer = "") Begin
100172>>>>>                    Send Info_Box "Please enter a server first, then try again."
100173>>>>>                    Procedure_Return
100174>>>>>                End
100174>>>>>>
100174>>>>>
100174>>>>>                Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID sServer sDatabase bTrusted sUserId sPassword to sConnectionString
100175>>>>>
100175>>>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
100176>>>>>                If (iDriverID = 0) Begin
100178>>>>>                    Set TextColor of oLoginInfo_tb to clRed
100179>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
100180>>>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
100181>>>>>                    Procedure_Return
100182>>>>>                End
100182>>>>>>
100182>>>>>
100182>>>>>                Get IsMertechDriver of ghoSQLConnectionHandler sDriverID to bMertechDriver
100183>>>>>                If (bMertechDriver = False) Begin
100185>>>>>                    Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
100188>>>>>                End
100188>>>>>>
100188>>>>>
100188>>>>>                Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
100189>>>>>                Set psDriverID of hoDriver to sDriverID
100190>>>>>                Get DbLogin    of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
100191>>>>>                Send Destroy   of hoDriver
100192>>>>>
100192>>>>>                If bLoginSuccessful Begin
100194>>>>>                    Set TextColor of oLoginInfo_tb to clGreen
100195>>>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful
100196>>>>>                End
100196>>>>>>
100196>>>>>                Else Begin
100197>>>>>                    Set TextColor of oLoginInfo_tb to clRed
100198>>>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
100199>>>>>                End
100199>>>>>>
100199>>>>>
100199>>>>>                Move hoErrorObj to Error_Object_Id
100200>>>>>                Send Cursor_Ready of Cursor_Control
100201>>>>>            End_Procedure
100202>>>>>
100202>>>>>            // This method is here simply to intercept any error that may occur while logging in
100202>>>>>            // it does not have to do anything with the error, but it suppresses the normal error display
100202>>>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
100205>>>>>                    If (LastErr = 25000) Begin
100207>>>>>                        If (Trim(sErrMsg) <> "") Begin
100209>>>>>                            Send Info_Box sErrMsg
100210>>>>>                        End
100210>>>>>>
100210>>>>>                    End
100210>>>>>>
100210>>>>>            End_Procedure
100211>>>>>
100211>>>>>        End_Object
100212>>>>>
100212>>>>>        Object oTableSpaceInfo_tb is a TextBox
100214>>>>>            Set Auto_Size_State to False
100215>>>>>            Set Size to 9 118
100216>>>>>            Set Location to 102 75
100217>>>>>            Set TextColor to clGreen
100218>>>>>            Set Justification_Mode to JMode_Right
100219>>>>>            Set peAnchors to anNone
100220>>>>>        End_Object
100221>>>>>
100221>>>>>        Object oBaseTableSpace_fm is a cSQLForm
100223>>>>>            Set Size to 13 120
100224>>>>>            Set Location to 115 74
100225>>>>>            Set Label to "Table Space"
100226>>>>>            Set Label_Col_Offset to 2
100227>>>>>            Set Label_Justification_Mode to JMode_Right
100228>>>>>            Set piItem to 12
100229>>>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
100230>>>>>            Set Prompt_Button_Mode to PB_PromptOn
100231>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
100232>>>>>
100232>>>>>            Procedure Prompt
100235>>>>>                String[] sTheData
100236>>>>>                Handle ho
100236>>>>>                tSQLConnection SQLConnection
100236>>>>>                tSQLConnection SQLConnection
100236>>>>>
100236>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
100237>>>>>                Get ReadCurrentSQLSettings to SQLConnection
100238>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
100239>>>>>
100239>>>>>                Get Prompt_Object to ho
100240>>>>>                Set psTheData  of ho to sTheData
100241>>>>>                Set Label of oTableSpaceInfo_tb to ""
100242>>>>>
100242>>>>>                Forward Send Prompt
100244>>>>>            End_Procedure
100245>>>>>
100245>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100248>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
100249>>>>>            End_Procedure
100250>>>>>        End_Object
100251>>>>>
100251>>>>>        Object oIndexTableSpace_fm is a cSQLForm
100253>>>>>            Set Size to 13 93
100254>>>>>            Set Location to 115 270
100255>>>>>            Set Label to "Index Table Space"
100256>>>>>            Set Label_Col_Offset to 2
100257>>>>>            Set Label_Justification_Mode to JMode_Right
100258>>>>>            Set piItem to 14
100259>>>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
100260>>>>>            Set Prompt_Button_Mode to PB_PromptOn
100261>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
100262>>>>>
100262>>>>>            Procedure Prompt
100265>>>>>                String[] sTheData
100266>>>>>                Handle ho
100266>>>>>                Integer iDbType
100266>>>>>                tSQLConnection SQLConnection
100266>>>>>                tSQLConnection SQLConnection
100266>>>>>
100266>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
100267>>>>>                Get ReadCurrentSQLSettings to SQLConnection
100268>>>>>
100268>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
100269>>>>>
100269>>>>>                Get Prompt_Object to ho
100270>>>>>                Set psTheData     of ho to sTheData
100271>>>>>                Set Label of oTableSpaceInfo_tb to ""
100272>>>>>
100272>>>>>                Forward Send Prompt
100274>>>>>            End_Procedure
100275>>>>>
100275>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100278>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
100279>>>>>            End_Procedure
100280>>>>>        End_Object
100281>>>>>
100281>>>>>        Object oLongTableSpace_fm is a cSQLForm
100283>>>>>            Set Size to 13 120
100284>>>>>            Set Location to 130 74
100285>>>>>            Set Label to "Long Table Space"
100286>>>>>            Set Label_Col_Offset to 2
100287>>>>>            Set Label_Justification_Mode to JMode_Right
100288>>>>>            Set piItem to 13
100289>>>>>            Set Prompt_Button_Mode to PB_PromptOn
100290>>>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
100291>>>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
100292>>>>>
100292>>>>>            Procedure Prompt
100295>>>>>                String[] sTheData
100296>>>>>                Handle ho
100296>>>>>                Integer iDbType
100296>>>>>                tSQLConnection SQLConnection
100296>>>>>                tSQLConnection SQLConnection
100296>>>>>
100296>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingTableSpaces
100297>>>>>                Get ReadCurrentSQLSettings to SQLConnection
100298>>>>>
100298>>>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
100299>>>>>
100299>>>>>                Get Prompt_Object to ho
100300>>>>>                Set psTheData     of ho to sTheData
100301>>>>>                Set Label of oTableSpaceInfo_tb to ""
100302>>>>>
100302>>>>>                Forward Send Prompt
100304>>>>>            End_Procedure
100305>>>>>
100305>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100308>>>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
100309>>>>>            End_Procedure
100310>>>>>        End_Object
100311>>>>>
100311>>>>>        Object oSchema_fm is a cSQLForm
100313>>>>>            Set Size to 13 93
100314>>>>>            Set Location to 130 270
100315>>>>>            Set Label to "Schema"
100316>>>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
100317>>>>>            Set Label_Col_Offset to 2
100318>>>>>            Set Label_Justification_Mode to JMode_Right
100319>>>>>            Set piItem to 11
100320>>>>>            Set Prompt_Button_Mode to PB_PromptOn
100321>>>>>            Set Prompt_Object to (oSchemasSelection_sl(Self))
100322>>>>>
100322>>>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
100324>>>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
100326>>>>>
100326>>>>>            Procedure Prompt
100329>>>>>                String[] sTheData
100330>>>>>                Handle ho
100330>>>>>                Integer iDbType
100330>>>>>                tSQLConnection SQLConnection
100330>>>>>                tSQLConnection SQLConnection
100330>>>>>
100330>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingSchemas
100331>>>>>                Get ReadCurrentSQLSettings to SQLConnection
100332>>>>>
100332>>>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
100333>>>>>
100333>>>>>                Get Prompt_Object to ho
100334>>>>>                Set psTheData     of ho to sTheData
100335>>>>>                Set Label of oTableSpaceInfo_tb to ""
100336>>>>>
100336>>>>>                Forward Send Prompt
100338>>>>>            End_Procedure
100339>>>>>
100339>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100342>>>>>                String sValue
100342>>>>>
100342>>>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
100343>>>>>                If (iDbType = EN_dbTypeMSSQL) Begin
100345>>>>>                    Set Label to CS_DF_File_Owner
100346>>>>>                    Set Prompt_Button_Mode to PB_PromptOff
100347>>>>>                    Set Prompt_Object to 0
100348>>>>>                    Set psToolTip to (psOwnerTooltip(Self))
100349>>>>>                    Get Value to sValue
100350>>>>>                    If (Trim(sValue) = "") Begin
100352>>>>>                        Set Value to "dbo"
100353>>>>>                    End
100353>>>>>>
100353>>>>>                End
100353>>>>>>
100353>>>>>                Else Begin
100354>>>>>                    Set Label to CS_DF_File_Schema
100355>>>>>                    Set Prompt_Button_Mode to PB_PromptOn
100356>>>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
100357>>>>>                    Set psToolTip to (psSchemaToolTip(Self))
100358>>>>>                    If (Trim(sValue) = "dbo") Begin
100360>>>>>                        Set Value to ""
100361>>>>>                    End
100361>>>>>>
100361>>>>>                End
100361>>>>>>
100361>>>>>                If (Enabled_State(Self) = False) Begin
100363>>>>>                    Set Value to ""
100364>>>>>                End
100364>>>>>>
100364>>>>>            End_Procedure
100365>>>>>        End_Object
100366>>>>>
100366>>>>>        Object oDatabase_fm is a cSQLForm
100368>>>>>            Set Size to 13 120
100369>>>>>            Set Location to 146 74
100370>>>>>            Set Label to "Database"
100371>>>>>            Set Label_Col_Offset to 2
100372>>>>>            Set Label_Justification_Mode to JMode_Right
100373>>>>>            Set Prompt_Button_Mode to PB_PromptOn
100374>>>>>            Set Prompt_Object to (oDatabaseSelection_sl(Self))
100375>>>>>            Set peAnchors to anTopLeftRight
100376>>>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
100377>>>>>            Set piItem to 6
100378>>>>>
100378>>>>>            Procedure Prompt
100381>>>>>                String[] sTheData
100382>>>>>                Handle ho
100382>>>>>                Integer iDbType
100382>>>>>                tSQLConnection SQLConnection
100382>>>>>                tSQLConnection SQLConnection
100382>>>>>
100382>>>>>                Set Label of oTableSpaceInfo_tb to CS_LoadingDatabases
100383>>>>>                Get ReadCurrentSQLSettings to SQLConnection
100384>>>>>
100384>>>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
100385>>>>>
100385>>>>>                Get Prompt_Object to ho
100386>>>>>                Set psTheData     of ho to sTheData
100387>>>>>                Set Label of oTableSpaceInfo_tb to ""
100388>>>>>
100388>>>>>                Forward Send Prompt
100390>>>>>            End_Procedure
100391>>>>>
100391>>>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
100394>>>>>                Boolean bAdd
100394>>>>>                String sValue
100394>>>>>
100394>>>>>                If (sDriverID <> "") Begin
100396>>>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX or sDriverID = MDSMySQL or sDriverID = MDSPgSQL or sDriverID = ORAFLEX)
100397>>>>>                    If (Enabled_State(Self) = True) Begin
100399>>>>>                        Move (piCurrentRow(Self) = -1) to bAdd
100400>>>>>                        Get Value to sValue
100401>>>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
100403>>>>>                            Set Value to "master"
100404>>>>>                        End
100404>>>>>>
100404>>>>>                        Else Begin
100405>>>>>                            Set Prompt_Button_Mode to PB_PromptOn
100406>>>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
100407>>>>>                            If (Value(Self) = "master") Begin
100409>>>>>                                Set Value to ""
100410>>>>>                            End
100410>>>>>>
100410>>>>>                        End
100410>>>>>>
100410>>>>>                    End
100410>>>>>>
100410>>>>>                    If (Enabled_State(Self) = False) Begin
100412>>>>>                        Set Value to ""
100413>>>>>                    End
100413>>>>>>
100413>>>>>                End
100413>>>>>>
100413>>>>>            End_Procedure
100414>>>>>
100414>>>>>        End_Object
100415>>>>>
100415>>>>>        Function ReadCurrentSQLSettings Returns tSQLConnection
100418>>>>>            tSQLConnection SQLConnection
100418>>>>>            tSQLConnection SQLConnection
100418>>>>>
100418>>>>>            Get Value of oDriverID_cf to SQLConnection.sDriverID
100419>>>>>            Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
100420>>>>>
100420>>>>>            Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
100421>>>>>            Get Value of oDriverID_cf        to SQLConnection.sDriverID
100422>>>>>            Get Value of oServer_fm          to SQLConnection.sServer
100423>>>>>            Get Value of oUserID_fm          to SQLConnection.sUserID
100424>>>>>            Get Value of oPassword_fm        to SQLConnection.sPassword
100425>>>>>            Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;                SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
100426>>>>>            Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
100427>>>>>
100427>>>>>            Function_Return SQLConnection
100428>>>>>        End_Function
100429>>>>>
100429>>>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
100432>>>>>            String sDbType
100432>>>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
100433>>>>>            Set Label to (sDbType * "Connection Details")
100434>>>>>        End_Procedure
100435>>>>>
100435>>>>>    End_Object
100436>>>>>
100436>>>>>    Object oOK_Btn is a cButtonDPI
100438>>>>>        Set Label    to "OK"
100439>>>>>        Set Location to 232 281
100440>>>>>        Set peAnchors to anBottomRight
100441>>>>>
100441>>>>>        Procedure OnClick
100444>>>>>            String sConnectionID sLoginText
100444>>>>>            String[] sConnectionData
100445>>>>>            tSQLConnection SQLIniFileConnection
100445>>>>>            tSQLConnection SQLIniFileConnection
100445>>>>>            Boolean bEnabled bTrusted bNew bOK bShouldSave
100445>>>>>            Handle ho
100445>>>>>            Integer iRetval iSize
100445>>>>>
100445>>>>>            Delegate Get Should_Save to bShouldSave
100447>>>>>            If (bShouldSave = False) Begin
100449>>>>>                Set pbChanged to False
100450>>>>>                Send Close_Panel
100451>>>>>                Procedure_Return
100452>>>>>            End
100452>>>>>>
100452>>>>>
100452>>>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
100454>>>>>
100454>>>>>            Get pbNew to bNew
100455>>>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
100456>>>>>            Case Begin
100456>>>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
100458>>>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
100460>>>>>                        Move "" to SQLIniFileConnection.sDatabase
100461>>>>>                    End
100461>>>>>>
100461>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
100463>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
100464>>>>>                    End
100464>>>>>>
100464>>>>>                    Else Begin
100465>>>>>                        // It should probably be allowed to use an UID but no password...
100465>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100466>>>>>                    End
100466>>>>>>
100466>>>>>                    Case Break
100467>>>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID or SQLIniFileConnection.sDriverID = SQLFLEX)
100470>>>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
100472>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
100473>>>>>                    End
100473>>>>>>
100473>>>>>                    Else Begin
100474>>>>>                        // It should probably be allowed to use an UID but no password...
100474>>>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100475>>>>>                    End
100475>>>>>>
100475>>>>>                    Case Break
100476>>>>>                Case (SQLIniFileConnection.sDriverID = ORAFLEX or SQLIniFileConnection.sDriverID = MDSPgSQL)
100479>>>>>                    // It should probably be allowed to use an UID but no password...
100479>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100480>>>>>                    Case Break
100481>>>>>                Case (SQLIniFileConnection.sDriverID = MDSPgSQL)
100484>>>>>                    // It should probably be allowed to use an UID but no password...
100484>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100485>>>>>                    Case Break
100486>>>>>                Case (SQLIniFileConnection.sDriverID = MDSMySQL)
100489>>>>>                    // It should probably be allowed to use an UID but no password...
100489>>>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
100490>>>>>                    Case Break
100491>>>>>            Case End
100491>>>>>
100491>>>>>            If (bOK = False) Begin
100493>>>>>                Send Info_Box "Please fill in all connection data."
100494>>>>>                Procedure_Return
100495>>>>>            End
100495>>>>>>
100495>>>>>
100495>>>>>            // Oct 28 2017 NGS. Don't think this restriction is needed!
100495>>>>>            // As long as only one connection can be active, we should be fine.
100495>>>>>            // Check that the connection ID is unique:
100495>>>>>//            Get IsConnectionIDDuplicate SQLIniFileConnection to bOK
100495>>>>>//            If (bOK = True) Begin
100495>>>>>//                Get Message_Box (CS_DUF_DuplicateConnectionIDPre * "'" + SQLIniFileConnection.sConnectionID + "'." * CS_DUF_DuplicateConnectionIDPost) ""  MB_OK MB_ICONEXCLAMATION to bOK
100495>>>>>//                Procedure_Return
100495>>>>>//            End
100495>>>>>
100495>>>>>            Move MBR_Yes to iRetval
100496>>>>>            Get Label of oLoginInfo_tb to sLoginText
100497>>>>>            If (sLoginText = CS_LoginFailed) Begin
100499>>>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
100500>>>>>            End
100500>>>>>>
100500>>>>>            Else If (sLoginText = "") Begin
100503>>>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
100504>>>>>            End
100504>>>>>>
100504>>>>>            If (iRetval <> MBR_Yes) Begin
100506>>>>>                Procedure_Return
100507>>>>>            End
100507>>>>>>
100507>>>>>
100507>>>>>            Set pSQLConnectionData to SQLIniFileConnection
100508>>>>>            Set pbChanged to True
100509>>>>>            Send Close_Panel
100510>>>>>        End_Procedure
100511>>>>>
100511>>>>>    End_Object
100512>>>>>
100512>>>>>    Object oCancel_Btn is a cButtonDPI
100514>>>>>        Set Label    to "Cancel"
100515>>>>>        Set Location to 232 343
100516>>>>>        Set peAnchors to anBottomRight
100517>>>>>
100517>>>>>        Procedure OnClick
100520>>>>>            Set pbChanged to False
100521>>>>>            Send Close_Panel
100522>>>>>        End_Procedure
100523>>>>>
100523>>>>>    End_Object
100524>>>>>
100524>>>>>    Object oHelp_Btn is a cButtonDPI
100526>>>>>        Set Label to "Help"
100527>>>>>        Set Location to 232 11
100528>>>>>        Set peAnchors to anBottomRight
100529>>>>>        Set psImage to "ActionHelp.ico"
100530>>>>>        
100530>>>>>        Procedure OnClick
100533>>>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
100534>>>>>        End_Procedure
100535>>>>>    End_Object
100536>>>>>
100536>>>>>    // Returns True if anything has changed.
100536>>>>>    Function Should_Save Returns Boolean
100539>>>>>        String[] sConnectionData sConnectionData2
100541>>>>>        tSQLConnection SQLConnectionData
100541>>>>>        tSQLConnection SQLConnectionData
100541>>>>>        Boolean bState
100541>>>>>
100541>>>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
100543>>>>>        Get pSQLConnectionData to SQLConnectionData
100544>>>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
100545>>>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
100545>>>>>        // to be able to compare properly.
100545>>>>>        Move "" to sConnectionData2[7]
100546>>>>>        Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
100547>>>>>
100547>>>>>        Function_Return (bState = False)
100548>>>>>    End_Function
100549>>>>>
100549>>>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
100552>>>>>        Integer iCount iSize iItems iCurrentRow
100552>>>>>        String sValue sConnectionID
100552>>>>>        Boolean bExists
100552>>>>>        tDataSourceRow[] TheData
100552>>>>>        tDataSourceRow[] TheData
100553>>>>>        tDataSourceRow TheRow
100553>>>>>        tDataSourceRow TheRow
100553>>>>>
100553>>>>>        Move 0 to iItems
100554>>>>>        Get piCurrentRow to iCurrentRow
100555>>>>>        Move SQLConnection.sConnectionID to sConnectionID
100556>>>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
100557>>>>>        Get pTheData to TheData
100558>>>>>        Move (SizeOfArray(TheData)) to iSize
100559>>>>>        If (iCurrentRow <> -1) Begin
100561>>>>>            // This is the sConnectionID:
100561>>>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
100562>>>>>        End
100562>>>>>>
100562>>>>>        Else Begin
100563>>>>>            Move TheRow to TheData[iSize]
100564>>>>>        End
100564>>>>>>
100564>>>>>        Move (SizeOfArray(TheData)) to iSize
100565>>>>>        Decrement iSize
100566>>>>>        For iCount from 0 to iSize
100572>>>>>>
100572>>>>>            Move TheData[iCount].sValue[2] to sValue
100573>>>>>            Move (sValue = sConnectionID) to bExists
100574>>>>>            If (bExists) Begin
100576>>>>>                Increment iItems
100577>>>>>            End
100577>>>>>>
100577>>>>>        Loop
100578>>>>>>
100578>>>>>
100578>>>>>        Function_Return (iItems > 1)
100579>>>>>    End_Function
100580>>>>>
100580>>>>>    // Transfers data between a tSQLConnection struct and a grid data row.
100580>>>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
100583>>>>>        tDataSourceRow TheRow
100583>>>>>        tDataSourceRow TheRow
100583>>>>>        Integer iDbType
100583>>>>>        String sValue
100583>>>>>
100583>>>>>        Move 0                                  to TheRow.sValue[0]
100584>>>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
100585>>>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
100586>>>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
100587>>>>>
100587>>>>>        // We only show three asterisks ("***") instead of the password in the grid.
100587>>>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
100588>>>>>        Move sValue                             to TheRow.sValue[4]
100589>>>>>
100589>>>>>        Move SQLConnection.iDbType to iDbType
100590>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
100591>>>>>        Move sValue                             to TheRow.sValue[5]
100592>>>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
100593>>>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
100594>>>>>
100594>>>>>        // Hidden columns (to make Should_Save function work)
100594>>>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
100595>>>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
100596>>>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
100597>>>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
100598>>>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
100599>>>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
100600>>>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
100601>>>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
100602>>>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
100603>>>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
100603>>>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
100603>>>>>
100603>>>>>        Function_Return TheRow
100604>>>>>    End_Function
100605>>>>>
100605>>>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
100608>>>>>        String[] sConnectionData
100609>>>>>        String sValue
100609>>>>>        Integer iRetval
100609>>>>>
100609>>>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
100610>>>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
100611>>>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
100612>>>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
100613>>>>>        Move SQLConnection.sServer           to sConnectionData[5]
100614>>>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
100615>>>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
100616>>>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
100617>>>>>        Move SQLConnection.sUserID           to sConnectionData[9]
100618>>>>>
100618>>>>>        If (SQLConnection.sPassword <> "") Begin
100620>>>>>            Move MBR_Yes to iRetval
100621>>>>>            If (pbDFConnId(Self) = True) Begin
100623>>>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. This password will not be touched. Continue?" to iRetval
100624>>>>>                If (iRetval = MBR_Yes) Begin
100626>>>>>                    Set psUncryptedPw to SQLConnection.sPassword
100627>>>>>                    Move "" to SQLConnection.sPassword
100628>>>>>                End
100628>>>>>>
100628>>>>>                Else Begin
100629>>>>>                    Send Stop_UI
100630>>>>>                End
100630>>>>>>
100630>>>>>            End
100630>>>>>>
100630>>>>>            Else Begin
100631>>>>>                Move SQLConnection.sPassword to sConnectionData[10]
100632>>>>>            End
100632>>>>>>
100632>>>>>        End
100632>>>>>>
100632>>>>>
100632>>>>>        Move SQLConnection.sSchema           to sConnectionData[11]
100633>>>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
100634>>>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
100635>>>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
100636>>>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
100637>>>>>
100637>>>>>        Function_Return sConnectionData
100638>>>>>    End_Function
100639>>>>>
100639>>>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
100642>>>>>        tSQLConnection SQLConnection
100642>>>>>        tSQLConnection SQLConnection
100642>>>>>        String sValue
100642>>>>>
100642>>>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
100643>>>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
100644>>>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
100645>>>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
100646>>>>>        Move sConnectionData[5]  to SQLConnection.sServer
100647>>>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
100648>>>>>
100648>>>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
100649>>>>>        Move sConnectionData[9]  to SQLConnection.sUserID
100650>>>>>
100650>>>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
100652>>>>>            Move sConnectionData[10] to SQLConnection.sPassword
100653>>>>>        End
100653>>>>>>
100653>>>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
100653>>>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
100653>>>>>        If (pbDFConnId(Self) = True) Begin
100655>>>>>            Get psUncryptedPw to SQLConnection.sPassword
100656>>>>>        End
100656>>>>>>
100656>>>>>
100656>>>>>        Move sConnectionData[11] to SQLConnection.sSchema
100657>>>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
100658>>>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
100659>>>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
100660>>>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
100661>>>>>
100661>>>>>        // Connection string:
100661>>>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
100662>>>>>
100662>>>>>        Function_Return SQLConnection
100663>>>>>    End_Function
100664>>>>>
100664>>>>>    Procedure Popup
100667>>>>>        tSQLConnection SQLIniFileConnection
100667>>>>>        tSQLConnection SQLIniFileConnection
100667>>>>>        String[] sConnectionData
100668>>>>>        String sDriverID
100668>>>>>        Integer iDbType
100668>>>>>        Boolean bAdd
100668>>>>>
100668>>>>>        Move (piCurrentRow(Self) = -1) to bAdd
100669>>>>>        Get pSQLConnectionData to SQLIniFileConnection
100670>>>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
100672>>>>>            Move True to SQLIniFileConnection.bEnabled
100673>>>>>        End
100673>>>>>>
100673>>>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
100674>>>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
100676>>>>>        // We need this message to "auto-default" certain fields.
100676>>>>>        If (bAdd = True) Begin
100678>>>>>            Get SelectedDbType of oDbType_cf to iDbType
100679>>>>>            Get Value of oDriverID_cf to sDriverID
100680>>>>>            If (sDriverID = "") Begin
100682>>>>>                Move MSSQLDRV_ID to sDriverID
100683>>>>>            End
100683>>>>>>
100683>>>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
100685>>>>>        End
100685>>>>>>
100685>>>>>        
100685>>>>>        Set Password_State of oPassword_fm to True
100686>>>>>        Set Value of oLoginInfo_tb to ""
100687>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
100688>>>>>        Forward Send Popup
100690>>>>>    End_Procedure
100691>>>>>
100691>>>>>    Procedure Page Integer iPageObject
100694>>>>>        Boolean bNew
100694>>>>>        String sText
100694>>>>>        Handle hWnd
100694>>>>>
100694>>>>>        Forward Send Page iPageObject
100696>>>>>
100696>>>>>        Set Icon to "SQLConnections.ico"
100697>>>>>        Get pbNew to bNew
100698>>>>>        If (bNew = True) Begin
100700>>>>>//            Set Prompt_Button_Mode of oDatabase_fm to PB_PromptOff
100700>>>>>//            Set Value of oDatabase_fm to "Master"
100700>>>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
100701>>>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
100702>>>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
100703>>>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
100704>>>>>            Send Info_Box sText
100705>>>>>        End
100705>>>>>>
100705>>>>>
100705>>>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
100707>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
100708>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
100709>>>>>        End
100709>>>>>>
100709>>>>>    End_Procedure
100710>>>>>
100710>>>>>    // Put a status bar at the bottom of the panel, which makes
100710>>>>>    // status_help work and puts a gripper in the lower right corner.
100710>>>>>    Procedure End_Construct_Object
100713>>>>>        Integer iStyle iSize iOffset
100713>>>>>
100713>>>>>        Forward Send End_Construct_Object
100715>>>>>
100715>>>>>        Get Border_Style to iStyle
100716>>>>>        Move 8 to iOffset
100717>>>>>        If (iStyle = Border_Thick) Begin
100719>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
100721>>>>>                Object oStatusBar is a cCJStatusBar
100723>>>>>                    Set phoDialogCommandbar to Self
100724>>>>>                    Object oStatusIdle is a cCJStatusBarPane
100726>>>>>                        Set piId to sbpIDIdlePane
100727>>>>>                        Set pbStyleStretch to True
100728>>>>>                    End_Object
100729>>>>>                End_Object
100730>>>>>            End_Object
100731>>>>>
100731>>>>>            Get Size to iSize
100732>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
100733>>>>>        End
100733>>>>>>
100733>>>>>    End_Procedure
100734>>>>>
100734>>>>>    Procedure ShowProgramHelp
100737>>>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
100738>>>>>    End_Procedure
100739>>>>>
100739>>>>>//    Object oSQLTableName_cf is a ComboForm
100739>>>>>//        Set Size to 11 116
100739>>>>>//        Set Location to 236 14
100739>>>>>//        Set Label_Col_Offset to 0
100739>>>>>//        Set Label_Justification_Mode to JMode_Top
100739>>>>>//        Set Label to "Select Table:"
100739>>>>>//        Set Label_Row_Offset to 1
100739>>>>>//        Set Entry_State to False
100739>>>>>//
100739>>>>>//        Procedure OnDropDown
100739>>>>>//            Send DoCombo_Fill_List
100739>>>>>//        End_Procedure
100739>>>>>//
100739>>>>>//        Procedure OnCloseUp
100739>>>>>//            Send Delete_Data of oSQLColumnName_cf
100739>>>>>//        End_Procedure
100739>>>>>//
100739>>>>>//        Procedure DoCombo_Fill_List
100739>>>>>//            String[] sTablesArray
100739>>>>>//            String sDriverID
100739>>>>>//            Integer iCount iSize
100739>>>>>//            tSQLConnection SQLConnection
100739>>>>>//
100739>>>>>//            Send Delete_Data
100739>>>>>//            Get Value of oDriverID_cf to sDriverID
100739>>>>>//            Get pSQLConnectionData to SQLConnection
100739>>>>>//            Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
100739>>>>>//
100739>>>>>//            Get SQLUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
100739>>>>>//            Move (SizeOfArray(sTablesArray)) to iSize
100739>>>>>//            Decrement iSize
100739>>>>>//            For iCount from 0 to iSize
100739>>>>>//                Send Combo_Add_Item sTablesArray[iCount]
100739>>>>>//            Loop
100739>>>>>//        End_Procedure
100739>>>>>//
100739>>>>>//        // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
100739>>>>>//        // Augmented Value function.
100739>>>>>//        // We need to use Wincombo_x messages. Probably due to sync reasons.
100739>>>>>//        // When e.g. OnCloseUp is fired the data_value still holds the old value.
100739>>>>>//        Function Value Integer iItem Returns String
100739>>>>>//            Integer iRetval
100739>>>>>//            String sValue
100739>>>>>//            Get WinCombo_Current_Item      to iItem
100739>>>>>//            Get WinCombo_Value item iItem  to sValue
100739>>>>>//            Function_Return sValue
100739>>>>>//        End_Function
100739>>>>>//
100739>>>>>//    End_Object
100739>>>>>//
100739>>>>>//    Object oSQLColumnName_cf is a ComboForm
100739>>>>>//        Set Size to 11 116
100739>>>>>//        Set Location to 236 135
100739>>>>>//        Set Label_Col_Offset to 0
100739>>>>>//        Set Label_Justification_Mode to JMode_Top
100739>>>>>//        Set Label to "Select Column:"
100739>>>>>//        Set Label_Row_Offset to 1
100739>>>>>//        Set Entry_State to False
100739>>>>>//
100739>>>>>//        Procedure DoCombo_Fill_List
100739>>>>>//            String[] sColumnsArray
100739>>>>>//            String sTableName sDriverID sConnectionString
100739>>>>>//            Integer iCount iSize
100739>>>>>//
100739>>>>>//            Send Delete_Data
100739>>>>>//            Get Value of oDriverID_cf to sDriverID
100739>>>>>//            Get Value               of oSQLTableName_cf        to sTableName
100739>>>>>////                Get psConnectionString  of ghoSQLConnectionHandler to sConnectionString
100739>>>>>//            Get SQLUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
100739>>>>>//            Move (SizeOfArray(sColumnsArray)) to iSize
100739>>>>>//            Decrement iSize
100739>>>>>//            For iCount from 0 to iSize
100739>>>>>//                Send Combo_Add_Item sColumnsArray[iCount]
100739>>>>>//            Loop
100739>>>>>//            If (iSize > 1) Begin
100739>>>>>//                Set Current_Item to 1
100739>>>>>//            End
100739>>>>>//        End_Procedure
100739>>>>>//
100739>>>>>//        Procedure OnDropDown
100739>>>>>//            Send DoCombo_Fill_List
100739>>>>>//        End_Procedure
100739>>>>>//    End_Object
100739>>>>>
100739>>>>>    On_Key Key_F1 Send ShowProgramHelp
100740>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
100741>>>>>//    On_Key Key_Ctrl+Key_O Send KeyAction of oOK_Btn
100741>>>>>//    On_Key Key_Ctrl+Key_C Send KeyAction of oCancel_Btn
100741>>>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
100742>>>>>End_Object
100743>>>>>                                                                                                                        // If ini-file= "DFConnId.ini" (DAW file)
100743>>>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
100746>>>>>    Handle ho
100746>>>>>
100746>>>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
100747>>>>>    Set pbNew                   of ho to bNew
100748>>>>>    Set piCurrentRow            of ho to iCurrentRow
100749>>>>>    Set pbDFConnId              of ho to bDFConnId
100750>>>>>    Set pSQLConnectionData      of ho to SQLConnectionData
100751>>>>>    Set pTheData                of ho to TheData
100752>>>>>
100752>>>>>    Send Popup                  of ho
100753>>>>>
100753>>>>>    Get pSQLConnectionData      of ho to SQLConnectionData
100754>>>>>    Get pbChanged               of ho to bChanged
100755>>>>>End_Procedure
100756>>>Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\AddToStudio.dg)
100756>>>>>Use Windows.pkg
100756>>>>>Use Dfspnfrm.pkg
100756>>>>>Use cRegistry.pkg
100756>>>>>Use vWin32fh.pkg
100756>>>>>
100756>>>>>Enum_List
100756>>>>>    Define cx_RegKeyAlreadyExist
100756>>>>>    Define cx_RegKeyCreated
100756>>>>>    Define cx_RegkeyFailed
100756>>>>>    Define cx_RegKeyVDFKeyDoesNotExist
100756>>>>>    Define CX_InstalledOkVdfUnder16
100756>>>>>End_Enum_List
100756>>>>>
100756>>>>>// Note: The "Visual" part will automatically be removed if
100756>>>>>// the current DataFlex version is above 17.
100756>>>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
100756>>>>>Define CS_StudioTools       for "\Studio\Tools"
100756>>>>>Define CS_RegApplication    for "<application>"
100756>>>>>Define CS_RegWorkspace      for "<workspace>"
100756>>>>>Define CS_CommandLine       for "CommandLine"
100756>>>>>Define CS_Name              for "Name"
100756>>>>>Define CS_Separator         for "Separator"
100756>>>>>Define CS_Command           for "Command"
100756>>>>>
100756>>>>>
100756>>>>>Object oAddToStudio_dg is a ModalPanel
100758>>>>>    Set Size to 81 330
100759>>>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
100760>>>>>    Set piMinSize to 79 211
100761>>>>>    Set Location to 5 4
100762>>>>>    Set Locate_Mode to Center_On_Parent
100763>>>>>
100763>>>>>    Property String psTag CS_RegApplication
100765>>>>>
100765>>>>>    Object oStudioIntegration_grp is a Group
100767>>>>>        Set Size to 45 299
100768>>>>>        Set Location to 8 15
100769>>>>>        Set Label to "DataFlex Studio Integration"
100770>>>>>
100770>>>>>        Object oStudioMajorVersion_sf is a SpinForm
100772>>>>>            Set Size to 12 27
100773>>>>>            Set Location to 18 168
100774>>>>>            Set Maximum_Position to 30
100775>>>>>            Set Minimum_Position to 14
100776>>>>>            Set Label_Col_Offset to 2
100777>>>>>            Set Label_Justification_Mode to JMode_Right
100778>>>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
100779>>>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
100780>>>>>            Set Value to FMAC_VERSION
100781>>>>>            Set peAnchors to anNone
100782>>>>>        End_Object
100783>>>>>
100783>>>>>        Object oStudioMinorVersion_sf is a SpinForm
100785>>>>>            Set Size to 12 27
100786>>>>>            Set Location to 18 254
100787>>>>>            Set Label_Col_Offset to 2
100788>>>>>            Set Label to "Minor Version"
100789>>>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
100790>>>>>            Set Maximum_Position to 9
100791>>>>>            Set Minimum_Position to 0
100792>>>>>            Set Value to FMAC_REVISION
100793>>>>>            Set Label_Justification_Mode to JMode_Right
100794>>>>>            Set peAnchors to anNone
100795>>>>>        End_Object
100796>>>>>
100796>>>>>    End_Object
100797>>>>>
100797>>>>>    Object oOK_btn is a Button
100799>>>>>        Set Size to 14 50
100800>>>>>        Set Location to 59 207
100801>>>>>        Set Label to "Add Now"
100802>>>>>        Set Status_Help to "Add to DataFlex Studios 'Tools' menu. The Studio version can be selected with the two spinforms. The COMManifestStudio program gets added to the Studios Tools menu. When selected from the Studio it will pass the current project name on the command line so that the current program's manifest file is automatically loaded by the COMManifestStudio program."
100803>>>>>        Set peAnchors to anTopRight
100804>>>>>
100804>>>>>        Procedure OnClick
100807>>>>>            Integer iRetval iMajorVersion iMinorVersion
100807>>>>>            String sText sStudioVersion
100807>>>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
100808>>>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
100809>>>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
100810>>>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
100811>>>>>            Case Begin
100811>>>>>                Case (iRetval = cx_RegKeyAlreadyExist)
100813>>>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
100814>>>>>                    Break
100815>>>>>                Case (iRetval = cx_RegKeyCreated)
100818>>>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
100819>>>>>                    Break
100820>>>>>                Case (iRetval = cx_RegkeyFailed)
100823>>>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
100824>>>>>                    Break
100825>>>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
100828>>>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
100829>>>>>                    Break
100830>>>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
100833>>>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
100834>>>>>                    Break
100835>>>>>            Case End
100835>>>>>
100835>>>>>            Send Info_Box sText
100836>>>>>        End_Procedure
100837>>>>>    End_Object
100838>>>>>
100838>>>>>    Object oCancel_Btn is a Button
100840>>>>>        Set Label to "&Close"
100841>>>>>        Set Location to 59 264
100842>>>>>        Set peAnchors to anBottomRight
100843>>>>>
100843>>>>>        Procedure OnClick
100846>>>>>            Send Close_Panel
100847>>>>>        End_Procedure
100848>>>>>
100848>>>>>    End_Object
100849>>>>>
100849>>>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
100852>>>>>        Boolean bOk bExists bOpen
100852>>>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
100852>>>>>        Handle hoReg hoArray
100852>>>>>        Integer i iItems iCreated iRetval
100852>>>>>
100852>>>>>        Move False to bOk
100853>>>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
100854>>>>>        If (sStudioVersion > "17.1") Begin
100856>>>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
100857>>>>>        End
100857>>>>>>
100857>>>>>
100857>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
100858>>>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
100859>>>>>        Get vFolderFormat sProgramPath to sProgramPath
100860>>>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
100861>>>>>        Get Module_Name to sProgram
100862>>>>>        Get Create U_cRegistry to hoReg
100863>>>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
100864>>>>>
100864>>>>>        // First check if the DataFlex version is installed
100864>>>>>        Get KeyExists of hoReg sStudioPath to bExists
100865>>>>>        If (bExists = False) Begin
100867>>>>>            Send Destroy of hoReg
100868>>>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
100869>>>>>        End
100869>>>>>>
100869>>>>>
100869>>>>>        // Then check if any tools have been installed in the Tools Menu.
100869>>>>>        // If no tools created yet, create the Tools registry key.
100869>>>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
100870>>>>>        Get KeyExists of hoReg sStudioPath to bExists
100871>>>>>        If (bExists = False) Begin
100873>>>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
100874>>>>>            Get CreateKey of hoReg sStudioPath to iCreated
100875>>>>>            If (iCreated <> 0) Begin
100877>>>>>                Move cx_RegkeyFailed to iRetval
100878>>>>>            End
100878>>>>>>
100878>>>>>            Else Begin
100879>>>>>                Move True to bExists
100880>>>>>            End
100880>>>>>>
100880>>>>>        End
100880>>>>>>
100880>>>>>
100880>>>>>        If (bExists = True) Begin
100882>>>>>            Get OpenKey of hoReg sStudioPath to bOk
100883>>>>>            If (bOk = True) Begin
100885>>>>>                Get Create U_Array to hoArray
100886>>>>>                Get GetSubkeys of hoReg hoArray to iItems
100887>>>>>                Decrement iItems
100888>>>>>                Move False to bExists
100889>>>>>                Set pfAccessRights of hoReg to KEY_READ
100890>>>>>                // Check if the key already exists:
100890>>>>>                For i from 0 to iItems
100896>>>>>>
100896>>>>>                    Get Value of hoArray item i to sKey
100897>>>>>                    Move (sStudioPath + "\" + sKey) to sKey
100898>>>>>                    Get OpenKey of hoReg sKey to bOpen
100899>>>>>                    If (bOpen = True) Begin
100901>>>>>                        Get ReadString of hoReg CS_Name to sValue
100902>>>>>                        If (sValue = sProduct) Move True to bExists
100905>>>>>                    End
100905>>>>>>
100905>>>>>                Loop
100906>>>>>>
100906>>>>>                Send Destroy of hoArray
100907>>>>>                If (bExists = False) Begin
100909>>>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
100910>>>>>                    // We need to create the next key number:
100910>>>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
100910>>>>>                    Increment iItems
100911>>>>>                    Increment iItems
100912>>>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
100913>>>>>                    If (iCreated = 0) Begin
100915>>>>>                        Send WriteString of hoReg CS_Name sProduct
100916>>>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
100916>>>>>                        If (sStudioVersion >= "16.0") Begin
100918>>>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
100919>>>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
100920>>>>>                        End
100920>>>>>>
100920>>>>>                        Else Begin
100921>>>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
100922>>>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
100923>>>>>                        End
100923>>>>>>
100923>>>>>                        Send WriteDword  of hoReg CS_Separator 1
100924>>>>>                        Move cx_RegKeyCreated to iRetval
100925>>>>>                    End
100925>>>>>>
100925>>>>>                    Else Begin
100926>>>>>                        Move cx_RegkeyFailed to iRetval
100927>>>>>                    End
100927>>>>>>
100927>>>>>                End
100927>>>>>>
100927>>>>>                Else Begin
100928>>>>>                    Move cx_RegKeyAlreadyExist to iRetval
100929>>>>>                End
100929>>>>>>
100929>>>>>                Send CloseKey of hoReg
100930>>>>>            End
100930>>>>>>
100930>>>>>        End
100930>>>>>>
100930>>>>>
100930>>>>>        Send Destroy of hoReg
100931>>>>>        Function_Return iRetval
100932>>>>>    End_Function
100933>>>>>
100933>>>>>    Procedure Page Integer iPageObject
100936>>>>>        Forward Send Page iPageObject
100938>>>>>        Set Icon to "SQLConnections.ico"
100939>>>>>    End_Procedure
100940>>>>>
100940>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
100941>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
100942>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
100943>>>>>End_Object
100944>>>
100944>>>Activate_View Activate_oSQLMaintainConnection for oSQLMaintainConnection
100954>>>>
100954>>>Object oSQLMaintainConnection is a dbView
100956>>>    Set Size to 153 489
100957>>>    Set Location to 2 2
100958>>>    Set Maximize_Icon to True
100959>>>    Set Minimize_Icon to False
100960>>>    Set Border_Style to Border_Thick
100961>>>    Set View_Mode to Viewmode_Zoom
100962>>>    Set pbAutoActivate to True
100963>>>    Set pbAcceptDropFiles to True
100964>>>    Property Boolean pbEnabled False
100966>>>    Property Boolean pbNew False
100968>>>    Property tDataSourceRow[] pTheData
100970>>>
100970>>>    Object oGridInfo_tb is a TextBox
100972>>>        Set Auto_Size_State to False
100973>>>        Set Size to 9 473
100974>>>        Set Location to 3 17
100975>>>        Set Label to "You can drag and drop a connection file on to the grid."
100976>>>        Set FontItalics to True
100977>>>        Set peAnchors to anTopLeftRight
100978>>>        Set Justification_Mode to JMode_Center
100979>>>    End_Object
100980>>>
100980>>>    Object oSQLConnections_grd is a cCJGrid
100982>>>        Set Size to 100 454
100983>>>        Set Location to 14 19
100984>>>        Set peAnchors to anAll
100985>>>        Set pbShowRowFocus to True
100986>>>        Set pbUseAlternateRowBackgroundColor to True
100987>>>        Set pbSelectionEnable to True
100988>>>        Set pbRestoreLayout to True
100989>>>        Set psLayoutSection to "oSQLConnections_grd"
100990>>>        Set piLayoutBuild to 12
100991>>>        Set pbShowFooter to True
100992>>>        Set pbAllowAppendRow to False
100993>>>        Set pbAllowEdit to False
100994>>>        Set pbAllowInsertRow to False
100995>>>        Set pbAutoAppend to False
100996>>>        Set pbAutoSave to False
100997>>>        Set pbEditOnTyping to False
100998>>>        Set peVisualTheme to xtpReportThemeOffice2003
100999>>>
100999>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
101001>>>            Set piWidth to 17
101002>>>        End_Object
101003>>>
101003>>>        Object oActive_Col is a cCJGridColumn
101005>>>            Set piWidth to 65
101006>>>            Set psCaption to "Enabled"
101007>>>            Set pbCheckbox to True
101008>>>            Set pbResizable to False
101009>>>            Set psToolTip to "Only one connection can be the active one at any time. Press the 'Edit' button or double-click on a row to edit."
101010>>>            Set pbResizable to False
101011>>>        End_Object
101012>>>
101012>>>        Object oConnectionID_Col is a cCJGridColumn
101014>>>            Set piWidth to 81
101015>>>            Set psCaption to "ID"
101016>>>//            Set piMaximumWidth to 170
101016>>>        End_Object
101017>>>
101017>>>        Object oDbType_Col is a cCJGridColumn
101019>>>            Set piWidth to 135
101020>>>            Set psCaption to "Database Type"
101021>>>//            Set pbResizable to False
101021>>>        End_Object
101022>>>
101022>>>        Object oServer_Col is a cCJGridColumn
101024>>>            Set piWidth to 124
101025>>>            Set psCaption to "Server"
101026>>>        End_Object
101027>>>
101027>>>        Object oDatabase_Col is a cCJGridColumn
101029>>>            Set piWidth to 82
101030>>>            Set psCaption to "Database"
101031>>>        End_Object
101032>>>
101032>>>        Object oDriver_Col is a cCJGridColumn
101034>>>            Set piWidth to 90
101035>>>            Set psCaption to "Driver ID"
101036>>>//            Set pbResizable to False
101036>>>        End_Object
101037>>>
101037>>>        Object oConnectionString_Col is a cCJGridColumn
101039>>>            Set piWidth to 328
101040>>>            Set psCaption to "Connection String"
101041>>>            Set psTooltip to "The full connection string as read from the connections ini-file. Press the 'Edit' button or double-click on a row to edit."
101042>>>        End_Object
101043>>>
101043>>>        // The following columns are all hidden. The only reason they are here is to make the grid data exactly the same
101043>>>        // as the tSQLConnection data.
101043>>>        // See the "Should_Save" function
101043>>>        //
101043>>>        // "Untouched" connection string column. Needed when passing data between grid and popup dialog as we mask pw in connection string.
101043>>>        Object oConnectionStringFull_Col is a cCJGridColumn
101045>>>            Set piWidth to 50
101046>>>            Set psCaption to "Connection String (Untouched)"
101047>>>            Set pbVisible to False
101048>>>        End_Object
101049>>>
101049>>>        Object oTrusted_Col is a cCJGridColumn
101051>>>            Set piWidth to 50
101052>>>            Set psCaption to "Trusted"
101053>>>            Set pbCheckbox to True
101054>>>            Set pbVisible to False
101055>>>        End_Object
101056>>>
101056>>>        Object oUserID_Col is a cCJGridColumn
101058>>>            Set piWidth to 50
101059>>>            Set psCaption to "UserID"
101060>>>            Set pbVisible to False
101061>>>        End_Object
101062>>>
101062>>>        Object oPassword_Col is a cCJGridColumn
101064>>>            Set piWidth to 50
101065>>>            Set psCaption to "Password"
101066>>>            Set pbVisible to False
101067>>>        End_Object
101068>>>
101068>>>        Object oSchema_Col is a cCJGridColumn
101070>>>            Set piWidth to 50
101071>>>            Set psCaption to "Schema"
101072>>>            Set pbVisible to False
101073>>>        End_Object
101074>>>
101074>>>        Object oBaseTableSpace_Col is a cCJGridColumn
101076>>>            Set piWidth to 50
101077>>>            Set psCaption to "Base Table Space"
101078>>>            Set pbVisible to False
101079>>>        End_Object
101080>>>
101080>>>        Object oLongTableSpace_Col is a cCJGridColumn
101082>>>            Set piWidth to 50
101083>>>            Set psCaption to "Long Table Space"
101084>>>            Set pbVisible to False
101085>>>        End_Object
101086>>>
101086>>>        Object oIndexTableSpace_Col is a cCJGridColumn
101088>>>            Set piWidth to 50
101089>>>            Set psCaption to "Index Table Space"
101090>>>            Set pbVisible to False
101091>>>        End_Object
101092>>>
101092>>>        Object oSilentLogin_Col is a cCJGridColumn
101094>>>            Set piWidth to 50
101095>>>            Set psCaption to "Silent Login"
101096>>>            Set pbCheckbox to True
101097>>>            Set pbVisible to False
101098>>>        End_Object
101099>>>
101099>>>//        Object oDisabled_Col is a cCJGridColumn
101099>>>//            Set piWidth to 50
101099>>>//            Set psCaption to "Disabled"
101099>>>//            Set pbVisible to False
101099>>>//        End_Object
101099>>>
101099>>>        Object oCJContextMenu is a cCJContextMenu
101101>>>            Set pbShowPopupBarToolTips of ghoCommandBars to True
101102>>>
101102>>>            Object oAddMenuItem is a cCJMenuItem
101104>>>                Set psCaption to "Add"
101105>>>                Set psTooltip to "Add new connection"
101106>>>                Set psImage to "ActionNew.ico"
101107>>>                Procedure OnExecute Variant vCommandBarControl
101110>>>                    Forward Send OnExecute vCommandBarControl
101112>>>                    Send KeyAction of oAdd_btn
101113>>>                End_Procedure
101114>>>            End_Object
101115>>>
101115>>>            Object oEditMenuItem is a cCJMenuItem
101117>>>                Set psCaption to "Edit"
101118>>>                Set psTooltip to "Edit existing connection"
101119>>>                Set psImage to "ActionEdit.ico"
101120>>>                Procedure OnExecute Variant vCommandBarControl
101123>>>                    Forward Send OnExecute vCommandBarControl
101125>>>                    Send KeyAction of oEdit_btn
101126>>>                End_Procedure
101127>>>            End_Object
101128>>>
101128>>>            Object oDeleteMenuItem is a cCJMenuItem
101130>>>                Set psCaption to "Delete"
101131>>>                Set psTooltip to "Delete current connection"
101132>>>                Set psImage to "ActionDelete.ico"
101133>>>                Procedure OnExecute Variant vCommandBarControl
101136>>>                    Forward Send OnExecute vCommandBarControl
101138>>>                    Send KeyAction of oDelete_btn
101139>>>                End_Procedure
101140>>>            End_Object
101141>>>
101141>>>            Object oRefreshMenuItem is a cCJMenuItem
101143>>>                Set pbControlBeginGroup to True
101144>>>                Set psCaption to "Refresh"
101145>>>                Set psTooltip to "Refresh grid (read values from ini-file)"
101146>>>                Set psImage to "ActionRefresh.ico"
101147>>>                Procedure OnExecute Variant vCommandBarControl
101150>>>                    Forward Send OnExecute vCommandBarControl
101152>>>                    Send KeyAction of oRefresh_btn
101153>>>                End_Procedure
101154>>>            End_Object
101155>>>
101155>>>            Object oSaveMenuItem is a cCJMenuItem
101157>>>                Set psCaption to "Save"
101158>>>                Set psTooltip to "Save changes"
101159>>>                Set psImage to "ActionSave.ico"
101160>>>                Procedure OnExecute Variant vCommandBarControl
101163>>>                    Forward Send OnExecute vCommandBarControl
101165>>>                    Send KeyAction of oSave_btn
101166>>>                End_Procedure
101167>>>
101167>>>                Function IsEnabled Returns Boolean
101170>>>                    Boolean bState
101170>>>                    Get Should_Save to bState
101171>>>                    Function_Return (bState = True)
101172>>>                End_Function
101173>>>            End_Object
101174>>>
101174>>>            Set phoContextMenu to Self
101175>>>        End_Object
101176>>>
101176>>>        Function Should_Save Returns Boolean
101179>>>            tDataSourceRow[] TheData1 TheData2
101179>>>            tDataSourceRow[] TheData1 TheData2
101181>>>            Handle hoDataSource
101181>>>
101181>>>            Get pTheData to TheData1
101182>>>            Get phoDataSource to hoDataSource
101183>>>            Get DataSource    of hoDataSource to TheData2
101184>>>            Function_Return (not(IsSameArray(TheData1, TheData2)))
101185>>>        End_Function
101186>>>
101186>>>        Function HasRecord Returns Boolean
101189>>>            tDataSourceRow[] TheData
101189>>>            tDataSourceRow[] TheData
101190>>>            Handle hoDataSource
101190>>>            Integer iSize
101190>>>
101190>>>            Get phoDataSource to hoDataSource
101191>>>            Get DataSource    of hoDataSource to TheData
101192>>>            Move (SizeOfArray(TheData)) to iSize
101193>>>
101193>>>            Function_Return (iSize > 0)
101194>>>        End_Function
101195>>>
101195>>>        Procedure ChangeHeaderText
101198>>>            Handle[] hoPanels
101199>>>            String sFileName
101199>>>
101199>>>            Send ChangeStatusRowText ""
101200>>>            Get IniFileName to sFileName
101201>>>            // Not sure why, but if the oStatusPane1 was set to "Set piID to sbpIDIdlePane",
101201>>>            // it wasn't always updated when this message was send. So instead change the
101201>>>            // text explicitly:
101201>>>            Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
101202>>>            Set psText of hoPanels[0] to sFileName
101203>>>        End_Procedure
101204>>>
101204>>>        Function InFileName Returns String
101207>>>            String sFileName sPath
101207>>>            Handle ho
101207>>>            Boolean bChangesExist
101207>>>
101207>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
101208>>>            Get psIniFilePath of ho to sPath
101209>>>            Get psIniFileName of ho to sFileName
101210>>>            Get Should_Save to bChangesExist
101211>>>            If (bChangesExist = True) Begin
101213>>>                Move (sFileName + "*") to sFileName
101214>>>            End
101214>>>>
101214>>>            Function_Return (sPath + sFileName)
101215>>>        End_Function
101216>>>
101216>>>        Procedure LoadData
101219>>>            Handle hoDataSource ho
101219>>>            tDataSourceRow[] TheData
101219>>>            tDataSourceRow[] TheData
101220>>>            tDataSourceRow TheRow
101220>>>            tDataSourceRow TheRow
101220>>>            Integer iCount iSize
101220>>>            tSQLConnection[] SQLConnectionsArray
101220>>>            tSQLConnection[] SQLConnectionsArray
101221>>>
101221>>>            Send ChangeHeaderText
101222>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
101223>>>
101223>>>            Get phoDataSource to hoDataSource
101224>>>            Send Reset of hoDataSource
101225>>>
101225>>>            Get ReadIniFile to SQLConnectionsArray
101226>>>            Move (SizeOfArray(SQLConnectionsArray)) to iSize
101227>>>            Decrement iSize
101228>>>
101228>>>            // Load data to the grid datasource array
101228>>>            For iCount from 0 to iSize
101234>>>>
101234>>>                Get MoveSQLConnectionToGridRow SQLConnectionsArray[iCount] to TheRow
101235>>>                Move TheRow to TheData[iCount]
101236>>>            Loop
101237>>>>
101237>>>
101237>>>            Set pTheData to TheData
101238>>>
101238>>>            // Initialize Grid with new data
101238>>>            Send InitializeData TheData
101239>>>
101239>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize +1))
101240>>>            Send MovetoFirstRow
101241>>>        End_Procedure
101242>>>
101242>>>        // Transfers data between a tSQLConnection struct and a grid data row.
101242>>>        Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
101245>>>            tDataSourceRow TheRow
101245>>>            tDataSourceRow TheRow
101245>>>            Integer iDbType
101245>>>            String sValue
101245>>>
101245>>>            Move SQLConnection.bEnabled             to TheRow.sValue[piColumnId(oActive_Col(Self))]
101246>>>            Move SQLConnection.sConnectionID        to TheRow.sValue[piColumnId(oConnectionID_Col(Self))]
101247>>>            Move SQLConnection.sDriverID            to TheRow.sValue[piColumnId(oDriver_Col(Self))]
101248>>>
101248>>>            // We only show three asterisks ("***") instead of the password in the grid.
101248>>>            Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
101249>>>            Move sValue                             to TheRow.sValue[piColumnId(oConnectionString_Col(Self))]
101250>>>
101250>>>            Move SQLConnection.iDbType to iDbType
101251>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
101252>>>            Move sValue                             to TheRow.sValue[piColumnId(oDbType_Col(Self))]
101253>>>            Move SQLConnection.sServer              to TheRow.sValue[piColumnId(oServer_Col(Self))]
101254>>>            Move SQLConnection.sDatabase            to TheRow.sValue[piColumnId(oDatabase_Col(Self))]
101255>>>
101255>>>            // Hidden columns (to make Should_Save function work)
101255>>>            Move SQLConnection.sConnectionString    to TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] // "Untouched" connection string.
101256>>>            Move SQLConnection.bTrusted             to TheRow.sValue[piColumnId(oTrusted_Col(Self))]
101257>>>            Move SQLConnection.sUserID              to TheRow.sValue[piColumnId(oUserID_Col(Self))]
101258>>>            Move SQLConnection.sPassword            to TheRow.sValue[piColumnId(oPassword_Col(Self))]
101259>>>            Move SQLConnection.sSchema              to TheRow.sValue[piColumnId(oSchema_Col(Self))]
101260>>>            Move SQLConnection.sBaseTableSpace      to TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]
101261>>>            Move SQLConnection.sLongTableSpace      to TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]
101262>>>            Move SQLConnection.sIndexTableSpace     to TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]
101263>>>            Move SQLConnection.bSilentLogin         to TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]
101264>>>//            Move SQLConnection.bDisabled            to TheRow.sValue[piColumnId(oDisabled_Col(Self))]
101264>>>
101264>>>            Function_Return TheRow
101265>>>        End_Function
101266>>>
101266>>>        // Transfers data between a grid data row and a tSQLConnection struct.
101266>>>        Function MoveGridRowToSQLConnection tDataSourceRow TheRow Returns tSQLConnection
101269>>>            tSQLConnection SQLConnection
101269>>>            tSQLConnection SQLConnection
101269>>>            Integer iDbType
101269>>>            String sValue
101269>>>
101269>>>            Move TheRow.sValue[piColumnId(oActive_Col(Self))]               to SQLConnection.bEnabled
101270>>>            Move TheRow.sValue[piColumnId(oConnectionID_Col(Self))]         to SQLConnection.sConnectionID
101271>>>
101271>>>            Move TheRow.sValue[piColumnId(oDbType_Col(Self))]               to sValue
101272>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sValue to SQLConnection.iDbType
101273>>>            Move TheRow.sValue[piColumnId(oServer_Col(Self))]               to SQLConnection.sServer
101274>>>            Move TheRow.sValue[piColumnId(oDatabase_Col(Self))]             to SQLConnection.sDatabase
101275>>>            Move TheRow.sValue[piColumnId(oDriver_Col(Self))]               to SQLConnection.sDriverID
101276>>>
101276>>>            // Hidden columns (to make Should_Save function work)
101276>>>            Move TheRow.sValue[piColumnId(oConnectionStringFull_Col(Self))] to SQLConnection.sConnectionString
101277>>>            Move TheRow.sValue[piColumnId(oTrusted_Col(Self))]              to SQLConnection.bTrusted
101278>>>            Move TheRow.sValue[piColumnId(oUserID_Col(Self))]               to SQLConnection.sUserID
101279>>>            Move TheRow.sValue[piColumnId(oPassword_Col(Self))]             to SQLConnection.sPassword
101280>>>            Move TheRow.sValue[piColumnId(oSchema_Col(Self))]               to SQLConnection.sSchema
101281>>>            Move TheRow.sValue[piColumnId(oBaseTableSpace_Col(Self))]       to SQLConnection.sBaseTableSpace
101282>>>            Move TheRow.sValue[piColumnId(oLongTableSpace_Col(Self))]       to SQLConnection.sLongTableSpace
101283>>>            Move TheRow.sValue[piColumnId(oIndexTableSpace_Col(Self))]      to SQLConnection.sIndexTableSpace
101284>>>            Move TheRow.sValue[piColumnId(oSilentLogin_Col(Self))]          to SQLConnection.bSilentLogin
101285>>>//            Move TheRow.sValue[piColumnId(oDisabled_Col(Self))]             to SQLConnection.bDisabled
101285>>>
101285>>>            Function_Return SQLConnection
101286>>>        End_Function
101287>>>
101287>>>        // Called when the grid object is created:
101287>>>        Procedure Activating
101290>>>            Forward Send Activating
101292>>>            Send LoadData
101293>>>        End_Procedure
101294>>>
101294>>>        Function CurrentRow Returns Integer
101297>>>            Handle hoDataSource
101297>>>            Integer iRow
101297>>>
101297>>>            Get phoDataSource to hoDataSource
101298>>>            Get SelectedRow   of hoDataSource to iRow
101299>>>            Function_Return iRow
101300>>>        End_Function
101301>>>
101301>>>        Function CurrentRowData Returns tDataSourceRow
101304>>>            tDataSourceRow[] TheData
101304>>>            tDataSourceRow[] TheData
101305>>>            tDataSourceRow TheRow
101305>>>            tDataSourceRow TheRow
101305>>>            Handle ho hoDataSource
101305>>>            Integer iRow
101305>>>
101305>>>            Get phoDataSource  to hoDataSource
101306>>>            Get DataSource     of hoDataSource to TheData
101307>>>            Get SelectedRow    of hoDataSource to iRow
101308>>>            Move TheData[iRow] to TheRow
101309>>>
101309>>>            Function_Return TheRow
101310>>>        End_Function
101311>>>
101311>>>        Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
101314>>>            Integer iRow
101314>>>            Handle hoDataSource
101314>>>            tDataSourceRow[] RowData
101314>>>            tDataSourceRow[] RowData
101315>>>
101315>>>            Forward Send OnRowChanged iOldRow iNewSelectedRow
101317>>>            Send ChangeHeaderText
101318>>>
101318>>>            Get phoDataSource to hoDataSource
101319>>>
101319>>>            Get SelectedRow of hoDataSource to iRow
101320>>>            If (iRow <> -1) Begin
101322>>>                Get DataSource of hoDataSource to RowData
101323>>>                Set pbEnabled to RowData[iRow].sValue[piColumnid(oActive_Col(Self))]
101324>>>                Set Enabled_State of oEdit_btn   to True
101325>>>                Set Enabled_State of oDelete_btn to True
101326>>>            End
101326>>>>
101326>>>        End_Procedure
101327>>>
101327>>>        Procedure OnComRowDblClick Variant llRow Variant llItem
101330>>>            Forward Send OnComRowDblClick llRow llItem
101332>>>            Send KeyAction of oEdit_btn
101333>>>        End_Procedure
101334>>>
101334>>>        Procedure OnEnterKey
101337>>>            Forward Send OnEnterKey
101339>>>            Send KeyAction of oEdit_btn
101340>>>        End_Procedure
101341>>>
101341>>>        Procedure AddConnection tDataSourceRow TheRow
101344>>>            Integer iSize iCount
101344>>>            Handle hoDataSource
101344>>>            tDataSourceRow[] TheData
101344>>>            tDataSourceRow[] TheData
101345>>>            Boolean bEnabled
101345>>>
101345>>>            Get phoDataSource to hoDataSource
101346>>>            Get DataSource    of hoDataSource to TheData
101347>>>
101347>>>            Move (SizeOfArray(TheData)) to iSize
101348>>>            Move (TheRow.sValue[piColumnid(oActive_Col(Self))]) to bEnabled
101349>>>            If (bEnabled = True) Begin
101351>>>                // Then bEnabled state have changed; deactivate all current rows.
101351>>>                For iCount from 0 to (iSize -1)
101357>>>>
101357>>>                    Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
101358>>>                Loop
101359>>>>
101359>>>            End
101359>>>>
101359>>>
101359>>>            Move TheRow to TheData[iSize]
101360>>>
101360>>>            // Initialize Grid with new data
101360>>>            Send InitializeData TheData True
101361>>>            Move (SizeOfArray(TheData)) to iSize
101362>>>            Send MoveToLastRow
101363>>>
101363>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
101364>>>        End_Procedure
101365>>>
101365>>>        Procedure UpdateConnection tDataSourceRow TheRow
101368>>>            Integer iRow iSize iCount
101368>>>            Handle hoDataSource
101368>>>            tDataSourceRow[] TheData
101368>>>            tDataSourceRow[] TheData
101369>>>            String sValue
101369>>>            Boolean bEnabled
101369>>>
101369>>>            Get phoDataSource to hoDataSource
101370>>>            Get SelectedRow of hoDataSource to iRow
101371>>>            If (iRow <> -1) Begin
101373>>>                Get DataSource of hoDataSource to TheData
101374>>>
101374>>>                // If bEnabled state has changed; deactivate all rows.
101374>>>                Move (TheRow.sValue[piColumnId(oActive_Col(Self))]) to bEnabled
101375>>>                If (bEnabled = True) Begin
101377>>>                    Move (SizeOfArray(TheData)) to iSize
101378>>>                    Decrement iSize
101379>>>                    For iCount from 0 to iSize
101385>>>>
101385>>>                        Move False to TheData[iCount].sValue[piColumnId(oActive_Col(Self))]
101386>>>                    Loop
101387>>>>
101387>>>                End
101387>>>>
101387>>>
101387>>>                Move TheRow to TheData[iRow]
101388>>>            End
101388>>>>
101388>>>
101388>>>            // Initialize Grid with new data
101388>>>            Send ReInitializeData TheData True
101389>>>            Move (SizeOfArray(TheData)) to iSize
101390>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
101391>>>        End_Procedure
101392>>>
101392>>>        Procedure RemoveCurrentConnection
101395>>>            Integer iSize iRow iItem
101395>>>            Handle hoDataSource
101395>>>            tDataSourceRow[] TheData
101395>>>            tDataSourceRow[] TheData
101396>>>
101396>>>            Move 0 to iItem
101397>>>            Get phoDataSource to hoDataSource
101398>>>            Get DataSource of hoDataSource to TheData
101399>>>
101399>>>            Get SelectedRow of hoDataSource to iRow
101400>>>            If (iRow = -1) Begin
101402>>>                Procedure_Return
101403>>>            End
101403>>>>
101403>>>
101403>>>            Move False to Err
101404>>>            Send Request_Delete
101405>>>
101405>>>            Get DataSource of hoDataSource to TheData
101406>>>            Move (SizeOfArray(TheData)) to iSize
101407>>>            Set psFooterText of oConnectionString_Col to ("Number of connections:" * String(iSize))
101408>>>        End_Procedure
101409>>>
101409>>>        Function IsOneItemActive Returns Boolean
101412>>>            Handle hoDataSource ho
101412>>>            tDataSourceRow[] TheData
101412>>>            tDataSourceRow[] TheData
101413>>>            Integer iSize iCount
101413>>>            Boolean bRetval bExists
101413>>>            String sSection
101413>>>
101413>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
101414>>>            Get psIniSectionName of ho to sSection
101415>>>            Get SectionExists    of ho sSection to bExists
101416>>>
101416>>>            Get phoDataSource to hoDataSource
101417>>>            Get DataSource of hoDataSource to TheData
101418>>>
101418>>>            Move (SizeOfArray(TheData)) to iSize
101419>>>            If (iSize = 0) Begin
101421>>>                Function_Return True
101422>>>            End
101422>>>>
101422>>>
101422>>>            Decrement iSize
101423>>>            For iCount from 0 to iSize
101429>>>>
101429>>>                If (TheData[iCount].sValue[piColumnId(oActive_Col(Self))] = True) Begin
101431>>>                    Move True to bRetval
101432>>>                End
101432>>>>
101432>>>            Loop
101433>>>>
101433>>>
101433>>>            Function_Return bRetval
101434>>>        End_Function
101435>>>
101435>>>        Function ReadIniFile Returns tSQLConnection[]
101438>>>            tSQLConnection[] SQLConnectionsArray
101438>>>            tSQLConnection[] SQLConnectionsArray
101439>>>            Handle ho
101439>>>
101439>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
101440>>>            Get SQLIniFileReadConnections of ho to SQLConnectionsArray
101441>>>
101441>>>            Function_Return SQLConnectionsArray
101442>>>        End_Function
101443>>>
101443>>>        Procedure WriteIniFile
101446>>>            Integer iCount iSize
101446>>>            Handle hoDataSource ho
101446>>>            tDataSourceRow[] TheData
101446>>>            tDataSourceRow[] TheData
101447>>>            tDataSourceRow TheRow
101447>>>            tDataSourceRow TheRow
101447>>>            tSQLConnection[] SQLConnectionArray
101447>>>            tSQLConnection[] SQLConnectionArray
101448>>>            tSQLConnection SQLConnection
101448>>>            tSQLConnection SQLConnection
101448>>>            Boolean bIsOneActive bOK
101448>>>            String sPath sFileName
101448>>>
101448>>>            Get IsOneItemActive to bIsOneActive
101449>>>            If (bIsOneActive = False) Begin
101451>>>                Send Info_Box "Sorry, you need to set one connection as active before changes can be saved."
101452>>>                Procedure_Return
101453>>>            End
101453>>>>
101453>>>
101453>>>            Move 0 to iCount
101454>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
101455>>>            Get phoDataSource to hoDataSource
101456>>>            Get DataSource of hoDataSource to TheData
101457>>>            Move (SizeOfArray(TheData)) to iSize
101458>>>            Decrement iSize
101459>>>
101459>>>            // Load data from the grid datasource array to SQLConnection array
101459>>>            For iCount from 0 to iSize
101465>>>>
101465>>>                Move TheData[iCount] to TheRow
101466>>>                Get MoveGridRowToSQLConnection TheRow to SQLConnection
101467>>>                Move SQLConnection to SQLConnectionArray[iCount]
101468>>>            Loop
101469>>>>
101469>>>
101469>>>            Get SQLIniFileWriteConnections of ho SQLConnectionArray to bOK
101470>>>            If (bOK = False) Begin
101472>>>                Send ChangeStatusRowText "Sorry, an error occured while saving the file and changes were not saved."
101473>>>                Procedure_Return
101474>>>            End
101474>>>>
101474>>>
101474>>>            // Update the view property with the newly saved values. (Used to check if anything has changed)
101474>>>            Set pTheData to TheData
101475>>>            Send ChangeHeaderText
101476>>>            Send ChangeStatusRowText "Ready! File saved."
101477>>>        End_Procedure
101478>>>
101478>>>        Procedure OnHeaderClick Integer iCol
101481>>>            String sPath sFileName
101481>>>            Handle ho
101481>>>
101481>>>            Forward Send OnHeaderClick iCol
101483>>>
101483>>>            Get vSelect_File "SQLConnections ini-files (*.ini)|SQLConnections.ini|All Ini Files (*.ini)|*.ini|All Files (*.*)|*.*" "Select a connection ini-file" "" to sFileName
101484>>>            If (sFileName <> "") Begin
101486>>>                Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
101487>>>                Get ParseFolderName sFileName to sPath
101488>>>                Set psIniFilePath of ho to sPath
101489>>>                Get ParseFileName sFileName to sFileName
101490>>>                Set psIniFileName of ho to sFilename
101491>>>                Set pbDFConnId of ho to (sFileName <> CS_SQLIniFileName)
101492>>>                Send LoadData of oSQLConnections_grd
101493>>>            End
101493>>>>
101493>>>        End_Procedure
101494>>>
101494>>>        // These overrides the grid standar behaviour
101494>>>        On_Key kSave_Record Send KeyAction of oSave_btn
101495>>>        On_Key Key_F5       Send KeyAction of oRefresh_btn
101496>>>    End_Object
101497>>>
101497>>>    Object oAdd_btn is a cSQLConnectionButton
101499>>>        Set Size to 14 50
101500>>>        Set Location to 128 262
101501>>>        Set Label to "&Add..."
101502>>>        Set peAnchors to anBottomRight
101503>>>        Set MultiLineState to True
101504>>>        Set psToolTip to "Add a new connection. (Ctrl+A)"
101505>>>        Set psImage to "ActionNew.ico"
101506>>>
101506>>>        Procedure OnClick
101509>>>            Boolean bChanged bDFConnId
101509>>>            tSQLConnection SQLConnection
101509>>>            tSQLConnection SQLConnection
101509>>>            tDataSourceRow[] TheData
101509>>>            tDataSourceRow[] TheData
101510>>>            tDataSourceRow   TheRow
101510>>>            tDataSourceRow   TheRow
101510>>>            Handle hoDataSource
101510>>>
101510>>>            Send ChangeStatusRowText ""
101511>>>            Get IsDFConnId to bDFConnId
101512>>>
101512>>>            Get phoDataSource of oSQLConnections_grd to hoDataSource
101513>>>            Get DataSource of hoDataSource to TheData
101514>>>            Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
101515>>>            If (bChanged = True) Begin
101517>>>                Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
101518>>>                Send AddConnection of oSQLConnections_grd TheRow
101519>>>            End
101519>>>>
101519>>>        End_Procedure
101520>>>
101520>>>    End_Object
101521>>>
101521>>>    Object oEdit_btn is a cSQLConnectionButton
101523>>>        Set Size to 14 50
101524>>>        Set Location to 128 317
101525>>>        Set Label to "&Edit..."
101526>>>        Set peAnchors to anBottomRight
101527>>>        Set MultiLineState to True
101528>>>        Set psToolTip to "Edit the selected connection. (Ctrl+E)"
101529>>>
101529>>>        Procedure OnClick
101532>>>            Boolean bEnabled bChanged bDFConnId
101532>>>            tSQLConnection SQLConnection
101532>>>            tSQLConnection SQLConnection
101532>>>            tDataSourceRow TheRow
101532>>>            tDataSourceRow TheRow
101532>>>            tDataSourceRow[] TheData
101532>>>            tDataSourceRow[] TheData
101533>>>            Handle hoDataSource
101533>>>            Integer iCurrentRow
101533>>>
101533>>>            Get CurrentRowData of oSQLConnections_grd to TheRow
101534>>>            Get MoveGridRowToSQLConnection of oSQLConnections_grd TheRow to SQLConnection
101535>>>            Send ChangeStatusRowText ""
101536>>>            Get pbEnabled to bEnabled
101537>>>            Get IsDFConnId to bDFConnId
101538>>>
101538>>>            Get phoDataSource of oSQLConnections_grd to hoDataSource
101539>>>            Get DataSource of hoDataSource to TheData
101540>>>            Get CurrentRow of oSQLConnections_grd to iCurrentRow
101541>>>
101541>>>            Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) iCurrentRow (&SQLConnection) (&bChanged) bDFConnId TheData
101542>>>            If (bChanged = True) Begin
101544>>>                Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
101545>>>                Send UpdateConnection of oSQLConnections_grd TheRow
101546>>>            End
101546>>>>
101546>>>        End_Procedure
101547>>>
101547>>>    End_Object
101548>>>
101548>>>    Object oDelete_btn is a cSQLConnectionButton
101550>>>        Set Size to 14 50
101551>>>        Set Location to 128 371
101552>>>        Set Label to "&Delete"
101553>>>        Set peAnchors to anBottomRight
101554>>>        Set MultiLineState to True
101555>>>        Set psToolTip to "Remove the selected connection. (Ctrl+D) or (Del)"
101556>>>
101556>>>        Procedure OnClick
101559>>>            Send ChangeStatusRowText ""
101560>>>            Send RemoveCurrentConnection of oSQLConnections_grd
101561>>>        End_Procedure
101562>>>
101562>>>    End_Object
101563>>>
101563>>>    Object oSave_btn is a cSQLConnectionButton
101565>>>        Set Size to 14 50
101566>>>        Set Location to 128 425
101567>>>        Set Label to "&Save"
101568>>>        Set peAnchors to anBottomRight
101569>>>        Set MultiLineState to True
101570>>>        Set psToolTip to ("Save changes to the" * CS_SQLIniFileName * "file. Note: As long as you haven't saved - you are only making changes to the grid. (Ctrl+S) or (F2)")
101571>>>
101571>>>        Procedure OnClick
101574>>>            Send ChangeStatusRowText ""
101575>>>            Send WriteIniFile of oSQLConnections_grd
101576>>>        End_Procedure
101577>>>
101577>>>    End_Object
101578>>>
101578>>>    Object oAbout_btn is a cSQLConnectionButton
101580>>>        Set Location to 128 19
101581>>>        Set Label to "About..."
101582>>>        Set peAnchors to anBottomLeft
101583>>>        Set psToolTip to "Info about the program..."
101584>>>
101584>>>        Procedure OnClick
101587>>>            Send ChangeStatusRowText ""
101588>>>            Send Activate_About of (Client_Id(phoMainPanel(ghoApplication)))
101589>>>        End_Procedure
101590>>>
101590>>>    End_Object
101591>>>
101591>>>    Object oAddToStudio_btn is a cSQLConnectionButton
101593>>>        Set Size to 14 72
101594>>>        Set Location to 128 74
101595>>>        Set Label to "Add to Studio..."
101596>>>        Set peAnchors to anBottomLeft
101597>>>        Set psToolTip to "Dialog that adds this program to the Studio's 'Tools' menu."
101598>>>        Set psImage to "ActionAddRecord.ico"
101599>>>
101599>>>        Procedure OnClick
101602>>>            Send ChangeStatusRowText ""
101603>>>            Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
101604>>>        End_Procedure
101605>>>
101605>>>    End_Object
101606>>>
101606>>>    Object oRefresh_btn is a cSQLConnectionButton
101608>>>        Set Location to 128 150
101609>>>        Set Label to "&Refresh"
101610>>>        Set peAnchors to anBottomLeft
101611>>>        Set psToolTip to ("Reloads the ini-file (Ctrl+R) or (F5)")
101612>>>
101612>>>        Procedure OnClick
101615>>>            Boolean bChanged
101615>>>            Handle ho
101615>>>            Integer iRetval
101615>>>
101615>>>            Move (oSQLConnections_grd(Self)) to ho
101616>>>            Get Should_Save of ho to bChanged
101617>>>            If (bChanged = True) Begin
101619>>>                Get YesNo_Box "Changes exists! If you press 'Yes' changes will be lost." to iRetval
101620>>>                If (iRetval <> MBR_Yes) Begin
101622>>>                    Procedure_Return
101623>>>                End
101623>>>>
101623>>>            End
101623>>>>
101623>>>            Send ChangeStatusRowText ""
101624>>>            Send LoadData of oSQLConnections_grd
101625>>>        End_Procedure
101626>>>
101626>>>    End_Object
101627>>>
101627>>>    Object oOpen_btn is a cSQLConnectionButton
101629>>>        Set Location to 128 204
101630>>>        Set Label to "&Open"
101631>>>        Set peAnchors to anBottomLeft
101632>>>        Set psToolTip to ("Opens an ini-file (Ctrl+O)")
101633>>>
101633>>>        Procedure OnClick
101636>>>            Send ChangeStatusRowText ""
101637>>>            Send OnHeaderClick of oSQLConnections_grd 1
101638>>>        End_Procedure
101639>>>
101639>>>    End_Object
101640>>>
101640>>>    Object oIdle is a cIdleHandler
101642>>>        Procedure OnIdle
101645>>>          Delegate Send OnIdle
101647>>>        End_Procedure
101648>>>    End_Object
101649>>>
101649>>>    Function IsDFConnId Returns Boolean
101652>>>        Boolean bDFConnId
101652>>>        Handle ho
101652>>>        String sFileName
101652>>>
101652>>>        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
101653>>>        Get psIniFileName of ho to sFileName
101654>>>        Move (Uppercase(sFileName) = Uppercase(CS_SQLDF19IniFileName)) to bDFConnId
101655>>>        Set pbDFConnId of ho to bDFConnId
101656>>>
101656>>>        Function_Return bDFConnId
101657>>>    End_Function
101658>>>
101658>>>    Procedure OnFileDropped String sFilename Boolean bLast
101661>>>        Boolean bHasChange
101661>>>        Handle ho hoGrid
101661>>>        Integer iRetval
101661>>>        String sPath
101661>>>
101661>>>        Forward Send OnFileDropped sFilename bLast
101663>>>
101663>>>        If (bLast = True) Begin
101665>>>            Move (oSQLConnections_grd(Self)) to hoGrid
101666>>>            Get ParseFolderName sFilename to sPath
101667>>>            Get ParseFileName   sFilename to sFilename
101668>>>            If (Uppercase(sFilename) <> Uppercase(CS_SQLIniFileName) and Uppercase(sFilename) <> Uppercase(CS_SQLDF19IniFileName)) Begin
101670>>>                Send Info_Box ("Sorry, only" * CS_SQLIniFileName * "files can be dropped!")
101671>>>                Procedure_Return
101672>>>            End
101672>>>>
101672>>>            Get Should_Save of hoGrid to bHasChange
101673>>>            If (bHasChange = True) Begin
101675>>>                Get YesNo_Box "Changes exist! Do you still want to load the new file?" to iRetval
101676>>>                If (iRetval <> MBR_Yes) Begin
101678>>>                    Procedure_Return
101679>>>                End
101679>>>>
101679>>>            End
101679>>>>
101679>>>            Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to ho
101680>>>            Set psIniFilePath of ho to sPath
101681>>>            Set psIniFileName of ho to sFilename
101682>>>            Send LoadData of oSQLConnections_grd
101683>>>        End
101683>>>>
101683>>>    End_Procedure
101684>>>
101684>>>    // This is only being called where no SQLConnections.ini file exists;
101684>>>    // thus a new active/enabled DFConnection ID needs to be established.
101684>>>    Procedure ConnectionDoesNotExist
101687>>>        tSQLConnection SQLConnection
101687>>>        tSQLConnection SQLConnection
101687>>>        Boolean bChanged bDFConnId bEnabled
101687>>>        Handle ho
101687>>>        tDataSourceRow TheRow
101687>>>        tDataSourceRow TheRow
101687>>>        Handle hoDataSource
101687>>>        tDataSourceRow[] TheData
101687>>>        tDataSourceRow[] TheData
101688>>>
101688>>>        Get IsDFConnId to bDFConnId
101689>>>
101689>>>        Move (oSQLMaintainConnections_dg(Self)) to ho
101690>>>        Move True to bEnabled
101691>>>        Set pbNew to True
101692>>>        Set pbNew of ho to True
101693>>>
101693>>>        Get phoDataSource of oSQLConnections_grd to hoDataSource
101694>>>        Get DataSource of hoDataSource to TheData
101695>>>
101695>>>        Send Activate_SQLMaintainConnections_dg of (Client_Id(phoMainPanel(ghoApplication))) (pbNew(Self)) -1 (&SQLConnection) (&bChanged) bDFConnId TheData
101696>>>        If (bChanged = True) Begin
101698>>>            // We also need to tell the main connection object that we now have
101698>>>            // created a connection.
101698>>>            Set pSQLConnection            of ghoSQLConnectionHandler to SQLConnection
101699>>>//            Set psConnectionID            of ghoSQLConnectionHandler to SQLConnection.sConnectionID
101699>>>//            Send UpdateConnectionString   of ghoSQLConnectionHandler SQLConnection
101699>>>//            Set psConnectionString        of ghoSQLConnectionHandler to SQLConnection.sConnectionString
101699>>>            // And add the data to the grid.
101699>>>            Get MoveSQLConnectionToGridRow of oSQLConnections_grd SQLConnection to TheRow
101700>>>            Send AddConnection of oSQLConnections_grd TheRow
101701>>>            // Not new anymore.
101701>>>            Set pbNew to False
101702>>>            Set pbNew of ho to False
101703>>>        End
101703>>>>
101703>>>    End_Procedure
101704>>>
101704>>>    Procedure ChangeStatusRowText String sText
101707>>>        Handle[] hoPanels
101708>>>        Get PaneObjects of (phoStatusBar(ghoCommandBars)) to hoPanels
101709>>>        Set psText of hoPanels[1] to sText
101710>>>    End_Procedure
101711>>>
101711>>>    Function IniFileName Returns String
101714>>>        String sRetval
101714>>>        Get InfileName of oSQLConnections_grd to sRetval
101715>>>        Function_Return sRetval
101716>>>    End_Function
101717>>>
101717>>>    Procedure ActivateOpenDialog
101720>>>        Send OnHeaderClick of oSQLConnections_grd 1
101721>>>    End_Procedure
101722>>>
101722>>>    Procedure Activating
101725>>>        Handle ho
101725>>>
101725>>>        Set Maximize_Icon to True
101726>>>        Set Minimize_Icon to False
101727>>>        Set Border_Style to Border_Thick
101728>>>        Set View_Mode to Viewmode_Zoom
101729>>>
101729>>>        // Note: The following line is essential for the resizing logic
101729>>>        // to work when starting the program.
101729>>>        Move (Client_Id(ghoCommandBars)) to ho
101730>>>        Set Border_Style of ho to Border_ClientEdge
101731>>>
101731>>>        Set pbEnabled of oIdle to True
101732>>>    End_Procedure
101733>>>
101733>>>    Procedure Deactivating
101736>>>        Set pbEnabled of oIdle to False
101737>>>        Forward Send Deactivating
101739>>>    End_Procedure
101740>>>
101740>>>    Procedure OnIdle
101743>>>        Boolean bChanged bRecord
101743>>>        Handle ho
101743>>>
101743>>>        Move (oSQLConnections_grd(Self)) to ho
101744>>>        Send ChangeHeaderText of ho
101745>>>        Get Should_Save   of ho to bChanged
101746>>>        Get HasRecord     of ho to bRecord
101747>>>        Set Enabled_State of oSave_btn   to bChanged
101748>>>        Set Enabled_State of oEdit_btn   to bRecord
101749>>>        Set Enabled_State of oDelete_btn to bRecord
101750>>>
101750>>>    End_Procedure
101751>>>
101751>>>    Function Verify_Exit_Application Returns Integer
101754>>>        Integer iRetval
101754>>>        Boolean bChanged
101754>>>
101754>>>        Get Should_Save of oSQLConnections_grd to bChanged
101755>>>        If (bChanged = False) Begin
101757>>>            Function_Return False
101758>>>        End
101758>>>>
101758>>>        Else Begin
101759>>>            Get YesNoCancel_Box "Changes exists. Save changes first?" to iRetval
101760>>>            If (iRetval = MBR_Cancel) Begin
101762>>>                Function_Return True
101763>>>            End
101763>>>>
101763>>>            If (iRetval = MBR_Yes) Begin
101765>>>                Send KeyAction of oSave_btn
101766>>>                Send Exit_Application
101767>>>            End
101767>>>>
101767>>>            If (iRetval = MBR_No) Begin
101769>>>                Function_Return False
101770>>>            End
101770>>>>
101770>>>        End
101770>>>>
101770>>>        Function_Return True
101771>>>    End_Function
101772>>>
101772>>>    On_Key kDelete_Character Send KeyAction of oDelete_btn
101773>>>    On_Key Key_F5            Send KeyAction of oRefresh_btn
101774>>>    On_Key Key_Ctrl+Key_E    Send KeyAction of oEdit_btn
101775>>>    On_Key Key_Ctrl+Key_A    Send KeyAction of oAdd_btn
101776>>>    On_Key Key_Ctrl+Key_D    Send KeyAction of oDelete_btn
101777>>>    On_Key Key_Ctrl+Key_R    Send KeyAction of oRefresh_btn
101778>>>    On_Key Key_F5            Send KeyAction of oRefresh_btn
101779>>>    On_Key kSave_Record      Send KeyAction of oSave_btn
101780>>>    On_Key Key_Ctrl+Key_S    Send KeyAction of oSave_btn
101781>>>    On_Key Key_F2            Send KeyAction of oSave_btn
101782>>>    On_Key Key_Ctrl+Key_O    Send ActivateOpenDialog
101783>>>    On_Key kCancel           Send None
101784>>>    On_Key Key_Ctrl+Key_F4   Send None
101785>>>End_Object
101786>        Use ManageSQLConnections.dg
101786>        Use AddToStudio.dg
101786>
101786>        Procedure Activate_About
101789>            Send DoAbout "" "" ("Copyright 2016-2017" * psCompany(ghoApplication)) "Author: Nils G. Svedmyr" "SQLConnections.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com"
101790>        End_Procedure
101791>
101791>    End_Object
101792>
101792>    Procedure ShowProgramHelp
101795>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
101796>    End_Procedure
101797>
101797>    On_Key Key_F1 Send ShowProgramHelp
101798>End_Object
101799>
101799>// Check if a SQLConnections.ini file exists;
101799>// else the user needs to setup a Connection ID and login info & save the new connection file.
101799>Procedure CheckIfConnectionExists
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
101801>    Boolean bIniFileExists
101801>    Get pbIniFileExists of ghoApplication to bIniFileExists
101802>    If (bIniFileExists = False) Begin
101804>        Send ConnectionDoesNotExist of (oSQLMaintainConnection(Client_Id(phoMainPanel(ghoApplication))))
101805>    End
101805>End_Procedure
101806>Send CheckIfConnectionExists
101807>
101807>Start_UI
101808>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 54275
Total Resources: 3
Total Commands : 101807
Total Windows  : 1
Total Pages    : 1
Static Data    : 738537
Message area   : 640888
Total Blocks   : 36021
