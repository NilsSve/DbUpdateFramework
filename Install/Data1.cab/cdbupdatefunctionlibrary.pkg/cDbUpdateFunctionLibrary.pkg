//****************************************************************************
// $Module type: Class
// $Module name: cDbUpdateFunctionLibrary
// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
// Web-site    : http://www.rdctools.com
// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
//
// Description : The class consists of a function library for database manipulations, aka make changes to a database.
//               It has top level functions that uses the DataFlex db API, _but_ also specialized
//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
//               with the help of Sql-scripts.
//
// $Rev History:
//    2014-09-05  Module header created
//
//****************************************************************************
Use cApplication.pkg
Use seq_chnl.pkg
Use GlobalFunctionsProcedures.pkg
Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
Use DUFStatusPanel.pkg
Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Use cSQLConnectionHandler.pkg
Use vWin32fh.pkg

//
Class cDbUpdateFunctionLibrary is a cObject
    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
    #Include ParseKeyWord.pkg

    Procedure Construct_Object
        Handle ho
        Forward Send Construct_Object

        Move Self to ghoDbUpdateFunctionLibrary

        Send CreateDbUpdateLibraryProperties
        // If no ghoSQLConnectionHandler object has been created prior to this object,
        // we will create one as it is used for all ConnectionID, ConnectionString
        // etc settings.
        If (ghoSQLConnectionHandler = 0) Begin
            Get Create (RefClass(cSQLConnectionHandler)) to ho
            Set phoSQLConnectionHandler to ho
        End

    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
    End_Procedure

    // *** SQL Messages for making changes to the SQL back-end ***
    //

    // Function for creating a new *Database*.
    // Note: This is for creating SQL DATABASES - not tables!
    // Returns True if successful.
    // ToDo: Only works for MS-SQL...
    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
        String sSQL sSQL1 sConnectionID sConnectionString sCreateDatabaseKeyWord sSelectFromWhereName
        Handle hConnection hStmt hoSQLManager
        Integer iFetchResult iDbType
        Boolean bOK bMertechDriver

        Get piDbType to iDbType
        If (iDbType <> EN_DbTypeMSSQL) Begin
            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
            Function_Return False
        End

        Get IsMertechDriver sDriverID to bMertechDriver
        If (bMertechDriver = False) Begin
            Get phoSQLManager to hoSQLManager
        End
        Else Begin
            Get _MertechSQLManagerHandle to hoSQLManager
        End

        Get psConnectionID     to sConnectionID
        Get psConnectionString to sConnectionString
        Move 0 to LastErr

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
            Function_Return False
        End

        Get SqlOpen of hConnection to hStmt

        If (hStmt = 0) Begin
            Send SqlDisconnect of hoSQLManager
            Error DFERR_PROGRAM CS_SQLConnectError
            Function_Return False
        End

        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
        Get _SqlSelectFromWhereName to sSelectFromWhereName
        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL

        // Check if database exists
        Send SqlExecDirect of hStmt sSQL
        Get SqlFetch of hStmt to iFetchResult
        Send SqlClose of hStmt
        Send SqlDisconnect of hConnection

        // If database already exists we're out of here!
        // Note that we return True as this is not an error.
        If (iFetchResult > 0) Begin
            Function_Return True
        End

        // Database doesn't exist, create it.
        If (iFetchResult = 0) Begin
            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR

            Send SqlUtilExecuteQuery sSQL1 sDriverID

            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            If (LastErr = CLIERR_GENERAL_ERROR) Begin
               Function_Return False
            End

            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
            Sleep 1
            Send SqlUtilExecuteQuery sSQL sDriverID
        End

        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
        // the one we just created.
        If (bUpdateConnectionString = True) Begin
            Set psDatabase to sDatabase
            //...and perhaps also the SQLConnections.ini file setting.
            If (bPermanantly = True) Begin
                If (ghoSQLConnectionHandler <> 0) Begin
                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
                End
            End
        End

        Function_Return (Err = False)
    End_Function

    // Converts from SQL to Embedded (DataFlex .dat files).
    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
        Handle hToTable
        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bCopyData
        String sDriverID sPhysicalName sRootName sDisplayName sEmpty sConnectionID sConnectionString
        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase
        tSQLConnection SQLConnection
        Integer iPos iMaxRecords

        Get psDriverID to sDriverID
        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        If (num_arguments > 1) Begin
            Move bCpyDat to bCopyData
        End
        Else Begin
            Move False to bCopyData
        End

        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
            Function_Return False
        End
        Move 0 to hToTable

        Move 16711679 to iMaxRecords
        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
        Move (Pos(".", sDisplayName)) to iPos
        If (iPos > 0) Begin
            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
        End
        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
        Get _TableNameOnly sRootName                 to sRootName
        Move (sRootName + ".dat")                    to sPhysicalName

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
        End

        Move False to Err

        Structure_Start hToTable DATAFLEX_ID
            Structure_Copy hTable to hToTable

            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords

        Structure_End hToTable

        Move (not(Err)) to bOK
        If (bOK = True and bCopyData = True) Begin
            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
        End

        Get IsMertechDriver sDriverID to bMertechDriver
        If (bMertechDriver = True) Begin
            Open hTable
        End

        // This must be after copying data...
        If (Err = False) Begin
            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
        End
        Move (not(Err)) to bOK

        Function_Return (bOK = True)
    End_Function

    // Creates an SQL Table at the SQL end by its filelist number;
    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
    Function SqlTableCreate Integer hTable Returns Boolean
        String sTableName sSQLString sPath sVal sCreateTable sDriverID
        Integer iRetval iDbType
        Boolean bExists bOK

        Get psDriverID to sDriverID
        Get UtilTableHandleToString hTable to sTableName
        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        Get psDataPathFirstPart to sPath
        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists

        Get piDbType to iDbType
        Get _SqlProperTableName sTableName to sTableName
        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID

        Function_Return (Err = False)
    End_Function

    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
    Function SqlTableCreateByTableName String sTableName  Returns Boolean
        String sSQLString sPath sVal sCreateTable sDriverID
        Integer iRetval iDbType
        Boolean bExists bOK

        Get psDriverID to sDriverID
        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        Get psDataPathFirstPart to sPath
        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
        If (bExists = True) Begin
            // ToDo: What should we do if an .int file already exists?
        End

        Get piDbType to iDbType
        Get _SqlProperTableName sTableName to sTableName
        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID

        Function_Return (Err = False)
    End_Function

    // First deletes the data cache file and then drops the passed SQL table.
    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
    //       else try using the SqlTableRemoveByTableName message.
    Function SqlTableRemove Integer hTable Returns Boolean
        String sSQLString sPath sDropTable sTableName sDriverID
        Integer iRetval iDbType
        Boolean bExists bMertechDriver bOK

        Get psDriverID to sDriverID
        Get IsMertechDriver sDriverID to bMertechDriver
        Get UtilTableHandleToString hTable to sTableName
        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        Get psDataPathFirstPart to sPath
        Get UtilDeleteCacheFile sTableName to iRetval

        Get piDbType to iDbType
        Get _SqlProperTableName sTableName to sTableName
        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
        Move (sDropTable * String(sTableName)) to sSQLString

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID

        // We also need to remove the cache-file since the table has been changed
        Get UtilDeleteCacheFile sTableName to bOK

        Function_Return (Err = False)
    End_Function

    // First deletes the data cache file and then drops the passed data table.
    Function SqlTableRemoveByTableName String sTableName Returns Boolean
        String sSQLString sPath sDropTable sVal sSchema sDriverID
        Integer iRetval iDbType
        Boolean bMertechDriver bOK

        Get psDriverID to sDriverID
        Get IsMertechDriver sDriverID to bMertechDriver
        Get psDataPathFirstPart to sPath
        Get UtilDeleteCacheFile sTableName to iRetval

        Get piDbType to iDbType
        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
        Get psSchema to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End
        Move (Uppercase(sTableName)) to sVal
        If (not(sVal contains (sSchema + "."))) Begin
            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
        End
        Move (sDropTable * String(sTableName)) to sSQLString

        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID

        // We also need to remove the cache-file since the table has been changed
        Get UtilDeleteCacheFile sTableName to bOK

        Function_Return (Err = False)
    End_Function

    // *** Sql View Messages ***

    // First deletes the data cache file and then drops the passed Sql data view.
    Function SqlViewRemove String sDataView Returns Boolean
        String sDriverID sSQLString sPath sDropViewKeyWord
        Integer iRetval
        Boolean bMertechDriver bOK

        Get psDriverID to sDriverID
        Get IsMertechDriver sDriverID to bMertechDriver
        Get UtilDeleteCacheFile sDataView to iRetval

        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
        Set psSQLStatementString to sSQLString

        // As we don't check if the view exist or not, it might happen
        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
        Move False to Err
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send SqlUtilExecuteQuery sSQLString sDriverID
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Move 0 to LastErr

        // We also need to remove the cache-file since the table has been changed
        Get UtilDeleteCacheFile sDataView to bOK

        Function_Return (Err = False)
    End_Function

    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
        Boolean bOK
        Integer iDbType 
        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
        
        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        
        Case Begin
            Case (iDbType = EN_DbTypeDB2)
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
            Break

            Case (iDbType = EN_DbTypeMSSQL)
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
            Break

            Case (iDbType = EN_DbTypeOracle)
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
            Break

            Case (iDbType = EN_DbTypePostgre)
                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
            Break

            Case (iDbType = EN_DbTypeMySQL)
                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
            Break
        Case End   
        
        Move False to Err
        Send SqlUtilExecuteQuery sSQLString sDriverID
        Move (Err = False) to bOK
        
        Function_Return bOK
    End_Function
    
     // *** Sql Column Messages ***
    //
    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
        Integer iColumn iDbType iLength iDecimals
        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
        String sTableName sDriverID sUpdate sSet sNoCountOn
        Boolean bExists bOK bInitializeValue

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableHandleToString hTable to sTableName
        If (sTableName = "") Begin
            Function_Return False
        End

        If (num_arguments > 3) Begin
            Move iLen     to iLength
            Move iDec     to iDecimals
            Move bInitVal to bInitializeValue
            Move sColVal  to sColumnValue
        End

        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK

        Function_Return (bOK = True)
    End_Function

    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
        Integer iColumn iDbType iLength iDecimals iDriver
        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
        String sDriverID sUpdate sSet sNoCountOn sNotNull
        Boolean bExists bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
        Handle hTable

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableNameToHandle sTableName to hTable
        If (hTable = 0) Begin
            Get NextFreeFilelistSlot to hTable
        End 

        Get piDbType to iDbType
        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
        Get _SqlFindColumnName sTableName sColumnName to sVal
        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
            Function_Return False
        End

        Get DriverIndex sDriverID to iDriver
        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True

        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
        If (num_arguments > 3) Begin
            Move iLen     to iLength
            Move iDec     to iDecimals
            Move bInitVal to bInitializeValue
            Move sColVal  to sColumnValue
        End

        Get _SqlProperTableName sTableName   to sTableName
        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull

        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
        If (bFixed = False) Begin
            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
        End
        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt

        Move False to Err
        Send SqlUtilExecuteQuery sStmt sDriverID

        If (bInitializeValue = True and Err = False) Begin
            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
        End

        If (Err = False) Begin
            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
        End

        Move (not(Err)) to bRetval

        // We also need to remove the cache-file since the table has been changed
        Get UtilDeleteCacheFile sTableName to bOK
        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState

        Function_Return bRetval
    End_Function
    
    // To update all current rows for a table column with a common value.
    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
        Boolean bRetval bSQLDriver 
        Integer iCurrErr
        
        Move False to bRetval
        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver = False) Begin
            Function_Return bRetval
        End
        Get UtilTableHandleToString hTable to sTableName
        
        Move Err to iCurrErr
        Move False to Err
        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
        Get _SqlFindKeyWord CI_SQLSet          to sSet
        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
        Send SqlUtilExecuteQuery sStmt sDriverID
        Move (Err = False) to bRetval
        Move iCurrErr to Err
        
        Function_Return bRetval
    End_Function

    // The fourth & fifth arguments are optional, depending on the iDataType
    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
        Integer iColumn iDbType iLength iDecimals
        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sTableName sNotNull
        Boolean bExists bOK bFixed

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableHandleToString hTable to sTableName
        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK

        Function_Return (Err = False)
    End_Function

    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
    // The fourth & fifth arguments are optional, depending on the iDataType
    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
        Integer iColumn iDbType iLength iDecimals
        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sNotNull
        Boolean bExists bOK bFixed
        Handle hTable

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableNameToHandle sTableName to hTable
        If (hTable = 0) Begin
            Get NextFreeFilelistSlot to hTable
        End
        Get SQLUtilColumnExists sTableName sColumnName to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        If (num_arguments > 3) Begin
            Move iLen to iLength
        End
        If (num_arguments > 4) Begin
            Move iDec to iDecimals
        End

        Get piDbType to iDbType
        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType

        Move False to Err
        Get _SqlProperTableName sTableName    to sTableName
        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull

        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
        If (bFixed = False) Begin
            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
        End

        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
        Send SqlUtilExecuteQuery sStmt sDriverID

        // We also need to remove the cache-file since the table has been changed
        Get UtilDeleteCacheFile sTableName to bOK

        Function_Return (Err = False)
    End_Function

    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
        Boolean bOK bErr bIsSQLDriver
        String sDriverID

        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bIsSQLDriver
        If (bIsSQLDriver = False) Begin
            Function_Return False
        End

        Move Err to bErr
        Move False to bErr

        // There seems to be a problem with the ODBC_DRV driver that sometimes
        // inserts randomly character(10) and spaces, so we correct from that here:
        Move (Replaces(Character(10), Trim(sValue), "")) to sValue

        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
        Move (not(Err)) to bOK
        Move bErr to Err

        Function_Return bOK
    End_Function

    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
        String sDriverID

        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bIsSQLDriver
        If (bIsSQLDriver = False) Begin
            Function_Return False
        End

        Move Err to bErr
        Move False to bErr
        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
        If (bNullable = bCurrentState) Begin
            Function_Return True
        End

        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Get AutoConnectionIDLogin to bOK
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            Open hTable
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
        End
        If (bOpen = True) Begin
            Structure_Start hTable sDriverID
                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
            Structure_End hTable
        End

        Move (not(Err)) to bOK
        Move bErr to Err

        Function_Return bOK
    End_Function

    // Drop column by its table handle
    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
        Integer iColumn idbType
        String sDriverID sStmt sAlterTable sDropColumn sVal sTableName
        Boolean bExists bOK

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableHandleToString hTable to sTableName
        If (sTableName = "") Begin
            Function_Return False
        End

        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK

        Function_Return (bOK = True)
    End_Function

    // Drop column by its table name as a string.
    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
        Integer iColumn iDbType iDriver
        String sDriverID sStmt sAlterTable sDropColumn sVal
        Boolean bExists bOK bRetval bDriverIgnoreErrorState
        Handle hTable

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get DriverIndex sDriverID to iDriver
        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True

        Get UtilTableNameToHandle sTableName to hTable
        If (hTable <> 0) Begin
            Get SQLUtilColumnExists sTableName sColumnName to bExists
            If (bExists = False) Begin
                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
                Function_Return False
            End
        End

        Get piDbType to iDbType
        If (iDbType = EN_DbTypeMSSQL) Begin
            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
            Get UtilDeleteCacheFile sTableName to bOK
            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
            Function_Return bOK
        End

        Move False to Err
        Get _SqlProperTableName sTableName    to sTableName
        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn

        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
        Send SqlUtilExecuteQuery sStmt sDriverID
        Move (not(Err)) to bRetval

        // We also need to remove the cache-file since the table has been changed
        Get UtilDeleteCacheFile sTableName to bOK
        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState

        Function_Return bRetval
    End_Function

    // Rename a field/column by table handle (filelist number)
    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
        Integer iColumn idbType
        String sDriverID sTableName sStmt sAlterTable sRenameColumn sVal sColumnKeyWord
        Boolean bExists bOK

        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get UtilTableHandleToString hTable to sTableName
        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK

        Function_Return (Err = False)
    End_Function

    // Rename a field/column by table name.
    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
        Integer iColumn iDbType iDataType
        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
        Boolean bExists bOK bRetval
        Handle hTable

        Move sTableName to sOrgTableName
        Get psDriverID to sDriverID
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Get _SqlFindColumnName sTableName sColumnName to sVal
        If (sVal = "") Begin
            Function_Return False
        End

        Get piDbType to iDbType
        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
        Get _SqlProperTableName sTableName     to sTableName
        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn

        Case Begin
            Case (iDbType = EN_dbTypeMSSQL)
                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
                Case Break
            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
            Case (iDbType = EN_dbTypeOracle)
                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
                Case Break
            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
            Case (iDbType = EN_dbTypeDB2)
                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
                Case Break
            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
            Case (iDbType = EN_dbTypePostgre)
                Move sOrgTableName to sTableName
                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
                Case Break
            Case (iDbType = EN_dbTypeMySQL)
                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
                Move sOrgTableName to sTableName
                Get psDatabase to sDatabase
                Get UtilTableNameToHandle sTableName to hTable
                If (hTable = 0) Begin
                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                    Get NextFreeFilelistSlot to hTable
                End
                Else Begin
                    Open hTable
                End
                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
                Case Break
            Case Else
                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
        Case End

        Move False to Err
        Send SqlUtilExecuteQuery sStmt sDriverID
        Move (Err = False) to bRetval
        // We also need to remove the cache-file since the table has been changed
        Get UtilDeleteCacheFile sTableName to bOK

        Function_Return bRetval
    End_Function

    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
        Handle hoSQLHandler hSQLConnect hStmt
        Boolean bMertechDriver
        Integer iNumCols iCount iSQLType iDataType
        String sValue

        Get IsMertechDriver sDriverID to bMertechDriver
        If (bMertechDriver = False) Begin
            Get phoSQLManager to hoSQLHandler
        End
        Else Begin
            Get _MertechSQLManagerHandle to hoSQLHandler
        End

        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
        If (hSQLConnect <> 0) Begin
            Get SQLOpen of hSQLConnect to hStmt
            If (hStmt <> 0) Begin
                Send SQLExecDirect of hStmt ("select * from" * sTableName)

                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
                For iCount from 1 to iNumCols
                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
                        Move iNumCols to iCount // We're out of here
                    End
                Loop

                Send SQLClose of hStmt
            End
            Send SQLDisconnect of hSQLConnect
        End

        Function_Return iDataType
    End_Function


    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
    // the DbUpdateVersion database revision in.
    // Also pass the file number of the current (embedded?) table number used in development.
    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
    Function SqlCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
        Boolean bOK bOpened
        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt sDropColumn

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
        Get _TableNameOnly sTableName to sTableName
        If (sTableName = "") Begin
            Function_Return False
        End

        // This just creates the table and a "dummy" column.
        Get SqlTableCreate hTable sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Close hTable
        Move False to Err

        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
        Move "Decimal" to sDataType
        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals

        // Adds the "sColumnName" passed to the function
        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
        Send SqlUtilExecuteQuery sStmt sDriverID

        // Now we can delete the dummy column:
        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK

        // Finally, we attach to the newly created table.
        If (Err = False) Begin
            Get ApiTableAttachToSQL hTable True to bOK
        End
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bOpened

        Function_Return (Err = False and bOK = True and bOpened = True)
    End_Function

    // Checks if a column/field name exists in a SQL table definition
    // Returns True if it does
    // Sample:
    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
        Integer iNumColumns iColumn
        String sColumn sDriverID
        String[] sColumnsArray
        Boolean bExists bOK

        Move False to bExists
        Get AutoConnectionIDLogin to bOK
        Get psDriverID to sDriverID

        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
        Move (SizeOfArray(sColumnsArray)) to iNumColumns
        Decrement iNumColumns
        For iColumn from 0 to iNumColumns
            Move sColumnsArray[iColumn] to sColumn
            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
                Move True to bExists
                Move iNumColumns to iColumn // We're out of here
            End
        Loop

        Function_Return bExists
    End_Function

    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
        Integer iNumColumns iColumn iDFType iNativeType
        Boolean bOpened bOK
        String sColumnName sNativeTypeName

        Get AutoConnectionIDLogin to bOK
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
            Function_Return False
        End

        Move False to Err

        Structure_Start hTable
            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns

            For iColumn from 1 to iNumColumns
                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName

                Case Begin
                    Case (iDFType = DF_DATE)
                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
                            // Convert datetime to date
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
                        End
                        Case Break
                    Case (iDFType = DF_DATETIME)
                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
                            // Convert datetime to datetime2
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
                        End
                        Case Break
                    Case (iDFType = DF_ASCII)
                        If (iNativeType = SQL_CHAR) Begin
                            // Convert char to varchar
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
                        End
                        Case Break
                    Case (iDFType = DF_TEXT)
                        If (iNativeType = SQL_LONGVARCHAR) Begin
                            // Convert text to varchar(max)
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
                        End
                        Case Break
                    Case (iDFType = DF_BINARY)
                        If (iNativeType = SQL_LONGVARBINARY) Begin
                            // Convert image to varbinary(max)
                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
                        End
                        Case Break
                Case End
            Loop
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    // Does three things with auxilirary files;
    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
        String sDataPath sDDSrcPath sVal sDriverID
        Boolean bOK bExists bMertechDriver
        Integer iCount iItems iCh iPos

        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
        If (sTableName contains ".") Begin
            Move (Pos(".", sTableName)) to iPos
            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
        End

        Get psDriverID to sDriverID
        Get psDataPathFirstPart to sDataPath
        Get vFolderExists sDataPath to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
            Function_Return False
        End

        Get IsMertechDriver sDriverID to bMertechDriver
        // First delete the cache file:
        Get UtilDeleteCacheFile sTableName to bOK

        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Function_Return False
        End

        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        // Add the new column name to the .tag file:
        Append_Output channel iCh (sDataPath + sTableName + ".tag")
            Writeln channel iCh sColumnName
        Close_Output

        // If in development environment; output new .fd file:
        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
        If (iCount > 1) Begin
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
        End
        Get vFolderExists sDDSrcPath to bExists
        If (bExists = True) Begin
            Get vFolderFormat sDDSrcPath to sDDSrcPath
            Move False to Err
            Get AutoConnectionIDLogin to bOK
            If (hTable <> 0) Begin
                Open hTable
            End
            Else Begin
                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
            End

            Get_Attribute DF_FILE_OPENED of hTable to bOK
            If (bOK = True) Begin
                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
            End
            If (Err = True) Begin
                Move False to bOK
            End
        End

        Function_Return (bOK = True)
    End_Function

    // The table must already exist in the filelist for this function to work.
    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
        Boolean bOK bExists bUseConnectionID bMertech
        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
        String[] sIndexArray
        Integer iCount iCh iSize

        Move (Trim(sConnectionID) <> "") to bUseConnectionID
        Get psConnectionString to sConnectionString

        Move CS_ANSI_Txt to sANSI_OEM
        If (bANSI = False) Begin
            Move CS_OEM_Txt to sANSI_OEM
        End

        Get psDataPathFirstPart to sDataPath
        Get vFolderExists sDataPath to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
            Function_Return False
        End
        Get vFolderFormat sDataPath to sDataPath

        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get _TableNameOnly sRootName to sDatabaseName
        Move sLogicalName  to sPhysicalFileName
        Move (sPhysicalFileName + ".int") to sPhysicalFileName

        Get IsMertechDriver sDriverID to bMertech
        If (bMertech = True) Begin
            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
            // Else it will create an error in the error log (although it won't do anything...)
            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
            Function_Return (bOK = True)
        End

        Get psSchema hTable to sSchemaName
        If (sSchemaName = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
        End

        // If the .int file already exists; we rename it to "FileName" + ".bak"
        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
        If (bExists = True) Begin
            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
        End

        Get UtilDeleteCacheFile sRootName to bOK
        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray

        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
            If (bUseConnectionID = True) Begin
                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
            End
            Else Begin
                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
            End
            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
            // There seems to be a new order how these are set from DF19.
            If (bSysFile = True) Begin
                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
            End
            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
            If (bSysFile = True) Begin
                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
            End

            If (bSysFile = False) Begin
                Move (SizeOfArray(sIndexArray)) to iSize
                Move (SortArray(sIndexArray)) to sIndexArray
                If (iSize > 0) Begin
                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
                    Writeln channel iCh // Just an empty line
                End
                Decrement iSize
                For iCount from 0 to iSize
                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
                    Writeln channel iCh
                Loop
            End
        Send Seq_Close_Channel iCh

        // Wait a sec for Windows to finish writing the file:
        Sleep 1

        Function_Return (bOK = True)
    End_Function

    // Message for changing .int files to use connection ID's
    //
    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
    // OR changes an existing connection id to a new id.
    // Pass the full path to the data folder and the name of the connection id (string value).
    // Pass a True for the bShowResult parameter to show work in progress (showln's).
    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
        String sFileName sDriverID sDriverFile sConnectionString
        String[] sFilesData
        Boolean bExists bOK bCancel
        Integer iSize iCount

        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
        Move (SizeOfArray(sFilesData))    to iSize
        If (iSize = 0) Begin    
            If (ghoStatusPanel <> 0) Begin
                If (Active_State(ghoStatusPanel)) Begin
                    Send Stop_StatusPanel of ghoStatusPanel
                End
            End
            Send Info_Box "No .int files found! Nothing was changed."
            Procedure_Return
        End

        Move (Trim(sConnectionID)) to sConnectionID
        Get vFolderFormat sDataPath to sDataPath
        Decrement iSize
        For iCount from 0 to iSize
            Move sFilesData[iCount] to sFileName
            // This makes sure that we also can change an existing connection id to something new:
            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
            If (ghoStatusPanel <> 0) Begin
                If (Active_State(ghoStatusPanel)) Begin
                    Get Check_StatusPanel of ghoStatusPanel to bCancel
                    If (bCancel = True) Begin
                        Send Deactivate of ghoStatusPanel
                        Procedure_Return
                    End
                End
            End
        Loop

        Get psDriverID to sDriverID

         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
        Move "" to sFileName
        If (sDriverID = MSSQLDRV_ID) Begin
            Move "MSSQLDrv.int" to sFileName
        End
        If (sDriverID = DB2_DRV_ID) Begin
            Move "DB2_Drv.int" to sFileName
        End
        If (sDriverID = ODBC_DRV_ID) Begin
            Move "ODBC_Drv.int" to sFileName
        End
        If (sFileName <> "") Begin
            Move "" to sDriverFile
            Get_File_Path sFileName to sDriverFile
            If (sDriverFile <> "") Begin
                Get psConnectionString to sConnectionString
                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
            End
        End
    End_Procedure

    // Checks if the database exists in SQL. Returns = True if it does.
    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
        String[] sDatabaseArray
        String sVal sServer sDriverID
        Integer iCount iSize iPos
        Boolean bExists
        tSQLConnection SQLConnection

        Move False to bExists
        Get psDriverID to sDriverID
        // DB2 doesn't need to have a "Database" name, so we always return True.
        If (sDriverID = DB2_DRV_ID) Begin
            Function_Return bExists
        End

        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
        If (SizeOfArray(sDatabaseArray) = 0) Begin
            Function_Return False
        End

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
        If (sServer contains "/") Begin
            Move (Pos("/", sServer)) to iPos
            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
        End

        Move (SizeOfArray(sDatabaseArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sDatabaseArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
                Move True to bExists
            End
        Loop

        Function_Return bExists
    End_Function

    // Checks if a table exists as an SQL table. Returns = True if it does.
    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
        String sTableName sVal
        Boolean bExists
        String[] sTablesArray
        Integer iSize iCount

        Move False to bExists
        Get UtilTableHandleToString hTable to sTableName
        Get SqlUtilEnumerateTables sDriverID to sTablesArray
        Move (SizeOfArray(sTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sTablesArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
                Move True to bExists
                Move iSize to iCount // We're done!
            End
        Loop

        Function_Return bExists
    End_Function

    // Checks if a table exists as an SQL table. Returns = True if it does.
    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
        String sVal
        Boolean bExists
        String[] sTablesArray
        Integer iSize iCount

        Move False to bExists
        Get SqlUtilEnumerateTables sDriverID to sTablesArray
        Move (SizeOfArray(sTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sTablesArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
                Move True to bExists
                Move iSize to iCount // We're done!
            End
        Loop

        Function_Return bExists
    End_Function

    // ToDo: This index name function needs to be finished...
    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
        String sStmt sSchema sTableName sDriverID
        Boolean bExists

        Get psDriverID to sDriverID
        Get psSchema to sSchema
        Get UtilTableHandleToString hTable to sTableName

        Function_Return bExists
    End_Function

    // Function creates the passed Sql script as a ".sql" file in the workspace's
    // Home folder, if no path was specified for the filename.
    // Mostly for debugging purposes. E.g. to recreate a Sql script that has been
    // compiled into the program, when the program is run at other location.
//    Function SqlUtilCreateScriptAsFile String sSQLScript String sFileName Returns String
//        String sRetval sPath
//        Integer iCh
//
//        Get ParseFolderName sFileName to sPath
//        If (Trim(sPath) = "") Begin
//            Get psHome of (phoWorkspace(ghoApplication)) to sPath
//        End
//        Get vFolderFormat sPath to sPath
//        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
//            Write channel iCh sSQLScript
//        Send Seq_Close_Channel iCh
//
//        Function_Return (sPath + sFileName)
//    End_Function

    // Enumerate SQL Servers.
    // Pass a driver id. Returns a string array.
    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
        String[] sReturnArray
        Handle hoSQLHandler
        String sServer
        Integer iCount iNumItems iDataSourceType
        Boolean bOK

        If (num_arguments > 1) Begin
            Move iDatSrcType to iDataSourceType
        End

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Get phoMSSQLHandler to hoSQLHandler
                #IFNDEF get_ComparetConnectionById
                    Get EnumerateServers of hoSQLHandler to iNumItems
                #ELSE
                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
                    If (iNumItems = 0) Begin
                        Get EnumerateServers of hoSQLHandler to iNumItems
                    End
                #ENDIF
                For iCount from 0 to (iNumItems - 1)
                    Get String_Value of hoSQLHandler item iCount to sServer
                    Move (Trim(sServer)) to sReturnArray[iCount]
                Loop
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Get phoDB2SQLHandler to hoSQLHandler
                Send SeedDataSources of hoSQLHandler
                Move 0 to iCount
                Repeat
                    Get DataSources of hoSQLHandler to sServer
                    If (sServer <> "") Begin
                        Move (Replace(",", sServer, "")) to sServer
                        Move sServer to sReturnArray[iCount]
                    End
                    Increment iCount
                Until (sServer = "")
                Case Break

            Case (sDriverID = ODBC_DRV_ID)
                Get phoODBCSQLHandler to hoSQLHandler
                Set DataSourceType of hoSQLHandler to iDataSourceType
                Move 0 to iCount
                Repeat
                    Get DataSources of hoSQLHandler to sServer
                    If (sServer <> "") Begin
                        Move (Replace(",", sServer, ", ")) to sServer
                        Move sServer to sReturnArray[iCount]
                    End
                    Increment iCount
                Until (sServer = "")
                Case Break

            Case (sDriverID = SQLFLEX)
                Get _MertechEnumerateSQLFlexServers to sReturnArray
                Case Break

            Case (sDriverID = ORAFLEX)
                Get _MertechEnumerateORAFLEXServers to sReturnArray
                Case Break

            // There appearantly is no way to enumerate servers for this backend.
            Case (sDriverID = MDSPgSQL)
                Move "localhost" to sReturnArray[0]
                Case Break

            // There appearantly is no way to enumerate servers for this backend.
            Case (sDriverID = MDSMySQL)
                Move "localhost" to sReturnArray[0]
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns all databases as a string array for the passed driver id.
    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
        String[] sReturnArray
        String sUserID sPassword
        Boolean bOK

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return sReturnArray
        End

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Get _SqlDatabasesArrayMSSQL to sReturnArray
                Case Break
            Case (sDriverID = DB2_DRV_ID)
                Get _SqlDatabasesArrayDB2 to sReturnArray
                Case Break

            // Enumeration of ODBC databases should be irrelevant as the database
            // should have been specified when the ODBC source was setup with the ODBC manager.
            Case (sDriverID = ODBC_DRV_ID)
                Case Break

            Case (sDriverID = SQLFLEX)
                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
                Case Break

            Case (sDriverID = MDSPgSQL)
                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
                Case Break

            Case (sDriverID = MDSMySQL)
                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
                Case Break

            Case (sDriverID = ORAFLEX)
                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns all table spaces as a string array for the passed driver id.
    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
        String[] sReturnArray
        String sServer sUserID sPassword
        Boolean bOK

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return sReturnArray
        End

        Case Begin
            Case (sDriverID = DB2_DRV_ID)
                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
                Case Break

            Case (sDriverID = MDSPgSQL)
                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
                Case Break

            Case (sDriverID = ORAFLEX)
                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
                Case Break
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns all schemas as a string array for the passed driver id.
    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
        String[] sReturnArray
        Boolean bOK

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return sReturnArray
        End

        Case Begin
            Case (sDriverID = DB2_DRV_ID)
                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
                Case Break

            Case (sDriverID = MDSPgSQL)
                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
                Case Break

            Case (sDriverID = ORAFLEX)
                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
                Case Break
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns a string array with all tables for the current database.
    Function SqlUtilEnumerateTables String sDriverID Returns String[]
        String[] sReturnArray sArray
        String sServer sDatabase sConnectionString sSelect sSchema
        Integer iSize iCount
        Boolean bOK

        If (sDriverID = DATAFLEX_ID) Begin
            Function_Return sArray
        End

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return sReturnArray
        End

        Get psConnectionString to sConnectionString
        Get psDatabase to sDatabase
        Get psSchema   to sSchema

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Get _SqlTableArrayDAW to sReturnArray
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Get _SqlTableArrayDAW to sReturnArray
                Case Break

            Case (sDriverID = ODBC_DRV_ID)
                Get _SqlTableArrayDAW to sReturnArray
                Case Break

            Case (sDriverID = SQLFLEX)
                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
                Case Break

            Case (sDriverID = MDSMySQL)
                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
                Case Break

            Case (sDriverID = MDSPgSQL)
                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
                Case Break

            Case (sDriverID = ORAFLEX)
                Move "SELECT table_name from user_tables" to sSelect
                Get SqlEnumerateEsqlMertech sSelect to sArray
                Move (SizeOfArray(sArray)) to iSize
                Decrement iSize
                For iCount from 0 to iSize
                    If (not(sArray[iCount] contains "$")) Begin
                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
                    End
                Loop
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
                Case Break
        Case End

        Function_Return sReturnArray
    End_Function

    // Returns a string array with all table columns/fields for the passed table handle and driver id.
    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
        String[] sReturnArray
        String sServer sConnectionString sSelect sSchema
        Boolean bOK

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
            Function_Return sReturnArray
        End

        Get psConnectionString to sConnectionString
        Get psSchema to sSchema

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
                Case Break

            Case (sDriverID = SQLFLEX)
                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
                Case Break

            Case (sDriverID = MDSMySQL)
                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
                Case Break

            Case (sDriverID = MDSPgSQL)
                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
                Case Break

            Case (sDriverID = ORAFLEX)
                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
                Case Break
        Case End

        Function_Return sReturnArray
    End_Function


    // Returns a string array with all table indexes for the passed table handle and driver id.
    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
        String[] sReturnArray sReturnArray2
        String sServer sConnectionString sSelect sSchema
        Boolean bOK
        Integer iCount iSize

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
            Function_Return sReturnArray
        End

        Get psConnectionString to sConnectionString
        Get psSchema to sSchema

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
                Case Break

            Case (sDriverID = SQLFLEX)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
                Case Break

            Case (sDriverID = MDSMySQL)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
                Case Break

            Case (sDriverID = MDSPgSQL)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
                Case Break

            Case (sDriverID = ORAFLEX)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
                Case Break
        Case End

        Move (SizeOfArray(sReturnArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            If (Trim(sReturnArray[iCount]) <> "") Begin
                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
            End
        Loop

        Function_Return sReturnArray2
    End_Function

    // Returns a string array with all table names the passed table handle has relation ships with.
    // The format of the array is "TableName.FieldName"
    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
        String[] sFileNameArray sFieldNameArray
        tSQLRelation[] sRelationsArray
        String sServer sConnectionString sSelect sSchema sFileName sFieldName sVal
        Boolean bOK
        Integer iCount iSize iLength iPos
        Integer iFileNumber iFieldNumber

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
            Function_Return sRelationsArray
        End

        Get psConnectionString to sConnectionString
        Get psSchema to sSchema

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
                Case Break

            Case (sDriverID = SQLFLEX)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
                Case Break

            Case (sDriverID = MDSMySQL)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
                Case Break

            Case (sDriverID = MDSPgSQL)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
                Case Break

            Case (sDriverID = ORAFLEX)
                Error "Not implemented yet! The select statement has not been finalized."
//                Move () to sSelect
//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
                Case Break

            Case Else
                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
                Case Break
        Case End

        Move (Length(sTableName)) to iLength
        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
        Move (SizeOfArray(sFileNameArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            If (Trim(sFileNameArray[iCount]) <> "") Begin
                Move sFileNameArray[iCount]         to sFileName
                Move sFieldNameArray[iCount]        to sFieldName
                Move (Mid(sFieldName, 99, iLength)) to sFieldName
                Move sFileName  to sRelationsArray[iCount].sFileName
                Move sFieldName to sRelationsArray[iCount].sFieldName
            End
        Loop

        Function_Return sRelationsArray
    End_Function

    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
        tSQLLoggedInUser[] SQLLoggedInUser
        String[] sUsers sPrograms
        String sSelect
        Integer iSize iCount

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;
                + sDatabase + "') ORDER by Inlog") to sSelect
                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
                Case Break
            Case (sDriverID = SQLFLEX)
                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;
                + sDatabase + "') ORDER by Inlog") to sSelect
                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
                Case Break
            Case Else
                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
        Case End

        Move (SizeOfArray(sUsers)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
        Loop

        Function_Return SQLLoggedInUser
    End_Function

    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
        String[] sFilesData
        Boolean bExists
        Integer iCh
        String sFileName sExt

        Get vFolderExists sDataPath to bExists
        If (bExists = True) Begin
            Move (ToANSI(Trim(sDataPath))) to sDataPath
            Move ("dir:" + sDataPath)      to sDataPath
            Get Seq_New_Channel to iCh  // get free channel for input
            Direct_Input channel iCh sDataPath
                Repeat
                    Readln channel iCh sFileName
                    Get ParseFileExtension sFileName to sExt
                    If (Uppercase(sExt) = "INT") Begin
                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
                        End
                    End
                Until (SeqEof = True)
            Close_Input channel iCh
        End
        Function_Return sFilesData
    End_Function

    // Returns a handle to the SQL server associated with the passed driver ID.
    // Pass e.g. the psServer property to determine the current connection server.
    // Returns a handle to the database connection, or a zero (0) if it fails.
    // This handle can be used to obtain attributes about the server, such as default
    // column types.
    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
        Handle hDatabase
        Integer iDriver iServers iCount
        String sValue

        If (sServer = "") Begin
            Function_Return 0
        End

        Get DriverIndex sDriverID to iDriver
        If (iDriver = 0) Begin
            Function_Return 0
        End

        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
        For iCount from 1 to iServers
            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
            End
        Loop

        Function_Return hDatabase
    End_Function

    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
        String sConnectionString sMessage
        Handle hoSqlHandler hoSQLConnect hoStmt hoError
        Integer i iMsgs iFetchResult iResultCount iRowType iRows iErr iMessage iLastErr
        String[] sMsg aSQLQueryMessages aSQLFetchResults
        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
        TimeSpan tsQuery tsFetch
        tSqlErrorArray aSqlErrorArray
        Boolean bOK bMertechDriver bShowProgress
        tSQLConnection SQLConnection

        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Procedure_Return
        End

        If (num_arguments > 2) Begin
            Move bShowProgr to bShowProgress
        End

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection

        Get IsMertechDriver sDriverID to bMertechDriver
        If (bMertechDriver = True) Begin
            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
        End
        If (bMertechDriver = False) Begin
            Get phoSQLManager to hoSqlHandler
            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
        End

        If (hoSQLConnect <> 0) Begin
            Get SqlOpen of hoSQLConnect to hoStmt
            If (hoStmt <> 0) Begin
                // record starting date/time stamp
                Move (CurrentDateTime()) to dtQueryExecStart
                // turn on error handling if enabled
                If (pbHandleQueryErrors(Self)) Begin
                    Set pbSqlError to False
                    Set paSqlErrorArray to aSqlErrorArray
                    Move Error_Object_Id to hoError
                    Move Self to Error_Object_Id
                End

                // Before we execute the statement; save it so we can display the faulty statement in the error log.
                Set psSQLStatementString to sStmt
                Send SqlExecDirect of hoStmt sStmt

                If (pbHandleQueryErrors(Self)) Begin
                    Move hoError to Error_Object_Id
                End

                Move 0 to iMsgs
                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
                If (bMertechDriver = False) Begin
                    Move Err to iErr
                    Move LastErr to iLastErr
                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
                    Send _SqlColumnInfo hoStmt
                    Send Ignore_Error of Error_Object_Id 12289
                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                    Repeat
                        Get SqlFetch of hoStmt to iFetchResult
                        If (iFetchResult <> 0) Begin
                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
                        End
                    Until (iFetchResult = 0)
                    Send Trap_Error of Error_Object_Id 12289
                    Set Error_Report_Mode to DUF_ERROR_REPORT
                    Move iErr to Err
                    Move iLastErr to LastErr
                    Set paSQLFetchResults to aSQLFetchResults
                End

                Set piRows    to iRows
                Set piRowType to iRowType
                Move (CurrentDateTime()) to dtQueryExecEnd
                Move (CurrentDateTime()) to dtFetchStart

                If (iMsgs <> 0) Begin
                    If (ghoDbUpdateHandler > 0) Begin
                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
                    End
                    For i from 1 to iMsgs
                        Get SqlGetMessage of hoStmt i to sMessage
                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
                        If (bShowProgress = True) Begin
                            If (Active_State(ghoStatusPanel)) Begin
                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
                            End
                            Else Begin
                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
                            End
                        End
                        Move sMessage to sMsg[SizeOfArray(sMsg)]
                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
                    Loop
                    If (ghoDbUpdateHandler > 0) Begin
                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
                    End
                    Set paQueryMessages to sMsg
                End
                Move (CurrentDateTime()) to dtFetchEnd
            End
            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
            Move (dtFetchStart - dtFetchEnd) to tsFetch
            Set ptsQueryExec to tsQuery
            Set ptsFetchResults to tsFetch
            Send SqlClose of hoStmt
        End

        Send SqlDisconnect of hoSQLConnect
    End_Procedure

    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
    // Returns False if no error occured.
    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
        Boolean bOK bShowProgress
        tSQLScriptArray SQLScriptArray
        Integer iOut iRows iCount
        DateTime dtTotalQueryStart dtTotalQueryEnd
        TimeSpan tsTotalTime
        String sMessage

        Move (CurrentDateTime()) to dtTotalQueryStart
        Get SqlUtilReadResource sMemFileName to SQLScriptArray
        If (SQLScriptArray.bError = True) Begin
            Function_Return False
        End

        If (num_arguments > 3) Begin
            Move bShowProgr to bShowProgress
        End

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
        Set Error_Report_Mode to DUF_ERROR_REPORT

        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
        End

        Move (CurrentDateTime()) to dtTotalQueryEnd
        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
        Set ptsTotalQueryTime to tsTotalTime

        Function_Return bOK
    End_Procedure

//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
//        String sRootName
//        Boolean bOK
//
//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
//        Move (sRootName contains sDriverID) to bOK
//
//        Function_Return bOK
//    End_Function

//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
//        String sDriverID sRootName sDisplayName sSchema sVal
//        Integer iDbType
//        Boolean bOK
//
//        Get UtilIsFilelistEntryDriverBased to bOK
//        If (bOK = True) Begin
//            Function_Return False
//        End
//
//        Get psDriverID to sDriverID
//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
//        Move (sDriverID + ":" + sRootName)           to sRootName
//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
//
//        Get psDriverID to sDriverID
//        Get piDbType   to iDbType
//        Get psSchema   to sSchema
//        If (sSchema = "") Begin
//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
//        End
//
//        Move (Uppercase(sDisplayName)) to sVal
//        If (not(sVal contains (sSchema + "."))) Begin
//            If (iDbType = EN_dbTypeDB2) Begin
//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
//            End
//            Else Begin
//                Move (sSchema + "." + sDisplayName) to sDisplayName
//            End
//        End
//
//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
//
//        Function_Return True
//    End_Function

    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
    // from the passed filelist.
    // Returns the number of tables affected.
    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
        Integer iRetval
        Handle hTable

        // We first save the current filelist as the passed filelist name
        // may come from another workspace, to restore it when we're ready.
        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
        Set_Attribute DF_FILELIST_NAME to sFilelist
        Move 0 to hTable
        Move 0 to iRetval

        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
                Move (Uppercase(sRootName)) to sVal
                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
                    // Prefixes:
                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
                    // Suffixes:
                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName

                    // Change Filelist entry:
                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName

                    Move (Lowercase(sDisplayName)) to sVal
                    If (sVal contains "dbo.") Begin
                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName

                        // Change Filelist entry:
                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
                    End
                    Increment iRetval
                End
            End
        Until (hTable = 0)

        Set_Attribute DF_FILELIST_NAME to sCurrentFileList

        Function_Return iRetval
    End_Function

    // To open all Sql based tables in Filelist.cfg
    Procedure SqlUtilOpenAllTables
        Handle hTable
        String sRoot sDriverID
        Boolean bOK

        Move 0 to hTable
        Move "" to sDriverID
        Get AutoConnectionIDLogin to bOK

        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
                        Open hTable
                    End
                End
            End

        Until (hTable = 0)
    End_Procedure

    // This function allows you to put an Sql script in a CM Image. It makes it easier to
    // copy and paste between a DataFlex program and an Sql Editor.
    Function SqlUtilLoadImageFile String sFileName Returns String
        Integer iChannel iPos
        String sTextValue sLine sPath
        Boolean bSeqEof

        Move "" to sTextValue
        Get ParseFolderName sFileName to sPath
        If (Trim(sPath) = "") Begin
            Get psDataPathFirstPart to sPath
            Move (sPath + sFileName) to sFileName
        End

        Get Seq_New_Channel to iChannel
        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DFERR_PROGRAM "No channel available..."
        End
        Else Begin
            Direct_Input channel iChannel sFileName
            Move (SeqEof) to bSeqEof
            If (bSeqEof = True) Begin
                Send Seq_Release_Channel iChannel
                Set psSQLStatementString to ""
                Error DFERR_PROGRAM ("The Sql script file:\n" + sFileName + "\nCould not be found.")
                Function_Return ""
            End

            While (not(bSeqEof))
                Readln channel iChannel sLine
                Move (Pos("/", sLine)) to iPos
                Move (SeqEol) to bSeqEof
                If (not(bSeqEof) and iPos <> 1) Begin
                    Move (sTextValue + sLine + Character(13)) to sTextValue
                End
            Loop
            Send Seq_Release_Channel iChannel
        End

        Set psSQLStatementString to sTextValue
        Function_Return sTextValue
    End_Function

    // Reads an Sql script that have been compiled into the program as an "image" (/MyImageName) and returns the full script as a string.
    // Usage: Get SqlUtilReadScriptFromCMImage of ghoDbUpdateFunctionLibrary CreatevwWorkflowInbox.n
    //
    // This is a trick to use an old DataFlex feature/syntax to include "image names" at the top
    // of a file. Each such section must end with a "/*".
    // Note: Sql script files remarks/comments cannot be handled by the DataFlex compiler. All Sql comment
    //       sections in the "xxx.pkg.sql" file _must_ be removed.
//    Function SqlUtilReadScriptFromCMImage Integer iImg Returns tSQLScriptResult
//        Integer iChannel iPos
//        String sTextValue sLine
//        Boolean bSeqEof
//        tSQLScriptResult SqlScriptResult
//
//        Move "" to sTextValue
//
//        Get Seq_New_Channel to iChannel
//        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
//            Error DFERR_PROGRAM "No channel available..."
//            Function_Return ""
//        End
//
//        Get SqlUtilCheckScriptSize False "" iImg True to SqlScriptResult
//
//        Direct_Input channel iChannel ("image: " + String(iImg))
//        Move (SeqEof) to bSeqEof
//        While (not(bSeqEof))
//            Readln channel iChannel sLine
//            Move (SeqEol) to bSeqEof
//            If (not(bSeqEof)) Begin
//                Move (Trim(sLine)) to sLine
//                If (Left(sLine, 2) <> (Character(47) + Character(47))) Begin // ASCII 47 = "/" (Comments)
//                    Move (sTextValue + sLine + character(13)) to sTextValue
//                End
//            End
//        Loop
//        Send Seq_Release_Channel iChannel
//
//        Set psSQLStatementString to sTextValue
//        Move sTextValue to SqlScriptResult.sSQLScript
//        Function_Return SqlScriptResult
//    End_Function

//    Function SqlUtilSchemaName Handle hTable Returns String
//        String sRetval sDriverID
//        String sTableName
//        Integer iDbType iIndex
//        Boolean bOK
//
//        Get psDriverID to sDriverID
//        Get _SqlCheckCurrentDriver sDriverID to bOK
//        If (hTable = 0 or bOK = False) Begin
//            Function_Return ""
//        End
//
//        Move False to Err
//        Get UtilTableHandleToString hTable to sTableName
//        Get piDbType to iDbType
//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
//        If (iIndex = -1) Begin
//            Function_Return ""
//        End
//
//        Function_Return sRetval
//    End_Function

    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
        Boolean bOpened bOK bMertech
        
        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        Get _TableNameOnly sRootName to sDatabaseName
        // For some reason this .int file update screws up of CodeMast & CodeType .int files
        // which makes the program unable to run because they can't be opened.
        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
        // proper .int files for the two tables.
        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
            Function_Return True
        End                     
        
        Move CS_OEM_Txt  to sOrgFormat
        Move CS_ANSI_Txt to sNewFormat
        Get AutoConnectionIDLogin to bOK
        Send Ignore_Error of Error_Object_Id DFERR_MISSING_VALUE
        Open hTable
        Send Trap_Error of Error_Object_Id DFERR_MISSING_VALUE
        Get_Attribute DF_FILE_OPENED of hTable to bOpened

        // ToDo: What to do if we cannot open the table?!
        If (bOpened = False) Begin
            Function_Return False
        End

        Get psDriverID to sDriverID
        Get IsMertechDriver sDriverID to bMertech
        If (bMertech = True) Begin
            Get psDataPathFirstPart to sDataPath
            Get vFolderExists sDataPath to bOK
            If (bOK = False) Begin
                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
                Function_Return False
            End
            Get vFolderFormat sDataPath to sDataPath
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            Get _TableNameOnly sRootName to sDatabaseName
            Move sDatabaseName to sPhysicalFileName
            Move (sPhysicalFileName + ".int") to sPhysicalFileName
            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
            Function_Return (bOK = True)
        End

        Move False to Err
        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
        Move (Uppercase(sOrgFormat)) to sOrgFormat
        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
        // to "touch" the table so the driver feels there has been a change and updates the .int file.
        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat

        Structure_Start hTable
            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
        Structure_End hTable (DF_STRUCTEND_OPT_IN_PLACE ior DF_STRUCTEND_OPT_FORCE)

        Function_Return (Err = False)
    End_Function

    // Checks if the passed Table;
    // 1) Already has a Filelist entry that points to SQL and
    // 2) It has an .int file.
    // If both is True it should already be connected to SQL
    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
        Boolean bExists bRootName
        String sRootName sDataPath
        Integer iCount

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        Move (sRootName contains sDriverID) to bRootName

        Get psDataPathFirstPart to sDataPath
        Get vFolderExists sDataPath to bExists
        If (bExists = False) Begin
            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
            Function_Return False
        End

        Get vFolderFormat sDataPath to sDataPath
        Get _TableNameOnly sRootName to sRootName
        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists

        Function_Return (bRootName = True and bExists = True)
    End_Function

    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
        Boolean bViewTableType bOpen bMertechDriver bOK
        Integer hoSQLHandler
        Integer iTableCount iNumTables iPos iTableIndex
        String sTableName sOwner sTableType sLogin sEnumTableName sEnumSchemaName sCurrent_Login
        Handle hoCliHandler
        tSQLConnection SQLConnection

        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Get AutoConnectionIDLogin to bOK
            Open hTable
        End

        Get pSQLConnection to SQLConnection
        Get phoCLIHandler to hoCliHandler
        Set psDriverID of hoCliHandler to sDriverID

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
        Get _TableNameOnly sTableName to sTableName
        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables

        For iTableCount from 1 to iNumTables
            Get TableName  of hoCliHandler iTableCount to sEnumTableName
            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
                Get TableType of hoCliHandler iTableCount to sTableType
                Move iNumTables to iTableCount // We're done.
            End
        Loop

        Move (sTableType = "VIEW") to bViewTableType
        If (bOpen = False) Begin
            Close hTable
        End

        Function_Return bViewTableType
    End_Function

    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
    //
    // SQL utility function that returns a database type (string) constant
    // corresponding to the passed iDbType.
    Function SqlUtilDbTypeToString Integer iDbType Returns String
        String sRetval
        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
        Function_Return sRetval
    End_Function

    // SQL utility function that returns a database type constant (integer)
    // corresponding to the passed sDbType string constant.
    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
        Integer iRetval
        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
        Function_Return iRetval
    End_Function

    // Pass an integer DbType and function returns the database type integer as a string value.
    // Used e.g. when reading a connection ini-file to display the database type in
    // the SQL Connection program's grid.
    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
        String sRetval
        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
        Function_Return sRetval
    End_Function

    // Pass a driver name as a string and the function will return
    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
    // quite work and always returns "MS SQL Server"
    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
        Integer iRetval
        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
        Function_Return iRetval
    End_Function

    // *** Helper Functions ***
    // They all start with an underscore: "_" in the function name.
    //
    // Reads a SQL script file that has been compiled into the .exe program as a resource.
    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
        Integer iChannel iArgumentSize iOut iChunk iPointer iCount iSize
        Number nByteCount
        String sCharacter sSQLScript
        Boolean bSeqEof
        tSQLScriptArray SqlScriptArray
        UChar[] uCharData

        Move False to Err
        Get Seq_New_Channel to iChannel
        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DFERR_PROGRAM 'No channel available...'
            Move True to SqlScriptArray.bError
            Function_Return SqlScriptArray
        End

        // First decide the size of the script
        Direct_Input channel iChannel ("Resource: " + sMemFileName)
        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
        Close_Input channel iChannel

        Move (SizeOfArray(uCharData)) to nByteCount
        If (nByteCount  < 1) Begin
            Send Seq_Release_Channel iChannel
            Move True to SqlScriptArray.bError
            Function_Return SqlScriptArray
        End

        // If necessary change the string argument_size
        Get_Argument_Size to iArgumentSize
        If (nByteCount >= iArgumentSize) Begin
            Move (nByteCount + 2048) to nByteCount
            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
            Move True          to SqlScriptArray.bArgumentSizeChanged
            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
        End
        Else Begin
            Move False to SqlScriptArray.bArgumentSizeChanged
        End

        // Read the script file from memory line-by-line
        Direct_Input channel iChannel ("Resource: " + sMemFileName)
            Move 0 to iCount
            Repeat
                Readln channel iChannel sSQLScript
                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
                Increment iCount
            Until (SeqEof = True)
        Close_Input channel iChannel
        Send Seq_Release_Channel iChannel

        // Finally "sanitize" the script by removing all comments.
        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray

        Function_Return SqlScriptArray
    End_Function

    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
        String sSQLVal sStmt sCR sDebugFileName sTmp sGOKeyWord sNoCountKeyWord sMessage sExportFile
        Handle hoSql hoSQLConnect hoStmt hoError
        Integer i iMsgs iFetchResult iResultCount iRows iRowType iCount iChunkCounter iChunkMax iPos iOut iNextSet iMessage
        String[] sMsg aSQLQueryMessages
        DateTime dtQueryExecStart dtQueryExecEnd
        TimeSpan tsQuery
        tSqlErrorArray aSqlErrorArray
        tSQLConnection SQLConnection
        Boolean bOK bMertechDriver bShowProgress

        If (num_arguments > 4) Begin
            Move bShowProgr to bShowProgress
        End
        Get IsMertechDriver sDriverID to bMertechDriver
        If (bMertechDriver = False) Begin
            Get phoSQLManager to hoSql
        End
        Else Begin
            Get _MertechSQLManagerHandle to hoSql
        End

        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
        // There seems to be a problem to pass strings when their value gets really big, aka
        // above the argument_size level. It isn't clear when these problems starts but sooner
        // or later SqlExecDirect stops working correctly with no error messages!
        // To guard from this we set a max number of lines (iChunkMax) that can be processed
        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
        // A bonus of this is that it turns out that it is actually faster to run in chunks!
        Get piChunkMax to iChunkMax
        Move 0 to iChunkCounter
        Move "" to sStmt

        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
        Move (Character(13) + Character(10)) to sCR

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection

        If (bMertechDriver = True) Begin
            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
        End
        If (bMertechDriver = False) Begin
            Get phoSQLManager  to hoSQL
            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
        End

        If (hoSQLConnect <> 0) Begin
            Move False to Err
            Get SqlOpen of hoSQLConnect to hoStmt
            If (hoStmt <> 0) Begin

                // If the embedded resource should be written as a script file to disk:
                If (bCreateScriptFile = True) Begin
                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
                    Get vFolderFormat sExportFile to sExportFile
                    Move (sExportFile + sMemFileName) to sExportFile
                    Get Seq_New_Channel to iOut
                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
                        Direct_Output channel iOut sExportFile
                    End
                End

                // Record starting date/time stamp
                Move (CurrentDateTime()) to dtQueryExecStart
                // Turn on error handling if enabled
                If (pbHandleQueryErrors(Self)) Begin
                    Set pbSqlError to False
                    Set paSqlErrorArray to aSqlErrorArray
                    Move Error_Object_Id to hoError
                    Move Self to Error_Object_Id
                End

                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
                Decrement iRows
                Move (sNoCountKeyWord + sCR) to sStmt

                For iCount from 0 to iRows
                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal

                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
                        If (sSQLVal <> "") Begin
                            Move (sSQLVal + sCR) to sSQLVal
                        End
                        Move (Append(sStmt, (sSQLVal))) to sStmt
                    End

                    // - Each time we encounter a "GO" statement we execute it,
                    // or if at the very end of the script.
                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin

                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
                        // instead of all in one go.
                        Send SqlExecDirect of hoStmt sStmt

                        If (bCreateScriptFile = True) Begin
                            Write channel iOut sStmt
                        End
                        Move "" to sStmt
                        Move 0 to iChunkCounter
                    End
                    Increment iChunkCounter
                Loop

                Repeat
                    If (pbHandleQueryErrors(Self)) Begin
                        Move hoError to Error_Object_Id
                    End
                    Move (CurrentDateTime()) to dtQueryExecEnd

                    Send _SqlColumnInfo hoStmt
                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
                    Set piRows    to iRows
                    Set piRowType to iRowType

                    If (iMsgs <> 0) Begin
                        If (ghoDbUpdateHandler > 0) Begin
                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
                        End
                        For i from 1 to iMsgs
                            Get SqlGetMessage of hoStmt i to sMessage
                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
                            If (bShowProgress = True) Begin
                                If (Active_State(ghoStatusPanel)) Begin
                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
                                End
                                Else Begin
                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
                                End
                            End
                            Move sMessage to sMsg[SizeOfArray(sMsg)]
                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
                        Loop


                        If (ghoDbUpdateHandler > 0) Begin
                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
                        End
                        Set paQueryMessages to sMsg
                    End

                    Get SQLNextResultSet of hoStmt to iNextSet
                Until (iNextSet = 0)

                Move (CurrentDateTime()) to dtQueryExecEnd
            End

            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
            Set ptsQueryExec to tsQuery
            Send SqlClose of hoStmt

            If (bCreateScriptFile = True) Begin
                Close_Output channel iOut
                Send Seq_Release_Channel iOut
            End
        End
        Send SqlDisconnect of hoSQLConnect

        Function_Return (hoSQLConnect <> 0 and Err = False)
    End_Function

    // To enumerate SQL database resources with ESQL and return the result as a string array,
    // for DAW drivers.
    // Returns: A string array.
    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
        String[] sReturnArray
        String sValue sPrevious
        Handle hoSQLHandler hoSQLConnect hstmt
        Integer iFetchResult iRows
        tSQLConnection SQLConnection

        Get phoSQLManager to hoSQLHandler

        If (hoSQLHandler <> 0) Begin
            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect

            If (hoSQLConnect <> 0) Begin
                Get SQLOpen of hoSQLConnect to hstmt
                If (hstmt <> 0) Begin
                    Send SqlExecDirect of hstmt sStmt
                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
                    Repeat
                        Get SQLFetch of hstmt to iFetchResult
                        If (iFetchResult <> 0) Begin
                            Get SQLColumnValue of hstmt iColumn to sValue
                            If (sValue <> sPrevious) Begin
                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
                            End
                            Move sValue to sPrevious
                        End
                    Until (iFetchResult = 0)
                    Send SQLClose of hstmt
                End
                Send SQLDisconnect of hoSQLConnect
            End
        End

        Function_Return sReturnArray
    End_Function

    // To enumerate SQL database resources with ESQL and return the result as a string array,
    // for Mertech drivers.
    // Returns: A string array.
    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
        String[] sReturnArray
        String sValue sUserID sPassword
        Handle hoSQLHandler hoSQLConnect hStmt
        Integer iFetchResult iRows
        tSQLConnection SQLConnection

        Get _MertechSQLManagerHandle to hoSQLHandler

        If (hoSQLHandler <> 0) Begin
            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect

            If (hoSQLConnect <> 0) Begin
                Get SQLOpen of hoSQLConnect to hStmt
                If (hStmt <> 0) Begin
                    Send SqlExecDirect of hStmt sStmt
                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
                    Repeat
                        Get SQLFetch of hStmt to iFetchResult
                        If (iFetchResult <> 0) Begin
                            Get SQLColumnValue of hStmt 1 to sValue
                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
                        End
                    Until (iFetchResult = 0)
                    Send SQLClose of hStmt
                End
                Send SQLDisconnect of hoSQLConnect
            End
        End

        Function_Return sReturnArray
    End_Function

    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
    // will be used.
    Function SqlUtilBackupDatabaseToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
        Boolean bOK bExists bShowProgress
        String sStatement sDriverID
        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
        Integer iDbType

        If (sDatabase = "") Begin
            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
            Function_Return False
        End
        If (sBackupName = "") Begin
            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
            Function_Return False
        End

        // Create backup-folder if it doesn't exist
        Get vFolderExists sPath to bExists
        If (bExists = False) Begin
            Get vCreateDirectory sPath to bOK
            If (bOK = False) Begin
                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
                Function_Return False
            End
        End
        // Make sure the path ends with a back-slash
        If (sPath <> "") Begin
            Get vFolderFormat sPath to sPath
        End

        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        If (num_arguments > 3) Begin
            Move bShowProg to bShowProgress
        End

        Case Begin
            Case (iDbType = EN_DbTypeMSSQL)
                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady

                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
                Case Break
            Case Else
                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
        Case End

        Function_Return bOK
    End_Function

    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
    // that "fits" in the max allowed length for table names.
    // Max number of characters allowed for table names;
    // IBM DB2      = 128
    // MS-SQL       = 128
    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
    // MySQL        = 64
    // PostgreSQL   = 64
    Function SqlUtilGUIDTempTableName String sRootName Returns String
        String sGUIDName
        Integer iDbType iLength
        
        Get piDbType to iDbType
        Move (RandomHexUUID()) to sGUIDName
        Move (sRootName + "_" + sGUIDName) to sGUIDName
        Move (Length(sGUIDName)) to iLength
        
        Case Begin
            Case (iDbType = EN_DbTypeDB2)
            If (iLength > 128) Begin
                Move (Left(sGUIDName, 128)) to sGUIDName
            End
            Case Break

            Case (iDbType = EN_DbTypeMSSQL)
            If (iLength > 128) Begin
                Move (Left(sGUIDName, 128)) to sGUIDName
            End
            Case Break

            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
            If (iLength > 128) Begin
                Move (Left(sGUIDName, 128)) to sGUIDName
            End
            Case Break

            Case (iDbType = EN_DbTypeMySQL)
            If (iLength > 64) Begin
                Move (Left(sGUIDName, 64)) to sGUIDName
            End
            Case Break

            Case (iDbType = EN_DbTypePostgre)
            If (iLength > 64) Begin
                Move (Left(sGUIDName, 64)) to sGUIDName
            End
        Case End
       
        Function_Return sGUIDName   
    End_Function
       
    // Reads a resource that has been embedded by the compiler and writes it to disk.
    // Pass the memory resource file reference and the filename to be created,
    // including full path.
    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
        String sText
        Integer iCh iSize iArgSize

        Move ("Resource:" + sMemFileName) to sMemFileName
        Get Seq_Open_Input_Channel sMemFileName to iCh
            Get_Channel_Size iCh to iSize
            Get_Argument_Size to iArgSize
            If (iSize > iArgSize) Begin
                Set_Argument_Size iSize
            End
            Read_Block channel iCh sText iSize
        Send Seq_Close_Channel iCh

        Get Seq_Open_Output_Channel sFileName to iCh
            Write channel iCh sText
        Send Seq_Close_Channel iCh

        If (iSize <> iArgSize) Begin
            Set_Argument_Size iArgSize
        End

        // Wait for file to be written to disk.
        Sleep 2
    End_Procedure

    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
        String sNotNull sRetval sDefaultValue
        Boolean bOK

        Get IsSQLDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return ""
        End

        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull

        Case Begin
            Case (iDbType = EN_dbTypeMSSQL)
                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
                Case Break
            Case (iDbType = EN_dbTypeMySQL)
                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
                Case Break
            Case (iDbType = EN_dbTypePostgre)
                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
                Case Break
            Case (iDbType = EN_dbTypeDB2)
                Move (String(sNotNull))                                     to sRetval
                Case Break

            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
            // ToDo: We need to look deeper into how Oracle handles NULL
            Case (iDbType = EN_dbTypeOracle)
                Move  ""                                                    to sRetval
                Case Break

            Case Else
                Move  ""                                                    to sRetval
        Case End

        Function_Return sRetval
    End_Function

    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
        String[] sReturnArray
        String sValue sUserID sPassword
        Handle hoSQLHandler hoSQLConnect hStmt
        Integer iFetchResult iRetval
        tSQLConnection SQLConnection

        Get _MertechSQLManagerHandle to hoSQLHandler
        If (hoSQLHandler <> 0) Begin
            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
            If (hoSQLConnect <> 0) Begin
                Get SQLOpen of hoSQLConnect to hStmt
                If (hStmt <> 0) Begin
                    Send SQLSetProcedureName of hStmt sStmt
                    If (sArgument <> "") Begin
                        Send SqlSetArgument  of hStmt 1 sArgument
                    End
                    Send SQLCall of hStmt

                    Get SqlReturnValue       of hStmt to iRetval
                    If (iRetval = 0) Begin
                        Repeat
                            Get SQLFetch of hStmt to iFetchResult
                            If (iFetchResult <> 0) Begin
                                Get SQLColumnValue of hStmt 1 to sValue
                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
                            End
                        Until (iFetchResult = 0)
                        Send SQLClose of hStmt
                    End
                End
                Send SQLDisconnect of hoSQLConnect
            End
        End

        Function_Return sReturnArray
    End_Function

    // Returns the index for the passed sTableName
    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
        Integer iIndex iSize iCount
        String[] sTablesArray
        String sVal sConnectionString

        Move -1 to iIndex
        Get psConnectionString to sConnectionString
        Get SqlUtilEnumerateTables sDriverID to sTablesArray
        Move (SizeOfArray(sTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move sTablesArray[iCount] to sVal
            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
                Move iCount to iIndex // We found it!
                Move iSize to iCount  // End the loop
            End
        Loop

        Function_Return iIndex
    End_Function

    // Helper function that builds a string like;
    // "SELECT name from [Master].[sys].[databases] where name"
    Function _SqlSelectFromWhereName Returns String
        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO

        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
        Get _SqlFindKeyWord CI_SQLName         to sName
        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
        Get _SqlFindKeyWord CI_SQLSys          to sSys
        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
        Function_Return sRetval
    End_Function

    // Helper function to create a SQL statement like;
    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
    // Used for checking if an index exists.
    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName

        Get _SqlFindKeyWord CI_SQLSelect to sSelect
        Get _SqlFindKeyWord CI_SQLFrom to sFrom
        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
        Get _SqlFindKeyWord CI_SQLWhere to sWhere
        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
        Get _SqlFindKeyWord CI_SQLAND to sAnd
        Get _SqlFindKeyWord CI_SQLName to sName

        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval

        Function_Return sRetval
    End_Function

    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
        String sRetval
        If (iLength <> 0) Begin
            Move ("(" + String(iLength)) to sRetval
            If (iDecimals <> 0) Begin
                Move (sRetval + "," + String(iDecimals)) to sRetval
            End
            Move (sRetval + ")") to sRetval
        End
        Function_Return sRetval
    End_Function

    Procedure _SqlColumnInfo Handle hoStmt
        Integer i iCols iItem
        tSqlColumnNew[] aQueryColumns

        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
        For i from 1 to iCols
            Move (SizeOfArray(aQueryColumns)) to iItem
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
        Loop
        Set piColumns to iCols
        Set paQueryColumns to aQueryColumns
    End_Procedure

    // Checks that the passed sDriverID is defined.
    // Also checks if the driver has been loaded; else it gets loaded.
    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
        Boolean bOK
        Integer iDriver

        If (sDriverID = DATAFLEX_ID) Begin
            Function_Return False
        End

        Get IsDAWSQLDriver sDriverID to bOK

        If (bOK = False) Begin
            Get IsMertechDriver sDriverID to bOK
        End

        If (bOK = False) Begin
            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
            Function_Return False
        End

        Get DriverIndex sDriverID to iDriver
        If (iDriver = 0) Begin
            Load_Driver sDriverID
        End

        Function_Return True
    End_Function

    // Checks that the length parameter has been passed correctly.
    // This is only of concern for certain SQL data types.
    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
        Integer iLength
        Boolean bOK bCheckTypeLength

        If (num_arguments > 1) Begin
            Move iLen to iLength
        End
        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;
              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;
              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength

        If (bCheckTypeLength = True) Begin
            Move (iLength > 0) to bOK
        End

        Function_Return (bOK = True)
    End_Function

    Function _SqlProperTableName String sTableName Returns String
        String sVal sSchema sDriverID sValue
        Handle hTable
        Integer iDbType

        If (Trim(sTableName) = "") Begin
            Function_Return ""
        End

        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        If (iDbType = EN_dbTypeOracle) Begin
            Get psUserID to sSchema
            // Not sure about this uppercasing but it seems like Oracle wants that?
            Move (Uppercase(sSchema)) to sSchema
            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
            Function_Return sTableName
        End
        If (iDbType = EN_DbTypeMySQL) Begin
            Get psDatabase to sVal
            Move (sVal + "." + sTableName) to sTableName
            Function_Return sTableName
        End
        If (iDbType = EN_DbTypePostgre) Begin
            Move ('"' + sTableName + '"') to sTableName
            Function_Return sTableName
        End

        Get psSchema to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End

        Move (Uppercase(sTableName)) to sVal
        If (not(sVal contains (sSchema + "."))) Begin
            If (iDbType = EN_dbTypeDB2) Begin
                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
            End
            Else Begin
                Move (sSchema + "." + sTableName) to sTableName
            End
        End

        Function_Return sTableName
    End_Function

    // SQL column names can be case-sensitive. This function is used to check that
    // the passed sFieldName has the correct spelling.
    // Used with Embedded SQL statement calls.
    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
    Function _SqlFindColumnName String sTableName String sColumnName Returns String
        String sRetval sValue sConnectionString sDriverID
        String[] sColumnNamesArray
        Integer iCount iColumns

        Move "" to sRetval
        Get psDriverID to sDriverID
        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
        Move (SizeOfArray(sColumnNamesArray)) to iColumns
        Decrement iColumns

        For iCount from 0 to iColumns
            Move sColumnNamesArray[iCount] to sValue
            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
                Move sValue to sRetval
                Move iColumns to iCount // We're done.
            End
        Loop

        Function_Return sRetval
    End_Function

    { Visibility=Private }
    Function _SqlDatabasesArrayMSSQL Returns String[]
        String[] sReturnArray
        Handle hoSQLHandler
        Integer iCount iSize iItem
        String sServer sUser sPassword
        tSQLConnection SQLConnection

        Get phoMSSQLHandler to hoSQLHandler
        Send Delete_Data    of hoSQLHandler
        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
        Decrement iSize

        For iCount from 0 to iSize
            Get String_Value of hoSQLHandler item iCount to sServer
            Move (Trim(sServer)) to sReturnArray[iItem]
            Increment iItem
        Loop

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Function_Return sReturnArray
    End_Function

    Function _SqlTableArrayDAW Returns String[]
        String[] sReturnArray
        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
        Handle hoSQLHandler
        Integer iCount iSize iItem
        Boolean bOK
        tSQLConnection SQLConnection

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        If (SQLConnection.sConnectionString = "") Begin
            Function_Return sReturnArray
        End

        Move SQLConnection.sSchema      to sDefSchema
        Move (Uppercase(sDefSchema))    to sDefSchema
        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord

        Get phoCLIHandler to hoSQLHandler
        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
        Send Delete_Data  of hoSQLHandler

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
        Move False to Err
        Decrement iSize

        For iCount from 0 to iSize
            Get TableName    of hoSQLHandler iCount to sTable
            Get TableType    of hoSQLHandler iCount to sTableType
            Get SchemaName   of hoSQLHandler iCount to sSchema
            Get TableComment of hoSQLHandler iCount to sComment
            Move (Trim(sTable)) to sTable
            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
            End
            Else Begin
                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
            End
            If (bOK = True) Begin
                Move sTable to sReturnArray[iItem]
                Increment iItem
            End
        Loop

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Function_Return sReturnArray
    End_Function

    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
        String[] sReturnArray
        String sValue
        Handle hoSQLHandler hoSQLConnect hStmt
        Integer iRetval iCols iFetchResult
        tSQLConnection SQLConnection

        Get phoSQLManager to hoSQLHandler
        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect

        If (hoSQLConnect <> 0) Begin
            Get SqlOpen of hoSQLConnect to hStmt
            If (hStmt <> 0) Begin
                Send SqlSetProcedurename of hStmt sStmt
                If (sArgument <> "") Begin
                    Send SqlSetArgument  of hStmt 1 sArgument
                End

                Send SqlCall             of hStmt
                Get SqlReturnValue       of hStmt to iRetval
                If (iRetval = 0) Begin
                    Repeat
                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
                        If (iCols > 0) Begin
                            Repeat
                                Get SqlFetch of hStmt to iFetchResult
                                If (iFetchResult <> 0) Begin
                                    Get SqlColumnValue of hStmt 1 to sValue
                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
                                End
                            Until (iFetchResult = 0)
                        End
                        Get SqlNextResultSet of hStmt to iRetval
                    Until (iRetval = 0)
                    Send SqlClose of hStmt
                End
            End
            Send SqlDisconnect of hoSQLConnect
        End
        Function_Return sReturnArray
    End_Function

    { Visibility=Private }
    Function _SqlDatabasesArrayDB2 Returns String[]
        String[] sReturnArray
        String sDataSource
        Handle hoSQLHandler
        Integer iItem

        Get phoDB2SQLHandler to hoSQLHandler
        Send SeedDataSources of hoSQLHandler

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Repeat
            Get DataSources of hoSQLHandler to sDataSource
            Move (Replaces(",", sDataSource, "")) to sDataSource
            Move (Trim(sDataSource)) to sReturnArray[iItem]
            Increment iItem
        Until (sDataSource = "")

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Function_Return sReturnArray
    End_Function

    { Visibility=Private }
    Function _SqlDatabasesArrayODBC Returns String[]
        String[] sReturnArray
        String sDataSource
        Handle hoSQLHandler
        Integer iItem

        Get phoODBCSQLHandler to hoSQLHandler
        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Send SeedDataSources of hoSQLHandler

        Repeat
            Get DataSources of hoSQLHandler to sDataSource
            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
                Move (Trim(sDataSource)) to sReturnArray[iItem]
                Increment iItem
            End
        Until (sDataSource = "")

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL

        Function_Return sReturnArray
    End_Function

    // We might have a split Sql script where the info about which database to use is
    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
    // insert it for scriplets to come after the first one.
    Function _SqlFormatStatement String sStmt Returns String
        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
        Integer iStart iEnd iDbType
        Boolean bOK

        Get piDbType to iDbType
        Get psDriverID to sDriverID
        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
        Move (Replaces(" ", sStmt, "")) to sTmp
        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
            Move (Pos("[", (Uppercase(sTmp)))) to iStart
            Move (Pos("]", sTmp)) to iEnd
            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
            Set Private.psUseDatabase to sUseDatabase
        End
        Else Begin
            Move (Uppercase(sStmt)) to sTmp

            // A "Create View" statement _must_ be the very first words in a Sql statement.
            If (not(sTmp contains sCreateViewKeyWord)) Begin
                Get Private.psUseDatabase to sUseDatabase
                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
            End

            // This is a bit special to place here but was done so because it was easier that way.
            // We will get an error when trying to create a view if it already exists.
            // So to avoid such errors; we first remove it & then recreate it.
            Else If (sTmp contains sCreateViewKeyWord) Begin
                // Make sure we only have one space between statements/words.
                Move (Replaces("  ", sTmp, " ")) to sTmp
                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
                Move (Trim(sTmp)) to sTmp
                Move (Pos(" ", sTmp)) to iEnd
                Move (Left(sTmp, iEnd)) to sTmp
                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
                End
                Move (Trim(sTmp)) to sTmp
                // Remove data view as it already exists!
                Get SqlViewRemove sDriverID sTmp to bOK
            End
        End

        Function_Return sStmt
    End_Function

    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
        String sRetval
        Integer iDbType iSize iItem iIndex
        tSQLKeyWords[] SQLKeywordArray
        tSQLKeyWords   SQLKeyWords

        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
        Get piDbType to iDbType
        Move iDbType             to SQLKeyWords.iSQLDbType
        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord

        Get paSQLKeywordArray to SQLKeywordArray
        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval

        Function_Return sRetval
    End_Function

    // Function will "clean/sanitize" the script by removing all comments and blank lines.
    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
        String[] sSQLScriptArray
        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
        Integer iCh iSize iArgSize iPos iCount
        Boolean bCommentStart bCommentEnd bDashComment

        Move False to bCommentStart
        Move False to bCommentEnd
        Move False to bDashComment
        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
        Move "*/"  to sCommentEnd
        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".

        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
        Decrement iSize
        Move "" to sText

        For iCount from 0 to iSize
            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
            Move (Trim(sLine)) to sTmp
            If (sTmp <> "") Begin
                Move (Left(sTmp, 2) = sDashComment) to bDashComment
                If (bCommentStart = False) Begin
                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
                    If (bCommentStart = False) Begin
                    End
                End
                Move (sTmp contains sCommentEnd) to bCommentEnd
                If (bCommentEnd = True) Begin
                    Move False to bCommentStart
                End
                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
                End
            End
        Loop

        // Update the retval struct array:
        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
        Function_Return SqlScriptArray
    End_Function
    

    // *** Database API Functions: ***
    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
    // make changes/updates to the database.
    //
    //
    // This might not do what you think - Here's what it does:
    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
    // to the SQL table.
    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
    // already exists in SQL.
    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
    // restructuring an existing table.
    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
        String sDriverID sTableName sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
        Handle hToTable
        Integer iPos

        Move True to bUseConnectionID
        If (num_arguments > 1) Begin
            Move bUseConnID to bUseConnectionID
        End

        Get psDriverID to sDriverID
        // If the table doesn't exist on the SQL back-end we do nothing.
        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        Get UtilTableIsAlias hTable to bIsAlias
        
        Get _SqlCheckCurrentDriver sDriverID to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        // Then we need to check that the function hasn't been called before; which in case
        // we do nothing
        Get SQLUtilTableIsAttached sDriverID hTable to bExists
        If (bExists = True) Begin
            Function_Return False
        End

        Get psConnectionID     to sConnectionID
        Get psConnectionString to sConnectionString
        If (sConnectionID = "" or sConnectionString = "") Begin
            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
            Function_Return False
        End

        Get psSchema to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End

        Get IsMertechDriver sDriverID to bMertechDriver

        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
        // was a programmer's error and we adjust for it here.
        If (bMertechDriver = True) Begin
            Move False to bUseConnectionID
        End

        // If we should use a connection id we need to check it exists;
        // else we create it before attempting creating the table
        If (bUseConnectionID = True) Begin
            Get AutoConnectionIDLogin to bOK
            If (bOk = False) Begin
                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
                Function_Return False
            End
        End

        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        Get _TableNameOnly sRootName to sRootName
        If (sRootName = "") Begin
            Function_Return False
        End
        Move (sRootName + ".int")                    to sPhysicalName
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName  

        // We don't want to change the display name if it starts with an ampersand ("@"),
        // because then the table should not be visible to users.
        Move (Pos("@", sDisplayName)) to iPos
        If (iPos <> 1) Begin
            If (sDisplayName contains ".") Begin
                Move (Pos(".", sDisplayName)) to iPos
                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
                Move (sSchema + "." + sDisplayName)       to sDisplayName
            End
            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
            End
        End

        If (bIsAlias = False) Begin
            Get OpenTableExclusive hTable to bOpened
            If (bOpened = False) Begin
                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
                Function_Return False
            End
        End

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
        End
        // Note: The hToTable will get changed by the Structure_xxx command...
        Move hTable to hToTable
        Move False to Err

        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
        // a proper and updated .int file.
        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
        
        If (bIsAlias = False) Begin
            Structure_Start hToTable sDriverID
                If (bUseConnectionID = True) Begin
                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
                End
                Else Begin
                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
                End
                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
                Move False to Err
                Move 0 to LastErr
            Structure_End hToTable
        End

        Move (not(Err)) to bOK
        If (bOK = True) Begin
            // The attributes set above will always trigger an error
            // We also adjust the Filelist entries
            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName

            // This pseudo updates the .int file to make it up-to-date with the SQL back-end.
            Get SqlUtilUpdateIntFile hTable to bOK
        End

        Function_Return (bOK = True)
    End_Function

    // Sample usage:
    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Structure_Start hTable
            Set_Attribute iAttribute of hTable to iValue
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    // To use a filelist slot for the passed FileName, TableName & DisplayName,
    // or to change the filelist slot names.
    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
        Boolean bExists
        Integer iPos
        
        Move False to Err
        Get UtilTableNumberIsInUse hTable to bExists
        If (bExists = False) Begin
            Function_Return False
        End

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
        End
        // If all strings are empty it means that we should remove this entry from filelist.
        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
            Function_Return (Err = False) // And we're done.
        End

        If (sDriverID <> DATAFLEX_ID) Begin
            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
        End
        Else Begin
            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
        End

        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName

        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
        End
        Else Begin
            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
        End

        Function_Return (Err = False)
    End_Function

    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Structure_Start hTable
            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
        Boolean bOK

        Move False to Err
        Get AutoConnectionIDLogin to bOK
        Open hToTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Structure_Start hTable
            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    Procedure ApiTableConvertAllAddException Integer hTable
        Integer[] iTableConvertExceptions
        Get piTableConvertExceptions to iTableConvertExceptions
        Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
        Set piTableConvertExceptions to iTableConvertExceptions
    End_Procedure

    Procedure ApiTableConvertALLToSql
        Integer[] iTablesArray
        Integer iSize iCount
        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
        String sDriverID

        Get psDriverID to sDriverID
        Get pbUseConnectionID to bUseConnectionID
        Get pbToANSI          to bToANSI
        Get pbRecnum          to bRecnum
        Get pbCopyData        to bCopyData
        If (ghoDbUpdateHandler > 0) Begin
            Get pbContinueOnError to bContinueOnError
        End

        Get _AllTablesToConvert to iTablesArray
        Move (SizeOfArray(iTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
            // Probably the right logic here is to just continue trying to convert every table even
            // if there was an error converting one table...
            //If (bContinueOnError = False and bOK = False) Break
        Loop

    End_Procedure

    Procedure ApiTableAttachALLToSql 
        Integer[] iTablesArray
        Integer iSize iCount
        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
        String sDriverID

        Get psDriverID to sDriverID
        Get pbUseConnectionID to bUseConnectionID
        Get pbToANSI          to bToANSI
        Get pbRecnum          to bRecnum
        Get pbCopyData        to bCopyData
        If (ghoDbUpdateHandler > 0) Begin
            Get pbContinueOnError to bContinueOnError
        End

        Get _AllTablesToConvert to iTablesArray
        Move (SizeOfArray(iTablesArray)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
        Loop

    End_Procedure

    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
        Handle hToTable hoLogFile
        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
        String sPhysicalName sRootName sLogicalName sDisplayName sEmpty sConnectionID sConnectionString
        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
        tSQLConnection SQLConnection

        Get UtilTableIsAlias hTable to bIsAlias 
        // If this is an Alias file there is nothing to convert to SQL.
        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
        If (bIsAlias = True) Begin   
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName) 
                Get psConnectionID to sConnectionID
                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
            End
            Function_Return True
        End
        
        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sLogicalName) * "Number:" * String(hTable))
        End  
        
        // Marco Kuipers suggestion;
        // If Filelist.cfg points to an embedded .dat table and the table already exists as
        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
        // table again.
        Get UtilTableIsSQL hTable to bOK
        If (bOK = False) Begin
            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists 
            If (bExists = True) Begin
                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
                Get phoLogFile to hoLogFile
                If (hoLogFile <> 0) Begin
                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
                    Send LogError sWarning False
                End                                        
                Else Begin
                    Error DFERR_PROGRAM sWarning
                End
            End
        End
        
        // Does the rootname contain a driver?
        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
            // Does the table already exist as an SQL table?
            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
            // It can happen that the table is missing from Filelist.cfg but still
            // exist on the SQL side, in case we want to search for the table by its name.
            If (bExists = False) Begin
                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
            End
            If (bExists = True) Begin
                Set TableName_Text of ghoStatusPanel to ""
                Function_Return False
            End
        End

        Move CS_ANSI_Txt to sANSI_OEM
        If (bToAnsi = False) Begin
            Move CS_OEM_Txt to sANSI_OEM
        End

        Get IsDAWSQLDriver sDriverID to bDAWDriver
        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
        // passed as True, we adjust for that here.
        Get IsMertechDriver sDriverID to bMertechDriver
        If (bMertechDriver = True and bUseConnectionID = True) Begin
            Move False to bUseConnectionID
        End

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Move SQLConnection.sSchema           to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO    to sSchema 
            Move (Lowercase(sSchema))        to sSchema
        End

        If (sDriverID = ORAFLEX) Begin
            Move SQLConnection.sUserID       to sSchema
        End

        Move SQLConnection.sDatabase         to sDatabase
        Move SQLConnection.sConnectionID     to sConnectionID
        Move SQLConnection.sConnectionString to sConnectionString
        If (sConnectionID = "" or sConnectionString = "") Begin
            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
            Function_Return False
        End

        Get AutoConnectionIDLogin to bOK
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
            Function_Return False
        End

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
        End  
        
        Move 0 to hToTable
        Get _TableNameOnly sRootName                 to sRootName
        Move (sRootName + ".int")                    to sPhysicalName

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Case Break
            Case (sDriverID = ODBC_DRV_ID)
                Case Break
            Case (sDriverID = DB2_DRV_ID)
                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
                Move SQLConnection.sLongTableSpace  to sLongTableSpace
                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
                Case Break
            Case (sDriverID = ORAFLEX)
                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
                Case Break
            Case (sDriverID = MDSMySQL)
                Case Break
            Case (sDriverID = MDSPgSQL)
                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
                Case Break
            Case (sDriverID = DATAFLEX_ID)
                Case Break
            Case Else
                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
                Case Break
        Case End

        Move False to Err
        
        If (bIsAlias = False) Begin
    
            If (bMertechDriver = True) Begin
                // Note: This function also sets the Err flag.
                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
            End
    
            If (bMertechDriver = False) Begin
                Structure_Start hToTable sDriverID
                    Structure_Copy hTable to hToTable
    
                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
    
                    If (sDriverID <> DATAFLEX_ID) Begin
                        If (bUseConnectionID = True) Begin
                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
                        End
                        Else Begin
                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
                        End
    
                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
    
                        If (sSchema <> "") Begin
                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
                        End
    
                        If (sDriverID = DB2_DRV_ID) Begin
                            If (sLongTableSpace <> "") Begin
                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
                            End
                            If (sBaseTableSpace <> "") Begin
                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
                            End
                            If (sIndexTableSpace <> "") Begin
                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
                            End
                        End
                    End
    
                Structure_End hToTable
            End
    
            Move (not(Err)) to bOK
            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
                If (bIsAlias = False) Begin
                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
                    If (ghoDbUpdateHandler > 0) Begin
                        Get pbContinueOnError to bContinueOnError
                    End
                    // If the data copy failed we will keep the newly created SQL table but
                    // rename it by adding a GUID at the end of the table name
                    // - or as much as "fit" because different SQL back-ends have
                    // different rules how long a table name can be.
                    // The new table will probably contain data but something went
                    // wrong while converting the data from embedded to SQL.
                    If (bOK = False and bContinueOnError = False) Begin
                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
                    End
                End
            End
        End
        
        If (bMertechDriver = True) Begin
            Open hTable
        End

        // This must be after copying data...
        If (Err = False) Begin
            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
            // We also adjust the display name by prefixing it by the schema name;
            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
                // The max length for the display_name is 31 characters...
                If (Length(sSchema + "." + sDisplayName) < 31) Begin
                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
                End
            End
        End
        
        Close hTable
        Move (not(Err)) to bOK
        Function_Return (bOK = True)
    End_Function  
    
    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
    // It will first drop all indicies, copy the data and then recreate indicies.
    // An error log file with the sRootname + ".err" will be created in the Data folder.
    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
        Boolean bOpened bOK
        Integer hToTable iIndex iCount iRetval iVoid iOrgFreq
        String sErrorFile sEmpty sPath

        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
        Get AutoConnectionIDLogin to bOK
        If (sDriverID = DATAFLEX_ID) Begin
            Send IncreaseSortBufferSize
//            Send SetAllIndexesToBatch hToTable
        End

        Move False to Err
        Open sPhysicalName as hToTable
        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
        If (bOpened = False) Begin
            Function_Return False
        End

        If (ghoStatusPanel <> 0) Begin
            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
        End

        Move "" to sEmpty
        Move False to Err
        Move True to bOK

        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
//        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
        If (sDriverID <> DATAFLEX_ID) Begin
            // Remove all indices to speed up copying of data:
            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
            If (iRetval <> 0) Begin
                Error DFERR_PROGRAM ("Failed dropping indices for table:" * sRootName)
                Function_Return False
            End
        End

        Move (sRootName + ".err") to sErrorFile
        Move 0 to iIndex
        Move False to Err

        Copy_Records hFromTable to hToTable using 0 Callback Self

        If (Err = False) Begin
            Get psHome of (phoWorkspace(ghoApplication)) to sPath
            Get vDeleteFile (sPath + sErrorFile) to iRetval
        End

        If (sDriverID <> DATAFLEX_ID) Begin
            // Recreate indices:
            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
        End

        Close hToTable
        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq

        If (bOK = True) Begin
            Move (not(Err)) to bOK
        End

        If (ghoStatusPanel <> 0) Begin
            Set TableName_Text of ghoStatusPanel to ""
            Set Message_Text   of ghoStatusPanel to ""
            Set Action_Text    of ghoStatusPanel to ""
        End

        Function_Return (bOK = True)
    End_Function

    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
        Handle hFile
        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
        Integer iColumn iIdentityType iDataType iDbType iCount iSize
        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened
        tSQLConnection SQLConnection
        tAPIColumn[] aColumns
        tColumnType ColumnType
        
        // First check if the passed filenumber already exists; in case we do nothing
        Get UtilTableExists hTable to bOk
        If (bOk = True) Begin
            Function_Return False
        End
        
        Move sLogicalName to sTableName
        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar
            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable))
        End

        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSqlDriver
        Get piDbType to iDbType

        // If no columns passed in, we need to create a "dummy" column 
        Move False to bDeleteDummy 
        If (Num_Arguments = 8) Begin
            Move aColumnIn to aColumns
        End
        If ((SizeOfArray(aColumns)) = 0) Begin
            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
            Move ColumnType.iType to iDataType
            If (bRecnum = False) Begin
                Move C_tAPIColumn_Identity to iIdentityType
            End                                            
            Else Begin
                Move C_tAPIColumn_None     to iIdentityType
            End
            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
            Move True to bDeleteDummy 
        End  
        
        // If columns have been passed as an array we need to check if an identity column
        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
        // if so auto-set the bRecnum to FALSE. This is because else there would be 
        // two identity columns and SQL doesn't like that and throws an error.
        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
            Move (SizeOfArray(aColumns)) to iSize
            Decrement iSize
            for iCount from 0 to iSize
                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
                    Move False to bRecnum  
                    Move iSize to iCount
                End
            Loop
        End
        
        // If this is a SQL based driver we also check if the table exists
        // in the SQL back end; in case we do nothing.
        If (bSqlDriver = True) Begin
            // Get all connection properties
            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
            Move SQLConnection.sSchema to sSchema
            If (sSchema = "") Begin
                Get _SqlFindKeyWord CI_SQLDBO to sSchema
            End   

            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
            // It can happen that the table is missing from Filelist.cfg but still
            // exist on the SQL side, in case we want to search for the table by its name.
            If (bExists = False) Begin
                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
            End
            // If the table exists on the SQL back-end but not in Filelist.cfg,
            // we will just add it to Filelist.cfg
            If (bExists = True) Begin
                If (bExistsInFilelist = False) Begin
                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
                        Move (sDriverID + ":" + sRootName) to sRootName
                    End
                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName                        
                    Move False to bSysFile
                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
                End
                Function_Return False
            End
        End

        Move CS_ANSI_Txt to sANSI_OEM
        If (num_arguments > 6) Begin
            If (bANSI = False) Begin
                Move CS_OEM_Txt to sANSI_OEM
            End
        End

        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
        // is a programmer's error and we auto-correct for it here.
        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
        // set it back and use a Mertech function to convert it to SQL.
        Get IsMertechDriver sDriverID to bMertechDriver
        If (bMertechDriver = True) Begin
            If (bUseConnectionID = True) Begin
                Move False to bUseConnectionID
            End
            Move sDriverID to sOriginalDriverID
            Move DATAFLEX_ID to sDriverID
        End

        Move False to Err
        If (sDriverID = DATAFLEX_ID) Begin
            Move sRootName to sPhysicalFile
        End

        If (sDriverID <> DATAFLEX_ID) Begin
            Move SQLConnection.sConnectionID to sConnectionID

            // If DAW driver and we should use a connection id we need to
            // check if the connection ID exists; else we create it before attempting creating the table
            If (bMertechDriver = False and bUseConnectionID = True) Begin
                Get IsConnectionID sConnectionID sDriverID to bExists
                If (bExists = False) Begin
                    Get UtilCreateConnectionID sConnectionID to bOk
                    If (bOk = False) Begin
                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
                        Function_Return False
                    End
                End
            End

            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
                Move (sTableName + ".int") to sPhysicalFile
            End                                            
            Else Begin
                Move (sRootName + ".int") to sPhysicalFile
            End
            Move (Uppercase(sDisplayName)) to sVal
            If (not(sVal contains (sSchema + "."))) Begin
                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
            End
        End
        Move False to Err
        Move 0 to hFile

        Structure_Start hFile sDriverID
            If (sDriverID <> DATAFLEX_ID) Begin
                If (bUseConnectionID = True) Begin
                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
                End
                Else Begin
                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
                End
                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum

                If (sSchema <> "") Begin
                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
                End

                If (sDriverID = DB2_DRV_ID) Begin
                    If (SQLConnection.sLongTableSpace <> "") Begin
                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
                    End
                End
                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
                    If (SQLConnection.sBaseTableSpace <> "") Begin
                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
                    End
                    If (SQLConnection.sIndexTableSpace <> "") Begin
                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
                    End
                End
            End

            Set_Attribute DF_FILE_PHYSICAL_NAME                of hFile to sPhysicalFile
            Send ApiColumnsAddToTable hFile aColumns True
        Structure_End hFile

        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
        If (bMertechDriver = True) Begin
            Move sOriginalDriverID to sDriverID
            If (not(sVal contains (sSchema + "."))) Begin
                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
            End
            // Note: This function also sets the Err flag.
            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
        End

        Move (not(Err)) to bOK
        If (bOk = True) Begin
            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
                Move (sDriverID + ":" + sRootName) to sRootName
            End
            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName

            // Lastly we remove the temporary column we created above, if all went well.
            If (bDeleteDummy) Begin
                Get ApiColumnRemove hTable "temp" to bOk
            End
        End
        
        Close hTable
        Function_Return (bOK = True)
    End_Function

    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
        Boolean bExists

        Move False to Err
        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName

        Function_Return (Err = False)
    End_Function

    // ToDo: Needs to be revised
    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
        Handle hTable
        String sDEFName sDataPath sDriverID
        Boolean bExists

        // Do nothing if MSSQL Driver.
//        Get IsMSSQLDriver to bExists
//        If (bExists = True) Begin
//            Procedure_Return
//        End

        Get psDataPathFirstPart to sDataPath
        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
        If (bExists = True) Begin
            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
            // still be missing from the filelist and needs to be added.
            Get UtilTableNumberIsInUse iFilelistSlot to bExists
            If (bExists = True) Begin
                Procedure_Return
            End
            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
            Else Begin
                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
                Procedure_Return
            End
        End

        Move (sPath + sFileName + ".def") to sDEFName
        Move 0 to hTable
        Move False to Err

        Structure_Start hTable DATAFLEX_ID
            Load_Def sDEFName Onto hTable
            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
        Structure_End hTable DF_STRUCTEND_OPT_NONE

        Move iFilelistSlot to hTable
        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName

    End_Procedure

    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
        Boolean bTmp bErr bOK
        String sTableName sDisplayName sFileName sDBOKeyWord sVal

        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
        Move Err to bTmp
        Move False to Err

        Get AutoConnectionIDLogin to bOK
        // First get the info for the current filelist slot:
        Open iFromFileSlot
        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
        If (bOK = True) Begin
            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName

            //...then move it.
            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName

            //...and finally remove the old filelist values.
            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
        End
        Close iFromFileSlot

        Move Err to bErr
        Move bTmp to Err
        Function_Return (bErr = False)
    End_Function

    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
        Handle hTable
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Open hTableFrom Mode DF_EXCLUSIVE
        If (hTableTo > 0) Begin
            Open hTableTo
        End
        Move hTableFrom to hTable

        Structure_Start hTable
            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
            If (iColumnTo <> 0) Begin
                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
            End
        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE

        Close hTableFrom
        If (hTableTo > 0) Begin
            Close hTableTo
        End

        Function_Return (Err = False)
    End_Function

    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
    Function ApiTableRemove Handle hTable Returns Boolean
        String sTableName sDriverID
        Boolean bOk
        String sDataPath

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get psDriverID to sDriverID
        Get UtilTableHandleToString hTable sDriverID to sTableName
        If (sTableName = "") Begin
            Function_Return False
        End

        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
        Delete_db sTableName
        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE

        If (sDriverID <> DATAFLEX_ID) Begin
            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
            Get psDataPathFirstPart to sDataPath
            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
        End
        // Also remove table from filelist.cfg in case the physical file didn't exist.
        If (hTable <> 0) Begin
            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
        End
        
        Close hTable
        Function_Return (hTable <> 0)
    End_Function

    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
        Handle hTable
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Open hTableTo Mode DF_EXCLUSIVE
        Move hTableTo to hTable

        Structure_Start hTable
            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE

        Close hTableTo
        Function_Return (Err = False)
    End_Function

    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
        String sPhysicalName sDataPath sDriverID
        Boolean bOK bExists
        Integer iRetval

        Move False to Err
        Get psDataPathFirstPart to sDataPath
        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName

        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Close hTable
        If (sDriverID = DATAFLEX_ID) Begin
            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
            If (bExists = True) Begin
                If (Uppercase(sPhysicalName) = Uppercase(sRootName)) Begin
                    Function_Return False
                End
            End
            Copy_db (sDataPath + sPhysicalName) to (sDataPath + sRootName)
        End

        If (sDriverID <> DATAFLEX_ID) Begin
            Move (sDriverID + ":" + sRootName) to sRootName
        End

        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName

        // We need a short break here before attempting to delete the physical file or Windows
        // might report "File in use..." and the deletion will fail.
        Sleep 2
        If (sDriverID = DATAFLEX_ID) Begin
            Get vDeleteFile (sDataPath + sPhysicalName + ".*") to bOK
        End

        Function_Return (Err = False)
    End_Function

    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
        Move False to Err
        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName

        Function_Return (Err = False)
    End_Function                        
    
    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
    // Note that it first removes any driver prefixes in the rootname.
    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
        Boolean bTheSame bIsSQL 
        Handle hTable
        
//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Move APITableInfo.iTableNumber      to hTable
        Get UtilTableIsSQL hTable           to bIsSQL
        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo  
        Get _TableNameOnly sRootNameTo                to sRootNameTo
        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
        
        If (bCompareFilelistUppercase = True) Begin
            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bTheSame                  
        End
        Else Begin
            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bTheSame                  
        End
//        Set Error_Report_Mode to DUF_ERROR_REPORT
            
        Function_Return bTheSame
    End_Function  
    
    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
        Handle hFile hTable 
        String sTableName sLogicalName sDisplayName 
        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
        Integer iColumn iIdentityType iDataType iDbType iCount iSize
        Boolean bOk bExists bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened bSameColumnDefinitions
        Boolean bUseConnectionID bToANSI bRecnum bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase bExistingTable
        Boolean bIsSame bSameTableNames bIsOpen bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
        tSQLConnection SQLConnection  
        tColumnType    ColumnType
        tAPITable      APITableFrom APITableTo
        
        // We don't allow update of the framework's DbVersion table.
        If (Uppercase(sTableName) = "DBVERSION") Begin
            Function_Return False
        End
        
        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
        Get piDbType                            to iDbType
        Get pbUseConnectionID                   to bUseConnectionID
        Get pbRecnum                            to bRecnum
        Get pbToANSI                            to bToANSI
        Get pbCompareDate_DateTime              to bCompareDate_DateTime
        Get pbCompareIndexAscending             to bCompareIndexAscending
        Get pbCompareIndexUppercase             to bCompareIndexUppercase 
        
        Move CS_ANSI_Txt to sANSI_OEM
        If (bToANSI = False) Begin
            Move CS_OEM_Txt to sANSI_OEM
        End
        Move APITableNameInfoFrom.sRootName  to sTableName
        Get _TableNameOnly sTableName        to sTableName
        If (sDriverIDFrom = DATAFLEX_ID) Begin
            Move sTableName to sPhysicalFile
        End

        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
        // is a programmer's error and we auto-correct for it here.
        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
        // set it back and use a Mertech function to convert it to SQL.
        Get IsMertechDriver sDriverIDFrom to bMertechDriver
        If (bMertechDriver = True) Begin
            If (bUseConnectionID = True) Begin
                Move False to bUseConnectionID
            End
            Move sDriverIDFrom to sOriginalDriverID
            Move DATAFLEX_ID to sDriverIDFrom
        End
        
        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
        Move aColumnsFrom                       to APITableFrom.aApiColumns
        Move aIndexesFrom                       to APITableFrom.aApiIndexes
        Move aRelationsFrom                     to APITableFrom.aApiRelations
        Move APITableNameInfoFrom.iTableNumber  to hTable
        Move APITableNameInfoFrom.sRootName     to sRootName
        Move APITableNameInfoFrom.sLogicalName  to sLogicalName
        Move APITableNameInfoFrom.sDisplayName  to sDisplayName
        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
        
        // 'To' table properties:
        Get UtilTableIsAlias hTable             to bIsAliasTo
        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
        If (bIsSQLTableTo = False) Begin
            Move DATAFLEX_ID to sDriverIDTo
        End                                
        Else Begin
            Move sDriverIDFrom to sDriverIDTo
        End
        
        // Does the 'To' table exist in Filelist.cfg _and_ on disk (embedded) or on the SQL back-end.
        Get UtilTableExists  hTable             to bExistingTable
        If (bExistingTable = False and bIsSQLTableFrom = True and bMertechDriver = False) Begin
            Move True                           to bIsSQLTableTo 
            Move sDriverIDFrom                  to sDriverIDTo   
        End
        // Does table exist in Filelist.cfg:
        Get UtilTableNumberIsInUse hTable       to bExistsInFilelist 

        If (bIsSQLTableFrom = False and sDriverIDFrom <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverIDFrom)) Begin
            Move (sDriverIDFrom + ":" + sRootName) to sRootName
        End

        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar   
            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sTableName) * "Number:" * String(hTable))
        End   
        
        // a) The table is an Alias table:
        //
        // If this is an Alias file the Logical or Display name might have changed. Other than that
        // there is nothing that can be updated for an Alias table.
        // But we change all three attributes in case this is a new Alias table.
        If (bIsAliasFrom = True) Begin           
            // ToDo: The first param needs to be paramerized:
            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
            If (bSameTableNames = True) Begin
                Function_Return True
            End
            Else Begin 
                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sTableName
                End                                                           
                Else Begin
                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName  
                End
                Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
                Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName                        
                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
                    Get SqlUtilCreateIntFile hTable sDriverIDFrom sConnectionID True False to bOk
                End
            End  
            Function_Return True
        End                                                           
        
        Move hTable         to APITableTo.ApiTableInfo.iTableNumber
        If (bIsSQLTableTo = True) Begin
            Move sRootName  to APITableTo.ApiTableInfo.sRootName
        End 
        Else Begin
            Move sTableName to APITableTo.ApiTableInfo.sRootName
        End
        
        Move sLogicalName   to APITableTo.ApiTableInfo.sLogicalName
        Move sDisplayName   to APITableTo.ApiTableInfo.sDisplayName
        Move bIsAliasTo     to APITableTo.ApiTableInfo.bIsAlias
        Move bIsSQLTableTo  to APITableTo.ApiTableInfo.bIsSQL
        
        // b) Table exists in Filelist.cfg. We will then compare & check the Filelist.cfg entries for differences.
        If (bExistsInFilelist = True) Begin
            // ToDo: The first param needs to be paramerized:
            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
            If (bSameTableNames = False) Begin
                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
                End
                Else Begin
                    Set_Attribute DF_FILE_ROOT_NAME of hTable to APITableFrom.ApiTableInfo.sRootName
                End
                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableFrom.ApiTableInfo.sLogicalName
                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableFrom.ApiTableInfo.sDisplayName                        
            End  
        End                                     
        
        // c) Both exists in Filelist.cfg and the table exists on disk (embedded) or as an SQL table. 
        //    We then check for differences.
        If (bExistingTable = True) Begin 
            Get UtilColumnsStructFill  hTable to APITableTo.aApiColumns
            Get UtilIndexesStructFill  hTable to APITableTo.aApiIndexes
            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
        
            Move False to bFilelistError
            Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
            // If there was a "Filelist" error (aka the logical names for the 'From' and 'To' tables weren't the same,
            // we will _not_ attempt to make any table changes. An error has by now been generated and will
            // appear in the logfile.
            // Of course, if the tables were the same we also do nothing.
            If (bFilelistError = True or bIsSame = True) Begin
                Set TableName_Text of ghoStatusPanel to ""
                Function_Return True
            End
        End
        
        // d) Create as new Table?
        //
        Move False to Err
        If (bExistingTable = False) Begin
            Get ApiTableCreate hTable sRootName sDisplayName sTableName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
            Function_Return bOk // And we're done.
        End
        
        // e) If we got this far we need to Update the table:
        //    This is the last case (a-e).
        If (ghoProgressBar <> 0) Begin
            Send DoAdvance of ghoProgressBar   
            Set TableName_Text of ghoStatusPanel to ("Updating Table:" * String(sTableName) * "Number:" * String(hTable))
        End
        
        // If an SQL 'To' table we fetch the connection details for login & Schema:
        If (bIsSQLTableTo = True) Begin

            // Get connection properties
            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
            Move SQLConnection.sSchema to sSchema
            If (sSchema = "") Begin
                Get _SqlFindKeyWord CI_SQLDBO to sSchema
            End                                            
            Move SQLConnection.sConnectionID to sConnectionID

            // If a DAW driver and using a connection id we need to check if it exists;
            // else we create it before attempting creating the table
            If (bMertechDriver = False and bUseConnectionID = True) Begin
                Get IsConnectionID sConnectionID sDriverIDFrom to bExists
                If (bExists = False) Begin
                    Get UtilCreateConnectionID sConnectionID to bOk
                    If (bOk = False) Begin
                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
                        Function_Return False
                    End
                End
            End

            Move (sTableName + ".int") to sPhysicalFile
            Move (Uppercase(sDisplayName)) to sVal
            // Pre-face the DisplayName with the schema name;
            // that is how DAW's tools does it.
            If (not(sVal contains (sSchema + "."))) Begin
                Move (Lowercase(sSchema) + "." + sLogicalName) to sDisplayName
            End
        End 
        
        Open hTable Mode DF_EXCLUSIVE
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened = False) Begin
            Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
            Function_Return False
        End
                
        Move False to Err
        Move hTable to hFile

        // This will create new columns or update existing ones.     
        Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
                
        If (bOk = True) Begin             
            If (bExistingTable = False) Begin
                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
                End                                                            
                Else Begin
                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
                End
                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName 
                If (bIsSQLTableTo = True) Begin
                    Get SqlUtilUpdateIntFile hTable to bOk
                End
            End

            // Compare Indexes and if different; either create or change them 
            Get UtilIndexesStructFill hTable to APITableTo.aApiIndexes
            Get UtilIndexesCompare hTable APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
            If (bIsSame = False) Begin
                Get UtilIndexesUpdate hFile APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
            End
            
            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
            Get UtilRelationsCompare hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
            If (bIsSame = False) Begin
                Get UtilRelationsUpdate hFile APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
            End
        End
        
        Close hTable
        Set TableName_Text of ghoStatusPanel to ""

        Function_Return (bOK = True)
    End_Function                                                                                                        

    // *** Field/Column Level Functions: ***
    //
    // Adds a column name to the passed table number.
    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
        Integer iColumn iCount iFile iPrecision
        Boolean bExists bOK bInitializeValue bRetval
        String sDdSrcPath sTableName sColumnValue

        Get UtilColumnExists hTable sFieldName to bExists  
        Move False to Err
        If (bExists = True) Begin
            Function_Return False
        End 
        If (num_arguments > 4) Begin
            Move iPrec to iPrecision
        End
        If (num_arguments > 6) Begin
            Move bInitVal to bInitializeValue
            Move sColVal  to sColumnValue
        End
        If (iType < -1490) Begin
            Move (iType + 1500) to iType
        End
        
        Get AutoConnectionIDLogin to bOK
        Move False to Err
        // Structure_start will change the value of hTable...
        Move hTable to iFile
        Open iFile Mode DF_EXCLUSIVE

        Structure_Start iFile
            Move 0 to iColumn
            Create_Field hTable At iColumn
            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to iLength
            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
        Structure_End iFile

        // If in development environment; create .fd file:
        Open hTable
        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
        If (iCount > 1) Begin
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
        End
        Get vFolderExists sDDSrcPath to bExists
        If (bExists = True) Begin
            Get vFolderFormat sDDSrcPath to sDDSrcPath
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
            Get _TableNameOnly sTableName to sTableName
            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
        End
        
        // Check for a default value
        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
        End
        Close hTable

        Function_Return (Err = False)
    End_Function   
    
//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean 
//        Integer iColumn iCount iFile
//        Boolean bExists bOK  
//        String sDdSrcPath sTableName
//    
//        Get AutoConnectionIDLogin to bOK
//        Move False to Err   
//        
//        // Structure_start will change the value of hTable...
//        Move hTable to iFile
//        Open iFile Mode DF_EXCLUSIVE
//        
//        Structure_Start iFile
//            Send ApiColumnsAddToTable iFile aColumns False
//        Structure_End iFile
//        
//        // If in development environment; create .fd file:
//        Open hTable
//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
//        If (iCount > 1) Begin
//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath    
//        End 
//        Get vFolderExists sDDSrcPath to bExists
//        If (bExists = True) Begin                                   
//            Get vFolderFormat sDDSrcPath to sDDSrcPath 
//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
//            Get _TableNameOnly sTableName to sTableName 
//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
//        End
//        Close hTable
//
//        Function_Return (Err = False)
//    End_Function

    // To update all records for a table column with a fixed value.
    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
        Integer iRecs iCurrErr iField iRecord
        Boolean bRetval bOpen
        
        Move 0 to iRecs                
        Move False to bRetval 
        Move Err to iCurrErr
        Move False to Err
        
        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Open hTable
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
            If (bOpen = False) Begin
                Function_Return bRetval
            End
        End
        
        Field_Map hTable sFieldName to iField
        If (iField <> 0) Begin
            Clear hTable
            Repeat
                Vfind hTable 0 GT
                If (Found) Begin
                    If (ghoStatusPanel <> 0) Begin
                        Get_Field_Value hTable 0 to iRecord
                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
                    End
                    Reread hTable
                        Set_Field_Value hTable iField to sColumnValue
                        SaveRecord hTable
                    Unlock   
                End
           Until (not(Found))
        End
        
        Move (Err = False) to bRetval
        Move iCurrErr to Err
        
        Function_Return bRetval
    End_Function  
    
    Procedure ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating
        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen
        String sFieldName sDriverID sTableName
        
        Get psDriverID to sDriverID                      
        Get piDbType to iDbType
        Get UtilTableHandleToString hTable to sTableName
        Get IsSQLDriver    sDriverID to bIsSQLDriver
        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver                     
        Get UtilTableIsSQL hTable to bIsSqlTable 
        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
            Move True to bIsSqlTable
        End
        Move False to bIsOpen
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        End
        If (bIsOpen = True) Begin
            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
        End 
        Else Begin
            Move True to bRecnumTable
        End
        
        Move (SizeOfArray(aColumns)) to iSize
        Decrement iSize
        for iCount from 0 to iSize   
            Move aColumns[iCount].sFieldName to sFieldName
            If (hTable > 0) Begin    
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
                Move (Trim(sFieldName) <> "") to bFieldExists
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
            End
            Else Begin
                Move False to bFieldExists
            End
            
            If (bFieldExists = False) Begin 
                Move 0 to iColumn
                Create_Field hTable At iColumn                                                   
            End  
            Else Begin
                Move iCount to iColumn
            End
            
            Move                                        iColumn to aColumns[iCount].iFieldNumber
            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName                             

            Move aColumns[iCount].iType to iType
            Move (not(iType < -1490)) to bNativeType
            If (iType < -1490) Begin
                Move (iType + 1500) to iType
            End
            
            If (bIsSqlTable = True) Begin
                If (aColumns[iCount].bIsSQLType = True) Begin
                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iDataFlexType
                    Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType  
                End
                Else Begin
                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
                End
            End
            Else Begin
                If (bCreating = False) Begin
                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
                End
                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
            End
            
            Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
            Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
            
            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
                If (bRecnumTable = False) Begin
                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True 
                End
                
                Move 0 to iIndex 
                Create_Index hTable at iIndex
                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn  
                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
                
                // If we have an identity table - we must create a primary_key table. 
                If (bIsSqlTable = True) Begin
                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True     
                End
            End
        Loop
    End_Procedure

    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
        Integer iCount iSize iColumn iType iIndex iColumnsToSize hFile
        Boolean bFieldExists bNativeType bIsSQLDriver bIsSame bOK bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen
        String sFieldName sTableName sDriverTo
        
        Move False to Err
        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
        Get UtilTableIsSQL hTable to bIsSQLTableTo
        If (bIsSQLTableTo = False) Begin
            Move DATAFLEX_ID to sDriverTo
        End                            
        Else Begin
            Get psDriverID to sDriverTo
        End
        Get UtilTableHandleToString hTable to sTableName
        
        Move (SizeOfArray(aColumnsFrom)) to iSize 
        Move (SizeOfArray(aColumnsTo)) to iColumnsToSize
        Get OpenTableExclusive hTable to bOpened
        
        Decrement iSize
        For iCount from 0 to iSize   
            Move aColumnsFrom[iCount].sFieldName   to sFieldName
            Move aColumnsFrom[iCount].iFieldNumber to iColumn
            If (hTable > 0) Begin                       
                Move False to bFieldExists
                If (iCount < iColumnsToSize) Begin
                    Move aColumnsTo[iCount].sFieldName to sFieldName
                    Move (Trim(sFieldName) <> "") to bFieldExists
                End
            End
            Else Begin
                Move False to bFieldExists
            End
            
            If (bFieldExists = True) Begin     
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Get UtilColumnCompare sDriverIDFrom bIsSQLTableFrom bIsSQLTableTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DateTime to bIsSame
                Set Error_Report_Mode to DUF_ERROR_REPORT
                If (bIsSame = False) Begin  
                    // ToDo: We might need to set more properties for the field than what currently is set...
                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                    Get ApiColumnChangeByColumnNumber sDriverIDFrom bIsSQLTableFrom hTable bIsSQLTableTo aColumnsFrom[iCount].sFieldName aColumnsFrom[iCount].iFieldNumber aColumnsFrom[iCount].iType aColumnsFrom[iCount].iLength aColumnsFrom[iCount].iPrecision aColumnsFrom[iCount].iOptions to bOK
                    Set Error_Report_Mode to DUF_ERROR_REPORT
                End
            End
            
            If (bFieldExists = False) Begin  
                Move False to bIsOpen
                If (hTable > 0) Begin        
                    Close hTable
                    Open hTable Mode DF_EXCLUSIVE
                    Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
                End
                If (bIsOpen = True) Begin
                    Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
                End 
                Else Begin
                    Move True to bRecnumTable
                End

                Move hTable to hFile
                Structure_Start hFile sDriverIDFrom
                    Move aColumnsFrom[iCount].iFieldNumber to iColumn
                    Create_Field hFile At iColumn                                                   
                    Set_Attribute DF_FIELD_NAME   of hFile iColumn to aColumnsFrom[iCount].sFieldName                                 
//                    If (bIsSQLTable = True) Begin
//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength - aColumnsFrom[iCount].iPrecision)
                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to aColumnsFrom[iCount].iLength
//                    End
//                    Else Begin
//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength + aColumnsFrom[iCount].iPrecision)
//                    End
                    
                    If (aColumnsFrom[iCount].iPrecision > 0) Begin
                        Set_Attribute DF_FIELD_PRECISION of hFile iColumn to aColumnsFrom[iCount].iPrecision
                    End
                    
                    Move aColumnsFrom[iCount].iType to iType
                    Move (not(iType < -1490)) to bNativeType
                    If (iType < -1490) Begin
                        Move (iType + 1500) to iType
                    End
                    // ToDo: This test is not enough. Do check for bSQLTableFrom
                    If (bIsSQLTableTo = True) Begin
                        Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
                    End
                    Else Begin
                        Set_Attribute DF_FIELD_TYPE of hFile iColumn to iType
                    End
                    
                    If (aColumnsFrom[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
                        If (bRecnumTable = False) Begin
                            Set_Attribute DF_FIELD_IS_IDENTITY     of hFile iColumn to True 
                        End
                        // If we have an identity table - we must create a primary_key table. 
                        Move 0 to iIndex 
                        Create_Index hFile at iIndex
                        Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn  
                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile iIndex to 1
                        If (bIsSQLDriver = True) Begin
                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True     
                        End
                    End  
                Structure_End hFile
    
            End
        Loop
            
        Function_Return (Err = False)
    End_Function

    // Changes a field type, length and precision for the passed table number and field name
    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
        Boolean bOK bIsSqlTable  
        String sFieldNameTo

        If (num_arguments > 4) Begin
            Move iPrec to iPrecFrom
        End
        If (iTypeFrom < -1490) Begin
            Move (iTypeFrom + 1500) to iTypeFrom
        End
        
        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End  
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        Field_Map hTable sFieldNameFrom to iColumn
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        If (Err = True) Begin
            Function_Return False
        End
        
        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
        Get UtilTableIsSQL hTable to bIsSqlTable
        If (bIsSqlTable = False) Begin
            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
        End
        Else Begin
            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
        End 
        // Let the driver decide the other values;
        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
        
        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
            Function_Return False
        End

        Structure_Start hTable      
            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
            If (bIsSqlTable = False) Begin
                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
            End
            Else Begin
                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
            End
            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    // Changes a field type, length and precision for the passed table number and field name
    Function ApiColumnChangeByColumnNumber String sDriverID Boolean bIsSQLTableFrom Handle hTable Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType
        Boolean bOK bIsSQL bCompareDate_DateTime bSkip
        String sFieldNameTo    
        tColumnType ColumnType
        
        Get pbCompareDate_DateTime to bCompareDate_DateTime
        Get piDbType to iDbType
        If (num_arguments > 4) Begin
            Move iPrec to iPrecFrom                                    
            Move iOpt  to iOptionFrom
        End
        If (iTypeFrom < -1490) Begin
            Move (iTypeFrom + 1500) to iTypeFrom
        End
        
        Get UtilTableIsSql hTable to bIsSQL
        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End  
        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
        
        If (bIsSQLTableTo = True) Begin
            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
        End
        Else Begin
            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
        End
        
        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
        Get_Attribute DF_FIELD_IS_IDENTITY          of hTable iColumn to iOptionTo
        
        // If one of the two tables are SQL and the other Embedded we need to "translate"
        // data types between Embedded and SQL.
        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iTypeFrom
        End
        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeTo   iLengthTo   to iTypeTo
        End
        
        
        If (bCompareDate_DateTime = False) Begin
            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
            If (bSkip = True) Begin
                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
                    Function_Return False
                End
            End
        End
        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
            Function_Return False
        End

        Structure_Start hTable      
            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
            If (bIsSQLTableTo = False) Begin
                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
            End
            Else Begin
                Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iDataFlexType
                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iDataFlexType
                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
            End
            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
            
            If (bIsSQL = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
                Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
            End
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Structure_Start hTable
            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    // To move an existing field to another position in a table.
    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Returns Boolean
        String sColumn sDriverID
        Integer iType iLength iPrecision
        Boolean bOK

        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        If (sDriverID = DFBTRDRV_ID) Begin
            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
            Function_Return False
        End

        Close hTable
        Get AutoConnectionIDLogin to bOK
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType

        If (iType <> DF_DATE) Begin
            Get_Attribute DF_FIELD_LENGTH of hTable iOld to iLength
        End

        If (iType = DF_BCD) Begin
            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
        End
        Move False to Err

        Structure_Start hTable
            Delete_Field hTable iOld
            Create_Field hTable At iNew
            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
            Set_Attribute DF_FIELD_TYPE of hTable iNew to iType

            If (iType <> DF_DATE) Begin
                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
            End

            If (iType = DF_BCD) Begin
                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
            End

            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    // Deletes a column name for the passed table number (and column number).
    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
        Integer iColumn
        Boolean bOK

        Get AutoConnectionIDLogin to bOK 
        Move False to Err
        Close hTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        
        If (not(Err)) Begin
            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
            Field_Map hTable sFieldName to iColumn
            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
            If (Err = True) Begin
                Function_Return False
            End
            Move False to Err
    
            Structure_Start hTable
                Delete_Field hTable iColumn
            Structure_End hTable
        End  
        Else Begin
            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
        End

        Function_Return (Err = False)
    End_Function

    // Renames a field for the passed table number & old field name & new field name
    // Returns True if no errors occured.
    // Sample usage:
    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
        Integer iField
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
        Structure_Start hTable
            Field_Map hTable sOldFieldName to iField
            If (iField > 0) Begin
                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
            End
            Else Begin
                Move 0 to LastErr
                Move False to Err
            End
        Structure_End hTable

        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return (Err = False)
    End_Function

    // *** Index Level Functions: ***
    //
    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
        String sDriverID
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move -1 to iSegment1
        Move -1 to iSegment2
        Move -1 to iSegment3
        Move -1 to iSegment4
        Move -1 to iSegment5
        Move -1 to iSegment6
        Move -1 to iSegment7
        Move -1 to iSegment8
        Move -1 to iSegment9
        Move -1 to iSegment10

        If (num_arguments > 3) Begin
            Move iSgmnt1 to iSegment1
        End
        If (num_arguments > 4) Begin
            Move iSgmnt2 to iSegment2
        End
        If (num_arguments > 5) Begin
            Move iSgmnt3 to iSegment3
        End
        If (num_arguments > 6) Begin
            Move iSgmnt4 to iSegment4
        End
        If (num_arguments > 7) Begin
            Move iSgmnt5 to iSegment5
        End
        If (num_arguments > 8) Begin
            Move iSgmnt6 to iSegment6
        End
        If (num_arguments > 9) Begin
            Move iSgmnt7 to iSegment7
        End
        If (num_arguments > 10) Begin
            Move iSgmnt8 to iSegment8
        End
        If (num_arguments > 11) Begin
            Move iSgmnt9 to iSegment9
        End
        If (num_arguments > 12) Begin
            Move iSgmnt10 to iSegment10
        End

        Move False to Err
        Move hTable to iTableNo
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID

        // We start by deleting the index
        Structure_Start hTable sDriverID
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
            Delete_Index iTableNo iIndex
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
        Structure_End hTable DF_STRUCTEND_OPT_NONE

        Move False to Err
        Move iTableNo to hTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End

        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Structure_Start hTable sDriverID
            Create_Index hTable At iIndex
            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments

            If (iSgmnt1 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
            End
            If (iSegment2 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
            End
            If (iSegment3 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
            End
            If (iSegment4 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
            End
            If (iSegment5 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
            End
            If (iSegment6 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
            End
            If (iSegment7 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
            End
            If (iSegment8 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
            End
            If (iSegment9 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
            End
            If (iSegment10 <> -1) Begin
                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
            End
        Structure_End hTable DF_STRUCTEND_OPT_NONE

        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
//        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return (Err = False)
    End_Function

    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex Integer iIndex tAPIIndexSegment[] aIndexSegments Returns Boolean 
        String[] aFields
        Integer iCount iSize iMax iTableNo iField iSegments
        String sDriverID
        Boolean bOK 

        Move (SizeOfArray(aIndexSegments)) to iSize
        If (iSize = 0) Begin
            Function_Return False                                                            
        End
        Decrement iSize
        
        Move hTable to iTableNo
        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        
        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER 
        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
        Send Ignore_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        // We will only attempt to delete the index in case it exists.
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
        If (iSegments > 0) Begin
            // We start by deleting the index
            Structure_Start hTable sDriverID 
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Delete_Index iTableNo iIndex
                Set Error_Report_Mode to DUF_ERROR_REPORT
            Structure_End hTable DF_STRUCTEND_OPT_NONE
        End
        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER 
        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
        Send Trap_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
        Set Error_Report_Mode to DUF_ERROR_REPORT
        
        Move False to Err
        Move 0 to LastErr
        Move iTableNo to hTable
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
    
        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
        Structure_Start hTable sDriverID
            Create_Index hTable At iIndex
            Set_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndex.sSQLIndexName
            Set_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndex.bIsPrimaryKey
    		Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iSize + 1)
            for iCount from 0 to iSize
                Move aIndexSegments[iCount].iFieldNumber to iField
                If (iField <> -1) Begin 
            		Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iCount + 1) to iField
                End
            Loop
        Structure_End hTable DF_STRUCTEND_OPT_NONE

        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
        Function_Return (Err = False)
    End_Function
    
    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Structure_Start hTable
            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
        Integer iCase
        Boolean bOK

        If (bUppercase = True) Begin
            Move DF_CASE_IGNORED to iCase
        End
        Else Begin
            Move DF_CASE_USED to iCase
        End

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Structure_Start hTable
            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
        Structure_End hTable

        Function_Return (Err = False)
    End_Function

    // To delete an index
    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
        Integer iTableNo iNumSegments
        String sDriverID
        Boolean bOK

        Get AutoConnectionIDLogin to bOK
        Move False to Err
        Move hTable to iTableNo
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID

        // Check to see if the index exists or not...
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
        If (iNumSegments = 0) Begin
            Function_Return False
        End

        Structure_Start hTable sDriverID
            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
            Delete_Index iTableNo iIndex
            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
        Structure_End hTable DF_STRUCTEND_OPT_NONE

        Function_Return (Err = False)
    End_Function

    // Delete an Index Segment
    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
        Boolean bOK bSQLDriver bIndexTemporary
        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
        Integer iIndexType
        String sDriverID 

        Get AutoConnectionIDLogin to bOK
        Move False to Err
    
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        
        // Check to see if the index exists or not...
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
        If (iNumSegments = 0) Begin
            Function_Return False
        End
        
        Move False to bIndexTemporary
        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver) Begin
           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
            #IF (Required_RT_Version > 18)
                Get_Attribute DF_INDEX_TYPE to iIndexType
                Move True to bIndexTemporary
            #ENDIF
        End
    
        // If SQL and Temporary Index must not use Structure_Start/Structure_End
        If (bSQLDriver = True and bIndexTemporary = True) Begin
            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
            If (iSegment = iNumSegments) Begin
                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
            End
            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
                For iCurSegment from iSegment to (iNumSegments - 1)
                    //*** Move index segment attributes
                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
                Loop
                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
            End
        End

        Else Begin
           Structure_Start hTable
               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
               If (iSegment = iNumSegments) Begin
                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
               End
               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
                   for iCurSegment from iSegment to (iNumSegments - 1)
                       //*** Move index segment attributes
                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
                   Loop
                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
               End
           Structure_End hTable
        End
        
        Function_Return (Err = False)
    End_Function
    
    // Add/Insert an Index Segment
    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
        Boolean bOK bSQLDriver bIndexTemporary
        Integer iSQLType iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
        Integer iIndexType
        String sDriverId
        
        Get AutoConnectionIDLogin to bOK
        Move False to Err
    
        Get OpenTableExclusive hTable to bOK
        If (bOK = False) Begin
            Function_Return False
        End
        
        Move False to bIndexTemporary
        // Check to see if the index exists or not...
        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
        If (iNumSegments = 0) Begin
            Function_Return False
        End
    
        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver) Begin
           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
            #IF (Required_RT_Version > 18)
                Get_Attribute DF_INDEX_TYPE to iIndexType
                Move True to bIndexTemporary
            #ENDIF
        End

        // If SQL and Temporary Index must not use Structure_Start/Structure_End
        If (bSQLDriver = True and bIndexTemporary = True) Begin
           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
    
           If (iSegment > iNumSegments) Begin
               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
               Move (iNumSegments + 1) to iCurSegment
           End
           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
               Move iNumSegments to iCurSegment
           
               While (iCurSegment > iSegment)
                   //*** Move index segment attributes
                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
                   Decrement iCurSegment
               End
           
               //*** Now set new segment attributes
               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
           End
        End
        
        Else Begin
           Structure_Start hTable
              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
           
              If (iSegment > iNumSegments) Begin
                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
                  Move (iNumSegments + 1) to iCurSegment
              End
              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
                  Move iNumSegments to iCurSegment
              
                  While (iCurSegment > iSegment)
                      //*** Move index segment attributes
                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
                      Decrement iCurSegment
                  End
              
                  //*** Now set new segment attributes
                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
              End
           Structure_End hTable
        End
        
        Function_Return (Err = False)
    End_Function
    
    // Returns an SQL Driver ID if it appears as a prefix for the passed sRootName
    // If no driver found the DATAFLEX_ID is returned
//    Function UtilDriverIDFromRootName String sRootName Returns String
//        String sDriverID
//        Integer iPos
//        Move (Pos(":", sRootName)) to iPos
//        If (iPos <> 0) Begin
//            Move (Left(sRootName, (iPos -1))) to sDriverID
//        End
//        Else Begin
//            Move DATAFLEX_ID to sDriverID
//        End
//        Function_Return sDriverID
//    End_Function              
    
    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
    // Note that it first removes any driver prefixes in the rootname.
    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfoFrom tAPITableNameInfo APITableInfoTo Returns Boolean
        Boolean bTheSame 
        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
        
        Get _TableNameOnly APITableInfoFrom.sRootName to sRootNameFrom
        Get _TableNameOnly APITableInfoTo.sRootName   to sRootNameTo                                    
        Move APITableInfoFrom.sLogicalName            to sLogicalNameFrom
        Move APITableInfoTo.sLogicalName              to sLogicalNameTo
        Move APITableInfoFrom.sDisplayName            to sDisplayNameFrom
        Move APITableInfoTo.sDisplayName              to sDisplayNameTo
        If (bCompareFilelistUppercase = True) Begin
            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bTheSame
        End
        Else Begin
            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bTheSame                  
        End
            
        Function_Return bTheSame
    End_Function                
    
    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
        Handle hTableFrom hTableTo 
        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase 
        String sRootName sDriverID

        Move False to bFilelistError
        Move True to bIsSame
        Get pbCompareDate_DateTime  to bCompareDate_DateTime
        Get pbCompareIndexAscending to bCompareIndexAscending
        Get pbCompareIndexUppercase to bCompareIndexUppercase
        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo          
        
        Move APITableFrom.ApiTableInfo.sRootName to sRootName
        Get _TableNameOnly sRootName             to sRootName
        Move sRootName to APITableTo.ApiTableInfo.sRootName

        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
        // bCodeGenerateMode = True = Code Generation mode.
        If (bCodeGenerateMode = True) Begin
            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
                Function_Return False
            End
            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
            If (bIsSame = False) Begin   
                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
                Move True to bFilelistError
                Function_Return False
            End
        End
        
        If (bCodeGenerateMode = False) Begin
            // Then we want to create this table
            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
                Function_Return False
            End
                
            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
            If (bIsSame = False) Begin
                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
                Move True to bFilelistError
                Function_Return False
            End
        End

        // Check columns:                        
        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom 
        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverID
        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns  
        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End
        
        // ...then check indexes:
        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
        Get UtilIndexesCompare    hTableFrom APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End
        
        // ...and finally relationships:
        Get UtilRelationStructFill hTableFrom to APITableTo.aApiRelations
        Get UtilRelationsCompare      hTableFrom APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
        
        Function_Return (bIsSame = True)
    End_Function
    
    // Similar to UtilTableCompare, but takes two tAPITable struct arrays as parameters and a apitableboolean struct as params.
    Function UtilTableCompare_Ex tAPITable CompareTableFrom tAPITable CompareTableTo tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
        Handle hTableFrom hTableTo 
        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
        tAPITableNameInfo APITableInfoFrom APITableInfoTo
        tAPIIndex[]    aIndexesFrom   aIndexesTo
        tAPIColumn[]   aColumnsFrom   aColumnsTo
        tAPIRelation[] aRelationsFrom aRelationsTo        
        String sRootName sDriverID
        
        If (CompareTableFrom.ApiTableInfo.iTableNumber < 0 or CompareTableTo.ApiTableInfo.iTableNumber < 0) Begin
            Move True to bFilelistError
            Function_Return False    
        End 
        
        Move True  to bIsSame 
        Move False to bFilelistError
        
        Move CompareTableFrom.ApiTableInfo  to APITableInfoFrom
        Move CompareTableFrom.aApiColumns   to aColumnsFrom
        Move CompareTableFrom.aApiIndexes   to aIndexesFrom
        Move CompareTableFrom.aApiRelations to aRelationsFrom  
        Move APITableInfoFrom.iTableNumber  to hTableFrom 
        Move APITableInfoFrom.bIsSQL        to bIsSQLFrom         
        Move APITableInfoFrom.sDriverID     to sDriverID
        
        Move CompareTableTo.ApiTableInfo    to APITableInfoTo
        Move CompareTableTo.aApiColumns     to aColumnsTo
        Move CompareTableTo.aApiIndexes     to aIndexesTo
        Move CompareTableTo.aApiRelations   to aRelationsTo
        Move APITableInfoTo.iTableNumber    to hTableTo          
        Move APITableInfoTo.bIsSQL          to bIsSQLTo
        
        Move APITableInfoTo.sRootName       to sRootName
        Get _TableNameOnly sRootName        to sRootName

        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
        // bCodeGenerateMode = True = Code Generation mode.
        If (bCodeGenerateMode = True) Begin
            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
            If (Trim(APITableInfoTo.sLogicalName) = "") Begin
                Function_Return False
            End                                                                    
            Move (Uppercase(APITableInfoFrom.sLogicalName) = Uppercase(APITableInfoTo.sLogicalName)) to bIsSame
            If (bIsSame = False) Begin
                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableInfoFrom.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableInfoTo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
                Move True to bFilelistError
                Function_Return False
            End
        End
        
        If (bCodeGenerateMode = False) Begin
            If (Trim(Uppercase(APITableInfoTo.sLogicalName)) = "") Begin
                // Then we might want to create this table
                Function_Return False
            End
            
            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableInfoFrom APITableInfoTo to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End

        // Check columns:         
        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom aColumnsTo CompareTableBooleans.bCompareDate_DateTime to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End
        
        // ...then check indexes:
        Get UtilIndexesCompare hTableFrom aIndexesFrom aIndexesTo CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End
        
        // ...and finally relationships:
        Get UtilRelationsCompare hTableFrom aRelationsFrom aRelationsTo to bIsSame
        
        Function_Return (bIsSame = True)
    End_Function
    
    // Compare multiple columns. (For 'From' & 'To' tables)
    Function UtilColumnsCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
        Boolean bIsSame        
        Integer iCount iSize iSizeFrom iSizeTo iColumn iType iLength
        String sColumnNameFrom sColumnNameTo
        
        Move True to bIsSame
        Move (SizeOfArray(aColumnsFrom)) to iSizeFrom
        Move (SizeOfArray(aColumnsTo))   to iSizeTo
        If (iSizeFrom <> iSizeTo) Begin
            Function_Return False
        End          
        Move (iSizeFrom max iSizeTo)     to iSize 
        Set piMaximum of ghoProgressBar  to iSize
        
        Decrement iSize
        for iCount from 0 to iSize       
            Set piPosition of ghoProgressBar to iCount
            If (iCount <= iSizeFrom and iCount <= iSizeTo) Begin
                Get UtilColumnCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DataTime to bIsSame
            End 
            Else Begin
                Move False to bIsSame
            End
            
            If (bIsSame = False) Begin
                Function_Return False
            End
        Loop
        
        Function_Return (bIsSame = True)
    End_Function
    
    // Compares a single column (For 'From' & 'To' tables)
    Function UtilColumnCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn aColumnsFrom tAPIColumn aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
        Boolean bIsSame 
        Integer iFromType iToType iDbType                    
        tColumnType ColumnType
        
        Get piDbType to iDbType
        Move (aColumnsFrom.iFieldNumber <> 0 and aColumnsTo.iFieldNumber <> 0) to bIsSame
        // Check that _both_ field_number and field_name are the same
        // else they needs to be changed...                                  
        If (bIsSame = False) Begin
            Move (aColumnsFrom.iFieldNumber = aColumnsTo.iFieldNumber) to bIsSame
        End
        If (bIsSame = False) Begin
            Function_Return False
        End
        Move (aColumnsFrom.sFieldName = aColumnsTo.sFieldName) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End
        
        Move aColumnsFrom.iType to iFromType
        Move aColumnsTo.iType   to iToType
        
        // If one of the two tables are SQL and the other Embedded we need to "translate"
        // data types between Embedded and SQL.
        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iFromType aColumnsFrom.iLength to iFromType
        End
        Else If (bIsSQLFrom = False and bIsSQLTo = True) Begin
            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iToType   aColumnsFrom.iLength to iToType
        End
        
        // *** THIS NEEDS TO BE REDONE ***
        
        // Make Date and DateTime comparison?
        If (bCompareDate_DataTime = True and iFromType = DF_DATE or iFromType = DF_DATETIME or iFromType = SQL_TYPE_TIMESTAMP or iFromType = SQL_TYPE_TIMESTAMP2) Begin
            Move (iFromType = iToType) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End
        
        // This is when checking for other field types than dates...
//        If (bCompareDate_DataTime = False and iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
            Move (iFromType = iToType) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
//        End
        
        // If the field is of Date type (any of them) we don't compare length & precision.
        If (iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
            Move (aColumnsFrom.iLength = aColumnsTo.iLength) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End                                               
            Move (aColumnsFrom.iPrecision = aColumnsTo.iPrecision) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End                                               
        End
        
        Move (aColumnsFrom.iOptions = aColumnsTo.iOptions) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End                                               

        Function_Return True
    End_Function
    
    // Compares multiple indexes for a 'From' and a 'To' table.
    Function UtilIndexesCompare Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
        Boolean bIsSame bDAWSQLDriver 
        Integer iCount iSize iSizeFrom iSizeTo iSegment iNumSegments iColumn
        String sIndexNameFrom sIndexNameTo sDriverID sColumnNameFrom
        
        Move True to bIsSame
        Get psDriverID to sDriverID
        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
        
        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
        Move (SizeOfArray(aIndexesTo))   to iSizeTo  
        If (iSizeFrom = 0 and iSizeTo = 0) Begin
            Function_Return True
        End
        If (iSizeFrom <> iSizeTo) Begin
            Function_Return False
        End          
        Move (iSizeFrom max iSizeTo) to iSize

        Decrement iSize
        For iCount from 0 to iSize 
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Get UtilIndexCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
            Set Error_Report_Mode to DUF_ERROR_REPORT
            If (bIsSame = False) Begin
                Function_Return False
            End
        Loop
        
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return bIsSame
    End_Function
    
    // Compares a single index for a 'From' and a 'To' table.
    Function UtilIndexCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
        Boolean bIsSame bDAWSQLDriver bIsSqlTable
        String sDriverID  
        Integer iSegment
        
        Move True to bIsSame
        Get psDriverID to sDriverID
        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
        Get IsSQLDriver sDriverID to bIsSqlTable
        If (bIsSqlTable = True) Begin
            Get UtilTableIsSQL hTable to bIsSqlTable
        End
        
        Move True to bIsSame
        If (bIsSqlTable = True) Begin
            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
            Move (aIndexFrom.bIsPrimaryKey = aIndexTo.bIsPrimaryKey) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
            Move (aIndexFrom.sSQLIndexName = aIndexTo.sSQLIndexName) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
        Set Error_Report_Mode to DUF_ERROR_REPORT
        If (bIsSame = False) Begin
            Function_Return False
        End                      
        
        Get UtilIndexSegmentsCompare aIndexFrom aIndexTo bCompareIndexUppercase bCompareIndexAscending to iSegment
        If (iSegment = -1) Begin
            Move True to bIsSame
        End  
        Else Begin                                                         
            Move True to aIndexTo.bShouldChange
            Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
        End
        
        Function_Return (bIsSame = True)
    End_Function
    
    // Compares each segment for the passed index.
    // Returns -1 if same; else returns the index segment that differs.
    Function UtilIndexSegmentsCompare tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment                                                
        Boolean bIsSame
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Move (SizeOfArray(aIndexFrom.IndexSegmentArray)) to iNumSegmentsFrom
        Move (SizeOfArray(aIndexTo.IndexSegmentArray))   to iNumSegmentsTo
        Move (iNumSegmentsFrom max iNumSegmentsTo)       to iNumSegments
        
        Decrement iNumSegments
        for iSegment from 0 to iNumSegments  
            Move False to bIsSame
            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
                Get UtilIndexSegmentCompare aIndexFrom.IndexSegmentArray[iSegment] aIndexTo.IndexSegmentArray[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
            End
            If (bIsSame = False) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Move True to aIndexTo.bShouldChange
                Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
                Function_Return iSegment
            End
        Loop             
        
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return -1 // This means bIsSame = True
    End_Function
    
    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
        Integer iNumSegments iSegment                                                
        Boolean bIsSame

        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
        If (bIsSame = False) Begin
            Function_Return False
        End
        If (bCompareIndexUppercase = True) Begin
            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End
        If (bCompareIndexAscending = True) Begin
            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
            If (bIsSame = False) Begin
                Function_Return False
            End
        End
        
        Function_Return True
    End_Function
    
    // This is the same as the UtilIndexCompare function _except_ it only checks if the Index type and number are equal or not.
    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
        Boolean bIsSame bDAWSQLDriver bIsSqlTable
        Integer iCount iSize iSegment iNumSegments iIndexSegment
        String sDriverID 
        
        Move True to bIsSame
        Get psDriverID to sDriverID
        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
        Get IsSQLDriver sDriverID to bIsSqlTable
        If (bIsSqlTable = True) Begin
            Get UtilTableIsSQL hTable to bIsSqlTable
        End
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Move True to bIsSame
        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
            // Don't think we should do this. Or should we?
            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
            If (bIsSame = False) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Function_Return False
            End
        End
        
        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
        Set Error_Report_Mode to DUF_ERROR_REPORT
        If (bIsSame = False) Begin
            Function_Return False
        End                      
        
        Function_Return bIsSame
    End_Function
    
    // Compares multiple relationships for a 'From' and a 'To' table
    Function UtilRelationsCompare Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
        Boolean bIsSame
        Integer iSize iCount
        
        Move True to bIsSame
        Move (SizeOfArray(aRelationsFrom)) to iSize
        Decrement iSize
        For iCount from 0 to iSize   
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
            Set Error_Report_Mode to DUF_ERROR_REPORT
            If (bIsSame = False) Begin
                Function_Return False
            End
        Loop
        
        Function_Return bIsSame
    End_Function

    // Compares a single relationship for a 'From' and a 'To' table
    Function UtilRelationCompare Handle hTable tAPIRelation aRelationsFrom tAPIRelation aRelationsTo Returns Boolean
        Boolean bIsSame
        Integer iSize iCount
        
        Move True to bIsSame
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Move (aRelationsFrom.hTableFrom = aRelationsTo.hTableFrom) to bIsSame
        If (bIsSame = False) Begin
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Function_Return False
        End
        Move (aRelationsFrom.hTableTo = aRelationsTo.hTableTo) to bIsSame
        If (bIsSame = False) Begin
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Function_Return False
        End
        Move (aRelationsFrom.iColumnFrom = aRelationsTo.iColumnFrom) to bIsSame
        If (bIsSame = False) Begin
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Function_Return False
        End
        
        Move (aRelationsFrom.iColumnTo = aRelationsTo.iColumnTo) to bIsSame
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return bIsSame
    End_Function

    // This message is different from ApiTableCreate in that it will not do a function_return if the table
    // already exists. Instead it checks if the table needs to be updated with any of the struct arrays,
    // for fields, indexes or relations.
    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
        Boolean bIsSame bOK
        Integer iSize iCount 
        
        Move True to bOK
        Move (SizeOfArray(aRelationsFrom)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
            Set Error_Report_Mode to DUF_ERROR_REPORT
            If (bIsSame = False) Begin
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo to bOK
                Set Error_Report_Mode to DUF_ERROR_REPORT
            End
        Loop
        
        Function_Return bOK
    End_Function
    
    Function UtilIndexesUpdate Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
        Boolean bIsSame bOK
        Integer iSizeFrom iSizeTo iCount iIndexSegment                   
        String sIndexFields
        
        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
        Move (SizeOfArray(aIndexesTo))   to iSizeTo 
        Decrement iSizeTo
        Decrement iSizeFrom
        for iCount from 0 to iSizeFrom
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Get UtilIndexTypeNumberCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] to bIsSame
            Set Error_Report_Mode to DUF_ERROR_REPORT
            If (bIsSame = False and iSizeTo <> 0 and iCount <= iSizeTo) Begin
                Get APIIndexCreateByFieldNames hTable iCount aIndexesFrom[iCount] aIndexesFrom[iCount].IndexSegmentArray to bOK
            End
            If (bIsSame = True) Begin
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT 
                Move 0 to iIndexSegment
                Get UtilIndexSegmentsCompare aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to iIndexSegment
                Set Error_Report_Mode to DUF_ERROR_REPORT
                If (iIndexSegment <> -1) Begin
                    Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount].iIndexNumber aIndexesFrom[iCount].IndexSegmentArray to bOK
                End
            End
        Loop
    
        Function_Return bOK
    End_Function  
    
//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
//        String sFieldName sDriverID
//        
//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
//        If (bIsOpen = False) Begin
//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
//            Open hTable
//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
//            If (bIsOpen = False) Begin
//                Function_Return False
//            End
//        End
//
//        Move True to bEqual
//        Get psDriverID to sDriverID
//        Get IsSQLDriver    sDriverID to bSqlDriver
//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
//        Move (SizeOfArray(aColumns)) to iSize
//        Decrement iSize   
//        
//        For iCount from 0 to iSize
//            Move 0 to iOptions    
//            Move False to bIdentityKey
//            Move aColumns[iCount].sFieldName to sFieldName               
//            
//            // We need to use the column name - not the column integer as
//            // the order does not need to be the same, and the logic should still work.
//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
//            If (iColumn > 0) Begin
//                If (bDawSqlDriver = True) Begin
//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
//                    If (iType <> aColumns[iCount].iType) Begin
//                        Move False to bEqual
//                    End
//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
//                    If (bIdentityKey = True) Begin
//                        Move C_tAPIColumn_Identity to iOptions
//                    End
//                    If (iOptions <> aColumns[iCount].iOptions) Begin
//                        Move False to bEqual
//                    End
//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
//                End
//                Else Begin
//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
//                    If (iType <> aColumns[iCount].iType) Begin
//                        Move False to bEqual
//                    End
//                End
//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
//                If (iLength <> aColumns[iCount].iLength) Begin
//                    Move False to bEqual
//                End
//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
//                    Move False to bEqual
//                End
//                If (bEqual = False) Begin
//                    Function_Return False
//                End
//            End
//                    
//            Else Begin
//                Function_Return False
//            End
//        Loop
//        
//        Function_Return bEqual
//    End_Function  
    
    // To fill a complete Table structure (tAPITable) with data.
    // The data + filelist.cfg path, login et al must have been setup properly first.
    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
    Function UtilTableStructFill Boolean bStatusPanel Boolean bFromTables Returns tAPITable[]
        tAPIColumn[]    aApiColumns   
        tAPIIndex[]     aApiIndexes   
        tAPIRelation[]  aApiRelations 
        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
        Handle hTable
        Integer iCount iPos 
        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
        String sLogicalName sRootName sDisplayName sTableName sDriverID
        
        Move 0 to hTable    
        If (bFromTables = True) Begin
            Set Message_Text of ghoStatusPanel to "Reading 'From' Table Structure:"
        End 
        Else Begin
            Set Message_Text of ghoStatusPanel to "Reading 'To' Table Structure:"
        End
        Get UtilFilelistNoOfTables to iCount
        Set piMaximum of ghoProgressBarOverall to iCount
        Move 0 to iCount                                
        
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0 and hTable <> 50) Begin           
                Get_Attribute DF_FILE_ROOT_NAME of hTable    to sRootName   
                Get _TableNameOnly sRootName                 to sTableName
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName   
                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
                Get UtilTableOpen hTable sTableName DF_SHARE to bIsOpen
                Get_Attribute DF_FILE_DRIVER       of hTable to sDriverID
                Set piPosition of ghoProgressBarOverall to iCount
                Set Action_Text of ghoStatusPanel  to (sTableName * "Number:" * String(hTable))
                
                Get UtilColumnsStructFill  hTable to aApiColumns
                Get UtilIndexesStructFill  hTable to aApiIndexes
                Get UtilRelationStructFill hTable to aApiRelations
                Get UtilTableIsAlias       hTable to bIsAlias  
                Get UtilTableIsSQL         hTable to bIsSQL
                
                Move hTable                                  to aApiTables[iCount].ApiTableInfo.iTableNumber
                Move sRootName                               to aApiTables[iCount].ApiTableInfo.sRootName
                Move sLogicalName                            to aApiTables[iCount].ApiTableInfo.sLogicalName
                Move sDisplayName                            to aApiTables[iCount].ApiTableInfo.sDisplayName
                Move sDriverID                               to aApiTables[iCount].ApiTableInfo.sDriverID
                Move bIsAlias                                to aApiTables[iCount].ApiTableInfo.bIsAlias
                Move bIsSQL                                  to aApiTables[iCount].ApiTableInfo.bIsSQL
                Move aApiColumns                             to aApiTables[iCount].aApiColumns
                Move aApiIndexes                             to aApiTables[iCount].aApiIndexes
                Move aApiRelations                           to aApiTables[iCount].aApiRelations
                Increment iCount
            End     
            
            If (bStatusPanel = True) Begin
                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
                If (bUserCancel = True) Begin
                    Send Stop_StatusPanel of ghoStatusPanel
                    Function_Return aApiTablesEmpty
                End
            End

        Until (hTable = 0)    
    
        Function_Return aApiTables    
    End_Function

    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
        tAPIColumn[] APIColumns APIColumnsEmpty
        String sDriverID sFieldName sRootName sLogicalName sValue
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
        Get piDbType to iDbType
        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
        Open hTable
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Open hTable
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
            If (bIsOpen = False) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT 
                Function_Return APIColumnsEmpty
            End
        End
        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
        Get IsSQLDriver    sDriverID to bSqlDriver
        Get IsDAWSQLDriver sDriverID to bDawSqlDriver       
        
        If (sDriverID <> DATAFLEX_ID) Begin
            Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
            If (bIsSqlTable = True) Begin
                Get UtilTableExists hTable to bExists
                If (bExists = False) Begin
                    Function_Return APIColumnsEmpty
                End
            End                                    
        End
        
        Move 0 to iCount
        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
        Set piMaximum of ghoProgressBar to iNumColumns
        
        for iColumn from 1 to iNumColumns
            Move 0 to iOptions       
            Move False to bIdentityKey         
            Move False to Err
            Move 0     to LastErr     
            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
            Set piPosition of ghoProgressBar to iColumn
            If (bDawSqlDriver = True) Begin
                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE   
                If (bIsSqlTable = True) Begin
                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
                End
                Else Begin
                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType 
                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
                End
                
                // If the array value is out of bounce it means that this column doesn't exist on the backend.
                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
                Move (iCheckFieldNumber >= 0) to bExists
                If (bExists = False) Begin
                    Move 0 to APIColumns[iCount].iType
                End
                If (bExists = True) Begin
                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey                
                End
                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
                If (bIdentityKey = True) Begin
                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
                End
            End
            Else Begin
                Move False to Err
                Move 0     to LastErr
                If (bIsSqlTable = True) Begin
                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
                End
                Else Begin
                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
                End
                // If the array value is out of bounce it means that this column doesn't exist on the backend.
                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists           
                If (bExists = False) Begin
                    Move 0 to APIColumns[iCount].iType
                End
            End
            
            If (bExists = True) Begin                                                          
                Move iColumn to APIColumns[iCount].iFieldNumber
                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems. 
//                If (bIsSqlTable = True) Begin
//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
//                End
                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
                
                // If the length was zero we might have an Overlap(!) field.
                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
                If (APIColumns[iCount].iLength = 0) Begin
                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
                    If (iType = DF_OVERLAP) Begin
                        Move 0 to APIColumns[iCount].iFieldNumber
                        Move 0 to APIColumns[iCount].iLength
                        Move 0 to APIColumns[iCount].iOptions
                        Move 0 to APIColumns[iCount].iPrecision
                        Move DF_OVERLAP to APIColumns[iCount].iType
                        Move "" to APIColumns[iCount].sFieldName
                        Decrement iCount
                    End                                                          
                End
            End
            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
            If (bUserCancel = True) Begin
                Send Stop_StatusPanel of ghoStatusPanel
                Send Info_Box "Process interrupted..."
                Function_Return APIColumnsEmpty
            End
            Increment iCount
        Loop
        
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return APIColumns                          
    End_Function        
    
    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
        tAPIIndex[] APIIndexes
        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn iIndexType iCase
        String sDriverID
        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsPrimaryKey
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Get psDriverID to sDriverID
        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver 
        Get UtilTableIsSQL hTable to bIsSQLTable
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
            Open hTable
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
            If (bIsOpen = False) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Function_Return APIIndexes
            End
        End
        
        Move 0 to iCount
        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
        for iIndex from 1 to iIndexes                                              
            // This is a test that the index exists as there might be "holes" aka the index
            // numbers doesn not need to be consequitive:
            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
            If (iNumSegments > 0) Begin
            
                Move iIndex to APIIndexes[iCount].iIndexNumber    
                If (bIsSQLTable = True) Begin
                    Get_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndexes[iCount].sSQLIndexName
                    Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsPrimaryKey
                End
    
                Move 0 to iSegmentCount
                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments       
                for iSegment from 1 to iNumSegments     
                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
                    Increment iSegmentCount
                Loop                                                                                       
            End
    
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Increment iCount
        Loop                              
        
        Function_Return APIIndexes
    End_Function
    
    Function UtilRelationStructFill Handle hTable Returns tAPIRelation[]
        tAPIRelation[] APIRelations
        Integer iColumn iNumColumns iCount
        Handle hParent 
        Boolean bIsOpen
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Move 0 to iCount
        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
        If (bIsOpen = False) Begin
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Open hTable
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
            If (bIsOpen = False) Begin
                Set Error_Report_Mode to DUF_ERROR_REPORT
                Function_Return APIRelations
            End
        End

        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
        For iColumn from 1 to iNumColumns
            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
            If (hParent <> 0) Begin
                Move (String(hTable))  to APIRelations[iCount].hTableFrom
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APIRelations[iCount].sLogicalNameFrom
                Move (String(iColumn)) to APIRelations[iCount].iColumnFrom                          
                Get_Attribute DF_FIELD_NAME of hTable iColumn to APIRelations[iCount].sFieldNameFrom

                Move (String(hParent)) to APIRelations[iCount].hTableTo
                Get_Attribute DF_FILE_LOGICAL_NAME of hParent to APIRelations[iCount].sLogicalNameTo
                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to APIRelations[iCount].iColumnTo
                Get_Attribute DF_FIELD_NAME of hTable APIRelations[iCount].iColumnTo to APIRelations[iCount].sFieldNameTo
                Increment iCount
            End         
        Loop                                                    
        
        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return APIRelations
    End_Function
    
    // Checks if a field name exists in a table definition
    // Returns True if it does
    // Sample:
    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
        Integer iNumColumns iColumn
        String sColumn
        Boolean bExists bOK bOpen

        Get AutoConnectionIDLogin to bOK
        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
        Open hTable
        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Function_Return False
        End

        Move False to bExists
        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
        for iColumn from 1 to iNumColumns
            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
                Move iNumColumns to iColumn
                Move True to bExists
            End
        Loop
        Close hTable

        Function_Return bExists
    End_Function
    
    // Returns the field/column number for the passed FieldName as an integer.
    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
        Integer iNumColumns iColumn iRetval
        String sColumn
        Boolean bExists bOK bOpen

        Get AutoConnectionIDLogin to bOK
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
        Open hTable
        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Set Error_Report_Mode to DUF_ERROR_REPORT
            Function_Return False
        End
        
        Move 0 to iColumn                  
        Move 0 to iRetval
        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
        for iColumn from 1 to iNumColumns
            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
                Move iColumn to iRetval
                Move iNumColumns to iColumn
            End
        Loop
        Close hTable

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return iRetval
    End_Function

    // Checks if the current psConnectionID is logged in; if not
    // attempts to make a login.
    // Because
    // Returns True if already logged in or the new login was successful.
    // *** Utility Messages ***
    //
    //
    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
        Boolean bError bFound

        Move False to Err
        Open CodeMast
        Open CodeType

        If (bCodeType = True) Begin
            Clear CodeType
            Move sTypeValue to CODETYPE.Type
            Find eq CODETYPE.Type
            Move (Found = True) to bFound
            If (bFound = True) Begin
                Reread CodeType
            End
            If (bFound = False) Begin
                Clear CodeType
            End
                Move sTypeValue to CODETYPE.Type
                Move sValue2    to CODETYPE.Description
                Move sValue3    to CODETYPE.Comment
                SaveRecord CODETYPE
            If (bFound = True) Begin
                Unlock
            End
        End

        If (bCodeType = False) Begin
            Clear CODEMAST
            Move sTypeValue to CODEMAST.Type
            Move sValue2    to CODEMAST.Code
            Find eq CODEMAST.Code
            Move (Found = True) to bFound
            If (bFound = True) Begin
                Reread CODEMAST
            End
            If (bFound = False) Begin
                Clear CODEMAST
            End
                Move sTypeValue to CODEMAST.Type
                Move sValue2    to CODEMAST.Code
                Move sValue3    to CODEMAST.Description
                SaveRecord CODEMAST
            If (bFound = True) Begin
            Unlock
            End
        End

        Close CodeMast
        Close CodeType

        Function_Return (Err = False)
    End_Function

    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
    // CodeType and then spins through all CodeMast records to change all related records.
    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
        Boolean bFound

        Move False to Err
        Open CodeMast
        Open CodeType

        Clear CodeType
        Move sFromValue to CODETYPE.Type
        Find eq CODETYPE.Type
        If (Found = True) Begin
            Reread CODETYPE
                Move sToValue to CODETYPE.Type
                SaveRecord CODETYPE
            Unlock
        End

        Clear CODEMAST
        Find gt CODEMAST by Recnum
        While (Found = True)
            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
            If (bFound = True) Begin
                Reread CODEMAST
                    Move sToValue to CODEMAST.Type
                    SaveRecord CODEMAST
                Unlock
            End
            Find gt CODEMAST by Recnum
        Loop

        Close CodeMast
        Close CodeType

        Function_Return (Err = False)
    End_Function

    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
        Boolean bError bFound

        Move False to Err
        Open CodeMast

        Clear CODEMAST
        Move sTypeValue to CODEMAST.Type
        Move sValue2    to CODEMAST.Code
        Find eq CODEMAST.Code
        Move (Found = True) to bFound
        If (bFound = True) Begin
            Delete CODEMAST
        End

        Close CodeMast

        Function_Return (Err = False)
    End_Function

    // Note:
    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
    // In most cases the back end name will be the same as the table name used in DataFlex.
    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
    Function UtilTableHandleToString Handle hTable Returns String
        String sTableName
        Boolean bOpen bExists bRecnum bOK

        Get UtilTableNumberIsInUse hTable to bExists
        If (bExists = False) Begin
            Function_Return ""
        End

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Get AutoConnectionIDLogin to bOK
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            Open hTable
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
        End
        If (bOpen = True) Begin
            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
            // If blank it is an embedded table:
            If (sTableName = "") Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move 0 to LastErr
                Move False to Err
            End
            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
        End
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return sTableName
    End_Function

    // Returns the filenumber for the passed Table name from Filelist.cfg.
    // Returns 0 if unsuccessful.
    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
    Function UtilTableNameToHandle String sTableName Returns Integer
        String sValue sPrefixTableName sDriverID
        Handle hTable hRetval

        Get psDriverID to sDriverID
        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
            Move (sDriverID + ":" + sTableName) to sPrefixTableName
        End
        Move 0 to hTable
        Move 0 to hRetval
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
                    Move hTable to hRetval
                    Move 0 to hTable
                End
            End
        Until (hTable = 0)

        Function_Return hRetval
    End_Function

    // Check if the file exists in the Data folder,
    // else creates it from memory as it has been compiled into the program as a resource:
    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
        String sPath sDataPath
        Boolean bExists

        Get psDataPathFirstPart to sPath
        Move (sPath + sFileName) to sFileName
        Get vFilePathExists sFileName to bExists

        If (bExists = False) Begin
            // Read from memory & create file on disk.
            Send SqlUtilCreateFileFromMemory sResourceName sFileName
            Get vFilePathExists sFileName to bExists
        End
        Function_Return bExists
    End_Function

    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
    // The reciprocal function of UtilColumnTypeToInteger.
    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
        tColumnType RetvalType

        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
        Function_Return RetvalType.iType
    End_Function

    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
    // The reciprocal function of UtilColumnTypeToString.
    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
        tColumnType RetvalType
        String sValue

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Function_Return RetvalType.sType
    End_Function

    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
        tColumnType RetvalType 
        Integer iRetval
        
        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Move RetvalType.iDataFlexType to iRetval
        If (RetvalType.iDataFlexType = DF_TEXT) Begin
            If (iLength <= 255) Begin
                Move DF_ASCII to iRetval
            End
        End                             
        Function_Return iRetval
    End_Function

    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
        tColumnType RetvalType
        String sValue

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Function_Return RetvalType.sPrecision
    End_Function

    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
        tColumnType RetvalType
        String sValue

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Function_Return RetvalType.bFixedSize
    End_Function

    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
        tColumnType RetvalType
        String sValue
        Integer iRetval iPos

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Move RetvalType.sPrecision to sValue
        Move (Pos(".", sValue)) to iPos
        If (iPos <> 0) Begin
            Move (Left(sValue, (iPos -1))) to iRetval
        End
        Else Begin
            Move sValue to iRetval
        End
        Function_Return iRetval
    End_Function

    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
        tColumnType RetvalType
        String sValue
        Integer iRetval iPos

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Move RetvalType.sPrecision to sValue
        Move (Pos(".", sValue)) to iPos
        If (iPos = 0) Begin
            Function_Return 0
        End
        Move (Mid(sValue, 99, (iPos + 1))) to iRetval

        Function_Return iRetval
    End_Function

    // The default value used for a datatype as specified in the driver int file.
    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
        String sRetval sServer
        tColumnType RetvalType
        Integer iDriver iDataFlexType
        Handle hDatabase

        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
        Move RetvalType.iDataFlexType to iDataFlexType
        Get DriverIndex sDriverID to iDriver
        Get psServer to sServer
        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
        If (hDatabase = 0) Begin
            Function_Return ""
        End

        Case Begin
            Case (iDataFlexType = DF_ASCII)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_BCD)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_BINARY)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_DATE)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_DATETIME)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
                Case Break
            Case (iDataFlexType = DF_TEXT)
                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
                Case Break
            Case Else
                Move "" to sRetval
        Case End

        Function_Return sRetval
    End_Function 
    
    Procedure Set DF_DATABASE_DEFAULT_DEFAULT_DATE_DUF String sDateValue
        String sDriverID sRetval sServer
        tColumnType RetvalType
        Integer iDbType iDriver iDataFlexType
        Handle hDatabase
        
        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        Get DriverIndex sDriverID to iDriver
        Get psServer to sServer
        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
        If (hDatabase = 0) Begin
            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database."
            Procedure_Return
        End                      
        
        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue

    End_Procedure

    Procedure Set DF_DATABASE_DEFAULT_DEFAULT_DATETIME_DUF String sDateValue
        String sDriverID sRetval sServer
        tColumnType RetvalType
        Integer iDbType iDriver iDataFlexType
        Handle hDatabase
        
        Get psDriverID to sDriverID
        Get piDbType   to iDbType
        Get DriverIndex sDriverID to iDriver
        Get psServer to sServer
        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
        If (hDatabase = 0) Begin
            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
            Procedure_Return
        End                      
        
        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue

    End_Procedure

    // Returns a struct array with the default column types for the SQL back-end and how they
    // are mapped to the standard DataFlex data types.
    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
        tColumnType[] ColumnTypeArray EmptyArray
        String sDataType
        Integer iDataType iDriverID iCount  
        Boolean bSQLDriver

        Move 0 to iCount
        Get DriverIndex sDriverID to iDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver = False) Begin
            Function_Return EmptyArray
        End

        // DF_ASCII
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sType
        Move iDataType   to ColumnTypeArray[iCount].iType
        Increment iCount

        // DF_BINARY
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sType
        Move iDataType   to ColumnTypeArray[iCount].iType
        Increment iCount

        // DF_DATE
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sType
        Move iDataType   to ColumnTypeArray[iCount].iType
        Increment iCount

        // DF_DATETIME
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sType
        Move iDataType   to ColumnTypeArray[iCount].iType
        Increment iCount

        // DF_NUMERIC
        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
        // we make them here all "Numeric"... 
        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                Move SQL_NUMERIC to iDataType 
                Move "numeric"   to sDataType
                Case Break
            Case (sDriverID = DB2_DRV_ID)
                Move SQL_NUMERIC to iDataType
                Move "NUMERIC"   to sDataType
                Case Break                   
            Case (sDriverID = SQLFLEX)
                Move eSQLServer_NUMERIC to iDataType
                Move "numeric"   to sDataType
                Case Break                   
            Case (sDriverID = MDSMySQL)
                Move eMySQL_DECIMAL to iDataType
                Move "decimal"   to sDataType
                Case Break       
            Case (sDriverID = ORAFLEX)
                Move eOracle_NUMBER to iDataType
                Move "NUMBER"   to sDataType
                Case Break       
            Case (sDriverID = MDSPgSQL)
                Move ePgSQL_FLOAT4 to iDataType
                Move "decimal"   to sDataType
                Case Break       
            Case Else
                Move DF_BCD      to iDataType
                Move "Numeric"   to sDataType
        Case End
        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sType
        Move iDataType   to ColumnTypeArray[iCount].iType
        Increment iCount

        // DF_TEXT
        If (sDriverID = ODBC_DRV_ID) Begin
            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
        End
        Else Begin
            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
        End
        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
        Move sDataType   to ColumnTypeArray[iCount].sType
        Move iDataType   to ColumnTypeArray[iCount].iType

        Function_Return ColumnTypeArray
    End_Function 
    
    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
        tColumnType[] ColumnTypeArray
        tColumnType   ColumnType 
        Integer iCount iSize
        
        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
        Move (SizeOfArray(ColumnTypeArray)) to iSize
        Decrement iSize
        
        for iCount from 0 to iSize
            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
                Move ColumnTypeArray[iCount].bFixedSize     to ColumnType.bFixedSize
                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
                Move ColumnTypeArray[iCount].iType          to ColumnType.iType
                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
                Move ColumnTypeArray[iCount].sType          to ColumnType.sType
                Move iSize to iCount
            End
        Loop
        
        Function_Return ColumnType
    End_Function

    // Returns a struct with the default column types for the SQL back-end and how they
    // are mapped to a framework DataFlex data type.
    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
        tColumnType ColumnType
        String sDataType
        Integer iDriverID iDataType iCount

        Move 0 to iCount
        Get DriverIndex sDriverID to iDriverID
            
        Case Begin
            // DF_ASCII
            Case (iType = DF_ASCII_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType 
                End
                Move DF_ASCII    to ColumnType.iDataFlexType
                Move "ASCII"     to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sType
                Move DF_ASCII    to ColumnType.iType
                Move False       to ColumnType.bFixedSize
                Case Break
                
            // DF_BINARY
            Case (iType = DF_BINARY_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_BINARY   to ColumnType.iDataFlexType
                Move "Binary"    to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sType
                Move DF_BINARY   to ColumnType.iType
                Move False       to ColumnType.bFixedSize
                Case Break
    
            // DF_DATE
            Case (iType = DF_DATE_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_DATE     to ColumnType.iDataFlexType
                Move "Date"      to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sType
                Move DF_DATE     to ColumnType.iType
                Move True        to ColumnType.bFixedSize
                Case Break
    
            // DF_DATETIME       
            Case (iType = DF_DATETIME_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_DATETIME to ColumnType.iDataFlexType
                Move "DateTime"  to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sType
                Move DF_DATETIME to ColumnType.iType
                Move True        to ColumnType.bFixedSize
                Case Break
    
            // DF_NUMERIC
            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
            // we make them here all "Numeric"...
            // If (sDriverID = ODBC_DRV_ID) Begin
            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
            // End
            // Else Begin
            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
            // End 
            // ToDo: How should we find the best "Numeric" data type here?
            Case (iType = DF_BCD_DUF)
                Move DF_BCD      to ColumnType.iDataFlexType
                Move "Numeric"   to ColumnType.sDataFlexType
                Move "Numeric"   to ColumnType.sType
                Move SQL_NUMERIC to ColumnType.iType
                Move False       to ColumnType.bFixedSize
                Case Break
                
            // DF_TEXT
            Case (iType = DF_TEXT_DUF)
                If (sDriverID = ODBC_DRV_ID) Begin
                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
                End
                Else Begin
                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
                End
                Move DF_TEXT     to ColumnType.iDataFlexType
                Move "Text"      to ColumnType.sDataFlexType
                Move sDataType   to ColumnType.sType
                Move DF_TEXT     to ColumnType.iType
                Move False       to ColumnType.bFixedSize
                Case Break
                
            Case Else
                Move -1999       to ColumnType.iDataFlexType
                Move "Undefined" to ColumnType.sDataFlexType
                Move "Undefined" to ColumnType.sType
                Move -1999       to ColumnType.iType
                Move True        to ColumnType.bFixedSize

        Case End

        Function_Return ColumnType
    End_Function

    Function UtilDeleteCacheFile String sTableName Returns Boolean
        String sDataPath sDriverID
        Boolean bMertechDriver bOK
        Integer iPos

        If (sTableName contains ".") Begin
            Move (Pos(".", sTableName)) to iPos
            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
        End

        Get psDriverID to sDriverID
        Get psDataPathFirstPart to sDataPath
        Get IsMertechDriver sDriverID to bMertechDriver
        // First delete the cache file:
        If (bMertechDriver = False) Begin
            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
        End
        Else Begin
            Get _MertechDeleteTDFile sTableName to bOK
        End

        Function_Return bOK
    End_Function

    // Changes source code files.
    // Pass a file name with full path and a value to search for, together with the value
    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
    // to use a Connection ID.
    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
    // Returns True if no errors occured.
    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
        Integer iCh iRow iItems iCount
        String sValue sRow
        String[] sFileArray
        Boolean bExists bIsActive

        Move False to Err
        Move 0 to iRow

        If (ghoStatusPanel <> 0) Begin
            Get Active_state of ghoStatusPanel to bIsActive
        End

        Get vFilePathExists sFileName to bExists
        If (bExists = False) Begin
            If (bShowResult = True) Begin                  
                If (bIsActive = True) Begin
                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
                End 
                Else Begin
                    Showln "File does not exist: " sFileName
                End
            End
            Function_Return False
        End

        Get Seq_Open_Input_Channel sFileName to iCh
        If (iCh < 1) Begin
            Function_Return False
        End

        If (bShowResult = True) Begin      
            If (ghoStatusPanel <> 0) Begin
                Get Active_state of ghoStatusPanel to bIsActive
                If (bIsActive = True) Begin
                    Set Message_Text of ghoStatusPanel to sFileName
                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo)) 
                    Send DoAdvance of ghoProgressBar
                End
            End
            Else Begin
                Showln ""
                Showln "sFileName = " sFileName
                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
            End
        End

        While (not(SeqEof))
            Readln channel iCh sRow
            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
//                If (bShowResult = True) Begin  
//                    If (bIsActive = True) Begin
//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
//                    End
//                    Else Begin
//                        Showln "Changed from: " sRow " to: " sChangeTo
//                    End
//                End
                // Change the whole line to the new connection id:
                Move sChangeTo to sRow
                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
            End
            Move sRow to sFileArray[iRow]
            Increment iRow
        End
        Send Seq_Close_Channel iCh

        Sleep 1 // Wait for Windows to close the file

        Get Seq_Open_Output_Channel sFileName to iCh
        If (iCh < 1) Begin
            Function_Return False
        End
        Move (SizeOfArray(sFileArray)) to iItems
        Decrement iItems

        For iCount from 0 to iItems
            Move sFileArray[iCount] to sValue
            Writeln channel iCh sValue
        Loop
        Send Seq_Close_Channel iCh

        Function_Return (Err = False)
    End_Function

    // This might be needed by API-methods when a connection id is to be used and
    // the connection ID hasn't been established with the driver's CLI interface.
    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
    Function UtilCreateConnectionID String sConnectionID Returns Boolean
        String sConnectionString sDriverID
        Boolean bOK bSilent bDawDriver
        Handle hoCLI

        Move False to bOK
        Get psDriverID to sDriverID
        Get IsDAWSQLDriver sDriverID to bDawDriver
        If (bDawDriver = False) Begin
            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
            Function_Return False
        End

        Get psConnectionString to sConnectionString
        Get pbSilentLogin      to bSilent

        Get phoCLIHandler to hoCLI
        If (hoCLI <> 0) Begin
            Set psDriverID of hoCLI to sDriverID
            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
        End

        Function_Return (bOK = False)
    End_Function

    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
    // and opens it in "notepad.exe".
    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
    Procedure UtilShowErrorList
        tSqlErrorArray aSqlErrorArray
        Integer iRows iCount iCh iErrorNum
        String sPath sFileName sErrorTxt sStatement

        Get psHome of (phoWorkspace(ghoApplication)) to sPath
        Get vFolderFormat sPath to sPath
        Move "SQLErrorLog.txt"  to sFileName
        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
            Get paSqlErrorArray to aSqlErrorArray
            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
            If (iRows > 0) Begin
                Decrement iRows
                for iCount from 0 to iRows
                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
                    Writeln channel iCh "SQL Statement: " sStatement
                Loop
            End
        Send Seq_Close_Channel iCh

        If (iRows > 0) Begin
            Runprogram Background "Notepad.exe" (sPath + sFileName)
        End
    End_Procedure
    
    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
    // and the table needs to exist as an SQL table.
    Function UtilTableIsSql Handle hTable Returns Boolean
        String sRootName sLogicalName sDriverID
        Boolean bIsSQL
        
        Move False to bIsSQL
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            Move (sRootName contains ":") to bIsSQL
            If (bIsSQL = True) Begin               
                Get psDriverID to sDriverID
                Get _TableNameOnly sRootName to sRootName
                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
            End
        End

        Function_Return bIsSQL
    End_Function

    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
        Boolean bIsSQL
        Move (sRootName contains ":") to bIsSQL
        Function_Return bIsSQL
    End_Function

    // Returns True if the passed hTable (filelist slot number) is an Alias table.
    // An Alias file/table is a filelist number that share the same Physical filename
    // but the Logical name is different.
    // Note: If the table cannot be opened; the table is not considered to be an Alias.
//    Function UtilTableIsAlias Handle hTable Returns Boolean
//        String sPhysicalName sPhysicalNameCompare
//        Boolean bWasOpen bOpened bOK
//        Integer iCount 
//        
//        Move 0 to iCount    
//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
//        If (bWasOpen = False) Begin
//            Open hTable
//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
//            If (bOpened = False) Begin
//                Function_Return False
//            End  
//        End
//        
//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
//        Get _TableNameOnly sPhysicalName to sPhysicalName
//        If (bWasOpen = False and bOpened = True) Begin
//            Close hTable
//        End
//
//        Move 0 to hTable
//        Repeat
//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
//            If (hTable > 0 and hTable <> 50) Begin
//                Open hTable
//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
//                If (bOpened = True) Begin
//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
//                    Close hTable
//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
//                        Increment iCount 
//                    End
//                End
//            End
//        Until (hTable = 0)
//        
//        If (iCount > 1) Begin
//            Function_Return True
//        End
//
//        Function_Return False
//    End_Function  

    Function UtilTableIsAlias Handle hTable Returns Boolean
        String sPhysicalName sPhysicalNameCompare
        Integer iCount iMaster iAlias iInTable
        
        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
        Get _TableNameOnly sPhysicalName to sPhysicalName
        Move hTable to iInTable
        Move 0 to hTable                      
        Move 0 to iCount    
        
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0 and hTable <> 50) Begin
                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
                
                    If (iCount = 0) Begin
                        Move hTable to iMaster
                    End
                    If (iCount > 0) Begin
                        Move hTable to iAlias
                    End
                    Increment iCount 
                End
            End
        Until (hTable = 0)
        
        If (iCount > 1) Begin
            Function_Return (iInTable >= iAlias and iAlias > iMaster)
        End

        Function_Return False
    End_Function  
    
//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
//        String sDDSrcPath sDataPath sLogicalName
//        Boolean bOK bExists
//        
//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath  
//        If (Right(sDataPath, 1) = "\") Begin
//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
//        End
//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
//        
//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
//        
//        Function_Return bExists
//    End_Function  

    // To Open a table with any driver.
    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
    //       that the proper login properties has been setup properly with the cSQLConnections object.
    //
    // If the open command fails the Err flag will be reset to false, at the end of the function!
    // The found flag is still used to indicate if the open was successful or not. The function
    // returns a True if successful (table could be opened).
    //
    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
    // This is good because with DFConnectionID's those credentials doesn't need to be available in
    // the .int file (and probably aren't). As long as the login properties of this object have been
    // set properly we can open the table.
    //
    // DAW Driver Syntax:
    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
    //
    // DAW Driver Sample:
    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
    //
    // Mertech Driver Samples:
    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
        Boolean bOpen bMertechDriver bOK
        Integer iRetval
        tSQLConnection SQLConnection

        Move sTableName to sTableNameOrg
        If (hTable > 0) Begin
//        If (hTable > 0 and Trim(sTableName) = "") Begin
            Send Ignore_Error of Error_Object_Id 20529
            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
            Open hTable
            Send Trap_Error of Error_Object_Id 20529
            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND  
            Get_Attribute DF_FILE_OPENED of hTable to bOpen
            If (bOpen = True) Begin
                Function_Return True
            End
        End

        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Move SQLConnection.sDriverID to sDriverID
        Get IsMertechDriver sDriverID to bMertechDriver
        Move SQLConnection.sConnectionString to sConnection
        Move SQLConnection.sSchema to sSchema
        If (sSchema = "") Begin
            Get _SqlFindKeyWord CI_SQLDBO to sSchema
        End

        // We need to remove the ".int" part of the table name because
        // the table name after the "#" in the connection syntax below wants the
        // "bare" table name without any extension.
        If (sDriverID <> DATAFLEX_ID) Begin
            If (Lowercase(sTableName) contains ".int") Begin
                Get ParseFileExtension sTableName to sExt
                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
            End
            Else Begin
                Move sTableName to sTableNameShort
                Move (Append(sTableName, ".int")) to sTableName
            End
            If (bMertechDriver = False) Begin
                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
                Move sConnection to sTableName
            End
        End

        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
        If (hTable = 0) Begin
            Get NextFreeFilelistSlot to hTable
        End

        Case Begin
            Case (sDriverID = MSSQLDRV_ID)
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = DB2_DRV_ID)
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = ODBC_DRV_ID)
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = SQLFLEX)
                // ToDo: What is the <owner>? Same as Schema?
                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = MDSMySQL)
                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = MDSPgSQL)
                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = ORAFLEX)
                // ToDo: What is the <owner>? Same as Schema?
                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
                // If not df_exclusive mode, we use the "Open As" syntax.
                If (iMode <> DF_EXCLUSIVE) Begin
                    Open sTableName as hTable
                End
                Else Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Case Break

            Case (sDriverID = DATAFLEX_ID)
                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
                    Open sTableName as hTable
                End
                Else If (iMode = DF_EXCLUSIVE) Begin
                    Get OpenTableExclusive hTable to bOK
                    If (bOK = False) Begin
                        Function_Return False
                    End
                End
                Else Begin
                    Open hTable
                End
                Case Break

            // ToDo: Logic needs to be expanded for Mertech drivers!

            Case Else
                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
        Case End

        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
            Move False to Found
        End
        // If open failed, the Err is set to true,
        // but we don't want that because it could end our loop.
        Move False to Err
        Get_Attribute DF_FILE_OPENED of hTable to bOpen

        Function_Return bOpen
    End_Function

    // Checks that the passed hTable number both exists in Filelist.cfg and
    // that the embedded .dat file exists on disk _or_ that the SQL table exists
    // if it is an SQL table
    Function UtilTableExists Handle hTable Returns Boolean
        Boolean bExists bIsSQLTable
        String sDataPath sRootName
        
        Get UtilTableNumberIsInUse hTable to bExists
        If (bExists = False) Begin
            Function_Return False
        End
        
        Move False to bIsSQLTable
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            Move (sRootName contains ":") to bIsSQLTable
        End
        If (bIsSQLTable = True) Begin
            Get UtilTableIsSQL hTable to bExists
            Function_Return bExists
        End
        Else Begin
            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
            Get vFolderFormat sDataPath to sDataPath
            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
        End
        
        Function_Return bExists
    End_Function               
    
    // Pass a table handle
    // Returns True if the table exists in filelist.cfg.
    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
        Handle hTable
        Boolean bFound

        Move False to bFound
        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                If (hTable = hCheckTable) Begin
                    Move True to bFound
                End
            End
            If (bFound = True) Break
        Until (hTable = 0)

        Function_Return (bFound = True)
    End_Function

    // Number of tables in Filelist.cfg. Returns integger
    Function UtilFilelistNoOfTables Returns Integer
        Handle hTable
        Integer iRetval

        Move 0 to hTable         
        Move 0 to iRetval
        
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Increment iRetval
            End
        Until (hTable = 0)

        Function_Return iRetval
    End_Function

    // Pass a table's logical name
    // Returns True if the table exists in filelist.cfg.
    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
        Handle hTable
        Boolean bFound                           
        String sCompareTable

        Move False to bFound
        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
                    Move True to bFound
                End
            End
            If (bFound = True) Break
        Until (hTable = 0)

        Function_Return (bFound = True)
    End_Function    
    
    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
        Boolean bOK bRecnum bToAnsi
        Integer iCh                   
        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
        
        If (Trim(sDataPath) = "") Begin
            Function_Return False
        End
        
        Move False to Err
        Get psDriverID     to sDriverID
        Get psConnectionID to sConnectionID
        Get psSchema       to sSchemaName
        Get True           to bRecnum
        Get pbToANSI       to bToAnsi
        Move CS_ANSI_Txt to sANSI_OEM
        If (bToAnsi = False) Begin
            Move CS_OEM_Txt to sANSI_OEM
        End
        
        Get vFolderFormat sDataPath to sDataPath
        Move "CodeMast.int"         to sFileName
        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
            Writeln channel iCh ("DATABASE_NAME CODEMAST")
            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
            Writeln channel iCh ("")
            Writeln channel iCh ("RECNUM_TABLE YES")
            Writeln channel iCh ("PRIMARY_INDEX 0")
            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
            Writeln channel iCh ("")
            Writeln channel iCh ("INDEX_NUMBER 1")
            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
            Writeln channel iCh ("")
        Send Seq_Close_Channel iCh
        
        Get vFolderFormat sDataPath to sDataPath
        Move "CodeType.int"         to sFileName
        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
            Writeln channel iCh ("DATABASE_NAME CODETYPE")
            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
            Writeln channel iCh ("")
            Writeln channel iCh ("RECNUM_TABLE YES")
            Writeln channel iCh ("PRIMARY_INDEX 0")
            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
            Writeln channel iCh ("")
            Writeln channel iCh ("INDEX_NUMBER 0")
            Writeln channel iCh ("INDEX_NAME CODETYPE000")
            Writeln channel iCh ("")
            Writeln channel iCh ("INDEX_NUMBER 1")
            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
            Writeln channel iCh ("")
        Send Seq_Close_Channel iCh
    
        Function_Return (Err = False)
    End_Function

    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
        String  sRetval sColumnName
        String[] sOverlapFieldsArray
        Integer iType iColumn iColumns
        Boolean bOpen bOverlap

        Get_Attribute DF_FILE_OPENED of hTable to bOpen
        If (bOpen = False) Begin
            Open hTable
        End

        Move "" to sRetval

        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns

        for iColumn from 0 to iColumns
            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
                If (bOverlap) Begin
                    If (sRetval <> "") Begin
                        Append sRetval ","
                    End
                    Append sRetval iColumn
                End
            End
        Loop

        If (bOpen = False) Begin
            Close hTable
        End

        Get StrSplitToArray sRetval "," to sOverlapFieldsArray

        Function_Return sOverlapFieldsArray
    End_Function

    // Returns a struct array with all data types for the passed driver & dbtype.
    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
        tColumnType[] ColumnType

        Case Begin
            Case (iDbType = EN_dbTypeDataFlex)
                Get _UtilEnumerateDataFlexTypes to ColumnType
                Case Break

            Case (iDbType = EN_DbTypeDB2)
                Get _UtilEnumerateDB2Types to ColumnType
                Case Break

            Case (iDbType = EN_DbTypeMSSQL)
                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
                Case Break

            Case (sDriverID = MDSMySQL)
                Get _UtilEnumerateMySQLTypes to ColumnType
                Case Break

            Case (sDriverID = ORAFLEX)
                Get _UtilEnumerateOracleTypes to ColumnType
                Case Break

            Case (sDriverID = MDSPgSQL)
                Get _UtilEnumeratePostgreSQLTypes to ColumnType
                Case Break
        Case End

        Function_Return ColumnType
    End_Function 
    
    Function UtilEnumerateMSSQLODBCDrivers Returns String
        Handle hoRegistry hoODBCDriverNames
        Boolean bExists bKeyOpened
        String sKey
        String[] sDrivers
        Integer iDriverNames iDriverName
        
        Get Create (RefClass (cRegistry)) to hoRegistry
        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
        Set pfAccessRights of hoRegistry to Key_Read
        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
        Get KeyExists of hoRegistry sKey to bExists
        If (bExists) Begin
            Get OpenKey of hoRegistry sKey to bKeyOpened
            If (bKeyOpened) Begin
                Get Create (RefClass (Array)) to hoODBCDriverNames
                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
                If (iDriverNames > 0) Begin
                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
                    Decrement iDriverNames
                    for iDriverName from 0 to iDriverNames
                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
                      Loop
                End
                Send CloseKey of hoRegistry
            End
        End
        Send Destroy of hoRegistry
        
        Function_Return sDrivers
    End_Function

    // DataFlex Embedded Database Data Types:
    // Helper function for UtilEnumerateColumnTypes
    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
        tColumnType[] ColumnType
        Integer i

        Move DF_ASCII           to ColumnType[i].iType
        Move "ASCII"            to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        Move DF_BCD             to ColumnType[i].iType
        Move "Numeric"          to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move DF_DATE            to ColumnType[i].iType
        Move "Date"             to ColumnType[i].sType
        Move DF_DATE            to ColumnType[i].iDataFlexType
        Move "Date"             to ColumnType[i].sDataFlexType
        Move "6.0"              to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move DF_TEXT            to ColumnType[i].iType
        Move "Text"             to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move DF_BINARY          to ColumnType[i].iType
        Move "Binary"           to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move DF_DATETIME        to ColumnType[i].iType
        Move "DateTime"         to ColumnType[i].sType
        Move DF_DATETIME        to ColumnType[i].iDataFlexType
        Move "DateTime"         to ColumnType[i].sDataFlexType
        Move "23"               to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move DF_OVERLAP         to ColumnType[i].iType
        Move "Overlap"          to ColumnType[i].sType
        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
        Move "Overlap"          to ColumnType[i].sDataFlexType
        Move "0.0"              to ColumnType[i].sPrecision

        Function_Return ColumnType
    End_Function

    Function _UtilEnumerateDB2Types Returns tColumnType[]
        tColumnType[] ColumnType
        Integer i

        Move SQL_DBCLOB         to ColumnType[i].iType
        Move "DBCLOB"           to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move SQL_BIGINT         to ColumnType[i].iType
        Move "BIGINT"           to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.0"             to ColumnType[i].sPrecision
        Increment i

        Move SQL_BLOB           to ColumnType[i].iType
        Move "BLOB"             to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "BINARY"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move SQL_CHAR           to ColumnType[i].iType
        Move "CHAR"             to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        // ToDo: We need to change the sType when using this!
        Move SQL_CHARBIT            to ColumnType[i].iType
        Move "CHAR FOR BIT DATA"    to ColumnType[i].sType
        Move DF_BINARY              to ColumnType[i].iDataFlexType
        Move "Binary"               to ColumnType[i].sDataFlexType
        Move "254"                  to ColumnType[i].sPrecision
        Increment i

        Move SQL_DATE           to ColumnType[i].iType
        Move "DATE"             to ColumnType[i].sType
        Move DF_DATE            to ColumnType[i].iDataFlexType
        Move "Date"             to ColumnType[i].sDataFlexType
        Move "6.0"              to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move SQL_CLOB           to ColumnType[i].iType
        Move "CLOB"             to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move SQL_DECIMAL        to ColumnType[i].iType
        Move "DECIMAL"          to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move SQL_DOUBLE         to ColumnType[i].iType
        Move "DOUBLE"           to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move SQL_FLOAT          to ColumnType[i].iType
        Move "FLOAT"            to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move SQL_GRAPHIC        to ColumnType[i].iType
        Move "GRAPHIC"          to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "255"              to ColumnType[i].sPrecision
        Increment i

        Move SQL_INTEGER        to ColumnType[i].iType
        Move "INTEGER"          to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "9.0"              to ColumnType[i].sPrecision
        Increment i

        Move SQL_LONGVARCHAR    to ColumnType[i].iType
        Move "LONG VARCHAR"     to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "TEXT"             to ColumnType[i].sDataFlexType
        Move "32000"            to ColumnType[i].sPrecision
        Increment i

        Move SQL_LONGVARCHARBIT to ColumnType[i].iType
        Move "LONG VARCHAR BIT" to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "TEXT"             to ColumnType[i].sDataFlexType
        Move "32000"            to ColumnType[i].sPrecision
        Increment i

        Move SQL_LONGVARGRAPHIC to ColumnType[i].iType
        Move "LONG VARGRAPHIC"  to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "TEXT"             to ColumnType[i].sDataFlexType
        Move "32000"            to ColumnType[i].sPrecision
        Increment i

        Move SQL_NUMERIC        to ColumnType[i].iType
        Move "NUMERIC"          to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move SQL_REAL           to ColumnType[i].iType
        Move "REAL"             to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move SQL_SMALLINT       to ColumnType[i].iType
        Move "SMALLINT"         to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "NUMERIC"          to ColumnType[i].sDataFlexType
        Move "5.0"              to ColumnType[i].sPrecision
        Increment i

        Move SQL_TIME           to ColumnType[i].iType
        Move "TIME"             to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "19.0"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move SQL_TIMESTAMP      to ColumnType[i].iType
        Move "TIMESTAMP"        to ColumnType[i].sType
        Move DF_DATETIME        to ColumnType[i].iDataFlexType
        Move "DATETIME"         to ColumnType[i].sDataFlexType
        Move "23.6"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move SQL_VARCHAR        to ColumnType[i].iType
        Move "VARCHAR"          to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "TEXT"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        // ToDo: We need to change the sType when using this!
        Move SQL_VARCHARBIT         to ColumnType[i].iType
        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sType
        Move DF_TEXT                to ColumnType[i].iDataFlexType
        Move "TEXT"                 to ColumnType[i].sDataFlexType
        Move "16384"                to ColumnType[i].sPrecision
        Increment i

        Move SQL_VARGRAPHIC     to ColumnType[i].iType
        Move "VARGRAPHIC"       to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "TEXT"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision

        Move SQL_XML            to ColumnType[i].iType
        Move "XML"              to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "TEXT"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision

        Function_Return ColumnType
    End_Function

    // Microsoft SQL Server Database Data Types:
    // Helper function for UtilEnumerateColumnTypes
    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
        tColumnType[] ColumnType
        Integer i

        If (sDriverID = MSSQLDRV_ID) Begin
            Move SQL_BIGINT         to ColumnType[i].iType
            Move "bigint"           to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.0"             to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_BINARY         to ColumnType[i].iType
            Move "binary"           to ColumnType[i].sType
            Move DF_BINARY          to ColumnType[i].iDataFlexType
            Move "Binary"           to ColumnType[i].sDataFlexType
            Move "8000"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_BIT            to ColumnType[i].iType
            Move "bit"              to ColumnType[i].sType
            Move DF_ASCII           to ColumnType[i].iDataFlexType
            Move "ASCII"            to ColumnType[i].sDataFlexType
            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_CHAR           to ColumnType[i].iType
            Move "char"             to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "8000"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_DATE           to ColumnType[i].iType
            Move "date"             to ColumnType[i].sType
            Move DF_DATE            to ColumnType[i].iDataFlexType
            Move "Date"             to ColumnType[i].sDataFlexType
            Move "6.0"              to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_DATETIME       to ColumnType[i].iType
            Move "datetime"         to ColumnType[i].sType
            Move DF_DATETIME        to ColumnType[i].iDataFlexType
            Move "DateTime"         to ColumnType[i].sDataFlexType
            Move "23.3"             to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iType
            Move "datetime2"         to ColumnType[i].sType
            Move DF_DATETIME         to ColumnType[i].iDataFlexType
            Move "DateTime"          to ColumnType[i].sDataFlexType
            Move "23.6"              to ColumnType[i].sPrecision
            Move True                to ColumnType[i].bFixedSize
            Increment i

            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iType
            Move "datetimeoffset"       to ColumnType[i].sType
            Move DF_DATETIME            to ColumnType[i].iDataFlexType
            Move "DateTime"             to ColumnType[i].sDataFlexType
            Move "34.0"                 to ColumnType[i].sPrecision
            Move True                   to ColumnType[i].bFixedSize
            Increment i

            Move SQL_DECIMAL        to ColumnType[i].iType
            Move "decimal"          to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_FLOAT          to ColumnType[i].iType
            Move "float"            to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_INTEGER        to ColumnType[i].iType
            Move "int"              to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "8.0"              to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_TYPE_MONEY     to ColumnType[i].iType
            Move "money"            to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
            Increment i

            Move SQL_WCHAR          to ColumnType[i].iType
            Move "nchar"            to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "4000"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_WLONGVARCHAR   to ColumnType[i].iType
            Move "ntext"            to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "16384"            to ColumnType[i].sPrecision
            Increment i

            Move SQL_NUMERIC        to ColumnType[i].iType
            Move "numeric"          to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_WVARCHAR       to ColumnType[i].iType
            Move "nvarchar"         to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "Text"             to ColumnType[i].sDataFlexType
            Move "4000"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_VARCHARMAX     to ColumnType[i].iType
            Move "nvarchar(max)"    to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "16384"            to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_REAL           to ColumnType[i].iType
            Move "real"             to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "NUMERIC"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iType
            Move "smalldatetime"        to ColumnType[i].sType
            Move DF_DATETIME            to ColumnType[i].iDataFlexType
            Move "DATETIME"             to ColumnType[i].sDataFlexType
            Move "23.0"                 to ColumnType[i].sPrecision
            Move True                   to ColumnType[i].bFixedSize
            Increment i

            Move SQL_SMALLINT       to ColumnType[i].iType
            Move "smallint"         to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "NUMERIC"          to ColumnType[i].sDataFlexType
            Move "4.0"              to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iType
            Move "smallmoney"        to ColumnType[i].sType
            Move DF_BCD              to ColumnType[i].iDataFlexType
            Move "NUMERIC"           to ColumnType[i].sDataFlexType
            Move "10.0"              to ColumnType[i].sPrecision
            Increment i

            Move SQL_TEXT           to ColumnType[i].iType
            Move "text"             to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "8000"             to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_TIME           to ColumnType[i].iType
            Move "time"             to ColumnType[i].sType
            Move DF_ASCII           to ColumnType[i].iDataFlexType
            Move "ASCII"            to ColumnType[i].sDataFlexType
            Move "19.0"             to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_TINYINT        to ColumnType[i].iType
            Move "tinyint"          to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "NUMERIC"          to ColumnType[i].sDataFlexType
            Move "2.0"              to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_GUID           to ColumnType[i].iType
            Move "uniqueidentifier" to ColumnType[i].sType
            Move DF_ASCII           to ColumnType[i].iDataFlexType
            Move "ASCII"            to ColumnType[i].sDataFlexType
            Move "36"               to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_VARBINARY      to ColumnType[i].iType
            Move "varbinary"        to ColumnType[i].sType
            Move DF_BINARY          to ColumnType[i].iDataFlexType
            Move "BINARY"           to ColumnType[i].sDataFlexType
            Move "16384"            to ColumnType[i].sPrecision
            Increment i

            Move SQL_LONGVARBINARY  to ColumnType[i].iType
            Move "varbinary(max)"   to ColumnType[i].sType
            Move DF_BINARY          to ColumnType[i].iDataFlexType
            Move "BINARY"           to ColumnType[i].sDataFlexType
            Move "16384"            to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_VARCHAR        to ColumnType[i].iType
            Move "varchar"          to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "8000"             to ColumnType[i].sPrecision
            Increment i

            Move SQL_LONGVARCHAR    to ColumnType[i].iType
            Move "varchar(max)"     to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "16384"            to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_SS_XML         to ColumnType[i].iType
            Move "xml"              to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "16384"            to ColumnType[i].sPrecision
            Increment i

            Move SQL_TYPE_DATE      to ColumnType[i].iType
            Move "DATE"             to ColumnType[i].sType
            Move DF_DATE            to ColumnType[i].iDataFlexType
            Move "date"             to ColumnType[i].sDataFlexType
            Move "6.0"              to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_TYPE_TIME      to ColumnType[i].iType
            Move "time"             to ColumnType[i].sType
            Move DF_ASCII           to ColumnType[i].iDataFlexType
            Move "ASCII"            to ColumnType[i].sDataFlexType
            Move "8.7"              to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iType
            Move "datetime"         to ColumnType[i].sType
            Move DF_DATETIME        to ColumnType[i].iDataFlexType
            Move "DateTime"         to ColumnType[i].sDataFlexType
            Move "23.6"             to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

        End

        // Mertech SQLFlex driver
        If (sDriverID = SQLFLEX) Begin
            Move eSQLServer_BIGINT  to ColumnType[i].iType
            Move "BigInt"           to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.0"             to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_BINARY  to ColumnType[i].iType
            Move "Binary"           to ColumnType[i].sType
            Move DF_BINARY          to ColumnType[i].iDataFlexType
            Move "Binary"           to ColumnType[i].sDataFlexType
            Move "8000"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_BIT     to ColumnType[i].iType
            Move "Bit"              to ColumnType[i].sType
            Move DF_ASCII           to ColumnType[i].iDataFlexType
            Move "ASCII"            to ColumnType[i].sDataFlexType
            Move "1.0"              to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize // In SQL allows 1, 0, or "NULL"
            Increment i

            Move eSQLServer_CHAR    to ColumnType[i].iType
            Move "Char"             to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "Text"             to ColumnType[i].sDataFlexType
            Move "8000"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_DATE    to ColumnType[i].iType
            Move "Date"             to ColumnType[i].sType
            Move DF_DATE            to ColumnType[i].iDataFlexType
            Move "Date"             to ColumnType[i].sDataFlexType
            Move "6.0"              to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_DATETIME    to ColumnType[i].iType
            Move "DateTime"             to ColumnType[i].sType
            Move DF_DATETIME            to ColumnType[i].iDataFlexType
            Move "DateTime"             to ColumnType[i].sDataFlexType
            Move "23.3"                 to ColumnType[i].sPrecision
            Move True                   to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_DATETIME2   to ColumnType[i].iType
            Move "DateTime2"            to ColumnType[i].sType
            Move DF_DATETIME            to ColumnType[i].iDataFlexType
            Move "DateTime"             to ColumnType[i].sDataFlexType
            Move "23.6"                 to ColumnType[i].sPrecision
            Move True                   to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iType
            Move "DateTimeOffest"           to ColumnType[i].sType
            Move DF_DATETIME                to ColumnType[i].iDataFlexType
            Move "DateTime"                 to ColumnType[i].sDataFlexType
            Move "23.0"                     to ColumnType[i].sPrecision
            Move True                       to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_DECIMAL to ColumnType[i].iType
            Move "Decimal"          to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_DOUBLE  to ColumnType[i].iType
            Move "Double"           to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_FLOAT   to ColumnType[i].iType
            Move "Float"            to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_INT     to ColumnType[i].iType
            Move "Int"              to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "11.0"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_NCHAR   to ColumnType[i].iType
            Move "Nchar"            to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "4000"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_NTEXT   to ColumnType[i].iType
            Move "Ntext"            to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "16384"            to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_NUMERIC to ColumnType[i].iType
            Move "Numeric"          to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_NVARCHAR    to ColumnType[i].iType
            Move "NvarChar"             to ColumnType[i].sType
            Move DF_TEXT                to ColumnType[i].iDataFlexType
            Move "Text"                 to ColumnType[i].sDataFlexType
            Move "4000"                 to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_NVARCHARMAX to ColumnType[i].iType
            Move "NvarCharMax"          to ColumnType[i].sType
            Move DF_TEXT                to ColumnType[i].iDataFlexType
            Move "Text"                 to ColumnType[i].sDataFlexType
            Move "16384"                to ColumnType[i].sPrecision
            Move True                   to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_REAL    to ColumnType[i].iType
            Move "Real"             to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "NUMERIC"          to ColumnType[i].sDataFlexType
            Move "14.8"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iType
            Move "SmallDateTime"            to ColumnType[i].sType
            Move DF_DATETIME                to ColumnType[i].iDataFlexType
            Move "DATETIME"                 to ColumnType[i].sDataFlexType
            Move "23.0"                     to ColumnType[i].sPrecision
            Move True                       to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_SMALLINT    to ColumnType[i].iType
            Move "SmallInt"             to ColumnType[i].sType
            Move DF_BCD                 to ColumnType[i].iDataFlexType
            Move "NUMERIC"              to ColumnType[i].sDataFlexType
            Move "6.0"                  to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_TEXT    to ColumnType[i].iType
            Move "Text"             to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "8000"             to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_TIME    to ColumnType[i].iType
            Move "Time"             to ColumnType[i].sType
            Move DF_ASCII           to ColumnType[i].iDataFlexType
            Move "Date"             to ColumnType[i].sDataFlexType
            Move "16.0"             to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_TIMESTAMP   to ColumnType[i].iType
            Move "TimeStamp"            to ColumnType[i].sType
            Move DF_ASCII               to ColumnType[i].iDataFlexType
            Move "DateTime"             to ColumnType[i].sDataFlexType
            Move "8.0"                  to ColumnType[i].sPrecision
            Move True                   to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_TINYINT to ColumnType[i].iType
            Move "TinyInt"          to ColumnType[i].sType
            Move DF_BCD             to ColumnType[i].iDataFlexType
            Move "Numeric"          to ColumnType[i].sDataFlexType
            Move "3.0"              to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_GUID    to ColumnType[i].iType
            Move "UniqueIdentifier" to ColumnType[i].sType
            Move DF_ASCII           to ColumnType[i].iDataFlexType
            Move "ASCII"            to ColumnType[i].sDataFlexType
            Move "38"               to ColumnType[i].sPrecision
            Move True               to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_VARBINARY   to ColumnType[i].iType
            Move "VarBinary"            to ColumnType[i].sType
            Move DF_BINARY              to ColumnType[i].iDataFlexType
            Move "BINARY"               to ColumnType[i].sDataFlexType
            Move "8000"                 to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_VARBINARYMAX to ColumnType[i].iType
            Move "VarBinary(Max)"        to ColumnType[i].sType
            Move DF_BINARY               to ColumnType[i].iDataFlexType
            Move "BINARY"                to ColumnType[i].sDataFlexType
            Move "16384"                 to ColumnType[i].sPrecision
            Move True                    to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_VARCHAR to ColumnType[i].iType
            Move "VarChar"          to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "8000"             to ColumnType[i].sPrecision
            Increment i

            Move eSQLServer_VARCHARMAX  to ColumnType[i].iType
            Move "VarChar(Max)"         to ColumnType[i].sType
            Move DF_TEXT                to ColumnType[i].iDataFlexType
            Move "TEXT"                 to ColumnType[i].sDataFlexType
            Move "16384"                to ColumnType[i].sPrecision
            Move True                   to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_SQLVARIANT  to ColumnType[i].iType
            Move "SQL_Variant"          to ColumnType[i].sType
            Move DF_BINARY              to ColumnType[i].iDataFlexType
            Move "Binary"               to ColumnType[i].sDataFlexType
            Move "8016"                 to ColumnType[i].sPrecision
            Move True                   to ColumnType[i].bFixedSize
            Increment i

            Move eSQLServer_XML     to ColumnType[i].iType
            Move "XML"              to ColumnType[i].sType
            Move DF_TEXT            to ColumnType[i].iDataFlexType
            Move "TEXT"             to ColumnType[i].sDataFlexType
            Move "16384"            to ColumnType[i].sPrecision
        End

        Function_Return ColumnType
    End_Function

    // MySQL Data Types
    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
        tColumnType[] ColumnType
        Integer i

        Move eMySQL_LONGLONG    to ColumnType[i].iType
        Move "bigint"           to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.0"             to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_BIT         to ColumnType[i].iType
        Move "bit"              to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move eMySQL_BLOB        to ColumnType[i].iType
        Move "blob"             to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "BINARY"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_STRING      to ColumnType[i].iType
        Move "char"             to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "TEXT"             to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_DATE        to ColumnType[i].iType
        Move "date"             to ColumnType[i].sType
        Move DF_DATE            to ColumnType[i].iDataFlexType
        Move "Date"             to ColumnType[i].sDataFlexType
        Move "6.0"              to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move eMySQL_DATETIME    to ColumnType[i].iType
        Move "datetime"         to ColumnType[i].sType
        Move DF_DATETIME        to ColumnType[i].iDataFlexType
        Move "DateTime"         to ColumnType[i].sDataFlexType
        Move "23.0"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move eMySQL_DECIMAL     to ColumnType[i].iType
        Move "decimal"          to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_DOUBLE      to ColumnType[i].iType
        Move "double"           to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_ENUM        to ColumnType[i].iType
        Move "enum"             to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_FLOAT       to ColumnType[i].iType
        Move "float"            to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_INT24       to ColumnType[i].iType
        Move "int"              to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "NUMERIC"          to ColumnType[i].sDataFlexType
        Move "11.0"             to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_LONG_BLOB   to ColumnType[i].iType
        Move "longblob"         to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_LONG_TEXT   to ColumnType[i].iType
        Move "longtext"         to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iType
        Move "mediumblob"       to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_INT24       to ColumnType[i].iType
        Move "mediumint"        to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "9.0"              to ColumnType[i].sPrecision

        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iType
        Move "mediumtext"       to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_SET         to ColumnType[i].iType
        Move "set"              to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_SHORT       to ColumnType[i].iType
        Move "smallint"         to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "6.0"              to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_TEXT        to ColumnType[i].iType
        Move "text"             to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_TIME        to ColumnType[i].iType
        Move "time"             to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "10.0"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move eMySQL_TIMESTAMP   to ColumnType[i].iType
        Move "timestamp"        to ColumnType[i].sType
        Move DF_DATETIME        to ColumnType[i].iDataFlexType
        Move "DateTime"         to ColumnType[i].sDataFlexType
        Move "23.0"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move eMySQL_TINY_BLOB   to ColumnType[i].iType
        Move "tinyblob"         to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_TINY        to ColumnType[i].iType
        Move "tinyint"          to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "4.0"              to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_TINY_TEXT   to ColumnType[i].iType
        Move "tinytext"         to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_VAR_STRING  to ColumnType[i].iType
        Move "varchar"          to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eMySQL_YEAR        to ColumnType[i].iType
        Move "year"             to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "NUMERIC"          to ColumnType[i].sDataFlexType
        Move "4.0"              to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Function_Return ColumnType
    End_Function

    // Oracle Data Types
    Function _UtilEnumerateOracleTypes Returns tColumnType[]
        tColumnType[] ColumnType
        Integer i

        Move eOracle_BLOB       to ColumnType[i].iType
        Move "BLOB"             to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eOracle_CHAR       to ColumnType[i].iType
        Move "CHAR"             to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "2000"             to ColumnType[i].sPrecision
        Increment i

        Move eOracle_CLOB       to ColumnType[i].iType
        Move "CLOB"             to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eOracle_DATE       to ColumnType[i].iType
        Move "DATE"             to ColumnType[i].sType
        Move DF_Date            to ColumnType[i].iDataFlexType
        Move "Date"             to ColumnType[i].sDataFlexType
        Move "6.0"              to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move eOracle_FLOAT      to ColumnType[i].iType
        Move "FLOAT"            to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Number"           to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move eOracle_INT        to ColumnType[i].iType
        Move "INT"              to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Number"           to ColumnType[i].sDataFlexType
        Move "14.0"             to ColumnType[i].sPrecision
        Increment i

        Move eOracle_INTERVALDS to ColumnType[i].iType
        Move "INTERVALDAYTOSEC" to ColumnType[i].sType
        Move DF_DATETIME        to ColumnType[i].iDataFlexType
        Move "DateTime"         to ColumnType[i].sDataFlexType
        Move "23.0"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move eOracle_INTERVALYM  to ColumnType[i].iType
        Move "INTERVALYEARTOMON" to ColumnType[i].sType
        Move DF_DATETIME         to ColumnType[i].iDataFlexType
        Move "DateTime"          to ColumnType[i].sDataFlexType
        Move "23.0"              to ColumnType[i].sPrecision
        Move True                to ColumnType[i].bFixedSize
        Increment i

        Move eOracle_RAW        to ColumnType[i].iType
        Move "LONG"             to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eOracle_LONGRAW    to ColumnType[i].iType
        Move "LONG RAW"         to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eOracle_NCHAR      to ColumnType[i].iType
        Move "NCHAR"            to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "2000"             to ColumnType[i].sPrecision
        Increment i

        Move eOracle_NCLOB      to ColumnType[i].iType
        Move "NCLOB"            to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eOracle_NUMBER     to ColumnType[i].iType
        Move "NUMBER"           to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Number"           to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move eOracle_NVARCHAR2  to ColumnType[i].iType
        Move "NVARCHAR2"        to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "4000"             to ColumnType[i].sPrecision
        Increment i

        Move eOracle_RAW        to ColumnType[i].iType
        Move "RAW"              to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "2000"             to ColumnType[i].sPrecision
        Increment i

        Move eOracle_ROWID      to ColumnType[i].iType
        Move "ROWID"            to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move eOracle_TIMESTAMP  to ColumnType[i].iType
        Move "TimeStamp"        to ColumnType[i].sType
        Move DF_DATETIME        to ColumnType[i].iDataFlexType
        Move "DateTime"         to ColumnType[i].sDataFlexType
        Move "11.0"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iType
        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sType
        Move DF_DATETIME            to ColumnType[i].iDataFlexType
        Move "DateTime"             to ColumnType[i].sDataFlexType
        Move "13.0"                 to ColumnType[i].sPrecision
        Move True                   to ColumnType[i].bFixedSize
        Increment i

        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iType
        Move "TIMEZONETIMEZONE"     to ColumnType[i].sType
        Move DF_DATETIME            to ColumnType[i].iDataFlexType
        Move "DateTime"             to ColumnType[i].sDataFlexType
        Move "11.0"                 to ColumnType[i].sPrecision
        Move True                   to ColumnType[i].bFixedSize
        Increment i

        Move eOracle_VARCHAR2   to ColumnType[i].iType
        Move "VARCHAR"          to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision

        Function_Return ColumnType
    End_Function

    // PostgreSQL Data Types
    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
        tColumnType[] ColumnType
        Integer i

        Move ePgSQL_INT8        to ColumnType[i].iType
        Move "bigint"           to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "14.0"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move ePgSQL_BIT         to ColumnType[i].iType
        Move "bit"              to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_BOOL        to ColumnType[i].iType
        Move "boolean"          to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "1"                to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_BYTEA       to ColumnType[i].iType
        Move "bytea"            to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_CHAR        to ColumnType[i].iType
        Move "char"             to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "2000"             to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_CITEXT      to ColumnType[i].iType
        Move "citext"           to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "254"              to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_DATE        to ColumnType[i].iType
        Move "date"             to ColumnType[i].sType
        Move DF_DATE            to ColumnType[i].iDataFlexType
        Move "Date"             to ColumnType[i].sDataFlexType
        Move "6.0"              to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move ePgSQL_FLOAT4      to ColumnType[i].iType
        Move "decimal"          to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Decimal"          to ColumnType[i].sDataFlexType
        Move "14.8"             to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_FLOAT8      to ColumnType[i].iType
        Move "double"           to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "22"               to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_INT4        to ColumnType[i].iType
        Move "integer"          to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "8.0"              to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_MONEY       to ColumnType[i].iType
        Move "money"            to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "8.0"              to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_OID         to ColumnType[i].iType
        Move "oid"              to ColumnType[i].sType
        Move DF_BINARY          to ColumnType[i].iDataFlexType
        Move "Binary"           to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_FLOAT4      to ColumnType[i].iType
        Move "real"             to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Real"             to ColumnType[i].sDataFlexType
        Move "6.6"              to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_REGPROC     to ColumnType[i].iType
        Move "regproc"          to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "64"               to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_INT2        to ColumnType[i].iType
        Move "smallint"         to ColumnType[i].sType
        Move DF_BCD             to ColumnType[i].iDataFlexType
        Move "Numeric"          to ColumnType[i].sDataFlexType
        Move "6.0"              to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_TEXT        to ColumnType[i].iType
        Move "text"             to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "Text"             to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_TIME        to ColumnType[i].iType
        Move "time"             to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "DateTime"         to ColumnType[i].sDataFlexType
        Move "15.0"             to ColumnType[i].sPrecision
        Increment i

        Move ePgSQL_TIMESTAMP   to ColumnType[i].iType
        Move "timestamp"        to ColumnType[i].sType
        Move DF_DATETIME        to ColumnType[i].iDataFlexType
        Move "DateTime"         to ColumnType[i].sDataFlexType
        Move "23.0"             to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move ePgSQL_UUID        to ColumnType[i].iType
        Move "uuid"             to ColumnType[i].sType
        Move DF_ASCII           to ColumnType[i].iDataFlexType
        Move "ASCII"            to ColumnType[i].sDataFlexType
        Move "40"               to ColumnType[i].sPrecision
        Move True               to ColumnType[i].bFixedSize
        Increment i

        Move ePgSQL_VARCHAR     to ColumnType[i].iType
        Move "varchar"          to ColumnType[i].sType
        Move DF_TEXT            to ColumnType[i].iDataFlexType
        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
        Move "16384"            to ColumnType[i].sPrecision
        Increment i

        Function_Return ColumnType
    End_Function

    // Internal usage. Use the UtilColumnTypeXXX functions instead.
    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
        Integer iValue iSize iCount iStart iDriverID
        tColumnType[] ColumnTypeArray
        tColumnType RetvalType
        String sValue  
        Boolean bFrameworkDataFlexType

        Move "Undefined" to RetvalType.sType
        Move -1999       to RetvalType.iType

        Move 0 to iStart
        Move (Uppercase(sType)) to sType
        Move (iType <= -1490) to bFrameworkDataFlexType
        If (bFrameworkDataFlexType = True) Begin
            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
            Function_Return RetvalType
        End

        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray

        Move (SizeOfArray(ColumnTypeArray)) to iSize
        Decrement iSize

        for iCount from iStart to iSize
            Move ColumnTypeArray[iCount].iType to iValue
            Move ColumnTypeArray[iCount].sType to sValue
            If (bIntegerInputType = True) Begin
                If (iValue = iType) Begin
                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
                    Move iType                                  to RetvalType.iType
                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
                    Move iSize to iCount // We're done!
                End
            End
            Else Begin
                Move (Uppercase(sValue)) to sValue
                If (sValue = sType) Begin
                    Move sType                                  to RetvalType.sType
                    Move ColumnTypeArray[iCount].iType          to RetvalType.iType
                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
                    Move iSize to iCount // We're done!
                End
            End
        Loop            
        
        // If no match was found it was probably because it was a DataFlex standard type that was passed.
        // In which case we search for a match in DataFlex standard types:
        If (RetvalType.sType = "Undefined") Begin
            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
            Move (SizeOfArray(ColumnTypeArray)) to iSize
            Decrement iSize
    
            for iCount from iStart to iSize
                Move ColumnTypeArray[iCount].iType to iValue
                Move ColumnTypeArray[iCount].sType to sValue
                If (iValue = iType) Begin
                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
                    Move iType                                  to RetvalType.iType
                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
                    Move iSize to iCount // We're done!
                End
            Loop    
        End

        Function_Return RetvalType
    End_Function

    Function _AllTablesToConvert Returns Integer[]
        Integer[] iTableConvertExceptions iTablesArray
        Handle hTable
        Integer iIndex
        String sTableName
        Boolean bFlexErrs

        // a) Get the exception table array the developer has specified
        Get piTableConvertExceptions to iTableConvertExceptions

        // b) Add CodeMast, CodeType & DbVersion to exceptions
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
                If (bFlexErrs = False) Begin
                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
                        Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
                        If (iIndex = -1) Begin
                            Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
                        End
                    End
                End
            End
        Until (hTable = 0)

        Move 0 to hTable

        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable > 0) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
                If (bFlexErrs = False) Begin
                    Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
                    If (iIndex = -1) Begin
                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
                    End
                End
            End
        Until (hTable = 0)

        Function_Return iTablesArray
    End_Function

    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[] 
        tAPIColumn NewAPIColumn 
        
        Move sFieldName to NewAPIColumn.sFieldName
        Move iType      to NewAPIColumn.iType
        Move iLength    to NewAPIColumn.iLength
        Move iPrecision to NewAPIColumn.iPrecision
        Move iOptions   to NewAPIColumn.iOptions
        
        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
        
        Function_Return aCurrent
    End_Function

    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
        String sRetval sFieldName
        Integer iCount iSize
        
        Move (SizeOfArray(APIIndexSegment)) to iSize
        Decrement iSize
        for iCount from 0 to iSize
            Move APIIndexSegment[iCount].sFieldName to sFieldName
            Move (sRetval * (String(sFieldName))) to sRetval
        Loop                                                
        Move (Trim(sRetval)) to sRetval
        
        Function_Return sRetval
    End_Function

    // *** Miscellaneous other functions ***
    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
    //

    // Callback functionality used when e.g. calling driver functions directly.
    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
        Integer iRetval iPos iPerc
        String sVal1 sVal2
        Number nReady nTotal

        Send DoAdvance of ghoProgressBar

        If (sCallback_Text contains "Copy records") Begin
            Move CS_SQLCopyingData to sCallback_Text
        End
        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
        End
        If (sCallback_Text contains "Creating index") Begin
            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
        End

        Case Begin
            Case (iCallback_Type = DF_Message_Text)
//                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_1)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_2)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_3)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_4)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Heading_5)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Warning)
                Send None
                Case Break
            Case (iCallback_Type = DF_Message_Progress_Title)
                Set Message_Text of ghoStatusPanel to sCallback_Text
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Progress_Value)
                //*** Interpret numbers
                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
                Move ((nReady / nTotal) * 100)                                                    to iPerc
                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
                Case Break
            Case Else
                Set Message_Text to ""
                Set Action_Text  to ""
        Case End

        Send ProcessEvents of ghoStatusPanel
        Function_Return False
    End_Function

    Procedure IncreaseSortBufferSize
        String sNull
        Integer iSortBufferSize
        Boolean bBufferSet

        Move "" to sNull
        Move (1024 * 128) to iSortBufferSize
        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback Self Passing sNull sNull iSortBufferSize Result bBufferSet

    End_Procedure

    Procedure SetAllIndexesToBatch Handle hTable
        Integer iLastIndex iIndex iNumSegments iIndexType
        String sTable
        Boolean bOK
        
        If (hTable > 0) Begin
            Close hTable
            Get OpenTableExclusive hTable to bOK
            If (bOK = False) Begin
                Function_Return False
            End
            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
            for iIndex from 1 to iLastIndex
                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
                If (iNumSegments > 0) Begin
                    Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
                End
            Loop
            Close hTable
        End
    End_Procedure

    Function NextFreeFilelistSlot Returns Handle
        Handle hTable

        Move 0 to hTable
        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable

        Function_Return hTable
    End_Function

    // For debugging purposes. To print Sql statements as they are build...
    Procedure DebugPrint String sStmt String sFileName
        Integer iCh
        Get Seq_Append_Output_Channel sFileName to iCh
            Write channel iCh sStmt
        Send Seq_Close_Channel iCh
    End_Procedure

    // Returns the integer number for the passed Driver ID that is
    // needed by some database API calls.
    Function DriverIndex String sDriverID Returns Integer
        String  sCurrentDriver
        Integer iNumberOfDrivers iDriver iCount

        Move 0 to iDriver

        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
        for iCount from 1 to iNumberOfDrivers

            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
                Move iCount to iDriver
            End
        Loop

        // In case it was not found, it wasn't loaded so we do that now.
        If (iDriver = 0) Begin
            Move False to Err
            Load_Driver sDriverID
            If (Err = False) Begin
                Move 1 to iDriver
            End
        End

        Function_Return iDriver
    End_Function

    // Returns TRUE if table is opened exclusive, otherwise FALSE  
    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
    //       so in that case we "cheat" and report those tables were opened OK.
    Function OpenTableExclusive Handle hTable Returns Boolean
        Integer iMode
        Boolean bOpened bCodeMasterType                        
        String sTableName
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Get_Attribute DF_FILE_OPENED of hTable to bOpened
        If (bOpened) Begin
            If (IsDebuggerPresent()) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
                    Set Error_Report_Mode to DUF_ERROR_REPORT
                    Function_Return True
                End
            End
            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
            If (iMode=DF_EXCLUSIVE) Begin
                    Set Error_Report_Mode to DUF_ERROR_REPORT
                Function_Return True
            End
            Close hTable
        End
        Else Begin
            Open hTable
            Get_Attribute DF_FILE_OPENED of hTable to bOpened
            If (bOpened and IsDebuggerPresent()) Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
                    Set Error_Report_Mode to DUF_ERROR_REPORT
                    Function_Return True
                End
            End
            
        End

        Open hTable Mode DF_EXCLUSIVE
        Get_Attribute DF_FILE_OPENED of hTable to bOpened

        Set Error_Report_Mode to DUF_ERROR_REPORT
        Function_Return bOpened
    End_Function
    
    Function AutoConnectionIDLogin Returns Boolean
        String sConnectionID sConnectionString sDriverID
        Boolean bExists bOK bDAWDriver bSQLDriver
        Handle hoCLI hoDriver
        Integer iRetval
        tSQLConnection SQLConnection
        
        Get psDriverID to sDriverID
        Get IsSQLDriver sDriverID to bSQLDriver
        If (bSQLDriver = False) Begin
            Function_Return True
        End                     
        
        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Move SQLConnection.sDriverID                  to sDriverID
        Move SQLConnection.sConnectionString          to sConnectionString
        Get IsDAWSQLDriver sDriverID to bOK
        If (bOK = True) Begin
//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
        End
        If (bOK = False) Begin
            Get _MertechSQLManagerHandle to hoCLI
            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
            Set psDriverID of hoDriver to SQLConnection.sDriverID
            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
                Send Destroy of hoDriver
            End
            Function_Return False
        End

        Move SQLConnection.sConnectionID to sConnectionID

        Get IsConnectionID sConnectionID sDriverID to bExists
        If (bExists = False) Begin
            // We always start by deleting the current connection - if any - because the
            // login details my have changed.
            Get phoCLIHandler to hoCLI
            Set psDriverID    of hoCLI to sDriverID
            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
            Get UtilCreateConnectionID sConnectionID to bOk
            If (bOk = False) Begin
                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
                Function_Return False
            End
            Move bOK to bExists
        End

        Function_Return (bExists = True)
    End_Function

    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
    // Returns: False if nobody else is running
    //          True if at least one table is open by another process (e.g. another user is running the application)
    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
    //      tables are not locked as DataFlex tables are.
    Function IsDatabaseInUse Returns Boolean
        Handle  hTable
        Integer iTemp
        String  sRootName sOrgOpenPath sOrgFileList
        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs

        Get AutoConnectionIDLogin to bOK
        Move 0 to hTable
        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
        Move False to bErr
        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION

        Repeat
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs

            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
            Move False to bOpen

            // Don't bother about FlexErrs (Normally table 50)
            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
                Open hTable
                Get_Attribute DF_FILE_OPENED of hTable to bOpen
                Set Error_Report_Mode to DUF_ERROR_REPORT
                If (bOpen = True) Begin
                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
                    Get UtilTableIsAlias hTable to bAlias
                    If (bAlias = False) Begin 
                        Close hTable
                        Get OpenTableExclusive hTable to bOpen
                        If (bOpen = False) Begin
                            Move True to bErr
                        End
                    End
                End 
                Close hTable
            End
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (bErr = True ) Break
        Until (not(hTable))

        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
        Move False to Err

        Function_Return bErr
    End_Function

    // Checks if the passed connection id exists in the CLI interface.
    // This might be needed by API-methods when a connection id is to be used and
    // the connection id hasn't been established with the driver's CLI interface.
    // NOTE: Only applicable for DAW drivers.
    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
        String sID sConnString
        Integer iDriver iNumConn iCount
        Handle hoCLI
        Boolean bOK

        Get IsDAWSQLDriver sDriverID to bOK
        If (bOK = False) Begin
            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
            Function_Return False
        End

        Move False to bOK
        Get phoCLIHandler to hoCLI
        If (hoCLI <> 0) Begin
            Set psDriverID of hoCLI to sDriverID
            Get DriverIndex of hoCLI sDriverID to iDriver

            // If driver not loaded; load it.
            If (iDriver = 0) Begin
                Load_Driver sDriverID
                Get DriverIndex sDriverID to iDriver
            End
            If (iDriver <> 0) Begin
                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
                Decrement iNumConn
                for iCount from 0 to iNumConn
                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
                    If (sID = sConnectionID) Move True to bOK
                Loop
            End
        End

        Function_Return bOK
    End_Function

    Function IsDAWSQLDriver String sDriverID Returns Boolean
        Boolean bOK
        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
        Function_Return bOK
    End_Function

    Function IsMertechDriver String sDriverID Returns Boolean
        Boolean bOK
        Move False to bOK
        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
        Function_Return bOK
    End_Function

    Function IsMSSQLDriver Returns Boolean
        Handle ho
        Integer iDriverIndex

        Get DriverIndex MSSQLDRV_ID to iDriverIndex

        Function_Return (iDriverIndex <> 0)
    End_Function

    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
    // attempt to load the driver.
    // Returns true if the passed driver is SQL based.
    Function IsSQLDriver String sDriverID Returns Boolean
        Boolean bOK
        Integer iDriver

        Get IsDAWSQLDriver sDriverID to bOK

        If (bOK = False) Begin
            Get IsMertechDriver sDriverID to bOK
        End

        Function_Return bOK
    End_Function

    // *** Error Handler ***
    //
    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
        String sText
        Integer iSize iErrorMode
        tSqlErrorArray aSqlErrorArray

        If (pbProcessingError(Self)) Begin
            Procedure_Return
        End

        Get Error_Report_Mode to iErrorMode
        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
            Procedure_Return
        End

        Set pbProcessingError to True
        Set pbSqlError to True
        Get paSqlErrorArray      to aSqlErrorArray
        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
        Set paSqlErrorArray      to aSqlErrorArray
        Set pbProcessingError to False
    End_Procedure

    // *** Miscellanous Helper Functions ***
    //
    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
    // returns the table name only; stripped of any path or filename extension.
    Function _TableNameOnly String sName Returns String
        String sPath sExt

        Get ParseFolderName sName to sPath
        If (sPath <> "") Begin
            Move (Replace(sPath, sName, "")) to sName
        End
        Get ParseFileExtension sName to sExt
        If (sExt <> "") Begin
            Move (Replace(("." + sExt), sName, "")) to sName
        End

        Function_Return sName
    End_Function

    // Returns the first datapath found in the psDataPath property.
    // The returned path always ends with a "\"
    Function psDataPathFirstPart Returns String
        String sDataPath
        Integer iCount

        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
        If (iCount > 1) Begin
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
        End
        If (sDataPath <> "") Begin
            Get vFolderFormat sDataPath to sDataPath
        End

        Function_Return sDataPath
    End_Function

    // *** Property Messages ***
    //
    // These "properties" are settings for the cSQLConnectionHandler class, but have been
    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
    //

    Function pSQLConnection Returns tSQLConnection
        tSQLConnection SQLConnection
        If (ghoSQLConnectionHandler = 0) Begin
            // Note: No point in translating as the programmer will see this immediately after compiling the program...
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        Function_Return SQLConnection
    End_Function

    Procedure Set psServer String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            // Note: No point in translating as the programmer will see this immediately after compiling the program...
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psServer of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psServer Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psServer of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set psDatabase String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psDatabase of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDatabase Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psDatabase of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set psUserID String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Set psUserID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psUserID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psUserID of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set psPassword String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psPassword of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psPassword Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psPassword of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set pbTrusted Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbTrusted of ghoSQLConnectionHandler to bValue
    End_Procedure

    Function pbTrusted Returns Boolean
        Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbTrusted of ghoSQLConnectionHandler to bValue
        Function_Return bValue
    End_Function

    Procedure Set pbSilentLogin Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
    End_Procedure

    Function pbSilentLogin Returns Boolean
        Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
        Function_Return bValue
    End_Function

    Procedure Set psConnectionID String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psConnectionID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psConnectionID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psConnectionID of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    Procedure Set psConnectionString String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psConnectionString of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psConnectionString Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psConnectionString of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function

    // The normal connection string looks something like this;
    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
    // ...and the full connection string looks like this;
    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
    Function psFullConnectionString Returns String
        String sConnectionID sConnectionString
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
        Move (Trim(sConnectionID)) to sConnectionID
        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
    End_Function

    Function piConnectionOptions Returns Integer
        Integer iValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
        Function_Return iValue
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue="Default" }
    Procedure Set psSchema String sValue
        tSQLConnection SQLConnection
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psSchema of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psSchema Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psSchema of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue="Default" }
    Procedure Set psBaseTableSpace String sValue
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psBaseTableSpace Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue="Default" }
    Procedure Set psLongTableSpace String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psLongTableSpace Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue="Default" }
    Procedure Set psIndexTableSpace String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psIndexTableSpace Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=True }
    Procedure Set pbUseConnectionID Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbUseConnectionID Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=True }
    Procedure Set pbToANSI Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbToANSI of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbToANSI Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbToANSI of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=True }
    Procedure Set pbRecnum Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbRecnum of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbRecnum Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbRecnum of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=True }
    Procedure Set pbCopyData Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbCopyData of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbCopyData Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbCopyData of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=False }
    Procedure Set pbCompareDate_DateTime Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbCompareDate_DateTime Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=False }
    Procedure Set pbCompareIndexAscending Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbCompareIndexAscending Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="Convert to SQL" InitialValue=False }
    Procedure Set pbCompareIndexUppercase Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbCompareIndexUppercase Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
            Function_Return
        End
        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueASCII String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueASCII Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueBinary String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueBinary Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueDate String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueDate Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueDateTime String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueDateTime Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueNumeric String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueNumeric Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue="Default" }
    Procedure Set psDriverDefaultValueText String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverDefaultValueText Returns String
        String sRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
        Function_Return sRetval
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableASCII Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableASCII Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableBinary Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableBinary Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableDate Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableDate Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableDateTime Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableNumeric Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    { MethodType=Property Category="SQL Driver Defaults" InitialValue=False }
    Procedure Set pbDriverDefaultNullableText Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Procedure_Return
        End
        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbDriverDefaultNullableText Returns Boolean
        Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
            Function_Return
        End
        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
        Function_Return bState
    End_Function

    // Note: If the psDriverID + other connection properties are to be changed,
    //       the psDriverID *must* be the first property that gets changed!
    //       Otherwise errors might be raised by the driver when e.g. the format
    //       for a connection string has the wrong format for that driver.
    { MethodType=Property Category="Database" InitialValue="Default" }
    { EnumList="DATAFLEX, MSSQLDRV, DB2_DRV, ODBC_DRV, SQL_DRV, MDSPGSQL, MDSMYSQL, ORA_DRV" }
    Procedure Set psDriverID String sValue
        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Delegate Set psDriverID to sValue
        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Set psDriverID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDriverID Returns String
        String sDriverID

        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
        // This should get it from the parent object (when using the cDbUpdateHandler class)
        Delegate Get psDriverID to sDriverID
        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Move False to Err

        // ...and in case it didn't use property of this class. Then the library is
        // probably used as "utilites" from a special made program and
        // the ghoSQLConnectionHandler must have been setup
        If (sDriverID = "") Begin
            Get psDriverID of ghoSQLConnectionHandler to sDriverID
        End
        Function_Return sDriverID
    End_Function

    { MethodType=Property Category="Database" InitialValue=Default }
    { EnumList="EN_DbTypeMSSQL, EN_DbTypeMySQL, EN_DbTypeOracle, EN_DbTypeDB2, EN_DbTypePostgre, EN_DbTypeDataFlex" }
    Procedure Set piDbType Integer iValue
        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Delegate Set piDbType to iValue
        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
        Set piDbType of ghoSQLConnectionHandler to iValue
    End_Procedure

    Function piDbType Returns String
        Integer iRetval

//        Move False to Err
//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
        // This should get it from the parent object (when using the cDbUpdateHandler class)
//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
//        Delegate Get piDbType to iRetval
//        Set Error_Report_Mode to DUF_ERROR_REPORT
//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE

        // ...and in case it didn't use property of this class. Then the library is
        // probably used as "utilites" from a special made program and
        // the ghoSQLConnectionHandler must have been setup
//        If (Err = True) Begin
            Get piDbType of ghoSQLConnectionHandler to iRetval
//        End

//        Move False to Err
        Function_Return iRetval
    End_Function  
    
    Function phoLogFile Returns Handle
        Handle hoLogFile
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Delegate Get phoLogFile to hoLogFile
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return hoLogFile
    End_Function

    Function pnCurrentVersionUpdate Returns Number
        Number nCurrentVersionUpdate

        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
        Set Error_Report_Mode to DUF_ERROR_REPORT

        Function_Return nCurrentVersionUpdate
    End_Function
    
    Procedure LogError String sText Boolean bError
        Handle hoLogFile 
        Number nCurrentVersionUpdate
        
        Get phoLogFile to hoLogFile
        If (hoLogFile = 0) Begin
            Procedure_Return
        End 
        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
        
        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
        Set Error_Report_Mode to DUF_ERROR_REPORT
    End_Procedure        
    
    Function pbContinueOnError Returns Boolean
        Boolean bContinueOnError
        If (ghoDbUpdateHandler > 0) Begin
            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
        End
        Function_Return bContinueOnError
    End_Function

    // Messages not available in pre DF18 versions:
#IF (Required_RT_Version < 18)
    // Splits a string into an array of strings using the given delimiter.
    //
    // Params:
    //     sString     The string to split.
    //     sDel        The delimiter (like "," or "|")
    // Returns:
    //     Array of strings (not including the delimiters itself.
    Function StrSplitToArray String sString String sDel Returns String[]
        String[] asResult
        Integer iStart iEnd iDel
        
        If (sString <> "") Begin
            
            Move 1 to iStart
            
            Move (Length(sDel)) to iDel
            Move (Pos(sDel, sString, iStart)) to iEnd
            
            If (iEnd > 0) Begin
                While (iEnd > 0)
                    Move (Mid(sString,  iEnd - iStart, iStart)) to asResult[SizeOfArray(asResult)]
                    
                    Move (iEnd + iDel) to iStart
                    Move (Pos(sDel, sString, iStart)) to iEnd
                Loop
                
                Move (Right(sString,  Length(sString) - iStart + 1)) to asResult[SizeOfArray(asResult)]
            End
            Else Begin
                Move sString to asResult[0]
            End
        End
        
        Function_Return asResult
    End_Function
#ENDIF  

    Function StrToFieldNumber Integer iFile String sField Returns Integer 
        Integer iMax iPos 
        String sName 
        
        Move (Lowercase(sField)) to sField
        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax 
        for iPos from 0 to iMax 
            Get_Attribute DF_FIELD_NAME of iFile iPos to sName 
            Move (Lowercase(sName)) to sName 
            If (sName = sField) Begin
                Function_Return iPos 
            End
        Loop
        Function_Return -1 
    End_Function


    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
    // For data types that are stored inline in the rows (int for example) it may even take up space on
    // the new rows added after the alter statement. to get around this you need to create a clustered
    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
    //   ALTER TABLE MyTable
    //       REBUILD
    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
        Boolean bOK

        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
            Function_Return False
        End

        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK

        Function_Return (bOK = True)
    End_Function


    // *** Helper functions with compiled sql script code ***
    //
    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
    // For data types that are stored inline in the rows (int for example) it may even take up space on
    // the new rows added after the alter statement. To get around this you need to create a clustered
    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
    //   ALTER TABLE MyTable
    //       REBUILD
    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
        tSQLScriptArray SQLScriptArray
        String sDriverID sVal
        Boolean bOK
        Integer iSize iCount

        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
            Function_Return False
        End

        Get psDriverID to sDriverID
        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
        If (SQLScriptArray.bError = True) Begin
            Function_Return False
        End

        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
        Decrement iSize

        for iCount from 0 to iSize
            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
            End
            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
            End
        Loop

        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK

        Function_Return (bOK = True)
    End_Function

    // *** Helper functions for Mertech Drivers ***
    // Created to not clutter up the standard function code with lots of #IFDEF's
    // and commands that the Studio editor knows nothing about.
    Function _MertechDeleteTDFile String sTableName Returns Integer
        Integer iRetval
        String sPath

        #IFDEF DUF_Use_Mertech_Drivers
            SQL_GET_LOCAL_TD_PATH to sPath
        #ENDIF
        If (sPath = "" or sTableName = "") Begin
            Function_Return 0
        End

        Get vFolderFormat sPath to sPath
        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
        Function_Return iRetval
    End_Function

    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
        Move False to Err
        #IFDEF DUF_Use_Mertech_Drivers
            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to False
            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to False
            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to False
            OUTPUT_INT_FILE for hTable to (sDataPath + sPhysicalFileName)
        #ENDIF
        Function_Return (Err = False)
    End_Function

    Function _MertechEnumerateSQLFlexServers Returns String[]
        Integer iNumItems iCount
        String[] sReturnArray
        String sServer

        #IFDEF DUF_Use_Mertech_Drivers
        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
        For iCount from 1 to iNumItems
            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
            Move sServer to sReturnArray[iCount -1]
        Loop
        #ENDIF

        Function_Return sReturnArray
    End_Function

    Function _MertechEnumerateORAFLEXServers Returns String[]
        String[] sReturnArray
        String sServer

        #IFDEF DUF_Use_Mertech_Drivers
        GET_CURRENT_SQL_SERVER to sServer
        Move sServer to sReturnArray[0]
        #ENDIF

        Function_Return sReturnArray
    End_Function

    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
        Handle hoSQLHandler hoSQLConnect

        Move 0 to hoSQLConnect
        #IFDEF DUF_Use_Mertech_Drivers
            Get _MertechSQLManagerHandle to hoSQLHandler
            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
        #ENDIF

        Function_Return hoSQLConnect
    End_Function

    // Returns the handle of the Mertech SQL handler.
    // It also ensures that the correct Server & Database attributes are set both for
    // embedded SQL calls and "normal" database commands like e.g. "Open".
    Function _MertechSQLManagerHandle Returns Handle
        Handle hoSQLHandler
        String sDriverID sServer sDatabase

        Move 0 to hoSQLHandler
        Get psDriverID to sDriverID
        Get psServer   to sServer
        Get psDatabase to sDatabase
        #IFDEF DUF_Use_Mertech_Drivers
        // This command is used to set the server to be used when opening tables
        SET_CURRENT_SQL_SERVER            to sServer
        // This command is used to specify which server to use for embedded SQL statements,
        // but it has been constructed rather studidly as only constants and not variables
        // are allowed...
        If (sDriverID = MDSPgSQL) Begin
            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
        End
        If (sDriverID = MDSMySQL) Begin
            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
        End
        If (sDriverID = ORAFLEX) Begin
            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
        End
        If (sDriverID = SQLFLEX) Begin
            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
        End

        // This command is used to specify which database is used for SQL statements only.
        SQL_USE_DATABASE sDatabase
        SET_DATABASE_NAME to sDatabase

        Get phoSQLManagerMT to hoSQLHandler
        #ENDIF

        Function_Return hoSQLHandler
    End_Function

    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
    // macro-commands <sigh!>
    // Note: The function sets the Err flag.
    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
        Move False to Err

        #IFDEF DUF_Use_Mertech_Drivers
            MERTECH_WARNING_MESSAGE Disabled
            SET_DATABASE_NAME to sDatabase
            If (sBaseTableSpace <> "") Begin
                SET_DEFAULT_TABLESPACE to sBaseTableSpace
            End
            If (sIndexTableSpace <> "") Begin
                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
            End
            CREATE_TABLE_FROM_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_NOT_NULL sRootName
            If (bCopyData = True) Begin
                COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
            End
        #ENDIF

        Function_Return (Err = False)
    End_Function

End_Class
