Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFCodeGenerator.src
Memory Available: 2147483646
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dfallent.pkd)
79228>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardCommandBarSystem.pkg)
79228>>>// these are all the packages used in a standard MDI menubar/toolbar system
79228>>>
79228>>>Use cCJCommandBarSystem.pkg
79228>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardMenuItemClasses.pkg)
79228>>>>>Use Dfpanel.pkg
79228>>>>>Use cCJCommandBarSystem.pkg
79228>>>>>Use LanguageText.pkg
79228>>>>>
79228>>>>>
79228>>>>>Class cCJUndoMenuItem is a cCJMenuItem
79229>>>>>    
79229>>>>>    Procedure Construct_Object
79231>>>>>        Forward Send Construct_Object
79233>>>>>        Set psCaption   to C_$CaptionUndo
79234>>>>>        Set psToolTip to C_$ToolTipUndo
79235>>>>>        Set psDescription to C_$DescUndo
79236>>>>>        Set psImage to "ActionUndo.ico"
79237>>>>>        Set pbActiveUpdate to True
79238>>>>>        Set psCategory to C_$CategoryEdit
79239>>>>>        Set psShortcut to C_$Key_Ctrl_Z
79240>>>>>    End_Procedure
79241>>>>>
79241>>>>>    Procedure OnExecute Variant vCommandBarControl
79243>>>>>        Send Undo of (focus(Self))
79244>>>>>    End_Procedure
79245>>>>>    
79245>>>>>    Function IsEnabled Returns Boolean
79247>>>>>        Boolean bEnabled
79247>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
79248>>>>>        Function_Return bEnabled
79249>>>>>    End_Function
79250>>>>>         
79250>>>>>End_Class
79251>>>>>
79251>>>>>
79251>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
79252>>>>>    
79252>>>>>    Procedure Construct_Object
79254>>>>>        Forward Send Construct_Object
79256>>>>>        Set psCaption   to C_$CaptionDelete
79257>>>>>        Set psToolTip to C_$ToolTipDelete
79258>>>>>        Set psDescription to C_$DescDelete
79259>>>>>        Set psImage to "actionDelete.ico"
79260>>>>>        Set psShortcut to C_$Key_Delete
79261>>>>>        Set pbActiveUpdate to True
79262>>>>>        Set psCategory to C_$CategoryEdit
79263>>>>>    End_Procedure
79264>>>>>
79264>>>>>
79264>>>>>    Procedure OnExecute Variant vCommandBarControl
79266>>>>>        Send Delete of (focus(Self))
79267>>>>>    End_Procedure
79268>>>>>    
79268>>>>>    Function IsEnabled Returns Boolean
79270>>>>>        Boolean bEnabled
79270>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
79271>>>>>        Function_Return bEnabled
79272>>>>>    End_Function
79273>>>>>         
79273>>>>>End_Class
79274>>>>>
79274>>>>>
79274>>>>>Class cCJCutMenuItem is a cCJMenuItem
79275>>>>>    
79275>>>>>    Procedure Construct_Object
79277>>>>>        Forward Send Construct_Object
79279>>>>>        Set psCaption   to C_$CaptionCut
79280>>>>>        Set psToolTip to C_$TooltipCut
79281>>>>>        Set psDescription to C_$DescCut
79282>>>>>        Set psImage to "actionCut.ico"
79283>>>>>        Set psShortcut to C_$Key_Ctrl_X
79284>>>>>        Set pbActiveUpdate to True
79285>>>>>        Set psCategory to C_$CategoryEdit
79286>>>>>    End_Procedure
79287>>>>>
79287>>>>>
79287>>>>>    Procedure OnExecute Variant vCommandBarControl
79289>>>>>        Send Cut of (focus(Self))
79290>>>>>    End_Procedure
79291>>>>>    
79291>>>>>    Function IsEnabled Returns Boolean
79293>>>>>        Boolean bEnabled
79293>>>>>        Get CanCut of (Focus(Self)) to bEnabled
79294>>>>>        Function_Return bEnabled
79295>>>>>    End_Function
79296>>>>>         
79296>>>>>End_Class
79297>>>>>
79297>>>>>
79297>>>>>Class cCJCopyMenuItem is a cCJMenuItem
79298>>>>>    
79298>>>>>    Procedure Construct_Object
79300>>>>>        Forward Send Construct_Object
79302>>>>>        Set psCaption   to C_$CaptionCopy
79303>>>>>        Set psToolTip to C_$ToolTipCopy
79304>>>>>        Set psDescription to C_$DescCopy
79305>>>>>        Set psImage to "actionCopy.ico"
79306>>>>>        Set psShortcut to C_$Key_Ctrl_C
79307>>>>>        Set pbActiveUpdate to True
79308>>>>>        Set psCategory to C_$CategoryEdit
79309>>>>>    End_Procedure
79310>>>>>
79310>>>>>
79310>>>>>    Procedure OnExecute Variant vCommandBarControl
79312>>>>>        Send Copy of (focus(Self))
79313>>>>>    End_Procedure
79314>>>>>    
79314>>>>>    Function IsEnabled Returns Boolean
79316>>>>>        Boolean bEnabled
79316>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
79317>>>>>        Function_Return bEnabled
79318>>>>>    End_Function
79319>>>>>         
79319>>>>>End_Class
79320>>>>>
79320>>>>>
79320>>>>>Class cCJPasteMenuItem is a cCJMenuItem
79321>>>>>    
79321>>>>>    Procedure Construct_Object
79323>>>>>        Forward Send Construct_Object
79325>>>>>        Set psCaption   to C_$CaptionPaste
79326>>>>>        Set psToolTip to C_$ToolTipPaste
79327>>>>>        Set psDescription to C_$DescPaste
79328>>>>>        Set psImage to "actionPaste.ico"
79329>>>>>        Set pbActiveUpdate to True
79330>>>>>        Set psShortcut to C_$Key_Ctrl_V
79331>>>>>        Set psCategory to C_$CategoryEdit
79332>>>>>    End_Procedure
79333>>>>>
79333>>>>>
79333>>>>>    Procedure OnExecute Variant vCommandBarControl
79335>>>>>        Send Paste of (focus(Self))
79336>>>>>    End_Procedure
79337>>>>>    
79337>>>>>    Function IsEnabled Returns Boolean
79339>>>>>        Boolean bEnabled
79339>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
79340>>>>>        Function_Return bEnabled
79341>>>>>    End_Function
79342>>>>>         
79342>>>>>End_Class
79343>>>>>
79343>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
79344>>>>>    
79344>>>>>    Procedure Construct_Object
79346>>>>>        Forward Send Construct_Object
79348>>>>>        Set psCaption   to C_$CaptionSelectAll
79349>>>>>        Set psToolTip to C_$ToolTipSelectAll
79350>>>>>        Set psDescription to C_$DescSelectAll
79351>>>>>        Set pbActiveUpdate to True
79352>>>>>        Set psShortcut to C_$Key_Ctrl_A
79353>>>>>        Set psCategory to C_$CategoryEdit
79354>>>>>    End_Procedure
79355>>>>>
79355>>>>>
79355>>>>>    Procedure OnExecute Variant vCommandBarControl
79357>>>>>        Send Select_All of (focus(Self))
79358>>>>>    End_Procedure
79359>>>>>    
79359>>>>>    Function IsEnabled Returns Boolean
79361>>>>>        Boolean bEnabled
79361>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
79362>>>>>        Function_Return bEnabled
79363>>>>>    End_Function
79364>>>>>         
79364>>>>>End_Class
79365>>>>>
79365>>>>> 
79365>>>>>Class cCJExitMenuItem is a cCJMenuItem
79366>>>>>
79366>>>>>    Procedure Construct_Object
79368>>>>>        Forward Send Construct_Object
79370>>>>>        Set psCaption to C_$CaptionExit
79371>>>>>        Set psToolTip to C_$ToolTipExit
79372>>>>>        Set psDescription to C_$ToolTipExit
79373>>>>>        Set psShortcut to C_$Key_Alt_F4
79374>>>>>        Set psCategory to C_$CategoryFile
79375>>>>>    End_Procedure
79376>>>>>
79376>>>>>    Procedure OnExecute Variant vCommandBarControl
79378>>>>>        Send Exit_Application of Desktop
79379>>>>>    End_Procedure
79380>>>>>
79380>>>>>End_Class           
79381>>>>>
79381>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
79382>>>>>
79382>>>>>    Procedure Construct_Object
79384>>>>>        Forward Send Construct_Object
79386>>>>>        Set psCaption to C_$CaptionHelp
79387>>>>>        Set psDescription to C_$ToolTipHelp
79388>>>>>        Set psToolTip to C_$DescHelp
79389>>>>>        Set psImage to "ActionHelp.ico"
79390>>>>>        Set psShortcut to "F1"
79391>>>>>        Set psCategory to C_$CategoryHelp
79392>>>>>    End_Procedure
79393>>>>>    
79393>>>>>    Procedure OnExecute Variant vCommandBarControl
79395>>>>>        Send Help of (Focus(Self))
79396>>>>>    End_Procedure
79397>>>>>
79397>>>>>End_Class
79398>>>>>
79398>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
79399>>>>>
79399>>>>>    Procedure Construct_Object
79401>>>>>        Forward Send Construct_Object
79403>>>>>        Set psCaption to C_$CaptionAddStatusbar
79404>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
79405>>>>>        Set psDescription to  C_$DescAddStatusbar
79406>>>>>        Set psCategory to C_$CategoryWindow
79407>>>>>    End_Procedure
79408>>>>>
79408>>>>>    Procedure OnExecute Variant vCommandBarControl
79410>>>>>        Handle hoCommandBars hoClientArea
79410>>>>>        Get CommandBarSystemObject to hoCommandBars
79411>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79412>>>>>        If hoClientArea Begin
79414>>>>>            // the clientarea's parent panel has message
79414>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
79415>>>>>        End
79415>>>>>>
79415>>>>>    End_Procedure
79416>>>>>
79416>>>>>     Function IsChecked Returns Boolean
79418>>>>>        Boolean bOn
79418>>>>>        Handle hoCommandBars hoClientArea
79418>>>>>        Get CommandBarSystemObject to hoCommandBars
79419>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79420>>>>>        If hoClientArea Begin
79422>>>>>            // the clientarea's parent panel has message
79422>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
79423>>>>>        End
79423>>>>>>
79423>>>>>        Function_Return bOn
79424>>>>>     End_Function
79425>>>>>End_Class
79426>>>>>
79426>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
79427>>>>>
79427>>>>>    Procedure Construct_Object
79429>>>>>        Forward Send Construct_Object
79431>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
79432>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
79433>>>>>        Set psDescription to C_$DescAutoArrangeIcons
79434>>>>>        Set psCategory to C_$CategoryWindow
79435>>>>>    End_Procedure
79436>>>>>
79436>>>>>    Procedure OnExecute Variant vCommandBarControl
79438>>>>>        Handle hoCommandBars hoClientArea
79438>>>>>        Get CommandBarSystemObject to hoCommandBars
79439>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79440>>>>>        If hoClientArea Begin
79442>>>>>            // the clientarea's parent panel has message
79442>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
79443>>>>>        End
79443>>>>>>
79443>>>>>    End_Procedure
79444>>>>>    
79444>>>>>     Function IsChecked Returns Boolean
79446>>>>>        Boolean bOn
79446>>>>>        Handle hoCommandBars hoClientArea
79446>>>>>        Get CommandBarSystemObject to hoCommandBars
79447>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79448>>>>>        If hoClientArea Begin
79450>>>>>            // the clientarea's parent panel has message
79450>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
79451>>>>>        End
79451>>>>>>
79451>>>>>        Function_Return bOn
79452>>>>>     End_Function
79453>>>>>End_Class
79454>>>>>
79454>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
79455>>>>>
79455>>>>>    Procedure Construct_Object
79457>>>>>        Forward Send Construct_Object
79459>>>>>        Set psCaption to C_$CaptionRestoreMenus
79460>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
79461>>>>>        Set psDescription to C_$DescRestoreMenus
79462>>>>>        Set psCategory to C_$CategoryWindow
79463>>>>>    End_Procedure
79464>>>>>
79464>>>>>    Procedure OnExecute Variant vCommandBarControl
79466>>>>>        Handle hoCommandBars
79466>>>>>        Get CommandBarSystemObject to hoCommandBars
79467>>>>>        Send RestoreLayout of hoCommandBars
79468>>>>>    End_Procedure
79469>>>>>    
79469>>>>>End_Class
79470>>>>>
79470>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
79471>>>>>
79471>>>>>    Procedure Construct_Object
79473>>>>>        Forward Send Construct_Object
79475>>>>>        Set psCaption to C_$CaptionCascade
79476>>>>>        Set psToolTip to C_$ToolTipCascade
79477>>>>>        Set psDescription to  C_$DescCascade
79478>>>>>        Set psImage to "ActionCascade.ico"
79479>>>>>        Set psCategory to C_$CategoryWindow
79480>>>>>    End_Procedure
79481>>>>>    
79481>>>>>    Procedure OnExecute Variant vCommandBarControl
79483>>>>>        Handle hoCommandBars hoClientArea
79483>>>>>        Get CommandBarSystemObject to hoCommandBars
79484>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79485>>>>>        If hoClientArea Begin
79487>>>>>            Send Cascade_Windows of hoClientArea
79488>>>>>        End
79488>>>>>>
79488>>>>>    End_Procedure
79489>>>>>End_Class
79490>>>>>
79490>>>>>Class cCJTileHorizontally is a cCJMenuItem
79491>>>>>
79491>>>>>    Procedure Construct_Object
79493>>>>>        Forward Send Construct_Object
79495>>>>>        Set psCaption to C_$CaptionTileHorizontally 
79496>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
79497>>>>>        Set psDescription to  C_$DescTileHorizontally
79498>>>>>        Set psImage to "ActionTileHorizontally.ico"
79499>>>>>        Set psCategory to C_$CategoryWindow
79500>>>>>    End_Procedure
79501>>>>>
79501>>>>>    Procedure OnExecute Variant vCommandBarControl
79503>>>>>        Handle hoCommandBars hoClientArea
79503>>>>>        Get CommandBarSystemObject to hoCommandBars
79504>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79505>>>>>        If hoClientArea Begin
79507>>>>>            Send Tile_Windows_Horizontal of hoClientArea
79508>>>>>        End
79508>>>>>>
79508>>>>>    End_Procedure
79509>>>>>End_Class
79510>>>>>
79510>>>>>Class cCJTileVertically is a cCJMenuItem
79511>>>>>
79511>>>>>    Procedure Construct_Object
79513>>>>>        Forward Send Construct_Object
79515>>>>>        Set psCaption to C_$CaptionTileVertically  
79516>>>>>        Set psToolTip to C_$ToolTipTileVertically
79517>>>>>        Set psDescription to  C_$DescTileVertically
79518>>>>>        Set psImage to "ActionTileVertically.ico"
79519>>>>>        Set psCategory to C_$CategoryWindow
79520>>>>>    End_Procedure
79521>>>>>
79521>>>>>    Procedure OnExecute Variant vCommandBarControl
79523>>>>>        Handle hoCommandBars hoClientArea
79523>>>>>        Get CommandBarSystemObject to hoCommandBars
79524>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79525>>>>>        If hoClientArea Begin
79527>>>>>            Send Tile_Windows_Vertical of hoClientArea
79528>>>>>        End
79528>>>>>>
79528>>>>>    End_Procedure
79529>>>>>End_Class
79530>>>>>
79530>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
79531>>>>>
79531>>>>>    Procedure Construct_Object
79533>>>>>        Forward Send Construct_Object
79535>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
79536>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
79537>>>>>        Set psDescription to  C_$DescMinimizeWindows
79538>>>>>        Set psCategory to C_$CategoryWindow
79539>>>>>    End_Procedure
79540>>>>>
79540>>>>>    Procedure OnExecute Variant vCommandBarControl
79542>>>>>        Handle hoCommandBars hoClientArea
79542>>>>>        Get CommandBarSystemObject to hoCommandBars
79543>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79544>>>>>        If hoClientArea Begin
79546>>>>>            // the clientarea's parent panel has message
79546>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
79547>>>>>        End
79547>>>>>>
79547>>>>>    End_Procedure
79548>>>>>End_Class
79549>>>>>
79549>>>>>
79549>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
79550>>>>>
79550>>>>>    Procedure Construct_Object
79552>>>>>        Forward Send Construct_Object
79554>>>>>        Set psCaption to C_$CaptionRestoreWindows
79555>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
79556>>>>>        Set psDescription to  C_$DescRestoreWindows
79557>>>>>        Set psCategory to C_$CategoryWindow
79558>>>>>    End_Procedure
79559>>>>>
79559>>>>>    Procedure OnExecute Variant vCommandBarControl
79561>>>>>        Handle hoCommandBars hoClientArea
79561>>>>>        Get CommandBarSystemObject to hoCommandBars
79562>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79563>>>>>        If hoClientArea Begin
79565>>>>>            // the clientarea's parent panel has message
79565>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
79566>>>>>        End
79566>>>>>>
79566>>>>>    End_Procedure
79567>>>>>End_Class
79568>>>>>
79568>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
79569>>>>>
79569>>>>>    Procedure Construct_Object
79571>>>>>        Forward Send Construct_Object
79573>>>>>        Set psCaption to C_$CaptionArrangeIcons  
79574>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
79575>>>>>        Set psDescription to  C_$DescArrangeIcons
79576>>>>>        Set psCategory to C_$CategoryWindow
79577>>>>>    End_Procedure
79578>>>>>
79578>>>>>    Procedure OnExecute Variant vCommandBarControl
79580>>>>>        Handle hoCommandBars hoClientArea
79580>>>>>        Get CommandBarSystemObject to hoCommandBars
79581>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79582>>>>>        If hoClientArea Begin
79584>>>>>            Send Arrange_Icons of hoClientArea
79585>>>>>        End
79585>>>>>>
79585>>>>>    End_Procedure
79586>>>>>
79586>>>>>End_Class
79587>>>>>    
79587>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJAboutMenuItem.pkg)
79587>>>>>Use cCJCommandBarSystem.pkg
79587>>>>>Use LanguageText.pkg
79587>>>>>
79587>>>>>// It is expected that if you use this class that you provide an about object that is
79587>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
79587>>>>>// because you may wish to create your own custom about package.
79587>>>>>
79587>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
79588>>>>>
79588>>>>>    Procedure Construct_Object
79590>>>>>        Forward Send Construct_Object
79592>>>>>        Set psCaption to C_$CaptionAbout
79593>>>>>        Set psDescription to C_$ToolTipAbout
79594>>>>>        Set psToolTip to C_$DescAbout
79595>>>>>        Set psImage to "ActionAbout.ico"
79596>>>>>        Set psCategory to C_$CategoryHelp
79597>>>>>    End_Procedure
79598>>>>>    
79598>>>>>    Procedure OnExecute Variant vCommandBarControl
79600>>>>>        Handle hoCommandBars hoClientArea
79600>>>>>        Get CommandBarSystemObject to hoCommandBars
79601>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79602>>>>>        If hoClientArea Begin
79604>>>>>            Send Activate_About of hoClientArea
79605>>>>>        End
79605>>>>>>
79605>>>>>    End_Procedure
79606>>>>>
79606>>>>>End_Class
79607>>>>>
79607>>>>>
79607>>>Use cCJDeoMenuItemClasses.pkg
79607>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJMDIWindowsMenuItem.pkg)
79607>>>>>Use cCJCommandBarSystem.pkg
79607>>>>>
79607>>>>>Register_Function Client_ID Returns Integer
79607>>>>>
79607>>>>>// only used by cCJMDIWIndowsMenuItem
79607>>>>>Class cCJMDIWindowItem is a cCJMenuItem
79608>>>>>
79608>>>>>    Procedure Construct_Object
79610>>>>>        Forward Send Construct_Object
79612>>>>>        Property Handle phWindow 0 // object id of view
79613>>>>>        Set pbControlFlagNoMovable to True
79614>>>>>        Set pbActiveUpdate to True
79615>>>>>    End_Procedure
79616>>>>>    
79616>>>>>    Procedure OnExecute Variant vCommandBarControl
79618>>>>>        Handle hWindow
79618>>>>>        Get phWindow to hWindow
79619>>>>>        Send Activate_View of hWindow
79620>>>>>    End_Procedure
79621>>>>>    
79621>>>>>End_Class                
79622>>>>>
79622>>>>>
79622>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
79623>>>>>    
79623>>>>>    Procedure Construct_Object
79625>>>>>        Forward Send Construct_Object
79627>>>>>        Property Handle[] phArrayOfWindows
79628>>>>>        Set peControlType to xtpControlPopup
79629>>>>>        Set psCategory to C_$CategoryWindow
79630>>>>>    End_Procedure
79631>>>>>    
79631>>>>>     // This adds MDI windows to the existing menu items.
79631>>>>>     // This removes any existing windows menus and always adds a new set to the end
79631>>>>>
79631>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
79633>>>>>        Handle  hClientArea hView
79633>>>>>        String  sLabel
79633>>>>>        Integer i iWindows
79633>>>>>        Handle[] hArrayOfWindows
79634>>>>>        Variant vItem
79634>>>>>        
79634>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
79634>>>>>        // also assume that destroying an action removes all menu instances of that action
79634>>>>>        Get phArrayOfWindows to hArrayOfWindows
79635>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
79636>>>>>        For i from 0 to (iWindows-1)
79642>>>>>>
79642>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
79643>>>>>        Loop
79644>>>>>>
79644>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
79645>>>>>
79645>>>>>        // Add all views to this menu. Create the action and add the item
79645>>>>>        Move 0 to i
79646>>>>>        Get Client_Id to hClientArea // object id of client area
79647>>>>>        If (hClientArea > 0) Begin
79649>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
79650>>>>>            While (hView <> 0)
79654>>>>>                If (Active_State(hView)) Begin
79656>>>>>                    // create the action
79656>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
79657>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
79658>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
79659>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
79660>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
79662>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
79663>>>>>                    End
79663>>>>>>
79663>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
79664>>>>>                    If (i=0) Begin
79666>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
79667>>>>>                    End
79667>>>>>>
79667>>>>>                    // Create a menu item for this action
79667>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
79668>>>>>                    Increment i
79669>>>>>                End
79669>>>>>>
79669>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
79670>>>>>            Loop
79671>>>>>>
79671>>>>>        End
79671>>>>>>
79671>>>>>
79671>>>>>        Set phArrayOfWindows to hArrayOfWindows
79672>>>>>
79672>>>>>     End_Procedure
79673>>>>>     
79673>>>>>End_Class
79674>>>>>
79674>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
79674>>>//****************************************************************************
79674>>>// $Module type: Class
79674>>>// $Module name: cDbUpdateHandler
79674>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
79674>>>// Web-site    : http://www.rdctools.com
79674>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
79674>>>//
79674>>>// Purpose     : A framework for doing automated code based updates of a database from within
79674>>>//               a program, when it is started.
79674>>>//
79674>>>// Description : Place _one_ object of this class right after the cApplication object.
79674>>>//               Then inside this object place a series of cDbUpdateVersion objects
79674>>>//               as childs. One child object for each new database update.
79674>>>//
79674>>>//               - OnPreUpdate is a pre-processing event called
79674>>>//               before any database changes are started.
79674>>>//               - OnPostUpdate is a post-processing event called after all
79674>>>//               database changes have taken place.
79674>>>//
79674>>>// Note        : If tables have been opened prior to an object of this class
79674>>>//               (e.g. in the cApplication object), those tables will be closed.
79674>>>//               In that case you need to use the OnPostUpdate hook event to re-open
79674>>>//               tables after the last update has finished.
79674>>>//
79674>>>// Security    : Before an update is attempted; three things are checked to ensure the
79674>>>//               database is not in use. Aka nobody else is running the application.
79674>>>//               - All tables are tested for "Open in Exclusive_Mode"
79674>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
79674>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
79674>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
79674>>>//                 folder and a bit-lock is performed for each start of the application and this
79674>>>//                 user counter is checked before an update is attempted.
79674>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
79674>>>//                            against the database being "in use", there is no such guarantee! The
79674>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
79674>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
79674>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
79674>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
79674>>>//                 automatically be released after the update is completed.
79674>>>//
79674>>>//
79674>>>// Usage       :  Use cDbUpdateHandler.pkg
79674>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
79674>>>//                    // Declare the table that contains a "database version" field.
79674>>>//                    Declare_Datafile Sys
79674>>>//                    // Either one of these syntaxes is fine:
79674>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
79674>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
79674>>>//
79674>>>//                    // Don't forget to increase the pnVersionNumber property for each
79674>>>//                    // cDbUpdateVersion object!
79674>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
79674>>>//                    // with the value of pnVersionNumber after each update has been finished.
79674>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
79674>>>//                        Set pnVersionNumber to 1.1
79674>>>//                        Use VersionUpdate1_1.pkg
79674>>>//                    End_Object
79674>>>//
79674>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
79674>>>//                        Set pnVersionNumber to 1.2
79674>>>//                        Use VersionUpdate1_2.pkg
79674>>>//                    End_Object
79674>>>//
79674>>>//                End_Object
79674>>>//
79674>>>//
79674>>>// $Rev History:
79674>>>//    2016-09-27  Module header created
79674>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
79674>>>//                take place before any tables have been opened, or errors
79674>>>//                could occur if the client database is out of sync with the
79674>>>//                compiled program.
79674>>>//                Added user counting checks + lockout while database is being
79674>>>//                updated.
79674>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
79674>>>//                as it is more in line with the child class cDbUpdateVersion name.
79674>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
79674>>>//****************************************************************************
79674>>>Use VdfBase.pkg
79674>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
79674>>>>>// StatPnl.pkg - creates the standard status_panel object.
79674>>>>>//
79674>>>>>//
79674>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
79674>>>>>// invoke the standard status panel. The standard has always been that the package name
79674>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
79674>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
79674>>>>>// prior revisions has been replace with status panel that is part of the application.
79674>>>>>// This should work much better and faster than the old sentinel based solution.
79674>>>>>// While the way this operates has changed, the interface has not and therefore this should work
79674>>>>>// with most applications.
79674>>>>>//
79674>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
79674>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
79674>>>>>// a cleaner more robust interface.
79674>>>>>//
79674>>>>>//
79674>>>>>// Compatibility Note:
79674>>>>>//
79674>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
79674>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
79674>>>>>//
79674>>>>>// If for some reason you application will not work using this as a replacement for the old status
79674>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
79674>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
79674>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
79674>>>>>//
79674>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
79674>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
79674>>>>>//
79674>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
79674>>>>>// can still access the new object via the ghoStatusPanel handle.
79674>>>>>//
79674>>>>>//
79674>>>>>// Creating your own Status Panel objects
79674>>>>>//
79674>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
79674>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
79674>>>>>// with a different file and object name and direct your status panel request to the new object.
79674>>>>>//
79674>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
79674>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
79674>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
79674>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
79674>>>>>// e.g.
79674>>>>>//       Procedure UpdateStatusBar
79674>>>>>//           Send DoAdvance of oProgressBar
79674>>>>>//           Send ProcessEvents
79674>>>>>//       End_Procedure
79674>>>>>//
79674>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
79674>>>>>// messages this will be done for you.
79674>>>>>//
79674>>>>>// the standard Interface for status panels are:
79674>>>>>//
79674>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
79674>>>>>// Send Start_StatusPanel      - start the status panel
79674>>>>>// Send Stop_StatusPanel       - stop the status panel
79674>>>>>// Send Update_StatusPanel     - update the status panel's action area
79674>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
79674>>>>>//
79674>>>>>// Get/Set Caption_Text - updates the caption bar
79674>>>>>// Get/Set Title_Text   - updates the title area
79674>>>>>// Get/Set Message_Text - updates the Message area
79674>>>>>// Get/Set Action_Text  - updates the action area
79674>>>>>// Get/Set Button_Text  - updates the button area
79674>>>>>//
79674>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
79674>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
79674>>>>>//
79674>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
79674>>>>>Use cProcessStatusPanel.pkg
79674>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJSkinFramework.pkg)
79674>>>>>>>Use windows.pkg
79674>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJComSkinFramework.pkg)
79674>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v17.3.0\Bin\Codejock.SkinFramework.v17.3.0.ocx
79674>>>>>>>>>Use FlexCom20.pkg
79674>>>>>>>>>
79674>>>>>>>>>// Changes to Imported package
79674>>>>>>>>>//     OLEXTPxx to XTPxx
79674>>>>>>>>>//     OLExtpxx to xtpxx
79674>>>>>>>>>//     OLESkinFramework to SkinFramework
79674>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
79674>>>>>>>>>//     cCom classes to cCJ
79674>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
79674>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
79674>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
79674>>>>>>>>>//     Use statements as noted below (classes moved to these files)
79674>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
79674>>>>>>>>>
79674>>>>>>>>>// These have been extracted from this class and moved into seperate packages
79674>>>>>>>>>// because other Codejock classes use these.
79674>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
79674>>>>>>>>>
79674>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
79674>>>>>>>>>    Define xtpSkinApplyMetrics for 1
79674>>>>>>>>>    Define xtpSkinApplyFrame for 2
79674>>>>>>>>>    Define xtpSkinApplyColors for 4
79674>>>>>>>>>    Define xtpSkinApplyMenus for 8
79674>>>>>>>>>
79674>>>>>>>>>// CLSID: {AFA0E6A1-28D7-4F2C-87A7-7266367B4655}
79674>>>>>>>>>// Dispatch interface for SkinFramework Control
79674>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
79675>>>>>>>>>
79675>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
79677>>>>>>>>>        SkinFrameworkApplyOptions retVal
79677>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
79678>>>>>>>>>        Function_Return retVal
79679>>>>>>>>>    End_Function
79680>>>>>>>>>
79680>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
79682>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
79683>>>>>>>>>    End_Procedure
79684>>>>>>>>>
79684>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
79686>>>>>>>>>        Boolean retVal
79686>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
79687>>>>>>>>>        Function_Return retVal
79688>>>>>>>>>    End_Function
79689>>>>>>>>>
79689>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
79691>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
79692>>>>>>>>>    End_Procedure
79693>>>>>>>>>
79693>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
79695>>>>>>>>>        Boolean retVal
79695>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
79696>>>>>>>>>        Function_Return retVal
79697>>>>>>>>>    End_Function
79698>>>>>>>>>
79698>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
79700>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
79701>>>>>>>>>    End_Procedure
79702>>>>>>>>>
79702>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
79704>>>>>>>>>        Handle hDispatchDriver
79704>>>>>>>>>        Boolean retVal
79704>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79705>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79706>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
79707>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
79708>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
79709>>>>>>>>>        Function_Return retVal
79710>>>>>>>>>    End_Function
79711>>>>>>>>>
79711>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
79713>>>>>>>>>        Handle hDispatchDriver
79713>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79714>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79715>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79716>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
79717>>>>>>>>>    End_Procedure
79718>>>>>>>>>
79718>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
79720>>>>>>>>>        Handle hDispatchDriver
79720>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79721>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79722>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79723>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
79724>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
79725>>>>>>>>>    End_Procedure
79726>>>>>>>>>
79726>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
79728>>>>>>>>>        Handle hDispatchDriver
79728>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79729>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79730>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79731>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
79732>>>>>>>>>    End_Procedure
79733>>>>>>>>>
79733>>>>>>>>>    Procedure ComRemoveAllWindows
79735>>>>>>>>>        Handle hDispatchDriver
79735>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79736>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
79737>>>>>>>>>    End_Procedure
79738>>>>>>>>>
79738>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
79740>>>>>>>>>        Handle hDispatchDriver
79740>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79741>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79742>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
79743>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
79744>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
79745>>>>>>>>>    End_Procedure
79746>>>>>>>>>
79746>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
79748>>>>>>>>>        Handle hDispatchDriver
79748>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79749>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79750>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
79751>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
79752>>>>>>>>>    End_Procedure
79753>>>>>>>>>
79753>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
79755>>>>>>>>>        Handle hDispatchDriver
79755>>>>>>>>>        Variant retVal
79755>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79756>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79757>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
79758>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
79759>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
79760>>>>>>>>>        Function_Return retVal
79761>>>>>>>>>    End_Function
79762>>>>>>>>>
79762>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
79764>>>>>>>>>        Handle hDispatchDriver
79764>>>>>>>>>        Variant retVal
79764>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79765>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79766>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
79767>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
79768>>>>>>>>>        Function_Return retVal
79769>>>>>>>>>    End_Function
79770>>>>>>>>>
79770>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
79772>>>>>>>>>        Handle hDispatchDriver
79772>>>>>>>>>        OLE_COLOR retVal
79772>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79773>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79774>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79775>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
79776>>>>>>>>>        Function_Return retVal
79777>>>>>>>>>    End_Function
79778>>>>>>>>>
79778>>>>>>>>>    Procedure ComExcludeModule String llModuleName
79780>>>>>>>>>        Handle hDispatchDriver
79780>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79781>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79782>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
79783>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
79784>>>>>>>>>    End_Procedure
79785>>>>>>>>>
79785>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
79787>>>>>>>>>        Handle hDispatchDriver
79787>>>>>>>>>        Variant retVal
79787>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79788>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79789>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
79790>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
79791>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
79792>>>>>>>>>        Function_Return retVal
79793>>>>>>>>>    End_Function
79794>>>>>>>>>
79794>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
79796>>>>>>>>>        Handle hDispatchDriver
79796>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79797>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
79798>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79799>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
79800>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
79801>>>>>>>>>    End_Procedure
79802>>>>>>>>>
79802>>>>>>>>>    Procedure ComAboutBox
79804>>>>>>>>>        Handle hDispatchDriver
79804>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79805>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
79806>>>>>>>>>    End_Procedure
79807>>>>>>>>>End_Class
79808>>>>>>>>>
79808>>>>>>>>>// CLSID: {40217CB8-4463-4030-B324-AC6A8075FEC8}
79808>>>>>>>>>// Event interface for SkinFramework Control
79808>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
79809>>>>>>>>>
79809>>>>>>>>>    Procedure RegisterComEvents
79811>>>>>>>>>    End_Procedure
79812>>>>>>>>>End_Class
79813>>>>>>>>>
79813>>>>>>>>>// CoClass
79813>>>>>>>>>// ProgID: Codejock.SkinFramework.17.3.0
79813>>>>>>>>>// CLSID: {DE67160B-9A3E-4EA6-846E-8C9A72F9F203}
79813>>>>>>>>>// SkinFramework Control
79813>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
79814>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
79815>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
79816>>>>>>>>>
79816>>>>>>>>>    Procedure Construct_Object
79818>>>>>>>>>        Forward Send Construct_Object
79820>>>>>>>>>        Set psProgID to "{DE67160B-9A3E-4EA6-846E-8C9A72F9F203}"
79821>>>>>>>>>        Set psEventId to "{40217CB8-4463-4030-B324-AC6A8075FEC8}"
79822>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2016 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v17.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
79823>>>>>>>>>        Set peAutoCreate to acAutoCreate
79824>>>>>>>>>    End_Procedure
79825>>>>>>>>>End_Class
79826>>>>>>>>>
79826>>>>>>>>>// CLSID: {06E8A85B-70E4-4F71-A0FC-D1D5658C7E17}
79826>>>>>>>>>// SkinFramework Global Settings
79826>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
79827>>>>>>>>>
79827>>>>>>>>>    Function ComLicense Returns String
79829>>>>>>>>>        String retVal
79829>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
79830>>>>>>>>>        Function_Return retVal
79831>>>>>>>>>    End_Function
79832>>>>>>>>>
79832>>>>>>>>>    Procedure Set ComLicense String value
79834>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
79835>>>>>>>>>    End_Procedure
79836>>>>>>>>>
79836>>>>>>>>>    Function ComTitle Returns String
79838>>>>>>>>>        String retVal
79838>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
79839>>>>>>>>>        Function_Return retVal
79840>>>>>>>>>    End_Function
79841>>>>>>>>>
79841>>>>>>>>>    Procedure Set ComTitle String value
79843>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
79844>>>>>>>>>    End_Procedure
79845>>>>>>>>>
79845>>>>>>>>>    Function ComVersion Returns String
79847>>>>>>>>>        Handle hDispatchDriver
79847>>>>>>>>>        String retVal
79847>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79848>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
79849>>>>>>>>>        Function_Return retVal
79850>>>>>>>>>    End_Function
79851>>>>>>>>>
79851>>>>>>>>>    Function ComUnicode Returns Boolean
79853>>>>>>>>>        Handle hDispatchDriver
79853>>>>>>>>>        Boolean retVal
79853>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79854>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
79855>>>>>>>>>        Function_Return retVal
79856>>>>>>>>>    End_Function
79857>>>>>>>>>
79857>>>>>>>>>    Function ComOcxPath Returns String
79859>>>>>>>>>        Handle hDispatchDriver
79859>>>>>>>>>        String retVal
79859>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79860>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
79861>>>>>>>>>        Function_Return retVal
79862>>>>>>>>>    End_Function
79863>>>>>>>>>End_Class
79864>>>>>>>>>
79864>>>>>>>>>// CoClass
79864>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.17.3.0
79864>>>>>>>>>// CLSID: {C4136A4A-67FD-4FC1-BA62-A715B4D60808}
79864>>>>>>>>>// SkinFramework Global Settings
79864>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
79865>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
79866>>>>>>>>>
79866>>>>>>>>>    Procedure Construct_Object
79868>>>>>>>>>        Forward Send Construct_Object
79870>>>>>>>>>        Set psProgID to "{C4136A4A-67FD-4FC1-BA62-A715B4D60808}"
79871>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
79872>>>>>>>>>    End_Procedure
79873>>>>>>>>>End_Class
79874>>>>>>>>>
79874>>>>>>>>>// CLSID: {27E4AC9B-4A2D-4FBB-A782-BD76BEFA4345}
79874>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
79875>>>>>>>>>
79875>>>>>>>>>    Function ComColorScheme Returns String
79877>>>>>>>>>        String retVal
79877>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
79878>>>>>>>>>        Function_Return retVal
79879>>>>>>>>>    End_Function
79880>>>>>>>>>
79880>>>>>>>>>    Procedure Set ComColorScheme String value
79882>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
79883>>>>>>>>>    End_Procedure
79884>>>>>>>>>
79884>>>>>>>>>    Function ComFontSize Returns String
79886>>>>>>>>>        String retVal
79886>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
79887>>>>>>>>>        Function_Return retVal
79888>>>>>>>>>    End_Function
79889>>>>>>>>>
79889>>>>>>>>>    Procedure Set ComFontSize String value
79891>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
79892>>>>>>>>>    End_Procedure
79893>>>>>>>>>
79893>>>>>>>>>    Function ComIniFileName Returns String
79895>>>>>>>>>        String retVal
79895>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
79896>>>>>>>>>        Function_Return retVal
79897>>>>>>>>>    End_Function
79898>>>>>>>>>
79898>>>>>>>>>    Procedure Set ComIniFileName String value
79900>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
79901>>>>>>>>>    End_Procedure
79902>>>>>>>>>End_Class
79903>>>>>>>>>
79903>>>>>>>>>// CLSID: {5005F22B-A30E-4B12-B142-E97F62A927A6}
79903>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
79904>>>>>>>>>
79904>>>>>>>>>    Function ComName Returns String
79906>>>>>>>>>        String retVal
79906>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
79907>>>>>>>>>        Function_Return retVal
79908>>>>>>>>>    End_Function
79909>>>>>>>>>
79909>>>>>>>>>    Procedure Set ComName String value
79911>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
79912>>>>>>>>>    End_Procedure
79913>>>>>>>>>
79913>>>>>>>>>    Function ComPath Returns String
79915>>>>>>>>>        String retVal
79915>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
79916>>>>>>>>>        Function_Return retVal
79917>>>>>>>>>    End_Function
79918>>>>>>>>>
79918>>>>>>>>>    Procedure Set ComPath String value
79920>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
79921>>>>>>>>>    End_Procedure
79922>>>>>>>>>
79922>>>>>>>>>    Function ComCount Returns Integer
79924>>>>>>>>>        Handle hDispatchDriver
79924>>>>>>>>>        Integer retVal
79924>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79925>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
79926>>>>>>>>>        Function_Return retVal
79927>>>>>>>>>    End_Function
79928>>>>>>>>>
79928>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
79930>>>>>>>>>        Handle hDispatchDriver
79930>>>>>>>>>        Variant retVal
79930>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79931>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79932>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79933>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
79934>>>>>>>>>        Function_Return retVal
79935>>>>>>>>>    End_Function
79936>>>>>>>>>
79936>>>>>>>>>    Function Com_NewEnum Returns Variant
79938>>>>>>>>>        Handle hDispatchDriver
79938>>>>>>>>>        Variant retVal
79938>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79939>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
79940>>>>>>>>>        Function_Return retVal
79941>>>>>>>>>    End_Function
79942>>>>>>>>>End_Class
79943>>>>>>>>>
79943>>>>>>>>>// CLSID: {C4367A33-2A7C-4CC6-BF0C-C50383B34B51}
79943>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
79944>>>>>>>>>
79944>>>>>>>>>    Function ComCount Returns Integer
79946>>>>>>>>>        Handle hDispatchDriver
79946>>>>>>>>>        Integer retVal
79946>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79947>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
79948>>>>>>>>>        Function_Return retVal
79949>>>>>>>>>    End_Function
79950>>>>>>>>>
79950>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
79952>>>>>>>>>        Handle hDispatchDriver
79952>>>>>>>>>        Variant retVal
79952>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79953>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
79954>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79955>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
79956>>>>>>>>>        Function_Return retVal
79957>>>>>>>>>    End_Function
79958>>>>>>>>>
79958>>>>>>>>>    Function Com_NewEnum Returns Variant
79960>>>>>>>>>        Handle hDispatchDriver
79960>>>>>>>>>        Variant retVal
79960>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
79961>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
79962>>>>>>>>>        Function_Return retVal
79963>>>>>>>>>    End_Function
79964>>>>>>>>>End_Class
79965>>>>>>>>>
79965>>>>>>>>>// CLSID: {128507E0-C56F-43C0-BCF1-8193B35FE4C4}
79965>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
79966>>>>>>>>>End_Class
79967>>>>>>>Use cApplication.pkg
79967>>>>>>>
79967>>>>>>>Struct tSkinInformation
79967>>>>>>>    String sName     // description of the skin
79967>>>>>>>    String sSkinfile // file path. Can be relative or full
79967>>>>>>>    String sSkinIni  // section name
79967>>>>>>>End_Struct
79967>>>>>>>
79967>>>>>>>
79967>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
79968>>>>>>>    
79968>>>>>>>    Procedure Construct_Object
79970>>>>>>>        Forward Send Construct_Object
79972>>>>>>>        
79972>>>>>>>        Property String psSkinFile ""
79973>>>>>>>        Property String psSkinIni ""
79974>>>>>>>        Property Boolean pbLoadPreference False
79975>>>>>>>        
79975>>>>>>>        Set peAutoCreate to acAutoCreate
79976>>>>>>>        
79976>>>>>>>        Move Self to ghoSkinFramework
79977>>>>>>>    End_Procedure
79978>>>>>>>    
79978>>>>>>>    // return the default skin path, which is the programs directory.
79978>>>>>>>    // This requires an application object.
79978>>>>>>>    // If you want to different skin path, override this.
79978>>>>>>>    Function SkinPath Returns String
79980>>>>>>>        String sPath sPaths
79980>>>>>>>        Handle hoWorkspace
79980>>>>>>>        If ghoApplication Begin
79982>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79983>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
79984>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
79985>>>>>>>        End
79985>>>>>>>>
79985>>>>>>>        Else Begin
79986>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
79987>>>>>>>>
79987>>>>>>>        End
79987>>>>>>>>
79987>>>>>>>        Function_Return sPath
79988>>>>>>>    End_Function
79989>>>>>>>    
79989>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
79989>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
79989>>>>>>>    Function SkinQFile Returns String
79991>>>>>>>        String sFile sPath sSep
79991>>>>>>>        Boolean bQualified
79991>>>>>>>        Get psSkinFile to sFile
79992>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
79994>>>>>>>            Get SkinPath to sPath
79995>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
79996>>>>>>>            Move (sPath - sSep - sFile) to sFile
79997>>>>>>>        End
79997>>>>>>>>
79997>>>>>>>        Function_Return sFile
79998>>>>>>>    End_Function
79999>>>>>>>        
79999>>>>>>>    // defines the default VDF window class mapping.    
79999>>>>>>>    Procedure OnAddVDFWindowClasses
80001>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
80002>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
80003>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
80004>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
80005>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
80006>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
80007>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
80008>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
80009>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
80010>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
80011>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
80012>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient" 
80013>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
80014>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
80015>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
80016>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
80017>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
80018>>>>>>>        // External class
80018>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
80019>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
80020>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
80021>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
80022>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
80023>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
80024>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
80025>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
80026>>>>>>>    End_Procedure
80027>>>>>>>    
80027>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
80027>>>>>>>    Procedure OnAddCustomWindowClasses
80029>>>>>>>    End_Procedure
80030>>>>>>>
80030>>>>>>>    // called when object is created during end_construct_object.
80030>>>>>>>    Procedure OnCreate
80032>>>>>>>        Integer iOpts
80032>>>>>>>        Boolean bUseWindowsFont
80032>>>>>>>        Forward Send OnCreate
80034>>>>>>>        
80034>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
80034>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
80034>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
80035>>>>>>>        If bUseWindowsFont Begin
80037>>>>>>>            Get ComApplyOptions to iOpts
80038>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
80039>>>>>>>        End
80039>>>>>>>>
80039>>>>>>>
80039>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down. 
80039>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
80039>>>>>>>        // and this was the suggested workaround.
80039>>>>>>>        Set ComAutoApplyNewThreads to False
80040>>>>>>>
80040>>>>>>>        Send OnAddVDFWindowClasses
80041>>>>>>>        Send OnAddCustomWindowClasses
80042>>>>>>>        
80042>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
80042>>>>>>>        If (pbLoadPreference(Self)) Begin
80044>>>>>>>            Send LoadSkinPreference
80045>>>>>>>        End
80045>>>>>>>>
80045>>>>>>>        // if a skin file name exists, we apply the skin.    
80045>>>>>>>        If (psSkinFile(Self)<>"") Begin
80047>>>>>>>            Send ApplySkin
80048>>>>>>>        End        
80048>>>>>>>>
80048>>>>>>>    End_Procedure
80049>>>>>>>    
80049>>>>>>>    // called by framework as part of application exit.
80049>>>>>>>    Procedure Broadcast_Notify_Exit_Application
80051>>>>>>>        Send Notify_Exit_Application
80052>>>>>>>    End_Procedure // Notify_Exit_Application
80053>>>>>>>
80053>>>>>>>    Procedure Notify_Exit_Application
80055>>>>>>>        If (pbLoadPreference(Self)) Begin
80057>>>>>>>            Send SaveSkinPreference
80058>>>>>>>        End
80058>>>>>>>>
80058>>>>>>>    End_Procedure
80059>>>>>>>
80059>>>>>>>    Procedure NotifyPreApplySkin
80061>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True       
80063>>>>>>>    End_Procedure
80064>>>>>>>
80064>>>>>>>    Procedure NotifyPostApplySkin
80066>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True       
80068>>>>>>>    End_Procedure
80069>>>>>>>    
80069>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
80069>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
80069>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
80071>>>>>>>        tSkinInformation[] Skins
80071>>>>>>>        tSkinInformation[] Skins
80072>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
80072>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
80072>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
80072>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
80072>>>>>>>        Integer iPos iDfltLen
80072>>>>>>>        Boolean bUseRelativePath
80072>>>>>>>        
80072>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80073>>>>>>>        
80073>>>>>>>        Get SkinPath to sDefaultPath
80074>>>>>>>        If (sPath="") Begin
80076>>>>>>>            Move sDefaultPath to sPath
80077>>>>>>>        End
80077>>>>>>>>
80077>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
80078>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
80079>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
80080>>>>>>>
80080>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
80081>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
80083>>>>>>>
80083>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
80084>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
80085>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
80086>>>>>>>            
80086>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
80087>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
80088>>>>>>>            
80088>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
80094>>>>>>>>
80094>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
80095>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
80096>>>>>>>
80096>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
80097>>>>>>>                    
80097>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
80103>>>>>>>>
80103>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
80104>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
80105>>>>>>>
80105>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
80106>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
80107>>>>>>>                    If bUseRelativePath Begin
80109>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
80110>>>>>>>                        If iPos Begin
80112>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile   
80113>>>>>>>                            While (Left(sSkinFile,1)=sSep)
80117>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile   
80118>>>>>>>                            Loop                         
80119>>>>>>>>
80119>>>>>>>                        End
80119>>>>>>>>
80119>>>>>>>                    End
80119>>>>>>>>
80119>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
80120>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
80121>>>>>>>
80121>>>>>>>                    Increment iArrayItem
80122>>>>>>>                Loop
80123>>>>>>>>
80123>>>>>>>            Loop
80124>>>>>>>>
80124>>>>>>>                            
80124>>>>>>>            Send Destroy of hSkinDescriptions
80125>>>>>>>            Send Destroy of hSkinDescription
80126>>>>>>>            Send Destroy of hSkinIniFile
80127>>>>>>>                
80127>>>>>>>        End
80127>>>>>>>>
80127>>>>>>>        Function_Return Skins
80128>>>>>>>    End_Function 
80129>>>>>>>    
80129>>>>>>>    // Save the skin preference. This requires an application object.
80129>>>>>>>    // Only do this if the application object allows it. 
80129>>>>>>>    // This is called during startup if pbLoadPreference is True
80129>>>>>>>    // Suitable for override
80129>>>>>>>    Procedure SaveSkinPreference 
80131>>>>>>>        String sSkin sIni
80131>>>>>>>        If ghoApplication Begin
80133>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80135>>>>>>>                Get psSkinFile to sSkin
80136>>>>>>>                Get psSkinIni to sIni
80137>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
80138>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
80139>>>>>>>            End
80139>>>>>>>>
80139>>>>>>>        End
80139>>>>>>>>
80139>>>>>>>        Else Begin
80140>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80141>>>>>>>>
80141>>>>>>>        End
80141>>>>>>>>
80141>>>>>>>    End_Procedure
80142>>>>>>>
80142>>>>>>>    // Load the skin preference. This requires an application object.
80142>>>>>>>    // Only do this if the application object allows it. 
80142>>>>>>>    // This is called during startup if pbLoadPreference is True
80142>>>>>>>    // Suitable for override
80142>>>>>>>    Procedure LoadSkinPreference 
80144>>>>>>>        String sSkin sIni
80144>>>>>>>        Boolean bExists
80144>>>>>>>        If ghoApplication Begin
80146>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80148>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
80149>>>>>>>                If bExists Begin
80151>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
80152>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
80153>>>>>>>                    Set psSkinFile to sSkin
80154>>>>>>>                    Set psSkinIni to sIni
80155>>>>>>>                End
80155>>>>>>>>
80155>>>>>>>            End
80155>>>>>>>>
80155>>>>>>>        End
80155>>>>>>>>
80155>>>>>>>        Else Begin
80156>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80157>>>>>>>>
80157>>>>>>>        End
80157>>>>>>>>
80157>>>>>>>    End_Procedure
80158>>>>>>>
80158>>>>>>>    // Can be called to apply the current skin.
80158>>>>>>>    Procedure ApplySkin
80160>>>>>>>        Boolean bOk
80160>>>>>>>        String sSkin sIni
80160>>>>>>>        If (IsComObjectCreated(Self)) Begin
80162>>>>>>>            Get SkinQFile to sSkin
80163>>>>>>>            Get psSkinIni to sIni
80164>>>>>>>            
80164>>>>>>>            Send NotifyPreApplySkin
80165>>>>>>>            // when skins are used we don't want to use built in Visual Styles
80165>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
80166>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
80167>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
80169>>>>>>>                // if not ok, no skin was appied. Enable visual styles
80169>>>>>>>                Send EnableVisualStyles of Desktop True
80170>>>>>>>            End
80170>>>>>>>>
80170>>>>>>>            Send NotifyPostApplySkin
80171>>>>>>>        End
80171>>>>>>>>
80171>>>>>>>    End_Procedure
80172>>>>>>>
80172>>>>>>>
80172>>>>>>>End_Class
80173>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cProgressBar.pkg)
80173>>>>>>>Use Windows.pkg
80173>>>>>>>Use cWinControl.pkg
80173>>>>>>>Use CommCtrl.pkg
80173>>>>>>>
80173>>>>>>>Type tPbRange
80173>>>>>>>    Field tPbRange.iLow  as DWord
80173>>>>>>>    Field tPbRange.iHigh as DWord
80173>>>>>>>End_Type
80173>>>>>>>
80173>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
80173>>>>>>>Class cProgressBar is a cWinControl
80174>>>>>>>
80174>>>>>>>    Procedure Construct_Object
80176>>>>>>>        Forward Send Construct_Object
80178>>>>>>>        Property Integer private_piMinimum
80179>>>>>>>        Property Integer private_piMaximum   100
80180>>>>>>>        Property Integer private_piAdvanceBy 10
80181>>>>>>>        Property Integer private_piPosition
80182>>>>>>>        Property Integer private_pbVertical  False
80183>>>>>>>        Property Integer private_pbSmooth    False
80184>>>>>>>        Property Integer private_piBackColor clDefault
80185>>>>>>>        Property Integer private_piBarColor  clDefault
80186>>>>>>>
80186>>>>>>>        Send Define_ToolTip_Support_Mixin
80187>>>>>>>
80187>>>>>>>        Set External_Class_Name 'cVdfProgressBar' To 'msctls_progress32'
80188>>>>>>>        Set Focus_Mode to NonFocusable
80189>>>>>>>        Set Skip_State to True
80190>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
80191>>>>>>>    End_Procedure
80192>>>>>>>
80192>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
80193>>>>>>>
80193>>>>>>>    Procedure Set piMinimum Integer iMin
80195>>>>>>>        Integer iMax
80195>>>>>>>
80195>>>>>>>        Set private_piMinimum to iMin
80196>>>>>>>        Get private_piMaximum To iMax
80197>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80198>>>>>>>    End_Procedure
80199>>>>>>>    Function piMinimum Returns Integer
80201>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
80204>>>>>>>        Else Function_Return (private_piMinimum(self))
80206>>>>>>>    End_Function
80207>>>>>>>
80207>>>>>>>    Procedure Set piMaximum Integer iMax
80209>>>>>>>        Integer iMin
80209>>>>>>>
80209>>>>>>>        Set private_piMaximum to iMax
80210>>>>>>>        Get private_piMinimum To iMin
80211>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80212>>>>>>>    End_Procedure
80213>>>>>>>    Function piMaximum Returns Integer
80215>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
80218>>>>>>>        Else Function_Return (private_piMaximum(self))
80220>>>>>>>    End_Function
80221>>>>>>>
80221>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
80223>>>>>>>        Set private_piAdvanceBy To iAdvanceBy
80224>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
80225>>>>>>>    End_Procedure
80226>>>>>>>    Function piAdvanceBy Returns Integer
80228>>>>>>>        Function_Return (private_piAdvanceBy(self))
80229>>>>>>>    End_Function
80230>>>>>>>
80230>>>>>>>    Procedure Set piPosition Integer iPos
80232>>>>>>>        Set private_piPosition To iPos
80233>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
80234>>>>>>>    End_Procedure
80235>>>>>>>
80235>>>>>>>    Function piPosition Returns Integer
80237>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
80240>>>>>>>        Else Function_Return (private_piPosition(self))
80242>>>>>>>    End_Function
80243>>>>>>>
80243>>>>>>>    Procedure Set pbVertical Boolean bVertical
80245>>>>>>>        If (private_pbVertical(self) <> bVertical) Begin
80247>>>>>>>            Set private_pbVertical To bVertical
80248>>>>>>>           Send DoRecreateWindow
80249>>>>>>>        End
80249>>>>>>>>
80249>>>>>>>    End_Procedure
80250>>>>>>>
80250>>>>>>>    Function pbVertical Returns Boolean
80252>>>>>>>        Function_Return (private_pbVertical(self))
80253>>>>>>>    End_Function
80254>>>>>>>
80254>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
80256>>>>>>>        If (private_pbSmooth(self) <> bSmooth) Begin
80258>>>>>>>           Set private_pbSmooth To bSmooth
80259>>>>>>>           Send DoRecreateWindow
80260>>>>>>>        End
80260>>>>>>>>
80260>>>>>>>    End_Procedure
80261>>>>>>>    Function pbSmooth Returns Boolean
80263>>>>>>>        Function_Return (private_pbSmooth(self))
80264>>>>>>>    End_Function
80265>>>>>>>
80265>>>>>>>    Procedure Set piBackColor Integer rgbColor
80267>>>>>>>        Set private_piBackColor To rgbColor
80268>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
80269>>>>>>>    End_Procedure
80270>>>>>>>    Function piBackColor Returns Integer
80272>>>>>>>        Function_Return (private_piBackColor(self))
80273>>>>>>>    End_Function
80274>>>>>>>
80274>>>>>>>    Procedure Set piBarColor Integer rgbColor
80276>>>>>>>        Set private_piBarColor To rgbColor
80277>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
80278>>>>>>>    End_Procedure
80279>>>>>>>    Function piBarColor Returns Integer
80281>>>>>>>        Function_Return (private_piBarColor(self))
80282>>>>>>>    End_Function
80283>>>>>>>
80283>>>>>>>    Procedure DoAdvance
80285>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
80286>>>>>>>    End_procedure
80287>>>>>>>
80287>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
80289>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
80290>>>>>>>    End_procedure
80291>>>>>>>
80291>>>>>>>    Procedure private_DoInitWindow
80293>>>>>>>        Set piBarColor  To (private_piBarColor(self))
80294>>>>>>>        Set piBackColor To (private_piBackColor(self))
80295>>>>>>>        Set piAdvanceBy To (private_piAdvanceBy(self))
80296>>>>>>>        Set piMinimum   To (private_piMinimum(self))
80297>>>>>>>        Set piMaximum   To (private_piMaximum(self))
80298>>>>>>>        Set piPosition  To (private_piPosition(self))
80299>>>>>>>    End_Procedure
80300>>>>>>>
80300>>>>>>>    Procedure Page_Object Integer iState
80302>>>>>>>        Handle hWnd
80302>>>>>>>
80302>>>>>>>        Get Window_Handle To hWnd
80303>>>>>>>        If (hWnd=0 and iState) Begin
80305>>>>>>>            Set Window_Style To PBS_VERTICAL (private_pbVertical(self))
80306>>>>>>>            Set Window_Style To PBS_SMOOTH   (private_pbSmooth(self))
80307>>>>>>>            Forward Send Page_Object True
80309>>>>>>>        End
80309>>>>>>>>
80309>>>>>>>        Else Forward Send Page_Object iState
80312>>>>>>>     
80312>>>>>>>        // Handle tooltip support....
80312>>>>>>>        If (iState = 0) Begin
80314>>>>>>>            Send RequestDeleteToolTip
80315>>>>>>>        End 
80315>>>>>>>>
80315>>>>>>>        Else Begin
80316>>>>>>>            Send RequestAddToolTip
80317>>>>>>>        End
80317>>>>>>>>
80317>>>>>>>    End_Procedure
80318>>>>>>>
80318>>>>>>>    Procedure Page Integer iState
80320>>>>>>>        Forward Send Page iState
80322>>>>>>>        If (iState =1) Send private_DoInitWindow
80325>>>>>>>    End_Procedure
80326>>>>>>>
80326>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
80326>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
80326>>>>>>>    // is implemented in a mixin class.
80326>>>>>>>    Procedure RequestAddToolTip
80328>>>>>>>        Send AddToolTip
80329>>>>>>>    End_Procedure  // RequestAddToolTip
80330>>>>>>>
80330>>>>>>>
80330>>>>>>>    // Called by Page_Object. Handles tooltip removal. 
80330>>>>>>>    Procedure RequestDeleteToolTip
80332>>>>>>>        Send DeleteToolTip
80333>>>>>>>    End_Procedure // RequestDeleteToolTip
80334>>>>>>>End_Class
80335>>>>>
80335>>>>>
80335>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
80335>>>>>
80335>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
80335>>>>>
80335>>>>>Object Status_Panel is a cProcessStatusPanel
80337>>>>>    Set Size to 140 222
80338>>>>>    Set Border_Style to Border_Dialog
80339>>>>>//    Set Sysmenu_Icon to False  
80339>>>>>    Set Icon to "DbUpdateFrameworkdf19.ico"
80340>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
80341>>>>>
80341>>>>>    Property Boolean Cancel_Button_Visible_State True
80343>>>>>
80343>>>>>    Procedure Activate
80346>>>>>        Integer iSizeBefore iSizeAfter
80346>>>>>        Get GuiSize to iSizeBefore
80347>>>>>        Forward Send Activate
80349>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))  
80350>>>>>    End_Procedure  
80351>>>>>    
80351>>>>>    Procedure End_Construct_Object
80354>>>>>        Forward Send End_Construct_Object
80356>>>>>        Set Label of oTitleTxt      to ""
80357>>>>>        Set Label of oTableNameTxt  to ""
80358>>>>>        Set Label of oMessageTxt    to ""
80359>>>>>        Set Label of oActionTxt     to ""
80360>>>>>    End_Procedure
80361>>>>>
80361>>>>>    Object oTitleTxt is a TextBox
80363>>>>>        Set Location to 5 21
80364>>>>>        Set Size to 8 179
80365>>>>>        Set Auto_Size_State to False
80366>>>>>        Set Justification_Mode  to jMode_Center
80367>>>>>        Set Label to "This is the Title Text"
80368>>>>>    End_Object
80369>>>>>
80369>>>>>    Object oTableNameTxt is a TextBox
80371>>>>>        Set Size to 19 204
80372>>>>>        Set Location to 18 9
80373>>>>>        Set Auto_Size_State to False
80374>>>>>        Set Justification_Mode to JMode_Left
80375>>>>>        Set Label to "This is the TableName Text"
80376>>>>>    End_Object
80377>>>>>
80377>>>>>    Object oMessageTxt is a TextBox
80379>>>>>        Set Location to 39 9
80380>>>>>        Set Size to 19 204
80381>>>>>        Set Auto_Size_State to False
80382>>>>>        Set Justification_Mode to JMode_Left
80383>>>>>        Set Label to "This is the Message text"
80384>>>>>    End_Object
80385>>>>>
80385>>>>>    Object oActionTxt is a TextBox
80387>>>>>        Set Size to 19 204
80388>>>>>        Set Location to 60 9
80389>>>>>        Set Auto_Size_State to False
80390>>>>>        Set Justification_Mode to JMode_Left
80391>>>>>        Set Label to "This is the Action Text"
80392>>>>>    End_Object
80393>>>>>
80393>>>>>    Object oStopButton is a Button
80395>>>>>        Set Location to 112 82
80396>>>>>        Set Label to C_$Cancel
80397>>>>>
80397>>>>>        Procedure OnClick
80400>>>>>            Send Close_panel
80401>>>>>        End_Procedure
80402>>>>>
80402>>>>>    End_Object
80403>>>>>
80403>>>>>    Object oPercentage_tb is a TextBox
80405>>>>>        Set Location to 74 196
80406>>>>>        Set Size to 10 25
80407>>>>>//        Set Label to "% Done"
80407>>>>>    End_Object
80408>>>>>
80408>>>>>    Object oCopyRight is a TextBox
80410>>>>>        Set Location to 129 21
80411>>>>>        Set Size to 9 197
80412>>>>>        Set FontPointHeight to 8
80413>>>>>        Set Auto_Size_State to False
80414>>>>>        Set Justification_Mode  to jMode_Center
80415>>>>>        Set Label to "Copyright 2001-2018 RDC Tools International"
80416>>>>>    End_Object
80417>>>>>
80417>>>>>    Object oProgressBar is a cProgressBar
80419>>>>>        Set Size to 10 179
80420>>>>>        Set Location to 86 22
80421>>>>>        Set pbVisible to True // default
80422>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
80423>>>>>    End_Object
80424>>>>>
80424>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
80427>>>>>        Set pbVisible of ghoProgressBar to bVisible
80428>>>>>    End_Procedure
80429>>>>>
80429>>>>>    Function Progress_Bar_Visible_State Returns Boolean
80432>>>>>        Boolean bVisible
80432>>>>>        Get pbVisible of ghoProgressBar to bVisible
80433>>>>>        Function_Return (bVisible)
80434>>>>>    End_Function
80435>>>>>
80435>>>>>    Object oProgressBarOverall is a cProgressBar
80437>>>>>        Set Size to 10 179
80438>>>>>        Set Location to 99 22
80439>>>>>        Set pbVisible to True // default
80440>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
80441>>>>>    End_Object
80442>>>>>
80442>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
80445>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
80446>>>>>    End_Procedure
80447>>>>>
80447>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
80450>>>>>        Boolean bVisible
80450>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
80451>>>>>        Function_Return (bVisible)
80452>>>>>    End_Function
80453>>>>>
80453>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
80453>>>>>    // objects defined within this instance of the status panel.
80453>>>>>
80453>>>>>    // note: all of the messages that change text should be forwarded
80453>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
80453>>>>>
80453>>>>>    Procedure Set Message_Text String sText
80456>>>>>        Set Label of oMessageTxt to sText
80457>>>>>        Forward Set Message_Text to sText
80459>>>>>    End_Procedure
80460>>>>>
80460>>>>>    Function Message_Text Returns String
80463>>>>>        Function_Return (Label(oMessageTxt))
80464>>>>>    End_Function
80465>>>>>
80465>>>>>    Procedure Set Action_Text String sText
80468>>>>>        Set Label of oActionTxt to sText
80469>>>>>        Forward Set Action_Text to sText
80471>>>>>    End_Procedure
80472>>>>>
80472>>>>>    Function Action_Text Returns String
80475>>>>>        Function_Return (Label(oActionTxt))
80476>>>>>    End_Function
80477>>>>>
80477>>>>>    Procedure Set Button_Text String sText
80480>>>>>        Set Label of oStopButton to sText
80481>>>>>        Forward Set Button_Text to sText
80483>>>>>    End_Procedure
80484>>>>>
80484>>>>>    Function Button_Text Returns String
80487>>>>>        Function_Return (Label(oStopButton))
80488>>>>>    End_Function
80489>>>>>
80489>>>>>    Procedure Set Title_Text String sText
80492>>>>>        Set Label of oTitleTxt to sText
80493>>>>>        Forward Set Title_Text to sText
80495>>>>>    End_Procedure
80496>>>>>
80496>>>>>    Function Title_Text Returns String
80499>>>>>        Function_Return (Label(oTitleTxt))
80500>>>>>    End_Function
80501>>>>>
80501>>>>>    Procedure Set TableName_Text String sText
80504>>>>>        Set Label of oTableNameTxt to sText
80505>>>>>    End_Procedure
80506>>>>>
80506>>>>>    Function TableName_Text Returns String
80509>>>>>        Function_Return (Label(oTableNameTxt))
80510>>>>>    End_Function
80511>>>>>
80511>>>>>    Procedure Set License_Text String sText
80514>>>>>//        Set Label of oLicense_txt to sText
80514>>>>>    End_Procedure
80515>>>>>
80515>>>>>    // gets called when status panel is activated passing whether a button
80515>>>>>    // should appear
80515>>>>>    Procedure EnableCancelButton Boolean bEnable
80518>>>>>        Boolean bVisible
80518>>>>>        Get Cancel_Button_Visible_State to bVisible
80519>>>>>        If (bEnable = False) Begin
80521>>>>>            Set Visible_State of oStopButton to bVisible
80522>>>>>        End
80522>>>>>>
80522>>>>>        Set Enabled_State of oStopButton to bEnable
80523>>>>>    End_Procedure
80524>>>>>
80524>>>>>    Procedure Reset_StatusPanel
80527>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
80528>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
80529>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
80530>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
80531>>>>>    End_Procedure
80532>>>>>
80532>>>>>//    Object oProgressBar is a cProgressBar
80532>>>>>//        Move Self to ghoProgressBar
80532>>>>>//        Set Location to 1 25
80532>>>>>//        Set Size to 9 173
80532>>>>>//        Set piMinimum        to 0
80532>>>>>//        Set piMaximum        to 2000
80532>>>>>//        Set piAdvanceBy      to 100
80532>>>>>//        Set pbSmooth to True
80532>>>>>//
80532>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
80532>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
80532>>>>>//        // color will show correctly.
80532>>>>>//        Procedure Page Integer iPageObject
80532>>>>>//            Handle hWin
80532>>>>>//            Forward Send Page iPageObject
80532>>>>>//            If (ghoSkinFramework <> 0) Begin
80532>>>>>//                Get Window_Handle to hWin
80532>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
80532>>>>>//            End
80532>>>>>//        End_Procedure
80532>>>>>//    End_Object
80532>>>>>
80532>>>>>End_Object
80533>>>>>
80533>>>Use seq_chnl.pkg
80533>>>Use Datadict.pkg
80533>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
80533>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
80533>>>>>//
80533>>>>>Use VdfBase.pkg  
80533>>>>>Use cApplication.pkg
80533>>>>>Use seq_chnl.pkg
80533>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vWin32fh.pkg)
80533>>>>>>>// This code is part of VDF GUIdance
80533>>>>>>>// Visit us @ http://www.vdf-guidance.com
80533>>>>>>>// e-Mail us @ info@vdf-guidance.com
80533>>>>>>>// VDF GUIdance is a mutual project of
80533>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
80533>>>>>>>// Wil van Antwerpen  - Antwise Solutions
80533>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
80533>>>>>>>//
80533>>>>>>>//
80533>>>>>>>// *** Windows 32bit file handling wrapper class ***
80533>>>>>>>//
80533>>>>>>>
80533>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
80533>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
80533>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
80533>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
80533>>>>>>>//
80533>>>>>>>// The used naming-convention is:
80533>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
80533>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
80533>>>>>>>//
80533>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
80533>>>>>>>// of DataAccess in the future.
80533>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
80533>>>>>>>//
80533>>>>>>>// mm-dd-yyyy Author Description
80533>>>>>>>//
80533>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
80533>>>>>>>//                   vGetWindowsDirectory
80533>>>>>>>//
80533>>>>>>>//                   vGetTempFileName
80533>>>>>>>//                   vGetTempPath
80533>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
80533>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
80533>>>>>>>//                   error in your application anyways. Changed this for:
80533>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
80533>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
80533>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
80533>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
80533>>>>>>>//                   It is renamed too avoid this.
80533>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
80533>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
80533>>>>>>>//                   Removed the local keyword in the variable declarations
80533>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
80533>>>>>>>//                   created file-open dialog
80533>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
80533>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
80533>>>>>>>//                   This has now been taken care of.
80533>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
80533>>>>>>>//                   These declarations are now included from the vWin32fh header file.
80533>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
80533>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
80533>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
80533>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
80533>>>>>>>//                   One can however restore to the old way of handling by simply calling the
80533>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
80533>>>>>>>//                   filehandling operations
80533>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
80533>>>>>>>//                   as well as the StringFromRightOfChar function.
80533>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
80533>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
80533>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
80533>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
80533>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
80533>>>>>>>//                   extended characters are treated ok too.
80533>>>>>>>//                   Reported by Flemming from
80533>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
80533>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
80533>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
80533>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
80533>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
80533>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
80533>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
80533>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
80533>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
80533>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
80533>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
80533>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
80533>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
80533>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
80533>>>>>>>
80533>>>>>>>Use Case.mac
80533>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
80533>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cvFileDialogs.pkg)
80533>>>>>>>>>//***************************************************************************
80533>>>>>>>>>//*
80533>>>>>>>>>//* Class:        cvSaveAsDialog
80533>>>>>>>>>//* Package Name: cvFileDialogs.pkg
80533>>>>>>>>>//*
80533>>>>>>>>>//***************************************************************************
80533>>>>>>>>>
80533>>>>>>>>>Use File_dlg.pkg
80533>>>>>>>>>
80533>>>>>>>>>// *WvA: 13-01-1999 Created
80533>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
80533>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
80533>>>>>>>>>// file_name.
80533>>>>>>>>>Class cvSelectFile_Dialog Is An OpenDialog
80534>>>>>>>>>
80534>>>>>>>>>  Procedure Construct_Object Integer iImage_Id
80536>>>>>>>>>    Forward Send Construct_Object iImage_Id
80538>>>>>>>>>    Set HideReadOnly_State To True
80539>>>>>>>>>  End_Procedure // Construct_Object
80540>>>>>>>>>
80540>>>>>>>>>  Function SelectedFileName Returns String
80542>>>>>>>>>    String sFileName
80542>>>>>>>>>    Move "" To sFileName
80543>>>>>>>>>    If (Show_Dialog(Self)) Begin
80545>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
80546>>>>>>>>>    End
80546>>>>>>>>>>
80546>>>>>>>>>    Function_Return sFileName
80547>>>>>>>>>  End_Function // SelectedFileName
80548>>>>>>>>>End_Class // cvSelectFile_Dialog
80549>>>>>>>>>
80549>>>>>>>>>
80549>>>>>>>>>// *WvA: 13-01-1999 Created
80549>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
80549>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
80549>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
80549>>>>>>>>>//                   file-open dialog
80549>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
80551>>>>>>>>>  String sSelectedFile
80551>>>>>>>>>  Integer hoOpenFileDialog
80551>>>>>>>>>
80551>>>>>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
80553>>>>>>>>>
80553>>>>>>>>>    Set Dialog_Caption    To sCaptionText
80554>>>>>>>>>    Set Filter_String     To sSupportedFileTypes
80555>>>>>>>>>    Set Initial_Folder    To sInitialFolder
80556>>>>>>>>>
80556>>>>>>>>>    Move Self       To hoOpenFileDialog
80557>>>>>>>>>  End_Object // oOpenFileDialog
80558>>>>>>>>>
80558>>>>>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
80559>>>>>>>>>  Send Destroy_Object To hoOpenFileDialog
80560>>>>>>>>>  Function_Return sSelectedFile
80561>>>>>>>>>End_Function // vSelect_File
80562>>>>>>>>>
80562>>>>>>>>>
80562>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
80563>>>>>>>>>
80563>>>>>>>>>  Procedure Construct_Object
80565>>>>>>>>>    Forward Send Construct_Object
80567>>>>>>>>>    Set HideReadOnly_State To True
80568>>>>>>>>>  End_Procedure // Construct_Object
80569>>>>>>>>>
80569>>>>>>>>>  Function SelectedFileName Returns String
80571>>>>>>>>>    String sFileName
80571>>>>>>>>>    Move "" To sFileName
80572>>>>>>>>>    If (Show_Dialog(Self)) Begin
80574>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
80575>>>>>>>>>    End
80575>>>>>>>>>>
80575>>>>>>>>>    Function_Return sFileName
80576>>>>>>>>>  End_Function // SelectedFileName
80577>>>>>>>>>
80577>>>>>>>>>End_Class // cvSaveAsDialog
80578>>>>>>>>>
80578>>>>>>>>>// Added optional default filename as suggested by Nils
80578>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
80580>>>>>>>>>  String sSelectedFile
80580>>>>>>>>>  Integer hoDialog
80580>>>>>>>>>
80580>>>>>>>>>  Move "" To sSelectedFile
80581>>>>>>>>>  Get Create U_cvSaveAsDialog To hoDialog
80582>>>>>>>>>  If (hoDialog) Begin
80584>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
80584>>>>>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
80585>>>>>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
80586>>>>>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
80587>>>>>>>>>    If (Num_Arguments = 4) Begin
80589>>>>>>>>>      Set File_Title        of hoDialog to sDefaultFileName
80590>>>>>>>>>    End
80590>>>>>>>>>>
80590>>>>>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
80591>>>>>>>>>    Send Destroy Of hoDialog
80592>>>>>>>>>  End
80592>>>>>>>>>>
80592>>>>>>>>>  Function_Return sSelectedFile
80593>>>>>>>>>End_Function // vSelectSaveFile
80594>>>>>>>Use Seq_chnl.pkg
80594>>>>>>>
80594>>>>>>>Use windows
80594>>>>>>>//Use Dferror
80594>>>>>>>Use Dll
80594>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vwin32fh.h)
80594>>>>>>>>>//TH-Header
80594>>>>>>>>>//*****************************************************************************************
80594>>>>>>>>>// Copyright (c)  2004 KURANT Project
80594>>>>>>>>>// All rights reserved.
80594>>>>>>>>>//
80594>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
80594>>>>>>>>>// $ProjectName : Windows 32 bits file handling
80594>>>>>>>>>// $Authors     : Wil van Antwerpen
80594>>>>>>>>>// $Created     : 19.02.2004  19:25
80594>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
80594>>>>>>>>>//
80594>>>>>>>>>// Contents:
80594>>>>>>>>>//  This file contains the Windows API external function call definitions and
80594>>>>>>>>>//  constants as they are used in the vWin32fh package.
80594>>>>>>>>>//*****************************************************************************************
80594>>>>>>>>>//TH-RevisionStart
80594>>>>>>>>>//TH-RevisionEnd
80594>>>>>>>>>
80594>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
80594>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
80594>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
80594>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
80594>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
80594>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
80594>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
80594>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
80594>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
80594>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
80594>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
80594>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
80594>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
80594>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
80594>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
80594>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
80594>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
80594>>>>>>>>>
80594>>>>>>>>>
80594>>>>>>>>>Define vMax_Path     For |CI260
80594>>>>>>>>>Define vMinChar      For |CI$80
80594>>>>>>>>>Define vMaxChar      For |CI$7F
80594>>>>>>>>>Define vMinShort     For |CI$8000
80594>>>>>>>>>Define vMaxShort     For |CI$7FFF
80594>>>>>>>>>Define vMinLong      For |CI$80000000
80594>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
80594>>>>>>>>>Define vMaxByte      For |CI$FF
80594>>>>>>>>>Define vMaxWord      For |CI$FFFF
80594>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
80594>>>>>>>>>
80594>>>>>>>>>
80594>>>>>>>>>
80594>>>>>>>>>// For FindFirstFile
80594>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
80594>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
80594>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
80594>>>>>>>>>
80594>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
80594>>>>>>>>>// the API-call ShellExecute is used.
80594>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
80594>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
80594>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
80594>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
80594>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
80594>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
80594>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
80594>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
80594>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
80594>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
80594>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
80594>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
80594>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
80594>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
80594>>>>>>>>>
80594>>>>>>>>>
80594>>>>>>>>>// C-Structure
80594>>>>>>>>>//typedef struct _browseinfo {
80594>>>>>>>>>//    HWND hwndOwner;
80594>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
80594>>>>>>>>>//    LPSTR pszDisplayName;
80594>>>>>>>>>//    LPCSTR lpszTitle;
80594>>>>>>>>>//    UINT ulFlags;
80594>>>>>>>>>//    BFFCALLBACK lpfn;
80594>>>>>>>>>//    LPARAM lParam;
80594>>>>>>>>>//    int iImage;
80594>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
80594>>>>>>>>>
80594>>>>>>>>>//declare C structure struct_browseinfo
80594>>>>>>>>>//as documented in MSDN under Windows Shell API
80594>>>>>>>>>Type vtBrowseInfo
80594>>>>>>>>>  Field vtBrowseInfo.hWndOwner      as Handle
80594>>>>>>>>>  Field vtBrowseInfo.pIDLRoot       as Pointer
80594>>>>>>>>>  Field vtBrowseInfo.pszDisplayName as Pointer
80594>>>>>>>>>  Field vtBrowseInfo.lpszTitle      as Pointer
80594>>>>>>>>>  Field vtBrowseInfo.ulFlags        as dWord
80594>>>>>>>>>  Field vtBrowseInfo.lpfnCallback   as Pointer
80594>>>>>>>>>  Field vtBrowseInfo.lParam         as dWord
80594>>>>>>>>>  Field vtBrowseInfo.iImage         as dWord
80594>>>>>>>>>End_Type // tBrowseInfo
80594>>>>>>>>>
80594>>>>>>>>>// Browsing for directory.
80594>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
80594>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
80594>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
80594>>>>>>>>>                                            // The callback function can set the status text by
80594>>>>>>>>>                                            // sending messages to the dialog box.
80594>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
80594>>>>>>>>>
80594>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
80594>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
80594>>>>>>>>>
80594>>>>>>>>>// message from browser
80594>>>>>>>>>//Define BFFM_INITIALIZED        1
80594>>>>>>>>>//Define BFFM_SELCHANGED         2
80594>>>>>>>>>
80594>>>>>>>>>// messages to browser
80594>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
80594>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
80594>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
80594>>>>>>>>>
80594>>>>>>>>>
80594>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
80595>>>>>>>>>
80595>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
80596>>>>>>>>>
80596>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
80597>>>>>>>>>
80597>>>>>>>>>
80597>>>>>>>>>
80597>>>>>>>>>
80597>>>>>>>>>Type vtSecurity_attributes
80597>>>>>>>>>  Field vtSecurity_attributes.nLength        as dWord
80597>>>>>>>>>  Field vtSecurity_attributes.lpDescriptor   as Pointer
80597>>>>>>>>>  Field vtSecurity_attributes.bInheritHandle as Integer
80597>>>>>>>>>End_Type // vtSecurity_attributes
80597>>>>>>>>>
80597>>>>>>>>>//nLength:
80597>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
80597>>>>>>>>>// SECURITY_ATTRIBUTES structure.
80597>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
80597>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
80597>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
80597>>>>>>>>>//
80597>>>>>>>>>//lpSecurityDescriptor:
80597>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
80597>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
80597>>>>>>>>>// descriptor of the calling process.
80597>>>>>>>>>//
80597>>>>>>>>>//bInheritHandle:
80597>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
80597>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
80597>>>>>>>>>
80597>>>>>>>>>
80597>>>>>>>>>// BOOL CreateDirectory(
80597>>>>>>>>>//    LPCTSTR lpPathName,
80597>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
80597>>>>>>>>>//   );
80597>>>>>>>>>//
80597>>>>>>>>>// lpPathName
80597>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
80597>>>>>>>>>//  to be created.
80597>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
80597>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
80597>>>>>>>>>// lpSecurityAttributes
80597>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
80597>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
80597>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
80597>>>>>>>>>// Returns:
80597>>>>>>>>>//  If the function succeeds, the return value is nonzero.
80597>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
80597>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
80598>>>>>>>>>
80598>>>>>>>>>
80598>>>>>>>>>// lpPathName
80598>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
80598>>>>>>>>>//  to be removed.
80598>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
80598>>>>>>>>>// Returns:
80598>>>>>>>>>//  If the function succeeds, the return value is nonzero.
80598>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
80598>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
80599>>>>>>>>>
80599>>>>>>>>>
80599>>>>>>>>>
80599>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
80599>>>>>>>>>// executable file or a document file.
80599>>>>>>>>>//
80599>>>>>>>>>// Operation can be one of the following:
80599>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
80599>>>>>>>>>//            The file can be an executable file or a document file.
80599>>>>>>>>>//            The file can be a folder to open.
80599>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
80599>>>>>>>>>//            The file should be a document file. If the file is an executable file,
80599>>>>>>>>>//            the function opens the file, as if "open" had been specified.
80599>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
80599>>>>>>>>>//
80599>>>>>>>>>// Return Values:
80599>>>>>>>>>//
80599>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
80599>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
80599>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
80599>>>>>>>>>//
80599>>>>>>>>>// The following table lists these error values:
80599>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
80599>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
80599>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
80599>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
80599>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
80599>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
80599>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
80599>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
80599>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
80599>>>>>>>>>// Public Const SE_ERR_FNF = 2
80599>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
80599>>>>>>>>>// Public Const SE_ERR_OOM = 8
80599>>>>>>>>>// Public Const SE_ERR_PNF = 3
80599>>>>>>>>>// Public Const SE_ERR_SHARE = 26
80599>>>>>>>>>
80599>>>>>>>>>
80599>>>>>>>>>
80599>>>>>>>>>// Code to open the program that is associated with the selected file.
80599>>>>>>>>>//
80599>>>>>>>>>// External function call used in Procedure DoStartDocument
80599>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
80600>>>>>>>>>
80600>>>>>>>>>
80600>>>>>>>>>
80600>>>>>>>>>
80600>>>>>>>>>
80600>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
80600>>>>>>>>>
80600>>>>>>>>>Type vtShFileOpStruct
80600>>>>>>>>>  Field vtShFileOpStruct.hWnd                   as Handle
80600>>>>>>>>>  Field vtShFileOpStruct.wFunc                  as Integer
80600>>>>>>>>>  Field vtShFileOpStruct.pFrom                  as Pointer
80600>>>>>>>>>  Field vtShFileOpStruct.pTo                    as Pointer
80600>>>>>>>>>  Field vtShFileOpStruct.fFlags                 as Short
80600>>>>>>>>>  Field vtShFileOpStruct.fAnyOperationsAborted  as Short
80600>>>>>>>>>  Field vtShFileOpStruct.hNameMappings          as Pointer
80600>>>>>>>>>  Field vtShFileOpStruct.lpszProgressTitle      as Pointer // only used if FOF_SIMPLEPROGRESS
80600>>>>>>>>>End_Type // tShFileOpStruct
80600>>>>>>>>>
80600>>>>>>>>>// hwnd
80600>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
80600>>>>>>>>>
80600>>>>>>>>>// wFunc
80600>>>>>>>>>//   Operation to perform. This member can be one of the following values:
80600>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
80600>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
80600>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
80600>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
80600>>>>>>>>>
80600>>>>>>>>>// pFrom
80600>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
80600>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
80600>>>>>>>>>
80600>>>>>>>>>// pTo
80600>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
80600>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
80600>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
80600>>>>>>>>>//   double null-terminated.
80600>>>>>>>>>
80600>>>>>>>>>// fAnyOperationsAborted
80600>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
80600>>>>>>>>>//   were completed or FALSE otherwise.
80600>>>>>>>>>
80600>>>>>>>>>
80600>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
80600>>>>>>>>>// This can be a file or a folder.
80600>>>>>>>>>// With thanks to Andrew S Kaplan
80600>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
80601>>>>>>>>>
80601>>>>>>>>>
80601>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
80601>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
80602>>>>>>>>>
80602>>>>>>>>>
80602>>>>>>>>>
80602>>>>>>>>>// Courtesy Of Vincent Oorsprong
80602>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
80602>>>>>>>>>//   Pointer lpPathName ;
80602>>>>>>>>>//   Pointer lpPrefixString ;
80602>>>>>>>>>//   Integer uUnique ;
80602>>>>>>>>>//   Pointer lpTempFileName ;
80602>>>>>>>>>//   Returns Integer
80602>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
80602>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
80603>>>>>>>>>
80603>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
80604>>>>>>>>>
80604>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
80605>>>>>>>>>                  
80605>>>>>>>>>// from:
80605>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
80605>>>>>>>>>//
80605>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
80605>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
80605>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
80605>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
80605>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
80605>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
80605>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
80605>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
80605>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
80605>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
80605>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
80605>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
80605>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
80605>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
80605>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
80605>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
80605>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
80605>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
80605>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
80605>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
80605>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
80605>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
80605>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
80605>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
80605>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
80605>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
80605>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
80605>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
80605>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
80605>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
80605>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
80605>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
80605>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
80605>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
80605>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
80605>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
80605>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
80605>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
80605>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
80605>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
80605>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
80605>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
80605>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
80605>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
80605>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
80605>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
80605>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
80605>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
80605>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
80605>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
80605>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
80605>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
80605>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
80605>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
80605>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
80605>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
80605>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
80605>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
80605>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
80605>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
80605>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
80605>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
80605>>>>>>>>>
80605>>>>>>>>>
80605>>>>>>>>>//HRESULT SHGetFolderPath(
80605>>>>>>>>>//    HWND hwndOwner,
80605>>>>>>>>>//    int nFolder,
80605>>>>>>>>>//    HANDLE hToken,
80605>>>>>>>>>//    DWORD dwFlags,
80605>>>>>>>>>//    LPTSTR pszPath
80605>>>>>>>>>//);
80605>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
80605>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
80605>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
80605>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
80605>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
80605>>>>>>>>>//
80605>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
80606>>>>>>>>>
80606>>>>>>>>>
80606>>>>>>>>>
80606>>>>>>>>>Type vWin32_Find_Data
80606>>>>>>>>>  Field vWin32_Find_Data.dwFileAttributes As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.ftCreationLowDateTime As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.ftCreationHighDateTime As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.ftLastAccessLowDateTime As dword
80606>>>>>>>>>  Field vWin32_Find_Data.ftLastAccessHighDateTime As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.ftLastWriteLowDateTime As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.ftLastWriteHighDateTime As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.nFileSizeHigh As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.nFileSizeLow As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.dwReserved0 As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.dwReserved1 As Dword
80606>>>>>>>>>  Field vWin32_Find_Data.cFileName As Char vMax_Path
80606>>>>>>>>>  Field vWin32_Find_Data.cAlternateFileName As Char 14
80606>>>>>>>>>End_Type // vWin32_Find_Data
80606>>>>>>>>>
80606>>>>>>>>>// Courtesy Of Vincent Oorsprong
80606>>>>>>>>>// lpFileName      : address of name of file to search for
80606>>>>>>>>>// lpFindFileData  : address of returned information
80606>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
80607>>>>>>>>>
80607>>>>>>>>>// Courtesy Of Vincent Oorsprong
80607>>>>>>>>>// hFindFile       : handle of search
80607>>>>>>>>>// lpFindFileData  : address of structure for data on found file
80607>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
80608>>>>>>>>>
80608>>>>>>>>>// Courtesy Of Vincent Oorsprong
80608>>>>>>>>>//  hFindFile      : file search handle
80608>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
80609>>>>>>>>>
80609>>>>>>>>>
80609>>>>>>>>>
80609>>>>>>>>>Type vFileTime
80609>>>>>>>>>  Field vFileTime.dwLowDateTime As Dword
80609>>>>>>>>>  Field vFileTime.dwHighDateTime As Dword
80609>>>>>>>>>End_Type // vFileTime
80609>>>>>>>>>
80609>>>>>>>>>
80609>>>>>>>>>Type vSystemTime
80609>>>>>>>>>  Field vSystemTime.wYear As Word
80609>>>>>>>>>  Field vSystemTime.wMonth As Word
80609>>>>>>>>>  Field vSystemTime.wDayOfWeek As Word
80609>>>>>>>>>  Field vSystemTime.wDay As Word
80609>>>>>>>>>  Field vSystemTime.wHour As Word
80609>>>>>>>>>  Field vSystemTime.wMinute As Word
80609>>>>>>>>>  Field vSystemTime.wSecond As Word
80609>>>>>>>>>  Field vSystemTime.wMilliSeconds As Word
80609>>>>>>>>>End_Type // vSystemTime
80609>>>>>>>>>
80609>>>>>>>>>
80609>>>>>>>>>// Courtesy Of Vincent Oorsprong
80609>>>>>>>>>//  lpFileTime     : pointer to file time to convert
80609>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
80609>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
80610>>>>>>>>>
80610>>>>>>>>>// Courtesy Of Vincent Oorsprong
80610>>>>>>>>>// This function formats the time in a picture-string passed
80610>>>>>>>>>//
80610>>>>>>>>>// Picture      Meaning
80610>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
80610>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
80610>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
80610>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
80610>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
80610>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
80610>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
80610>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
80610>>>>>>>>>//    t         One character time marker string, such as A or P
80610>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
80610>>>>>>>>>//
80610>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
80610>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
80610>>>>>>>>>
80610>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
80611>>>>>>>>>
80611>>>>>>>>>
80611>>>>>>>>>// Courtesy Of Vincent Oorsprong
80611>>>>>>>>>// This function formats the date in a picture-string passed
80611>>>>>>>>>//
80611>>>>>>>>>// Picture      Meaning
80611>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
80611>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
80611>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
80611>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
80611>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
80611>>>>>>>>>//              value associated with the specified locale.
80611>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
80611>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
80611>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
80611>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
80611>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
80611>>>>>>>>>//              associated with the specified locale.
80611>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
80611>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
80611>>>>>>>>>//    yyyy      Year represented hy full four digits.
80611>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
80611>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
80611>>>>>>>>>//              does not have an associated era or period string.
80611>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
80611>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
80611>>>>>>>>>
80611>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
80612>>>>>>>>>
80612>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
80612>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$0000000l  //  do not use minutes or seconds
80612>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
80612>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
80612>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
80612>>>>>>>>>
80612>>>>>>>>>//  Date Flags for GetDateFormatW.
80612>>>>>>>>>//
80612>>>>>>>>>Define DATE_SHORTDATE           For |CI$0000000l  //  use short date picture
80612>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
80612>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
80612>>>>>>>>>
80612>>>>>>>>>
80612>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
80613>>>>>>>>>
80613>>>>>>>>>
80613>>>>>>>>>// **WvA: 20-02-2004
80613>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
80613>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
80613>>>>>>>>>// incorrectly into an unsigned integer.
80613>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
80613>>>>>>>>>// It does smell a bit fishy though
80613>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
80613>>>>>>>>>
80613>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
80613>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
80613>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
80613>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
80613>>>>>>>>>
80613>>>>>>>>>// Possible errors that can be returned by the shellformat function
80613>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
80613>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
80613>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
80613>>>>>>>>>                                                
80613>>>>>>>>>
80613>>>>>>>>> // Courtesy Of Steve Walter,
80613>>>>>>>>> // USA Software, Inc
80613>>>>>>>>> // Format a disk
80613>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
80613>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
80614>>>>>>>>>
80614>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
80614>>>>>>>>>
80614>>>>>>>>>// SHCreateDirectoryEx
80614>>>>>>>>>
80614>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
80614>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
80614>>>>>>>>>//
80614>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
80614>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
80614>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
80614>>>>>>>>>//
80614>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
80614>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
80614>>>>>>>>>//        ERROR_CANCELLED.
80614>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
80614>>>>>>>>>
80614>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
80614>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
80614>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
80614>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
80614>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
80614>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
80614>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
80614>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
80614>>>>>>>>>
80614>>>>>>>>>//        int SHCreateDirectoryEx(
80614>>>>>>>>>//            HWND hwnd,
80614>>>>>>>>>//            LPCTSTR pszPath,
80614>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
80614>>>>>>>>>//        );
80614>>>>>>>>>
80614>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
80615>>>>>>>
80615>>>>>>>
80615>>>>>>>
80615>>>>>>>
80615>>>>>>>
80615>>>>>>>//
80615>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
80615>>>>>>>// If sStopChar has no occurences in the string an empty string is
80615>>>>>>>// returned.
80615>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
80617>>>>>>>  String  sRetVal
80617>>>>>>>  String  sChar
80617>>>>>>>  Integer iLength
80617>>>>>>>  Integer iPos
80617>>>>>>>  Boolean bStopChar
80617>>>>>>>  Move "" To sRetval
80618>>>>>>>  Move (Length(sFrom)) To iLength
80619>>>>>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
80621>>>>>>>    Move iLength   To iPos
80622>>>>>>>    Move (False)   To bStopChar
80623>>>>>>>    While Not bStopChar
80627>>>>>>>      Move (Mid(sFrom,1,iPos)) To sChar
80628>>>>>>>      Decrement iPos
80629>>>>>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
80631>>>>>>>        Move (True) To bStopChar
80632>>>>>>>      End
80632>>>>>>>>
80632>>>>>>>      Else Begin
80633>>>>>>>        Move (sChar+sRetVal) To sRetVal
80634>>>>>>>      End
80634>>>>>>>>
80634>>>>>>>    Loop
80635>>>>>>>>
80635>>>>>>>  End
80635>>>>>>>>
80635>>>>>>>  Function_Return sRetVal
80636>>>>>>>End_Function // StringFromRightOfChar
80637>>>>>>>
80637>>>>>>>
80637>>>>>>>// Pre:  sFileName contains the complete path of the file.
80637>>>>>>>// Post: returns the complete path of the file.
80637>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
80637>>>>>>>Function ParseFolderName Global String sFileName Returns String
80639>>>>>>>  String sFile
80639>>>>>>>  String sFolderName
80639>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
80639>>>>>>>  MOve "" To sFolderName
80640>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
80641>>>>>>>  If sDirSep In sFileName Begin
80643>>>>>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
80644>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
80645>>>>>>>  End
80645>>>>>>>>
80645>>>>>>>  Else If ":" In sFileName Begin
80648>>>>>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
80649>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
80650>>>>>>>  End
80650>>>>>>>>
80650>>>>>>>  Function_Return sFolderName
80651>>>>>>>End_Function // ParseFolderName
80652>>>>>>>
80652>>>>>>>
80652>>>>>>>// Pre:  sFileName contains the complete path of the file.
80652>>>>>>>// post: The returned filename has it's path removed, but will have a extension
80652>>>>>>>Function ParseFileName Global String sFileName Returns String
80654>>>>>>>  String sFolderName
80654>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
80654>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
80655>>>>>>>  Get ParseFolderName sFileName To sFolderName
80656>>>>>>>  If (sFolderName <> "") Move (Replace(sFolderName,sFileName,"")) To sFileName
80659>>>>>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
80660>>>>>>>  Function_Return sFilename
80661>>>>>>>End_Function // ParseFileName
80662>>>>>>>
80662>>>>>>>
80662>>>>>>>// Pre:  sFileName may contain the complete path of the file.
80662>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
80662>>>>>>>//       return "bak" as the extension and not "gif"
80662>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
80662>>>>>>>//       such as "html" or "java"
80662>>>>>>>Function ParseFileExtension Global String sFileName Returns String
80664>>>>>>>  String  sFileExtension
80664>>>>>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
80665>>>>>>>  Function_Return sFileExtension
80666>>>>>>>End_Function // ParseFileExtension
80667>>>>>>>
80667>>>>>>>
80667>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
80667>>>>>>>
80667>>>>>>>
80667>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80669>>>>>>>  String sMessage
80669>>>>>>>  Case Begin
80669>>>>>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
80671>>>>>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
80672>>>>>>>      Case Break
80673>>>>>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
80676>>>>>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
80677>>>>>>>      Case Break
80678>>>>>>>    Case (iErrorID = vERROR_BAD_FORMAT)
80681>>>>>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
80682>>>>>>>      Case Break
80683>>>>>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
80686>>>>>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
80687>>>>>>>      Case Break
80688>>>>>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
80691>>>>>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
80692>>>>>>>      Case Break
80693>>>>>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
80696>>>>>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
80697>>>>>>>      Case Break
80698>>>>>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
80701>>>>>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
80702>>>>>>>      Case Break
80703>>>>>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
80706>>>>>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
80707>>>>>>>      Case Break
80708>>>>>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
80711>>>>>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
80712>>>>>>>      Case Break
80713>>>>>>>    Case (iErrorID = vSE_ERR_NOASSOC)
80716>>>>>>>      Move CS_DDE_ERR_NOASSOC To sMessage
80717>>>>>>>      Case Break
80718>>>>>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
80721>>>>>>>      Move CS_DDE_ERR_OOM To sMessage
80722>>>>>>>      Case Break
80723>>>>>>>    Case (iErrorID = vSE_ERR_PNF)
80726>>>>>>>      Move CS_DDE_ERR_PNF To sMessage
80727>>>>>>>      Case Break
80728>>>>>>>    Case (iErrorID = vSE_ERR_SHARE)
80731>>>>>>>      Move CS_DDE_ERR_SHARE To sMessage
80732>>>>>>>      Case Break
80733>>>>>>>    Case Else
80733>>>>>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
80734>>>>>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
80735>>>>>>>      Case Break
80736>>>>>>>  Case End
80736>>>>>>>  Function_Return sMessage
80737>>>>>>>End_Function // DDE_Error_To_String
80738>>>>>>>
80738>>>>>>>
80738>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80740>>>>>>>  String sMessage
80740>>>>>>>  Get DDE_Error_To_String iErrorID To sMessage
80741>>>>>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
80742>>>>>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
80743>>>>>>>End_Procedure // vDDE_Error_Handler hInstance
80744>>>>>>>
80744>>>>>>>
80744>>>>>>>// Does the directory exist? - No = 0, Yes = 1
80744>>>>>>>// This also works with UNC path encoding and wildcards
80744>>>>>>>Function vFolderExists Global String sFolderName Returns Integer
80746>>>>>>>  String  sFolder sTmp
80746>>>>>>>  Integer bFolderExists iCh
80746>>>>>>>
80746>>>>>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
80746>>>>>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
80747>>>>>>>  If (sFolderName = "") Begin
80749>>>>>>>    Function_Return False
80750>>>>>>>  End
80750>>>>>>>>
80750>>>>>>>
80750>>>>>>>  Move dfTrue To bFolderExists
80751>>>>>>>  Move "dir:" To sFolder
80752>>>>>>>  Append sFolder sFolderName
80753>>>>>>>  Get Seq_New_Channel To iCh  // get free channel for input
80754>>>>>>>  Direct_Input Channel iCh sFolder
80756>>>>>>>    Repeat
80756>>>>>>>>
80756>>>>>>>      Readln Channel iCh sTmp
80758>>>>>>>      If (Trim(sTmp)="") Move dfFalse To bFolderExists
80761>>>>>>>      Else Begin
80762>>>>>>>        Move dfTrue To bFolderExists
80763>>>>>>>        Indicate seqeof True  // end loop
80764>>>>>>>        End
80764>>>>>>>>
80764>>>>>>>    Until (seqeof)
80766>>>>>>>  Close_Input Channel iCh
80768>>>>>>>  Send Seq_Release_Channel iCh
80769>>>>>>>  Function_Return bFolderExists
80770>>>>>>>End_Function  // vFolderExists
80771>>>>>>>
80771>>>>>>>
80771>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
80771>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
80773>>>>>>>  String sFolder sBrowseInfo sTitle
80773>>>>>>>  Pointer lpItemIdList lpsFolder lpsBrowseInfo lpsTitle
80773>>>>>>>  Integer iFolderSelected iRetval
80773>>>>>>>
80773>>>>>>>  // fill string variable with null characters
80773>>>>>>>  ZeroType vtBrowseInfo To sBrowseInfo
80774>>>>>>>
80774>>>>>>>  If (sDialogTitle<>"") Begin
80776>>>>>>>    Move sDialogTitle To sTitle
80777>>>>>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
80777>>>>>>>    // disables showing some commonly used ascii characters like ascii 137 ()
80777>>>>>>>    // These chars are correctly shown if no toansi is used.
80777>>>>>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
80777>>>>>>>    // selected it will always be valid.
80777>>>>>>>    GetAddress Of sTitle To lpsTitle
80778>>>>>>>    Put lpsTitle To sBrowseInfo At vtBrowseInfo.lpszTitle
80779>>>>>>>  End
80779>>>>>>>>
80779>>>>>>>
80779>>>>>>>  Put vBIF_RETURNONLYFSDIRS To sBrowseInfo At vtBrowseInfo.ulFlags
80780>>>>>>>
80780>>>>>>>  // Torben Lund added line below. Move handle of focus object to structure before
80780>>>>>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
80780>>>>>>>  Put (window_handle(focus(desktop))) To sBrowseInfo At vtBrowseInfo.hWndOwner
80781>>>>>>>
80781>>>>>>>  GetAddress Of sBrowseInfo To lpsBrowseInfo
80782>>>>>>>
80782>>>>>>>  // null 128 chars into var (make space)
80782>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
80783>>>>>>>  GetAddress Of sFolder To lpsFolder
80784>>>>>>>
80784>>>>>>>  // select folder
80784>>>>>>>  Move (vWin32_SHBrowseForFolder(lpsBrowseInfo)) To lpItemIdList
80785>>>>>>>  // get selected folder name
80785>>>>>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, lpsFolder)) To iFolderSelected
80786>>>>>>>
80786>>>>>>>  // release memory resources that are used by the ItemIdList
80786>>>>>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
80787>>>>>>>
80787>>>>>>>  If (iFolderSelected<>0) Function_Return (CString(sFolder))
80790>>>>>>>  Else Function_Return ""
80792>>>>>>>End_Function // vSHBrowseForFolder
80793>>>>>>>
80793>>>>>>>
80793>>>>>>>// returns 0 if the folder is created.
80793>>>>>>>//         1 if the API-call returned an error.
80793>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
80795>>>>>>>  String  sFolder sSA
80795>>>>>>>  Pointer lpsFolder lpsSecurity_Attributes lpDescriptor
80795>>>>>>>  Integer iRetval bFolderCreated bInheritHandle
80795>>>>>>>
80795>>>>>>>  Move (False) To bFolderCreated
80796>>>>>>>  // fill string variable with null characters
80796>>>>>>>  ZeroType vtSecurity_attributes To sSA
80797>>>>>>>
80797>>>>>>>  // null MAX_PATH chars into var (make space)
80797>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
80798>>>>>>>
80798>>>>>>>  If (sNewFolder <> "") Begin
80800>>>>>>>
80800>>>>>>>    Move dfTrue To  bInheritHandle
80801>>>>>>>    // Setting this to NULL is already done by the zerotype command
80801>>>>>>>    // Move NULL   To  lpDescriptor
80801>>>>>>>    Put (length(sSA))   To sSA At vtSecurity_attributes.nLength
80802>>>>>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
80802>>>>>>>    Put bInheritHandle To sSA At vtSecurity_attributes.bInheritHandle
80803>>>>>>>
80803>>>>>>>    GetAddress Of sSA To lpsSecurity_Attributes
80804>>>>>>>
80804>>>>>>>    //
80804>>>>>>>    Move sNewFolder To sFolder
80805>>>>>>>    GetAddress Of sFolder To lpsFolder
80806>>>>>>>    Move (vWin32_CreateDirectory(lpsFolder, lpsSecurity_Attributes)) To bFolderCreated
80807>>>>>>>  End
80807>>>>>>>>
80807>>>>>>>
80807>>>>>>>  Ifnot bFolderCreated Move 1 To iRetVal
80810>>>>>>>  Function_Return iRetVal
80811>>>>>>>End_Function // vCreateDirectory
80812>>>>>>>
80812>>>>>>>
80812>>>>>>>// **WvA: 03-02-2002 Function created.
80812>>>>>>>// With this function one can remove a directory.
80812>>>>>>>// returns 0 if the folder is removed.
80812>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
80812>>>>>>>//         2 if the folder did not exist
80812>>>>>>>//         3 if the sFolder parameter passed is equal to ""
80812>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
80814>>>>>>>  String  sPath
80814>>>>>>>  Pointer lpsPath
80814>>>>>>>  Integer iRetval bRemoved bExists
80814>>>>>>>
80814>>>>>>>  Move (False) To bRemoved
80815>>>>>>>  Move 0 To iRetVal
80816>>>>>>>  Move (Trim(sFolder)) To sFolder
80817>>>>>>>  If (sFolder="") Begin
80819>>>>>>>    Move 3 To iRetVal
80820>>>>>>>  End
80820>>>>>>>>
80820>>>>>>>  If (vFolderExists(sFolder)=False) Begin
80822>>>>>>>    Move 2 To iRetVal
80823>>>>>>>  End
80823>>>>>>>>
80823>>>>>>>  If (iRetVal=0) Begin
80825>>>>>>>    // null MAX_PATH chars into var (make space)
80825>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
80826>>>>>>>    //
80826>>>>>>>    Move (Insert(sFolder,sPath,1)) To sPath
80827>>>>>>>    GetAddress Of sPath To lpsPath
80828>>>>>>>    Move (vWin32_RemoveDirectory(lpsPath)) To bRemoved
80829>>>>>>>  End
80829>>>>>>>>
80829>>>>>>>
80829>>>>>>>  If ((iRetVal=0) And (bRemoved=False)) Begin
80831>>>>>>>    Move 1 To iRetVal
80832>>>>>>>  End
80832>>>>>>>>
80832>>>>>>>  Function_Return iRetVal
80833>>>>>>>End_Function // vRemoveDirectory
80834>>>>>>>
80834>>>>>>>
80834>>>>>>>
80834>>>>>>>// This function informs the user that he entered a yet unknown folder and
80834>>>>>>>// asks if he/she wants to create the folder (Yes/No)
80834>>>>>>>// Choice: "Yes" - this creates the folder
80834>>>>>>>//                 if successful, the function returns false
80834>>>>>>>//                 else it will be true.
80834>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
80834>>>>>>>//                 For example: to stop a save
80834>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
80834>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
80834>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
80836>>>>>>>  Integer bIsNotValid
80836>>>>>>>  Integer iUsers_Choice
80836>>>>>>>  String  sMessage
80836>>>>>>>
80836>>>>>>>  If (vFolderExists(sFolderName) Eq 0) Begin
80838>>>>>>>    Move "The folder '" To sMessage
80839>>>>>>>    Append sMessage sFolderName
80840>>>>>>>    Append sMessage "' does not yet exist,\n"
80841>>>>>>>    Append sMessage "Do you want to create it now?"
80842>>>>>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
80843>>>>>>>    Case Begin
80843>>>>>>>      Case (iUsers_Choice = MBR_Yes)
80845>>>>>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
80846>>>>>>>        If bIsNotValid Begin
80848>>>>>>>          Move "An error occurred while trying to create folder '" To sMessage
80849>>>>>>>          Append sMessage sFolderName "'.\n\n"
80851>>>>>>>          Send Info_Box sMessage "Info"
80852>>>>>>>          End
80852>>>>>>>>
80852>>>>>>>        Case Break
80853>>>>>>>      Case (iUsers_Choice = MBR_No)
80856>>>>>>>        Move dfTrue To bIsNotValid // Cancel the save
80857>>>>>>>        Case Break
80858>>>>>>>    Case End
80858>>>>>>>  End
80858>>>>>>>>
80858>>>>>>>  Function_Return bIsNotValid
80859>>>>>>>End_Function // vVerifyNewFolder
80860>>>>>>>
80860>>>>>>>
80860>>>>>>>// This will perform an operation on a file (e.g. open) with the application
80860>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
80860>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
80860>>>>>>>Procedure vShellExecute global String sOperation String sDocument String sParameters String sPath
80862>>>>>>>  Handle  hInstance hWnd
80862>>>>>>>  Pointer lpsOperation
80862>>>>>>>  Pointer lpsDocument
80862>>>>>>>  Pointer lpsParameters
80862>>>>>>>  Pointer lpsPath
80862>>>>>>>  // remove any leading/trailing spaces in the string
80862>>>>>>>  Move (Trim(sDocument)) To sDocument
80863>>>>>>>  Move (Trim(sPath))     To sPath
80864>>>>>>>  // Make the strings readable for windows API, by converting them to null-terminated
80864>>>>>>>  Append sOperation   (Character(0))
80865>>>>>>>  Append sDocument    (Character(0))
80866>>>>>>>  Append sParameters  (Character(0))
80867>>>>>>>  Append sPath        (Character(0))
80868>>>>>>>  // Connect the corresponding pointers to the strings
80868>>>>>>>  GetAddress Of sOperation  To lpsOperation
80869>>>>>>>  GetAddress Of sDocument   To lpsDocument
80870>>>>>>>  GetAddress Of sParameters To lpsParameters
80871>>>>>>>  GetAddress Of sPath       To lpsPath
80872>>>>>>>
80872>>>>>>>  Get Window_Handle To hWnd
80873>>>>>>>  Move (vWin32_ShellExecute (hWnd, lpsOperation, lpsDocument, lpsParameters, lpsPath, 1)) To hInstance
80874>>>>>>>  If (hInstance <= 32) Begin
80876>>>>>>>    Send vDDE_Error_Handler hInstance
80877>>>>>>>  End
80877>>>>>>>>
80877>>>>>>>End_Procedure // vShellExecute
80878>>>>>>>
80878>>>>>>>
80878>>>>>>>Class cShellFileOperations Is a Array
80879>>>>>>>
80879>>>>>>>  Procedure Construct_Object
80881>>>>>>>    Forward Send Construct_Object
80883>>>>>>>    Property Integer piDeleteFlags        Public 0
80884>>>>>>>    Property Integer piCopyFlags          Public 0
80885>>>>>>>    Property Integer piMoveFlags          Public 0
80886>>>>>>>    Property Integer piRenameFlags        Public 0
80887>>>>>>>
80887>>>>>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80888>>>>>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
80889>>>>>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
80890>>>>>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80891>>>>>>>  End_Procedure // Construct_Object
80892>>>>>>>
80892>>>>>>>
80892>>>>>>>  // This function uses the shell API to perform a file operation on the
80892>>>>>>>  // files supplied.
80892>>>>>>>  //
80892>>>>>>>  Function FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
80894>>>>>>>    String   sShFileOp
80894>>>>>>>    Pointer  lpShFileOp
80894>>>>>>>    Pointer  lpsSource
80894>>>>>>>    Pointer  lpsDestination
80894>>>>>>>    Integer  iRetVal
80894>>>>>>>    Integer  bUserAbort
80894>>>>>>>
80894>>>>>>>    ZeroType vtShFileOpStruct To sShFileOp
80895>>>>>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
80896>>>>>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
80897>>>>>>>    GetAddress Of sSource    To lpsSource
80898>>>>>>>    If iOperation Ne vFO_DELETE Begin
80900>>>>>>>      GetAddress Of sDestination      To lpsDestination
80901>>>>>>>      Put lpsDestination To sShFileOp At vtShFileOpStruct.pTo
80902>>>>>>>    End
80902>>>>>>>>
80902>>>>>>>
80902>>>>>>>    Put iOperation     To sShFileOp At vtShFileOpStruct.wFunc
80903>>>>>>>    Put lpsSource      To sShFileOp At vtShFileOpStruct.pFrom
80904>>>>>>>    Put iFlags         To sShFileOp At vtShFileOpStruct.fFlags
80905>>>>>>>
80905>>>>>>>    GetAddress Of sShFileOp To lpShFileOp
80906>>>>>>>
80906>>>>>>>    Move (vWin32_SHFileOperation(lpShFileOp)) To iRetVal
80907>>>>>>>    GetBuff From sShFileOp At vtShFileOpStruct.fAnyOperationsAborted To bUserAbort
80908>>>>>>>    If (bUserAbort <> 0) Begin
80910>>>>>>>      Move 80 To iRetVal  // file Operation Aborted by USER
80911>>>>>>>    End
80911>>>>>>>>
80911>>>>>>>    Function_Return (iRetVal)
80912>>>>>>>  End_Function // FileOperation
80913>>>>>>>
80913>>>>>>>
80913>>>>>>>  Function sfoDeleteFile String sFileName Returns Integer
80915>>>>>>>    Integer  iRetVal
80915>>>>>>>    Integer  iFlags
80915>>>>>>>
80915>>>>>>>    Get piDeleteFlags To iFlags
80916>>>>>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
80917>>>>>>>    Function_Return iRetVal
80918>>>>>>>  End_Function // sfoDeleteFile
80919>>>>>>>
80919>>>>>>>
80919>>>>>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
80921>>>>>>>    Integer  iRetVal
80921>>>>>>>    Integer  iFlags
80921>>>>>>>
80921>>>>>>>    Get piCopyFlags To iFlags
80922>>>>>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
80923>>>>>>>    Function_Return iRetVal
80924>>>>>>>  End_Function // sfoCopyFile
80925>>>>>>>
80925>>>>>>>
80925>>>>>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
80927>>>>>>>    Integer  iRetVal
80927>>>>>>>    Integer  iFlags
80927>>>>>>>
80927>>>>>>>    Get piMoveFlags To iFlags
80928>>>>>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
80929>>>>>>>    Function_Return iRetVal
80930>>>>>>>  End_Function // sfoMoveFile
80931>>>>>>>
80931>>>>>>>
80931>>>>>>>  // Rename a file or folder
80931>>>>>>>  // Returns a nonzero value if the operation failed.
80931>>>>>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
80933>>>>>>>    Integer  iRetVal
80933>>>>>>>    Integer  iFlags
80933>>>>>>>
80933>>>>>>>    Get piRenameFlags To iFlags
80934>>>>>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
80935>>>>>>>    Function_Return iRetVal
80936>>>>>>>  End_Function // sfoRenameFile
80937>>>>>>>
80937>>>>>>>  // Courtesy Of Steve Walter
80937>>>>>>>  // Requires Windows 2000 and up according to msdn but it was
80937>>>>>>>  //  in fact available before that as an unpublished API call
80937>>>>>>>  //  a little google search shows that this was already available
80937>>>>>>>  //  in windows 95 and NT
80937>>>>>>>  //
80937>>>>>>>  // The format is controlled by the dialog interface.
80937>>>>>>>  // That is, the user must click the OK button To actually Begin the format
80937>>>>>>>  // the format cannot be started programmatically.
80937>>>>>>>  // An alternative to this functionality would be to use a controlpanel
80937>>>>>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
80937>>>>>>>  //
80937>>>>>>>  // hWnd = The windows handle of the object from which the format Function
80937>>>>>>>  //        is called.
80937>>>>>>>  // To Get this,
80937>>>>>>>  //          use:  Get Window_Handle Of <object>
80937>>>>>>>  //          For instance, in this app, we're going to use the Report_Panel:
80937>>>>>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
80937>>>>>>>  //
80937>>>>>>>  // sDrive = The drive letter. At this moment only A and B are valid
80937>>>>>>>  //
80937>>>>>>>  // iOptions = Format options.
80937>>>>>>>  //  SHFMT_OPT_DEFAULT = Quick format
80937>>>>>>>  //  SHFMT_OPT_FULL    = Full Format
80937>>>>>>>  //  SHFMT_OPT_SYSONLY = System only
80937>>>>>>>  //  3                 = Full format with system. (unsupported)
80937>>>>>>>  //
80937>>>>>>>  // Return Values:
80937>>>>>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
80937>>>>>>>  //  SHFMT_CANCEL   = Format cancelled by user.
80937>>>>>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
80937>>>>>>>  //
80937>>>>>>>  //
80937>>>>>>>  // *** ATTENTION: This function has been disabled as it doesn't
80937>>>>>>>  //                seem to work, i must have made a silly mistake
80937>>>>>>>  //                somewhere.
80937>>>>>>>  //
80937>>>>>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
80939>>>>>>>    Handle   hWnd
80939>>>>>>>    Integer  iObj
80939>>>>>>>    DWORD    dwReturnVal
80939>>>>>>>    Integer iDrive
80939>>>>>>>
80939>>>>>>>    Function_Return (1) // STOP HERE
80940>>>>>>>
80940>>>>>>>    Move (Trim(sDrive)) To sDrive
80941>>>>>>>    If ( sDrive <> '' ) Begin
80943>>>>>>>      If ( sDrive Contains ':' ) Move (Replace(':',sDrive,'')) To sDrive
80946>>>>>>>      If (Not( 'AB' Contains sDrive )) Function_Return (SHFMT_NOFORMAT)
80949>>>>>>>      If ( sDrive = 'A' ) Move 0 To iDrive
80952>>>>>>>      Else If ( sDrive = 'B' ) Move 1 To iDrive
80956>>>>>>>      // Window_Handle Of Desktop equals to 0
80956>>>>>>>
80956>>>>>>>      Get focus Of desktop To iObj
80957>>>>>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
80960>>>>>>>      While (hWnd=0 And iObj<>Desktop)
80964>>>>>>>          Get Parent Of iObj To iObj
80965>>>>>>>          Get Container_Handle Of iObj To hWnd
80966>>>>>>>      End
80967>>>>>>>>
80967>>>>>>>
80967>>>>>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
80967>>>>>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
80968>>>>>>>    End
80968>>>>>>>>
80968>>>>>>>    Else Begin
80969>>>>>>>      Move (SHFMT_ERROR) To dwReturnVal
80970>>>>>>>    End
80970>>>>>>>>
80970>>>>>>>    Function_Return dwReturnVal
80971>>>>>>>  End_Function // sfoFormatDisk
80972>>>>>>>
80972>>>>>>>  //Example:
80972>>>>>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
80972>>>>>>>  //                                          mode.
80972>>>>>>>
80972>>>>>>>End_Class // cShellFileOperations
80973>>>>>>>
80973>>>>>>>
80973>>>>>>>Object oShellFileOperations Is a cShellFileOperations
80975>>>>>>>End_Object // oShellFileOperations
80976>>>>>>>
80976>>>>>>>
80976>>>>>>>// Restore to the old way of working with the shell file operations.
80976>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
80976>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
80976>>>>>>>Procedure vWin32fhCompatibilityMode
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80978>>>>>>>  Integer hoSFO
80978>>>>>>>  Integer iFlags
80978>>>>>>>
80978>>>>>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
80979>>>>>>>  Move (oShellFileOperations(Self)) To hoSFO
80980>>>>>>>
80980>>>>>>>  Set piDeleteFlags Of hoSFO To iFlags
80981>>>>>>>  Set piCopyFlags   Of hoSFO To iFlags
80982>>>>>>>  Set piMoveFlags   Of hoSFO To iFlags
80983>>>>>>>  Set piRenameFlags Of hoSFO To iFlags
80984>>>>>>>End_Procedure // vWin32fhCompatibilityMode
80985>>>>>>>
80985>>>>>>>
80985>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
80987>>>>>>>  Integer  iRetVal
80987>>>>>>>
80987>>>>>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
80988>>>>>>>  Function_Return iRetVal
80989>>>>>>>End_Function // vDeleteFile
80990>>>>>>>
80990>>>>>>>
80990>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
80992>>>>>>>  Integer  iRetVal
80992>>>>>>>
80992>>>>>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80993>>>>>>>  Function_Return iRetVal
80994>>>>>>>End_Function // vCopyFile
80995>>>>>>>
80995>>>>>>>
80995>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
80997>>>>>>>  Integer  iRetVal
80997>>>>>>>
80997>>>>>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80998>>>>>>>  Function_Return iRetVal
80999>>>>>>>End_Function // vMoveFile
81000>>>>>>>
81000>>>>>>>
81000>>>>>>>// Rename a file or folder
81000>>>>>>>// Returns a nonzero value if the operation failed.
81000>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
81002>>>>>>>  Integer  iRetVal
81002>>>>>>>
81002>>>>>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
81003>>>>>>>  Function_Return iRetVal
81004>>>>>>>End_Function // vRenameFile
81005>>>>>>>
81005>>>>>>>
81005>>>>>>>
81005>>>>>>>Function vGetWindowsDirectory Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81007>>>>>>>  String  sDirectory
81007>>>>>>>  Pointer lpDirectory
81007>>>>>>>  Integer iVoid
81007>>>>>>>
81007>>>>>>>  ZeroString vMAX_PATH To sDirectory
81008>>>>>>>  GetAddress Of sDirectory To lpDirectory
81009>>>>>>>
81009>>>>>>>  Move (vWin32_GetWindowsDirectory(lpDirectory, vMAX_PATH)) To iVoid
81010>>>>>>>  Function_Return (CString(sDirectory))  // **WvA: Changed to CString()
81011>>>>>>>End_Function // vGetWindowsDirectory
81012>>>>>>>
81012>>>>>>>
81012>>>>>>>
81012>>>>>>>
81012>>>>>>>// Courtesy of Marco Kuipers
81012>>>>>>>Function vMakeTempFile Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81014>>>>>>>    Integer iRetval
81014>>>>>>>    String  sTempPath sTempFileName sPrefixString
81014>>>>>>>    Pointer lpTempPath lpTempFileName lpPrefixString
81014>>>>>>>
81014>>>>>>>    Move (Repeat (Character (0), 255)) To sTempPath
81015>>>>>>>    GetAddress Of sTempPath To lpTempPath
81016>>>>>>>    Move (vWin32_GetTempPath (255, lpTempPath)) To iRetVal
81017>>>>>>>
81017>>>>>>>    If (sTempPath = "") Begin
81019>>>>>>>       Get_Current_Directory To sTempPath
81020>>>>>>>    End
81020>>>>>>>>
81020>>>>>>>    Move (pad(sTempPath,vMax_Path-14)) To sTempPath // *WvA: 28-04-2005 Quote from msdn: The string cannot be longer than MAX_PATH-14 characters.
81021>>>>>>>    Move (Repeat (Character (0), 255)) To sTempFileName
81022>>>>>>>    GetAddress Of sTempFileName To lpTempFileName
81023>>>>>>>    Move ("tmp"+character(0)) To sPrefixString // **WvA: 28-04-2005 Added a null
81024>>>>>>>    GetAddress Of sPrefixString To lpPrefixString
81025>>>>>>>    GetAddress Of sTempPath To lpTempPath
81026>>>>>>>    Move (vWin32_GetTempFileName (lpTempPath, lpPrefixString, 0, lpTempFileName)) To iRetval
81027>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
81029>>>>>>>        Move "" To sTempFileName
81030>>>>>>>    End
81030>>>>>>>>
81030>>>>>>>
81030>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
81031>>>>>>>End_Function // vMakeTempFile
81032>>>>>>>
81032>>>>>>>
81032>>>>>>>// This function creates a uniquely named temporary file in folder sPath
81032>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
81032>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
81032>>>>>>>// does not take care of that.
81032>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81034>>>>>>>    String sTempFileName
81034>>>>>>>    Integer iCnt iRetVal
81034>>>>>>>    Pointer lpTempFileName
81034>>>>>>>    Pointer lpPath
81034>>>>>>>    Pointer lpPrefix
81034>>>>>>>
81034>>>>>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
81035>>>>>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
81036>>>>>>>    Move (pad("", vMAX_PATH)) To sTempFileName
81037>>>>>>>    GetAddress Of sTempFileName To lpTempFileName
81038>>>>>>>    GetAddress Of sPath         To lpPath
81039>>>>>>>    GetAddress Of sPrefix       To lpPrefix
81040>>>>>>>
81040>>>>>>>    Move (vWin32_GetTempFileName(lpPath, lpPrefix, 0, lpTempFileName)) To iRetVal
81041>>>>>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
81042>>>>>>>    Function_Return sTempFileName
81043>>>>>>>End_Function // vCreateTempFileInPath
81044>>>>>>>
81044>>>>>>>//
81044>>>>>>>// Get a specific shell folder for example to get the desktop folder
81044>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
81044>>>>>>>//
81044>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
81046>>>>>>>  String  sFolder
81046>>>>>>>  Integer iVoid
81046>>>>>>>  Pointer lpsFolder
81046>>>>>>>  Handle  hWnd
81046>>>>>>>  Move (Window_Handle(focus(desktop))) To hWnd
81047>>>>>>>
81047>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
81048>>>>>>>  GetAddress Of sFolder To lpsFolder
81049>>>>>>>
81049>>>>>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,lpsFolder)) To iVoid
81050>>>>>>>  Function_Return (CString(sFolder))
81051>>>>>>>End_Function // vSHGetFolderPath
81052>>>>>>>
81052>>>>>>>
81052>>>>>>>
81052>>>>>>>// Courtesy Of Vincent Oorsprong
81052>>>>>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
81054>>>>>>>  String  sftTime sSystemTime sFormattedTime sFormattedDate
81054>>>>>>>  Pointer lpsftTime lpsSystemTime lpsFormattedTime lpsFormattedDate
81054>>>>>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
81054>>>>>>>
81054>>>>>>>  ZeroType vFileTime  To sftTime
81055>>>>>>>  Put dwLowDateTime  To sftTime At vFileTime.dwLowDateTime
81056>>>>>>>  Put dwHighDateTime To sftTime At vFileTime.dwHighDateTime
81057>>>>>>>  GetAddress Of sftTime To lpsftTime
81058>>>>>>>
81058>>>>>>>  ZeroType vSystemTime To sSystemTime
81059>>>>>>>  GetAddress Of sSystemTime To lpsSystemTime
81060>>>>>>>
81060>>>>>>>  Moveint (vWin32_FileTimeToSystemTime (lpsftTime, lpsSystemTime)) To iSuccess
81061>>>>>>>>
81061>>>>>>>  If iSuccess Eq DfTrue Begin
81063>>>>>>>    ZeroString 255 To sFormattedTime
81064>>>>>>>    GetAddress Of sFormattedTime To lpsFormattedTime
81065>>>>>>>    Length sFormattedTime To iLenCcTime
81066>>>>>>>>
81066>>>>>>>    Moveint (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedTime, iLenCcTime)) To iDataLength
81067>>>>>>>>
81067>>>>>>>    ZeroString 255 To sFormattedDate
81068>>>>>>>    GetAddress Of sFormattedDate To lpsFormattedDate
81069>>>>>>>    Length sFormattedDate To iLenCcDate
81070>>>>>>>>
81070>>>>>>>    Moveint (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedDate, iLenCcDate)) To iDataLength
81071>>>>>>>>
81071>>>>>>>    Function_Return (Cstring (sFormattedDate)  * Cstring (sFormattedTime))
81072>>>>>>>  End // iSuccess
81072>>>>>>>>
81072>>>>>>>End_Function // vConvertFileDateTime
81073>>>>>>>
81073>>>>>>>
81073>>>>>>>// **WvA Removed, See the cFileSet class for an alternative
81073>>>>>>>//Procedure DoBrowseDir String sFilePath
81073>>>>>>>//End_Procedure // DoBrowseDir
81073>>>>>>>
81073>>>>>>>// **WvA:
81073>>>>>>>// A windows replacement for the standard function FileExists.
81073>>>>>>>// This version will also return (true) for a file when it is open by an application.
81073>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
81073>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
81073>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
81073>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
81075>>>>>>>  String  sWin32FindData
81075>>>>>>>  String  sDirSep
81075>>>>>>>  Pointer lpsFilePathMask lpsWin32FindData
81075>>>>>>>  Handle  hFindFile
81075>>>>>>>  Integer iVoid
81075>>>>>>>
81075>>>>>>>  Move vINVALID_HANDLE_VALUE To hFindFile
81076>>>>>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
81077>>>>>>>
81077>>>>>>>  If (length(sFilePathMask)>0) Begin
81079>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
81079>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
81080>>>>>>>    While (Right(sFilePathMask, 1) = sDirSep)
81084>>>>>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
81085>>>>>>>    Loop
81086>>>>>>>>
81086>>>>>>>
81086>>>>>>>    GetAddress Of sFilePathMask To lpsFilePathMask
81087>>>>>>>    ZeroType vWin32_Find_Data To sWin32FindData
81088>>>>>>>    GetAddress Of sWin32FindData To lpswin32FindData
81089>>>>>>>    Move (vWin32_FindFirstFile (lpsFilePathMask, lpsWin32FindData)) To hFindFile
81090>>>>>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
81091>>>>>>>  End
81091>>>>>>>>
81091>>>>>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
81092>>>>>>>End_Function // vFilePathExists
81093>>>>>>>
81093>>>>>>>
81093>>>>>>>// **WvA
81093>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
81093>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
81093>>>>>>>// The folder may contain a drive letter or UNC encoding.
81093>>>>>>>Function vFolderFormat Global String sFolderName Returns String
81095>>>>>>>  String sDirSep
81095>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
81096>>>>>>>  Move (Trim(sFolderName)) To sFolderName
81097>>>>>>>  If (Right(sFolderName,1)<>sDirSep) Begin
81099>>>>>>>    Move (sFolderName+sDirSep) To sFolderName
81100>>>>>>>  End
81100>>>>>>>>
81100>>>>>>>  Function_Return sFolderName
81101>>>>>>>End_Function // vFolderFormat
81102>>>>>>>//
81102>>>>>>>// Returns the amount of files in the folder (if it exists)
81102>>>>>>>// Returns -1 if folder doesn't exist.
81102>>>>>>>// The files "." and ".." are not counted.
81102>>>>>>>//
81102>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
81104>>>>>>>  Boolean bFound
81104>>>>>>>  Handle  hFindFile
81104>>>>>>>  Integer iCount  iVoid
81104>>>>>>>  Integer iSuccess
81104>>>>>>>  Pointer lpsFolderName lpsWin32FindData
81104>>>>>>>  String  sWin32FindData
81104>>>>>>>  String  sFileName
81104>>>>>>>
81104>>>>>>>  Move -1 To iCount
81105>>>>>>>  Get vFolderFormat sFolderName To sFolderName
81106>>>>>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
81107>>>>>>>  GetAddress Of sFolderName To lpsFolderName
81108>>>>>>>  ZeroType vWin32_Find_Data To sWin32FindData
81109>>>>>>>  GetAddress Of sWin32FindData To lpswin32FindData
81110>>>>>>>  Move (vWin32_FindFirstFile (lpsFolderName, lpsWin32FindData)) To hFindFile
81111>>>>>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
81112>>>>>>>  If (bFound) Move 0 To iCount
81115>>>>>>>  While (bFound)
81119>>>>>>>    Increment iCount
81120>>>>>>>    GetBuff_String From sWin32FindData At vWin32_Find_Data.cFileName To sFileName
81121>>>>>>>    If (sFileName="." or sFileName="..") Decrement iCount
81124>>>>>>>    Move (vWin32_FindNextFile(hFindFile, lpsWin32FindData)) To iSuccess
81125>>>>>>>    Move (iSuccess<>0) To bFound
81126>>>>>>>  Loop
81127>>>>>>>>
81127>>>>>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
81128>>>>>>>  Function_Return iCount
81129>>>>>>>End_Function // vFolderFileCount
81130>>>>>>>
81130>>>>>>>
81130>>>>>>>//
81130>>>>>>>// Gets the parent path of the currently supplied path
81130>>>>>>>// Returns "" when we are at the root folder.
81130>>>>>>>//
81130>>>>>>>Function vParentPath Global String sPath Returns String
81132>>>>>>>  String sStrip
81132>>>>>>>  Integer iLength
81132>>>>>>>  
81132>>>>>>>  If (Right(sPath,1)="\") Begin
81134>>>>>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
81135>>>>>>>  End
81135>>>>>>>>
81135>>>>>>>  If (Pos("\",sPath)) Begin
81137>>>>>>>    Move (StringFromRightOfChar(sPath,"\")) to sStrip
81138>>>>>>>    Move (Length(sStrip)) to iLength
81139>>>>>>>    Move (Left(sPath, (Length(sPath) - iLength -1))) to sPath
81140>>>>>>>//    Move (Replace(sStrip,sPath,"")) To sPath
81140>>>>>>>  End
81140>>>>>>>>
81140>>>>>>>  Else Begin
81141>>>>>>>    Move "" To sPath
81142>>>>>>>  End
81142>>>>>>>>
81142>>>>>>>  Function_Return sPath
81143>>>>>>>End_Function // vParentPath
81144>>>>>>>
81144>>>>>>>// Create the folder, including intermediate directories.
81144>>>>>>>// Don't panic if the folder already exists.
81144>>>>>>>// Michael Mullan June 2009.
81144>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
81146>>>>>>>  String  sFolder sSA
81146>>>>>>>  Pointer lpsFolder lpsSecurity_Attributes
81146>>>>>>>  Integer iRetval bFolderCreated bInheritHandle
81146>>>>>>>  Move (False) to bFolderCreated
81147>>>>>>>  // fill string variable with null characters
81147>>>>>>>  ZeroType vtSecurity_attributes to sSA
81148>>>>>>>  // null MAX_PATH chars into var (make space)
81148>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
81149>>>>>>>  If (sNewFolder <> "") Begin
81151>>>>>>>    Move dfTrue to  bInheritHandle
81152>>>>>>>    // Setting this to NULL is already done by the zerotype command
81152>>>>>>>    // Move NULL   To  lpDescriptor
81152>>>>>>>    Put (length(sSA))   to sSA At vtSecurity_attributes.nLength
81153>>>>>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
81153>>>>>>>    Put bInheritHandle to sSA At vtSecurity_attributes.bInheritHandle
81154>>>>>>>    GetAddress of sSA to lpsSecurity_Attributes
81155>>>>>>>    //
81155>>>>>>>    Move sNewFolder to sFolder
81156>>>>>>>    GetAddress of sFolder to lpsFolder
81157>>>>>>>    Move (vWin32_SHCreateDirectoryEx(0,lpsFolder, lpsSecurity_Attributes)) to bFolderCreated
81158>>>>>>>  End
81158>>>>>>>>
81158>>>>>>>
81158>>>>>>>  If (bFolderCreated <> 0) Begin
81160>>>>>>>    Move 1 to iRetVal
81161>>>>>>>
81161>>>>>>>    If (bFolderCreated = 161 ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
81164>>>>>>>    Else If (bFolderCreated = 206 ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
81168>>>>>>>    Else If (bFolderCreated = 3   ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
81172>>>>>>>    Else If (bFolderCreated = 80  ) Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
81176>>>>>>>    Else If (bFolderCreated = 183 ) Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
81180>>>>>>>    Else If (bFolderCreated = 1223) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
81184>>>>>>>    Else Error DFERR_OPERATOR ("Folder Creation Error # " + String(bfoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
81186>>>>>>>  End
81186>>>>>>>>
81186>>>>>>>  Function_Return iRetVal
81187>>>>>>>End_Function // vshCreateDirectoryEX
81188>>>>>>>
81188>>>>>>>
81188>>>>>>>Function vWin32_APIFileSize Global string sFileName returns integer
81190>>>>>>>     dWord dwFileSizeHigh dwFileSizeLow
81190>>>>>>>     integer iFileSize iVoid
81190>>>>>>>     handle hFindFile
81190>>>>>>>     pointer lpsFilePath lpsWin32FindData
81190>>>>>>>     string sWin32FindData
81190>>>>>>>
81190>>>>>>>     GetAddress of sFileName to lpsFilePath
81191>>>>>>>
81191>>>>>>>     ZeroType vWin32_Find_Data to sWin32FindData
81192>>>>>>>     GetAddress of sWin32FindData to lpsWin32FindData
81193>>>>>>>
81193>>>>>>>     move (vWin32_FindFirstFile (lpsFilePath, lpsWin32FindData)) to hFindFile
81194>>>>>>>     if (hFindFile<>vINVALID_HANDLE_VALUE) begin
81196>>>>>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeHigh To dwFileSizeHigh
81197>>>>>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeLow To dwFileSizeLow
81198>>>>>>>     end
81198>>>>>>>>
81198>>>>>>>     move (vWin32_FindClose (hFindFile)) to iVoid
81199>>>>>>>
81199>>>>>>>     moveInt ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
81200>>>>>>>>
81200>>>>>>>
81200>>>>>>>     function_return iFileSize
81201>>>>>>>End_Function  // vWin32_APIFileSize
81202>>>>>>>
81202>>>>>>>
81202>>>>>Use DUFLanguageConstants.inc  
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
81202>>>>>>>//
81202>>>>>>>// *** The Database Update Framework Include file ***
81202>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
81202>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
81202>>>>>>>//
81202>>>>>>>//
81202>>>>>>>Use LanguageText.Pkg
81202>>>>>>>
81202>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
81202>>>>>>>//
81202>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
81202>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
81202>>>>>>>//
81202>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
81202>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
81202>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
81202>>>>>>>//
81202>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
81202>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
81202>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
81202>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
81202>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
81202>>>>>>>//
81202>>>>>>>    Define CS_UpdateVersion     for "Updating database"
81202>>>>>>>    Define CS_UpdateFromVersion for "from version"
81202>>>>>>>    Define CS_UpdateToVersion   for "to version:"
81202>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
81202>>>>>>>//
81202>>>>>>>    Define CS_DatabaseInUseShort  for "There are others using the application/database. Are you sure you still want to update the database?"
81202>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
81202>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
81202>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
81202>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
81202>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
81202>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
81202>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
81202>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
81202>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>>>
81202>>>>>
81202>>>>>Struct tDbVersionInfo
81202>>>>>    Number nVersionNumber
81202>>>>>    Handle hObject
81202>>>>>End_Struct         
81202>>>>>
81202>>>>>Struct tDbUpdateError
81202>>>>>    Number nUpdateVersion
81202>>>>>    Integer iError
81202>>>>>    String  sErrorText
81202>>>>>    Integer iErrorLine
81202>>>>>    Boolean bError
81202>>>>>End_Struct
81202>>>>>
81202>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
81202>>>>>//  DF_FILE_IS_MASTER if master
81202>>>>>//  DF_FILE_IS_ALIAS if alias
81202>>>>>Struct tDbUpdateHandlerMasterAlias
81202>>>>>    Handle hTable
81202>>>>>    Integer iMode
81202>>>>>End_Struct
81202>>>>>
81202>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
81202>>>>>Enumeration_List
81202>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
81202>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
81202>>>>>End_Enumeration_List
81202>>>>>
81202>>>>>    Define DATAFLEX_ID for "DATAFLEX"
81202>>>>>
81202>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
81202>>>>>// communicate with the object from anywhere in a program.
81202>>>>>    Global_Variable Handle ghoDbUpdateHandler
81202>>>>>
81202>>>>>// NOTE: If the DbVersion table should _not_ be used and you
81202>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
81202>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
81202>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
81202>>>>>    Declare_Datafile DbVersion
Including file: DbVersion.fd    (C:\Projects\DF18\DbUpdateFramework\DDSrc\DbVersion.fd)
81202>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
81202>>>>>//****************************************************************************
81202>>>>>// $Module type: Class
81202>>>>>// $Module name: cDbUpdateLogFile
81202>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
81202>>>>>// Web-site    : http://www.rdctools.com
81202>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
81202>>>>>//
81202>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
81202>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
81202>>>>>//               that this class is to change; each developer can decide if the errors instead
81202>>>>>//               should be saved to a database table, or something entirely different.
81202>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
81202>>>>>//
81202>>>>>// $Rev History:
81202>>>>>//    2016-10-05  Module header created
81202>>>>>//****************************************************************************
81202>>>>>Use UI
81202>>>>>
81202>>>>>
81202>>>>>Class cDbUpdateLogFile is a cObject
81203>>>>>
81203>>>>>    Procedure Construct_Object
81205>>>>>        Forward Send Construct_Object
81207>>>>>
81207>>>>>        // Error handling:
81207>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
81208>>>>>        Property Integer piChannel -1
81209>>>>>
81209>>>>>        // This property is set by the cDbUpdateHandler object,
81209>>>>>        // when the update process starts.
81209>>>>>        Property DateTime pdtUpdateStart
81210>>>>>
81210>>>>>        // Gets set to True after the error log header text
81210>>>>>        // has been written.
81210>>>>>        Property Boolean pbHeaderWritten False
81211>>>>>
81211>>>>>        // If all activities should be logged- not just errors.
81211>>>>>        Property Boolean pbVerboseState False
81212>>>>>
81212>>>>>        // File name for the error log where all errors
81212>>>>>        // after a run is written to (appended).
81212>>>>>        // It is saved in the Data folder.
81212>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
81213>>>>>        Property String psEditorProgram "Notepad.exe"
81214>>>>>
81214>>>>>        Property Boolean pbUseDataTable False
81215>>>>>
81215>>>>>        // If true an error will be written to file immediately when
81215>>>>>        // it occurs. This can be handy if a large update generates a lots
81215>>>>>        // of errors and the application crasches before finished, thus
81215>>>>>        // the errors will not be written.
81215>>>>>        Property Boolean pbQuickWrite True
81216>>>>>    End_Procedure
81217>>>>>
81217>>>>>    Procedure End_Construct_Object
81219>>>>>        Forward Send End_Construct_Object
81221>>>>>
81221>>>>>    End_Procedure
81222>>>>>
81222>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError
81224>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
81224>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
81226>>>>>        Boolean bQuickWrite
81226>>>>>        Integer iSize
81226>>>>>        String sChar
81226>>>>>
81226>>>>>        // Only do once.
81226>>>>>        If (pbHeaderWritten(Self) = False) Begin
81228>>>>>            Send WriteHeaderData
81229>>>>>            Set pbHeaderWritten to True
81230>>>>>        End
81230>>>>>>
81230>>>>>
81230>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
81231>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
81232>>>>>        Move nVersion   to DbUpdateErrorArray[iSize].nUpdateVersion
81233>>>>>        Move iError     to DbUpdateErrorArray[iSize].iError
81234>>>>>        Move iErrorLine to DbUpdateErrorArray[iSize].iErrorLine
81235>>>>>        Move True       to DbUpdateErrorArray[iSize].bError
81236>>>>>        Move sErrorText to DbUpdateErrorArray[iSize].sErrorText
81237>>>>>
81237>>>>>        If (bError = False) Begin
81239>>>>>            Move False to DbUpdateErrorArray[iSize].bError
81240>>>>>        End
81240>>>>>>
81240>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
81241>>>>>
81241>>>>>        If (pbUseDataTable(Self) = True) Begin
81243>>>>>            If (pbQuickWrite(Self) = True) Begin
81245>>>>>                Send OnWriteRow_DataTable
81246>>>>>                // If we are writing error for error flush the
81246>>>>>                // error array when latest error has been written.
81246>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
81247>>>>>            End
81247>>>>>>
81247>>>>>            Procedure_Return
81248>>>>>        End  
81248>>>>>>
81248>>>>>        Else Begin
81249>>>>>            If (pbQuickWrite(Self) = True) Begin
81251>>>>>                Send WriteErrorLog                                 
81252>>>>>                // Flush the error log array
81252>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
81253>>>>>            End
81253>>>>>>
81253>>>>>        End
81253>>>>>>
81253>>>>>
81253>>>>>    End_Procedure
81254>>>>>
81254>>>>>    // Hook procedure for writing header text prior starting the update work to
81254>>>>>    // a database table. This does nothing by default.
81254>>>>>    // Don't forget to Open your "error log table" first (!) as all
81254>>>>>    // tables have been closed at this stage. Put anything
81254>>>>>    // you want to indicate that the update process is just started.
81254>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
81256>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
81258>>>>>    End_Procedure
81259>>>>>
81259>>>>>    Procedure OnWriteRow_DataTable
81261>>>>>        tDbUpdateError[] DbUpdateErrorArray
81261>>>>>        tDbUpdateError[] DbUpdateErrorArray
81262>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
81263>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
81265>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
81267>>>>>        End
81267>>>>>>
81267>>>>>    End_Procedure
81268>>>>>
81268>>>>>    Procedure WriteHeaderData
81270>>>>>        String sPath sFileName
81270>>>>>        Integer iCount iSize iCh
81270>>>>>        Boolean bExists bQuickWrite
81270>>>>>        DateTime dtCurrentDateTime dtUpdateStart dtUpdateEnd
81270>>>>>        TimeSpan tsElapsed
81270>>>>>
81270>>>>>        Move (CurrentDateTime()) to dtUpdateStart
81271>>>>>        If (pbUseDataTable(Self) = True) Begin
81273>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
81274>>>>>            Procedure_Return
81275>>>>>        End
81275>>>>>>
81275>>>>>
81275>>>>>        Get piChannel to iCh
81276>>>>>        If (iCh < 0) Begin
81278>>>>>            Get Seq_New_Channel to iCh
81279>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
81281>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
81282>>>>>>
81282>>>>>                Procedure_Return
81283>>>>>            End
81283>>>>>>
81283>>>>>            Set piChannel to iCh
81284>>>>>        End
81284>>>>>>
81284>>>>>
81284>>>>>        Get psDataPathFirstPart to sPath
81285>>>>>        Get psLogTextFile to sFileName
81286>>>>>        Move (sPath + sFileName) to sFileName
81287>>>>>
81287>>>>>        Get pbQuickWrite to bQuickWrite
81288>>>>>        If (bQuickWrite = True) Begin
81290>>>>>            Append_Output channel iCh sFileName
81292>>>>>                If (bQuickWrite = True) Begin
81294>>>>>                    Writeln channel iCh ""
81297>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
81300>>>>>                End
81300>>>>>>
81300>>>>>            Close_Output channel iCh
81302>>>>>        End
81302>>>>>>
81302>>>>>
81302>>>>>    End_Procedure
81303>>>>>
81303>>>>>    // Returns the first datapath found in the psDataPath property.
81303>>>>>    // The returned path always ends with a "\"
81303>>>>>    Function psDataPathFirstPart Returns String
81305>>>>>        String sDataPath
81305>>>>>        Integer iCount
81305>>>>>
81305>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81306>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
81307>>>>>        If (iCount > 1) Begin
81309>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
81310>>>>>        End
81310>>>>>>
81310>>>>>        If (sDataPath <> "") Begin
81312>>>>>            Get vFolderFormat sDataPath to sDataPath
81313>>>>>        End
81313>>>>>>
81313>>>>>
81313>>>>>        Function_Return sDataPath
81314>>>>>    End_Function
81315>>>>>
81315>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
81315>>>>>    Procedure WriteErrorLog
81317>>>>>        tDbUpdateError[] aDbUpdateErrorArray
81317>>>>>        tDbUpdateError[] aDbUpdateErrorArray
81318>>>>>        String sPath sFileName sErrorNo sVersion sErrorText sText
81318>>>>>        Integer iCount iSize iCh iError iErrorLine
81318>>>>>        Boolean bExists bUseDataTable bQuickWrite bError
81318>>>>>        DateTime dtCurrentDateTime dtUpdateStart dtUpdateEnd
81318>>>>>        TimeSpan tsElapsed
81318>>>>>        Number nVersion
81318>>>>>
81318>>>>>        If (pbHeaderWritten(Self) = False) Begin
81320>>>>>            Send WriteHeaderData
81321>>>>>            Set pbHeaderWritten to True
81322>>>>>        End
81322>>>>>>
81322>>>>>
81322>>>>>        Get pbUseDataTable to bUseDataTable
81323>>>>>        If (bUseDataTable = True) Begin
81325>>>>>            Send OnWriteRow_DataTable
81326>>>>>            Procedure_Return
81327>>>>>        End
81327>>>>>>
81327>>>>>
81327>>>>>        Get piChannel to iCh
81328>>>>>        If (iCh < 0) Begin
81330>>>>>            Get Seq_New_Channel to iCh
81331>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
81333>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
81334>>>>>>
81334>>>>>                Procedure_Return
81335>>>>>            End
81335>>>>>>
81335>>>>>            Set piChannel to iCh
81336>>>>>        End
81336>>>>>>
81336>>>>>
81336>>>>>        Get psDataPathFirstPart to sPath
81337>>>>>        Get psLogTextFile to sFileName
81338>>>>>        Move (sPath + sFileName) to sFileName
81339>>>>>
81339>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
81340>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
81341>>>>>        Decrement iSize
81342>>>>>
81342>>>>>        Get pdtUpdateStart to dtUpdateStart
81343>>>>>        Move (CurrentDateTime()) to dtUpdateEnd
81344>>>>>        Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
81345>>>>>        Get pbQuickWrite to bQuickWrite
81346>>>>>
81346>>>>>        Append_Output channel iCh sFileName
81348>>>>>            If (bQuickWrite = True) Begin
81350>>>>>                Writeln channel iCh ("Database Update Finished at:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
81353>>>>>            End
81353>>>>>>
81353>>>>>            Else Begin
81354>>>>>                Writeln channel iCh
81356>>>>>                Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
81359>>>>>            End
81359>>>>>>
81359>>>>>            Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
81362>>>>>
81362>>>>>            For iCount from 0 to iSize
81368>>>>>>
81368>>>>>                Move aDbUpdateErrorArray[iCount].iError         to iError
81369>>>>>                Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
81370>>>>>                Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
81371>>>>>                Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine
81372>>>>>                Get PadLeft (String(iError)) 8 to sErrorNo
81373>>>>>                If (aDbUpdateErrorArray[iCount].bError = True) Begin
81375>>>>>                    Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
81376>>>>>                    Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]") to sText
81377>>>>>                End
81377>>>>>>
81377>>>>>                Else Begin
81378>>>>>                    Get PadLeft (String(nVersion)) 27 to sVersion
81379>>>>>                    Move (sVersion + "   " + sErrorText) to sText
81380>>>>>                End
81380>>>>>>
81380>>>>>                Writeln channel iCh sText
81383>>>>>            Loop
81384>>>>>>
81384>>>>>        Close_Output channel iCh
81386>>>>>
81386>>>>>        Send Seq_Release_Channel iCh
81387>>>>>        Set piChannel to -1
81388>>>>>
81388>>>>>    End_Procedure
81389>>>>>
81389>>>>>    // The character to pad is optional. If nothing, spaces are used.
81389>>>>>    // Example:
81389>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
81389>>>>>    //  or:
81389>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
81389>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
81389>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
81391>>>>>        String sChar
81391>>>>>
81391>>>>>        If (Num_Arguments >= 3) Begin
81393>>>>>            Move sOptChar to sChar
81394>>>>>        End
81394>>>>>>
81394>>>>>        Else Begin
81395>>>>>            Move " " to sChar
81396>>>>>        End
81396>>>>>>
81396>>>>>
81396>>>>>        While (Length(sString) < iLength)
81400>>>>>            Move (sChar + sString) to sString
81401>>>>>        Loop
81402>>>>>>
81402>>>>>
81402>>>>>        Function_Return sString
81403>>>>>    End_Function
81404>>>>>
81404>>>>>    Procedure ShowErrorLog
81406>>>>>        String sPath sFileName
81406>>>>>        Boolean bExists
81406>>>>>
81406>>>>>        Get psDataPathFirstPart to sPath
81407>>>>>        Get psLogTextFile to sFileName
81408>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
81409>>>>>        If (bExists = True) Begin
81411>>>>>            Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
81412>>>>>        End
81412>>>>>>
81412>>>>>        Else Begin
81413>>>>>            Send Info_Box ("Could not locate the error log file:\n\n" + (sPath + sFileName))
81414>>>>>        End
81414>>>>>>
81414>>>>>    End_Procedure
81415>>>>>
81415>>>>>End_Class
81416>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
81416>>>>>//****************************************************************************
81416>>>>>// $Module type: Class
81416>>>>>// $Module name: cDbUpdateVersion
81416>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
81416>>>>>// Web-site    : http://www.rdctools.com
81416>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
81416>>>>>//
81416>>>>>// Description : Child class to cDbUpdateHandler.
81416>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
81416>>>>>//               Set the pnVersionNumber to a version number.
81416>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
81416>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
81416>>>>>//               Place your code in the "OnUpdate" event that alters the database.
81416>>>>>//
81416>>>>>// $Rev History:
81416>>>>>//    2016-09-27  Module header created
81416>>>>>//****************************************************************************
81416>>>>>Use UI
81416>>>>>Use DUFLanguageConstants.inc
81416>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
81416>>>>>>>//****************************************************************************
81416>>>>>>>// $Module type: Class
81416>>>>>>>// $Module name: cDbUpdateFunctionLibrary
81416>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
81416>>>>>>>// Web-site    : http://www.rdctools.com
81416>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
81416>>>>>>>//
81416>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
81416>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
81416>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
81416>>>>>>>//               with the help of Sql-scripts.
81416>>>>>>>//
81416>>>>>>>// $Rev History:
81416>>>>>>>//    2014-09-05  Module header created
81416>>>>>>>//
81416>>>>>>>//****************************************************************************
81416>>>>>>>Use cApplication.pkg
81416>>>>>>>Use seq_chnl.pkg
81416>>>>>>>Use GlobalFunctionsProcedures.pkg
81416>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
81416>>>>>>>Use DUFStatusPanel.pkg
81416>>>>>>>Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
81416>>>>>>>>>Use DUFLanguageConstants.inc
81416>>>>>>>>>
81416>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
81416>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
81416>>>>>>>>>
81416>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
81416>>>>>>>>>
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_OEM_Txt for "OEM"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_SERVER for "SERVER"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
81416>>>>>>>>>
81416>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
81416>>>>>>>>>
81416>>>>>>>>>
81416>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
81416>>>>>>>>>
81416>>>>>>>>>Struct tSQLScriptArray
81416>>>>>>>>>    Boolean bError
81416>>>>>>>>>    Boolean bArgumentSizeChanged
81416>>>>>>>>>    Integer iOrgArgumentSize
81416>>>>>>>>>    String[] sSQLScriptArray
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tSqlErrorArray
81416>>>>>>>>>    String[]  sSqlErrorArray
81416>>>>>>>>>    String[]  sSqlStatementArray
81416>>>>>>>>>    Integer[] iSqlErrorArray
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tSqlColumnNew
81416>>>>>>>>>    String  sBaseColumnName
81416>>>>>>>>>    String  sBaseTableName
81416>>>>>>>>>    String  sLabel
81416>>>>>>>>>    Integer iSqlType
81416>>>>>>>>>    Integer iSize
81416>>>>>>>>>    Integer iPrecision
81416>>>>>>>>>    Integer iDFType
81416>>>>>>>>>    Integer iDFNativeType
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tColumnType
81416>>>>>>>>>    String  sType
81416>>>>>>>>>    Integer iType
81416>>>>>>>>>    String  sDataFlexType
81416>>>>>>>>>    Integer iDataFlexType
81416>>>>>>>>>    String  sPrecision
81416>>>>>>>>>    Boolean bFixedSize 
81416>>>>>>>>>    Boolean bNativeDataType
81416>>>>>>>>>    Integer iDefaultSize
81416>>>>>>>>>    Integer iMinSize
81416>>>>>>>>>    Number  nMaxSize
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
81416>>>>>>>>>// Various SQL back-ends can have slightly different
81416>>>>>>>>>// keywords.
81416>>>>>>>>>Struct tSQLKeyWords
81416>>>>>>>>>    Integer iSQLWord
81416>>>>>>>>>    Integer iSQLDbType
81416>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tSQLRelation
81416>>>>>>>>>    Integer iFileNumber
81416>>>>>>>>>    Integer iFieldNumber
81416>>>>>>>>>    String  sFileName
81416>>>>>>>>>    String  sFieldName
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tSQLLoggedInUser
81416>>>>>>>>>    String sUser
81416>>>>>>>>>    String sProgram
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
81416>>>>>>>>>
81416>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
81416>>>>>>>>>// They can have slightly different SQL keywords.
81416>>>>>>>>>// Note: If a new type is added to the list,
81416>>>>>>>>>//       the struct array xxx must be adjusted
81416>>>>>>>>>//       so that it is filled with all SQL
81416>>>>>>>>>//       keywords for that new type.
81416>>>>>>>>>Enum_List
81416>>>>>>>>>    Define EN_DbTypeMSSQL
81416>>>>>>>>>    Define EN_DbTypeMySQL
81416>>>>>>>>>    Define EN_DbTypeOracle
81416>>>>>>>>>    Define EN_DbTypeDB2
81416>>>>>>>>>    Define EN_DbTypePostgre
81416>>>>>>>>>    Define EN_DbTypeDataFlex // Embedded database.
81416>>>>>>>>>End_Enum_List
81416>>>>>>>>>
81416>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
81416>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
81416>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
81416>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
81416>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
81416>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
81416>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
81416>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
81416>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
81416>>>>>>>>>
81416>>>>>>>>>// We need to re-define the standard constants because several driver constants
81416>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
81416>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
81416>>>>>>>>>Enum_List
81416>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
81416>>>>>>>>>    Define DF_BCD_DUF       for -1499
81416>>>>>>>>>    Define DF_DATE_DUF      for -1498
81416>>>>>>>>>    Define DF_TEXT_DUF      for -1495
81416>>>>>>>>>    Define DF_BINARY_DUF    for -1494
81416>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
81416>>>>>>>>>End_Enum_List
81416>>>>>>>>>
81416>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
81416>>>>>>>>>
81416>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
81416>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
81416>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
81416>>>>>>>>>
81416>>>>>>>>>// These are not defined pre DF 18:
81416>>>>>>>>>    Define SQL_VARCHARMAX for (-201)
81416>>>>>>>>>    Define SQL_TYPE_MONEY for (-204)
81416>>>>>>>>>    Define SQL_TYPE_SMALLMONEY for (-205)
81416>>>>>>>>>    Define SQL_TYPE_SMALLDATETIME for (-206)
81416>>>>>>>>>
81416>>>>>>>>>Struct tSQLIntTableInfo
81416>>>>>>>>>    String sDriverName
81416>>>>>>>>>    String sServerName
81416>>>>>>>>>    String sDatabaseName
81416>>>>>>>>>    String sSchemaName
81416>>>>>>>>>    Boolean bRecnumTable
81416>>>>>>>>>    Integer iPrimaryIndex
81416>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
81416>>>>>>>>>    String sTableCharacterFormat
81416>>>>>>>>>    Boolean bUseDummyZeroDate
81416>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
81416>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
81416>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
81416>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
81416>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
81416>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
81416>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
81416>>>>>>>>>    String sFileIndexTablespace
81416>>>>>>>>>    String sFileLongTablespace
81416>>>>>>>>>    String sTableTablespace
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tSQLIntColumnInfo
81416>>>>>>>>>    Integer iFieldNumber
81416>>>>>>>>>    Integer iFieldIndex
81416>>>>>>>>>    Integer iFieldRelatedFile
81416>>>>>>>>>    Integer iFieldRelatedField
81416>>>>>>>>>    Integer iIndexNumber
81416>>>>>>>>>    Integer iIndexNumberSegments      
81416>>>>>>>>>    Integer iIndexSegmentField1
81416>>>>>>>>>    Integer iIndexSegmentField2
81416>>>>>>>>>    Integer iIndexSegmentFieldn
81416>>>>>>>>>    String  sIndexName
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tAPIColumn 
81416>>>>>>>>>    String  sFieldName 
81416>>>>>>>>>    Integer iFieldNumber
81416>>>>>>>>>    Integer iType  
81416>>>>>>>>>    String  sType
81416>>>>>>>>>    Integer iLength 
81416>>>>>>>>>    Integer iPrecision 
81416>>>>>>>>>    Integer iOptions  
81416>>>>>>>>>    Boolean bIsSQLType
81416>>>>>>>>>    Boolean bShouldChange
81416>>>>>>>>>End_Struct  
81416>>>>>>>>>
81416>>>>>>>>>Struct tAPIRelation
81416>>>>>>>>>    Handle  hTableFrom
81416>>>>>>>>>    String  sLogicalNameFrom
81416>>>>>>>>>    Handle  hTableTo 
81416>>>>>>>>>    String  sLogicalNameTo
81416>>>>>>>>>    Integer iColumnFrom
81416>>>>>>>>>    String  sFieldNameFrom
81416>>>>>>>>>    Integer iColumnTo 
81416>>>>>>>>>    String  sFieldNameTo
81416>>>>>>>>>    Boolean bShouldChange
81416>>>>>>>>>End_Struct 
81416>>>>>>>>>
81416>>>>>>>>>Struct tAPIIndexSegment
81416>>>>>>>>>    Integer iFieldNumber
81416>>>>>>>>>    String  sFieldName 
81416>>>>>>>>>    Boolean bUppercase
81416>>>>>>>>>    Boolean bAscending
81416>>>>>>>>>    Boolean bShouldChange
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tAPIIndex
81416>>>>>>>>>    Integer iIndexNumber
81416>>>>>>>>>    String  sSQLIndexName
81416>>>>>>>>>    Integer iSQLIndexType
81416>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray 
81416>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray 
81416>>>>>>>>>    Boolean bIsPrimaryKey
81416>>>>>>>>>    Boolean bShouldChange
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Struct tAPITableNameInfo
81416>>>>>>>>>    Integer iTableNumber 
81416>>>>>>>>>    String  sRootName
81416>>>>>>>>>    String  sLogicalName
81416>>>>>>>>>    String  sDisplayName  
81416>>>>>>>>>    String  sDriverID
81416>>>>>>>>>    Boolean bIsAlias
81416>>>>>>>>>    Boolean bIsSQL
81416>>>>>>>>>    Boolean bShouldChange
81416>>>>>>>>>End_Struct
81416>>>>>>>>>    
81416>>>>>>>>>Struct tAPITable
81416>>>>>>>>>    tAPITableNameInfo ApiTableInfo
81416>>>>>>>>>    tAPITableNameInfo ApiTableInfo
81416>>>>>>>>>    tAPIColumn[]      aApiColumns
81416>>>>>>>>>    tAPIColumn[]      aApiColumns
81416>>>>>>>>>    tAPIIndex[]       aApiIndexes
81416>>>>>>>>>    tAPIIndex[]       aApiIndexes
81416>>>>>>>>>    tAPIRelation[]    aApiRelations
81416>>>>>>>>>    tAPIRelation[]    aApiRelations
81416>>>>>>>>>    Boolean bShouldChange
81416>>>>>>>>>End_Struct 
81416>>>>>>>>>
81416>>>>>>>>>Struct tAPITableBooleans
81416>>>>>>>>>    Boolean bCompareDate_DateTime
81416>>>>>>>>>    Boolean bCompareIndexAscending
81416>>>>>>>>>    Boolean bCompareIndexUppercase
81416>>>>>>>>>    Boolean bCompareFilelistUppercase
81416>>>>>>>>>End_Struct
81416>>>>>>>>>
81416>>>>>>>>>Define C_tAPIColumn_None for 0
81416>>>>>>>>>Define C_tAPIColumn_Identity for 1 
81416>>>>>>>>>
81416>>>>>>>>>// SQL Key-Word Constants:
81416>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
81416>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
81416>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
81416>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
81416>>>>>>>>>Enum_List
81416>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
81416>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
81416>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
81416>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
81416>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
81416>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
81416>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
81416>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
81416>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
81416>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
81416>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
81416>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
81416>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
81416>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
81416>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
81416>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
81416>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
81416>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
81416>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
81416>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
81416>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
81416>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
81416>>>>>>>>>    Define CI_SQLTo                    //for "TO"
81416>>>>>>>>>    Define CI_SQLGO                    //for "GO"
81416>>>>>>>>>    Define CI_SQLUse                   //for "USE"
81416>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
81416>>>>>>>>>
81416>>>>>>>>>    Define CI_SQLName                  //for "NAME"
81416>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
81416>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
81416>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
81416>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
81416>>>>>>>>>    Define CI_SQLID                    //for "ID"
81416>>>>>>>>>    Define CI_SQLAND                   //for "AND"
81416>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
81416>>>>>>>>>    Define CI_SQLSet                   //for "SET"
81416>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
81416>>>>>>>>>End_Enum_List
81416>>>>>>>>>
81416>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
81416>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
81416>>>>>>>>>//
81416>>>>>>>>>// We need to create a mixin class for the library.
81416>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
81416>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
81416>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
81416>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
81416>>>>>>>>>//
81416>>>>>>>>>Use VdfBase.pkg
81416>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinUuid.pkg)
81416>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
81417>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
81418>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
81419>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
81420>>>>>>>>>>>
81420>>>>>>>>>>>// RandomHexUUID:
81420>>>>>>>>>>>
81420>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
81420>>>>>>>>>>>Function RandomHexUUID Global Returns String
81422>>>>>>>>>>>    Address pUUID pUUIDStr
81422>>>>>>>>>>>    Integer iRetval iOffset iChar
81422>>>>>>>>>>>    String sUUID sKey
81422>>>>>>>>>>>    
81422>>>>>>>>>>>    Move (Alloc(16)) to pUUID
81423>>>>>>>>>>>    
81423>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
81424>>>>>>>>>>>    
81424>>>>>>>>>>>    If (iRetval = 0) Begin
81426>>>>>>>>>>>        Move 0 to pUUIDStr
81427>>>>>>>>>>>        
81427>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
81428>>>>>>>>>>>        If (iRetval = 0) Begin
81430>>>>>>>>>>>            Move pUUIDStr to sUUID
81431>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
81432>>>>>>>>>>> 
81432>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
81433>>>>>>>>>>>        End
81433>>>>>>>>>>>>
81433>>>>>>>>>>>    End
81433>>>>>>>>>>>>
81433>>>>>>>>>>>    
81433>>>>>>>>>>>    Move (Free(pUUID)) to iRetval 
81434>>>>>>>>>>>    
81434>>>>>>>>>>>    Function_Return sUUID
81435>>>>>>>>>>>End_Function
81436>>>>>>>>>>>
81436>>>>>>>>>>>
81436>>>>>>>>>>>// SeqHexUUID:
81436>>>>>>>>>>>
81436>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
81436>>>>>>>>>>>Function SeqHexUUID Global Returns String    
81438>>>>>>>>>>>    Address pUUID pUUIDStr
81438>>>>>>>>>>>    Integer iRetval iOffset iChar
81438>>>>>>>>>>>    String sUUID sKey
81438>>>>>>>>>>>    
81438>>>>>>>>>>>    Move (Alloc(16)) to pUUID
81439>>>>>>>>>>>    
81439>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
81440>>>>>>>>>>>    
81440>>>>>>>>>>>    If (iRetval = 0) Begin
81442>>>>>>>>>>>        Move 0 to pUUIDStr
81443>>>>>>>>>>>        
81443>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
81444>>>>>>>>>>>        If (iRetval = 0) Begin
81446>>>>>>>>>>>            Move pUUIDStr to sUUID
81447>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
81448>>>>>>>>>>> 
81448>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
81449>>>>>>>>>>>        End
81449>>>>>>>>>>>>
81449>>>>>>>>>>>    End
81449>>>>>>>>>>>>
81449>>>>>>>>>>>    
81449>>>>>>>>>>>    Move (Free(pUUID)) to iRetval 
81450>>>>>>>>>>>    
81450>>>>>>>>>>>    Function_Return sUUID
81451>>>>>>>>>>>End_Function
81452>>>>>>>>>Use cli.pkg
81452>>>>>>>>>Use sql.pkg
81452>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MSSqldrv.pkg)
81452>>>>>>>>>>>//*****************************************************************************
81452>>>>>>>>>>>//*** MSSQLDRV.PKG                                                          ***
81452>>>>>>>>>>>//***                                                                       ***
81452>>>>>>>>>>>//*** Author: Ben Weijers                                                   ***
81452>>>>>>>>>>>//***         Data Access Nederland                                         ***
81452>>>>>>>>>>>//***         29 June 1998                                                  ***
81452>>>>>>>>>>>//***                                                                       ***
81452>>>>>>>>>>>//***                                                                       ***
81452>>>>>>>>>>>//*** Purpose:                                                              ***
81452>>>>>>>>>>>//***   Package that declares MS SQL driver constants and functions.        ***
81452>>>>>>>>>>>//****                                                                      ***
81452>>>>>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
81452>>>>>>>>>>>//***   MS SQL Client specific code to a DataFlex application.              ***
81452>>>>>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
81452>>>>>>>>>>>//***             Changed EnumerateServers function to use the highest      ***
81452>>>>>>>>>>>//***             available SQL Server client driver.                       ***
81452>>>>>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
81452>>>>>>>>>>>//***             mssqldrv.pkg                                              ***
81452>>>>>>>>>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
81452>>>>>>>>>>>//***             Added constants for SQL Server specific native types      ***
81452>>>>>>>>>>>//***             ( var...(max) types, money types, datetime types)         ***
81452>>>>>>>>>>>//*****************************************************************************
81452>>>>>>>>>>>
81452>>>>>>>>>>>Use Cli.pkg
81452>>>>>>>>>>>Use SQL.pkg
81452>>>>>>>>>>>
81452>>>>>>>>>>>//*** Driver Indentification
81452>>>>>>>>>>>
81452>>>>>>>>>>>//*** Error number constants
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>// SQL Server spcific types. 
81452>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
81452>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
81452>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
81452>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
81452>>>>>>>>>>>
81452>>>>>>>>>>>// SQL Server spcific types. 
81452>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
81452>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
81452>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
81452>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
81452>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
81452>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
81452>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>//*****************************************************************************
81452>>>>>>>>>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
81452>>>>>>>>>>>//***                                                                       ***
81452>>>>>>>>>>>//***   Setup a constraint for a file.                                      ***
81452>>>>>>>>>>>//*****************************************************************************
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>
81452>>>>>>>>>>>Class cMSSQLHandler Is A cCLIHandler
81453>>>>>>>>>>>
81453>>>>>>>>>>>    Procedure Construct_Object
81455>>>>>>>>>>>        Forward Send Construct_Object
81457>>>>>>>>>>>
81457>>>>>>>>>>>        Set psDriverID To MSSQLDRV_ID
81458>>>>>>>>>>>    End_Procedure // Construct_Object
81459>>>>>>>>>>>
81459>>>>>>>>>>>
81459>>>>>>>>>>>
81459>>>>>>>>>>>    //***
81459>>>>>>>>>>>    //*** Function: ExtractList
81459>>>>>>>>>>>    //*** Purpose : Extract the list from the out connect string.
81459>>>>>>>>>>>    //***
81459>>>>>>>>>>>
81459>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
81461>>>>>>>>>>>        Local String  sItem
81461>>>>>>>>>>>        Local Integer iStart
81461>>>>>>>>>>>        Local Integer iEnd
81461>>>>>>>>>>>
81461>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object To hoStore
81464>>>>>>>>>>>
81464>>>>>>>>>>>        Send Delete_Data To hoStore
81465>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) To iStart
81466>>>>>>>>>>>        While (iStart > 0)
81470>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
81471>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
81474>>>>>>>>>>>            Else Begin
81475>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) To iStart
81476>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) To iEnd
81477>>>>>>>>>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
81480>>>>>>>>>>>
81480>>>>>>>>>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
81483>>>>>>>>>>>
81483>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 To iStart
81486>>>>>>>>>>>            End
81486>>>>>>>>>>>>
81486>>>>>>>>>>>        Loop
81487>>>>>>>>>>>>
81487>>>>>>>>>>>
81487>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
81488>>>>>>>>>>>    End_Procedure // ExtractList
81489>>>>>>>>>>>
81489>>>>>>>>>>>
81489>>>>>>>>>>>
81489>>>>>>>>>>>    //***
81489>>>>>>>>>>>    //*** Function: BrowseConnect
81489>>>>>>>>>>>    //*** Purpose : Call the driver's browse connect function
81489>>>>>>>>>>>    //***
81489>>>>>>>>>>>
81489>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
81491>>>>>>>>>>>        Local String  sDriver
81491>>>>>>>>>>>        Local String  sOutConnStr
81491>>>>>>>>>>>        Local Integer iArg
81491>>>>>>>>>>>        Local Integer iRetval
81491>>>>>>>>>>>
81491>>>>>>>>>>>        Get psDriverID To sDriver
81492>>>>>>>>>>>        If (sDriver <> "") Begin
81494>>>>>>>>>>>            Move (Repeat(" ", 8192)) To sOutConnStr
81495>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
81500>>>>>>>>>>>        End
81500>>>>>>>>>>>>
81500>>>>>>>>>>>
81500>>>>>>>>>>>        Function_Return sOutConnStr
81501>>>>>>>>>>>    End_Function// BrowseConnect
81502>>>>>>>>>>>
81502>>>>>>>>>>>
81502>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
81504>>>>>>>>>>>        Local String  sDriver
81504>>>>>>>>>>>        Local String  sOutConnStr
81504>>>>>>>>>>>        Local Integer iArg
81504>>>>>>>>>>>        Local Integer iRetval
81504>>>>>>>>>>>        
81504>>>>>>>>>>>        Move 1 to iArg // Browses only local
81505>>>>>>>>>>>
81505>>>>>>>>>>>        Get psDriverID to sDriver
81506>>>>>>>>>>>        If (sDriver <> "") Begin
81508>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
81509>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
81514>>>>>>>>>>>        End
81514>>>>>>>>>>>>
81514>>>>>>>>>>>
81514>>>>>>>>>>>        Function_Return sOutConnStr
81515>>>>>>>>>>>    End_Function// BrowseConnect
81516>>>>>>>>>>>
81516>>>>>>>>>>>
81516>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
81518>>>>>>>>>>>    
81518>>>>>>>>>>>        Local String  sCurrentDriver
81518>>>>>>>>>>>        Local Integer iNumberOfDrivers iDriver iCount
81518>>>>>>>>>>>    
81518>>>>>>>>>>>        Move 0 to iDriver
81519>>>>>>>>>>>    
81519>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
81522>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
81528>>>>>>>>>>>>
81528>>>>>>>>>>>    
81528>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
81531>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
81533>>>>>>>>>>>                Move iCount to iDriver
81534>>>>>>>>>>>            End
81534>>>>>>>>>>>>
81534>>>>>>>>>>>        Loop
81535>>>>>>>>>>>>
81535>>>>>>>>>>>    
81535>>>>>>>>>>>        Function_Return iDriver
81536>>>>>>>>>>>    
81536>>>>>>>>>>>    End_Function 
81537>>>>>>>>>>>
81537>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
81539>>>>>>>>>>>        
81539>>>>>>>>>>>        Local String  sServerList
81539>>>>>>>>>>>        Local Integer iNumServers
81539>>>>>>>>>>>        Local Integer iDriver
81539>>>>>>>>>>>        Local Integer iClientVersion
81539>>>>>>>>>>>        Local String  sDriver
81539>>>>>>>>>>>        
81539>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
81540>>>>>>>>>>>
81540>>>>>>>>>>>        If (iDriver) Begin
81542>>>>>>>>>>>                
81542>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
81545>>>>>>>>>>>            
81545>>>>>>>>>>>            Case Begin
81545>>>>>>>>>>>    
81545>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2016CLIENT)
81547>>>>>>>>>>>                    Move SQLSERVER2016DRVRSTR to sDriver
81548>>>>>>>>>>>                    Case Break
81549>>>>>>>>>>>    
81549>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2014CLIENT)
81552>>>>>>>>>>>                    Move SQLSERVER2014DRVRSTR to sDriver
81553>>>>>>>>>>>                    Case Break
81554>>>>>>>>>>>            
81554>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2012CLIENT)
81557>>>>>>>>>>>                    Move SQLSERVER2012DRVRSTR to sDriver
81558>>>>>>>>>>>                    Case Break
81559>>>>>>>>>>>    
81559>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2008CLIENT)
81562>>>>>>>>>>>                    Move SQLSERVER2008DRVRSTR to sDriver
81563>>>>>>>>>>>                    Case Break
81564>>>>>>>>>>>    
81564>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2005CLIENT)
81567>>>>>>>>>>>                    Move SQLSERVER2005DRVRSTR to sDriver
81568>>>>>>>>>>>                    Case Break
81569>>>>>>>>>>>            
81569>>>>>>>>>>>                Case (iClientVersion = SQLSERVER2000CLIENT)
81572>>>>>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81573>>>>>>>>>>>                    Case Break
81574>>>>>>>>>>>            
81574>>>>>>>>>>>                Case Else
81574>>>>>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81575>>>>>>>>>>>            
81575>>>>>>>>>>>            Case End
81575>>>>>>>>>>>    
81575>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
81576>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
81578>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
81579>>>>>>>>>>>            End
81579>>>>>>>>>>>>
81579>>>>>>>>>>>            Else Begin
81580>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
81581>>>>>>>>>>>            End
81581>>>>>>>>>>>>
81581>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
81582>>>>>>>>>>>        End
81582>>>>>>>>>>>>
81582>>>>>>>>>>>        
81582>>>>>>>>>>>        Function_Return iNumServers
81583>>>>>>>>>>>        
81583>>>>>>>>>>>    End_Function
81584>>>>>>>>>>>
81584>>>>>>>>>>>    //***
81584>>>>>>>>>>>    //*** Procedure: EnumerateServers
81584>>>>>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81584>>>>>>>>>>>    //***            This function will return all SQL Server instances on the network. 
81584>>>>>>>>>>>    //***            This may take a long time. 
81584>>>>>>>>>>>    //***            To enumerate only local SQL Server instances use EnumerateServersLocal 
81584>>>>>>>>>>>    Function EnumerateServers Returns Integer
81586>>>>>>>>>>>
81586>>>>>>>>>>>        Local Integer iNumServers
81586>>>>>>>>>>>        Local Integer iNetworkLocal
81586>>>>>>>>>>>        
81586>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
81587>>>>>>>>>>>        
81587>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81588>>>>>>>>>>>        
81588>>>>>>>>>>>        Function_Return iNumServers
81589>>>>>>>>>>>        
81589>>>>>>>>>>>    End_Function
81590>>>>>>>>>>>
81590>>>>>>>>>>>
81590>>>>>>>>>>>    //***
81590>>>>>>>>>>>    //*** Procedure: EnumerateServersLocal
81590>>>>>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81590>>>>>>>>>>>    //***            This function will return only return SQL Server instance on the local machine
81590>>>>>>>>>>>    //***            To enumerate all SQL Server instances in a network use EnumerateServers
81590>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
81592>>>>>>>>>>>
81592>>>>>>>>>>>        Local Integer iNumServers
81592>>>>>>>>>>>        Local Integer iNetworkLocal
81592>>>>>>>>>>>        
81592>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
81593>>>>>>>>>>>        
81593>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81594>>>>>>>>>>>        
81594>>>>>>>>>>>        Function_Return iNumServers
81595>>>>>>>>>>>        
81595>>>>>>>>>>>    End_Function
81596>>>>>>>>>>>
81596>>>>>>>>>>>    
81596>>>>>>>>>>>
81596>>>>>>>>>>>    //***
81596>>>>>>>>>>>    //*** Function: EnumerateDatabases
81596>>>>>>>>>>>    //*** Purpose : Enumerate database in a given server.
81596>>>>>>>>>>>    //***
81596>>>>>>>>>>>
81596>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
81598>>>>>>>>>>>        Local Integer hoSQL
81598>>>>>>>>>>>        Local String  sConnect
81598>>>>>>>>>>>        Local String  sDatabase
81598>>>>>>>>>>>        Local Integer hdbc
81598>>>>>>>>>>>        Local Integer hstmt
81598>>>>>>>>>>>        Local Integer iFetchResult
81598>>>>>>>>>>>
81598>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
81601>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" To sUser
81604>>>>>>>>>>>
81604>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
81607>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
81609>>>>>>>>>>>
81609>>>>>>>>>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
81611>>>>>>>>>>>            Move Current_Object To hoSQL
81612>>>>>>>>>>>        End_Object // oEnumDBSQLManager
81613>>>>>>>>>>>
81613>>>>>>>>>>>        If (hoSQL <> 0) Begin
81615>>>>>>>>>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
81616>>>>>>>>>>>            If (hdbc <> 0) Begin
81618>>>>>>>>>>>                Get SQLOpen Of hdbc To hstmt
81619>>>>>>>>>>>                If (hstmt <> 0) Begin
81621>>>>>>>>>>>                    //*** We could do a direct select on the sysdatabases table but we use
81621>>>>>>>>>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
81621>>>>>>>>>>>                    //*** approach in case meta data might change, the stored procedure will
81621>>>>>>>>>>>                    //*** stay the same.
81621>>>>>>>>>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
81622>>>>>>>>>>>                    Send SQLCall To hstmt
81623>>>>>>>>>>>                    Repeat
81623>>>>>>>>>>>>
81623>>>>>>>>>>>                        Get SQLFetch Of hstmt To iFetchResult
81624>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
81626>>>>>>>>>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
81627>>>>>>>>>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
81628>>>>>>>>>>>                        End
81628>>>>>>>>>>>>
81628>>>>>>>>>>>                    Until (iFetchResult = 0)
81630>>>>>>>>>>>
81630>>>>>>>>>>>                    Send SQLClose To hstmt
81631>>>>>>>>>>>                End
81631>>>>>>>>>>>>
81631>>>>>>>>>>>                Send SQLDisconnect To hdbc
81632>>>>>>>>>>>            End
81632>>>>>>>>>>>>
81632>>>>>>>>>>>        End
81632>>>>>>>>>>>>
81632>>>>>>>>>>>        Send Destroy_Object To hoSQL
81633>>>>>>>>>>>
81633>>>>>>>>>>>        Function_return (Item_Count(Current_Object))
81634>>>>>>>>>>>    End_Function // EnumerateDatabases
81635>>>>>>>>>>>
81635>>>>>>>>>>>
81635>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
81637>>>>>>>>>>>        
81637>>>>>>>>>>>        Local String  sSqlServerClientVersionName
81637>>>>>>>>>>>        
81637>>>>>>>>>>>            
81637>>>>>>>>>>>        Case Begin
81637>>>>>>>>>>>
81637>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
81639>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
81640>>>>>>>>>>>                Case Break
81641>>>>>>>>>>>
81641>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
81644>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
81645>>>>>>>>>>>                Case Break
81646>>>>>>>>>>>        
81646>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
81649>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
81650>>>>>>>>>>>                Case Break
81651>>>>>>>>>>>
81651>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
81654>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
81655>>>>>>>>>>>                Case Break
81656>>>>>>>>>>>
81656>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
81659>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
81660>>>>>>>>>>>                Case Break
81661>>>>>>>>>>>        
81661>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
81664>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
81665>>>>>>>>>>>                Case Break
81666>>>>>>>>>>>        
81666>>>>>>>>>>>            Case Else
81666>>>>>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
81667>>>>>>>>>>>        
81667>>>>>>>>>>>        Case End
81667>>>>>>>>>>>    
81667>>>>>>>>>>>        
81667>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
81668>>>>>>>>>>>        
81668>>>>>>>>>>>    End_Function
81669>>>>>>>>>>>
81669>>>>>>>>>>>
81669>>>>>>>>>>>End_Class // cMSSQLHandler
81670>>>>>>>>>>>
81670>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\db2_drv.pkg)
81670>>>>>>>>>>>//*****************************************************************************
81670>>>>>>>>>>>//*** DB2_DRV.PKG                                                           ***
81670>>>>>>>>>>>//***                                                                       ***
81670>>>>>>>>>>>//*** Author: Ben Weijers                                                   ***
81670>>>>>>>>>>>//***         Data Access Nederland                                         ***
81670>>>>>>>>>>>//***         30 July 1998                                                  ***
81670>>>>>>>>>>>//***                                                                       ***
81670>>>>>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
81670>>>>>>>>>>>//***                                                                       ***
81670>>>>>>>>>>>//*** Purpose:                                                              ***
81670>>>>>>>>>>>//***   Package that declares DB2 driver constants and functions.           ***
81670>>>>>>>>>>>//****                                                                      ***
81670>>>>>>>>>>>//***   This package can be used by developers who want to add DB2 driver   ***
81670>>>>>>>>>>>//***   specific code to a DataFlex application.                            ***
81670>>>>>>>>>>>//*****************************************************************************
81670>>>>>>>>>>>
81670>>>>>>>>>>>Use Cli.pkg
81670>>>>>>>>>>>
81670>>>>>>>>>>>//*** Driver attributes
81670>>>>>>>>>>>
81670>>>>>>>>>>>
81670>>>>>>>>>>>//*** Driver Indentification
81670>>>>>>>>>>>
81670>>>>>>>>>>>//*** Error number constants
81670>>>>>>>>>>>
81670>>>>>>>>>>>//*** Call driver function identifiers
81670>>>>>>>>>>>
81670>>>>>>>>>>>// DB2 specific data types
81670>>>>>>>>>>>Define SQL_CLOB           for   (-99)  
81670>>>>>>>>>>>Define SQL_BLOB           for   (-98)  
81670>>>>>>>>>>>Define SQL_XML            for   (-370) 
81670>>>>>>>>>>>// DB2 Graphic types are Unicode types
81670>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)  
81670>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)  
81670>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)  
81670>>>>>>>>>>>Define SQL_DBCLOB         for   (-350) 
81670>>>>>>>>>>>
81670>>>>>>>>>>>
81670>>>>>>>>>>>//*** Extra DB2 commands
81670>>>>>>>>>>>
81670>>>>>>>>>>>
81670>>>>>>>>>>>//*****************************************************************************
81670>>>>>>>>>>>//*** DB2_CheckTrigger <NewState>                                           ***
81670>>>>>>>>>>>//***                                                                       ***
81670>>>>>>>>>>>//*** This command will set the trigger check at open on or off.            ***
81670>>>>>>>>>>>//*****************************************************************************
81670>>>>>>>>>>>
81670>>>>>>>>>>>
81670>>>>>>>>>>>
81670>>>>>>>>>>>//*****************************************************************************
81670>>>>>>>>>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
81670>>>>>>>>>>>//***                                                                       ***
81670>>>>>>>>>>>//***   Setup a constraint for a file.                                      ***
81670>>>>>>>>>>>//*****************************************************************************
81670>>>>>>>>>>>
81670>>>>>>>>>>>
81670>>>>>>>>>>>
81670>>>>>>>>>>>Class cDB2Handler Is A cCLIHandler
81671>>>>>>>>>>>
81671>>>>>>>>>>>    Procedure Construct_Object
81673>>>>>>>>>>>        Forward Send Construct_Object
81675>>>>>>>>>>>
81675>>>>>>>>>>>        Set psDriverID To DB2_DRV_ID
81676>>>>>>>>>>>    End_Procedure // Construct_Object
81677>>>>>>>>>>>
81677>>>>>>>>>>>
81677>>>>>>>>>>>
81677>>>>>>>>>>>    //***
81677>>>>>>>>>>>    //*** Procedure: SeedDataSources
81677>>>>>>>>>>>    //*** Purpose  : Reset the datasource list to the beginning
81677>>>>>>>>>>>    //***
81677>>>>>>>>>>>
81677>>>>>>>>>>>    Procedure SeedDataSources
81679>>>>>>>>>>>        Local String  sDriver
81679>>>>>>>>>>>        Local String  sVoid
81679>>>>>>>>>>>        Local Integer iRetval
81679>>>>>>>>>>>
81679>>>>>>>>>>>        Get psDriverID To sDriver
81680>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
81687>>>>>>>>>>>    End_Procedure // SeedDataSources
81688>>>>>>>>>>>
81688>>>>>>>>>>>
81688>>>>>>>>>>>
81688>>>>>>>>>>>    //***
81688>>>>>>>>>>>    //*** Function: DataSources
81688>>>>>>>>>>>    //*** Purpose : Call the driver's data sources function
81688>>>>>>>>>>>    //***
81688>>>>>>>>>>>
81688>>>>>>>>>>>    Function DataSources Returns String
81690>>>>>>>>>>>        Local String  sDriver
81690>>>>>>>>>>>        Local String  sDataSource
81690>>>>>>>>>>>        Local String  sDescription
81690>>>>>>>>>>>        Local Integer iLength
81690>>>>>>>>>>>        Local Integer iRetval
81690>>>>>>>>>>>
81690>>>>>>>>>>>        Get psDriverID To sDriver
81691>>>>>>>>>>>        If (sDriver <> "") Begin
81693>>>>>>>>>>>            Move 8192 To iLength
81694>>>>>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81695>>>>>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
81696>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81701>>>>>>>>>>>        End
81701>>>>>>>>>>>>
81701>>>>>>>>>>>
81701>>>>>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81704>>>>>>>>>>>        Else ;            Function_Return ""
81706>>>>>>>>>>>    End_Function// DataSources
81707>>>>>>>>>>>
81707>>>>>>>>>>>End_Class // cODBCHandler
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\odbc_drv.pkg)
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBC_DRV.PKG                                                          ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Author: Ben Weijers                                                   ***
81708>>>>>>>>>>>//***         Data Access Nederland                                         ***
81708>>>>>>>>>>>//***         3 February 1998                                               ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Purpose:                                                              ***
81708>>>>>>>>>>>//***   Package that declares ODBC driver constants and functions.          ***
81708>>>>>>>>>>>//****                                                                      ***
81708>>>>>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
81708>>>>>>>>>>>//***   ODBC Client specific code to a DataFlex application.                ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>Use Cli.pkg
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*** Driver Indentification
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*** Error number constants
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*** Call driver function identifiers
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*** Extra ODBC commands
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBCManage                                                            ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Start the ODBC manager.                                               ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBCNumberOfDataSources To <NumDSN>                                   ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Returns the number of data sources.                                   ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBCDSNName <DSNNumber> To <DSNName>                                  ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Returns the name of the data source.                                  ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBCEnumerateTables <DSNName> To <TableNum>                           ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Builds internal table array and returns the number of tables in the   ***
81708>>>>>>>>>>>//*** DSN.                                                                  ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBCTableName <TableNum> To <TableName>                               ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Returns the name of the table.                                        ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBCSchemaName <TableNum> To <SchemaName>                             ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Returns the schema name of the table.                                 ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBCNumberOfFields <DSNName> <TableName> To <NumDSN>                  ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Returns the number of fields.                                         ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBCFieldName <FieldNumber> To <FieldName>                            ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//*** Returns the name of the field.                                  ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>//*** ODBC_SetConstraint <FileNum> <ConstraintText>                         ***
81708>>>>>>>>>>>//***                                                                       ***
81708>>>>>>>>>>>//***   Setup a constraint for a file.                                      ***
81708>>>>>>>>>>>//*****************************************************************************
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>
81708>>>>>>>>>>>Class cODBCHandler Is A cCLIHandler
81709>>>>>>>>>>>
81709>>>>>>>>>>>    Procedure Construct_Object
81711>>>>>>>>>>>        Forward Send Construct_Object
81713>>>>>>>>>>>
81713>>>>>>>>>>>        Set psDriverID To ODBC_DRV_ID
81714>>>>>>>>>>>    End_Procedure // Construct_Object
81715>>>>>>>>>>>
81715>>>>>>>>>>>
81715>>>>>>>>>>>
81715>>>>>>>>>>>    //***
81715>>>>>>>>>>>    //*** Procedure Set: DataSourceType
81715>>>>>>>>>>>    //*** Purpose      : Setup the type of data sources returned by the datasources function
81715>>>>>>>>>>>    //***
81715>>>>>>>>>>>
81715>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
81717>>>>>>>>>>>        Local String  sDriver
81717>>>>>>>>>>>        Local String  sVoid
81717>>>>>>>>>>>        Local Integer iRetval
81717>>>>>>>>>>>
81717>>>>>>>>>>>        Get psDriverID To sDriver
81718>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
81725>>>>>>>>>>>    End_Procedure // Set DataSourceType
81726>>>>>>>>>>>
81726>>>>>>>>>>>
81726>>>>>>>>>>>
81726>>>>>>>>>>>    //***
81726>>>>>>>>>>>    //*** Function: DataSources
81726>>>>>>>>>>>    //*** Purpose : Call the driver's data sources function
81726>>>>>>>>>>>    //***
81726>>>>>>>>>>>
81726>>>>>>>>>>>    Function DataSources Returns String
81728>>>>>>>>>>>        Local String  sDriver
81728>>>>>>>>>>>        Local String  sDataSource
81728>>>>>>>>>>>        Local String  sDescription
81728>>>>>>>>>>>        Local Integer iLength
81728>>>>>>>>>>>        Local Integer iRetval
81728>>>>>>>>>>>
81728>>>>>>>>>>>        Get psDriverID To sDriver
81729>>>>>>>>>>>        If (sDriver <> "") Begin
81731>>>>>>>>>>>            Move 8192 To iLength
81732>>>>>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81733>>>>>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
81734>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81739>>>>>>>>>>>        End
81739>>>>>>>>>>>>
81739>>>>>>>>>>>
81739>>>>>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81742>>>>>>>>>>>        Else ;            Function_Return ""
81744>>>>>>>>>>>    End_Function// DataSources
81745>>>>>>>>>>>
81745>>>>>>>>>>>End_Class // cODBCHandler
81746>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DFBTRDRV.PKG)
81746>>>>>>>>>>>//****************************************************************************
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// $File name  : DFBTRDRV.PKG
81746>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
81746>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
81746>>>>>>>>>>>//               specific functions in the DFBTRDRV.
81746>>>>>>>>>>>// $Author(s)  : Eddy Kleinjan
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
81746>>>>>>>>>>>// Created     : 01-07-97 @ 12:00:00
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Changed     : 04-04-2001.
81746>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Changed     : June 6, 2001
81746>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
81746>>>>>>>>>>>//
81746>>>>>>>>>>>//               Added DFBTR_DDF_OWNER command.
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Changed     : June 12, 2001
81746>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
81746>>>>>>>>>>>//
81746>>>>>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Changed     : August 4, 2004
81746>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
81746>>>>>>>>>>>//
81746>>>>>>>>>>>//               Added cDfbtrdrvHandler class.
81746>>>>>>>>>>>//               New functions in this class:
81746>>>>>>>>>>>//                  Function CKRevision Returns String
81746>>>>>>>>>>>//                  Function CkUsesUri Returns Integer
81746>>>>>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81746>>>>>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81746>>>>>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Changed     : September 30, 2005
81746>>>>>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
81746>>>>>>>>>>>//
81746>>>>>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
81746>>>>>>>>>>>//****************************************************************************
81746>>>>>>>>>>>Use Ui
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Driver Indentification
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//*** Driver attributes
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Call_Driver functions ID's
81746>>>>>>>>>>>//
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// DFBTRFN_SET_OWNER options
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to create all vars which may be needed
81746>>>>>>>>>>>// in other commands.
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to set the owner of a Btrieve file.
81746>>>>>>>>>>>// File must have been opened.
81746>>>>>>>>>>>// Filenumber needs to be passed.
81746>>>>>>>>>>>// To clear set the owner to "".
81746>>>>>>>>>>>// Examples:
81746>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
81746>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
81746>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
81746>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
81746>>>>>>>>>>>// To clear:
81746>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
81746>>>>>>>>>>>// options.
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to parse for Callback
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
81746>>>>>>>>>>>// File must have been opened.
81746>>>>>>>>>>>// Filenumber needs to be passed.
81746>>>>>>>>>>>// Examples:
81746>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
81746>>>>>>>>>>>// which will be tries when opening files.
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
81746>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
81746>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
81746>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to change the transaction type.
81746>>>>>>>>>>>// Valid types are:
81746>>>>>>>>>>>//     DFBTRTT_NONE
81746>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
81746>>>>>>>>>>>//     DFBTRTT_CONCURRENT
81746>>>>>>>>>>>//
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to get the current transaction type.
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to set explicit_locking
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to get explicit locking
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//
81746>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
81746>>>>>>>>>>>//
81746>>>>>>>>>>>
81746>>>>>>>>>>>//*****************************************************************************
81746>>>>>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
81746>>>>>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81746>>>>>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
81746>>>>>>>>>>>//*****************************************************************************
81746>>>>>>>>>>>
81746>>>>>>>>>>>Class cDFBtrDrvHandler Is An Array
81747>>>>>>>>>>>
81747>>>>>>>>>>>    Procedure Construct_Object Integer iImage
81749>>>>>>>>>>>        Forward Send Construct_object iImage
81751>>>>>>>>>>>
81751>>>>>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
81752>>>>>>>>>>>    End_Procedure // Construct_Object
81753>>>>>>>>>>>
81753>>>>>>>>>>>
81753>>>>>>>>>>>
81753>>>>>>>>>>>    //***
81753>>>>>>>>>>>    //*** Function: CKRevsion
81753>>>>>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
81753>>>>>>>>>>>    //***
81753>>>>>>>>>>>
81753>>>>>>>>>>>    Function CKRevision Returns String
81755>>>>>>>>>>>        Local String  sDriverID
81755>>>>>>>>>>>        Local String  sRevision
81755>>>>>>>>>>>        Local String  sVoid
81755>>>>>>>>>>>        Local Integer iRetval
81755>>>>>>>>>>>
81755>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81755>>>>>>>>>>>        // This error would otherwise be raised when we have an older
81755>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81755>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
81756>>>>>>>>>>>        Get psDriverID To sDriverID
81757>>>>>>>>>>>        Move (Repeat(" ", 255)) To sRevision
81758>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81763>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
81764>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
81766>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
81766>>>>>>>>>>>            Move "0.0.0.0" To sRevision
81767>>>>>>>>>>>        End
81767>>>>>>>>>>>>
81767>>>>>>>>>>>        Function_Return sRevision
81768>>>>>>>>>>>    End_Function // CKRevision
81769>>>>>>>>>>>
81769>>>>>>>>>>>    Function CkUsesUri Returns Integer
81771>>>>>>>>>>>        Local String  sDriverID
81771>>>>>>>>>>>        Local String  sVoid1
81771>>>>>>>>>>>        Local String  sVoid2
81771>>>>>>>>>>>        Local Integer iRetval
81771>>>>>>>>>>>
81771>>>>>>>>>>>        Get psDriverID To sDriverID
81772>>>>>>>>>>>
81772>>>>>>>>>>>        Move 0 To iRetval
81773>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81773>>>>>>>>>>>        // This error would otherwise be raised when we have an older
81773>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
81773>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
81774>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
81779>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
81780>>>>>>>>>>>
81780>>>>>>>>>>>        Function_Return iRetval
81781>>>>>>>>>>>    End_Function // CKUsesUri
81782>>>>>>>>>>>
81782>>>>>>>>>>>
81782>>>>>>>>>>>
81782>>>>>>>>>>>    //***
81782>>>>>>>>>>>    //*** Function: ExtractPartFromRevsion
81782>>>>>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81782>>>>>>>>>>>    //***
81782>>>>>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81782>>>>>>>>>>>    //***
81782>>>>>>>>>>>
81782>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81784>>>>>>>>>>>        Local Integer iPartRev
81784>>>>>>>>>>>        Local Integer iCurrentPart
81784>>>>>>>>>>>        Local Integer iSeparatorPos
81784>>>>>>>>>>>
81784>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81787>>>>>>>>>>>
81787>>>>>>>>>>>        Move 0 To iCurrentPart
81788>>>>>>>>>>>        Repeat
81788>>>>>>>>>>>>
81788>>>>>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81789>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
81791>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81792>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81793>>>>>>>>>>>                Increment iCurrentPart
81794>>>>>>>>>>>            End
81794>>>>>>>>>>>>
81794>>>>>>>>>>>            Else If (sRevision <> "") Begin
81797>>>>>>>>>>>                Move sRevision To iPartRev
81798>>>>>>>>>>>                Move "" To sRevision
81799>>>>>>>>>>>                Increment iCurrentPart
81800>>>>>>>>>>>            End
81800>>>>>>>>>>>>
81800>>>>>>>>>>>            Else ;                Move -1 To iPartRev
81802>>>>>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81804>>>>>>>>>>>
81804>>>>>>>>>>>        Function_Return iPartRev
81805>>>>>>>>>>>    End_Function // EcxtractPartFromRevision
81806>>>>>>>>>>>
81806>>>>>>>>>>>
81806>>>>>>>>>>>
81806>>>>>>>>>>>    //***
81806>>>>>>>>>>>    //*** Function: CKMajorRevision
81806>>>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
81806>>>>>>>>>>>    //***
81806>>>>>>>>>>>
81806>>>>>>>>>>>    Function CKMajorRevision Returns Integer
81808>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81809>>>>>>>>>>>    End_Function // CKMajorRevision
81810>>>>>>>>>>>
81810>>>>>>>>>>>
81810>>>>>>>>>>>
81810>>>>>>>>>>>    //***
81810>>>>>>>>>>>    //*** Function: CKMinorRevision
81810>>>>>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81810>>>>>>>>>>>    //***
81810>>>>>>>>>>>
81810>>>>>>>>>>>    Function CKMinorRevision Returns Integer
81812>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81813>>>>>>>>>>>    End_Function // CKMinorRevision
81814>>>>>>>>>>>
81814>>>>>>>>>>>
81814>>>>>>>>>>>
81814>>>>>>>>>>>    //***
81814>>>>>>>>>>>    //*** Function: CKReleaseRevision
81814>>>>>>>>>>>    //*** Purpose : Returns the release revision of the CK
81814>>>>>>>>>>>    //***
81814>>>>>>>>>>>
81814>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
81816>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81817>>>>>>>>>>>    End_Function // CKReleaseRevision
81818>>>>>>>>>>>
81818>>>>>>>>>>>
81818>>>>>>>>>>>
81818>>>>>>>>>>>    //***
81818>>>>>>>>>>>    //*** Function: CKBuildRevision
81818>>>>>>>>>>>    //*** Purpose : Returns the major revision of the CK
81818>>>>>>>>>>>    //***
81818>>>>>>>>>>>
81818>>>>>>>>>>>    Function CKBuildRevision Returns Integer
81820>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81821>>>>>>>>>>>    End_Function // CKBuildRevision
81822>>>>>>>>>>>
81822>>>>>>>>>>>
81822>>>>>>>>>>>
81822>>>>>>>>>>>    //***
81822>>>>>>>>>>>    //*** Function: IsMinimalRevision
81822>>>>>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81822>>>>>>>>>>>    //***
81822>>>>>>>>>>>
81822>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81824>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81827>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81830>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81833>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81836>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81839>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81843>>>>>>>>>>>            End
81843>>>>>>>>>>>>
81843>>>>>>>>>>>        End
81843>>>>>>>>>>>>
81843>>>>>>>>>>>
81843>>>>>>>>>>>        Function_Return (FALSE)
81844>>>>>>>>>>>    End_Function // IsMinimalRevision
81845>>>>>>>>>>>
81845>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
81845>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
81845>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
81845>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
81845>>>>>>>>>>>    //
81845>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
81845>>>>>>>>>>>    //   in the following format:
81845>>>>>>>>>>>    //       <version>.<revision>.<type>
81845>>>>>>>>>>>    //   possible values for <type>:
81845>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
81845>>>>>>>>>>>    //         server using Workgroup authentication mode
81845>>>>>>>>>>>    //       C for client cache engine
81845>>>>>>>>>>>    //       D for DOS workstation
81845>>>>>>>>>>>    //       N for client Requester
81845>>>>>>>>>>>    //       S for NetWare server
81845>>>>>>>>>>>    //       T for 32-bit Windows server engine
81845>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
81845>>>>>>>>>>>    //
81845>>>>>>>>>>>    //   example:
81845>>>>>>>>>>>    //       8.50.T
81845>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
81845>>>>>>>>>>>    //   32-bits Windows server.
81845>>>>>>>>>>>    //
81845>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
81845>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
81845>>>>>>>>>>>    //
81845>>>>>>>>>>>    //   If the version information is not available or can not be obtained
81845>>>>>>>>>>>    //   the functions will return "0.0.0"
81845>>>>>>>>>>>
81845>>>>>>>>>>>
81845>>>>>>>>>>>    //***
81845>>>>>>>>>>>    //*** Function: PSQLRequesterVersionInfo
81845>>>>>>>>>>>    //*** Purpose : Returns the version information of the
81845>>>>>>>>>>>    //***           Pervasive.SQL Client requester.
81845>>>>>>>>>>>
81845>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81847>>>>>>>>>>>
81847>>>>>>>>>>>        Local String  sDriverID
81847>>>>>>>>>>>        Local String  sVersion
81847>>>>>>>>>>>        Local String  sVoid
81847>>>>>>>>>>>        Local Integer iRetval
81847>>>>>>>>>>>
81847>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81847>>>>>>>>>>>        // This error would otherwise be raised when we have an older
81847>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81847>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
81848>>>>>>>>>>>        Get psDriverID To sDriverID
81849>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81850>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81855>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
81856>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
81858>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
81858>>>>>>>>>>>            Move "0.0.0" To sVersion
81859>>>>>>>>>>>        End
81859>>>>>>>>>>>>
81859>>>>>>>>>>>        Function_Return sVersion
81860>>>>>>>>>>>    End_Function //  PSQLRequesterVersion
81861>>>>>>>>>>>
81861>>>>>>>>>>>    //***
81861>>>>>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
81861>>>>>>>>>>>    //*** Purpose : Returns the version information of the
81861>>>>>>>>>>>    //***           Pervasive.SQL Local Engine
81861>>>>>>>>>>>
81861>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81863>>>>>>>>>>>
81863>>>>>>>>>>>        Local String  sDriverID
81863>>>>>>>>>>>        Local String  sVersion
81863>>>>>>>>>>>        Local String  sVoid
81863>>>>>>>>>>>        Local Integer iRetval
81863>>>>>>>>>>>
81863>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81863>>>>>>>>>>>        // This error would otherwise be raised when we have an older
81863>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81863>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
81864>>>>>>>>>>>        Get psDriverID To sDriverID
81865>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81866>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81871>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
81872>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
81874>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
81874>>>>>>>>>>>            Move "0.0.0" To sVersion
81875>>>>>>>>>>>        End
81875>>>>>>>>>>>>
81875>>>>>>>>>>>        Function_Return sVersion
81876>>>>>>>>>>>    End_Function //  PSQLLocalEngineVersion
81877>>>>>>>>>>>
81877>>>>>>>>>>>    //***
81877>>>>>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
81877>>>>>>>>>>>    //*** Purpose : Returns the version information of the
81877>>>>>>>>>>>    //***           Pervasive.SQL Server Engine
81877>>>>>>>>>>>
81877>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81879>>>>>>>>>>>
81879>>>>>>>>>>>        Local String  sDriverID
81879>>>>>>>>>>>        Local String  sVersion
81879>>>>>>>>>>>        Local String  sVoid
81879>>>>>>>>>>>        Local Integer iRetval
81879>>>>>>>>>>>
81879>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81879>>>>>>>>>>>        // This error would otherwise be raised when we have an older
81879>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81879>>>>>>>>>>>        Send Ignore_error To Error_object_Id 20491
81880>>>>>>>>>>>        Get psDriverID To sDriverID
81881>>>>>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81882>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81887>>>>>>>>>>>        Send Trap_Error To Error_object_Id 20491
81888>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
81890>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
81890>>>>>>>>>>>            Move "0.0.0" To sVersion
81891>>>>>>>>>>>        End
81891>>>>>>>>>>>>
81891>>>>>>>>>>>        Function_Return sVersion
81892>>>>>>>>>>>    End_Function //  PSQLServerEngineVersion
81893>>>>>>>>>>>
81893>>>>>>>>>>>End_Class // cDfbtrdrvHandler
81894>>>>>>>>>>>
81894>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
81894>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
81894>>>>>>>>>>>//****************************************************************************
81894>>>>>>>>>>>// $Module type: Include file
81894>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
81894>>>>>>>>>>>//
81894>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
81894>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
81894>>>>>>>>>>>// E-mail      : support@rdctools.com
81894>>>>>>>>>>>// Web-site    : http://www.rdctools.com
81894>>>>>>>>>>>//
81894>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
81894>>>>>>>>>>>//
81894>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
81894>>>>>>>>>>>//
81894>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
81894>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
81894>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
81894>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
81894>>>>>>>>>>>// in the help folder for more details.
81894>>>>>>>>>>>//
81894>>>>>>>>>>>Use Winkern.pkg
81894>>>>>>>>>>>Use cIniFile.pkg
81894>>>>>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCryptographer.pkg)
81894>>>>>>>>>>>>>Use VdfBase.pkg
81894>>>>>>>>>>>>>
81894>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\CryptographerConstants.pkg)
81894>>>>>>>>>>>>>>>//                                      
81894>>>>>>>>>>>>>>>// File    : CryptographerConstants.pkg
81894>>>>>>>>>>>>>>>//
81894>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
81894>>>>>>>>>>>>>>>//             Data Access Worldwide
81894>>>>>>>>>>>>>>>//
81894>>>>>>>>>>>>>>>//   Date    : October 4, 2009
81894>>>>>>>>>>>>>>>//
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Algorithm classes
81894>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
81894>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
81894>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
81894>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
81894>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
81894>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
81894>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Algorithm types
81894>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
81894>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
81894>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
81894>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
81894>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
81894>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
81894>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Generic sub-ids
81894>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// RSA sub-ids
81894>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
81894>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
81894>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
81894>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
81894>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// DSS sub-ids
81894>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
81894>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
81894>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// DES sub_ids
81894>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
81894>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
81894>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
81894>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
81894>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
81894>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
81894>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
81894>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
81894>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
81894>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
81894>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
81894>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
81894>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
81894>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Fortezza sub-ids
81894>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
81894>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// RC2 sub-ids
81894>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Stream cipher sub-ids
81894>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
81894>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
81894>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
81894>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
81894>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
81894>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Hash sub ids
81894>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
81894>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
81894>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
81894>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
81894>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
81894>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
81894>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
81894>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
81894>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
81894>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
81894>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
81894>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
81894>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
81894>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
81894>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// secure channel sub ids
81894>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
81894>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
81894>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
81894>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
81894>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
81894>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
81894>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// algorithm identifier definitions
81894>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
81894>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
81894>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
81894>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
81894>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
81894>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
81894>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81894>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
81894>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
81894>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81894>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
81894>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
81894>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
81894>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
81894>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
81894>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
81894>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
81894>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
81894>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
81894>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
81894>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
81894>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
81894>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
81894>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
81894>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
81894>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
81894>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
81894>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
81894>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
81894>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
81894>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
81894>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
81894>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
81894>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
81894>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
81894>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
81894>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
81894>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
81894>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
81894>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
81894>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
81894>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
81894>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
81894>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Providers
81894>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
81894>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
81894>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
81894>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
81894>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
81894>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
81894>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
81894>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
81894>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
81894>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
81894>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
81894>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
81894>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
81894>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
81894>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
81894>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
81894>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
81894>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
81894>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
81894>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
81894>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
81894>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
81894>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
81894>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
81894>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
81894>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
81894>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
81894>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
81894>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
81894>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
81894>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
81894>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// Provider types
81894>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
81894>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
81894>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
81894>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
81894>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
81894>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
81894>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
81894>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
81894>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
81894>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
81894>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
81894>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
81894>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
81894>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
81894>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
81894>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
81894>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
81894>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// KP_MODE
81894>>>>>>>>>>>>>>>// KP_MODE
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
81894>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
81894>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
81894>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
81894>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
81894>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
81894>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
81894>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
81894>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
81894>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
81894>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
81894>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
81894>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
81894>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
81894>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
81894>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
81894>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
81894>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
81894>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
81894>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
81894>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
81894>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
81894>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
81894>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
81894>>>>>>>>>>>>>>>Define KP_RP                            for 23
81894>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
81894>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
81894>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
81894>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
81894>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
81894>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
81894>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
81894>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
81894>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
81894>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
81894>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
81894>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
81894>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
81894>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
81894>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
81894>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
81894>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
81894>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
81894>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
81894>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
81894>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
81894>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
81894>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>// key BLOB types
81894>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
81894>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
81894>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
81894>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
81894>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
81894>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
81894>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
81894>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>//  Structure cryptimportkey
81894>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
81894>>>>>>>>>>>>>>>    UChar    bType
81894>>>>>>>>>>>>>>>    UChar    bVersion
81894>>>>>>>>>>>>>>>    UShort   reserved
81894>>>>>>>>>>>>>>>    UInteger aiKeyAlg
81894>>>>>>>>>>>>>>>End_Struct
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
81894>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81894>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81894>>>>>>>>>>>>>>>    UInteger       dwKeySize
81894>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
81894>>>>>>>>>>>>>>>End_Struct
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
81894>>>>>>>>>>>>>>>Struct HMAC_INFO
81894>>>>>>>>>>>>>>>    UInteger HashAlgid
81894>>>>>>>>>>>>>>>    Pointer pbInnerString
81894>>>>>>>>>>>>>>>    DWord cbInnerString
81894>>>>>>>>>>>>>>>    Pointer pbOuterString
81894>>>>>>>>>>>>>>>    DWord cbOuterString
81894>>>>>>>>>>>>>>>End_Struct
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>
81894>>>>>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
81895>>>>>>>>>>>>>>>
81895>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
81896>>>>>>>>>>>>>>>
81896>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
81897>>>>>>>>>>>>>>>
81897>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
81898>>>>>>>>>>>>>>>
81898>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
81899>>>>>>>>>>>>>>>
81899>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81900>>>>>>>>>>>>>>>
81900>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
81901>>>>>>>>>>>>>>>
81901>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
81902>>>>>>>>>>>>>>>
81902>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81903>>>>>>>>>>>>>>>
81903>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
81904>>>>>>>>>>>>>>>    
81904>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
81905>>>>>>>>>>>>>>>
81905>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
81906>>>>>>>>>>>>>>>
81906>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
81907>>>>>>>>>>>>>>>
81907>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
81908>>>>>>>>>>>>>>>    
81908>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
81909>>>>>>>>>>>>>>>    
81909>>>>>>>>>>>>>
81909>>>>>>>>>>>>>Class cCryptographer is a cObject
81910>>>>>>>>>>>>>    
81910>>>>>>>>>>>>>    // Procedure : Construct_Object
81910>>>>>>>>>>>>>    // Purpose   : Object constructor
81910>>>>>>>>>>>>>    Procedure Construct_Object
81912>>>>>>>>>>>>>        Forward Send Construct_Object
81914>>>>>>>>>>>>>
81914>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
81915>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
81916>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
81917>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
81918>>>>>>>>>>>>>        
81918>>>>>>>>>>>>>        // Private properties
81918>>>>>>>>>>>>>        Property Handle     Private_phProv
81919>>>>>>>>>>>>>    End_Procedure
81920>>>>>>>>>>>>>    
81920>>>>>>>>>>>>>    
81920>>>>>>>>>>>>>    // Function : AcquireContext
81920>>>>>>>>>>>>>    // Purpose  : Acquire key container handle
81920>>>>>>>>>>>>>    Function AcquireContext Returns Handle
81922>>>>>>>>>>>>>        Integer iProvider
81922>>>>>>>>>>>>>        String sProvider
81922>>>>>>>>>>>>>        Handle hProv
81922>>>>>>>>>>>>>        Boolean bOk
81922>>>>>>>>>>>>>        Address addrProv
81922>>>>>>>>>>>>>        
81922>>>>>>>>>>>>>        Move 0 to hProv
81923>>>>>>>>>>>>>        Get piProvider to iProvider
81924>>>>>>>>>>>>>        Get psProvider to sProvider
81925>>>>>>>>>>>>>        
81925>>>>>>>>>>>>>        //  Determine address to be passed as provider
81925>>>>>>>>>>>>>        If (Trim(sProvider) <> "") Begin
81927>>>>>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
81928>>>>>>>>>>>>>        End
81928>>>>>>>>>>>>>>
81928>>>>>>>>>>>>>        Else Begin
81929>>>>>>>>>>>>>            Move 0 to addrProv
81930>>>>>>>>>>>>>        End
81930>>>>>>>>>>>>>>
81930>>>>>>>>>>>>>        
81930>>>>>>>>>>>>>        //  Acquire Crypto Context
81930>>>>>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
81931>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81933>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
81934>>>>>>>>>>>>>        End
81934>>>>>>>>>>>>>>
81934>>>>>>>>>>>>>        
81934>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81936>>>>>>>>>>>>>            // Fallback to original
81936>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
81937>>>>>>>>>>>>>            
81937>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
81939>>>>>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
81940>>>>>>>>>>>>>            End
81940>>>>>>>>>>>>>>
81940>>>>>>>>>>>>>        End
81940>>>>>>>>>>>>>>
81940>>>>>>>>>>>>>        Set Private_phProv to hProv
81941>>>>>>>>>>>>>        
81941>>>>>>>>>>>>>        Function_Return hProv
81942>>>>>>>>>>>>>    End_Function
81943>>>>>>>>>>>>>    
81943>>>>>>>>>>>>>    // Function : ReleaseContext
81943>>>>>>>>>>>>>    // Purpose  : Releases key container handle
81943>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
81945>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
81946>>>>>>>>>>>>>    End_Function
81947>>>>>>>>>>>>>    
81947>>>>>>>>>>>>>    // Function : CreateHash
81947>>>>>>>>>>>>>    // Purpose  : Creates hash object
81947>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
81949>>>>>>>>>>>>>        Integer iAlgorithm
81949>>>>>>>>>>>>>        Handle hHash
81949>>>>>>>>>>>>>        Boolean bOk
81949>>>>>>>>>>>>>        
81949>>>>>>>>>>>>>        Move 0 to hHash
81950>>>>>>>>>>>>>        Get piHash to iAlgorithm
81951>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
81952>>>>>>>>>>>>>        
81952>>>>>>>>>>>>>        Function_Return hHash
81953>>>>>>>>>>>>>    End_Function
81954>>>>>>>>>>>>>    
81954>>>>>>>>>>>>>    // Function : DestroyHash
81954>>>>>>>>>>>>>    // Purpose  : Destroys the hash object
81954>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
81956>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
81957>>>>>>>>>>>>>    End_Function
81958>>>>>>>>>>>>>    
81958>>>>>>>>>>>>>    // Function : HashData
81958>>>>>>>>>>>>>    // Purpose  : Adds data to hash object
81958>>>>>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
81960>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
81961>>>>>>>>>>>>>    End_Function
81962>>>>>>>>>>>>>    
81962>>>>>>>>>>>>>    // Function : DeriveKey
81962>>>>>>>>>>>>>    // Purpose  : Generates session key
81962>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
81964>>>>>>>>>>>>>        Integer iAlgorithm
81964>>>>>>>>>>>>>        Handle hKey
81964>>>>>>>>>>>>>        Boolean bOk
81964>>>>>>>>>>>>>        
81964>>>>>>>>>>>>>        Move 0 to hKey
81965>>>>>>>>>>>>>        Get piCipher to iAlgorithm
81966>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
81967>>>>>>>>>>>>>        
81967>>>>>>>>>>>>>        Function_Return hKey
81968>>>>>>>>>>>>>    End_Function
81969>>>>>>>>>>>>>    
81969>>>>>>>>>>>>>    // Function : ImportPlainTextKey
81969>>>>>>>>>>>>>    // Purpose  : Imports a plain text key
81969>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
81971>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81971>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81971>>>>>>>>>>>>>        Boolean   bSuccess
81971>>>>>>>>>>>>>        Handle    hKey
81971>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
81971>>>>>>>>>>>>>        UChar[]   ucaKeyblob
81972>>>>>>>>>>>>>        Integer iVoid
81972>>>>>>>>>>>>>    
81972>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
81973>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
81974>>>>>>>>>>>>>    
81974>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
81975>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
81976>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
81977>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
81978>>>>>>>>>>>>>    
81978>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
81979>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
81980>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
81981>>>>>>>>>>>>>    
81981>>>>>>>>>>>>>        Move 0 to hKey
81982>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
81983>>>>>>>>>>>>>        If (not(bSuccess)) Begin 
81985>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
81986>>>>>>>>>>>>>        End
81986>>>>>>>>>>>>>>
81986>>>>>>>>>>>>>    
81986>>>>>>>>>>>>>        Function_Return hKey
81987>>>>>>>>>>>>>    End_Function
81988>>>>>>>>>>>>>
81988>>>>>>>>>>>>>    // Function : DestroyKey
81988>>>>>>>>>>>>>    // Purpose  : Destroys the key
81988>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
81990>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
81991>>>>>>>>>>>>>    End_Function
81992>>>>>>>>>>>>>    
81992>>>>>>>>>>>>>    // Function : KeyParameter
81992>>>>>>>>>>>>>    // Purpose  : Retrieves key data
81992>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
81994>>>>>>>>>>>>>        Integer iBuffer iLen
81994>>>>>>>>>>>>>        Boolean bOk
81994>>>>>>>>>>>>>        
81994>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
81995>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
81996>>>>>>>>>>>>>        Function_Return iBuffer
81997>>>>>>>>>>>>>    End_Function
81998>>>>>>>>>>>>>    
81998>>>>>>>>>>>>>    // Function : HashValue
81998>>>>>>>>>>>>>    // Purpose  : Retrieves a hash value
81998>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns String
82000>>>>>>>>>>>>>        Pointer lpSize
82000>>>>>>>>>>>>>        Pointer lpHash
82000>>>>>>>>>>>>>        String  lsSize
82000>>>>>>>>>>>>>        String  lsHash
82000>>>>>>>>>>>>>        Integer liResult
82000>>>>>>>>>>>>>
82000>>>>>>>>>>>>>        Move (Repeat(Character(0),4)) to lsSize
82001>>>>>>>>>>>>>        GetAddress of lsSize to lpSize
82002>>>>>>>>>>>>>
82002>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,lpSize,0)) to liResult
82003>>>>>>>>>>>>>        If (liResult = 0) Function_Return ""
82006>>>>>>>>>>>>>
82006>>>>>>>>>>>>>        Move (Repeat(Character(0),BytesTodWord(lsSize,1))) to lsHash
82007>>>>>>>>>>>>>        GetAddress of lsHash to lpHash
82008>>>>>>>>>>>>>
82008>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,lpHash,lpSize,0)) to liResult
82009>>>>>>>>>>>>>        If (liResult = 0) Function_Return ""
82012>>>>>>>>>>>>>
82012>>>>>>>>>>>>>        Function_Return lsHash
82013>>>>>>>>>>>>>    End_Function  // HashValue
82014>>>>>>>>>>>>>    
82014>>>>>>>>>>>>>            
82014>>>>>>>>>>>>>    // Function : Encrypt
82014>>>>>>>>>>>>>    // Purpose  : Encrypts data
82014>>>>>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
82016>>>>>>>>>>>>>        Handle hProv hHash hKey
82016>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
82016>>>>>>>>>>>>>        Boolean bOk
82016>>>>>>>>>>>>>        
82016>>>>>>>>>>>>>        Get AcquireContext to hProv
82017>>>>>>>>>>>>>        If (hProv) Begin
82019>>>>>>>>>>>>>            Get CreateHash hProv to hHash
82020>>>>>>>>>>>>>            If (hHash) Begin
82022>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
82023>>>>>>>>>>>>>                If (bOk) Begin
82025>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
82026>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
82027>>>>>>>>>>>>>                End // If (bOk) Begin            
82027>>>>>>>>>>>>>>
82027>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
82028>>>>>>>>>>>>>            End // If (hHash) Begin
82028>>>>>>>>>>>>>>
82028>>>>>>>>>>>>>            
82028>>>>>>>>>>>>>            If (hKey) Begin
82030>>>>>>>>>>>>>                //  First call to determine resulting data size
82030>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
82031>>>>>>>>>>>>>                Move (Length(sData)) to iCipherLen
82032>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
82033>>>>>>>>>>>>>                
82033>>>>>>>>>>>>>                //  Reserve space in string
82033>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
82035>>>>>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
82036>>>>>>>>>>>>>                End
82036>>>>>>>>>>>>>>
82036>>>>>>>>>>>>>                
82036>>>>>>>>>>>>>                //  Call to really decrypt
82036>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
82037>>>>>>>>>>>>>                //If (not(bOk)) Begin
82037>>>>>>>>>>>>>                    //Move "" to sData
82037>>>>>>>>>>>>>                    //Move (GetLastError()) to iErr
82037>>>>>>>>>>>>>                //End
82037>>>>>>>>>>>>>                
82037>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
82038>>>>>>>>>>>>>            End // If (hKey) Begin
82038>>>>>>>>>>>>>>
82038>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
82039>>>>>>>>>>>>>        End // If (hProv) Begin
82039>>>>>>>>>>>>>>
82039>>>>>>>>>>>>>        Function_Return sData
82040>>>>>>>>>>>>>    End_Function
82041>>>>>>>>>>>>>    
82041>>>>>>>>>>>>>    // Function : Decrypt
82041>>>>>>>>>>>>>    // Purpose  : Decrypts data
82041>>>>>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
82043>>>>>>>>>>>>>        Handle hProv hHash hKey
82043>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
82043>>>>>>>>>>>>>        Boolean bOk
82043>>>>>>>>>>>>>        
82043>>>>>>>>>>>>>        Get AcquireContext to hProv
82044>>>>>>>>>>>>>        If (hProv) Begin
82046>>>>>>>>>>>>>            Get CreateHash hProv to hHash
82047>>>>>>>>>>>>>            If (hHash) Begin
82049>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
82050>>>>>>>>>>>>>                If (bOk) Begin
82052>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
82053>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
82054>>>>>>>>>>>>>                End // If (bOk) Begin            
82054>>>>>>>>>>>>>>
82054>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
82055>>>>>>>>>>>>>            End // If (hHash) Begin
82055>>>>>>>>>>>>>>
82055>>>>>>>>>>>>>            
82055>>>>>>>>>>>>>            If (hKey) Begin
82057>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
82058>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
82059>>>>>>>>>>>>>                //If (bOk = False) Move "" to sData
82059>>>>>>>>>>>>>                
82059>>>>>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
82059>>>>>>>>>>>>>                If (Length(sData) > iDataLen) Begin
82061>>>>>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
82062>>>>>>>>>>>>>                End
82062>>>>>>>>>>>>>>
82062>>>>>>>>>>>>>                
82062>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
82063>>>>>>>>>>>>>            End // If (hKey) Begin
82063>>>>>>>>>>>>>>
82063>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
82064>>>>>>>>>>>>>        End // If (hProv) Begin
82064>>>>>>>>>>>>>>
82064>>>>>>>>>>>>>        Function_Return sData
82065>>>>>>>>>>>>>    End_Function
82066>>>>>>>>>>>>>    
82066>>>>>>>>>>>>>    //  Function : GenerateRandom
82066>>>>>>>>>>>>>    //  Purpose  : Generates random data.
82066>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
82068>>>>>>>>>>>>>        Handle hProv
82068>>>>>>>>>>>>>        UChar[] uaResult
82069>>>>>>>>>>>>>        Boolean bRes
82069>>>>>>>>>>>>>        
82069>>>>>>>>>>>>>        Get AcquireContext to hProv
82070>>>>>>>>>>>>>        
82070>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
82071>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
82072>>>>>>>>>>>>>        
82072>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
82073>>>>>>>>>>>>>        
82073>>>>>>>>>>>>>        Function_Return uaResult
82074>>>>>>>>>>>>>    End_Function
82075>>>>>>>>>>>>>    
82075>>>>>>>>>>>>>    //  Function : GenerateRandomString
82075>>>>>>>>>>>>>    //  Purpose  : Generates random data and does a base64 encoding to properly present it as a string.
82075>>>>>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
82077>>>>>>>>>>>>>        String sResult
82077>>>>>>>>>>>>>        UChar[] aData
82078>>>>>>>>>>>>>        Address pBase64
82078>>>>>>>>>>>>>        Integer iVoid
82078>>>>>>>>>>>>>
82078>>>>>>>>>>>>>        Get GenerateRandom iLenght to aData
82079>>>>>>>>>>>>>        
82079>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
82080>>>>>>>>>>>>>        Move pBase64 to sResult
82081>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid    
82082>>>>>>>>>>>>>        
82082>>>>>>>>>>>>>        Function_Return (Left(sResult, iLenght))
82083>>>>>>>>>>>>>    End_Function
82084>>>>>>>>>>>>>
82084>>>>>>>>>>>>>End_Class
82085>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Base64Functions.pkg)
82085>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
82085>>>>>>>>>>>>>//>
82085>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
82085>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
82085>>>>>>>>>>>>>//>
82085>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
82085>>>>>>>>>>>>>//> strings.
82085>>>>>>>>>>>>>//>
82085>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
82085>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
82085>>>>>>>>>>>>>//>
82085>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
82085>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
82085>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
82085>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
82085>>>>>>>>>>>>>
82085>>>>>>>>>>>>>Use VdfBase.pkg
82085>>>>>>>>>>>>>
82085>>>>>>>>>>>>>// Functions in vdfBase64.dll
82085>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
82086>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
82087>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
82088>>>>>>>>>>>>>
82088>>>>>>>>>>>>>// Structure
82088>>>>>>>>>>>>>Struct txxfBase64Buffer
82088>>>>>>>>>>>>>    Pointer pData
82088>>>>>>>>>>>>>    Integer iLength
82088>>>>>>>>>>>>>End_Struct
82088>>>>>>>>>>>>>
82088>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
82088>>>>>>>>>>>>>
82088>>>>>>>>>>>>>Object _oBase64Functions is a cObject
82090>>>>>>>>>>>>>    Move Self to oBase64Functions
82091>>>>>>>>>>>>>
82091>>>>>>>>>>>>>
82091>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
82094>>>>>>>>>>>>>        Address pBase64
82094>>>>>>>>>>>>>        String sResult
82094>>>>>>>>>>>>>        Integer iVoid
82094>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
82095>>>>>>>>>>>>>        Move pBase64 to sResult
82096>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
82097>>>>>>>>>>>>>        Function_Return sResult
82098>>>>>>>>>>>>>    End_Function
82099>>>>>>>>>>>>>
82099>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
82102>>>>>>>>>>>>>        Address pBinary
82102>>>>>>>>>>>>>        String sBinary
82102>>>>>>>>>>>>>        Integer iVoid iLen
82102>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
82103>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
82104>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
82105>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
82106>>>>>>>>>>>>>        Function_Return sBinary
82107>>>>>>>>>>>>>    End_Function
82108>>>>>>>>>>>>>
82108>>>>>>>>>>>>>End_Object
82109>>>>>>>>>>>Use MSSqldrv.pkg
82109>>>>>>>>>>>Use db2_drv.pkg
82109>>>>>>>>>>>Use odbc_drv.pkg
82109>>>>>>>>>>>Use vWin32fh.pkg
82109>>>>>>>>>>>
82109>>>>>>>>>>>Use DUFLanguageConstants.inc
82109>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MertechDUF.pkg)
82109>>>>>>>>>>>>>//
82109>>>>>>>>>>>>>// Use of Mertech drivers:
82109>>>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
82109>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
82109>>>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
82109>>>>>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
82109>>>>>>>>>>>>>// MySQL Data Types
82109>>>>>>>>>>>>>Define eMySQL_DECIMAL                               for 0
82109>>>>>>>>>>>>>Define eMySQL_TINY                                  for 1
82109>>>>>>>>>>>>>Define eMySQL_SHORT                                 for 2
82109>>>>>>>>>>>>>Define eMySQL_LONG                                  for 3
82109>>>>>>>>>>>>>Define eMySQL_FLOAT                                 for 4
82109>>>>>>>>>>>>>Define eMySQL_DOUBLE                                for 5
82109>>>>>>>>>>>>>Define eMySQL_NULL                                  for 6
82109>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
82109>>>>>>>>>>>>>Define eMySQL_LONGLONG                              for 8
82109>>>>>>>>>>>>>Define eMySQL_INT24                                 for 9
82109>>>>>>>>>>>>>Define eMySQL_DATE                                  for 10
82109>>>>>>>>>>>>>Define eMySQL_TIME                                  for 11
82109>>>>>>>>>>>>>Define eMySQL_DATETIME                              for 12
82109>>>>>>>>>>>>>Define eMySQL_YEAR                                  for 13
82109>>>>>>>>>>>>>Define eMySQL_NEWDATE                               for 14
82109>>>>>>>>>>>>>Define eMySQL_BIT                                   for 16
82109>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
82109>>>>>>>>>>>>>Define eMySQL_ENUM                                  for 247
82109>>>>>>>>>>>>>Define eMySQL_SET                                   for 248
82109>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
82109>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
82109>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
82109>>>>>>>>>>>>>Define eMySQL_BLOB                                  for 252
82109>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
82109>>>>>>>>>>>>>Define eMySQL_STRING                                for 254
82109>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
82109>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
82109>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
82109>>>>>>>>>>>>>Define eMySQL_TEXT                                  for -252
82109>>>>>>>>>>>>>
82109>>>>>>>>>>>>>// Oracle Data Types
82109>>>>>>>>>>>>>Define eOracle_VARCHAR2                             for   1
82109>>>>>>>>>>>>>Define eOracle_NUMBER                               for   2
82109>>>>>>>>>>>>>Define eOracle_INT                                  for   3
82109>>>>>>>>>>>>>Define eOracle_FLOAT                                for   4
82109>>>>>>>>>>>>>Define eOracle_STRING                               for   5
82109>>>>>>>>>>>>>Define eOracle_LONG                                 for   8
82109>>>>>>>>>>>>>Define eOracle_ROWID                                for  11
82109>>>>>>>>>>>>>Define eOracle_DATE                                 for  12
82109>>>>>>>>>>>>>Define eOracle_RAW                                  for  23
82109>>>>>>>>>>>>>Define eOracle_LONGRAW                              for  24
82109>>>>>>>>>>>>>Define eOracle_CHAR                                 for  96
82109>>>>>>>>>>>>>Define eOracle_MSLABEL                              for 106
82109>>>>>>>>>>>>>Define eOracle_CLOB                                 for 112
82109>>>>>>>>>>>>>Define eOracle_BLOB                                 for 113
82109>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
82109>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
82109>>>>>>>>>>>>>Define eOracle_INTERVALYM                           for 189
82109>>>>>>>>>>>>>Define eOracle_INTERVALDS                           for 190
82109>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
82109>>>>>>>>>>>>>Define eOracle_NCHAR                                for 286
82109>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
82109>>>>>>>>>>>>>Define eOracle_NCLOB                                for 288
82109>>>>>>>>>>>>>
82109>>>>>>>>>>>>>// PostgreSQL Data Types
82109>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
82109>>>>>>>>>>>>>Define ePgSQL_MONEY                                 for  790
82109>>>>>>>>>>>>>Define ePgSQL_BOOL                                  for   16
82109>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
82109>>>>>>>>>>>>>Define ePgSQL_CHAR                                  for   18
82109>>>>>>>>>>>>>Define ePgSQL_INT2                                  for   21
82109>>>>>>>>>>>>>Define ePgSQL_INT4                                  for   23
82109>>>>>>>>>>>>>Define ePgSQL_REGPROC                               for   24
82109>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
82109>>>>>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
82109>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
82109>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
82109>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
82109>>>>>>>>>>>>>Define ePgSQL_TEXT                                  for   25
82109>>>>>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
82109>>>>>>>>>>>>>Define ePgSQL_OID                                   for   26
82109>>>>>>>>>>>>>Define ePgSQL_TID                                   for   27
82109>>>>>>>>>>>>>Define ePgSQL_XID                                   for   28
82109>>>>>>>>>>>>>Define ePgSQL_CID                                   for   29
82109>>>>>>>>>>>>>Define ePgSQL_XML                                   for  142
82109>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
82109>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
82109>>>>>>>>>>>>>Define ePgSQL_INT8                                  for   20
82109>>>>>>>>>>>>>Define ePgSQL_PATH                                  for  602
82109>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
82109>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
82109>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
82109>>>>>>>>>>>>>Define ePgSQL_RELTIME                               for  703
82109>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
82109>>>>>>>>>>>>>Define ePgSQL_POINT                                 for  600
82109>>>>>>>>>>>>>Define ePgSQL_LINE                                  for  628
82109>>>>>>>>>>>>>Define ePgSQL_LSEG                                  for  601
82109>>>>>>>>>>>>>Define ePgSQL_BOX                                   for  603
82109>>>>>>>>>>>>>Define ePgSQL_POLYGON                               for  604
82109>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
82109>>>>>>>>>>>>>Define ePgSQL_MACADDR                               for  829
82109>>>>>>>>>>>>>Define ePgSQL_INET                                  for  869
82109>>>>>>>>>>>>>Define ePgSQL_CIDR                                  for  650
82109>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
82109>>>>>>>>>>>>>Define ePgSQL_DATE                                  for 1082
82109>>>>>>>>>>>>>Define ePgSQL_TIME                                  for 1083
82109>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
82109>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
82109>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
82109>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
82109>>>>>>>>>>>>>Define ePgSQL_BIT                                   for 1560
82109>>>>>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
82109>>>>>>>>>>>>>Define ePgSQL_UUID                                  for 2950
82109>>>>>>>>>>>>>
82109>>>>>>>>>>>>>// SQL Server Data Types
82109>>>>>>>>>>>>>Define eSQLServer_NA                                for    0
82109>>>>>>>>>>>>>Define eSQLServer_CHAR                              for    1
82109>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
82109>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
82109>>>>>>>>>>>>>Define eSQLServer_INT                               for    4
82109>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
82109>>>>>>>>>>>>>Define eSQLServer_FLOAT                             for    6
82109>>>>>>>>>>>>>Define eSQLServer_REAL                              for    7
82109>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
82109>>>>>>>>>>>>>Define eSQLServer_DATETIME                          for   11
82109>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
82109>>>>>>>>>>>>>Define eSQLServer_DATE                              for   40
82109>>>>>>>>>>>>>Define eSQLServer_TIME                              for   41
82109>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
82109>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
82109>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
82109>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
82109>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
82109>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
82109>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
82109>>>>>>>>>>>>>Define eSQLServer_TEXT                              for   -1
82109>>>>>>>>>>>>>Define eSQLServer_BINARY                            for   -2
82109>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
82109>>>>>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
82109>>>>>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
82109>>>>>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
82109>>>>>>>>>>>>>Define eSQLServer_BIT                               for   -7
82109>>>>>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
82109>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
82109>>>>>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
82109>>>>>>>>>>>>>Define eSQLServer_GUID                              for  -11
82109>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
82109>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
82109>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
82109>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
82109>>>>>>>>>>>>>Define eSQLServer_XML                               for -370
82109>>>>>>>>>>>>>
82109>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
82109>>>>>>>>>>>
82109>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
82109>>>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
82109>>>>>>>>>>>
82109>>>>>>>>>>>
82109>>>>>>>>>>>    Define SQLFLEX   for "SQL_DRV"
82109>>>>>>>>>>>
82109>>>>>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
82109>>>>>>>>>>>
82109>>>>>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
82109>>>>>>>>>>>
82109>>>>>>>>>>>    Define ORAFLEX   for "ORA_DRV"
82109>>>>>>>>>>>
82109>>>>>>>>>>>
82109>>>>>>>>>>>// SQLConnection.ini constants:
82109>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
82109>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
82109>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
82109>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
82109>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
82109>>>>>>>>>>>
82109>>>>>>>>>>>// DF 19 ini-file settings:
82109>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
82109>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
82109>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
82109>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
82109>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
82109>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
82109>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
82109>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
82109>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
82109>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection"
82109>>>>>>>>>>>
82109>>>>>>>>>>>// Database Update Framework extended settings:
82109>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
82109>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
82109>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
82109>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
82109>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
82109>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
82109>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
82109>>>>>>>>>>>
82109>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
82109>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
82109>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
82109>>>>>>>>>>>
82109>>>>>>>>>>>Struct tSQLConnection
82109>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
82109>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
82109>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
82109>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
82109>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
82109>>>>>>>>>>>    String sDatabase                // 6. SQL Database
82109>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
82109>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
82109>>>>>>>>>>>    String sUserID                  // 9. User ID
82109>>>>>>>>>>>    String sPassword                // 10. Password
82109>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
82109>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
82109>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
82109>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
82109>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
82109>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.    
82109>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
82109>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
82109>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
82109>>>>>>>>>>>End_Struct
82109>>>>>>>>>
82109>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
82110>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
82112>>>>>>>>>        Handle hoSQLManagerMT
82112>>>>>>>>>
82112>>>>>>>>>        // Error Reporting Related
82112>>>>>>>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
82112>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
82113>>>>>>>>>
82113>>>>>>>>>        Property String Private.psUseDatabase ""
82114>>>>>>>>>
82114>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
82115>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
82116>>>>>>>>>
82116>>>>>>>>>        Property Handle phoSQLManagerMT
82117>>>>>>>>>
82117>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
82118>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
82119>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
82120>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
82121>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
82122>>>>>>>>>
82122>>>>>>>>>        Property Boolean pbHandleQueryErrors True
82123>>>>>>>>>
82123>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
82124>>>>>>>>>        Property String[] paSQLFetchResults
82125>>>>>>>>>
82125>>>>>>>>>        // Error handling
82125>>>>>>>>>        Property Boolean pbSqlError False
82126>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
82127>>>>>>>>>        Property Boolean pbProcessingError False
82128>>>>>>>>>
82128>>>>>>>>>        // Statistics on query
82128>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
82129>>>>>>>>>        Property TimeSpan ptsQueryExec
82130>>>>>>>>>        Property TimeSpan ptsFetchResults
82131>>>>>>>>>        Property Integer piColumns 0
82132>>>>>>>>>        Property Integer piRows 0
82133>>>>>>>>>        Property Integer piRowType 0
82134>>>>>>>>>        Property String[] paQueryMessages
82135>>>>>>>>>        Property String psSQLStatementString
82136>>>>>>>>>
82136>>>>>>>>>        Property Integer[] piTableConvertExceptions
82137>>>>>>>>>
82137>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
82137>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
82137>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
82137>>>>>>>>>        Property Integer piChunkMax 500
82138>>>>>>>>>        
82138>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
82138>>>>>>>>>        Send SetupSQLKeywordArray
82139>>>>>>>>>    End_Procedure
82140>>>>>>>>>
82140>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
82140>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
82142>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
82144>>>>>>>>>            Function_Return (EQ)
82145>>>>>>>>>        End
82145>>>>>>>>>>
82145>>>>>>>>>        Function_Return (NE)
82146>>>>>>>>>    End_Function
82147>>>>>>>>>
82147>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
82147>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
82149>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) Begin
82151>>>>>>>>>            Function_Return (LT)
82152>>>>>>>>>        End
82152>>>>>>>>>>
82152>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) Begin
82154>>>>>>>>>            Function_Return (GT)
82155>>>>>>>>>        End
82155>>>>>>>>>>
82155>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) Begin
82157>>>>>>>>>            Function_Return (LT)
82158>>>>>>>>>        End
82158>>>>>>>>>>
82158>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) Begin
82160>>>>>>>>>            Function_Return (GT)
82161>>>>>>>>>        End
82161>>>>>>>>>>
82161>>>>>>>>>
82161>>>>>>>>>        Function_Return (EQ)
82162>>>>>>>>>    End_Function
82163>>>>>>>>>
82163>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
82165>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
82165>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
82166>>>>>>>>>        Integer iSize
82166>>>>>>>>>
82166>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82167>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
82168>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
82169>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
82170>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
82171>>>>>>>>>
82171>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
82172>>>>>>>>>    End_Procedure
82173>>>>>>>>>
82173>>>>>>>>>    // Creates a struct array with all SQL keywords
82173>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
82173>>>>>>>>>    // have slightly different wording.
82173>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
82173>>>>>>>>>    // needs to be done for every keyword group below.
82173>>>>>>>>>    Procedure SetupSQLKeywordArray
82175>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
82175>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
82177>>>>>>>>>
82177>>>>>>>>>        // This should only be called once; but in case it is
82177>>>>>>>>>        // we delete the array first.
82177>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
82178>>>>>>>>>
82178>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
82178>>>>>>>>>        //
82178>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
82179>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
82180>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
82181>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
82182>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
82183>>>>>>>>>
82183>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
82184>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
82185>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
82186>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
82187>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
82188>>>>>>>>>
82188>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
82189>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
82190>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
82191>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
82192>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
82193>>>>>>>>>
82193>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
82194>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
82195>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
82196>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
82197>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
82198>>>>>>>>>
82198>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
82199>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
82200>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
82201>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
82202>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
82203>>>>>>>>>
82203>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
82204>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
82205>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
82206>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
82207>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
82208>>>>>>>>>
82208>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
82209>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
82210>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
82211>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
82212>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
82213>>>>>>>>>
82213>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
82214>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
82215>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
82216>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
82217>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
82218>>>>>>>>>
82218>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
82219>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
82220>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
82221>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
82222>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
82223>>>>>>>>>
82223>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
82224>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
82225>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
82226>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
82227>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
82228>>>>>>>>>
82228>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_RENAME"
82229>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
82230>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
82231>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
82232>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
82233>>>>>>>>>
82233>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
82234>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
82235>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
82236>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
82237>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
82238>>>>>>>>>
82238>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
82239>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
82240>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
82241>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
82242>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
82243>>>>>>>>>
82243>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
82244>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
82245>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
82246>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
82247>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
82248>>>>>>>>>
82248>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
82249>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
82250>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
82251>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
82252>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
82253>>>>>>>>>
82253>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
82254>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
82255>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
82256>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
82257>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
82258>>>>>>>>>
82258>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
82259>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
82260>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
82261>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
82262>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
82263>>>>>>>>>
82263>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
82264>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
82265>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
82266>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
82267>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
82268>>>>>>>>>
82268>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
82269>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
82270>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
82271>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
82272>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
82273>>>>>>>>>
82273>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
82274>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
82275>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
82276>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
82277>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
82278>>>>>>>>>
82278>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
82279>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
82280>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
82281>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
82282>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
82283>>>>>>>>>
82283>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
82284>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
82285>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
82286>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
82287>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
82288>>>>>>>>>
82288>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
82289>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
82290>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
82291>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
82292>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
82293>>>>>>>>>
82293>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
82294>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
82295>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
82296>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
82297>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
82298>>>>>>>>>
82298>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
82299>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
82300>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
82301>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
82302>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
82303>>>>>>>>>
82303>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
82304>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
82305>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
82306>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
82307>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
82308>>>>>>>>>
82308>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
82309>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
82310>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
82311>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
82312>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
82313>>>>>>>>>
82313>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
82314>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
82315>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
82316>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
82317>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
82318>>>>>>>>>
82318>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
82319>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
82320>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
82321>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
82322>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
82323>>>>>>>>>
82323>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
82324>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
82325>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
82326>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
82327>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
82328>>>>>>>>>
82328>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
82329>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
82330>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
82331>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
82332>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
82333>>>>>>>>>
82333>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
82334>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
82335>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
82336>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
82337>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
82338>>>>>>>>>
82338>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
82339>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
82340>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
82341>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
82342>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
82343>>>>>>>>>
82343>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
82344>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
82345>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
82346>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
82347>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
82348>>>>>>>>>
82348>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
82349>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
82350>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
82351>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
82352>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
82353>>>>>>>>>
82353>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
82353>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82354>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
82355>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
82356>>>>>>>>>
82356>>>>>>>>>    End_Procedure
82357>>>>>>>>>
82357>>>>>>>>>End_Class
82358>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
82358>>>>>>>>>//****************************************************************************
82358>>>>>>>>>// $Module type: Class
82358>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
82358>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
82358>>>>>>>>>// Web-site    : http://www.rdctools.com
82358>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
82358>>>>>>>>>//
82358>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
82358>>>>>>>>>//
82358>>>>>>>>>// $Rev History:
82358>>>>>>>>>//    2015-08-11  Module header created
82358>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
82358>>>>>>>>>//                Added a new structure for passing connection data back & forth.
82358>>>>>>>>>//                Added better error handling.
82358>>>>>>>>>//                Added a decompose message for the connection string.
82358>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
82358>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
82358>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
82358>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
82358>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
82358>>>>>>>>>//****************************************************************************
82358>>>>>>>>>Use cli.pkg
82358>>>>>>>>>Use MSSqldrv.pkg
82358>>>>>>>>>Use db2_drv.pkg
82358>>>>>>>>>Use odbc_drv.pkg
82358>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
82358>>>>>>>>>>>//****************************************************************************
82358>>>>>>>>>>>// $Module type: Class
82358>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
82358>>>>>>>>>>>//
82358>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
82358>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
82358>>>>>>>>>>>// E-mail      : support@rdctools.com
82358>>>>>>>>>>>// Web-site    : http://www.rdctools.com
82358>>>>>>>>>>>//
82358>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
82358>>>>>>>>>>>//
82358>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
82358>>>>>>>>>>>//               properties of that object.
82358>>>>>>>>>>>//
82358>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
82358>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
82358>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
82358>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
82358>>>>>>>>>>>// in the help folder for more details.
82358>>>>>>>>>>>//
82358>>>>>>>>>>>Use cSQLConnectionIniFile.inc
82358>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
82358>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
82358>>>>>>>>>>>>>
82358>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
82359>>>>>>>>>>>>>    Procedure Construct_Object
82361>>>>>>>>>>>>>        Forward Send Construct_Object
82363>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
82364>>>>>>>>>>>>>    End_Procedure
82365>>>>>>>>>>>>>
82365>>>>>>>>>>>>>    Function ServerKeyword Returns String
82367>>>>>>>>>>>>>        Function_Return CS_SQLIniDSNKeyword
82368>>>>>>>>>>>>>    End_Function
82369>>>>>>>>>>>>>
82369>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82371>>>>>>>>>>>>>        String sConnect
82371>>>>>>>>>>>>>
82371>>>>>>>>>>>>>        Move (sConnect * ServerKeyword(Self) + "=" + sServer) to sConnect
82372>>>>>>>>>>>>>        If (sDatabase <> "") Begin
82374>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82375>>>>>>>>>>>>>        End
82375>>>>>>>>>>>>>>
82375>>>>>>>>>>>>>        If (bTrusted = True) Begin
82377>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82378>>>>>>>>>>>>>        End
82378>>>>>>>>>>>>>>
82378>>>>>>>>>>>>>        Else Begin
82379>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82380>>>>>>>>>>>>>        End
82380>>>>>>>>>>>>>>
82380>>>>>>>>>>>>>        Function_Return sConnect
82381>>>>>>>>>>>>>    End_Function
82382>>>>>>>>>>>>>
82382>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82384>>>>>>>>>>>>>        Boolean bLoginSuccessful
82384>>>>>>>>>>>>>        String sDriverID
82384>>>>>>>>>>>>>
82384>>>>>>>>>>>>>        Get psDriverID to sDriverID
82385>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
82387>>>>>>>>>>>>>            Function_Return True
82388>>>>>>>>>>>>>        End
82388>>>>>>>>>>>>>>
82388>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
82389>>>>>>>>>>>>>        If (bTrusted = False) Begin
82391>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82393>>>>>>>>>>>>>        End
82393>>>>>>>>>>>>>>
82393>>>>>>>>>>>>>        Else Begin
82394>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
82396>>>>>>>>>>>>>        End
82396>>>>>>>>>>>>>>
82396>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
82397>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82398>>>>>>>>>>>>>    End_Function
82399>>>>>>>>>>>>>End_Class
82400>>>>>>>>>>>>>
82400>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
82401>>>>>>>>>>>>>    Function ServerKeyword Returns String
82403>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
82404>>>>>>>>>>>>>    End_Function
82405>>>>>>>>>>>>>End_Class
82406>>>>>>>>>>>>>
82406>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
82407>>>>>>>>>>>>>End_Class
82408>>>>>>>>>>>>>
82408>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
82409>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82411>>>>>>>>>>>>>        Boolean bLoginSuccessful
82411>>>>>>>>>>>>>        String sDriverID
82411>>>>>>>>>>>>>
82411>>>>>>>>>>>>>        Move False to Err
82412>>>>>>>>>>>>>        Get psDriverID to sDriverID
82413>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains "DSN")) Begin
82415>>>>>>>>>>>>>            Move ("DSN=" + sServer) to sServer
82416>>>>>>>>>>>>>        End
82416>>>>>>>>>>>>>>
82416>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
82418>>>>>>>>>>>>>
82418>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82419>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82420>>>>>>>>>>>>>    End_Function
82421>>>>>>>>>>>>>End_Class
82422>>>>>>>>>>>>>
82422>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
82423>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82425>>>>>>>>>>>>>        Function_Return ""
82426>>>>>>>>>>>>>    End_Function
82427>>>>>>>>>>>>>End_Class
82428>>>>>>>>>>>>>
82428>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
82429>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82431>>>>>>>>>>>>>        Boolean bLoginSuccessful
82431>>>>>>>>>>>>>        String sDriverID
82431>>>>>>>>>>>>>
82431>>>>>>>>>>>>>        Get psDriverID to sDriverID
82432>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
82432>>>>>>>>>>>>>        Move False to Err
82433>>>>>>>>>>>>>        If (bTrusted = False) Begin
82435>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82437>>>>>>>>>>>>>        End
82437>>>>>>>>>>>>>>
82437>>>>>>>>>>>>>        Else Begin
82438>>>>>>>>>>>>>            Login sServer "" "" sDriverID
82440>>>>>>>>>>>>>        End
82440>>>>>>>>>>>>>>
82440>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82441>>>>>>>>>>>>>
82441>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82442>>>>>>>>>>>>>    End_Function
82443>>>>>>>>>>>>>End_Class
82444>>>>>>>>>>>>>
82444>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
82445>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82447>>>>>>>>>>>>>        Boolean bLoginSuccessful
82447>>>>>>>>>>>>>        String sDriverID sErrorMsg
82447>>>>>>>>>>>>>        String sVal
82447>>>>>>>>>>>>>        Integer iPos
82447>>>>>>>>>>>>>
82447>>>>>>>>>>>>>        Get psDriverID to sDriverID
82448>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
82449>>>>>>>>>>>>>        If (iPos = 0) Begin
82451>>>>>>>>>>>>>            If (sDatabase <> "") Begin
82453>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
82454>>>>>>>>>>>>>            End
82454>>>>>>>>>>>>>>
82454>>>>>>>>>>>>>        End
82454>>>>>>>>>>>>>>
82454>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82454>>>>>>>>>>>>>        Move False to Err
82455>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
82455>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
82457>>>>>>>>>>>>>
82457>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82458>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82459>>>>>>>>>>>>>    End_Function
82460>>>>>>>>>>>>>End_Class
82461>>>>>>>>>>>>>
82461>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
82462>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82464>>>>>>>>>>>>>        Boolean bLoginSuccessful
82464>>>>>>>>>>>>>        String sDriverID
82464>>>>>>>>>>>>>
82464>>>>>>>>>>>>>        Get psDriverID to sDriverID
82465>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82465>>>>>>>>>>>>>        Move False to Err
82466>>>>>>>>>>>>>        If (bTrusted = False) Begin
82468>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82470>>>>>>>>>>>>>        End
82470>>>>>>>>>>>>>>
82470>>>>>>>>>>>>>        Else Begin
82471>>>>>>>>>>>>>            Login sServer "" "" sDriverID
82473>>>>>>>>>>>>>        End
82473>>>>>>>>>>>>>>
82473>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82474>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82475>>>>>>>>>>>>>    End_Function
82476>>>>>>>>>>>>>End_Class
82477>>>>>>>>>>>>>
82477>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
82478>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82480>>>>>>>>>>>>>        Boolean bLoginSuccessful
82480>>>>>>>>>>>>>        String sDriverID
82480>>>>>>>>>>>>>
82480>>>>>>>>>>>>>        Get psDriverID to sDriverID
82481>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82481>>>>>>>>>>>>>        Move False to Err
82482>>>>>>>>>>>>>        If (bTrusted = False) Begin
82484>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82486>>>>>>>>>>>>>        End
82486>>>>>>>>>>>>>>
82486>>>>>>>>>>>>>        Else Begin
82487>>>>>>>>>>>>>            Login sServer "" "" sDriverID
82489>>>>>>>>>>>>>        End
82489>>>>>>>>>>>>>>
82489>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82490>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82491>>>>>>>>>>>>>    End_Function
82492>>>>>>>>>>>>>End_Class
82493>>>>>>>>>>>>>
82493>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
82494>>>>>>>>>>>>>    Procedure Construct_Object
82496>>>>>>>>>>>>>        Forward Send Construct_Object
82498>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
82499>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
82500>>>>>>>>>>>>>    End_Procedure
82501>>>>>>>>>>>>>
82501>>>>>>>>>>>>>    Function CreateDriver Returns Handle
82503>>>>>>>>>>>>>        String sDriverID
82503>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
82503>>>>>>>>>>>>>
82503>>>>>>>>>>>>>        Get psDriverID to sDriverID
82504>>>>>>>>>>>>>        Case Begin
82504>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82506>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
82507>>>>>>>>>>>>>                Case Break
82508>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
82511>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
82512>>>>>>>>>>>>>                Case Break
82513>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82516>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
82517>>>>>>>>>>>>>                Case Break
82518>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
82521>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
82522>>>>>>>>>>>>>                Case Break
82523>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
82526>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
82527>>>>>>>>>>>>>                Case Break
82528>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
82531>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
82532>>>>>>>>>>>>>                Case Break
82533>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
82536>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
82537>>>>>>>>>>>>>                Case Break
82538>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
82538>>>>>>>>>>>>>            Case Else  
82538>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
82539>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
82540>>>>>>>>>>>>>        Case End
82540>>>>>>>>>>>>>
82540>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
82541>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
82542>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
82543>>>>>>>>>>>>>
82543>>>>>>>>>>>>>        Function_Return hoDriver
82544>>>>>>>>>>>>>    End_Procedure
82545>>>>>>>>>>>>>
82545>>>>>>>>>>>>>    Procedure DestroyDriver
82547>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
82549>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
82550>>>>>>>>>>>>>        End
82550>>>>>>>>>>>>>>
82550>>>>>>>>>>>>>    End_Procedure
82551>>>>>>>>>>>>>
82551>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82553>>>>>>>>>>>>>        String sConnect
82553>>>>>>>>>>>>>        Handle hoDriver
82553>>>>>>>>>>>>>
82553>>>>>>>>>>>>>        Get CreateDriver to hoDriver
82554>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
82555>>>>>>>>>>>>>        Send DestroyDriver
82556>>>>>>>>>>>>>        Function_Return sConnect
82557>>>>>>>>>>>>>    End_Function
82558>>>>>>>>>>>>>
82558>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82560>>>>>>>>>>>>>        Boolean bLoginSuccessful
82560>>>>>>>>>>>>>        Handle hoDriver
82560>>>>>>>>>>>>>
82560>>>>>>>>>>>>>        Get CreateDriver to hoDriver
82561>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
82562>>>>>>>>>>>>>        Send DestroyDriver
82563>>>>>>>>>>>>>        Function_Return bLoginSuccessful
82564>>>>>>>>>>>>>    End_Function
82565>>>>>>>>>>>>>
82565>>>>>>>>>>>>>End_Class
82566>>>>>>>>>>>
82566>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
82567>>>>>>>>>>>    Procedure Construct_Object
82569>>>>>>>>>>>        Forward Send Construct_Object
82571>>>>>>>>>>>
82571>>>>>>>>>>>        Property String Private_psIniFilePath
82572>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
82573>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
82574>>>>>>>>>>>
82574>>>>>>>>>>>//        { Visibility=Private }
82574>>>>>>>>>>>        Property Boolean pbDFConnId False
82575>>>>>>>>>>>
82575>>>>>>>>>>>        // We use Base64 coding instead of the cCryptographer class because the
82575>>>>>>>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
82575>>>>>>>>>>>//        { Visibility=Public }
82575>>>>>>>>>>>//        // *** You really want to change this value! ***
82575>>>>>>>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
82575>>>>>>>>>>>
82575>>>>>>>>>>>    End_Procedure
82576>>>>>>>>>>>
82576>>>>>>>>>>>    Procedure End_Construct_Object
82578>>>>>>>>>>>        Forward Send End_Construct_Object
82580>>>>>>>>>>>    End_Procedure
82581>>>>>>>>>>>
82581>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
82583>>>>>>>>>>>        String sIniFile
82583>>>>>>>>>>>        Get vFolderFormat sPath to sPath
82584>>>>>>>>>>>        Set private_psIniFilePath to sPath
82585>>>>>>>>>>>        Get psIniFileName to sIniFile
82586>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
82587>>>>>>>>>>>    End_Procedure
82588>>>>>>>>>>>
82588>>>>>>>>>>>    Function psIniFilePath Returns String
82590>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
82591>>>>>>>>>>>    End_Function
82592>>>>>>>>>>>
82592>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
82594>>>>>>>>>>>        String sPath
82594>>>>>>>>>>>        Get psIniFilePath to sPath
82595>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
82596>>>>>>>>>>>        Set private_psIniFileName to sFileName
82597>>>>>>>>>>>    End_Procedure
82598>>>>>>>>>>>
82598>>>>>>>>>>>    Function psIniFileName Returns String
82600>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
82601>>>>>>>>>>>    End_Function
82602>>>>>>>>>>>
82602>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
82602>>>>>>>>>>>    // Sets a value in the program's ini file (write)
82602>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
82602>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
82604>>>>>>>>>>>        String sIniFile sPath
82604>>>>>>>>>>>
82604>>>>>>>>>>>        Get psIniFilePath to sPath
82605>>>>>>>>>>>        Get psIniFileName to sIniFile
82606>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
82607>>>>>>>>>>>        Set psFileName to sIniFile
82608>>>>>>>>>>>        Send WriteString sSection sValueName sValue
82609>>>>>>>>>>>    End_Procedure
82610>>>>>>>>>>>
82610>>>>>>>>>>>    // Get a value from program's ini-file (read)
82610>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
82610>>>>>>>>>>>    // Returns the value
82610>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
82612>>>>>>>>>>>        String sValue sIniFile sPath
82612>>>>>>>>>>>
82612>>>>>>>>>>>        Get psIniFilePath to sPath
82613>>>>>>>>>>>        Get psIniFileName to sIniFile
82614>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
82615>>>>>>>>>>>        Set psFileName to sIniFile
82616>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
82617>>>>>>>>>>>
82617>>>>>>>>>>>        Function_Return sValue
82618>>>>>>>>>>>    End_Function
82619>>>>>>>>>>>
82619>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
82619>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
82621>>>>>>>>>>>        Integer iCheckboxCol
82621>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) Begin
82623>>>>>>>>>>>            Function_Return (LT)
82624>>>>>>>>>>>        End
82624>>>>>>>>>>>>
82624>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) Begin
82626>>>>>>>>>>>            Function_Return (GT)
82627>>>>>>>>>>>        End
82627>>>>>>>>>>>>
82627>>>>>>>>>>>
82627>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) Begin
82629>>>>>>>>>>>            Function_Return (LT)
82630>>>>>>>>>>>        End
82630>>>>>>>>>>>>
82630>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) Begin
82632>>>>>>>>>>>            Function_Return (GT)
82633>>>>>>>>>>>        End
82633>>>>>>>>>>>>
82633>>>>>>>>>>>
82633>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) Begin
82635>>>>>>>>>>>            Function_Return (LT)
82636>>>>>>>>>>>        End
82636>>>>>>>>>>>>
82636>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) Begin
82638>>>>>>>>>>>            Function_Return (GT)
82639>>>>>>>>>>>        End
82639>>>>>>>>>>>>
82639>>>>>>>>>>>
82639>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) Begin
82641>>>>>>>>>>>            Function_Return (LT)
82642>>>>>>>>>>>        End
82642>>>>>>>>>>>>
82642>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) Begin
82644>>>>>>>>>>>            Function_Return (GT)
82645>>>>>>>>>>>        End
82645>>>>>>>>>>>>
82645>>>>>>>>>>>
82645>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) Begin
82647>>>>>>>>>>>            Function_Return (LT)
82648>>>>>>>>>>>        End
82648>>>>>>>>>>>>
82648>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) Begin
82650>>>>>>>>>>>            Function_Return (GT)
82651>>>>>>>>>>>        End
82651>>>>>>>>>>>>
82651>>>>>>>>>>>
82651>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) Begin
82653>>>>>>>>>>>            Function_Return (LT)
82654>>>>>>>>>>>        End
82654>>>>>>>>>>>>
82654>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) Begin
82656>>>>>>>>>>>            Function_Return (GT)
82657>>>>>>>>>>>        End
82657>>>>>>>>>>>>
82657>>>>>>>>>>>
82657>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) Begin
82659>>>>>>>>>>>            Function_Return (LT)
82660>>>>>>>>>>>        End
82660>>>>>>>>>>>>
82660>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) Begin
82662>>>>>>>>>>>            Function_Return (GT)
82663>>>>>>>>>>>        End
82663>>>>>>>>>>>>
82663>>>>>>>>>>>
82663>>>>>>>>>>>        Function_Return (EQ)
82664>>>>>>>>>>>    End_Function
82665>>>>>>>>>>>
82665>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
82667>>>>>>>>>>>        Handle hoSections
82667>>>>>>>>>>>        Integer iItems
82667>>>>>>>>>>>
82667>>>>>>>>>>>        Send ReadSections hoSections
82668>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
82669>>>>>>>>>>>        Function_Return iItems
82670>>>>>>>>>>>    End_Function
82671>>>>>>>>>>>
82671>>>>>>>>>>>    // The normal connection string looks something like this;
82671>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
82671>>>>>>>>>>>    // ...but the full connection string looks like this;
82671>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
82671>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
82671>>>>>>>>>>>//        String sSection
82671>>>>>>>>>>>//        Integer iCount
82671>>>>>>>>>>>//
82671>>>>>>>>>>>//        Move False to Err
82671>>>>>>>>>>>//        Get psIniSectionName to sSection
82671>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
82671>>>>>>>>>>>//        Increment iCount
82671>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
82671>>>>>>>>>>>//
82671>>>>>>>>>>>//        Function_Return (Err = False)
82671>>>>>>>>>>>//    End_Function
82671>>>>>>>>>>>
82671>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
82673>>>>>>>>>>>        Integer iCount
82673>>>>>>>>>>>        Boolean bExists
82673>>>>>>>>>>>        String sSection
82673>>>>>>>>>>>
82673>>>>>>>>>>>        Move False to Err
82674>>>>>>>>>>>        Move 1 to iCount
82675>>>>>>>>>>>        Get psIniSectionName to sSection
82676>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82677>>>>>>>>>>>        While (bExists = True)
82681>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
82682>>>>>>>>>>>            Increment iCount
82683>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82684>>>>>>>>>>>        Loop
82685>>>>>>>>>>>>
82685>>>>>>>>>>>        Function_Return (Err = False)
82686>>>>>>>>>>>    End_Function
82687>>>>>>>>>>>
82687>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
82689>>>>>>>>>>>        Integer iCount
82689>>>>>>>>>>>        String sSection
82689>>>>>>>>>>>        Boolean bExists
82689>>>>>>>>>>>
82689>>>>>>>>>>>        Move False to Err
82690>>>>>>>>>>>        Move 1 to iCount
82691>>>>>>>>>>>        Get psIniSectionName to sSection
82692>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
82693>>>>>>>>>>>        While (bExists = True)
82697>>>>>>>>>>>            If (iCount = iItem) Begin
82699>>>>>>>>>>>                Send DeleteSection sSection
82700>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
82700>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
82701>>>>>>>>>>>            End
82701>>>>>>>>>>>>
82701>>>>>>>>>>>            Increment iCount
82702>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
82703>>>>>>>>>>>        Loop
82704>>>>>>>>>>>>
82704>>>>>>>>>>>
82704>>>>>>>>>>>        Function_Return (Err = False)
82705>>>>>>>>>>>    End_Function
82706>>>>>>>>>>>
82706>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
82706>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
82706>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
82708>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82708>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82709>>>>>>>>>>>        tSQLConnection   SQLConnection
82709>>>>>>>>>>>        tSQLConnection   SQLConnection
82709>>>>>>>>>>>        Integer iIndex
82709>>>>>>>>>>>
82709>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
82710>>>>>>>>>>>        If (iIndex = -1) Begin
82712>>>>>>>>>>>            Move True to SQLConnection.bError
82713>>>>>>>>>>>            Function_Return SQLConnection
82714>>>>>>>>>>>        End
82714>>>>>>>>>>>>
82714>>>>>>>>>>>
82714>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82715>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
82716>>>>>>>>>>>
82716>>>>>>>>>>>        Function_Return SQLConnection
82717>>>>>>>>>>>    End_Function
82718>>>>>>>>>>>
82718>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
82718>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
82720>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82720>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82721>>>>>>>>>>>        Integer iRetval iCount iSize
82721>>>>>>>>>>>        String sValue
82721>>>>>>>>>>>        Boolean bExists
82721>>>>>>>>>>>
82721>>>>>>>>>>>        Move -1 to iRetval
82722>>>>>>>>>>>
82722>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82723>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82724>>>>>>>>>>>        Decrement iSize
82725>>>>>>>>>>>        For iCount from 0 to iSize
82731>>>>>>>>>>>>
82731>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
82732>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
82733>>>>>>>>>>>            If (bExists) Begin
82735>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
82736>>>>>>>>>>>                Move iSize to iCount         // We're done!
82737>>>>>>>>>>>            End
82737>>>>>>>>>>>>
82737>>>>>>>>>>>        Loop
82738>>>>>>>>>>>>
82738>>>>>>>>>>>
82738>>>>>>>>>>>        Function_Return iRetval
82739>>>>>>>>>>>    End_Function
82740>>>>>>>>>>>
82740>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
82740>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
82740>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
82742>>>>>>>>>>>        Integer iCount iSize iItems
82742>>>>>>>>>>>        String sValue
82742>>>>>>>>>>>        Boolean bExists
82742>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82742>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82743>>>>>>>>>>>
82743>>>>>>>>>>>        Move 0 to iItems
82744>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82745>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82746>>>>>>>>>>>        Decrement iSize
82747>>>>>>>>>>>        For iCount from 0 to iSize
82753>>>>>>>>>>>>
82753>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
82754>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
82755>>>>>>>>>>>            If (bExists) Begin
82757>>>>>>>>>>>                Increment iItems
82758>>>>>>>>>>>            End
82758>>>>>>>>>>>>
82758>>>>>>>>>>>        Loop
82759>>>>>>>>>>>>
82759>>>>>>>>>>>
82759>>>>>>>>>>>        Function_Return (iItems > 1)
82760>>>>>>>>>>>    End_Function
82761>>>>>>>>>>>
82761>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
82761>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
82763>>>>>>>>>>>        Boolean bRetval bOK
82763>>>>>>>>>>>        Integer iItem iSize iCount
82763>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82763>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82764>>>>>>>>>>>        tSQLConnection SQLConnection
82764>>>>>>>>>>>        tSQLConnection SQLConnection
82764>>>>>>>>>>>        String sConnectionString
82764>>>>>>>>>>>
82764>>>>>>>>>>>        Move False to Err
82765>>>>>>>>>>>        Get psConnectionString to sConnectionString
82766>>>>>>>>>>>
82766>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82767>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82768>>>>>>>>>>>        Decrement iSize
82769>>>>>>>>>>>        // Set all current connection to inactive.
82769>>>>>>>>>>>        For iCount from 0 to iSize
82775>>>>>>>>>>>>
82775>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
82776>>>>>>>>>>>        Loop
82777>>>>>>>>>>>>
82777>>>>>>>>>>>
82777>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
82778>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
82779>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
82780>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
82781>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
82782>>>>>>>>>>>
82782>>>>>>>>>>>        Function_Return (bOK = True)
82783>>>>>>>>>>>    End_Function
82784>>>>>>>>>>>
82784>>>>>>>>>>>    // Used for updating an existing connection with new data.
82784>>>>>>>>>>>    // Returns True if successful.
82784>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
82786>>>>>>>>>>>        Boolean bRetval bOK
82786>>>>>>>>>>>        Integer iItem iSize iCount
82786>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82786>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82787>>>>>>>>>>>
82787>>>>>>>>>>>        Move False to Err
82788>>>>>>>>>>>        Move -1 to iItem
82789>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82790>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82791>>>>>>>>>>>        Decrement iSize
82792>>>>>>>>>>>        // Set all current connection to inactive.
82792>>>>>>>>>>>        For iCount from 0 to iSize
82798>>>>>>>>>>>>
82798>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
82799>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
82801>>>>>>>>>>>                Move iCount to iItem
82802>>>>>>>>>>>            End
82802>>>>>>>>>>>>
82802>>>>>>>>>>>        Loop
82803>>>>>>>>>>>>
82803>>>>>>>>>>>
82803>>>>>>>>>>>        If (iItem <> -1) Begin
82805>>>>>>>>>>>            Move True to SQLConnection.bEnabled
82806>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
82807>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
82808>>>>>>>>>>>        End
82808>>>>>>>>>>>>
82808>>>>>>>>>>>
82808>>>>>>>>>>>        Function_Return (bOK = True)
82809>>>>>>>>>>>    End_Function
82810>>>>>>>>>>>
82810>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
82812>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82812>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
82813>>>>>>>>>>>        String sSection sValue
82813>>>>>>>>>>>        Integer iCount
82813>>>>>>>>>>>        Boolean bExists bEnabled
82813>>>>>>>>>>>
82813>>>>>>>>>>>        Get psIniSectionName to sSection
82814>>>>>>>>>>>        Get SectionExists sSection to bExists
82815>>>>>>>>>>>        If (bExists = False) Begin
82817>>>>>>>>>>>            Function_Return SQLConnectionsArray
82818>>>>>>>>>>>        End
82818>>>>>>>>>>>>
82818>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
82819>>>>>>>>>>>        If (bExists = True) Begin
82821>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
82822>>>>>>>>>>>>
82822>>>>>>>>>>>        End
82822>>>>>>>>>>>>
82822>>>>>>>>>>>
82822>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
82823>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82824>>>>>>>>>>>
82824>>>>>>>>>>>        While (bExists = True)
82828>>>>>>>>>>>            // We always put the enabled/active connection at the top
82828>>>>>>>>>>>            Move (iCount = 1) to bEnabled
82829>>>>>>>>>>>            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
82830>>>>>>>>>>>
82830>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
82831>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
82832>>>>>>>>>>>
82832>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
82832>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
82833>>>>>>>>>>>            If (sValue = "99") Begin
82835>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
82836>>>>>>>>>>>            End
82836>>>>>>>>>>>>
82836>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
82837>>>>>>>>>>>
82837>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
82838>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
82839>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
82841>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
82842>>>>>>>>>>>            End
82842>>>>>>>>>>>>
82842>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
82843>>>>>>>>>>>
82843>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
82844>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
82845>>>>>>>>>>>
82845>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
82846>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
82847>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
82849>>>>>>>>>>>                Get DecryptPassword sValue to sValue
82850>>>>>>>>>>>            End
82850>>>>>>>>>>>>
82850>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
82851>>>>>>>>>>>
82851>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
82851>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
82852>>>>>>>>>>>
82852>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
82853>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
82854>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
82855>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
82856>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to SQLConnectionsArray[iCount].bSilentLogin
82857>>>>>>>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
82857>>>>>>>>>>>
82857>>>>>>>>>>>            Increment iCount
82858>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82859>>>>>>>>>>>        Loop
82860>>>>>>>>>>>>
82860>>>>>>>>>>>
82860>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
82860>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
82862>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
82863>>>>>>>>>>>        End
82863>>>>>>>>>>>>
82863>>>>>>>>>>>
82863>>>>>>>>>>>        Function_Return SQLConnectionsArray
82864>>>>>>>>>>>    End_Function
82865>>>>>>>>>>>
82865>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
82867>>>>>>>>>>>        Integer iCount iSize iItem
82867>>>>>>>>>>>        Boolean bIsOneActive bEnabled bExists bOK
82867>>>>>>>>>>>        String sConnectionString sSection sValue
82867>>>>>>>>>>>
82867>>>>>>>>>>>        // First we need to _remove_ all current connections in the ini-file, we
82867>>>>>>>>>>>        // do that by setting their values to "".
82867>>>>>>>>>>>        Move 0 to iCount
82868>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
82869>>>>>>>>>>>        If (bOK = False) Begin
82871>>>>>>>>>>>            Function_Return False
82872>>>>>>>>>>>        End
82872>>>>>>>>>>>>
82872>>>>>>>>>>>
82872>>>>>>>>>>>        Move False to Err
82873>>>>>>>>>>>        Get psIniSectionName to sSection
82874>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
82874>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
82875>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82876>>>>>>>>>>>        Decrement iSize
82877>>>>>>>>>>>
82877>>>>>>>>>>>        For iCount from 0 to iSize
82883>>>>>>>>>>>>
82883>>>>>>>>>>>            // DF 19 compatible settings:
82883>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
82884>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
82885>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
82886>>>>>>>>>>>
82886>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
82887>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
82889>>>>>>>>>>>                Get EncryptPassword sValue to sValue
82890>>>>>>>>>>>            End
82890>>>>>>>>>>>>
82890>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
82891>>>>>>>>>>>
82891>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
82893>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
82894>>>>>>>>>>>            End
82894>>>>>>>>>>>>
82894>>>>>>>>>>>
82894>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
82895>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
82896>>>>>>>>>>>
82896>>>>>>>>>>>            // The Database Update Framework extended settings:
82896>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
82897>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
82898>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
82899>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
82900>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
82901>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to SQLConnectionsArray[iCount].bSilentLogin
82902>>>>>>>>>>>        Loop
82903>>>>>>>>>>>>
82903>>>>>>>>>>>
82903>>>>>>>>>>>        Function_Return (bOK and Err = False)
82904>>>>>>>>>>>    End_Function
82905>>>>>>>>>>>
82905>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
82905>>>>>>>>>>>    //
82905>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
82905>>>>>>>>>>>    // corresponding to the passed iDbType.
82905>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
82907>>>>>>>>>>>        String sRetval
82907>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL)       Move CS_dbTypeMSSQL     to sRetval
82910>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL)       Move CS_dbTypeMySQL     to sRetval
82913>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle)      Move CS_dbTypeOracle    to sRetval
82916>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2)         Move CS_dbTypeDB2       to sRetval
82919>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre)     Move CS_dbTypePostgre   to sRetval
82922>>>>>>>>>>>        Function_Return sRetval
82923>>>>>>>>>>>    End_Function
82924>>>>>>>>>>>
82924>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
82924>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
82924>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
82926>>>>>>>>>>>        Integer iRetval
82926>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL)       Move EN_dbTypeMSSQL     to iRetval
82929>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL)       Move EN_dbTypeMySQL     to iRetval
82932>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle)      Move EN_dbTypeOracle    to iRetval
82935>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2)         Move EN_dbTypeDB2       to iRetval
82938>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre)     Move EN_dbTypePostgre   to iRetval
82941>>>>>>>>>>>        Function_Return iRetval
82942>>>>>>>>>>>    End_Function
82943>>>>>>>>>>>
82943>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
82943>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
82943>>>>>>>>>>>    // the SQL Connection program's grid.
82943>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
82945>>>>>>>>>>>        String sRetval
82945>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL)       Move "EN_dbTypeMSSQL"   to sRetval
82948>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL)       Move "EN_dbTypeMySQL"   to sRetval
82951>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle)      Move "EN_dbTypeOracle"  to sRetval
82954>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2)         Move "EN_dbTypeDB2"     to sRetval
82957>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre)     Move "EN_dbTypePostgre" to sRetval
82960>>>>>>>>>>>        Function_Return sRetval
82961>>>>>>>>>>>    End_Function
82962>>>>>>>>>>>
82962>>>>>>>>>>>    // Pass a driver id and the function will return
82962>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
82962>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
82962>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
82964>>>>>>>>>>>        Integer iRetval
82964>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID)  Move EN_dbTypeMSSQL     to iRetval
82967>>>>>>>>>>>        If (sDriverID = SQLFLEX)      Move EN_dbTypeMSSQL     to iRetval
82970>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID)  Move EN_dbTypeMSSQL     to iRetval
82973>>>>>>>>>>>        If (sDriverID = MDSMySQL)     Move EN_dbTypeMySQL     to iRetval
82976>>>>>>>>>>>        If (sDriverID = ORAFLEX)      Move EN_dbTypeOracle    to iRetval
82979>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID)   Move EN_dbTypeDB2       to iRetval
82982>>>>>>>>>>>        If (sDriverID = MDSPgSQL)     Move EN_dbTypePostgre   to iRetval
82985>>>>>>>>>>>        Function_Return iRetval
82986>>>>>>>>>>>    End_Function
82987>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
82987>>>>>>>>>>>>
82987>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
82989>>>>>>>>>>>>    Integer iStart iEnd
82989>>>>>>>>>>>>    String sRetval
82989>>>>>>>>>>>>
82989>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
82990>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
82991>>>>>>>>>>>>    If (iStart = 0) Begin
82993>>>>>>>>>>>>        Function_Return ""
82994>>>>>>>>>>>>    End
82994>>>>>>>>>>>>>
82994>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
82995>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
82996>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
82998>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
82999>>>>>>>>>>>>    End
82999>>>>>>>>>>>>>
82999>>>>>>>>>>>>    Else Begin
83000>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
83001>>>>>>>>>>>>    End
83001>>>>>>>>>>>>>
83001>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
83003>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
83004>>>>>>>>>>>>        Decrement iEnd
83005>>>>>>>>>>>>    End
83005>>>>>>>>>>>>>
83005>>>>>>>>>>>>    If (iEnd <> 0) Begin
83007>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
83008>>>>>>>>>>>>    End
83008>>>>>>>>>>>>>
83008>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
83009>>>>>>>>>>>>
83009>>>>>>>>>>>>    Function_Return (Trim(sRetval))
83010>>>>>>>>>>>>End_Function
83011>>>>>>>>>>>>
83011>>>>>>>>>>>>
83011>>>>>>>>>>>
83011>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
83013>>>>>>>>>>>        String sConnect
83013>>>>>>>>>>>        Handle hoDriver
83013>>>>>>>>>>>
83013>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83014>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
83015>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
83016>>>>>>>>>>>        Send Destroy   of hoDriver
83017>>>>>>>>>>>
83017>>>>>>>>>>>//        Case Begin
83017>>>>>>>>>>>//            Case (sDriverID = MSSQLDRV_ID)
83017>>>>>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
83017>>>>>>>>>>>//                If (sDatabase <> "") Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                If (bTrusted = True) Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Else Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Case Break
83017>>>>>>>>>>>//
83017>>>>>>>>>>>//            Case (sDriverID = ODBC_DRV_ID)
83017>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83017>>>>>>>>>>>//                If (sDatabase <> "") Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                If (bTrusted = True) Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Else Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Case Break
83017>>>>>>>>>>>//
83017>>>>>>>>>>>//            Case (sDriverID = DB2_DRV_ID)
83017>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83017>>>>>>>>>>>////                If (sDatabase <> "") Begin
83017>>>>>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83017>>>>>>>>>>>////                End
83017>>>>>>>>>>>////                If (bTrusted = True) Begin
83017>>>>>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83017>>>>>>>>>>>////                End
83017>>>>>>>>>>>////                Else Begin
83017>>>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83017>>>>>>>>>>>////                End
83017>>>>>>>>>>>//                Case Break
83017>>>>>>>>>>>//
83017>>>>>>>>>>>//            Case (sDriverID = SQLFLEX)
83017>>>>>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
83017>>>>>>>>>>>//                If (sDatabase <> "") Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                If (bTrusted = True) Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Else Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Case Break
83017>>>>>>>>>>>//
83017>>>>>>>>>>>//            Case (sDriverID = ORAFLEX)
83017>>>>>>>>>>>//                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
83017>>>>>>>>>>>//                    Move (sServer + "/" + sDatabase)                  to sServer
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83017>>>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83017>>>>>>>>>>>//                Case Break
83017>>>>>>>>>>>//
83017>>>>>>>>>>>//            Case (sDriverID = MDSPgSQL)
83017>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83017>>>>>>>>>>>//                If (sDatabase <> "") Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83017>>>>>>>>>>>//                Case Break
83017>>>>>>>>>>>//
83017>>>>>>>>>>>//            Case (sDriverID = MDSMySQL)
83017>>>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83017>>>>>>>>>>>//                If (sDatabase <> "") Begin
83017>>>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83017>>>>>>>>>>>//                End
83017>>>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
83017>>>>>>>>>>>//                Case Break
83017>>>>>>>>>>>//
83017>>>>>>>>>>>//            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
83017>>>>>>>>>>>//                Break
83017>>>>>>>>>>>//
83017>>>>>>>>>>>//            Case Else
83017>>>>>>>>>>>//                Move "" to sConnect
83017>>>>>>>>>>>//        Case End
83017>>>>>>>>>>>
83017>>>>>>>>>>>        Function_Return sConnect
83018>>>>>>>>>>>    End_Function
83019>>>>>>>>>>>
83019>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
83019>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
83021>>>>>>>>>>>        String sConnect
83021>>>>>>>>>>>
83021>>>>>>>>>>>        Case Begin
83021>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
83023>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
83024>>>>>>>>>>>                If (sDatabase <> "") Begin
83026>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83027>>>>>>>>>>>                End
83027>>>>>>>>>>>>
83027>>>>>>>>>>>                Case Break
83028>>>>>>>>>>>
83028>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
83031>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83032>>>>>>>>>>>                If (sDatabase <> "") Begin
83034>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83035>>>>>>>>>>>                End
83035>>>>>>>>>>>>
83035>>>>>>>>>>>                Case Break
83036>>>>>>>>>>>
83036>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
83039>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83040>>>>>>>>>>>                If (sDatabase <> "") Begin
83042>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83043>>>>>>>>>>>                End
83043>>>>>>>>>>>>
83043>>>>>>>>>>>                Case Break
83044>>>>>>>>>>>
83044>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
83047>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83048>>>>>>>>>>>                If (sDatabase <> "") Begin
83050>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83051>>>>>>>>>>>                End
83051>>>>>>>>>>>>
83051>>>>>>>>>>>                Case Break
83052>>>>>>>>>>>
83052>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
83055>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83056>>>>>>>>>>>                If (sDatabase <> "") Begin
83058>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83059>>>>>>>>>>>                End
83059>>>>>>>>>>>>
83059>>>>>>>>>>>                Case Break
83060>>>>>>>>>>>
83060>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
83063>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
83064>>>>>>>>>>>                If (sDatabase <> "") Begin
83066>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
83067>>>>>>>>>>>                End
83067>>>>>>>>>>>>
83067>>>>>>>>>>>                Case Break
83068>>>>>>>>>>>
83068>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
83071>>>>>>>>>>>                Break
83072>>>>>>>>>>>
83072>>>>>>>>>>>            Case Else
83072>>>>>>>>>>>                Move "" to sConnect
83073>>>>>>>>>>>        Case End
83073>>>>>>>>>>>
83073>>>>>>>>>>>        Function_Return sConnect
83074>>>>>>>>>>>    End_Function
83075>>>>>>>>>>>
83075>>>>>>>>>>>    // Use Base64
83075>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
83077>>>>>>>>>>>        String sRetval sHashString
83077>>>>>>>>>>>//        Handle hoCryptographer
83077>>>>>>>>>>>//
83077>>>>>>>>>>>//        Get psHashString to sHashString
83077>>>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
83077>>>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
83077>>>>>>>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
83077>>>>>>>>>>>//
83077>>>>>>>>>>>//        Send Destroy of hoCryptographer
83077>>>>>>>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
83078>>>>>>>>>>>        Function_Return sRetval
83079>>>>>>>>>>>    End_Function
83080>>>>>>>>>>>
83080>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
83082>>>>>>>>>>>        String sRetval sHashString
83082>>>>>>>>>>>//        Handle hoCryptographer
83082>>>>>>>>>>>//
83082>>>>>>>>>>>//        Get psHashString to sHashString
83082>>>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
83082>>>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
83082>>>>>>>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
83082>>>>>>>>>>>//
83082>>>>>>>>>>>//        Send Destroy of hoCryptographer
83082>>>>>>>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
83083>>>>>>>>>>>
83083>>>>>>>>>>>        Function_Return sRetval
83084>>>>>>>>>>>    End_Function
83085>>>>>>>>>>>
83085>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
83085>>>>>>>>>>>    Function ApplicationPath Returns String
83087>>>>>>>>>>>        String sApplicationFileName sPath
83087>>>>>>>>>>>        Integer iNumChars iRetval
83087>>>>>>>>>>>
83087>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
83088>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
83089>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
83090>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
83091>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
83092>>>>>>>>>>>
83092>>>>>>>>>>>        Function_Return sPath
83093>>>>>>>>>>>    End_Function
83094>>>>>>>>>>>
83094>>>>>>>>>>>End_Class
83095>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
83095>>>>>>>>>
83095>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
83095>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
83095>>>>>>>>>
83095>>>>>>>>>// We're making references to this object handle so we need it defined
83095>>>>>>>>>// here as well as for the cDbUpdateHandler class
83095>>>>>>>>>
83095>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
83095>>>>>>>>>
83095>>>>>>>>>Class cSQLConnectionHandler is a cObject
83096>>>>>>>>>
83096>>>>>>>>>    Procedure Construct_Object
83098>>>>>>>>>        Forward Send Construct_Object
83100>>>>>>>>>        Move Self to ghoSQLConnectionHandler
83101>>>>>>>>>
83101>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
83102>>>>>>>>>
83102>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
83102>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
83102>>>>>>>>>        // methods to this class.
83102>>>>>>>>>        Property Boolean pbUseConnectionID True
83103>>>>>>>>>        Property Boolean pbToANSI          True
83104>>>>>>>>>        Property Boolean pbRecnum          True
83105>>>>>>>>>        Property Boolean pbCopyData        True
83106>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
83107>>>>>>>>>        Property Boolean pbCompareIndexAscending False
83108>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
83109>>>>>>>>>
83109>>>>>>>>>        // Driver default value settings:
83109>>>>>>>>>        // Note: When the object is created the corresponding values
83109>>>>>>>>>        // from the driver .int files are read.
83109>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
83109>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
83110>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
83111>>>>>>>>>        Property String psDriverDefaultValueDate     ""
83112>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
83113>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
83114>>>>>>>>>        Property String psDriverDefaultValueText     ""
83115>>>>>>>>>
83115>>>>>>>>>        // Driver "nullability" settings:
83115>>>>>>>>>        // Note: When the object is created the corresponding values
83115>>>>>>>>>        // from the driver .int files are read.
83115>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
83115>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
83116>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
83117>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
83118>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
83119>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
83120>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
83121>>>>>>>>>
83121>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
83121>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
83121>>>>>>>>>        //     driver interfaces.
83121>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
83121>>>>>>>>>        //     of the struct they are all routed throu this struct property.
83121>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
83122>>>>>>>>>
83122>>>>>>>>>    End_Procedure
83123>>>>>>>>>
83123>>>>>>>>>    Procedure End_Construct_Object
83125>>>>>>>>>        Boolean bReadSettings
83125>>>>>>>>>        tSQLConnection SQLConnection
83125>>>>>>>>>        tSQLConnection SQLConnection
83125>>>>>>>>>
83125>>>>>>>>>        Forward Send End_Construct_Object
83127>>>>>>>>>
83127>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
83127>>>>>>>>>        Get SetupSQLConnection True to SQLConnection
83128>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83129>>>>>>>>>    End_Procedure
83130>>>>>>>>>
83130>>>>>>>>>    // *** Properties ***
83130>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
83130>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
83130>>>>>>>>>    // merely here for conveniance.
83130>>>>>>>>>    //
83130>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
83130>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
83130>>>>>>>>>    // This struct property contains all the connection data.
83130>>>>>>>>>    //
83130>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
83132>>>>>>>>>        Boolean bIsDaw bIsMertech bOK
83132>>>>>>>>>
83132>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83133>>>>>>>>>
83133>>>>>>>>>        // When starting a program we might not have a connection id yet:
83133>>>>>>>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
83135>>>>>>>>>            Procedure_Return
83136>>>>>>>>>        End
83136>>>>>>>>>>
83136>>>>>>>>>        
83136>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
83136>>>>>>>>>        // be logged in already and don't want to do it again.
83136>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
83138>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
83138>>>>>>>>>            // driver interfaces about the change & make a new login.
83138>>>>>>>>>            Get SQLLogin SQLConnection to bOK
83139>>>>>>>>>            If (bOK = False) Begin
83141>>>>>>>>>                Error DFERR_PROGRAM "Login error."
83142>>>>>>>>>>
83142>>>>>>>>>            End
83142>>>>>>>>>>
83142>>>>>>>>>        End
83142>>>>>>>>>>
83142>>>>>>>>>
83142>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
83142>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
83143>>>>>>>>>
83143>>>>>>>>>    End_Procedure
83144>>>>>>>>>
83144>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
83144>>>>>>>>>    // attempt to load the driver.
83144>>>>>>>>>    // Returns true if the passed driver is SQL based.
83144>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
83146>>>>>>>>>        Boolean bOK
83146>>>>>>>>>        Integer iDriver
83146>>>>>>>>>
83146>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83147>>>>>>>>>
83147>>>>>>>>>        If (bOK = False) Begin
83149>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
83150>>>>>>>>>        End
83150>>>>>>>>>>
83150>>>>>>>>>
83150>>>>>>>>>        Function_Return bOK
83151>>>>>>>>>    End_Function
83152>>>>>>>>>
83152>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
83152>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
83154>>>>>>>>>        String sAttributeValue
83154>>>>>>>>>        Integer iDriverID
83154>>>>>>>>>        Boolean bNULL bSQLDriver
83154>>>>>>>>>
83154>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
83155>>>>>>>>>        If (bSQLDriver = False) Begin
83157>>>>>>>>>            Procedure_Return
83158>>>>>>>>>        End
83158>>>>>>>>>>
83158>>>>>>>>>
83158>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83159>>>>>>>>>
83159>>>>>>>>>        // Driver default values for various data types:
83159>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
83162>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
83163>>>>>>>>>
83163>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
83166>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
83167>>>>>>>>>
83167>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
83170>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
83171>>>>>>>>>
83171>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
83174>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
83175>>>>>>>>>
83175>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
83178>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
83179>>>>>>>>>
83179>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
83182>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
83183>>>>>>>>>
83183>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
83183>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
83186>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
83187>>>>>>>>>
83187>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
83190>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
83191>>>>>>>>>
83191>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
83194>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
83195>>>>>>>>>
83195>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
83198>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
83199>>>>>>>>>
83199>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
83202>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
83203>>>>>>>>>
83203>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
83206>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
83207>>>>>>>>>
83207>>>>>>>>>    End_Procedure
83208>>>>>>>>>
83208>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
83210>>>>>>>>>        Boolean bOK bIsDaw bIsMertech bTrusted
83210>>>>>>>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID sCheck
83210>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
83210>>>>>>>>>        Integer iDriverID
83210>>>>>>>>>
83210>>>>>>>>>        Move False to bOK
83211>>>>>>>>>
83211>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
83212>>>>>>>>>        If (bIsDaw = False) Begin
83214>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
83215>>>>>>>>>            If (bIsMertech = False) Begin
83217>>>>>>>>>                Function_Return False
83218>>>>>>>>>            End
83218>>>>>>>>>>
83218>>>>>>>>>        End
83218>>>>>>>>>>
83218>>>>>>>>>
83218>>>>>>>>>        Move Error_Object_Id to hoErrorObj
83219>>>>>>>>>        Move Self to Error_Object_Id
83220>>>>>>>>>
83220>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83221>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
83222>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
83223>>>>>>>>>        If (iDriverID = 0) Begin
83225>>>>>>>>>            Move hoErrorObj to Error_Object_Id
83226>>>>>>>>>            Function_Return False
83227>>>>>>>>>        End
83227>>>>>>>>>>
83227>>>>>>>>>
83227>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
83227>>>>>>>>>        If (bIsMertech = False) Begin
83229>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
83232>>>>>>>>>        End
83232>>>>>>>>>>
83232>>>>>>>>>
83232>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83233>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
83234>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
83235>>>>>>>>>        Send Destroy   of hoDriver
83236>>>>>>>>>        Move hoErrorObj to Error_Object_Id
83237>>>>>>>>>
83237>>>>>>>>>        Function_Return bOK
83238>>>>>>>>>    End_Function
83239>>>>>>>>>
83239>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
83241>>>>>>>>>        tSQLConnection SQLConnection
83241>>>>>>>>>        tSQLConnection SQLConnection
83241>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83242>>>>>>>>>        Function_Return SQLConnection
83243>>>>>>>>>    End_Function
83244>>>>>>>>>
83244>>>>>>>>>    Procedure Set psConnectionID String sValue
83246>>>>>>>>>        tSQLConnection SQLConnection
83246>>>>>>>>>        tSQLConnection SQLConnection
83246>>>>>>>>>        Integer iIndex
83246>>>>>>>>>
83246>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83247>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
83249>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
83250>>>>>>>>>        End
83250>>>>>>>>>>
83250>>>>>>>>>
83250>>>>>>>>>        // Else we might want to change the current connection ID
83250>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
83253>>>>>>>>>            Move False to Err
83254>>>>>>>>>            Logout SQLConnection.sDriverID
83255>>>>>>>>>            // This will also make a login to the new server.
83255>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
83256>>>>>>>>>        End
83256>>>>>>>>>>
83256>>>>>>>>>        Set pSQLConnection to SQLConnection
83257>>>>>>>>>    End_Procedure
83258>>>>>>>>>
83258>>>>>>>>>    Function psConnectionID Returns String
83260>>>>>>>>>        tSQLConnection SQLConnection
83260>>>>>>>>>        tSQLConnection SQLConnection
83260>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83261>>>>>>>>>        Function_Return SQLConnection.sConnectionID
83262>>>>>>>>>    End_Procedure
83263>>>>>>>>>
83263>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
83263>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
83263>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
83263>>>>>>>>>    //       for a connection string has the wrong format for that driver.
83263>>>>>>>>>    Procedure Set psDriverID String sValue
83265>>>>>>>>>        tSQLConnection SQLConnection
83265>>>>>>>>>        tSQLConnection SQLConnection
83265>>>>>>>>>        Get pSQLConnection to SQLConnection
83266>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
83267>>>>>>>>>        Set pSQLConnection to SQLConnection
83268>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
83270>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83271>>>>>>>>>        End
83271>>>>>>>>>>
83271>>>>>>>>>    End_Procedure
83272>>>>>>>>>
83272>>>>>>>>>    Function psDriverID Returns String
83274>>>>>>>>>        tSQLConnection SQLConnection
83274>>>>>>>>>        tSQLConnection SQLConnection
83274>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83275>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
83277>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
83278>>>>>>>>>        End
83278>>>>>>>>>>
83278>>>>>>>>>        Function_Return SQLConnection.sDriverID
83279>>>>>>>>>    End_Function
83280>>>>>>>>>
83280>>>>>>>>>    Procedure Set psConnectionString String sValue
83282>>>>>>>>>        tSQLConnection SQLConnection
83282>>>>>>>>>        tSQLConnection SQLConnection
83282>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83283>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
83284>>>>>>>>>        Set pSQLConnection to SQLConnection
83285>>>>>>>>>    End_Procedure
83286>>>>>>>>>
83286>>>>>>>>>    Function psConnectionString Returns String
83288>>>>>>>>>        tSQLConnection SQLConnection
83288>>>>>>>>>        tSQLConnection SQLConnection
83288>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83289>>>>>>>>>        Function_Return SQLConnection.sConnectionString
83290>>>>>>>>>    End_Function
83291>>>>>>>>>
83291>>>>>>>>>    Procedure Set psServer String sValue
83293>>>>>>>>>        tSQLConnection SQLConnection
83293>>>>>>>>>        tSQLConnection SQLConnection
83293>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83294>>>>>>>>>        Move sValue        to SQLConnection.sServer
83295>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83296>>>>>>>>>        Set pSQLConnection to SQLConnection
83297>>>>>>>>>    End_Procedure
83298>>>>>>>>>
83298>>>>>>>>>    Function psServer Returns String
83300>>>>>>>>>        tSQLConnection SQLConnection
83300>>>>>>>>>        tSQLConnection SQLConnection
83300>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83301>>>>>>>>>        Function_Return SQLConnection.sServer
83302>>>>>>>>>    End_Function
83303>>>>>>>>>
83303>>>>>>>>>    Procedure Set psDatabase String sValue
83305>>>>>>>>>        tSQLConnection SQLConnection
83305>>>>>>>>>        tSQLConnection SQLConnection
83305>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83306>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
83307>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83308>>>>>>>>>        Set pSQLConnection to SQLConnection
83309>>>>>>>>>    End_Procedure
83310>>>>>>>>>
83310>>>>>>>>>    Function psDatabase Returns String
83312>>>>>>>>>        tSQLConnection SQLConnection
83312>>>>>>>>>        tSQLConnection SQLConnection
83312>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83313>>>>>>>>>        Function_Return SQLConnection.sDatabase
83314>>>>>>>>>    End_Function
83315>>>>>>>>>
83315>>>>>>>>>    Procedure Set psUserID String sValue
83317>>>>>>>>>        tSQLConnection SQLConnection
83317>>>>>>>>>        tSQLConnection SQLConnection
83317>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83318>>>>>>>>>        Move sValue        to SQLConnection.sUserID
83319>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83320>>>>>>>>>        Set pSQLConnection to SQLConnection
83321>>>>>>>>>    End_Procedure
83322>>>>>>>>>
83322>>>>>>>>>    Function psUserID Returns String
83324>>>>>>>>>        tSQLConnection SQLConnection
83324>>>>>>>>>        tSQLConnection SQLConnection
83324>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83325>>>>>>>>>        Function_Return SQLConnection.sUserID
83326>>>>>>>>>    End_Function
83327>>>>>>>>>
83327>>>>>>>>>    // This is the uncrypted password
83327>>>>>>>>>    Procedure Set psPassword String sValue
83329>>>>>>>>>        tSQLConnection SQLConnection
83329>>>>>>>>>        tSQLConnection SQLConnection
83329>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83330>>>>>>>>>        Move sValue        to SQLConnection.sPassword
83331>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83332>>>>>>>>>        Set pSQLConnection to SQLConnection
83333>>>>>>>>>    End_Procedure
83334>>>>>>>>>
83334>>>>>>>>>    Function psPassword Returns String
83336>>>>>>>>>        tSQLConnection SQLConnection
83336>>>>>>>>>        tSQLConnection SQLConnection
83336>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83337>>>>>>>>>        Function_Return SQLConnection.sPassword
83338>>>>>>>>>    End_Function
83339>>>>>>>>>
83339>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
83341>>>>>>>>>        tSQLConnection SQLConnection
83341>>>>>>>>>        tSQLConnection SQLConnection
83341>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83342>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
83343>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83344>>>>>>>>>        Set pSQLConnection to SQLConnection
83345>>>>>>>>>    End_Procedure
83346>>>>>>>>>
83346>>>>>>>>>    Function pbTrusted Returns Boolean
83348>>>>>>>>>        tSQLConnection SQLConnection
83348>>>>>>>>>        tSQLConnection SQLConnection
83348>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83349>>>>>>>>>        Function_Return SQLConnection.bTrusted
83350>>>>>>>>>    End_Function
83351>>>>>>>>>
83351>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
83351>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
83351>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
83351>>>>>>>>>    //     the central pSQLConnection "hub".
83351>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
83353>>>>>>>>>        tSQLConnection SQLConnection
83353>>>>>>>>>        tSQLConnection SQLConnection
83353>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83354>>>>>>>>>        Move bValue to SQLConnection.bTrusted
83355>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83356>>>>>>>>>    End_Procedure
83357>>>>>>>>>
83357>>>>>>>>>    Function pbSilentLogin Returns Boolean
83359>>>>>>>>>        tSQLConnection SQLConnection
83359>>>>>>>>>        tSQLConnection SQLConnection
83359>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83360>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
83361>>>>>>>>>    End_Function
83362>>>>>>>>>
83362>>>>>>>>>    Procedure Set piDbType Integer iValue
83364>>>>>>>>>        tSQLConnection SQLConnection
83364>>>>>>>>>        tSQLConnection SQLConnection
83364>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83365>>>>>>>>>        Move iValue to SQLConnection.iDbType
83366>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83367>>>>>>>>>    End_Procedure
83368>>>>>>>>>
83368>>>>>>>>>    Function piDbType Returns Integer
83370>>>>>>>>>        tSQLConnection SQLConnection
83370>>>>>>>>>        tSQLConnection SQLConnection
83370>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83371>>>>>>>>>        Function_Return SQLConnection.iDbType
83372>>>>>>>>>    End_Function
83373>>>>>>>>>
83373>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
83375>>>>>>>>>        tSQLConnection SQLConnection
83375>>>>>>>>>        tSQLConnection SQLConnection
83375>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83376>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
83377>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83378>>>>>>>>>    End_Procedure
83379>>>>>>>>>
83379>>>>>>>>>    Function psBaseTableSpace Returns String
83381>>>>>>>>>        tSQLConnection SQLConnection
83381>>>>>>>>>        tSQLConnection SQLConnection
83381>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83382>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
83383>>>>>>>>>    End_Function
83384>>>>>>>>>
83384>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
83386>>>>>>>>>        tSQLConnection SQLConnection
83386>>>>>>>>>        tSQLConnection SQLConnection
83386>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83387>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
83388>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83389>>>>>>>>>    End_Procedure
83390>>>>>>>>>
83390>>>>>>>>>    Function psIndexTableSpace Returns String
83392>>>>>>>>>        tSQLConnection SQLConnection
83392>>>>>>>>>        tSQLConnection SQLConnection
83392>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83393>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
83394>>>>>>>>>    End_Function
83395>>>>>>>>>
83395>>>>>>>>>    Procedure Set psLongTableSpace String sValue
83397>>>>>>>>>        tSQLConnection SQLConnection
83397>>>>>>>>>        tSQLConnection SQLConnection
83397>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83398>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
83399>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83400>>>>>>>>>    End_Procedure
83401>>>>>>>>>
83401>>>>>>>>>    Function psLongTableSpace Returns String
83403>>>>>>>>>        tSQLConnection SQLConnection
83403>>>>>>>>>        tSQLConnection SQLConnection
83403>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83404>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
83405>>>>>>>>>    End_Function
83406>>>>>>>>>
83406>>>>>>>>>    Procedure Set psSchema String sValue
83408>>>>>>>>>        tSQLConnection SQLConnection
83408>>>>>>>>>        tSQLConnection SQLConnection
83408>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83409>>>>>>>>>        Move sValue to SQLConnection.sSchema
83410>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83411>>>>>>>>>    End_Procedure
83412>>>>>>>>>
83412>>>>>>>>>    Function psSchema Returns String
83414>>>>>>>>>        tSQLConnection SQLConnection
83414>>>>>>>>>        tSQLConnection SQLConnection
83414>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83415>>>>>>>>>        Function_Return SQLConnection.sSchema
83416>>>>>>>>>    End_Function
83417>>>>>>>>>
83417>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
83419>>>>>>>>>        tSQLConnection SQLConnection
83419>>>>>>>>>        tSQLConnection SQLConnection
83419>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83420>>>>>>>>>        Move bValue to SQLConnection.bEnabled
83421>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
83422>>>>>>>>>    End_Procedure
83423>>>>>>>>>
83423>>>>>>>>>    Function pbEnabled Returns Boolean
83425>>>>>>>>>        tSQLConnection SQLConnection
83425>>>>>>>>>        tSQLConnection SQLConnection
83425>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
83426>>>>>>>>>        Function_Return SQLConnection.bEnabled
83427>>>>>>>>>    End_Function
83428>>>>>>>>>
83428>>>>>>>>>
83428>>>>>>>>>    // ************************************
83428>>>>>>>>>    Function SetupSQLConnection Boolean bReadSettings Returns tSQLConnection
83430>>>>>>>>>        tSQLConnection SQLConnection
83430>>>>>>>>>        tSQLConnection SQLConnection
83430>>>>>>>>>
83430>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
83430>>>>>>>>>        // deferr reading SQL connection values until later.
83430>>>>>>>>>        If (bReadSettings = True) Begin
83432>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
83432>>>>>>>>>            If (ghoConnection > 0) Begin
83434>>>>>>>>>                Get ReadcConnections to SQLConnection
83435>>>>>>>>>            End
83435>>>>>>>>>>
83435>>>>>>>>>
83435>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
83435>>>>>>>>>            // object is used.
83435>>>>>>>>>            Get ReadSQLConnectionsIniSettings to SQLConnection
83436>>>>>>>>>        End
83436>>>>>>>>>>
83436>>>>>>>>>
83436>>>>>>>>>        Function_Return SQLConnection
83437>>>>>>>>>    End_Function
83438>>>>>>>>>
83438>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
83438>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
83440>>>>>>>>>        tConnection Connection
83440>>>>>>>>>        tConnection Connection
83440>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83440>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83440>>>>>>>>>        Integer iCount iSize iRetval iDbType
83440>>>>>>>>>        Boolean bOK bEnabled bConnected bVal
83440>>>>>>>>>        String sConnectionID sSchema
83440>>>>>>>>>
83440>>>>>>>>>            tConnection[] Connections
83440>>>>>>>>>            tConnection[] Connections
83441>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
83441>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
83441>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
83441>>>>>>>>>            //   we then generate an error and abort the program...
83441>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
83442>>>>>>>>>            If (bOK = False) Begin
83444>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
83445>>>>>>>>>>
83445>>>>>>>>>                Abort
83446>>>>>>>>>>
83446>>>>>>>>>            End 
83446>>>>>>>>>>
83446>>>>>>>>>            If (sConnectionID = "") Begin
83448>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections  
83449>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
83451>>>>>>>>>                    Move Connections[0].sId to sConnectionID
83452>>>>>>>>>                End
83452>>>>>>>>>>
83452>>>>>>>>>            End
83452>>>>>>>>>>
83452>>>>>>>>>
83452>>>>>>>>>            Move 0 to iRetval
83453>>>>>>>>>            // DAW DF19 connection info:
83453>>>>>>>>>            // We first check that the connection is OK:
83453>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
83454>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
83454>>>>>>>>>            If (iRetval = -1) Begin
83456>>>>>>>>>                Function_Return SQLConnectionEmpty
83457>>>>>>>>>            End
83457>>>>>>>>>>
83457>>>>>>>>>
83457>>>>>>>>>            If (sConnectionID <> "") Begin
83459>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
83460>>>>>>>>>            End
83460>>>>>>>>>>
83460>>>>>>>>>            If (Connection.sId = "") Begin
83462>>>>>>>>>                Move True to SQLConnectionEmpty.bError
83463>>>>>>>>>                Function_Return SQLConnectionEmpty
83464>>>>>>>>>            End
83464>>>>>>>>>>
83464>>>>>>>>>
83464>>>>>>>>>            // DUF connection info struct property:
83464>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
83465>>>>>>>>>
83465>>>>>>>>>            Move Connection.sId to sConnectionID
83466>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
83467>>>>>>>>>
83467>>>>>>>>>            If (bConnected = False) Begin
83469>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
83470>>>>>>>>>                If (iRetval <> 0) Begin
83472>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
83473>>>>>>>>>                    Send Exit_Application
83474>>>>>>>>>                End   
83474>>>>>>>>>>
83474>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
83475>>>>>>>>>                // We need to get the DAW connection info again as it might have
83475>>>>>>>>>                // been changed in the DAW db login dialog.
83475>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
83476>>>>>>>>>            End
83476>>>>>>>>>>
83476>>>>>>>>>
83476>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
83477>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
83478>>>>>>>>>
83478>>>>>>>>>            // Not used in DUF:
83478>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
83478>>>>>>>>>
83478>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
83479>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
83480>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
83481>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
83482>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
83483>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
83484>>>>>>>>>
83484>>>>>>>>>            // Not used in DUF:
83484>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
83484>>>>>>>>>
83484>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
83484>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
83484>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
83486>>>>>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniServerKeyword to SQLConnection.sServer
83487>>>>>>>>>            End
83487>>>>>>>>>>
83487>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
83489>>>>>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniDSNKeyword    to SQLConnection.sServer
83490>>>>>>>>>            End
83490>>>>>>>>>>
83490>>>>>>>>>            Get ParseKeyWord Connection.sString CS_SQLIniDatabaseKeyword   to SQLConnection.sDatabase
83491>>>>>>>>>
83491>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
83491>>>>>>>>>            // the value from the driver id:
83491>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
83492>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
83492>>>>>>>>>            Get piDbType                                     to iDbType
83493>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
83495>>>>>>>>>                Move iDbType to SQLConnection.iDbType
83496>>>>>>>>>            End
83496>>>>>>>>>>
83496>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
83497>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
83498>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
83499>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
83500>>>>>>>>>
83500>>>>>>>>>            // We finally set the struct property to the newly fetched values.
83500>>>>>>>>>            Set pSQLConnection to SQLConnection
83501>>>>>>>>>
83501>>>>>>>>>        Function_Return SQLConnection
83502>>>>>>>>>    End_Function
83503>>>>>>>>>
83503>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
83503>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
83503>>>>>>>>>    // connection id for a particular driver.
83503>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
83503>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
83503>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
83503>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
83503>>>>>>>>>    // connections of the DAW cConnect class.
83503>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
83505>>>>>>>>>        tConnection[] ConnIdArray
83505>>>>>>>>>        tConnection[] ConnIdArray
83506>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
83506>>>>>>>>>        Boolean bOK bEnabled bFound
83506>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
83506>>>>>>>>>
83506>>>>>>>>>        Move False to bFound
83507>>>>>>>>>        If (ghoConnection > 0) Begin
83509>>>>>>>>>
83509>>>>>>>>>            // The property of the cDbUpdateHandler container object
83509>>>>>>>>>            Get psDriverID to sDriverID
83510>>>>>>>>>
83510>>>>>>>>>            Move 0 to iConnectionIDCounter
83511>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
83511>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
83512>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
83513>>>>>>>>>            Decrement iSize
83514>>>>>>>>>            For iCount from 0 to iSize
83520>>>>>>>>>>
83520>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
83521>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
83522>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
83523>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
83523>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
83523>>>>>>>>>                If (sConnectionID = "") Begin
83525>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
83526>>>>>>>>>                End
83526>>>>>>>>>>
83526>>>>>>>>>                Else Begin
83527>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
83529>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
83530>>>>>>>>>                    End
83530>>>>>>>>>>
83530>>>>>>>>>                End
83530>>>>>>>>>>
83530>>>>>>>>>
83530>>>>>>>>>                If (bFound = True) Begin
83532>>>>>>>>>                    Increment iConnectionIDCounter
83533>>>>>>>>>                End
83533>>>>>>>>>>
83533>>>>>>>>>            Loop
83534>>>>>>>>>>
83534>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
83535>>>>>>>>>            If (bFound = True) Begin
83537>>>>>>>>>                Move sConnectionID2 to sConnectionID
83538>>>>>>>>>            End
83538>>>>>>>>>>
83538>>>>>>>>>        End
83538>>>>>>>>>>
83538>>>>>>>>>
83538>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
83538>>>>>>>>>        // but no DFConn.ini record has been created.
83538>>>>>>>>>        If (iSize = -1) Begin
83540>>>>>>>>>            Move True to bFound
83541>>>>>>>>>        End
83541>>>>>>>>>>
83541>>>>>>>>>
83541>>>>>>>>>        Function_Return bFound
83542>>>>>>>>>    End_Function
83543>>>>>>>>>
83543>>>>>>>>>    // Send on object creation to read the default connection string settings, and
83543>>>>>>>>>    // create a connection to the server.
83543>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
83545>>>>>>>>>        String sPath sFileName sSection sConnectionString sPassword
83545>>>>>>>>>        Boolean bExists
83545>>>>>>>>>        tSQLConnection[] SQLConnectionArray
83545>>>>>>>>>        tSQLConnection[] SQLConnectionArray
83546>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83546>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83546>>>>>>>>>        Handle hoIniFile
83546>>>>>>>>>        Integer iSize iCount
83546>>>>>>>>>
83546>>>>>>>>>        Get psIniFilePath to sPath
83547>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83548>>>>>>>>>        If (sPath = "") Begin
83550>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
83551>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
83552>>>>>>>>>        End
83552>>>>>>>>>>
83552>>>>>>>>>        Get vFolderFormat sPath to sPath
83553>>>>>>>>>        Get psIniFileName to sFileName
83554>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
83555>>>>>>>>>
83555>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
83556>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
83557>>>>>>>>>        If (iSize = 0) Begin
83559>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
83559>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
83559>>>>>>>>>            // in the cApplication object.
83559>>>>>>>>>            Get pSQLConnection to SQLConnection
83560>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
83562>>>>>>>>>                Function_Return SQLConnectionEmpty
83563>>>>>>>>>            End
83563>>>>>>>>>>
83563>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0]
83564>>>>>>>>>        End
83564>>>>>>>>>>
83564>>>>>>>>>
83564>>>>>>>>>        // The first connection should be the one that is active, but just in case...
83564>>>>>>>>>        Decrement iSize
83565>>>>>>>>>        For iCount from 0 to iSize
83571>>>>>>>>>>
83571>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
83572>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
83574>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
83575>>>>>>>>>            End
83575>>>>>>>>>>
83575>>>>>>>>>        Loop
83576>>>>>>>>>>
83576>>>>>>>>>
83576>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
83577>>>>>>>>>
83577>>>>>>>>>        Set pSQLConnection to SQLConnection
83578>>>>>>>>>        Send AutoSetConnectionID
83579>>>>>>>>>
83579>>>>>>>>>        Function_Return SQLConnection
83580>>>>>>>>>    End_Function
83581>>>>>>>>>
83581>>>>>>>>>    Procedure Set psIniFilePath String sPath
83583>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
83584>>>>>>>>>    End_Procedure
83585>>>>>>>>>
83585>>>>>>>>>    Function psIniFilePath Returns String
83587>>>>>>>>>        String sRetval
83587>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
83588>>>>>>>>>        Function_Return sRetval
83589>>>>>>>>>    End_Function
83590>>>>>>>>>
83590>>>>>>>>>    Procedure Set psIniFileName String sFileName
83592>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
83593>>>>>>>>>    End_Procedure
83594>>>>>>>>>
83594>>>>>>>>>    Function psIniFileName Returns String
83596>>>>>>>>>        String sRetval
83596>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
83597>>>>>>>>>        Function_Return sRetval
83598>>>>>>>>>    End_Function
83599>>>>>>>>>
83599>>>>>>>>>    // We use Base64 coding instead of the cCryptographer class because the
83599>>>>>>>>>    // password will get scrambled while writing/reading to/from the ini-file.
83599>>>>>>>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
83599>>>>>>>>>//    Procedure Set psHashString String sHashString
83599>>>>>>>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
83599>>>>>>>>>//    End_Procedure
83599>>>>>>>>>//
83599>>>>>>>>>//    Function psHashString Returns String
83599>>>>>>>>>//        String sRetval
83599>>>>>>>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
83599>>>>>>>>>//        Function_Return sRetval
83599>>>>>>>>>//    End_Function
83599>>>>>>>>>
83599>>>>>>>>>    Procedure Set psIniSectionName String sSection
83601>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
83602>>>>>>>>>    End_Procedure
83603>>>>>>>>>
83603>>>>>>>>>    Function psIniSectionName Returns String
83605>>>>>>>>>        String sRetval
83605>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
83606>>>>>>>>>        Function_Return sRetval
83607>>>>>>>>>    End_Function
83608>>>>>>>>>
83608>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
83610>>>>>>>>>        Handle ho
83610>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83611>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
83612>>>>>>>>>    End_Procedure
83613>>>>>>>>>
83613>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
83615>>>>>>>>>        Handle ho
83615>>>>>>>>>        String sRetval
83615>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83616>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
83617>>>>>>>>>        Function_Return sRetval
83618>>>>>>>>>    End_Function
83619>>>>>>>>>
83619>>>>>>>>>    Function SectionExists String sSection Returns Boolean
83621>>>>>>>>>        Handle ho
83621>>>>>>>>>        Boolean bRetval
83621>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83622>>>>>>>>>        Get SectionExists of ho sSection to bRetval
83623>>>>>>>>>        Function_Return bRetval
83624>>>>>>>>>    End_Function
83625>>>>>>>>>
83625>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
83627>>>>>>>>>        Handle ho
83627>>>>>>>>>        Boolean bRetval
83627>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83628>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
83629>>>>>>>>>        Function_Return bRetval
83630>>>>>>>>>    End_Function
83631>>>>>>>>>
83631>>>>>>>>>    Function EncryptPassword String sPassword Returns String
83633>>>>>>>>>        Handle ho
83633>>>>>>>>>        String sRetval
83633>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83634>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
83635>>>>>>>>>        Function_Return sRetval
83636>>>>>>>>>    End_Function
83637>>>>>>>>>
83637>>>>>>>>>    Function DecryptPassword String sPassword Returns String
83639>>>>>>>>>        Handle ho
83639>>>>>>>>>        String sRetval
83639>>>>>>>>>        Get phoSQLConnectionIniFile to ho
83640>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
83641>>>>>>>>>        Function_Return sRetval
83642>>>>>>>>>    End_Function
83643>>>>>>>>>
83643>>>>>>>>>    // *** Main Connection Message ***
83643>>>>>>>>>    // It will create a Connection ID for the passed driver.
83643>>>>>>>>>    // It will also set the psDriverID & psConnectionID of this class.
83643>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
83645>>>>>>>>>        Integer iResult
83645>>>>>>>>>        Handle hoCLI hoDriver
83645>>>>>>>>>        String sConnectionString sError
83645>>>>>>>>>        Boolean bMertech bLoginSuccessful
83645>>>>>>>>>
83645>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
83646>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83647>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
83648>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
83649>>>>>>>>>        If (bLoginSuccessful = False) Begin
83651>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
83652>>>>>>>>>>
83652>>>>>>>>>        End
83652>>>>>>>>>>
83652>>>>>>>>>        Send Destroy of hoDriver
83653>>>>>>>>>
83653>>>>>>>>>    End_Procedure
83654>>>>>>>>>
83654>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
83656>>>>>>>>>        Integer iRetval
83656>>>>>>>>>        Handle hoCLI
83656>>>>>>>>>        String sDriverID
83656>>>>>>>>>
83656>>>>>>>>>        Get psDriverID to sDriverID
83657>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
83658>>>>>>>>>        If (hoCLI <> 0) Begin
83660>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83661>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
83662>>>>>>>>>            Send Destroy of hoCLI
83663>>>>>>>>>        End
83663>>>>>>>>>>
83663>>>>>>>>>
83663>>>>>>>>>        Function_Return iRetval
83664>>>>>>>>>    End_Function
83665>>>>>>>>>
83665>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
83667>>>>>>>>>        Integer iResult
83667>>>>>>>>>        Handle hoCLI
83667>>>>>>>>>        String sServer sDatabase sUserID sPassword
83667>>>>>>>>>        tSQLConnection SQLConnection
83667>>>>>>>>>        tSQLConnection SQLConnection
83667>>>>>>>>>
83667>>>>>>>>>        Set psDriverID to sDriverID
83668>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
83669>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
83670>>>>>>>>>    End_Procedure
83671>>>>>>>>>
83671>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
83671>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
83671>>>>>>>>>    // or the one in the DataFlex Bin folder.)
83671>>>>>>>>>    // We then need to delete the current one before creating a new one.
83671>>>>>>>>>    // This is because the parameters may differ between the program code and the
83671>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
83671>>>>>>>>>    // when one tries to create a Connection ID that already exists.
83671>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
83673>>>>>>>>>        Integer iResult iDriver iNumConn iConn
83673>>>>>>>>>        Handle hoCLI
83673>>>>>>>>>        String sID
83673>>>>>>>>>
83673>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
83675>>>>>>>>>            Procedure_Return
83676>>>>>>>>>        End
83676>>>>>>>>>>
83676>>>>>>>>>
83676>>>>>>>>>        Move 0 to iResult
83677>>>>>>>>>        Get Create U_cCLIHandler to hoCLI
83678>>>>>>>>>        If (hoCLI <> 0) Begin
83680>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83681>>>>>>>>>            Get DriverIndex sDriverID to iDriver
83682>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83685>>>>>>>>>            Decrement iNumConn
83686>>>>>>>>>            For iConn from 0 to iNumConn
83692>>>>>>>>>>
83692>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
83695>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
83697>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
83698>>>>>>>>>                End
83698>>>>>>>>>>
83698>>>>>>>>>            Loop
83699>>>>>>>>>>
83699>>>>>>>>>            Send Destroy of hoCLI
83700>>>>>>>>>        End
83700>>>>>>>>>>
83700>>>>>>>>>
83700>>>>>>>>>    End_Procedure
83701>>>>>>>>>
83701>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
83703>>>>>>>>>        Integer iResult iDriver iNumConn iConn
83703>>>>>>>>>        Handle hoCLI
83703>>>>>>>>>        String sID sConnectionString sVal sDatabase
83703>>>>>>>>>        tSQLConnection SQLConnection
83703>>>>>>>>>        tSQLConnection SQLConnection
83703>>>>>>>>>        Boolean bTrusted
83703>>>>>>>>>
83703>>>>>>>>>        Move 0 to iResult
83704>>>>>>>>>        Get Create U_cCLIHandler to hoCLI
83705>>>>>>>>>        If (hoCLI <> 0) Begin
83707>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
83708>>>>>>>>>            Get DriverIndex sDriverID to iDriver
83709>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83712>>>>>>>>>            Decrement iNumConn
83713>>>>>>>>>            For iConn from 0 to iNumConn
83719>>>>>>>>>>
83719>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
83722>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
83724>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
83725>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
83728>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
83731>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
83732>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
83735>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
83736>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
83737>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
83738>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
83739>>>>>>>>>
83739>>>>>>>>>                    Case Begin
83739>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
83741>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
83742>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
83743>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
83744>>>>>>>>>                            Case Break
83745>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
83748>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83749>>>>>>>>>                            Case Break
83750>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
83753>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83754>>>>>>>>>                            Case Break
83755>>>>>>>>>                        Case (sDriverID = SQLFLEX)
83758>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83759>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83760>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
83762>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83763>>>>>>>>>                            End
83763>>>>>>>>>>
83763>>>>>>>>>                            Else Begin
83764>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83765>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83766>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83767>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83768>>>>>>>>>                            End
83768>>>>>>>>>>
83768>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83769>>>>>>>>>                            Case Break
83770>>>>>>>>>                        Case (sDriverID = MDSMySQL)
83773>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83774>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83775>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
83777>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83778>>>>>>>>>                            End
83778>>>>>>>>>>
83778>>>>>>>>>                            Else Begin
83779>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83780>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83781>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83782>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83783>>>>>>>>>                            End
83783>>>>>>>>>>
83783>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83784>>>>>>>>>                            Case Break
83785>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
83788>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83789>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83790>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
83792>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83793>>>>>>>>>                            End
83793>>>>>>>>>>
83793>>>>>>>>>                            Else Begin
83794>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83795>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83796>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83797>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83798>>>>>>>>>                            End
83798>>>>>>>>>>
83798>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
83799>>>>>>>>>                            Case Break
83800>>>>>>>>>
83800>>>>>>>>>                        Case (sDriverID = ORAFLEX)
83803>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
83804>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
83805>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83806>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
83808>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
83809>>>>>>>>>                            End
83809>>>>>>>>>>
83809>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
83811>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83812>>>>>>>>>                            End
83812>>>>>>>>>>
83812>>>>>>>>>                            Else Begin
83813>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83814>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83815>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83816>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83817>>>>>>>>>                            End
83817>>>>>>>>>>
83817>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83818>>>>>>>>>                            Case Break
83819>>>>>>>>>                        Case Else
83819>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
83820>>>>>>>>>>
83820>>>>>>>>>                            Case Break
83821>>>>>>>>>                    Case End
83821>>>>>>>>>                End
83821>>>>>>>>>>
83821>>>>>>>>>            Loop
83822>>>>>>>>>>
83822>>>>>>>>>            Send Destroy of hoCLI
83823>>>>>>>>>        End
83823>>>>>>>>>>
83823>>>>>>>>>
83823>>>>>>>>>        Function_Return SQLConnection
83824>>>>>>>>>    End_Function
83825>>>>>>>>>
83825>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
83827>>>>>>>>>        String  sCurrentDriver
83827>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount iRetval
83827>>>>>>>>>
83827>>>>>>>>>        Move 0 to iDriver
83828>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
83831>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
83837>>>>>>>>>>
83837>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
83840>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
83842>>>>>>>>>                Function_Return iCount
83843>>>>>>>>>            End
83843>>>>>>>>>>
83843>>>>>>>>>        Loop
83844>>>>>>>>>>
83844>>>>>>>>>
83844>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
83844>>>>>>>>>        If (iDriver = 0) Begin
83846>>>>>>>>>            Move 0 to LastErr
83847>>>>>>>>>            Load_Driver sDriverID
83848>>>>>>>>>            // If driver could not be loaded.
83848>>>>>>>>>            If (LastErr = 4255) Begin
83850>>>>>>>>>                Move 0 to iCount
83851>>>>>>>>>            End
83851>>>>>>>>>>
83851>>>>>>>>>            Function_Return iCount
83852>>>>>>>>>        End
83852>>>>>>>>>>
83852>>>>>>>>>        Function_Return 0
83853>>>>>>>>>    End_Function
83854>>>>>>>>>
83854>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
83854>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
83856>>>>>>>>>        String sRetval sDriverID sConnectionID sConnectionString sServer sDatabase sUserID sPassword
83856>>>>>>>>>        Boolean bTrusted bSilent
83856>>>>>>>>>        Integer iConnOptions
83856>>>>>>>>>
83856>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
83857>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
83858>>>>>>>>>        Move SQLConnection.sServer       to sServer
83859>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
83860>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
83861>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
83862>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
83863>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
83864>>>>>>>>>
83864>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
83865>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
83865>>>>>>>>>        Send AutoSetConnectionID
83866>>>>>>>>>    End_Procedure
83867>>>>>>>>>
83867>>>>>>>>>    // Called when the object is constructed.
83867>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
83867>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
83867>>>>>>>>>    // the database is needed.
83867>>>>>>>>>    Procedure AutoSetConnectionID
83869>>>>>>>>>        String sConnectionID sValue sDriverID sConnectionString
83869>>>>>>>>>        Integer iDriver iNumConn iConn iConnOptions iRetval
83869>>>>>>>>>        Handle hoCLI
83869>>>>>>>>>        Boolean bOK bSilent bMertechDriver
83869>>>>>>>>>
83869>>>>>>>>>        Get pbSilentLogin      to bSilent
83870>>>>>>>>>        Get psConnectionID     to sConnectionID
83871>>>>>>>>>        Get psConnectionString to sConnectionString
83872>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
83872>>>>>>>>>        Get psDriverID to sDriverID
83873>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83874>>>>>>>>>        If (bOK = False) Begin
83876>>>>>>>>>            Procedure_Return
83877>>>>>>>>>        End
83877>>>>>>>>>>
83877>>>>>>>>>
83877>>>>>>>>>        // Mertech drivers can't use connection ID's.
83877>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83878>>>>>>>>>        If (bMertechDriver = True) Begin
83880>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
83880>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
83880>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
83881>>>>>>>>>            Procedure_Return
83882>>>>>>>>>        End
83882>>>>>>>>>>
83882>>>>>>>>>
83882>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
83883>>>>>>>>>        // If driver not loaded; load it.
83883>>>>>>>>>        If (iDriver = 0) Begin
83885>>>>>>>>>            Load_Driver sDriverID
83886>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
83887>>>>>>>>>        End
83887>>>>>>>>>>
83887>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
83887>>>>>>>>>        If (iDriver = 0) Begin
83889>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
83890>>>>>>>>>>
83890>>>>>>>>>            Procedure_Return
83891>>>>>>>>>        End
83891>>>>>>>>>>
83891>>>>>>>>>
83891>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
83892>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
83893>>>>>>>>>        // Delete the connection first; in case it exists
83893>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
83894>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval
83895>>>>>>>>>
83895>>>>>>>>>        Send Destroy of hoCLI
83896>>>>>>>>>    End_Procedure
83897>>>>>>>>>
83897>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
83897>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
83897>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
83897>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
83897>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
83897>>>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
83899>>>>>>>>>        Handle hoSQLHandler
83899>>>>>>>>>        String sDriverID sServer sDatabase
83899>>>>>>>>>
83899>>>>>>>>>        Move 0 to hoSQLHandler
83900>>>>>>>>>        Get psDriverID to sDriverID
83901>>>>>>>>>        Get psServer   to sServer
83902>>>>>>>>>        Get psDatabase to sDatabase
83903>>>>>>>>>
83903>>>>>>>>>        Function_Return hoSQLHandler
83904>>>>>>>>>    End_Function
83905>>>>>>>>>
83905>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
83907>>>>>>>>>        Boolean bOK bMertechDriver
83907>>>>>>>>>
83907>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83908>>>>>>>>>
83908>>>>>>>>>        If (bOK = False) Begin
83910>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
83911>>>>>>>>>        End
83911>>>>>>>>>>
83911>>>>>>>>>
83911>>>>>>>>>        If (bOK = False) Begin
83913>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
83914>>>>>>>>>            If (bMertechDriver = True) Begin
83916>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
83917>>>>>>>>>>
83917>>>>>>>>>            End
83917>>>>>>>>>>
83917>>>>>>>>>            Else Begin
83918>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
83919>>>>>>>>>>
83919>>>>>>>>>            End
83919>>>>>>>>>>
83919>>>>>>>>>            Function_Return False
83920>>>>>>>>>        End
83920>>>>>>>>>>
83920>>>>>>>>>
83920>>>>>>>>>        Function_Return True
83921>>>>>>>>>    End_Function
83922>>>>>>>>>
83922>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
83924>>>>>>>>>        Boolean bOK
83924>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
83925>>>>>>>>>        Function_Return bOK
83926>>>>>>>>>    End_Function
83927>>>>>>>>>
83927>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
83929>>>>>>>>>        Boolean bOK
83929>>>>>>>>>        Move False to bOK
83930>>>>>>>>>        Function_Return bOK
83931>>>>>>>>>    End_Function
83932>>>>>>>>>
83932>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
83934>>>>>>>>>        Handle hoIniFile
83934>>>>>>>>>        String sConnect
83934>>>>>>>>>
83934>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83935>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
83936>>>>>>>>>
83936>>>>>>>>>        Function_Return sConnect
83937>>>>>>>>>    End_Function
83938>>>>>>>>>
83938>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
83938>>>>>>>>>    // Pass a complete driver connection string
83938>>>>>>>>>    // Returns the following as a struct:
83938>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
83938>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
83938>>>>>>>>>    //
83938>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
83940>>>>>>>>>        tSQLConnection SQLConnection
83940>>>>>>>>>        tSQLConnection SQLConnection
83940>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
83940>>>>>>>>>        Boolean bTrusted bSilent bOK
83940>>>>>>>>>        Integer iPos
83940>>>>>>>>>
83940>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83941>>>>>>>>>        If (bOK = False) Begin
83943>>>>>>>>>            Function_Return SQLConnection
83944>>>>>>>>>        End
83944>>>>>>>>>>
83944>>>>>>>>>
83944>>>>>>>>>        Move False to bTrusted
83945>>>>>>>>>        Move False to bSilent
83946>>>>>>>>>
83946>>>>>>>>>        Case Begin
83946>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
83948>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
83949>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83950>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83951>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83952>>>>>>>>>                If (bTrusted = False) Begin
83954>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83955>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83956>>>>>>>>>                End
83956>>>>>>>>>>
83956>>>>>>>>>                Case Break
83957>>>>>>>>>
83957>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
83960>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83961>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83962>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83963>>>>>>>>>                If (bTrusted = False) Begin
83965>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83966>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83967>>>>>>>>>                End
83967>>>>>>>>>>
83967>>>>>>>>>                Case Break
83968>>>>>>>>>
83968>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
83971>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83972>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83973>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83974>>>>>>>>>                Case Break
83975>>>>>>>>>
83975>>>>>>>>>            Case (sDriverID = SQLFLEX)
83978>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
83979>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83980>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83981>>>>>>>>>                If (bTrusted = False) Begin
83983>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83984>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83985>>>>>>>>>                End
83985>>>>>>>>>>
83985>>>>>>>>>                Case Break
83986>>>>>>>>>
83986>>>>>>>>>            Case (sDriverID = ORAFLEX)
83989>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83990>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83991>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
83993>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
83994>>>>>>>>>                End
83994>>>>>>>>>>
83994>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83995>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83996>>>>>>>>>                Case Break
83997>>>>>>>>>
83997>>>>>>>>>            Case (sDriverID = MDSPgSQL)
84000>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
84001>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
84002>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
84003>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
84004>>>>>>>>>                Case Break
84005>>>>>>>>>
84005>>>>>>>>>            Case (sDriverID = MDSMySQL)
84008>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
84009>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
84010>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
84011>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
84012>>>>>>>>>                Case Break
84013>>>>>>>>>
84013>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
84016>>>>>>>>>                Break
84017>>>>>>>>>        Case End
84017>>>>>>>>>
84017>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
84018>>>>>>>>>
84018>>>>>>>>>        // bSilent?
84018>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
84019>>>>>>>>>        If (iPos = 0) Begin
84021>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
84022>>>>>>>>>        End
84022>>>>>>>>>>
84022>>>>>>>>>        If (iPos = 0) Move "0"                                                  to sValue
84025>>>>>>>>>        Else Move (Mid(sConnectionString, 1, (iPos +1)))                        to sValue
84027>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
84028>>>>>>>>>
84028>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
84029>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
84030>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
84031>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
84032>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
84033>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
84034>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
84035>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
84036>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
84037>>>>>>>>>
84037>>>>>>>>>        Function_Return SQLConnection
84038>>>>>>>>>    End_Function
84039>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
84039>>>>>>>>>>
84039>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
84041>>>>>>>>>>    Integer iStart iEnd
84041>>>>>>>>>>    String sRetval
84041>>>>>>>>>>
84041>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
84042>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
84043>>>>>>>>>>    If (iStart = 0) Begin
84045>>>>>>>>>>        Function_Return ""
84046>>>>>>>>>>    End
84046>>>>>>>>>>>
84046>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
84047>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
84048>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
84050>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
84051>>>>>>>>>>    End
84051>>>>>>>>>>>
84051>>>>>>>>>>    Else Begin
84052>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
84053>>>>>>>>>>    End
84053>>>>>>>>>>>
84053>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
84055>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
84056>>>>>>>>>>        Decrement iEnd
84057>>>>>>>>>>    End
84057>>>>>>>>>>>
84057>>>>>>>>>>    If (iEnd <> 0) Begin
84059>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
84060>>>>>>>>>>    End
84060>>>>>>>>>>>
84060>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
84061>>>>>>>>>>
84061>>>>>>>>>>    Function_Return (Trim(sRetval))
84062>>>>>>>>>>End_Function
84063>>>>>>>>>>
84063>>>>>>>>>>
84063>>>>>>>>>
84063>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
84063>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
84065>>>>>>>>>        Handle ho
84065>>>>>>>>>        Integer iRetval iIndex
84065>>>>>>>>>        Boolean bRetval bOK
84065>>>>>>>>>        tSQLConnection SQLConnection
84065>>>>>>>>>        tSQLConnection SQLConnection
84065>>>>>>>>>
84065>>>>>>>>>        Get pSQLConnection to SQLConnection
84066>>>>>>>>>        Get phoSQLConnectionIniFile to ho
84067>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
84068>>>>>>>>>        If (iIndex = -1) Begin
84070>>>>>>>>>            Function_Return False
84071>>>>>>>>>        End
84071>>>>>>>>>>
84071>>>>>>>>>
84071>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
84072>>>>>>>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
84073>>>>>>>>>        If (ghoConnection > 0) Begin
84075>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
84076>>>>>>>>>            If (iIndex <> -1) Begin
84078>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
84079>>>>>>>>>            End
84079>>>>>>>>>>
84079>>>>>>>>>        End
84079>>>>>>>>>>
84079>>>>>>>>>
84079>>>>>>>>>        Function_Return bRetval
84080>>>>>>>>>    End_Function
84081>>>>>>>>>
84081>>>>>>>>>End_Class
84082>>>>>>>Use vWin32fh.pkg
84082>>>>>>>
84082>>>>>>>//
84082>>>>>>>Class cDbUpdateFunctionLibrary is a cObject
84083>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
84084>>>>>>>>
84084>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
84086>>>>>>>>    Integer iStart iEnd
84086>>>>>>>>    String sRetval
84086>>>>>>>>
84086>>>>>>>>    Move (Trim(sConnect)) to sConnect
84087>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
84088>>>>>>>>    If (iStart = 0) Begin
84090>>>>>>>>        Function_Return ""
84091>>>>>>>>    End
84091>>>>>>>>>
84091>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
84092>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
84093>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
84095>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
84096>>>>>>>>    End
84096>>>>>>>>>
84096>>>>>>>>    Else Begin
84097>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
84098>>>>>>>>    End
84098>>>>>>>>>
84098>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
84100>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
84101>>>>>>>>        Decrement iEnd
84102>>>>>>>>    End
84102>>>>>>>>>
84102>>>>>>>>    If (iEnd <> 0) Begin
84104>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
84105>>>>>>>>    End
84105>>>>>>>>>
84105>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
84106>>>>>>>>
84106>>>>>>>>    Function_Return (Trim(sRetval))
84107>>>>>>>>End_Function
84108>>>>>>>>
84108>>>>>>>>
84108>>>>>>>
84108>>>>>>>    Procedure Construct_Object
84110>>>>>>>        Handle ho
84110>>>>>>>        Forward Send Construct_Object
84112>>>>>>>
84112>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84113>>>>>>>
84113>>>>>>>        Send CreateDbUpdateLibraryProperties
84114>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
84114>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
84114>>>>>>>        // etc settings.
84114>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
84116>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
84117>>>>>>>            Set phoSQLConnectionHandler to ho
84118>>>>>>>        End
84118>>>>>>>>
84118>>>>>>>
84118>>>>>>>    End_Procedure
84119>>>>>>>
84119>>>>>>>    Procedure End_Construct_Object
84121>>>>>>>        Forward Send End_Construct_Object
84123>>>>>>>    End_Procedure
84124>>>>>>>
84124>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84124>>>>>>>    //
84124>>>>>>>
84124>>>>>>>    // Function for creating a new *Database*.
84124>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84124>>>>>>>    // Returns True if successful.
84124>>>>>>>    // ToDo: Only works for MS-SQL...
84124>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84126>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString sCreateDatabaseKeyWord sSelectFromWhereName
84126>>>>>>>        Handle hConnection hStmt hoSQLManager
84126>>>>>>>        Integer iFetchResult iDbType
84126>>>>>>>        Boolean bOK bMertechDriver
84126>>>>>>>
84126>>>>>>>        Get piDbType to iDbType
84127>>>>>>>        If (iDbType <> EN_DbTypeMSSQL) Begin
84129>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
84130>>>>>>>>
84130>>>>>>>            Function_Return False
84131>>>>>>>        End
84131>>>>>>>>
84131>>>>>>>
84131>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84132>>>>>>>        If (bMertechDriver = False) Begin
84134>>>>>>>            Get phoSQLManager to hoSQLManager
84135>>>>>>>        End
84135>>>>>>>>
84135>>>>>>>        Else Begin
84136>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
84137>>>>>>>        End
84137>>>>>>>>
84137>>>>>>>
84137>>>>>>>        Get psConnectionID     to sConnectionID
84138>>>>>>>        Get psConnectionString to sConnectionString
84139>>>>>>>        Move 0 to LastErr
84140>>>>>>>
84140>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84141>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84142>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84143>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84145>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84146>>>>>>>>
84146>>>>>>>            Function_Return False
84147>>>>>>>        End
84147>>>>>>>>
84147>>>>>>>
84147>>>>>>>        Get SqlOpen of hConnection to hStmt
84148>>>>>>>
84148>>>>>>>        If (hStmt = 0) Begin
84150>>>>>>>            Send SqlDisconnect of hoSQLManager
84151>>>>>>>            Error DFERR_PROGRAM CS_SQLConnectError
84152>>>>>>>>
84152>>>>>>>            Function_Return False
84153>>>>>>>        End
84153>>>>>>>>
84153>>>>>>>
84153>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84154>>>>>>>        Get _SqlSelectFromWhereName to sSelectFromWhereName
84155>>>>>>>        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84156>>>>>>>
84156>>>>>>>        // Check if database exists
84156>>>>>>>        Send SqlExecDirect of hStmt sSQL
84157>>>>>>>        Get SqlFetch of hStmt to iFetchResult
84158>>>>>>>        Send SqlClose of hStmt
84159>>>>>>>        Send SqlDisconnect of hConnection
84160>>>>>>>
84160>>>>>>>        // If database already exists we're out of here!
84160>>>>>>>        // Note that we return True as this is not an error.
84160>>>>>>>        If (iFetchResult > 0) Begin
84162>>>>>>>            Function_Return True
84163>>>>>>>        End
84163>>>>>>>>
84163>>>>>>>
84163>>>>>>>        // Database doesn't exist, create it.
84163>>>>>>>        If (iFetchResult = 0) Begin
84165>>>>>>>            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84166>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84167>>>>>>>
84167>>>>>>>            Send SqlUtilExecuteQuery sSQL1 sDriverID
84168>>>>>>>
84168>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84169>>>>>>>            If (LastErr = CLIERR_GENERAL_ERROR) Begin
84171>>>>>>>               Function_Return False
84172>>>>>>>            End
84172>>>>>>>>
84172>>>>>>>
84172>>>>>>>            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84172>>>>>>>            Sleep 1
84173>>>>>>>            Send SqlUtilExecuteQuery sSQL sDriverID
84174>>>>>>>        End
84174>>>>>>>>
84174>>>>>>>
84174>>>>>>>        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
84174>>>>>>>        // the one we just created.
84174>>>>>>>        If (bUpdateConnectionString = True) Begin
84176>>>>>>>            Set psDatabase to sDatabase
84177>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84177>>>>>>>            If (bPermanantly = True) Begin
84179>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84181>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84182>>>>>>>                End
84182>>>>>>>>
84182>>>>>>>            End
84182>>>>>>>>
84182>>>>>>>        End
84182>>>>>>>>
84182>>>>>>>
84182>>>>>>>        Function_Return (Err = False)
84183>>>>>>>    End_Function
84184>>>>>>>
84184>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84184>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84184>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84184>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84184>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84184>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84186>>>>>>>        Handle hToTable
84186>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bCopyData
84186>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName sEmpty sConnectionID sConnectionString
84186>>>>>>>        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase
84186>>>>>>>        tSQLConnection SQLConnection
84186>>>>>>>        tSQLConnection SQLConnection
84186>>>>>>>        Integer iPos iMaxRecords
84186>>>>>>>
84186>>>>>>>        Get psDriverID to sDriverID
84187>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84188>>>>>>>        If (bExists = False) Begin
84190>>>>>>>            Function_Return False
84191>>>>>>>        End
84191>>>>>>>>
84191>>>>>>>
84191>>>>>>>        If (num_arguments > 1) Begin
84193>>>>>>>            Move bCpyDat to bCopyData
84194>>>>>>>        End
84194>>>>>>>>
84194>>>>>>>        Else Begin
84195>>>>>>>            Move False to bCopyData
84196>>>>>>>        End
84196>>>>>>>>
84196>>>>>>>
84196>>>>>>>        Open hTable
84198>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84201>>>>>>>        If (bOpened = False) Begin
84203>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84204>>>>>>>>
84204>>>>>>>            Function_Return False
84205>>>>>>>        End
84205>>>>>>>>
84205>>>>>>>        Move 0 to hToTable
84206>>>>>>>
84206>>>>>>>        Move 16711679 to iMaxRecords
84207>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84210>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
84211>>>>>>>        If (iPos > 0) Begin
84213>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84214>>>>>>>        End
84214>>>>>>>>
84214>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84217>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
84218>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
84219>>>>>>>
84219>>>>>>>        If (ghoProgressBar <> 0) Begin
84221>>>>>>>            Send DoAdvance of ghoProgressBar
84222>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84223>>>>>>>        End
84223>>>>>>>>
84223>>>>>>>
84223>>>>>>>        Move False to Err
84224>>>>>>>
84224>>>>>>>        Structure_Start hToTable DATAFLEX_ID
84225>>>>>>>            Structure_Copy hTable to hToTable
84226>>>>>>>
84226>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84229>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84232>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84235>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84238>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84241>>>>>>>
84241>>>>>>>        Structure_End hToTable
84243>>>>>>>
84243>>>>>>>        Move (not(Err)) to bOK
84244>>>>>>>        If (bOK = True and bCopyData = True) Begin
84246>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84247>>>>>>>        End
84247>>>>>>>>
84247>>>>>>>
84247>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84248>>>>>>>        If (bMertechDriver = True) Begin
84250>>>>>>>            Open hTable
84252>>>>>>>        End
84252>>>>>>>>
84252>>>>>>>
84252>>>>>>>        // This must be after copying data...
84252>>>>>>>        If (Err = False) Begin
84254>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84257>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84260>>>>>>>        End
84260>>>>>>>>
84260>>>>>>>        Move (not(Err)) to bOK
84261>>>>>>>
84261>>>>>>>        Function_Return (bOK = True)
84262>>>>>>>    End_Function
84263>>>>>>>
84263>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
84263>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84263>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
84265>>>>>>>        String sTableName sSQLString sPath sVal sCreateTable sDriverID
84265>>>>>>>        Integer iRetval iDbType
84265>>>>>>>        Boolean bExists bOK
84265>>>>>>>
84265>>>>>>>        Get psDriverID to sDriverID
84266>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84267>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84268>>>>>>>        If (bExists = True) Begin
84270>>>>>>>            Function_Return False
84271>>>>>>>        End
84271>>>>>>>>
84271>>>>>>>
84271>>>>>>>        Get psDataPathFirstPart to sPath
84272>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84273>>>>>>>
84273>>>>>>>        Get piDbType to iDbType
84274>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84275>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84276>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84277>>>>>>>
84277>>>>>>>        Move False to Err
84278>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84279>>>>>>>
84279>>>>>>>        Function_Return (Err = False)
84280>>>>>>>    End_Function
84281>>>>>>>
84281>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84281>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84281>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84283>>>>>>>        String sSQLString sPath sVal sCreateTable sDriverID
84283>>>>>>>        Integer iRetval iDbType
84283>>>>>>>        Boolean bExists bOK
84283>>>>>>>
84283>>>>>>>        Get psDriverID to sDriverID
84284>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84285>>>>>>>        If (bExists = True) Begin
84287>>>>>>>            Function_Return False
84288>>>>>>>        End
84288>>>>>>>>
84288>>>>>>>
84288>>>>>>>        Get psDataPathFirstPart to sPath
84289>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84290>>>>>>>        If (bExists = True) Begin
84292>>>>>>>            // ToDo: What should we do if an .int file already exists?
84292>>>>>>>        End
84292>>>>>>>>
84292>>>>>>>
84292>>>>>>>        Get piDbType to iDbType
84293>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84294>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84295>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84296>>>>>>>
84296>>>>>>>        Move False to Err
84297>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84298>>>>>>>
84298>>>>>>>        Function_Return (Err = False)
84299>>>>>>>    End_Function
84300>>>>>>>
84300>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
84300>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84300>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
84300>>>>>>>    Function SqlTableRemove Integer hTable Returns Boolean
84302>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
84302>>>>>>>        Integer iRetval iDbType
84302>>>>>>>        Boolean bExists bMertechDriver bOK
84302>>>>>>>
84302>>>>>>>        Get psDriverID to sDriverID
84303>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84304>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84305>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84306>>>>>>>        If (bExists = False) Begin
84308>>>>>>>            Function_Return False
84309>>>>>>>        End
84309>>>>>>>>
84309>>>>>>>
84309>>>>>>>        Get psDataPathFirstPart to sPath
84310>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
84311>>>>>>>
84311>>>>>>>        Get piDbType to iDbType
84312>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84313>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84314>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84315>>>>>>>
84315>>>>>>>        Move False to Err
84316>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84317>>>>>>>
84317>>>>>>>        // We also need to remove the cache-file since the table has been changed
84317>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84318>>>>>>>
84318>>>>>>>        Function_Return (Err = False)
84319>>>>>>>    End_Function
84320>>>>>>>
84320>>>>>>>    // First deletes the data cache file and then drops the passed data table.
84320>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84322>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84322>>>>>>>        Integer iRetval iDbType
84322>>>>>>>        Boolean bMertechDriver bOK
84322>>>>>>>
84322>>>>>>>        Get psDriverID to sDriverID
84323>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84324>>>>>>>        Get psDataPathFirstPart to sPath
84325>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
84326>>>>>>>
84326>>>>>>>        Get piDbType to iDbType
84327>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84328>>>>>>>        Get psSchema to sSchema
84329>>>>>>>        If (sSchema = "") Begin
84331>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84332>>>>>>>        End
84332>>>>>>>>
84332>>>>>>>        Move (Uppercase(sTableName)) to sVal
84333>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
84335>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84336>>>>>>>        End
84336>>>>>>>>
84336>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84337>>>>>>>
84337>>>>>>>        Move False to Err
84338>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84339>>>>>>>
84339>>>>>>>        // We also need to remove the cache-file since the table has been changed
84339>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84340>>>>>>>
84340>>>>>>>        Function_Return (Err = False)
84341>>>>>>>    End_Function
84342>>>>>>>
84342>>>>>>>    // *** Sql View Messages ***
84342>>>>>>>
84342>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
84342>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
84344>>>>>>>        String sDriverID sSQLString sPath sDropViewKeyWord
84344>>>>>>>        Integer iRetval
84344>>>>>>>        Boolean bMertechDriver bOK
84344>>>>>>>
84344>>>>>>>        Get psDriverID to sDriverID
84345>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84346>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
84347>>>>>>>
84347>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
84348>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
84349>>>>>>>        Set psSQLStatementString to sSQLString
84350>>>>>>>
84350>>>>>>>        // As we don't check if the view exist or not, it might happen
84350>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
84350>>>>>>>        Move False to Err
84351>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84352>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84353>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84354>>>>>>>        Move 0 to LastErr
84355>>>>>>>
84355>>>>>>>        // We also need to remove the cache-file since the table has been changed
84355>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
84356>>>>>>>
84356>>>>>>>        Function_Return (Err = False)
84357>>>>>>>    End_Function
84358>>>>>>>
84358>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84360>>>>>>>        Boolean bOK
84360>>>>>>>        Integer iDbType 
84360>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84360>>>>>>>        
84360>>>>>>>        Get psDriverID to sDriverID
84361>>>>>>>        Get piDbType   to iDbType
84362>>>>>>>        
84362>>>>>>>        Case Begin
84362>>>>>>>            Case (iDbType = EN_DbTypeDB2)
84364>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84365>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84366>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84367>>>>>>>            Break
84368>>>>>>>
84368>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84371>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84372>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84373>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
84374>>>>>>>            Break
84375>>>>>>>
84375>>>>>>>            Case (iDbType = EN_DbTypeOracle)
84378>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84379>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84380>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84381>>>>>>>            Break
84382>>>>>>>
84382>>>>>>>            Case (iDbType = EN_DbTypePostgre)
84385>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84386>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84387>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84388>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
84389>>>>>>>            Break
84390>>>>>>>
84390>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
84393>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84394>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84395>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84396>>>>>>>            Break
84397>>>>>>>        Case End   
84397>>>>>>>        
84397>>>>>>>        Move False to Err
84398>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84399>>>>>>>        Move (Err = False) to bOK
84400>>>>>>>        
84400>>>>>>>        Function_Return bOK
84401>>>>>>>    End_Function
84402>>>>>>>    
84402>>>>>>>     // *** Sql Column Messages ***
84402>>>>>>>    //
84402>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84402>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84404>>>>>>>        Integer iColumn iDbType iLength iDecimals
84404>>>>>>>        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
84404>>>>>>>        String sTableName sDriverID sUpdate sSet sNoCountOn
84404>>>>>>>        Boolean bExists bOK bInitializeValue
84404>>>>>>>
84404>>>>>>>        Get psDriverID to sDriverID
84405>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84406>>>>>>>        If (bOK = False) Begin
84408>>>>>>>            Function_Return False
84409>>>>>>>        End
84409>>>>>>>>
84409>>>>>>>
84409>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84410>>>>>>>        If (sTableName = "") Begin
84412>>>>>>>            Function_Return False
84413>>>>>>>        End
84413>>>>>>>>
84413>>>>>>>
84413>>>>>>>        If (num_arguments > 3) Begin
84415>>>>>>>            Move iLen     to iLength
84416>>>>>>>            Move iDec     to iDecimals
84417>>>>>>>            Move bInitVal to bInitializeValue
84418>>>>>>>            Move sColVal  to sColumnValue
84419>>>>>>>        End
84419>>>>>>>>
84419>>>>>>>
84419>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84420>>>>>>>
84420>>>>>>>        Function_Return (bOK = True)
84421>>>>>>>    End_Function
84422>>>>>>>
84422>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84422>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84424>>>>>>>        Integer iColumn iDbType iLength iDecimals iDriver
84424>>>>>>>        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
84424>>>>>>>        String sDriverID sUpdate sSet sNoCountOn sNotNull
84424>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84424>>>>>>>        Handle hTable
84424>>>>>>>
84424>>>>>>>        Get psDriverID to sDriverID
84425>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84426>>>>>>>        If (bOK = False) Begin
84428>>>>>>>            Function_Return False
84429>>>>>>>        End
84429>>>>>>>>
84429>>>>>>>
84429>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84430>>>>>>>        If (hTable = 0) Begin
84432>>>>>>>            Get NextFreeFilelistSlot to hTable
84433>>>>>>>        End 
84433>>>>>>>>
84433>>>>>>>
84433>>>>>>>        Get piDbType to iDbType
84434>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84434>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84435>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84437>>>>>>>            Function_Return False
84438>>>>>>>        End
84438>>>>>>>>
84438>>>>>>>
84438>>>>>>>        Get DriverIndex sDriverID to iDriver
84439>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84442>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84445>>>>>>>
84445>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84446>>>>>>>        If (num_arguments > 3) Begin
84448>>>>>>>            Move iLen     to iLength
84449>>>>>>>            Move iDec     to iDecimals
84450>>>>>>>            Move bInitVal to bInitializeValue
84451>>>>>>>            Move sColVal  to sColumnValue
84452>>>>>>>        End
84452>>>>>>>>
84452>>>>>>>
84452>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
84453>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84454>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84455>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84456>>>>>>>
84456>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84457>>>>>>>        If (bFixed = False) Begin
84459>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84460>>>>>>>        End
84460>>>>>>>>
84460>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84461>>>>>>>
84461>>>>>>>        Move False to Err
84462>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84463>>>>>>>
84463>>>>>>>        If (bInitializeValue = True and Err = False) Begin
84465>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84466>>>>>>>        End
84466>>>>>>>>
84466>>>>>>>
84466>>>>>>>        If (Err = False) Begin
84468>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84469>>>>>>>        End
84469>>>>>>>>
84469>>>>>>>
84469>>>>>>>        Move (not(Err)) to bRetval
84470>>>>>>>
84470>>>>>>>        // We also need to remove the cache-file since the table has been changed
84470>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84471>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84474>>>>>>>
84474>>>>>>>        Function_Return bRetval
84475>>>>>>>    End_Function
84476>>>>>>>    
84476>>>>>>>    // To update all current rows for a table column with a common value.
84476>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84478>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
84478>>>>>>>        Boolean bRetval bSQLDriver 
84478>>>>>>>        Integer iCurrErr
84478>>>>>>>        
84478>>>>>>>        Move False to bRetval
84479>>>>>>>        Get psDriverID to sDriverID
84480>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
84481>>>>>>>        If (bSQLDriver = False) Begin
84483>>>>>>>            Function_Return bRetval
84484>>>>>>>        End
84484>>>>>>>>
84484>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84485>>>>>>>        
84485>>>>>>>        Move Err to iCurrErr
84486>>>>>>>        Move False to Err
84487>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84488>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84489>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84490>>>>>>>        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84491>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84492>>>>>>>        Move (Err = False) to bRetval
84493>>>>>>>        Move iCurrErr to Err
84494>>>>>>>        
84494>>>>>>>        Function_Return bRetval
84495>>>>>>>    End_Function
84496>>>>>>>
84496>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84496>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84496>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84498>>>>>>>        Integer iColumn iDbType iLength iDecimals
84498>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sTableName sNotNull
84498>>>>>>>        Boolean bExists bOK bFixed
84498>>>>>>>
84498>>>>>>>        Get psDriverID to sDriverID
84499>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84500>>>>>>>        If (bOK = False) Begin
84502>>>>>>>            Function_Return False
84503>>>>>>>        End
84503>>>>>>>>
84503>>>>>>>
84503>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84504>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84505>>>>>>>
84505>>>>>>>        Function_Return (Err = False)
84506>>>>>>>    End_Function
84507>>>>>>>
84507>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84507>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84507>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84507>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84509>>>>>>>        Integer iColumn iDbType iLength iDecimals
84509>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sNotNull
84509>>>>>>>        Boolean bExists bOK bFixed
84509>>>>>>>        Handle hTable
84509>>>>>>>
84509>>>>>>>        Get psDriverID to sDriverID
84510>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84511>>>>>>>        If (bOK = False) Begin
84513>>>>>>>            Function_Return False
84514>>>>>>>        End
84514>>>>>>>>
84514>>>>>>>
84514>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84515>>>>>>>        If (hTable = 0) Begin
84517>>>>>>>            Get NextFreeFilelistSlot to hTable
84518>>>>>>>        End
84518>>>>>>>>
84518>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84519>>>>>>>        If (bExists = True) Begin
84521>>>>>>>            Function_Return False
84522>>>>>>>        End
84522>>>>>>>>
84522>>>>>>>
84522>>>>>>>        If (num_arguments > 3) Begin
84524>>>>>>>            Move iLen to iLength
84525>>>>>>>        End
84525>>>>>>>>
84525>>>>>>>        If (num_arguments > 4) Begin
84527>>>>>>>            Move iDec to iDecimals
84528>>>>>>>        End
84528>>>>>>>>
84528>>>>>>>
84528>>>>>>>        Get piDbType to iDbType
84529>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84530>>>>>>>
84530>>>>>>>        Move False to Err
84531>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84532>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84533>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84534>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84535>>>>>>>
84535>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84536>>>>>>>        If (bFixed = False) Begin
84538>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84539>>>>>>>        End
84539>>>>>>>>
84539>>>>>>>
84539>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84540>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84541>>>>>>>
84541>>>>>>>        // We also need to remove the cache-file since the table has been changed
84541>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84542>>>>>>>
84542>>>>>>>        Function_Return (Err = False)
84543>>>>>>>    End_Function
84544>>>>>>>
84544>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84546>>>>>>>        Boolean bOK bErr bIsSQLDriver
84546>>>>>>>        String sDriverID
84546>>>>>>>
84546>>>>>>>        Get psDriverID to sDriverID
84547>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84548>>>>>>>        If (bIsSQLDriver = False) Begin
84550>>>>>>>            Function_Return False
84551>>>>>>>        End
84551>>>>>>>>
84551>>>>>>>
84551>>>>>>>        Move Err to bErr
84552>>>>>>>        Move False to bErr
84553>>>>>>>
84553>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84553>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84553>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84554>>>>>>>
84554>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84557>>>>>>>        Move (not(Err)) to bOK
84558>>>>>>>        Move bErr to Err
84559>>>>>>>
84559>>>>>>>        Function_Return bOK
84560>>>>>>>    End_Function
84561>>>>>>>
84561>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84563>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84563>>>>>>>        String sDriverID
84563>>>>>>>
84563>>>>>>>        Get psDriverID to sDriverID
84564>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84565>>>>>>>        If (bIsSQLDriver = False) Begin
84567>>>>>>>            Function_Return False
84568>>>>>>>        End
84568>>>>>>>>
84568>>>>>>>
84568>>>>>>>        Move Err to bErr
84569>>>>>>>        Move False to bErr
84570>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84573>>>>>>>        If (bNullable = bCurrentState) Begin
84575>>>>>>>            Function_Return True
84576>>>>>>>        End
84576>>>>>>>>
84576>>>>>>>
84576>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84579>>>>>>>        If (bOpen = False) Begin
84581>>>>>>>            Get AutoConnectionIDLogin to bOK
84582>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84583>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84584>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84585>>>>>>>            Open hTable
84587>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84588>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84589>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84590>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84593>>>>>>>        End
84593>>>>>>>>
84593>>>>>>>        If (bOpen = True) Begin
84595>>>>>>>            Structure_Start hTable sDriverID
84596>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84599>>>>>>>            Structure_End hTable
84601>>>>>>>        End
84601>>>>>>>>
84601>>>>>>>
84601>>>>>>>        Move (not(Err)) to bOK
84602>>>>>>>        Move bErr to Err
84603>>>>>>>
84603>>>>>>>        Function_Return bOK
84604>>>>>>>    End_Function
84605>>>>>>>
84605>>>>>>>    // Drop column by its table handle
84605>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84607>>>>>>>        Integer iColumn idbType
84607>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn sVal sTableName
84607>>>>>>>        Boolean bExists bOK
84607>>>>>>>
84607>>>>>>>        Get psDriverID to sDriverID
84608>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84609>>>>>>>        If (bOK = False) Begin
84611>>>>>>>            Function_Return False
84612>>>>>>>        End
84612>>>>>>>>
84612>>>>>>>
84612>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84613>>>>>>>        If (sTableName = "") Begin
84615>>>>>>>            Function_Return False
84616>>>>>>>        End
84616>>>>>>>>
84616>>>>>>>
84616>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84617>>>>>>>
84617>>>>>>>        Function_Return (bOK = True)
84618>>>>>>>    End_Function
84619>>>>>>>
84619>>>>>>>    // Drop column by its table name as a string.
84619>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84621>>>>>>>        Integer iColumn iDbType iDriver
84621>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn sVal
84621>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84621>>>>>>>        Handle hTable
84621>>>>>>>
84621>>>>>>>        Get psDriverID to sDriverID
84622>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84623>>>>>>>        If (bOK = False) Begin
84625>>>>>>>            Function_Return False
84626>>>>>>>        End
84626>>>>>>>>
84626>>>>>>>
84626>>>>>>>        Get DriverIndex sDriverID to iDriver
84627>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84630>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84633>>>>>>>
84633>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84634>>>>>>>        If (hTable <> 0) Begin
84636>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
84637>>>>>>>            If (bExists = False) Begin
84639>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84642>>>>>>>                Function_Return False
84643>>>>>>>            End
84643>>>>>>>>
84643>>>>>>>        End
84643>>>>>>>>
84643>>>>>>>
84643>>>>>>>        Get piDbType to iDbType
84644>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
84646>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
84647>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
84648>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84651>>>>>>>            Function_Return bOK
84652>>>>>>>        End
84652>>>>>>>>
84652>>>>>>>
84652>>>>>>>        Move False to Err
84653>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
84654>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84655>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
84656>>>>>>>
84656>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
84657>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84658>>>>>>>        Move (not(Err)) to bRetval
84659>>>>>>>
84659>>>>>>>        // We also need to remove the cache-file since the table has been changed
84659>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84660>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84663>>>>>>>
84663>>>>>>>        Function_Return bRetval
84664>>>>>>>    End_Function
84665>>>>>>>
84665>>>>>>>    // Rename a field/column by table handle (filelist number)
84665>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
84667>>>>>>>        Integer iColumn idbType
84667>>>>>>>        String sDriverID sTableName sStmt sAlterTable sRenameColumn sVal sColumnKeyWord
84667>>>>>>>        Boolean bExists bOK
84667>>>>>>>
84667>>>>>>>        Get psDriverID to sDriverID
84668>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84669>>>>>>>        If (bOK = False) Begin
84671>>>>>>>            Function_Return False
84672>>>>>>>        End
84672>>>>>>>>
84672>>>>>>>
84672>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84673>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
84674>>>>>>>
84674>>>>>>>        Function_Return (Err = False)
84675>>>>>>>    End_Function
84676>>>>>>>
84676>>>>>>>    // Rename a field/column by table name.
84676>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
84678>>>>>>>        Integer iColumn iDbType iDataType
84678>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
84678>>>>>>>        Boolean bExists bOK bRetval
84678>>>>>>>        Handle hTable
84678>>>>>>>
84678>>>>>>>        Move sTableName to sOrgTableName
84679>>>>>>>        Get psDriverID to sDriverID
84680>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84681>>>>>>>        If (bOK = False) Begin
84683>>>>>>>            Function_Return False
84684>>>>>>>        End
84684>>>>>>>>
84684>>>>>>>
84684>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84685>>>>>>>        If (sVal = "") Begin
84687>>>>>>>            Function_Return False
84688>>>>>>>        End
84688>>>>>>>>
84688>>>>>>>
84688>>>>>>>        Get piDbType to iDbType
84689>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
84690>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
84691>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
84692>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
84693>>>>>>>
84693>>>>>>>        Case Begin
84693>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
84695>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
84696>>>>>>>                Case Break
84697>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
84697>>>>>>>            Case (iDbType = EN_dbTypeOracle)
84700>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84701>>>>>>>                Case Break
84702>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
84702>>>>>>>            Case (iDbType = EN_dbTypeDB2)
84705>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84706>>>>>>>                Case Break
84707>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
84707>>>>>>>            Case (iDbType = EN_dbTypePostgre)
84710>>>>>>>                Move sOrgTableName to sTableName
84711>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84712>>>>>>>                Case Break
84713>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
84716>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
84716>>>>>>>                Move sOrgTableName to sTableName
84717>>>>>>>                Get psDatabase to sDatabase
84718>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
84719>>>>>>>                If (hTable = 0) Begin
84721>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84722>>>>>>>                    If (bOK = False) Begin
84724>>>>>>>                        Function_Return False
84725>>>>>>>                    End
84725>>>>>>>>
84725>>>>>>>                    Get NextFreeFilelistSlot to hTable
84726>>>>>>>                End
84726>>>>>>>>
84726>>>>>>>                Else Begin
84727>>>>>>>                    Open hTable
84729>>>>>>>                End
84729>>>>>>>>
84729>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
84730>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
84731>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
84732>>>>>>>                Case Break
84733>>>>>>>            Case Else
84733>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
84734>>>>>>>        Case End
84734>>>>>>>
84734>>>>>>>        Move False to Err
84735>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84736>>>>>>>        Move (Err = False) to bRetval
84737>>>>>>>        // We also need to remove the cache-file since the table has been changed
84737>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84738>>>>>>>
84738>>>>>>>        Function_Return bRetval
84739>>>>>>>    End_Function
84740>>>>>>>
84740>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
84742>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
84742>>>>>>>        Boolean bMertechDriver
84742>>>>>>>        Integer iNumCols iCount iSQLType iDataType
84742>>>>>>>        String sValue
84742>>>>>>>
84742>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84743>>>>>>>        If (bMertechDriver = False) Begin
84745>>>>>>>            Get phoSQLManager to hoSQLHandler
84746>>>>>>>        End
84746>>>>>>>>
84746>>>>>>>        Else Begin
84747>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
84748>>>>>>>        End
84748>>>>>>>>
84748>>>>>>>
84748>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
84749>>>>>>>        If (hSQLConnect <> 0) Begin
84751>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
84752>>>>>>>            If (hStmt <> 0) Begin
84754>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
84755>>>>>>>
84755>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
84756>>>>>>>                For iCount from 1 to iNumCols
84762>>>>>>>>
84762>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
84763>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
84765>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
84766>>>>>>>                        Move iNumCols to iCount // We're out of here
84767>>>>>>>                    End
84767>>>>>>>>
84767>>>>>>>                Loop
84768>>>>>>>>
84768>>>>>>>
84768>>>>>>>                Send SQLClose of hStmt
84769>>>>>>>            End
84769>>>>>>>>
84769>>>>>>>            Send SQLDisconnect of hSQLConnect
84770>>>>>>>        End
84770>>>>>>>>
84770>>>>>>>
84770>>>>>>>        Function_Return iDataType
84771>>>>>>>    End_Function
84772>>>>>>>
84772>>>>>>>
84772>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
84772>>>>>>>    // the DbUpdateVersion database revision in.
84772>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
84772>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
84772>>>>>>>    Function SqlCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
84774>>>>>>>        Boolean bOK bOpened
84774>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt sDropColumn
84774>>>>>>>
84774>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84777>>>>>>>        Get _TableNameOnly sTableName to sTableName
84778>>>>>>>        If (sTableName = "") Begin
84780>>>>>>>            Function_Return False
84781>>>>>>>        End
84781>>>>>>>>
84781>>>>>>>
84781>>>>>>>        // This just creates the table and a "dummy" column.
84781>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
84782>>>>>>>        If (bOK = False) Begin
84784>>>>>>>            Function_Return False
84785>>>>>>>        End
84785>>>>>>>>
84785>>>>>>>
84785>>>>>>>        Close hTable
84786>>>>>>>        Move False to Err
84787>>>>>>>
84787>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84788>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84789>>>>>>>        Move "Decimal" to sDataType
84790>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
84791>>>>>>>
84791>>>>>>>        // Adds the "sColumnName" passed to the function
84791>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
84792>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84793>>>>>>>
84793>>>>>>>        // Now we can delete the dummy column:
84793>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
84794>>>>>>>
84794>>>>>>>        // Finally, we attach to the newly created table.
84794>>>>>>>        If (Err = False) Begin
84796>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
84797>>>>>>>        End
84797>>>>>>>>
84797>>>>>>>        Open hTable
84799>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84802>>>>>>>
84802>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
84803>>>>>>>    End_Function
84804>>>>>>>
84804>>>>>>>    // Checks if a column/field name exists in a SQL table definition
84804>>>>>>>    // Returns True if it does
84804>>>>>>>    // Sample:
84804>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
84804>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
84806>>>>>>>        Integer iNumColumns iColumn
84806>>>>>>>        String sColumn sDriverID
84806>>>>>>>        String[] sColumnsArray
84807>>>>>>>        Boolean bExists bOK
84807>>>>>>>
84807>>>>>>>        Move False to bExists
84808>>>>>>>        Get AutoConnectionIDLogin to bOK
84809>>>>>>>        Get psDriverID to sDriverID
84810>>>>>>>
84810>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
84811>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
84812>>>>>>>        Decrement iNumColumns
84813>>>>>>>        For iColumn from 0 to iNumColumns
84819>>>>>>>>
84819>>>>>>>            Move sColumnsArray[iColumn] to sColumn
84820>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
84822>>>>>>>                Move True to bExists
84823>>>>>>>                Move iNumColumns to iColumn // We're out of here
84824>>>>>>>            End
84824>>>>>>>>
84824>>>>>>>        Loop
84825>>>>>>>>
84825>>>>>>>
84825>>>>>>>        Function_Return bExists
84826>>>>>>>    End_Function
84827>>>>>>>
84827>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
84829>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
84829>>>>>>>        Boolean bOpened bOK
84829>>>>>>>        String sColumnName sNativeTypeName
84829>>>>>>>
84829>>>>>>>        Get AutoConnectionIDLogin to bOK
84830>>>>>>>        Get OpenTableExclusive hTable to bOK
84831>>>>>>>        If (bOK = False) Begin
84833>>>>>>>            Function_Return False
84834>>>>>>>        End
84834>>>>>>>>
84834>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84837>>>>>>>        If (bOpened = False) Begin
84839>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
84840>>>>>>>>
84840>>>>>>>            Function_Return False
84841>>>>>>>        End
84841>>>>>>>>
84841>>>>>>>
84841>>>>>>>        Move False to Err
84842>>>>>>>
84842>>>>>>>        Structure_Start hTable
84843>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
84846>>>>>>>
84846>>>>>>>            For iColumn from 1 to iNumColumns
84852>>>>>>>>
84852>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
84855>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
84858>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
84861>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
84864>>>>>>>
84864>>>>>>>                Case Begin
84864>>>>>>>                    Case (iDFType = DF_DATE)
84866>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
84868>>>>>>>                            // Convert datetime to date
84868>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
84871>>>>>>>                        End
84871>>>>>>>>
84871>>>>>>>                        Case Break
84872>>>>>>>                    Case (iDFType = DF_DATETIME)
84875>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
84877>>>>>>>                            // Convert datetime to datetime2
84877>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
84880>>>>>>>                        End
84880>>>>>>>>
84880>>>>>>>                        Case Break
84881>>>>>>>                    Case (iDFType = DF_ASCII)
84884>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
84886>>>>>>>                            // Convert char to varchar
84886>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
84889>>>>>>>                        End
84889>>>>>>>>
84889>>>>>>>                        Case Break
84890>>>>>>>                    Case (iDFType = DF_TEXT)
84893>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
84895>>>>>>>                            // Convert text to varchar(max)
84895>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
84898>>>>>>>                        End
84898>>>>>>>>
84898>>>>>>>                        Case Break
84899>>>>>>>                    Case (iDFType = DF_BINARY)
84902>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
84904>>>>>>>                            // Convert image to varbinary(max)
84904>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
84907>>>>>>>                        End
84907>>>>>>>>
84907>>>>>>>                        Case Break
84908>>>>>>>                Case End
84908>>>>>>>            Loop
84909>>>>>>>>
84909>>>>>>>        Structure_End hTable
84911>>>>>>>
84911>>>>>>>        Function_Return (Err = False)
84912>>>>>>>    End_Function
84913>>>>>>>
84913>>>>>>>    // Does three things with auxilirary files;
84913>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
84913>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
84913>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
84913>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
84915>>>>>>>        String sDataPath sDDSrcPath sVal sDriverID
84915>>>>>>>        Boolean bOK bExists bMertechDriver
84915>>>>>>>        Integer iCount iItems iCh iPos
84915>>>>>>>
84915>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
84915>>>>>>>        If (sTableName contains ".") Begin
84917>>>>>>>            Move (Pos(".", sTableName)) to iPos
84918>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
84919>>>>>>>        End
84919>>>>>>>>
84919>>>>>>>
84919>>>>>>>        Get psDriverID to sDriverID
84920>>>>>>>        Get psDataPathFirstPart to sDataPath
84921>>>>>>>        Get vFolderExists sDataPath to bOK
84922>>>>>>>        If (bOK = False) Begin
84924>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
84925>>>>>>>>
84925>>>>>>>            Function_Return False
84926>>>>>>>        End
84926>>>>>>>>
84926>>>>>>>
84926>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
84927>>>>>>>        // First delete the cache file:
84927>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
84928>>>>>>>
84928>>>>>>>        Get Seq_New_Channel to iCh
84929>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84931>>>>>>>            Function_Return False
84932>>>>>>>        End
84932>>>>>>>>
84932>>>>>>>
84932>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
84933>>>>>>>        If (bExists = False) Begin
84935>>>>>>>            Function_Return False
84936>>>>>>>        End
84936>>>>>>>>
84936>>>>>>>
84936>>>>>>>        // Add the new column name to the .tag file:
84936>>>>>>>        Append_Output channel iCh (sDataPath + sTableName + ".tag")
84938>>>>>>>            Writeln channel iCh sColumnName
84941>>>>>>>        Close_Output
84942>>>>>>>
84942>>>>>>>        // If in development environment; output new .fd file:
84942>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
84943>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84944>>>>>>>        If (iCount > 1) Begin
84946>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84947>>>>>>>        End
84947>>>>>>>>
84947>>>>>>>        Get vFolderExists sDDSrcPath to bExists
84948>>>>>>>        If (bExists = True) Begin
84950>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
84951>>>>>>>            Move False to Err
84952>>>>>>>            Get AutoConnectionIDLogin to bOK
84953>>>>>>>            If (hTable <> 0) Begin
84955>>>>>>>                Open hTable
84957>>>>>>>            End
84957>>>>>>>>
84957>>>>>>>            Else Begin
84958>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84959>>>>>>>            End
84959>>>>>>>>
84959>>>>>>>
84959>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
84962>>>>>>>            If (bOK = True) Begin
84964>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84966>>>>>>>            End
84966>>>>>>>>
84966>>>>>>>            If (Err = True) Begin
84968>>>>>>>                Move False to bOK
84969>>>>>>>            End
84969>>>>>>>>
84969>>>>>>>        End
84969>>>>>>>>
84969>>>>>>>
84969>>>>>>>        Function_Return (bOK = True)
84970>>>>>>>    End_Function
84971>>>>>>>
84971>>>>>>>    // The table must already exist in the filelist for this function to work.
84971>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
84971>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
84973>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
84973>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
84973>>>>>>>        String[] sIndexArray
84974>>>>>>>        Integer iCount iCh iSize
84974>>>>>>>
84974>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
84975>>>>>>>        Get psConnectionString to sConnectionString
84976>>>>>>>
84976>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
84977>>>>>>>        If (bANSI = False) Begin
84979>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
84980>>>>>>>        End
84980>>>>>>>>
84980>>>>>>>
84980>>>>>>>        Get psDataPathFirstPart to sDataPath
84981>>>>>>>        Get vFolderExists sDataPath to bOK
84982>>>>>>>        If (bOK = False) Begin
84984>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
84985>>>>>>>>
84985>>>>>>>            Function_Return False
84986>>>>>>>        End
84986>>>>>>>>
84986>>>>>>>        Get vFolderFormat sDataPath to sDataPath
84987>>>>>>>
84987>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84990>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84993>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
84994>>>>>>>        Move sLogicalName  to sPhysicalFileName
84995>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
84996>>>>>>>
84996>>>>>>>        Get IsMertechDriver sDriverID to bMertech
84997>>>>>>>        If (bMertech = True) Begin
84999>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
84999>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
84999>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
84999>>>>>>>            Function_Return (bOK = True)
85000>>>>>>>        End
85000>>>>>>>>
85000>>>>>>>
85000>>>>>>>        Get psSchema hTable to sSchemaName
85001>>>>>>>        If (sSchemaName = "") Begin
85003>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
85004>>>>>>>        End
85004>>>>>>>>
85004>>>>>>>
85004>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
85004>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
85005>>>>>>>        If (bExists = True) Begin
85007>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
85008>>>>>>>        End
85008>>>>>>>>
85008>>>>>>>
85008>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
85009>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
85010>>>>>>>
85010>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
85011>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
85016>>>>>>>            If (bUseConnectionID = True) Begin
85018>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
85025>>>>>>>            End
85025>>>>>>>>
85025>>>>>>>            Else Begin
85026>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
85033>>>>>>>            End
85033>>>>>>>>
85033>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
85038>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
85043>>>>>>>            // There seems to be a new order how these are set from DF19.
85043>>>>>>>            If (bSysFile = True) Begin
85045>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
85050>>>>>>>            End
85050>>>>>>>>
85050>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
85055>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
85060>>>>>>>            If (bSysFile = True) Begin
85062>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
85067>>>>>>>            End
85067>>>>>>>>
85067>>>>>>>
85067>>>>>>>            If (bSysFile = False) Begin
85069>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
85070>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
85071>>>>>>>                If (iSize > 0) Begin
85073>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
85076>>>>>>>                    Writeln channel iCh // Just an empty line
85078>>>>>>>                End
85078>>>>>>>>
85078>>>>>>>                Decrement iSize
85079>>>>>>>                For iCount from 0 to iSize
85085>>>>>>>>
85085>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
85088>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
85091>>>>>>>                    Writeln channel iCh
85093>>>>>>>                Loop
85094>>>>>>>>
85094>>>>>>>            End
85094>>>>>>>>
85094>>>>>>>        Send Seq_Close_Channel iCh
85095>>>>>>>
85095>>>>>>>        // Wait a sec for Windows to finish writing the file:
85095>>>>>>>        Sleep 1
85096>>>>>>>
85096>>>>>>>        Function_Return (bOK = True)
85097>>>>>>>    End_Function
85098>>>>>>>
85098>>>>>>>    // Message for changing .int files to use connection ID's
85098>>>>>>>    //
85098>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85098>>>>>>>    // OR changes an existing connection id to a new id.
85098>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85098>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85098>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
85100>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
85100>>>>>>>        String[] sFilesData
85101>>>>>>>        Boolean bExists bOK bCancel
85101>>>>>>>        Integer iSize iCount
85101>>>>>>>
85101>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85102>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85103>>>>>>>        If (iSize = 0) Begin    
85105>>>>>>>            If (ghoStatusPanel <> 0) Begin
85107>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85109>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85110>>>>>>>                End
85110>>>>>>>>
85110>>>>>>>            End
85110>>>>>>>>
85110>>>>>>>            Send Info_Box "No .int files found! Nothing was changed."
85111>>>>>>>            Procedure_Return
85112>>>>>>>        End
85112>>>>>>>>
85112>>>>>>>
85112>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85113>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85114>>>>>>>        Decrement iSize
85115>>>>>>>        For iCount from 0 to iSize
85121>>>>>>>>
85121>>>>>>>            Move sFilesData[iCount] to sFileName
85122>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85122>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85123>>>>>>>            If (ghoStatusPanel <> 0) Begin
85125>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85127>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85128>>>>>>>                    If (bCancel = True) Begin
85130>>>>>>>                        Send Deactivate of ghoStatusPanel
85131>>>>>>>                        Procedure_Return
85132>>>>>>>                    End
85132>>>>>>>>
85132>>>>>>>                End
85132>>>>>>>>
85132>>>>>>>            End
85132>>>>>>>>
85132>>>>>>>        Loop
85133>>>>>>>>
85133>>>>>>>
85133>>>>>>>        Get psDriverID to sDriverID
85134>>>>>>>
85134>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85134>>>>>>>        Move "" to sFileName
85135>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85137>>>>>>>            Move "MSSQLDrv.int" to sFileName
85138>>>>>>>        End
85138>>>>>>>>
85138>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85140>>>>>>>            Move "DB2_Drv.int" to sFileName
85141>>>>>>>        End
85141>>>>>>>>
85141>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85143>>>>>>>            Move "ODBC_Drv.int" to sFileName
85144>>>>>>>        End
85144>>>>>>>>
85144>>>>>>>        If (sFileName <> "") Begin
85146>>>>>>>            Move "" to sDriverFile
85147>>>>>>>            Get_File_Path sFileName to sDriverFile
85148>>>>>>>            If (sDriverFile <> "") Begin
85150>>>>>>>                Get psConnectionString to sConnectionString
85151>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85152>>>>>>>            End
85152>>>>>>>>
85152>>>>>>>        End
85152>>>>>>>>
85152>>>>>>>    End_Procedure
85153>>>>>>>
85153>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85153>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85155>>>>>>>        String[] sDatabaseArray
85156>>>>>>>        String sVal sServer sDriverID
85156>>>>>>>        Integer iCount iSize iPos
85156>>>>>>>        Boolean bExists
85156>>>>>>>        tSQLConnection SQLConnection
85156>>>>>>>        tSQLConnection SQLConnection
85156>>>>>>>
85156>>>>>>>        Move False to bExists
85157>>>>>>>        Get psDriverID to sDriverID
85158>>>>>>>        // DB2 doesn't need to have a "Database" name, so we always return True.
85158>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85160>>>>>>>            Function_Return bExists
85161>>>>>>>        End
85161>>>>>>>>
85161>>>>>>>
85161>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85162>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85164>>>>>>>            Function_Return False
85165>>>>>>>        End
85165>>>>>>>>
85165>>>>>>>
85165>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85166>>>>>>>        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
85167>>>>>>>        If (sServer contains "/") Begin
85169>>>>>>>            Move (Pos("/", sServer)) to iPos
85170>>>>>>>            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
85171>>>>>>>        End
85171>>>>>>>>
85171>>>>>>>
85171>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85172>>>>>>>        Decrement iSize
85173>>>>>>>        For iCount from 0 to iSize
85179>>>>>>>>
85179>>>>>>>            Move sDatabaseArray[iCount] to sVal
85180>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85182>>>>>>>                Move True to bExists
85183>>>>>>>            End
85183>>>>>>>>
85183>>>>>>>        Loop
85184>>>>>>>>
85184>>>>>>>
85184>>>>>>>        Function_Return bExists
85185>>>>>>>    End_Function
85186>>>>>>>
85186>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85186>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85188>>>>>>>        String sTableName sVal
85188>>>>>>>        Boolean bExists
85188>>>>>>>        String[] sTablesArray
85189>>>>>>>        Integer iSize iCount
85189>>>>>>>
85189>>>>>>>        Move False to bExists
85190>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85191>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
85192>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85193>>>>>>>        Decrement iSize
85194>>>>>>>        For iCount from 0 to iSize
85200>>>>>>>>
85200>>>>>>>            Move sTablesArray[iCount] to sVal
85201>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85203>>>>>>>                Move True to bExists
85204>>>>>>>                Move iSize to iCount // We're done!
85205>>>>>>>            End
85205>>>>>>>>
85205>>>>>>>        Loop
85206>>>>>>>>
85206>>>>>>>
85206>>>>>>>        Function_Return bExists
85207>>>>>>>    End_Function
85208>>>>>>>
85208>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85208>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
85210>>>>>>>        String sVal
85210>>>>>>>        Boolean bExists
85210>>>>>>>        String[] sTablesArray
85211>>>>>>>        Integer iSize iCount
85211>>>>>>>
85211>>>>>>>        Move False to bExists
85212>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
85213>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85214>>>>>>>        Decrement iSize
85215>>>>>>>        For iCount from 0 to iSize
85221>>>>>>>>
85221>>>>>>>            Move sTablesArray[iCount] to sVal
85222>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85224>>>>>>>                Move True to bExists
85225>>>>>>>                Move iSize to iCount // We're done!
85226>>>>>>>            End
85226>>>>>>>>
85226>>>>>>>        Loop
85227>>>>>>>>
85227>>>>>>>
85227>>>>>>>        Function_Return bExists
85228>>>>>>>    End_Function
85229>>>>>>>
85229>>>>>>>    // ToDo: This index name function needs to be finished...
85229>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85231>>>>>>>        String sStmt sSchema sTableName sDriverID
85231>>>>>>>        Boolean bExists
85231>>>>>>>
85231>>>>>>>        Get psDriverID to sDriverID
85232>>>>>>>        Get psSchema to sSchema
85233>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85234>>>>>>>
85234>>>>>>>        Function_Return bExists
85235>>>>>>>    End_Function
85236>>>>>>>
85236>>>>>>>    // Function creates the passed Sql script as a ".sql" file in the workspace's
85236>>>>>>>    // Home folder, if no path was specified for the filename.
85236>>>>>>>    // Mostly for debugging purposes. E.g. to recreate a Sql script that has been
85236>>>>>>>    // compiled into the program, when the program is run at other location.
85236>>>>>>>//    Function SqlUtilCreateScriptAsFile String sSQLScript String sFileName Returns String
85236>>>>>>>//        String sRetval sPath
85236>>>>>>>//        Integer iCh
85236>>>>>>>//
85236>>>>>>>//        Get ParseFolderName sFileName to sPath
85236>>>>>>>//        If (Trim(sPath) = "") Begin
85236>>>>>>>//            Get psHome of (phoWorkspace(ghoApplication)) to sPath
85236>>>>>>>//        End
85236>>>>>>>//        Get vFolderFormat sPath to sPath
85236>>>>>>>//        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
85236>>>>>>>//            Write channel iCh sSQLScript
85236>>>>>>>//        Send Seq_Close_Channel iCh
85236>>>>>>>//
85236>>>>>>>//        Function_Return (sPath + sFileName)
85236>>>>>>>//    End_Function
85236>>>>>>>
85236>>>>>>>    // Enumerate SQL Servers.
85236>>>>>>>    // Pass a driver id. Returns a string array.
85236>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
85236>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
85236>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
85238>>>>>>>        String[] sReturnArray
85239>>>>>>>        Handle hoSQLHandler
85239>>>>>>>        String sServer
85239>>>>>>>        Integer iCount iNumItems iDataSourceType
85239>>>>>>>        Boolean bOK
85239>>>>>>>
85239>>>>>>>        If (num_arguments > 1) Begin
85241>>>>>>>            Move iDatSrcType to iDataSourceType
85242>>>>>>>        End
85242>>>>>>>>
85242>>>>>>>
85242>>>>>>>        Case Begin
85242>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85244>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
85245>>>>>>>                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
85246>>>>>>>                    If (iNumItems = 0) Begin
85248>>>>>>>                        Get EnumerateServers of hoSQLHandler to iNumItems
85249>>>>>>>                    End
85249>>>>>>>>
85249>>>>>>>                For iCount from 0 to (iNumItems - 1)
85255>>>>>>>>
85255>>>>>>>                    Get String_Value of hoSQLHandler item iCount to sServer
85256>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
85257>>>>>>>                Loop
85258>>>>>>>>
85258>>>>>>>                Case Break
85259>>>>>>>
85259>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85262>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
85263>>>>>>>                Send SeedDataSources of hoSQLHandler
85264>>>>>>>                Move 0 to iCount
85265>>>>>>>                Repeat
85265>>>>>>>>
85265>>>>>>>                    Get DataSources of hoSQLHandler to sServer
85266>>>>>>>                    If (sServer <> "") Begin
85268>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
85269>>>>>>>                        Move sServer to sReturnArray[iCount]
85270>>>>>>>                    End
85270>>>>>>>>
85270>>>>>>>                    Increment iCount
85271>>>>>>>                Until (sServer = "")
85273>>>>>>>                Case Break
85274>>>>>>>
85274>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85277>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
85278>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
85279>>>>>>>                Move 0 to iCount
85280>>>>>>>                Repeat
85280>>>>>>>>
85280>>>>>>>                    Get DataSources of hoSQLHandler to sServer
85281>>>>>>>                    If (sServer <> "") Begin
85283>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
85284>>>>>>>                        Move sServer to sReturnArray[iCount]
85285>>>>>>>                    End
85285>>>>>>>>
85285>>>>>>>                    Increment iCount
85286>>>>>>>                Until (sServer = "")
85288>>>>>>>                Case Break
85289>>>>>>>
85289>>>>>>>            Case (sDriverID = SQLFLEX)
85292>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
85293>>>>>>>                Case Break
85294>>>>>>>
85294>>>>>>>            Case (sDriverID = ORAFLEX)
85297>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
85298>>>>>>>                Case Break
85299>>>>>>>
85299>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
85299>>>>>>>            Case (sDriverID = MDSPgSQL)
85302>>>>>>>                Move "localhost" to sReturnArray[0]
85303>>>>>>>                Case Break
85304>>>>>>>
85304>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
85304>>>>>>>            Case (sDriverID = MDSMySQL)
85307>>>>>>>                Move "localhost" to sReturnArray[0]
85308>>>>>>>                Case Break
85309>>>>>>>
85309>>>>>>>            Case Else
85309>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
85310>>>>>>>>
85310>>>>>>>        Case End
85310>>>>>>>
85310>>>>>>>        Function_Return sReturnArray
85311>>>>>>>    End_Function
85312>>>>>>>
85312>>>>>>>    // Returns all databases as a string array for the passed driver id.
85312>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
85314>>>>>>>        String[] sReturnArray
85315>>>>>>>        String sUserID sPassword
85315>>>>>>>        Boolean bOK
85315>>>>>>>
85315>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85316>>>>>>>        If (bOK = False) Begin
85318>>>>>>>            Function_Return sReturnArray
85319>>>>>>>        End
85319>>>>>>>>
85319>>>>>>>
85319>>>>>>>        Case Begin
85319>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85321>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
85322>>>>>>>                Case Break
85323>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85326>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
85327>>>>>>>                Case Break
85328>>>>>>>
85328>>>>>>>            // Enumeration of ODBC databases should be irrelevant as the database
85328>>>>>>>            // should have been specified when the ODBC source was setup with the ODBC manager.
85328>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85331>>>>>>>                Case Break
85332>>>>>>>
85332>>>>>>>            Case (sDriverID = SQLFLEX)
85335>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
85336>>>>>>>                Case Break
85337>>>>>>>
85337>>>>>>>            Case (sDriverID = MDSPgSQL)
85340>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
85341>>>>>>>                Case Break
85342>>>>>>>
85342>>>>>>>            Case (sDriverID = MDSMySQL)
85345>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
85346>>>>>>>                Case Break
85347>>>>>>>
85347>>>>>>>            Case (sDriverID = ORAFLEX)
85350>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
85351>>>>>>>                Case Break
85352>>>>>>>
85352>>>>>>>            Case Else
85352>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
85353>>>>>>>>
85353>>>>>>>        Case End
85353>>>>>>>
85353>>>>>>>        Function_Return sReturnArray
85354>>>>>>>    End_Function
85355>>>>>>>
85355>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
85355>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
85357>>>>>>>        String[] sReturnArray
85358>>>>>>>        String sServer sUserID sPassword
85358>>>>>>>        Boolean bOK
85358>>>>>>>
85358>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85359>>>>>>>        If (bOK = False) Begin
85361>>>>>>>            Function_Return sReturnArray
85362>>>>>>>        End
85362>>>>>>>>
85362>>>>>>>
85362>>>>>>>        Case Begin
85362>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85364>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
85365>>>>>>>                Case Break
85366>>>>>>>
85366>>>>>>>            Case (sDriverID = MDSPgSQL)
85369>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
85370>>>>>>>                Case Break
85371>>>>>>>
85371>>>>>>>            Case (sDriverID = ORAFLEX)
85374>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
85375>>>>>>>                Case Break
85376>>>>>>>
85376>>>>>>>            Case Else
85376>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
85377>>>>>>>>
85377>>>>>>>                Case Break
85378>>>>>>>        Case End
85378>>>>>>>
85378>>>>>>>        Function_Return sReturnArray
85379>>>>>>>    End_Function
85380>>>>>>>
85380>>>>>>>    // Returns all schemas as a string array for the passed driver id.
85380>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
85382>>>>>>>        String[] sReturnArray
85383>>>>>>>        Boolean bOK
85383>>>>>>>
85383>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85384>>>>>>>        If (bOK = False) Begin
85386>>>>>>>            Function_Return sReturnArray
85387>>>>>>>        End
85387>>>>>>>>
85387>>>>>>>
85387>>>>>>>        Case Begin
85387>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85389>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
85390>>>>>>>                Case Break
85391>>>>>>>
85391>>>>>>>            Case (sDriverID = MDSPgSQL)
85394>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
85395>>>>>>>                Case Break
85396>>>>>>>
85396>>>>>>>            Case (sDriverID = ORAFLEX)
85399>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
85400>>>>>>>                Case Break
85401>>>>>>>
85401>>>>>>>            Case Else
85401>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
85402>>>>>>>>
85402>>>>>>>                Case Break
85403>>>>>>>        Case End
85403>>>>>>>
85403>>>>>>>        Function_Return sReturnArray
85404>>>>>>>    End_Function
85405>>>>>>>
85405>>>>>>>    // Returns a string array with all tables for the current database.
85405>>>>>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
85407>>>>>>>        String[] sReturnArray sArray
85409>>>>>>>        String sServer sDatabase sConnectionString sSelect sSchema
85409>>>>>>>        Integer iSize iCount
85409>>>>>>>        Boolean bOK
85409>>>>>>>
85409>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
85411>>>>>>>            Function_Return sArray
85412>>>>>>>        End
85412>>>>>>>>
85412>>>>>>>
85412>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85413>>>>>>>        If (bOK = False) Begin
85415>>>>>>>            Function_Return sReturnArray
85416>>>>>>>        End
85416>>>>>>>>
85416>>>>>>>
85416>>>>>>>        Get psConnectionString to sConnectionString
85417>>>>>>>        Get psDatabase to sDatabase
85418>>>>>>>        Get psSchema   to sSchema
85419>>>>>>>
85419>>>>>>>        Case Begin
85419>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85421>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
85422>>>>>>>                Case Break
85423>>>>>>>
85423>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85426>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
85427>>>>>>>                Case Break
85428>>>>>>>
85428>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85431>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
85432>>>>>>>                Case Break
85433>>>>>>>
85433>>>>>>>            Case (sDriverID = SQLFLEX)
85436>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
85437>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85438>>>>>>>                Case Break
85439>>>>>>>
85439>>>>>>>            Case (sDriverID = MDSMySQL)
85442>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
85443>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85444>>>>>>>                Case Break
85445>>>>>>>
85445>>>>>>>            Case (sDriverID = MDSPgSQL)
85448>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
85449>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
85450>>>>>>>                Case Break
85451>>>>>>>
85451>>>>>>>            Case (sDriverID = ORAFLEX)
85454>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
85455>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
85456>>>>>>>                Move (SizeOfArray(sArray)) to iSize
85457>>>>>>>                Decrement iSize
85458>>>>>>>                For iCount from 0 to iSize
85464>>>>>>>>
85464>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
85466>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
85467>>>>>>>                    End
85467>>>>>>>>
85467>>>>>>>                Loop
85468>>>>>>>>
85468>>>>>>>                Case Break
85469>>>>>>>
85469>>>>>>>            Case Else
85469>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
85470>>>>>>>>
85470>>>>>>>                Case Break
85471>>>>>>>        Case End
85471>>>>>>>
85471>>>>>>>        Function_Return sReturnArray
85472>>>>>>>    End_Function
85473>>>>>>>
85473>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
85473>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
85475>>>>>>>        String[] sReturnArray
85476>>>>>>>        String sServer sConnectionString sSelect sSchema
85476>>>>>>>        Boolean bOK
85476>>>>>>>
85476>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85477>>>>>>>        If (bOK = False) Begin
85479>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
85480>>>>>>>>
85480>>>>>>>            Function_Return sReturnArray
85481>>>>>>>        End
85481>>>>>>>>
85481>>>>>>>
85481>>>>>>>        Get psConnectionString to sConnectionString
85482>>>>>>>        Get psSchema to sSchema
85483>>>>>>>
85483>>>>>>>        Case Begin
85483>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85485>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
85486>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
85487>>>>>>>                Case Break
85488>>>>>>>
85488>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85491>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
85492>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
85493>>>>>>>                Case Break
85494>>>>>>>
85494>>>>>>>            Case (sDriverID = SQLFLEX)
85497>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
85498>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
85499>>>>>>>                Case Break
85500>>>>>>>
85500>>>>>>>            Case (sDriverID = MDSMySQL)
85503>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
85504>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
85505>>>>>>>                Case Break
85506>>>>>>>
85506>>>>>>>            Case (sDriverID = MDSPgSQL)
85509>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
85510>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
85511>>>>>>>                Case Break
85512>>>>>>>
85512>>>>>>>            Case (sDriverID = ORAFLEX)
85515>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
85516>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
85517>>>>>>>                Case Break
85518>>>>>>>
85518>>>>>>>            Case Else
85518>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
85519>>>>>>>>
85519>>>>>>>                Case Break
85520>>>>>>>        Case End
85520>>>>>>>
85520>>>>>>>        Function_Return sReturnArray
85521>>>>>>>    End_Function
85522>>>>>>>
85522>>>>>>>
85522>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
85522>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
85524>>>>>>>        String[] sReturnArray sReturnArray2
85526>>>>>>>        String sServer sConnectionString sSelect sSchema
85526>>>>>>>        Boolean bOK
85526>>>>>>>        Integer iCount iSize
85526>>>>>>>
85526>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85527>>>>>>>        If (bOK = False) Begin
85529>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
85530>>>>>>>>
85530>>>>>>>            Function_Return sReturnArray
85531>>>>>>>        End
85531>>>>>>>>
85531>>>>>>>
85531>>>>>>>        Get psConnectionString to sConnectionString
85532>>>>>>>        Get psSchema to sSchema
85533>>>>>>>
85533>>>>>>>        Case Begin
85533>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85535>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
85536>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
85537>>>>>>>                Case Break
85538>>>>>>>
85538>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85541>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85542>>>>>>>>
85542>>>>>>>//                Move () to sSelect
85542>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
85542>>>>>>>                Case Break
85543>>>>>>>
85543>>>>>>>            Case (sDriverID = SQLFLEX)
85546>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85547>>>>>>>>
85547>>>>>>>//                Move () to sSelect
85547>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85547>>>>>>>                Case Break
85548>>>>>>>
85548>>>>>>>            Case (sDriverID = MDSMySQL)
85551>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85552>>>>>>>>
85552>>>>>>>//                Move () to sSelect
85552>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85552>>>>>>>                Case Break
85553>>>>>>>
85553>>>>>>>            Case (sDriverID = MDSPgSQL)
85556>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85557>>>>>>>>
85557>>>>>>>//                Move () to sSelect
85557>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85557>>>>>>>                Case Break
85558>>>>>>>
85558>>>>>>>            Case (sDriverID = ORAFLEX)
85561>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85562>>>>>>>>
85562>>>>>>>//                Move () to sSelect
85562>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85562>>>>>>>                Case Break
85563>>>>>>>
85563>>>>>>>            Case Else
85563>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
85564>>>>>>>>
85564>>>>>>>                Case Break
85565>>>>>>>        Case End
85565>>>>>>>
85565>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
85566>>>>>>>        Decrement iSize
85567>>>>>>>        For iCount from 0 to iSize
85573>>>>>>>>
85573>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
85575>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
85576>>>>>>>            End
85576>>>>>>>>
85576>>>>>>>        Loop
85577>>>>>>>>
85577>>>>>>>
85577>>>>>>>        Function_Return sReturnArray2
85578>>>>>>>    End_Function
85579>>>>>>>
85579>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
85579>>>>>>>    // The format of the array is "TableName.FieldName"
85579>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
85581>>>>>>>        String[] sFileNameArray sFieldNameArray
85583>>>>>>>        tSQLRelation[] sRelationsArray
85583>>>>>>>        tSQLRelation[] sRelationsArray
85584>>>>>>>        String sServer sConnectionString sSelect sSchema sFileName sFieldName sVal
85584>>>>>>>        Boolean bOK
85584>>>>>>>        Integer iCount iSize iLength iPos
85584>>>>>>>        Integer iFileNumber iFieldNumber
85584>>>>>>>
85584>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85585>>>>>>>        If (bOK = False) Begin
85587>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
85588>>>>>>>>
85588>>>>>>>            Function_Return sRelationsArray
85589>>>>>>>        End
85589>>>>>>>>
85589>>>>>>>
85589>>>>>>>        Get psConnectionString to sConnectionString
85590>>>>>>>        Get psSchema to sSchema
85591>>>>>>>
85591>>>>>>>        Case Begin
85591>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85593>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
85594>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
85595>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85596>>>>>>>                Case Break
85597>>>>>>>
85597>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85600>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85601>>>>>>>>
85601>>>>>>>//                Move () to sSelect
85601>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
85601>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85601>>>>>>>                Case Break
85602>>>>>>>
85602>>>>>>>            Case (sDriverID = SQLFLEX)
85605>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85606>>>>>>>>
85606>>>>>>>//                Move () to sSelect
85606>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85606>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85606>>>>>>>                Case Break
85607>>>>>>>
85607>>>>>>>            Case (sDriverID = MDSMySQL)
85610>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85611>>>>>>>>
85611>>>>>>>//                Move () to sSelect
85611>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85611>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85611>>>>>>>                Case Break
85612>>>>>>>
85612>>>>>>>            Case (sDriverID = MDSPgSQL)
85615>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85616>>>>>>>>
85616>>>>>>>//                Move () to sSelect
85616>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85616>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85616>>>>>>>                Case Break
85617>>>>>>>
85617>>>>>>>            Case (sDriverID = ORAFLEX)
85620>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85621>>>>>>>>
85621>>>>>>>//                Move () to sSelect
85621>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85621>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85621>>>>>>>                Case Break
85622>>>>>>>
85622>>>>>>>            Case Else
85622>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
85623>>>>>>>>
85623>>>>>>>                Case Break
85624>>>>>>>        Case End
85624>>>>>>>
85624>>>>>>>        Move (Length(sTableName)) to iLength
85625>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
85626>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
85627>>>>>>>        Decrement iSize
85628>>>>>>>        For iCount from 0 to iSize
85634>>>>>>>>
85634>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
85636>>>>>>>                Move sFileNameArray[iCount]         to sFileName
85637>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
85638>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
85639>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
85640>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
85641>>>>>>>            End
85641>>>>>>>>
85641>>>>>>>        Loop
85642>>>>>>>>
85642>>>>>>>
85642>>>>>>>        Function_Return sRelationsArray
85643>>>>>>>    End_Function
85644>>>>>>>
85644>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
85646>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
85646>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
85647>>>>>>>        String[] sUsers sPrograms
85649>>>>>>>        String sSelect
85649>>>>>>>        Integer iSize iCount
85649>>>>>>>
85649>>>>>>>        Case Begin
85649>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85651>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
85652>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
85653>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
85654>>>>>>>                Case Break
85655>>>>>>>            Case (sDriverID = SQLFLEX)
85658>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
85659>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
85660>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
85661>>>>>>>                Case Break
85662>>>>>>>            Case Else
85662>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
85663>>>>>>>>
85663>>>>>>>        Case End
85663>>>>>>>
85663>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
85664>>>>>>>        Decrement iSize
85665>>>>>>>        For iCount from 0 to iSize
85671>>>>>>>>
85671>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
85672>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
85673>>>>>>>        Loop
85674>>>>>>>>
85674>>>>>>>
85674>>>>>>>        Function_Return SQLLoggedInUser
85675>>>>>>>    End_Function
85676>>>>>>>
85676>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
85676>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
85676>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
85678>>>>>>>        String[] sFilesData
85679>>>>>>>        Boolean bExists
85679>>>>>>>        Integer iCh
85679>>>>>>>        String sFileName sExt
85679>>>>>>>
85679>>>>>>>        Get vFolderExists sDataPath to bExists
85680>>>>>>>        If (bExists = True) Begin
85682>>>>>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
85683>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
85684>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
85685>>>>>>>            Direct_Input channel iCh sDataPath
85687>>>>>>>                Repeat
85687>>>>>>>>
85687>>>>>>>                    Readln channel iCh sFileName
85689>>>>>>>                    Get ParseFileExtension sFileName to sExt
85690>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
85692>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
85694>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
85695>>>>>>>                        End
85695>>>>>>>>
85695>>>>>>>                    End
85695>>>>>>>>
85695>>>>>>>                Until (SeqEof = True)
85697>>>>>>>            Close_Input channel iCh
85699>>>>>>>        End
85699>>>>>>>>
85699>>>>>>>        Function_Return sFilesData
85700>>>>>>>    End_Function
85701>>>>>>>
85701>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85701>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
85701>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85701>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
85701>>>>>>>    // column types.
85701>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85703>>>>>>>        Handle hDatabase
85703>>>>>>>        Integer iDriver iServers iCount
85703>>>>>>>        String sValue
85703>>>>>>>
85703>>>>>>>        If (sServer = "") Begin
85705>>>>>>>            Function_Return 0
85706>>>>>>>        End
85706>>>>>>>>
85706>>>>>>>
85706>>>>>>>        Get DriverIndex sDriverID to iDriver
85707>>>>>>>        If (iDriver = 0) Begin
85709>>>>>>>            Function_Return 0
85710>>>>>>>        End
85710>>>>>>>>
85710>>>>>>>
85710>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85713>>>>>>>        For iCount from 1 to iServers
85719>>>>>>>>
85719>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85722>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85724>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85727>>>>>>>            End
85727>>>>>>>>
85727>>>>>>>        Loop
85728>>>>>>>>
85728>>>>>>>
85728>>>>>>>        Function_Return hDatabase
85729>>>>>>>    End_Function
85730>>>>>>>
85730>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85732>>>>>>>        String sConnectionString sMessage
85732>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85732>>>>>>>        Integer i iMsgs iFetchResult iResultCount iRowType iRows iErr iMessage iLastErr
85732>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85735>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85735>>>>>>>        TimeSpan tsQuery tsFetch
85735>>>>>>>        tSqlErrorArray aSqlErrorArray
85735>>>>>>>        tSqlErrorArray aSqlErrorArray
85735>>>>>>>        Boolean bOK bMertechDriver bShowProgress
85735>>>>>>>        tSQLConnection SQLConnection
85735>>>>>>>        tSQLConnection SQLConnection
85735>>>>>>>
85735>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85736>>>>>>>        If (bOK = False) Begin
85738>>>>>>>            Procedure_Return
85739>>>>>>>        End
85739>>>>>>>>
85739>>>>>>>
85739>>>>>>>        If (num_arguments > 2) Begin
85741>>>>>>>            Move bShowProgr to bShowProgress
85742>>>>>>>        End
85742>>>>>>>>
85742>>>>>>>
85742>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85743>>>>>>>
85743>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
85744>>>>>>>        If (bMertechDriver = True) Begin
85746>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
85747>>>>>>>        End
85747>>>>>>>>
85747>>>>>>>        If (bMertechDriver = False) Begin
85749>>>>>>>            Get phoSQLManager to hoSqlHandler
85750>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85751>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85752>>>>>>>        End
85752>>>>>>>>
85752>>>>>>>
85752>>>>>>>        If (hoSQLConnect <> 0) Begin
85754>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85755>>>>>>>            If (hoStmt <> 0) Begin
85757>>>>>>>                // record starting date/time stamp
85757>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85758>>>>>>>                // turn on error handling if enabled
85758>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85760>>>>>>>                    Set pbSqlError to False
85761>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85762>>>>>>>                    Move Error_Object_Id to hoError
85763>>>>>>>                    Move Self to Error_Object_Id
85764>>>>>>>                End
85764>>>>>>>>
85764>>>>>>>
85764>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85764>>>>>>>                Set psSQLStatementString to sStmt
85765>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85766>>>>>>>
85766>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85768>>>>>>>                    Move hoError to Error_Object_Id
85769>>>>>>>                End
85769>>>>>>>>
85769>>>>>>>
85769>>>>>>>                Move 0 to iMsgs
85770>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
85770>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
85770>>>>>>>                If (bMertechDriver = False) Begin
85772>>>>>>>                    Move Err to iErr
85773>>>>>>>                    Move LastErr to iLastErr
85774>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85775>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85776>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85777>>>>>>>                    Send _SqlColumnInfo hoStmt
85778>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
85779>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85780>>>>>>>                    Repeat
85780>>>>>>>>
85780>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
85781>>>>>>>                        If (iFetchResult <> 0) Begin
85783>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85784>>>>>>>                        End
85784>>>>>>>>
85784>>>>>>>                    Until (iFetchResult = 0)
85786>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
85787>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
85788>>>>>>>                    Move iErr to Err
85789>>>>>>>                    Move iLastErr to LastErr
85790>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
85791>>>>>>>                End
85791>>>>>>>>
85791>>>>>>>
85791>>>>>>>                Set piRows    to iRows
85792>>>>>>>                Set piRowType to iRowType
85793>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85794>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85795>>>>>>>
85795>>>>>>>                If (iMsgs <> 0) Begin
85797>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85799>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85800>>>>>>>                    End
85800>>>>>>>>
85800>>>>>>>                    For i from 1 to iMsgs
85806>>>>>>>>
85806>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85807>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85808>>>>>>>                        If (bShowProgress = True) Begin
85810>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85812>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85813>>>>>>>                            End
85813>>>>>>>>
85813>>>>>>>                            Else Begin
85814>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85816>>>>>>>                            End
85816>>>>>>>>
85816>>>>>>>                        End
85816>>>>>>>>
85816>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85817>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85818>>>>>>>                    Loop
85819>>>>>>>>
85819>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85821>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85822>>>>>>>                    End
85822>>>>>>>>
85822>>>>>>>                    Set paQueryMessages to sMsg
85823>>>>>>>                End
85823>>>>>>>>
85823>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85824>>>>>>>            End
85824>>>>>>>>
85824>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85825>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85826>>>>>>>            Set ptsQueryExec to tsQuery
85827>>>>>>>            Set ptsFetchResults to tsFetch
85828>>>>>>>            Send SqlClose of hoStmt
85829>>>>>>>        End
85829>>>>>>>>
85829>>>>>>>
85829>>>>>>>        Send SqlDisconnect of hoSQLConnect
85830>>>>>>>    End_Procedure
85831>>>>>>>
85831>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85831>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85831>>>>>>>    // Returns False if no error occured.
85831>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85833>>>>>>>        Boolean bOK bShowProgress
85833>>>>>>>        tSQLScriptArray SQLScriptArray
85833>>>>>>>        tSQLScriptArray SQLScriptArray
85833>>>>>>>        Integer iOut iRows iCount
85833>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85833>>>>>>>        TimeSpan tsTotalTime
85833>>>>>>>        String sMessage
85833>>>>>>>
85833>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85834>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
85835>>>>>>>        If (SQLScriptArray.bError = True) Begin
85837>>>>>>>            Function_Return False
85838>>>>>>>        End
85838>>>>>>>>
85838>>>>>>>
85838>>>>>>>        If (num_arguments > 3) Begin
85840>>>>>>>            Move bShowProgr to bShowProgress
85841>>>>>>>        End
85841>>>>>>>>
85841>>>>>>>
85841>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85842>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85843>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85844>>>>>>>
85844>>>>>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
85846>>>>>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
85847>>>>>>>>
85847>>>>>>>        End
85847>>>>>>>>
85847>>>>>>>
85847>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85848>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85849>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85850>>>>>>>
85850>>>>>>>        Function_Return bOK
85851>>>>>>>    End_Procedure
85852>>>>>>>
85852>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85852>>>>>>>//        String sRootName
85852>>>>>>>//        Boolean bOK
85852>>>>>>>//
85852>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85852>>>>>>>//        Move (sRootName contains sDriverID) to bOK
85852>>>>>>>//
85852>>>>>>>//        Function_Return bOK
85852>>>>>>>//    End_Function
85852>>>>>>>
85852>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85852>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85852>>>>>>>//        Integer iDbType
85852>>>>>>>//        Boolean bOK
85852>>>>>>>//
85852>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85852>>>>>>>//        If (bOK = True) Begin
85852>>>>>>>//            Function_Return False
85852>>>>>>>//        End
85852>>>>>>>//
85852>>>>>>>//        Get psDriverID to sDriverID
85852>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85852>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85852>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85852>>>>>>>//
85852>>>>>>>//        Get psDriverID to sDriverID
85852>>>>>>>//        Get piDbType   to iDbType
85852>>>>>>>//        Get psSchema   to sSchema
85852>>>>>>>//        If (sSchema = "") Begin
85852>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85852>>>>>>>//        End
85852>>>>>>>//
85852>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
85852>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
85852>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
85852>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85852>>>>>>>//            End
85852>>>>>>>//            Else Begin
85852>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85852>>>>>>>//            End
85852>>>>>>>//        End
85852>>>>>>>//
85852>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85852>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85852>>>>>>>//
85852>>>>>>>//        Function_Return True
85852>>>>>>>//    End_Function
85852>>>>>>>
85852>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
85852>>>>>>>    // from the passed filelist.
85852>>>>>>>    // Returns the number of tables affected.
85852>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85854>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85854>>>>>>>        Integer iRetval
85854>>>>>>>        Handle hTable
85854>>>>>>>
85854>>>>>>>        // We first save the current filelist as the passed filelist name
85854>>>>>>>        // may come from another workspace, to restore it when we're ready.
85854>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85857>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85860>>>>>>>        Move 0 to hTable
85861>>>>>>>        Move 0 to iRetval
85862>>>>>>>
85862>>>>>>>        Repeat
85862>>>>>>>>
85862>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85865>>>>>>>            If (hTable <> 0) Begin
85867>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85870>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85873>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85876>>>>>>>                Move (Uppercase(sRootName)) to sVal
85877>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85879>>>>>>>                    // Prefixes:
85879>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85880>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85881>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85882>>>>>>>                    // Suffixes:
85882>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85883>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85884>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85885>>>>>>>
85885>>>>>>>                    // Change Filelist entry:
85885>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85888>>>>>>>
85888>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
85889>>>>>>>                    If (sVal contains "dbo.") Begin
85891>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85892>>>>>>>
85892>>>>>>>                        // Change Filelist entry:
85892>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85895>>>>>>>                    End
85895>>>>>>>>
85895>>>>>>>                    Increment iRetval
85896>>>>>>>                End
85896>>>>>>>>
85896>>>>>>>            End
85896>>>>>>>>
85896>>>>>>>        Until (hTable = 0)
85898>>>>>>>
85898>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85901>>>>>>>
85901>>>>>>>        Function_Return iRetval
85902>>>>>>>    End_Function
85903>>>>>>>
85903>>>>>>>    // To open all Sql based tables in Filelist.cfg
85903>>>>>>>    Procedure SqlUtilOpenAllTables
85905>>>>>>>        Handle hTable
85905>>>>>>>        String sRoot sDriverID
85905>>>>>>>        Boolean bOK
85905>>>>>>>
85905>>>>>>>        Move 0 to hTable
85906>>>>>>>        Move "" to sDriverID
85907>>>>>>>        Get AutoConnectionIDLogin to bOK
85908>>>>>>>
85908>>>>>>>        Repeat
85908>>>>>>>>
85908>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85911>>>>>>>            If (hTable > 0) Begin
85913>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85916>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85918>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85921>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85923>>>>>>>                        Open hTable
85925>>>>>>>                    End
85925>>>>>>>>
85925>>>>>>>                End
85925>>>>>>>>
85925>>>>>>>            End
85925>>>>>>>>
85925>>>>>>>
85925>>>>>>>        Until (hTable = 0)
85927>>>>>>>    End_Procedure
85928>>>>>>>
85928>>>>>>>    // This function allows you to put an Sql script in a CM Image. It makes it easier to
85928>>>>>>>    // copy and paste between a DataFlex program and an Sql Editor.
85928>>>>>>>    Function SqlUtilLoadImageFile String sFileName Returns String
85930>>>>>>>        Integer iChannel iPos
85930>>>>>>>        String sTextValue sLine sPath
85930>>>>>>>        Boolean bSeqEof
85930>>>>>>>
85930>>>>>>>        Move "" to sTextValue
85931>>>>>>>        Get ParseFolderName sFileName to sPath
85932>>>>>>>        If (Trim(sPath) = "") Begin
85934>>>>>>>            Get psDataPathFirstPart to sPath
85935>>>>>>>            Move (sPath + sFileName) to sFileName
85936>>>>>>>        End
85936>>>>>>>>
85936>>>>>>>
85936>>>>>>>        Get Seq_New_Channel to iChannel
85937>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85939>>>>>>>            Error DFERR_PROGRAM "No channel available..."
85940>>>>>>>>
85940>>>>>>>        End
85940>>>>>>>>
85940>>>>>>>        Else Begin
85941>>>>>>>            Direct_Input channel iChannel sFileName
85943>>>>>>>            Move (SeqEof) to bSeqEof
85944>>>>>>>            If (bSeqEof = True) Begin
85946>>>>>>>                Send Seq_Release_Channel iChannel
85947>>>>>>>                Set psSQLStatementString to ""
85948>>>>>>>                Error DFERR_PROGRAM ("The Sql script file:\n" + sFileName + "\nCould not be found.")
85949>>>>>>>>
85949>>>>>>>                Function_Return ""
85950>>>>>>>            End
85950>>>>>>>>
85950>>>>>>>
85950>>>>>>>            While (not(bSeqEof))
85954>>>>>>>                Readln channel iChannel sLine
85956>>>>>>>                Move (Pos("/", sLine)) to iPos
85957>>>>>>>                Move (SeqEol) to bSeqEof
85958>>>>>>>                If (not(bSeqEof) and iPos <> 1) Begin
85960>>>>>>>                    Move (sTextValue + sLine + Character(13)) to sTextValue
85961>>>>>>>                End
85961>>>>>>>>
85961>>>>>>>            Loop
85962>>>>>>>>
85962>>>>>>>            Send Seq_Release_Channel iChannel
85963>>>>>>>        End
85963>>>>>>>>
85963>>>>>>>
85963>>>>>>>        Set psSQLStatementString to sTextValue
85964>>>>>>>        Function_Return sTextValue
85965>>>>>>>    End_Function
85966>>>>>>>
85966>>>>>>>    // Reads an Sql script that have been compiled into the program as an "image" (/MyImageName) and returns the full script as a string.
85966>>>>>>>    // Usage: Get SqlUtilReadScriptFromCMImage of ghoDbUpdateFunctionLibrary CreatevwWorkflowInbox.n
85966>>>>>>>    //
85966>>>>>>>    // This is a trick to use an old DataFlex feature/syntax to include "image names" at the top
85966>>>>>>>    // of a file. Each such section must end with a "/*".
85966>>>>>>>    // Note: Sql script files remarks/comments cannot be handled by the DataFlex compiler. All Sql comment
85966>>>>>>>    //       sections in the "xxx.pkg.sql" file _must_ be removed.
85966>>>>>>>//    Function SqlUtilReadScriptFromCMImage Integer iImg Returns tSQLScriptResult
85966>>>>>>>//        Integer iChannel iPos
85966>>>>>>>//        String sTextValue sLine
85966>>>>>>>//        Boolean bSeqEof
85966>>>>>>>//        tSQLScriptResult SqlScriptResult
85966>>>>>>>//
85966>>>>>>>//        Move "" to sTextValue
85966>>>>>>>//
85966>>>>>>>//        Get Seq_New_Channel to iChannel
85966>>>>>>>//        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85966>>>>>>>//            Error DFERR_PROGRAM "No channel available..."
85966>>>>>>>//            Function_Return ""
85966>>>>>>>//        End
85966>>>>>>>//
85966>>>>>>>//        Get SqlUtilCheckScriptSize False "" iImg True to SqlScriptResult
85966>>>>>>>//
85966>>>>>>>//        Direct_Input channel iChannel ("image: " + String(iImg))
85966>>>>>>>//        Move (SeqEof) to bSeqEof
85966>>>>>>>//        While (not(bSeqEof))
85966>>>>>>>//            Readln channel iChannel sLine
85966>>>>>>>//            Move (SeqEol) to bSeqEof
85966>>>>>>>//            If (not(bSeqEof)) Begin
85966>>>>>>>//                Move (Trim(sLine)) to sLine
85966>>>>>>>//                If (Left(sLine, 2) <> (Character(47) + Character(47))) Begin // ASCII 47 = "/" (Comments)
85966>>>>>>>//                    Move (sTextValue + sLine + character(13)) to sTextValue
85966>>>>>>>//                End
85966>>>>>>>//            End
85966>>>>>>>//        Loop
85966>>>>>>>//        Send Seq_Release_Channel iChannel
85966>>>>>>>//
85966>>>>>>>//        Set psSQLStatementString to sTextValue
85966>>>>>>>//        Move sTextValue to SqlScriptResult.sSQLScript
85966>>>>>>>//        Function_Return SqlScriptResult
85966>>>>>>>//    End_Function
85966>>>>>>>
85966>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85966>>>>>>>//        String sRetval sDriverID
85966>>>>>>>//        String sTableName
85966>>>>>>>//        Integer iDbType iIndex
85966>>>>>>>//        Boolean bOK
85966>>>>>>>//
85966>>>>>>>//        Get psDriverID to sDriverID
85966>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85966>>>>>>>//        If (hTable = 0 or bOK = False) Begin
85966>>>>>>>//            Function_Return ""
85966>>>>>>>//        End
85966>>>>>>>//
85966>>>>>>>//        Move False to Err
85966>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
85966>>>>>>>//        Get piDbType to iDbType
85966>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85966>>>>>>>//        If (iIndex = -1) Begin
85966>>>>>>>//            Function_Return ""
85966>>>>>>>//        End
85966>>>>>>>//
85966>>>>>>>//        Function_Return sRetval
85966>>>>>>>//    End_Function
85966>>>>>>>
85966>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
85968>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
85968>>>>>>>        Boolean bOpened bOK bMertech
85968>>>>>>>        
85968>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85971>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
85972>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
85972>>>>>>>        // which makes the program unable to run because they can't be opened.
85972>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
85972>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
85972>>>>>>>        // proper .int files for the two tables.
85972>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
85974>>>>>>>            Function_Return True
85975>>>>>>>        End                     
85975>>>>>>>>
85975>>>>>>>        
85975>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
85976>>>>>>>        Move CS_ANSI_Txt to sNewFormat
85977>>>>>>>        Get AutoConnectionIDLogin to bOK
85978>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_MISSING_VALUE
85979>>>>>>>        Open hTable
85981>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_MISSING_VALUE
85982>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85985>>>>>>>
85985>>>>>>>        // ToDo: What to do if we cannot open the table?!
85985>>>>>>>        If (bOpened = False) Begin
85987>>>>>>>            Function_Return False
85988>>>>>>>        End
85988>>>>>>>>
85988>>>>>>>
85988>>>>>>>        Get psDriverID to sDriverID
85989>>>>>>>        Get IsMertechDriver sDriverID to bMertech
85990>>>>>>>        If (bMertech = True) Begin
85992>>>>>>>            Get psDataPathFirstPart to sDataPath
85993>>>>>>>            Get vFolderExists sDataPath to bOK
85994>>>>>>>            If (bOK = False) Begin
85996>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
85997>>>>>>>>
85997>>>>>>>                Function_Return False
85998>>>>>>>            End
85998>>>>>>>>
85998>>>>>>>            Get vFolderFormat sDataPath to sDataPath
85999>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86002>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
86003>>>>>>>            Move sDatabaseName to sPhysicalFileName
86004>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
86005>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
86006>>>>>>>            Function_Return (bOK = True)
86007>>>>>>>        End
86007>>>>>>>>
86007>>>>>>>
86007>>>>>>>        Move False to Err
86008>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
86011>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
86012>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
86012>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
86012>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
86013>>>>>>>
86013>>>>>>>        Structure_Start hTable
86014>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
86017>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
86020>>>>>>>        Structure_End hTable (DF_STRUCTEND_OPT_IN_PLACE ior DF_STRUCTEND_OPT_FORCE)
86022>>>>>>>
86022>>>>>>>        Function_Return (Err = False)
86023>>>>>>>    End_Function
86024>>>>>>>
86024>>>>>>>    // Checks if the passed Table;
86024>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
86024>>>>>>>    // 2) It has an .int file.
86024>>>>>>>    // If both is True it should already be connected to SQL
86024>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
86026>>>>>>>        Boolean bExists bRootName
86026>>>>>>>        String sRootName sDataPath
86026>>>>>>>        Integer iCount
86026>>>>>>>
86026>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86029>>>>>>>        Move (sRootName contains sDriverID) to bRootName
86030>>>>>>>
86030>>>>>>>        Get psDataPathFirstPart to sDataPath
86031>>>>>>>        Get vFolderExists sDataPath to bExists
86032>>>>>>>        If (bExists = False) Begin
86034>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
86034>>>>>>>            Function_Return False
86035>>>>>>>        End
86035>>>>>>>>
86035>>>>>>>
86035>>>>>>>        Get vFolderFormat sDataPath to sDataPath
86036>>>>>>>        Get _TableNameOnly sRootName to sRootName
86037>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
86038>>>>>>>
86038>>>>>>>        Function_Return (bRootName = True and bExists = True)
86039>>>>>>>    End_Function
86040>>>>>>>
86040>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
86042>>>>>>>        Boolean bViewTableType bOpen bMertechDriver bOK
86042>>>>>>>        Integer hoSQLHandler
86042>>>>>>>        Integer iTableCount iNumTables iPos iTableIndex
86042>>>>>>>        String sTableName sOwner sTableType sLogin sEnumTableName sEnumSchemaName sCurrent_Login
86042>>>>>>>        Handle hoCliHandler
86042>>>>>>>        tSQLConnection SQLConnection
86042>>>>>>>        tSQLConnection SQLConnection
86042>>>>>>>
86042>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
86045>>>>>>>        If (bOpen = False) Begin
86047>>>>>>>            Get AutoConnectionIDLogin to bOK
86048>>>>>>>            Open hTable
86050>>>>>>>        End
86050>>>>>>>>
86050>>>>>>>
86050>>>>>>>        Get pSQLConnection to SQLConnection
86051>>>>>>>        Get phoCLIHandler to hoCliHandler
86052>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
86053>>>>>>>
86053>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
86056>>>>>>>        Get _TableNameOnly sTableName to sTableName
86057>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
86060>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
86061>>>>>>>
86061>>>>>>>        For iTableCount from 1 to iNumTables
86067>>>>>>>>
86067>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
86068>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
86069>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
86071>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
86072>>>>>>>                Move iNumTables to iTableCount // We're done.
86073>>>>>>>            End
86073>>>>>>>>
86073>>>>>>>        Loop
86074>>>>>>>>
86074>>>>>>>
86074>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
86075>>>>>>>        If (bOpen = False) Begin
86077>>>>>>>            Close hTable
86078>>>>>>>        End
86078>>>>>>>>
86078>>>>>>>
86078>>>>>>>        Function_Return bViewTableType
86079>>>>>>>    End_Function
86080>>>>>>>
86080>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
86080>>>>>>>    //
86080>>>>>>>    // SQL utility function that returns a database type (string) constant
86080>>>>>>>    // corresponding to the passed iDbType.
86080>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
86082>>>>>>>        String sRetval
86082>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86083>>>>>>>        Function_Return sRetval
86084>>>>>>>    End_Function
86085>>>>>>>
86085>>>>>>>    // SQL utility function that returns a database type constant (integer)
86085>>>>>>>    // corresponding to the passed sDbType string constant.
86085>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
86087>>>>>>>        Integer iRetval
86087>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
86088>>>>>>>        Function_Return iRetval
86089>>>>>>>    End_Function
86090>>>>>>>
86090>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
86090>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
86090>>>>>>>    // the SQL Connection program's grid.
86090>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
86092>>>>>>>        String sRetval
86092>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
86093>>>>>>>        Function_Return sRetval
86094>>>>>>>    End_Function
86095>>>>>>>
86095>>>>>>>    // Pass a driver name as a string and the function will return
86095>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
86095>>>>>>>    // quite work and always returns "MS SQL Server"
86095>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
86097>>>>>>>        Integer iRetval
86097>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
86098>>>>>>>        Function_Return iRetval
86099>>>>>>>    End_Function
86100>>>>>>>
86100>>>>>>>    // *** Helper Functions ***
86100>>>>>>>    // They all start with an underscore: "_" in the function name.
86100>>>>>>>    //
86100>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
86100>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
86100>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
86100>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
86102>>>>>>>        Integer iChannel iArgumentSize iOut iChunk iPointer iCount iSize
86102>>>>>>>        Number nByteCount
86102>>>>>>>        String sCharacter sSQLScript
86102>>>>>>>        Boolean bSeqEof
86102>>>>>>>        tSQLScriptArray SqlScriptArray
86102>>>>>>>        tSQLScriptArray SqlScriptArray
86102>>>>>>>        UChar[] uCharData
86103>>>>>>>
86103>>>>>>>        Move False to Err
86104>>>>>>>        Get Seq_New_Channel to iChannel
86105>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
86107>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
86108>>>>>>>>
86108>>>>>>>            Move True to SqlScriptArray.bError
86109>>>>>>>            Function_Return SqlScriptArray
86110>>>>>>>        End
86110>>>>>>>>
86110>>>>>>>
86110>>>>>>>        // First decide the size of the script
86110>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
86112>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
86114>>>>>>>        Close_Input channel iChannel
86116>>>>>>>
86116>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
86117>>>>>>>        If (nByteCount  < 1) Begin
86119>>>>>>>            Send Seq_Release_Channel iChannel
86120>>>>>>>            Move True to SqlScriptArray.bError
86121>>>>>>>            Function_Return SqlScriptArray
86122>>>>>>>        End
86122>>>>>>>>
86122>>>>>>>
86122>>>>>>>        // If necessary change the string argument_size
86122>>>>>>>        Get_Argument_Size to iArgumentSize
86123>>>>>>>        If (nByteCount >= iArgumentSize) Begin
86125>>>>>>>            Move (nByteCount + 2048) to nByteCount
86126>>>>>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
86127>>>>>>>>
86127>>>>>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
86128>>>>>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
86129>>>>>>>        End
86129>>>>>>>>
86129>>>>>>>        Else Begin
86130>>>>>>>            Move False to SqlScriptArray.bArgumentSizeChanged
86131>>>>>>>        End
86131>>>>>>>>
86131>>>>>>>
86131>>>>>>>        // Read the script file from memory line-by-line
86131>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
86133>>>>>>>            Move 0 to iCount
86134>>>>>>>            Repeat
86134>>>>>>>>
86134>>>>>>>                Readln channel iChannel sSQLScript
86136>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
86137>>>>>>>                Increment iCount
86138>>>>>>>            Until (SeqEof = True)
86140>>>>>>>        Close_Input channel iChannel
86142>>>>>>>        Send Seq_Release_Channel iChannel
86143>>>>>>>
86143>>>>>>>        // Finally "sanitize" the script by removing all comments.
86143>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
86144>>>>>>>
86144>>>>>>>        Function_Return SqlScriptArray
86145>>>>>>>    End_Function
86146>>>>>>>
86146>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
86148>>>>>>>        String sSQLVal sStmt sCR sDebugFileName sTmp sGOKeyWord sNoCountKeyWord sMessage sExportFile
86148>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
86148>>>>>>>        Integer i iMsgs iFetchResult iResultCount iRows iRowType iCount iChunkCounter iChunkMax iPos iOut iNextSet iMessage
86148>>>>>>>        String[] sMsg aSQLQueryMessages
86150>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
86150>>>>>>>        TimeSpan tsQuery
86150>>>>>>>        tSqlErrorArray aSqlErrorArray
86150>>>>>>>        tSqlErrorArray aSqlErrorArray
86150>>>>>>>        tSQLConnection SQLConnection
86150>>>>>>>        tSQLConnection SQLConnection
86150>>>>>>>        Boolean bOK bMertechDriver bShowProgress
86150>>>>>>>
86150>>>>>>>        If (num_arguments > 4) Begin
86152>>>>>>>            Move bShowProgr to bShowProgress
86153>>>>>>>        End
86153>>>>>>>>
86153>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
86154>>>>>>>        If (bMertechDriver = False) Begin
86156>>>>>>>            Get phoSQLManager to hoSql
86157>>>>>>>        End
86157>>>>>>>>
86157>>>>>>>        Else Begin
86158>>>>>>>            Get _MertechSQLManagerHandle to hoSql
86159>>>>>>>        End
86159>>>>>>>>
86159>>>>>>>
86159>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
86160>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
86160>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
86160>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
86160>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
86160>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
86160>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
86160>>>>>>>        Get piChunkMax to iChunkMax
86161>>>>>>>        Move 0 to iChunkCounter
86162>>>>>>>        Move "" to sStmt
86163>>>>>>>
86163>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
86164>>>>>>>        Move (Character(13) + Character(10)) to sCR
86165>>>>>>>
86165>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86166>>>>>>>
86166>>>>>>>        If (bMertechDriver = True) Begin
86168>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
86169>>>>>>>        End
86169>>>>>>>>
86169>>>>>>>        If (bMertechDriver = False) Begin
86171>>>>>>>            Get phoSQLManager  to hoSQL
86172>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
86173>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
86174>>>>>>>        End
86174>>>>>>>>
86174>>>>>>>
86174>>>>>>>        If (hoSQLConnect <> 0) Begin
86176>>>>>>>            Move False to Err
86177>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
86178>>>>>>>            If (hoStmt <> 0) Begin
86180>>>>>>>
86180>>>>>>>                // If the embedded resource should be written as a script file to disk:
86180>>>>>>>                If (bCreateScriptFile = True) Begin
86182>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
86183>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
86184>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
86185>>>>>>>                    Get Seq_New_Channel to iOut
86186>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
86188>>>>>>>                        Direct_Output channel iOut sExportFile
86190>>>>>>>                    End
86190>>>>>>>>
86190>>>>>>>                End
86190>>>>>>>>
86190>>>>>>>
86190>>>>>>>                // Record starting date/time stamp
86190>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
86191>>>>>>>                // Turn on error handling if enabled
86191>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
86193>>>>>>>                    Set pbSqlError to False
86194>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
86195>>>>>>>                    Move Error_Object_Id to hoError
86196>>>>>>>                    Move Self to Error_Object_Id
86197>>>>>>>                End
86197>>>>>>>>
86197>>>>>>>
86197>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
86198>>>>>>>                Decrement iRows
86199>>>>>>>                Move (sNoCountKeyWord + sCR) to sStmt
86200>>>>>>>
86200>>>>>>>                For iCount from 0 to iRows
86206>>>>>>>>
86206>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
86207>>>>>>>
86207>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
86209>>>>>>>                        If (sSQLVal <> "") Begin
86211>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
86212>>>>>>>                        End
86212>>>>>>>>
86212>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
86213>>>>>>>                    End
86213>>>>>>>>
86213>>>>>>>
86213>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
86213>>>>>>>                    // or if at the very end of the script.
86213>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
86215>>>>>>>
86215>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
86215>>>>>>>                        // instead of all in one go.
86215>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
86216>>>>>>>
86216>>>>>>>                        If (bCreateScriptFile = True) Begin
86218>>>>>>>                            Write channel iOut sStmt
86220>>>>>>>                        End
86220>>>>>>>>
86220>>>>>>>                        Move "" to sStmt
86221>>>>>>>                        Move 0 to iChunkCounter
86222>>>>>>>                    End
86222>>>>>>>>
86222>>>>>>>                    Increment iChunkCounter
86223>>>>>>>                Loop
86224>>>>>>>>
86224>>>>>>>
86224>>>>>>>                Repeat
86224>>>>>>>>
86224>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
86226>>>>>>>                        Move hoError to Error_Object_Id
86227>>>>>>>                    End
86227>>>>>>>>
86227>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
86228>>>>>>>
86228>>>>>>>                    Send _SqlColumnInfo hoStmt
86229>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
86230>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
86231>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
86232>>>>>>>                    Set piRows    to iRows
86233>>>>>>>                    Set piRowType to iRowType
86234>>>>>>>
86234>>>>>>>                    If (iMsgs <> 0) Begin
86236>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
86238>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
86239>>>>>>>                        End
86239>>>>>>>>
86239>>>>>>>                        For i from 1 to iMsgs
86245>>>>>>>>
86245>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
86246>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
86247>>>>>>>                            If (bShowProgress = True) Begin
86249>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
86251>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
86252>>>>>>>                                End
86252>>>>>>>>
86252>>>>>>>                                Else Begin
86253>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
86255>>>>>>>                                End
86255>>>>>>>>
86255>>>>>>>                            End
86255>>>>>>>>
86255>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
86256>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
86257>>>>>>>                        Loop
86258>>>>>>>>
86258>>>>>>>
86258>>>>>>>
86258>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
86260>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
86261>>>>>>>                        End
86261>>>>>>>>
86261>>>>>>>                        Set paQueryMessages to sMsg
86262>>>>>>>                    End
86262>>>>>>>>
86262>>>>>>>
86262>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
86263>>>>>>>                Until (iNextSet = 0)
86265>>>>>>>
86265>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
86266>>>>>>>            End
86266>>>>>>>>
86266>>>>>>>
86266>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
86267>>>>>>>            Set ptsQueryExec to tsQuery
86268>>>>>>>            Send SqlClose of hoStmt
86269>>>>>>>
86269>>>>>>>            If (bCreateScriptFile = True) Begin
86271>>>>>>>                Close_Output channel iOut
86273>>>>>>>                Send Seq_Release_Channel iOut
86274>>>>>>>            End
86274>>>>>>>>
86274>>>>>>>        End
86274>>>>>>>>
86274>>>>>>>        Send SqlDisconnect of hoSQLConnect
86275>>>>>>>
86275>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
86276>>>>>>>    End_Function
86277>>>>>>>
86277>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
86277>>>>>>>    // for DAW drivers.
86277>>>>>>>    // Returns: A string array.
86277>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
86279>>>>>>>        String[] sReturnArray
86280>>>>>>>        String sValue sPrevious
86280>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
86280>>>>>>>        Integer iFetchResult iRows
86280>>>>>>>        tSQLConnection SQLConnection
86280>>>>>>>        tSQLConnection SQLConnection
86280>>>>>>>
86280>>>>>>>        Get phoSQLManager to hoSQLHandler
86281>>>>>>>
86281>>>>>>>        If (hoSQLHandler <> 0) Begin
86283>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86284>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
86285>>>>>>>
86285>>>>>>>            If (hoSQLConnect <> 0) Begin
86287>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
86288>>>>>>>                If (hstmt <> 0) Begin
86290>>>>>>>                    Send SqlExecDirect of hstmt sStmt
86291>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
86292>>>>>>>                    Repeat
86292>>>>>>>>
86292>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
86293>>>>>>>                        If (iFetchResult <> 0) Begin
86295>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
86296>>>>>>>                            If (sValue <> sPrevious) Begin
86298>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86299>>>>>>>                            End
86299>>>>>>>>
86299>>>>>>>                            Move sValue to sPrevious
86300>>>>>>>                        End
86300>>>>>>>>
86300>>>>>>>                    Until (iFetchResult = 0)
86302>>>>>>>                    Send SQLClose of hstmt
86303>>>>>>>                End
86303>>>>>>>>
86303>>>>>>>                Send SQLDisconnect of hoSQLConnect
86304>>>>>>>            End
86304>>>>>>>>
86304>>>>>>>        End
86304>>>>>>>>
86304>>>>>>>
86304>>>>>>>        Function_Return sReturnArray
86305>>>>>>>    End_Function
86306>>>>>>>
86306>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
86306>>>>>>>    // for Mertech drivers.
86306>>>>>>>    // Returns: A string array.
86306>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
86308>>>>>>>        String[] sReturnArray
86309>>>>>>>        String sValue sUserID sPassword
86309>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
86309>>>>>>>        Integer iFetchResult iRows
86309>>>>>>>        tSQLConnection SQLConnection
86309>>>>>>>        tSQLConnection SQLConnection
86309>>>>>>>
86309>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
86310>>>>>>>
86310>>>>>>>        If (hoSQLHandler <> 0) Begin
86312>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86313>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
86314>>>>>>>
86314>>>>>>>            If (hoSQLConnect <> 0) Begin
86316>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
86317>>>>>>>                If (hStmt <> 0) Begin
86319>>>>>>>                    Send SqlExecDirect of hStmt sStmt
86320>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
86321>>>>>>>                    Repeat
86321>>>>>>>>
86321>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
86322>>>>>>>                        If (iFetchResult <> 0) Begin
86324>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
86325>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86326>>>>>>>                        End
86326>>>>>>>>
86326>>>>>>>                    Until (iFetchResult = 0)
86328>>>>>>>                    Send SQLClose of hStmt
86329>>>>>>>                End
86329>>>>>>>>
86329>>>>>>>                Send SQLDisconnect of hoSQLConnect
86330>>>>>>>            End
86330>>>>>>>>
86330>>>>>>>        End
86330>>>>>>>>
86330>>>>>>>
86330>>>>>>>        Function_Return sReturnArray
86331>>>>>>>    End_Function
86332>>>>>>>
86332>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
86332>>>>>>>    // will be used.
86332>>>>>>>    Function SqlUtilBackupDatabaseToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
86334>>>>>>>        Boolean bOK bExists bShowProgress
86334>>>>>>>        String sStatement sDriverID
86334>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
86334>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
86334>>>>>>>        Integer iDbType
86334>>>>>>>
86334>>>>>>>        If (sDatabase = "") Begin
86336>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
86337>>>>>>>>
86337>>>>>>>            Function_Return False
86338>>>>>>>        End
86338>>>>>>>>
86338>>>>>>>        If (sBackupName = "") Begin
86340>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
86341>>>>>>>>
86341>>>>>>>            Function_Return False
86342>>>>>>>        End
86342>>>>>>>>
86342>>>>>>>
86342>>>>>>>        // Create backup-folder if it doesn't exist
86342>>>>>>>        Get vFolderExists sPath to bExists
86343>>>>>>>        If (bExists = False) Begin
86345>>>>>>>            Get vCreateDirectory sPath to bOK
86346>>>>>>>            If (bOK = False) Begin
86348>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
86349>>>>>>>>
86349>>>>>>>                Function_Return False
86350>>>>>>>            End
86350>>>>>>>>
86350>>>>>>>        End
86350>>>>>>>>
86350>>>>>>>        // Make sure the path ends with a back-slash
86350>>>>>>>        If (sPath <> "") Begin
86352>>>>>>>            Get vFolderFormat sPath to sPath
86353>>>>>>>        End
86353>>>>>>>>
86353>>>>>>>
86353>>>>>>>        Get psDriverID to sDriverID
86354>>>>>>>        Get piDbType   to iDbType
86355>>>>>>>        If (num_arguments > 3) Begin
86357>>>>>>>            Move bShowProg to bShowProgress
86358>>>>>>>        End
86358>>>>>>>>
86358>>>>>>>
86358>>>>>>>        Case Begin
86358>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
86360>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
86360>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
86360>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
86361>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
86362>>>>>>>
86362>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
86363>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
86364>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
86365>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
86366>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
86367>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
86368>>>>>>>                Case Break
86369>>>>>>>            Case Else
86369>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
86370>>>>>>>        Case End
86370>>>>>>>
86370>>>>>>>        Function_Return bOK
86371>>>>>>>    End_Function
86372>>>>>>>
86372>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
86372>>>>>>>    // that "fits" in the max allowed length for table names.
86372>>>>>>>    // Max number of characters allowed for table names;
86372>>>>>>>    // IBM DB2      = 128
86372>>>>>>>    // MS-SQL       = 128
86372>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
86372>>>>>>>    // MySQL        = 64
86372>>>>>>>    // PostgreSQL   = 64
86372>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
86374>>>>>>>        String sGUIDName
86374>>>>>>>        Integer iDbType iLength
86374>>>>>>>        
86374>>>>>>>        Get piDbType to iDbType
86375>>>>>>>        Move (RandomHexUUID()) to sGUIDName
86376>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
86377>>>>>>>        Move (Length(sGUIDName)) to iLength
86378>>>>>>>        
86378>>>>>>>        Case Begin
86378>>>>>>>            Case (iDbType = EN_DbTypeDB2)
86380>>>>>>>            If (iLength > 128) Begin
86382>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86383>>>>>>>            End
86383>>>>>>>>
86383>>>>>>>            Case Break
86384>>>>>>>
86384>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
86387>>>>>>>            If (iLength > 128) Begin
86389>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86390>>>>>>>            End
86390>>>>>>>>
86390>>>>>>>            Case Break
86391>>>>>>>
86391>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
86394>>>>>>>            If (iLength > 128) Begin
86396>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86397>>>>>>>            End
86397>>>>>>>>
86397>>>>>>>            Case Break
86398>>>>>>>
86398>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
86401>>>>>>>            If (iLength > 64) Begin
86403>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86404>>>>>>>            End
86404>>>>>>>>
86404>>>>>>>            Case Break
86405>>>>>>>
86405>>>>>>>            Case (iDbType = EN_DbTypePostgre)
86408>>>>>>>            If (iLength > 64) Begin
86410>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86411>>>>>>>            End
86411>>>>>>>>
86411>>>>>>>        Case End
86411>>>>>>>       
86411>>>>>>>        Function_Return sGUIDName   
86412>>>>>>>    End_Function
86413>>>>>>>       
86413>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
86413>>>>>>>    // Pass the memory resource file reference and the filename to be created,
86413>>>>>>>    // including full path.
86413>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
86415>>>>>>>        String sText
86415>>>>>>>        Integer iCh iSize iArgSize
86415>>>>>>>
86415>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
86416>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
86417>>>>>>>            Get_Channel_Size iCh to iSize
86418>>>>>>>            Get_Argument_Size to iArgSize
86419>>>>>>>            If (iSize > iArgSize) Begin
86421>>>>>>>                Set_Argument_Size iSize
86422>>>>>>>>
86422>>>>>>>            End
86422>>>>>>>>
86422>>>>>>>            Read_Block channel iCh sText iSize
86424>>>>>>>        Send Seq_Close_Channel iCh
86425>>>>>>>
86425>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
86426>>>>>>>            Write channel iCh sText
86428>>>>>>>        Send Seq_Close_Channel iCh
86429>>>>>>>
86429>>>>>>>        If (iSize <> iArgSize) Begin
86431>>>>>>>            Set_Argument_Size iArgSize
86432>>>>>>>>
86432>>>>>>>        End
86432>>>>>>>>
86432>>>>>>>
86432>>>>>>>        // Wait for file to be written to disk.
86432>>>>>>>        Sleep 2
86433>>>>>>>    End_Procedure
86434>>>>>>>
86434>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
86436>>>>>>>        String sNotNull sRetval sDefaultValue
86436>>>>>>>        Boolean bOK
86436>>>>>>>
86436>>>>>>>        Get IsSQLDriver sDriverID to bOK
86437>>>>>>>        If (bOK = False) Begin
86439>>>>>>>            Function_Return ""
86440>>>>>>>        End
86440>>>>>>>>
86440>>>>>>>
86440>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
86441>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
86442>>>>>>>
86442>>>>>>>        Case Begin
86442>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
86444>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
86445>>>>>>>                Case Break
86446>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
86449>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86450>>>>>>>                Case Break
86451>>>>>>>            Case (iDbType = EN_dbTypePostgre)
86454>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86455>>>>>>>                Case Break
86456>>>>>>>            Case (iDbType = EN_dbTypeDB2)
86459>>>>>>>                Move (String(sNotNull))                                     to sRetval
86460>>>>>>>                Case Break
86461>>>>>>>
86461>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86461>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86461>>>>>>>            Case (iDbType = EN_dbTypeOracle)
86464>>>>>>>                Move  ""                                                    to sRetval
86465>>>>>>>                Case Break
86466>>>>>>>
86466>>>>>>>            Case Else
86466>>>>>>>                Move  ""                                                    to sRetval
86467>>>>>>>        Case End
86467>>>>>>>
86467>>>>>>>        Function_Return sRetval
86468>>>>>>>    End_Function
86469>>>>>>>
86469>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
86471>>>>>>>        String[] sReturnArray
86472>>>>>>>        String sValue sUserID sPassword
86472>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
86472>>>>>>>        Integer iFetchResult iRetval
86472>>>>>>>        tSQLConnection SQLConnection
86472>>>>>>>        tSQLConnection SQLConnection
86472>>>>>>>
86472>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
86473>>>>>>>        If (hoSQLHandler <> 0) Begin
86475>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86476>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
86477>>>>>>>            If (hoSQLConnect <> 0) Begin
86479>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
86480>>>>>>>                If (hStmt <> 0) Begin
86482>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
86483>>>>>>>                    If (sArgument <> "") Begin
86485>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
86486>>>>>>>                    End
86486>>>>>>>>
86486>>>>>>>                    Send SQLCall of hStmt
86487>>>>>>>
86487>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
86488>>>>>>>                    If (iRetval = 0) Begin
86490>>>>>>>                        Repeat
86490>>>>>>>>
86490>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
86491>>>>>>>                            If (iFetchResult <> 0) Begin
86493>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
86494>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86495>>>>>>>                            End
86495>>>>>>>>
86495>>>>>>>                        Until (iFetchResult = 0)
86497>>>>>>>                        Send SQLClose of hStmt
86498>>>>>>>                    End
86498>>>>>>>>
86498>>>>>>>                End
86498>>>>>>>>
86498>>>>>>>                Send SQLDisconnect of hoSQLConnect
86499>>>>>>>            End
86499>>>>>>>>
86499>>>>>>>        End
86499>>>>>>>>
86499>>>>>>>
86499>>>>>>>        Function_Return sReturnArray
86500>>>>>>>    End_Function
86501>>>>>>>
86501>>>>>>>    // Returns the index for the passed sTableName
86501>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
86501>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
86503>>>>>>>        Integer iIndex iSize iCount
86503>>>>>>>        String[] sTablesArray
86504>>>>>>>        String sVal sConnectionString
86504>>>>>>>
86504>>>>>>>        Move -1 to iIndex
86505>>>>>>>        Get psConnectionString to sConnectionString
86506>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
86507>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
86508>>>>>>>        Decrement iSize
86509>>>>>>>        For iCount from 0 to iSize
86515>>>>>>>>
86515>>>>>>>            Move sTablesArray[iCount] to sVal
86516>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
86518>>>>>>>                Move iCount to iIndex // We found it!
86519>>>>>>>                Move iSize to iCount  // End the loop
86520>>>>>>>            End
86520>>>>>>>>
86520>>>>>>>        Loop
86521>>>>>>>>
86521>>>>>>>
86521>>>>>>>        Function_Return iIndex
86522>>>>>>>    End_Function
86523>>>>>>>
86523>>>>>>>    // Helper function that builds a string like;
86523>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
86523>>>>>>>    Function _SqlSelectFromWhereName Returns String
86525>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
86525>>>>>>>
86525>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
86526>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
86527>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
86528>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
86529>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
86530>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
86531>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
86532>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
86533>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
86534>>>>>>>        Function_Return sRetval
86535>>>>>>>    End_Function
86536>>>>>>>
86536>>>>>>>    // Helper function to create a SQL statement like;
86536>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
86536>>>>>>>    // Used for checking if an index exists.
86536>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
86538>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
86538>>>>>>>
86538>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
86539>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
86540>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
86541>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
86542>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
86543>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
86544>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
86545>>>>>>>
86545>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
86546>>>>>>>
86546>>>>>>>        Function_Return sRetval
86547>>>>>>>    End_Function
86548>>>>>>>
86548>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
86548>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
86548>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
86550>>>>>>>        String sRetval
86550>>>>>>>        If (iLength <> 0) Begin
86552>>>>>>>            Move ("(" + String(iLength)) to sRetval
86553>>>>>>>            If (iDecimals <> 0) Begin
86555>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
86556>>>>>>>            End
86556>>>>>>>>
86556>>>>>>>            Move (sRetval + ")") to sRetval
86557>>>>>>>        End
86557>>>>>>>>
86557>>>>>>>        Function_Return sRetval
86558>>>>>>>    End_Function
86559>>>>>>>
86559>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
86561>>>>>>>        Integer i iCols iItem
86561>>>>>>>        tSqlColumnNew[] aQueryColumns
86561>>>>>>>        tSqlColumnNew[] aQueryColumns
86562>>>>>>>
86562>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
86563>>>>>>>        For i from 1 to iCols
86569>>>>>>>>
86569>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
86570>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
86571>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
86572>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
86573>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
86574>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
86575>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
86576>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
86577>>>>>>>        Loop
86578>>>>>>>>
86578>>>>>>>        Set piColumns to iCols
86579>>>>>>>        Set paQueryColumns to aQueryColumns
86580>>>>>>>    End_Procedure
86581>>>>>>>
86581>>>>>>>    // Checks that the passed sDriverID is defined.
86581>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
86581>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
86583>>>>>>>        Boolean bOK
86583>>>>>>>        Integer iDriver
86583>>>>>>>
86583>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86585>>>>>>>            Function_Return False
86586>>>>>>>        End
86586>>>>>>>>
86586>>>>>>>
86586>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
86587>>>>>>>
86587>>>>>>>        If (bOK = False) Begin
86589>>>>>>>            Get IsMertechDriver sDriverID to bOK
86590>>>>>>>        End
86590>>>>>>>>
86590>>>>>>>
86590>>>>>>>        If (bOK = False) Begin
86592>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
86593>>>>>>>>
86593>>>>>>>            Function_Return False
86594>>>>>>>        End
86594>>>>>>>>
86594>>>>>>>
86594>>>>>>>        Get DriverIndex sDriverID to iDriver
86595>>>>>>>        If (iDriver = 0) Begin
86597>>>>>>>            Load_Driver sDriverID
86598>>>>>>>        End
86598>>>>>>>>
86598>>>>>>>
86598>>>>>>>        Function_Return True
86599>>>>>>>    End_Function
86600>>>>>>>
86600>>>>>>>    // Checks that the length parameter has been passed correctly.
86600>>>>>>>    // This is only of concern for certain SQL data types.
86600>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
86602>>>>>>>        Integer iLength
86602>>>>>>>        Boolean bOK bCheckTypeLength
86602>>>>>>>
86602>>>>>>>        If (num_arguments > 1) Begin
86604>>>>>>>            Move iLen to iLength
86605>>>>>>>        End
86605>>>>>>>>
86605>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
86606>>>>>>>
86606>>>>>>>        If (bCheckTypeLength = True) Begin
86608>>>>>>>            Move (iLength > 0) to bOK
86609>>>>>>>        End
86609>>>>>>>>
86609>>>>>>>
86609>>>>>>>        Function_Return (bOK = True)
86610>>>>>>>    End_Function
86611>>>>>>>
86611>>>>>>>    Function _SqlProperTableName String sTableName Returns String
86613>>>>>>>        String sVal sSchema sDriverID sValue
86613>>>>>>>        Handle hTable
86613>>>>>>>        Integer iDbType
86613>>>>>>>
86613>>>>>>>        If (Trim(sTableName) = "") Begin
86615>>>>>>>            Function_Return ""
86616>>>>>>>        End
86616>>>>>>>>
86616>>>>>>>
86616>>>>>>>        Get psDriverID to sDriverID
86617>>>>>>>        Get piDbType   to iDbType
86618>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
86620>>>>>>>            Get psUserID to sSchema
86621>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
86621>>>>>>>            Move (Uppercase(sSchema)) to sSchema
86622>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
86623>>>>>>>            Function_Return sTableName
86624>>>>>>>        End
86624>>>>>>>>
86624>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
86626>>>>>>>            Get psDatabase to sVal
86627>>>>>>>            Move (sVal + "." + sTableName) to sTableName
86628>>>>>>>            Function_Return sTableName
86629>>>>>>>        End
86629>>>>>>>>
86629>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
86631>>>>>>>            Move ('"' + sTableName + '"') to sTableName
86632>>>>>>>            Function_Return sTableName
86633>>>>>>>        End
86633>>>>>>>>
86633>>>>>>>
86633>>>>>>>        Get psSchema to sSchema
86634>>>>>>>        If (sSchema = "") Begin
86636>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86637>>>>>>>        End
86637>>>>>>>>
86637>>>>>>>
86637>>>>>>>        Move (Uppercase(sTableName)) to sVal
86638>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
86640>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
86642>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
86643>>>>>>>            End
86643>>>>>>>>
86643>>>>>>>            Else Begin
86644>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
86645>>>>>>>            End
86645>>>>>>>>
86645>>>>>>>        End
86645>>>>>>>>
86645>>>>>>>
86645>>>>>>>        Function_Return sTableName
86646>>>>>>>    End_Function
86647>>>>>>>
86647>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
86647>>>>>>>    // the passed sFieldName has the correct spelling.
86647>>>>>>>    // Used with Embedded SQL statement calls.
86647>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
86647>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
86649>>>>>>>        String sRetval sValue sConnectionString sDriverID
86649>>>>>>>        String[] sColumnNamesArray
86650>>>>>>>        Integer iCount iColumns
86650>>>>>>>
86650>>>>>>>        Move "" to sRetval
86651>>>>>>>        Get psDriverID to sDriverID
86652>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
86653>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
86654>>>>>>>        Decrement iColumns
86655>>>>>>>
86655>>>>>>>        For iCount from 0 to iColumns
86661>>>>>>>>
86661>>>>>>>            Move sColumnNamesArray[iCount] to sValue
86662>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
86664>>>>>>>                Move sValue to sRetval
86665>>>>>>>                Move iColumns to iCount // We're done.
86666>>>>>>>            End
86666>>>>>>>>
86666>>>>>>>        Loop
86667>>>>>>>>
86667>>>>>>>
86667>>>>>>>        Function_Return sRetval
86668>>>>>>>    End_Function
86669>>>>>>>
86669>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
86671>>>>>>>        String[] sReturnArray
86672>>>>>>>        Handle hoSQLHandler
86672>>>>>>>        Integer iCount iSize iItem
86672>>>>>>>        String sServer sUser sPassword
86672>>>>>>>        tSQLConnection SQLConnection
86672>>>>>>>        tSQLConnection SQLConnection
86672>>>>>>>
86672>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
86673>>>>>>>        Send Delete_Data    of hoSQLHandler
86674>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
86675>>>>>>>
86675>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86676>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
86677>>>>>>>        Decrement iSize
86678>>>>>>>
86678>>>>>>>        For iCount from 0 to iSize
86684>>>>>>>>
86684>>>>>>>            Get String_Value of hoSQLHandler item iCount to sServer
86685>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
86686>>>>>>>            Increment iItem
86687>>>>>>>        Loop
86688>>>>>>>>
86688>>>>>>>
86688>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86689>>>>>>>
86689>>>>>>>        Function_Return sReturnArray
86690>>>>>>>    End_Function
86691>>>>>>>
86691>>>>>>>    Function _SqlTableArrayDAW Returns String[]
86693>>>>>>>        String[] sReturnArray
86694>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
86694>>>>>>>        Handle hoSQLHandler
86694>>>>>>>        Integer iCount iSize iItem
86694>>>>>>>        Boolean bOK
86694>>>>>>>        tSQLConnection SQLConnection
86694>>>>>>>        tSQLConnection SQLConnection
86694>>>>>>>
86694>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86695>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
86697>>>>>>>            Function_Return sReturnArray
86698>>>>>>>        End
86698>>>>>>>>
86698>>>>>>>
86698>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
86699>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
86700>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
86701>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
86702>>>>>>>
86702>>>>>>>        Get phoCLIHandler to hoSQLHandler
86703>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
86704>>>>>>>        Send Delete_Data  of hoSQLHandler
86705>>>>>>>
86705>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86706>>>>>>>        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
86707>>>>>>>        Move False to Err
86708>>>>>>>        Decrement iSize
86709>>>>>>>
86709>>>>>>>        For iCount from 0 to iSize
86715>>>>>>>>
86715>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
86716>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
86717>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
86718>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
86719>>>>>>>            Move (Trim(sTable)) to sTable
86720>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
86722>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
86723>>>>>>>            End
86723>>>>>>>>
86723>>>>>>>            Else Begin
86724>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
86725>>>>>>>            End
86725>>>>>>>>
86725>>>>>>>            If (bOK = True) Begin
86727>>>>>>>                Move sTable to sReturnArray[iItem]
86728>>>>>>>                Increment iItem
86729>>>>>>>            End
86729>>>>>>>>
86729>>>>>>>        Loop
86730>>>>>>>>
86730>>>>>>>
86730>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86731>>>>>>>
86731>>>>>>>        Function_Return sReturnArray
86732>>>>>>>    End_Function
86733>>>>>>>
86733>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
86735>>>>>>>        String[] sReturnArray
86736>>>>>>>        String sValue
86736>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
86736>>>>>>>        Integer iRetval iCols iFetchResult
86736>>>>>>>        tSQLConnection SQLConnection
86736>>>>>>>        tSQLConnection SQLConnection
86736>>>>>>>
86736>>>>>>>        Get phoSQLManager to hoSQLHandler
86737>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86738>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
86739>>>>>>>
86739>>>>>>>        If (hoSQLConnect <> 0) Begin
86741>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
86742>>>>>>>            If (hStmt <> 0) Begin
86744>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
86745>>>>>>>                If (sArgument <> "") Begin
86747>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
86748>>>>>>>                End
86748>>>>>>>>
86748>>>>>>>
86748>>>>>>>                Send SqlCall             of hStmt
86749>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
86750>>>>>>>                If (iRetval = 0) Begin
86752>>>>>>>                    Repeat
86752>>>>>>>>
86752>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
86753>>>>>>>                        If (iCols > 0) Begin
86755>>>>>>>                            Repeat
86755>>>>>>>>
86755>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
86756>>>>>>>                                If (iFetchResult <> 0) Begin
86758>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
86759>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
86760>>>>>>>                                End
86760>>>>>>>>
86760>>>>>>>                            Until (iFetchResult = 0)
86762>>>>>>>                        End
86762>>>>>>>>
86762>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
86763>>>>>>>                    Until (iRetval = 0)
86765>>>>>>>                    Send SqlClose of hStmt
86766>>>>>>>                End
86766>>>>>>>>
86766>>>>>>>            End
86766>>>>>>>>
86766>>>>>>>            Send SqlDisconnect of hoSQLConnect
86767>>>>>>>        End
86767>>>>>>>>
86767>>>>>>>        Function_Return sReturnArray
86768>>>>>>>    End_Function
86769>>>>>>>
86769>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
86771>>>>>>>        String[] sReturnArray
86772>>>>>>>        String sDataSource
86772>>>>>>>        Handle hoSQLHandler
86772>>>>>>>        Integer iItem
86772>>>>>>>
86772>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
86773>>>>>>>        Send SeedDataSources of hoSQLHandler
86774>>>>>>>
86774>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86775>>>>>>>
86775>>>>>>>        Repeat
86775>>>>>>>>
86775>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
86776>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
86777>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
86778>>>>>>>            Increment iItem
86779>>>>>>>        Until (sDataSource = "")
86781>>>>>>>
86781>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86782>>>>>>>
86782>>>>>>>        Function_Return sReturnArray
86783>>>>>>>    End_Function
86784>>>>>>>
86784>>>>>>>    Function _SqlDatabasesArrayODBC Returns String[]
86786>>>>>>>        String[] sReturnArray
86787>>>>>>>        String sDataSource
86787>>>>>>>        Handle hoSQLHandler
86787>>>>>>>        Integer iItem
86787>>>>>>>
86787>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
86788>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86789>>>>>>>
86789>>>>>>>        Send SeedDataSources of hoSQLHandler
86790>>>>>>>
86790>>>>>>>        Repeat
86790>>>>>>>>
86790>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
86791>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
86793>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
86794>>>>>>>                Increment iItem
86795>>>>>>>            End
86795>>>>>>>>
86795>>>>>>>        Until (sDataSource = "")
86797>>>>>>>
86797>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86798>>>>>>>
86798>>>>>>>        Function_Return sReturnArray
86799>>>>>>>    End_Function
86800>>>>>>>
86800>>>>>>>    // We might have a split Sql script where the info about which database to use is
86800>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
86800>>>>>>>    // insert it for scriplets to come after the first one.
86800>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
86802>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
86802>>>>>>>        Integer iStart iEnd iDbType
86802>>>>>>>        Boolean bOK
86802>>>>>>>
86802>>>>>>>        Get piDbType to iDbType
86803>>>>>>>        Get psDriverID to sDriverID
86804>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
86805>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
86806>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
86807>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
86808>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
86809>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
86811>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
86812>>>>>>>            Move (Pos("]", sTmp)) to iEnd
86813>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
86814>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
86815>>>>>>>            Set Private.psUseDatabase to sUseDatabase
86816>>>>>>>        End
86816>>>>>>>>
86816>>>>>>>        Else Begin
86817>>>>>>>            Move (Uppercase(sStmt)) to sTmp
86818>>>>>>>
86818>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
86818>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
86820>>>>>>>                Get Private.psUseDatabase to sUseDatabase
86821>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
86822>>>>>>>            End
86822>>>>>>>>
86822>>>>>>>
86822>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
86822>>>>>>>            // We will get an error when trying to create a view if it already exists.
86822>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
86822>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
86825>>>>>>>                // Make sure we only have one space between statements/words.
86825>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
86826>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
86827>>>>>>>                Move (Trim(sTmp)) to sTmp
86828>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
86829>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
86830>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
86832>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
86833>>>>>>>                End
86833>>>>>>>>
86833>>>>>>>                Move (Trim(sTmp)) to sTmp
86834>>>>>>>                // Remove data view as it already exists!
86834>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
86835>>>>>>>            End
86835>>>>>>>>
86835>>>>>>>        End
86835>>>>>>>>
86835>>>>>>>
86835>>>>>>>        Function_Return sStmt
86836>>>>>>>    End_Function
86837>>>>>>>
86837>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
86837>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
86839>>>>>>>        String sRetval
86839>>>>>>>        Integer iDbType iSize iItem iIndex
86839>>>>>>>        tSQLKeyWords[] SQLKeywordArray
86839>>>>>>>        tSQLKeyWords[] SQLKeywordArray
86840>>>>>>>        tSQLKeyWords   SQLKeyWords
86840>>>>>>>        tSQLKeyWords   SQLKeyWords
86840>>>>>>>
86840>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
86840>>>>>>>        Get piDbType to iDbType
86841>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
86842>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
86843>>>>>>>
86843>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
86844>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
86845>>>>>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
86846>>>>>>>
86846>>>>>>>        Function_Return sRetval
86847>>>>>>>    End_Function
86848>>>>>>>
86848>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
86848>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
86850>>>>>>>        String[] sSQLScriptArray
86851>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
86851>>>>>>>        Integer iCh iSize iArgSize iPos iCount
86851>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
86851>>>>>>>
86851>>>>>>>        Move False to bCommentStart
86852>>>>>>>        Move False to bCommentEnd
86853>>>>>>>        Move False to bDashComment
86854>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
86855>>>>>>>        Move "*/"  to sCommentEnd
86856>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
86857>>>>>>>
86857>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
86858>>>>>>>        Decrement iSize
86859>>>>>>>        Move "" to sText
86860>>>>>>>
86860>>>>>>>        For iCount from 0 to iSize
86866>>>>>>>>
86866>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
86867>>>>>>>            Move (Trim(sLine)) to sTmp
86868>>>>>>>            If (sTmp <> "") Begin
86870>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
86871>>>>>>>                If (bCommentStart = False) Begin
86873>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
86874>>>>>>>                    If (bCommentStart = False) Begin
86876>>>>>>>                    End
86876>>>>>>>>
86876>>>>>>>                End
86876>>>>>>>>
86876>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
86877>>>>>>>                If (bCommentEnd = True) Begin
86879>>>>>>>                    Move False to bCommentStart
86880>>>>>>>                End
86880>>>>>>>>
86880>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
86882>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
86883>>>>>>>                End
86883>>>>>>>>
86883>>>>>>>            End
86883>>>>>>>>
86883>>>>>>>        Loop
86884>>>>>>>>
86884>>>>>>>
86884>>>>>>>        // Update the retval struct array:
86884>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
86885>>>>>>>        Function_Return SqlScriptArray
86886>>>>>>>    End_Function
86887>>>>>>>    
86887>>>>>>>
86887>>>>>>>    // *** Database API Functions: ***
86887>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86887>>>>>>>    // make changes/updates to the database.
86887>>>>>>>    //
86887>>>>>>>    //
86887>>>>>>>    // This might not do what you think - Here's what it does:
86887>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86887>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86887>>>>>>>    // to the SQL table.
86887>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86887>>>>>>>    // already exists in SQL.
86887>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86887>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86887>>>>>>>    // restructuring an existing table.
86887>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86889>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
86889>>>>>>>        String sDriverID sTableName sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86889>>>>>>>        Handle hToTable
86889>>>>>>>        Integer iPos
86889>>>>>>>
86889>>>>>>>        Move True to bUseConnectionID
86890>>>>>>>        If (num_arguments > 1) Begin
86892>>>>>>>            Move bUseConnID to bUseConnectionID
86893>>>>>>>        End
86893>>>>>>>>
86893>>>>>>>
86893>>>>>>>        Get psDriverID to sDriverID
86894>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86894>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86895>>>>>>>        If (bExists = False) Begin
86897>>>>>>>            Function_Return False
86898>>>>>>>        End
86898>>>>>>>>
86898>>>>>>>
86898>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86899>>>>>>>        
86899>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86900>>>>>>>        If (bOK = False) Begin
86902>>>>>>>            Function_Return False
86903>>>>>>>        End
86903>>>>>>>>
86903>>>>>>>
86903>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86903>>>>>>>        // we do nothing
86903>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86904>>>>>>>        If (bExists = True) Begin
86906>>>>>>>            Function_Return False
86907>>>>>>>        End
86907>>>>>>>>
86907>>>>>>>
86907>>>>>>>        Get psConnectionID     to sConnectionID
86908>>>>>>>        Get psConnectionString to sConnectionString
86909>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86911>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86912>>>>>>>>
86912>>>>>>>            Function_Return False
86913>>>>>>>        End
86913>>>>>>>>
86913>>>>>>>
86913>>>>>>>        Get psSchema to sSchema
86914>>>>>>>        If (sSchema = "") Begin
86916>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86917>>>>>>>        End
86917>>>>>>>>
86917>>>>>>>
86917>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
86918>>>>>>>
86918>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
86918>>>>>>>        // was a programmer's error and we adjust for it here.
86918>>>>>>>        If (bMertechDriver = True) Begin
86920>>>>>>>            Move False to bUseConnectionID
86921>>>>>>>        End
86921>>>>>>>>
86921>>>>>>>
86921>>>>>>>        // If we should use a connection id we need to check it exists;
86921>>>>>>>        // else we create it before attempting creating the table
86921>>>>>>>        If (bUseConnectionID = True) Begin
86923>>>>>>>            Get AutoConnectionIDLogin to bOK
86924>>>>>>>            If (bOk = False) Begin
86926>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86927>>>>>>>>
86927>>>>>>>                Function_Return False
86928>>>>>>>            End
86928>>>>>>>>
86928>>>>>>>        End
86928>>>>>>>>
86928>>>>>>>
86928>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86931>>>>>>>        Get _TableNameOnly sRootName to sRootName
86932>>>>>>>        If (sRootName = "") Begin
86934>>>>>>>            Function_Return False
86935>>>>>>>        End
86935>>>>>>>>
86935>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86936>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86939>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName  
86942>>>>>>>
86942>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86942>>>>>>>        // because then the table should not be visible to users.
86942>>>>>>>        Move (Pos("@", sDisplayName)) to iPos
86943>>>>>>>        If (iPos <> 1) Begin
86945>>>>>>>            If (sDisplayName contains ".") Begin
86947>>>>>>>                Move (Pos(".", sDisplayName)) to iPos
86948>>>>>>>                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86949>>>>>>>                Move (sSchema + "." + sDisplayName)       to sDisplayName
86950>>>>>>>            End
86950>>>>>>>>
86950>>>>>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86952>>>>>>>                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86953>>>>>>>            End
86953>>>>>>>>
86953>>>>>>>        End
86953>>>>>>>>
86953>>>>>>>
86953>>>>>>>        If (bIsAlias = False) Begin
86955>>>>>>>            Get OpenTableExclusive hTable to bOpened
86956>>>>>>>            If (bOpened = False) Begin
86958>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86959>>>>>>>>
86959>>>>>>>                Function_Return False
86960>>>>>>>            End
86960>>>>>>>>
86960>>>>>>>        End
86960>>>>>>>>
86960>>>>>>>
86960>>>>>>>        If (ghoProgressBar <> 0) Begin
86962>>>>>>>            Send DoAdvance of ghoProgressBar
86963>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86964>>>>>>>        End
86964>>>>>>>>
86964>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86964>>>>>>>        Move hTable to hToTable
86965>>>>>>>        Move False to Err
86966>>>>>>>
86966>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86966>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
86966>>>>>>>        // a proper and updated .int file.
86966>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86969>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86970>>>>>>>        
86970>>>>>>>        If (bIsAlias = False) Begin
86972>>>>>>>            Structure_Start hToTable sDriverID
86973>>>>>>>                If (bUseConnectionID = True) Begin
86975>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86978>>>>>>>                End
86978>>>>>>>>
86978>>>>>>>                Else Begin
86979>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86982>>>>>>>                End
86982>>>>>>>>
86982>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86985>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86985>>>>>>>                Move False to Err
86986>>>>>>>                Move 0 to LastErr
86987>>>>>>>            Structure_End hToTable
86989>>>>>>>        End
86989>>>>>>>>
86989>>>>>>>
86989>>>>>>>        Move (not(Err)) to bOK
86990>>>>>>>        If (bOK = True) Begin
86992>>>>>>>            // The attributes set above will always trigger an error
86992>>>>>>>            // We also adjust the Filelist entries
86992>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86995>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86998>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87001>>>>>>>
87001>>>>>>>            // This pseudo updates the .int file to make it up-to-date with the SQL back-end.
87001>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
87002>>>>>>>        End
87002>>>>>>>>
87002>>>>>>>
87002>>>>>>>        Function_Return (bOK = True)
87003>>>>>>>    End_Function
87004>>>>>>>
87004>>>>>>>    // Sample usage:
87004>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
87004>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
87004>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
87006>>>>>>>        Boolean bOK
87006>>>>>>>
87006>>>>>>>        Get AutoConnectionIDLogin to bOK
87007>>>>>>>        Move False to Err
87008>>>>>>>        Get OpenTableExclusive hTable to bOK
87009>>>>>>>        If (bOK = False) Begin
87011>>>>>>>            Function_Return False
87012>>>>>>>        End
87012>>>>>>>>
87012>>>>>>>        Structure_Start hTable
87013>>>>>>>            Set_Attribute iAttribute of hTable to iValue
87016>>>>>>>        Structure_End hTable
87018>>>>>>>
87018>>>>>>>        Function_Return (Err = False)
87019>>>>>>>    End_Function
87020>>>>>>>
87020>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
87020>>>>>>>    // or to change the filelist slot names.
87020>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
87022>>>>>>>        Boolean bExists
87022>>>>>>>        Integer iPos
87022>>>>>>>        
87022>>>>>>>        Move False to Err
87023>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
87024>>>>>>>        If (bExists = False) Begin
87026>>>>>>>            Function_Return False
87027>>>>>>>        End
87027>>>>>>>>
87027>>>>>>>
87027>>>>>>>        If (ghoProgressBar <> 0) Begin
87029>>>>>>>            Send DoAdvance of ghoProgressBar
87030>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
87031>>>>>>>        End
87031>>>>>>>>
87031>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
87031>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
87033>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87036>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87039>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87042>>>>>>>            Function_Return (Err = False) // And we're done.
87043>>>>>>>        End
87043>>>>>>>>
87043>>>>>>>
87043>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87045>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87048>>>>>>>        End
87048>>>>>>>>
87048>>>>>>>        Else Begin
87049>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87052>>>>>>>        End
87052>>>>>>>>
87052>>>>>>>
87052>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87055>>>>>>>
87055>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
87057>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
87060>>>>>>>        End
87060>>>>>>>>
87060>>>>>>>        Else Begin
87061>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87064>>>>>>>        End
87064>>>>>>>>
87064>>>>>>>
87064>>>>>>>        Function_Return (Err = False)
87065>>>>>>>    End_Function
87066>>>>>>>
87066>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
87068>>>>>>>        Boolean bOK
87068>>>>>>>
87068>>>>>>>        Get AutoConnectionIDLogin to bOK
87069>>>>>>>        Move False to Err
87070>>>>>>>        Get OpenTableExclusive hTable to bOK
87071>>>>>>>        If (bOK = False) Begin
87073>>>>>>>            Function_Return False
87074>>>>>>>        End
87074>>>>>>>>
87074>>>>>>>
87074>>>>>>>        Structure_Start hTable
87075>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
87078>>>>>>>        Structure_End hTable
87080>>>>>>>
87080>>>>>>>        Function_Return (Err = False)
87081>>>>>>>    End_Function
87082>>>>>>>
87082>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
87084>>>>>>>        Boolean bOK
87084>>>>>>>
87084>>>>>>>        Move False to Err
87085>>>>>>>        Get AutoConnectionIDLogin to bOK
87086>>>>>>>        Open hToTable
87088>>>>>>>        Get OpenTableExclusive hTable to bOK
87089>>>>>>>        If (bOK = False) Begin
87091>>>>>>>            Function_Return False
87092>>>>>>>        End
87092>>>>>>>>
87092>>>>>>>
87092>>>>>>>        Structure_Start hTable
87093>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
87096>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
87099>>>>>>>        Structure_End hTable
87101>>>>>>>
87101>>>>>>>        Function_Return (Err = False)
87102>>>>>>>    End_Function
87103>>>>>>>
87103>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
87105>>>>>>>        Integer[] iTableConvertExceptions
87106>>>>>>>        Get piTableConvertExceptions to iTableConvertExceptions
87107>>>>>>>        Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
87108>>>>>>>        Set piTableConvertExceptions to iTableConvertExceptions
87109>>>>>>>    End_Procedure
87110>>>>>>>
87110>>>>>>>    Procedure ApiTableConvertALLToSql
87112>>>>>>>        Integer[] iTablesArray
87113>>>>>>>        Integer iSize iCount
87113>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
87113>>>>>>>        String sDriverID
87113>>>>>>>
87113>>>>>>>        Get psDriverID to sDriverID
87114>>>>>>>        Get pbUseConnectionID to bUseConnectionID
87115>>>>>>>        Get pbToANSI          to bToANSI
87116>>>>>>>        Get pbRecnum          to bRecnum
87117>>>>>>>        Get pbCopyData        to bCopyData
87118>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
87120>>>>>>>            Get pbContinueOnError to bContinueOnError
87121>>>>>>>        End
87121>>>>>>>>
87121>>>>>>>
87121>>>>>>>        Get _AllTablesToConvert to iTablesArray
87122>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
87123>>>>>>>        Decrement iSize
87124>>>>>>>        For iCount from 0 to iSize
87130>>>>>>>>
87130>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
87131>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
87131>>>>>>>            // if there was an error converting one table...
87131>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
87131>>>>>>>        Loop
87132>>>>>>>>
87132>>>>>>>
87132>>>>>>>    End_Procedure
87133>>>>>>>
87133>>>>>>>    Procedure ApiTableAttachALLToSql 
87135>>>>>>>        Integer[] iTablesArray
87136>>>>>>>        Integer iSize iCount
87136>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
87136>>>>>>>        String sDriverID
87136>>>>>>>
87136>>>>>>>        Get psDriverID to sDriverID
87137>>>>>>>        Get pbUseConnectionID to bUseConnectionID
87138>>>>>>>        Get pbToANSI          to bToANSI
87139>>>>>>>        Get pbRecnum          to bRecnum
87140>>>>>>>        Get pbCopyData        to bCopyData
87141>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
87143>>>>>>>            Get pbContinueOnError to bContinueOnError
87144>>>>>>>        End
87144>>>>>>>>
87144>>>>>>>
87144>>>>>>>        Get _AllTablesToConvert to iTablesArray
87145>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
87146>>>>>>>        Decrement iSize
87147>>>>>>>        For iCount from 0 to iSize
87153>>>>>>>>
87153>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
87154>>>>>>>        Loop
87155>>>>>>>>
87155>>>>>>>
87155>>>>>>>    End_Procedure
87156>>>>>>>
87156>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
87158>>>>>>>        Handle hToTable hoLogFile
87158>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
87158>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sEmpty sConnectionID sConnectionString
87158>>>>>>>        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
87158>>>>>>>        tSQLConnection SQLConnection
87158>>>>>>>        tSQLConnection SQLConnection
87158>>>>>>>
87158>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
87159>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
87159>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
87159>>>>>>>        If (bIsAlias = True) Begin   
87161>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87164>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
87166>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName) 
87169>>>>>>>                Get psConnectionID to sConnectionID
87170>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
87171>>>>>>>            End
87171>>>>>>>>
87171>>>>>>>            Function_Return True
87172>>>>>>>        End
87172>>>>>>>>
87172>>>>>>>        
87172>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
87175>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87178>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87181>>>>>>>
87181>>>>>>>        If (ghoProgressBar <> 0) Begin
87183>>>>>>>            Send DoAdvance of ghoProgressBar
87184>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sLogicalName) * "Number:" * String(hTable))
87185>>>>>>>        End  
87185>>>>>>>>
87185>>>>>>>        
87185>>>>>>>        // Marco Kuipers suggestion;
87185>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
87185>>>>>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
87185>>>>>>>        // table again.
87185>>>>>>>        Get UtilTableIsSQL hTable to bOK
87186>>>>>>>        If (bOK = False) Begin
87188>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists 
87189>>>>>>>            If (bExists = True) Begin
87191>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87192>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87193>>>>>>>                Get phoLogFile to hoLogFile
87194>>>>>>>                If (hoLogFile <> 0) Begin
87196>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
87197>>>>>>>                    Send LogError sWarning False
87198>>>>>>>                End                                        
87198>>>>>>>>
87198>>>>>>>                Else Begin
87199>>>>>>>                    Error DFERR_PROGRAM sWarning
87200>>>>>>>>
87200>>>>>>>                End
87200>>>>>>>>
87200>>>>>>>            End
87200>>>>>>>>
87200>>>>>>>        End
87200>>>>>>>>
87200>>>>>>>        
87200>>>>>>>        // Does the rootname contain a driver?
87200>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87202>>>>>>>            // Does the table already exist as an SQL table?
87202>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87203>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87203>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87203>>>>>>>            If (bExists = False) Begin
87205>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
87206>>>>>>>            End
87206>>>>>>>>
87206>>>>>>>            If (bExists = True) Begin
87208>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
87209>>>>>>>                Function_Return False
87210>>>>>>>            End
87210>>>>>>>>
87210>>>>>>>        End
87210>>>>>>>>
87210>>>>>>>
87210>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87211>>>>>>>        If (bToAnsi = False) Begin
87213>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
87214>>>>>>>        End
87214>>>>>>>>
87214>>>>>>>
87214>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
87215>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
87215>>>>>>>        // passed as True, we adjust for that here.
87215>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
87216>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
87218>>>>>>>            Move False to bUseConnectionID
87219>>>>>>>        End
87219>>>>>>>>
87219>>>>>>>
87219>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87220>>>>>>>        Move SQLConnection.sSchema           to sSchema
87221>>>>>>>        If (sSchema = "") Begin
87223>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema 
87224>>>>>>>            Move (Lowercase(sSchema))        to sSchema
87225>>>>>>>        End
87225>>>>>>>>
87225>>>>>>>
87225>>>>>>>        If (sDriverID = ORAFLEX) Begin
87227>>>>>>>            Move SQLConnection.sUserID       to sSchema
87228>>>>>>>        End
87228>>>>>>>>
87228>>>>>>>
87228>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
87229>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
87230>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
87231>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
87233>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
87234>>>>>>>>
87234>>>>>>>            Function_Return False
87235>>>>>>>        End
87235>>>>>>>>
87235>>>>>>>
87235>>>>>>>        Get AutoConnectionIDLogin to bOK
87236>>>>>>>        Open hTable
87238>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87241>>>>>>>        If (bOpened = False) Begin
87243>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
87244>>>>>>>>
87244>>>>>>>            Function_Return False
87245>>>>>>>        End
87245>>>>>>>>
87245>>>>>>>
87245>>>>>>>        If (ghoProgressBar <> 0) Begin
87247>>>>>>>            Send DoAdvance of ghoProgressBar
87248>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
87249>>>>>>>        End  
87249>>>>>>>>
87249>>>>>>>        
87249>>>>>>>        Move 0 to hToTable
87250>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
87251>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
87252>>>>>>>
87252>>>>>>>        Case Begin
87252>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
87254>>>>>>>                Case Break
87255>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
87258>>>>>>>                Case Break
87259>>>>>>>            Case (sDriverID = DB2_DRV_ID)
87262>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87263>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
87264>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87265>>>>>>>                Case Break
87266>>>>>>>            Case (sDriverID = ORAFLEX)
87269>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87270>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87271>>>>>>>                Case Break
87272>>>>>>>            Case (sDriverID = MDSMySQL)
87275>>>>>>>                Case Break
87276>>>>>>>            Case (sDriverID = MDSPgSQL)
87279>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87280>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87281>>>>>>>                Case Break
87282>>>>>>>            Case (sDriverID = DATAFLEX_ID)
87285>>>>>>>                Case Break
87286>>>>>>>            Case Else
87286>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
87287>>>>>>>>
87287>>>>>>>                Case Break
87288>>>>>>>        Case End
87288>>>>>>>
87288>>>>>>>        Move False to Err
87289>>>>>>>        
87289>>>>>>>        If (bIsAlias = False) Begin
87291>>>>>>>    
87291>>>>>>>            If (bMertechDriver = True) Begin
87293>>>>>>>                // Note: This function also sets the Err flag.
87293>>>>>>>                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
87294>>>>>>>            End
87294>>>>>>>>
87294>>>>>>>    
87294>>>>>>>            If (bMertechDriver = False) Begin
87296>>>>>>>                Structure_Start hToTable sDriverID
87297>>>>>>>                    Structure_Copy hTable to hToTable
87298>>>>>>>    
87298>>>>>>>                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
87301>>>>>>>    
87301>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
87303>>>>>>>                        If (bUseConnectionID = True) Begin
87305>>>>>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
87308>>>>>>>                        End
87308>>>>>>>>
87308>>>>>>>                        Else Begin
87309>>>>>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
87312>>>>>>>                        End
87312>>>>>>>>
87312>>>>>>>    
87312>>>>>>>                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
87315>>>>>>>                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
87318>>>>>>>    
87318>>>>>>>                        If (sSchema <> "") Begin
87320>>>>>>>                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
87323>>>>>>>                        End
87323>>>>>>>>
87323>>>>>>>    
87323>>>>>>>                        If (sDriverID = DB2_DRV_ID) Begin
87325>>>>>>>                            If (sLongTableSpace <> "") Begin
87327>>>>>>>                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
87330>>>>>>>                            End
87330>>>>>>>>
87330>>>>>>>                            If (sBaseTableSpace <> "") Begin
87332>>>>>>>                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
87335>>>>>>>                            End
87335>>>>>>>>
87335>>>>>>>                            If (sIndexTableSpace <> "") Begin
87337>>>>>>>                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
87340>>>>>>>                            End
87340>>>>>>>>
87340>>>>>>>                        End
87340>>>>>>>>
87340>>>>>>>                    End
87340>>>>>>>>
87340>>>>>>>    
87340>>>>>>>                Structure_End hToTable
87342>>>>>>>            End
87342>>>>>>>>
87342>>>>>>>    
87342>>>>>>>            Move (not(Err)) to bOK
87343>>>>>>>            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
87345>>>>>>>                If (bIsAlias = False) Begin
87347>>>>>>>                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
87348>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
87350>>>>>>>                        Get pbContinueOnError to bContinueOnError
87351>>>>>>>                    End
87351>>>>>>>>
87351>>>>>>>                    // If the data copy failed we will keep the newly created SQL table but
87351>>>>>>>                    // rename it by adding a GUID at the end of the table name
87351>>>>>>>                    // - or as much as "fit" because different SQL back-ends have
87351>>>>>>>                    // different rules how long a table name can be.
87351>>>>>>>                    // The new table will probably contain data but something went
87351>>>>>>>                    // wrong while converting the data from embedded to SQL.
87351>>>>>>>                    If (bOK = False and bContinueOnError = False) Begin
87353>>>>>>>                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87354>>>>>>>                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87355>>>>>>>                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
87356>>>>>>>>
87356>>>>>>>                    End
87356>>>>>>>>
87356>>>>>>>                End
87356>>>>>>>>
87356>>>>>>>            End
87356>>>>>>>>
87356>>>>>>>        End
87356>>>>>>>>
87356>>>>>>>        
87356>>>>>>>        If (bMertechDriver = True) Begin
87358>>>>>>>            Open hTable
87360>>>>>>>        End
87360>>>>>>>>
87360>>>>>>>
87360>>>>>>>        // This must be after copying data...
87360>>>>>>>        If (Err = False) Begin
87362>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87365>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
87365>>>>>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
87367>>>>>>>                // The max length for the display_name is 31 characters...
87367>>>>>>>                If (Length(sSchema + "." + sDisplayName) < 31) Begin
87369>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
87372>>>>>>>                End
87372>>>>>>>>
87372>>>>>>>            End
87372>>>>>>>>
87372>>>>>>>        End
87372>>>>>>>>
87372>>>>>>>        
87372>>>>>>>        Close hTable
87373>>>>>>>        Move (not(Err)) to bOK
87374>>>>>>>        Function_Return (bOK = True)
87375>>>>>>>    End_Function  
87376>>>>>>>    
87376>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
87376>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
87376>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
87376>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
87378>>>>>>>        Boolean bOpened bOK
87378>>>>>>>        Integer hToTable iIndex iCount iRetval iVoid iOrgFreq
87378>>>>>>>        String sErrorFile sEmpty sPath
87378>>>>>>>
87378>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
87381>>>>>>>        Get AutoConnectionIDLogin to bOK
87382>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87384>>>>>>>            Send IncreaseSortBufferSize
87385>>>>>>>//            Send SetAllIndexesToBatch hToTable
87385>>>>>>>        End
87385>>>>>>>>
87385>>>>>>>
87385>>>>>>>        Move False to Err
87386>>>>>>>        Open sPhysicalName as hToTable
87388>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
87391>>>>>>>        If (bOpened = False) Begin
87393>>>>>>>            Function_Return False
87394>>>>>>>        End
87394>>>>>>>>
87394>>>>>>>
87394>>>>>>>        If (ghoStatusPanel <> 0) Begin
87396>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
87397>>>>>>>        End
87397>>>>>>>>
87397>>>>>>>
87397>>>>>>>        Move "" to sEmpty
87398>>>>>>>        Move False to Err
87399>>>>>>>        Move True to bOK
87400>>>>>>>
87400>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87403>>>>>>>//        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
87403>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87405>>>>>>>            // Remove all indices to speed up copying of data:
87405>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
87410>>>>>>>            If (iRetval <> 0) Begin
87412>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table:" * sRootName)
87413>>>>>>>>
87413>>>>>>>                Function_Return False
87414>>>>>>>            End
87414>>>>>>>>
87414>>>>>>>        End
87414>>>>>>>>
87414>>>>>>>
87414>>>>>>>        Move (sRootName + ".err") to sErrorFile
87415>>>>>>>        Move 0 to iIndex
87416>>>>>>>        Move False to Err
87417>>>>>>>
87417>>>>>>>        Copy_Records hFromTable to hToTable using 0 Callback Self
87420>>>>>>>
87420>>>>>>>        If (Err = False) Begin
87422>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
87423>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
87424>>>>>>>        End
87424>>>>>>>>
87424>>>>>>>
87424>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87426>>>>>>>            // Recreate indices:
87426>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
87431>>>>>>>        End
87431>>>>>>>>
87431>>>>>>>
87431>>>>>>>        Close hToTable
87432>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87435>>>>>>>
87435>>>>>>>        If (bOK = True) Begin
87437>>>>>>>            Move (not(Err)) to bOK
87438>>>>>>>        End
87438>>>>>>>>
87438>>>>>>>
87438>>>>>>>        If (ghoStatusPanel <> 0) Begin
87440>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
87441>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87442>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87443>>>>>>>        End
87443>>>>>>>>
87443>>>>>>>
87443>>>>>>>        Function_Return (bOK = True)
87444>>>>>>>    End_Function
87445>>>>>>>
87445>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
87445>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
87445>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
87447>>>>>>>        Handle hFile
87447>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
87447>>>>>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
87447>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened
87447>>>>>>>        tSQLConnection SQLConnection
87447>>>>>>>        tSQLConnection SQLConnection
87447>>>>>>>        tAPIColumn[] aColumns
87447>>>>>>>        tAPIColumn[] aColumns
87448>>>>>>>        tColumnType ColumnType
87448>>>>>>>        tColumnType ColumnType
87448>>>>>>>        
87448>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
87448>>>>>>>        Get UtilTableExists hTable to bOk
87449>>>>>>>        If (bOk = True) Begin
87451>>>>>>>            Function_Return False
87452>>>>>>>        End
87452>>>>>>>>
87452>>>>>>>        
87452>>>>>>>        Move sLogicalName to sTableName
87453>>>>>>>        If (ghoProgressBar <> 0) Begin
87455>>>>>>>            Send DoAdvance of ghoProgressBar
87456>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable))
87457>>>>>>>        End
87457>>>>>>>>
87457>>>>>>>
87457>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87458>>>>>>>        Get psDriverID to sDriverID
87459>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
87460>>>>>>>        Get piDbType to iDbType
87461>>>>>>>
87461>>>>>>>        // If no columns passed in, we need to create a "dummy" column 
87461>>>>>>>        Move False to bDeleteDummy 
87462>>>>>>>        If (Num_Arguments = 8) Begin
87464>>>>>>>            Move aColumnIn to aColumns
87465>>>>>>>        End
87465>>>>>>>>
87465>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87467>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87468>>>>>>>            Move ColumnType.iType to iDataType
87469>>>>>>>            If (bRecnum = False) Begin
87471>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
87472>>>>>>>            End                                            
87472>>>>>>>>
87472>>>>>>>            Else Begin
87473>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
87474>>>>>>>            End
87474>>>>>>>>
87474>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87475>>>>>>>            Move True to bDeleteDummy 
87476>>>>>>>        End  
87476>>>>>>>>
87476>>>>>>>        
87476>>>>>>>        // If columns have been passed as an array we need to check if an identity column
87476>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87476>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be 
87476>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
87476>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87478>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
87479>>>>>>>            Decrement iSize
87480>>>>>>>            for iCount from 0 to iSize
87486>>>>>>>>
87486>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87488>>>>>>>                    Move False to bRecnum  
87489>>>>>>>                    Move iSize to iCount
87490>>>>>>>                End
87490>>>>>>>>
87490>>>>>>>            Loop
87491>>>>>>>>
87491>>>>>>>        End
87491>>>>>>>>
87491>>>>>>>        
87491>>>>>>>        // If this is a SQL based driver we also check if the table exists
87491>>>>>>>        // in the SQL back end; in case we do nothing.
87491>>>>>>>        If (bSqlDriver = True) Begin
87493>>>>>>>            // Get all connection properties
87493>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87494>>>>>>>            Move SQLConnection.sSchema to sSchema
87495>>>>>>>            If (sSchema = "") Begin
87497>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87498>>>>>>>            End   
87498>>>>>>>>
87498>>>>>>>
87498>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87499>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
87499>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
87499>>>>>>>            If (bExists = False) Begin
87501>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87502>>>>>>>            End
87502>>>>>>>>
87502>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87502>>>>>>>            // we will just add it to Filelist.cfg
87502>>>>>>>            If (bExists = True) Begin
87504>>>>>>>                If (bExistsInFilelist = False) Begin
87506>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87508>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87509>>>>>>>                    End
87509>>>>>>>>
87509>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87512>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87515>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName                        
87518>>>>>>>                    Move False to bSysFile
87519>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
87520>>>>>>>                End
87520>>>>>>>>
87520>>>>>>>                Function_Return False
87521>>>>>>>            End
87521>>>>>>>>
87521>>>>>>>        End
87521>>>>>>>>
87521>>>>>>>
87521>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87522>>>>>>>        If (num_arguments > 6) Begin
87524>>>>>>>            If (bANSI = False) Begin
87526>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
87527>>>>>>>            End
87527>>>>>>>>
87527>>>>>>>        End
87527>>>>>>>>
87527>>>>>>>
87527>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
87527>>>>>>>        // is a programmer's error and we auto-correct for it here.
87527>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
87527>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
87527>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
87527>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
87527>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
87528>>>>>>>        If (bMertechDriver = True) Begin
87530>>>>>>>            If (bUseConnectionID = True) Begin
87532>>>>>>>                Move False to bUseConnectionID
87533>>>>>>>            End
87533>>>>>>>>
87533>>>>>>>            Move sDriverID to sOriginalDriverID
87534>>>>>>>            Move DATAFLEX_ID to sDriverID
87535>>>>>>>        End
87535>>>>>>>>
87535>>>>>>>
87535>>>>>>>        Move False to Err
87536>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87538>>>>>>>            Move sRootName to sPhysicalFile
87539>>>>>>>        End
87539>>>>>>>>
87539>>>>>>>
87539>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87541>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
87542>>>>>>>
87542>>>>>>>            // If DAW driver and we should use a connection id we need to
87542>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
87542>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
87544>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87545>>>>>>>                If (bExists = False) Begin
87547>>>>>>>                    Get UtilCreateConnectionID sConnectionID to bOk
87548>>>>>>>                    If (bOk = False) Begin
87550>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87551>>>>>>>>
87551>>>>>>>                        Function_Return False
87552>>>>>>>                    End
87552>>>>>>>>
87552>>>>>>>                End
87552>>>>>>>>
87552>>>>>>>            End
87552>>>>>>>>
87552>>>>>>>
87552>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87554>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
87555>>>>>>>            End                                            
87555>>>>>>>>
87555>>>>>>>            Else Begin
87556>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
87557>>>>>>>            End
87557>>>>>>>>
87557>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
87558>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
87560>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87561>>>>>>>            End
87561>>>>>>>>
87561>>>>>>>        End
87561>>>>>>>>
87561>>>>>>>        Move False to Err
87562>>>>>>>        Move 0 to hFile
87563>>>>>>>
87563>>>>>>>        Structure_Start hFile sDriverID
87564>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
87566>>>>>>>                If (bUseConnectionID = True) Begin
87568>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87571>>>>>>>                End
87571>>>>>>>>
87571>>>>>>>                Else Begin
87572>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87575>>>>>>>                End
87575>>>>>>>>
87575>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87578>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87581>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87584>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87587>>>>>>>
87587>>>>>>>                If (sSchema <> "") Begin
87589>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87592>>>>>>>                End
87592>>>>>>>>
87592>>>>>>>
87592>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
87594>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87596>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87599>>>>>>>                    End
87599>>>>>>>>
87599>>>>>>>                End
87599>>>>>>>>
87599>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
87601>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
87603>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
87606>>>>>>>                    End
87606>>>>>>>>
87606>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
87608>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
87611>>>>>>>                    End
87611>>>>>>>>
87611>>>>>>>                End
87611>>>>>>>>
87611>>>>>>>            End
87611>>>>>>>>
87611>>>>>>>
87611>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME                of hFile to sPhysicalFile
87614>>>>>>>            Send ApiColumnsAddToTable hFile aColumns True
87615>>>>>>>        Structure_End hFile
87617>>>>>>>
87617>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
87617>>>>>>>        If (bMertechDriver = True) Begin
87619>>>>>>>            Move sOriginalDriverID to sDriverID
87620>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
87622>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87623>>>>>>>            End
87623>>>>>>>>
87623>>>>>>>            // Note: This function also sets the Err flag.
87623>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
87624>>>>>>>        End
87624>>>>>>>>
87624>>>>>>>
87624>>>>>>>        Move (not(Err)) to bOK
87625>>>>>>>        If (bOk = True) Begin
87627>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87629>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
87630>>>>>>>            End
87630>>>>>>>>
87630>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87633>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87636>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87639>>>>>>>
87639>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
87639>>>>>>>            If (bDeleteDummy) Begin
87641>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
87642>>>>>>>            End
87642>>>>>>>>
87642>>>>>>>        End
87642>>>>>>>>
87642>>>>>>>        
87642>>>>>>>        Close hTable
87643>>>>>>>        Function_Return (bOK = True)
87644>>>>>>>    End_Function
87645>>>>>>>
87645>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
87647>>>>>>>        Boolean bExists
87647>>>>>>>
87647>>>>>>>        Move False to Err
87648>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
87651>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
87654>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
87657>>>>>>>
87657>>>>>>>        Function_Return (Err = False)
87658>>>>>>>    End_Function
87659>>>>>>>
87659>>>>>>>    // ToDo: Needs to be revised
87659>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
87661>>>>>>>        Handle hTable
87661>>>>>>>        String sDEFName sDataPath sDriverID
87661>>>>>>>        Boolean bExists
87661>>>>>>>
87661>>>>>>>        // Do nothing if MSSQL Driver.
87661>>>>>>>//        Get IsMSSQLDriver to bExists
87661>>>>>>>//        If (bExists = True) Begin
87661>>>>>>>//            Procedure_Return
87661>>>>>>>//        End
87661>>>>>>>
87661>>>>>>>        Get psDataPathFirstPart to sDataPath
87662>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
87663>>>>>>>        If (bExists = True) Begin
87665>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
87665>>>>>>>            // still be missing from the filelist and needs to be added.
87665>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
87666>>>>>>>            If (bExists = True) Begin
87668>>>>>>>                Procedure_Return
87669>>>>>>>            End
87669>>>>>>>>
87669>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
87669>>>>>>>            Else Begin
87670>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
87673>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
87676>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
87679>>>>>>>                Procedure_Return
87680>>>>>>>            End
87680>>>>>>>>
87680>>>>>>>        End
87680>>>>>>>>
87680>>>>>>>
87680>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
87681>>>>>>>        Move 0 to hTable
87682>>>>>>>        Move False to Err
87683>>>>>>>
87683>>>>>>>        Structure_Start hTable DATAFLEX_ID
87684>>>>>>>            Load_Def sDEFName Onto hTable
87685>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
87688>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
87690>>>>>>>
87690>>>>>>>        Move iFilelistSlot to hTable
87691>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
87694>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87697>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87700>>>>>>>
87700>>>>>>>    End_Procedure
87701>>>>>>>
87701>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
87703>>>>>>>        Boolean bTmp bErr bOK
87703>>>>>>>        String sTableName sDisplayName sFileName sDBOKeyWord sVal
87703>>>>>>>
87703>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
87703>>>>>>>        Move Err to bTmp
87704>>>>>>>        Move False to Err
87705>>>>>>>
87705>>>>>>>        Get AutoConnectionIDLogin to bOK
87706>>>>>>>        // First get the info for the current filelist slot:
87706>>>>>>>        Open iFromFileSlot
87708>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
87711>>>>>>>        If (bOK = True) Begin
87713>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
87716>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
87719>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
87722>>>>>>>
87722>>>>>>>            //...then move it.
87722>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
87725>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
87728>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
87731>>>>>>>
87731>>>>>>>            //...and finally remove the old filelist values.
87731>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
87734>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
87737>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
87740>>>>>>>        End
87740>>>>>>>>
87740>>>>>>>        Close iFromFileSlot
87741>>>>>>>
87741>>>>>>>        Move Err to bErr
87742>>>>>>>        Move bTmp to Err
87743>>>>>>>        Function_Return (bErr = False)
87744>>>>>>>    End_Function
87745>>>>>>>
87745>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
87747>>>>>>>        Handle hTable
87747>>>>>>>        Boolean bOK
87747>>>>>>>
87747>>>>>>>        Get AutoConnectionIDLogin to bOK
87748>>>>>>>        Move False to Err
87749>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
87751>>>>>>>        If (hTableTo > 0) Begin
87753>>>>>>>            Open hTableTo
87755>>>>>>>        End
87755>>>>>>>>
87755>>>>>>>        Move hTableFrom to hTable
87756>>>>>>>
87756>>>>>>>        Structure_Start hTable
87757>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87760>>>>>>>            If (iColumnTo <> 0) Begin
87762>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87765>>>>>>>            End
87765>>>>>>>>
87765>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE
87767>>>>>>>
87767>>>>>>>        Close hTableFrom
87768>>>>>>>        If (hTableTo > 0) Begin
87770>>>>>>>            Close hTableTo
87771>>>>>>>        End
87771>>>>>>>>
87771>>>>>>>
87771>>>>>>>        Function_Return (Err = False)
87772>>>>>>>    End_Function
87773>>>>>>>
87773>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87773>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
87775>>>>>>>        String sTableName sDriverID
87775>>>>>>>        Boolean bOk
87775>>>>>>>        String sDataPath
87775>>>>>>>
87775>>>>>>>        Get AutoConnectionIDLogin to bOK
87776>>>>>>>        Move False to Err
87777>>>>>>>        Get psDriverID to sDriverID
87778>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87779>>>>>>>        If (sTableName = "") Begin
87781>>>>>>>            Function_Return False
87782>>>>>>>        End
87782>>>>>>>>
87782>>>>>>>
87782>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87783>>>>>>>        Delete_db sTableName
87784>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87785>>>>>>>
87785>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87787>>>>>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
87788>>>>>>>            Get psDataPathFirstPart to sDataPath
87789>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87790>>>>>>>        End
87790>>>>>>>>
87790>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87790>>>>>>>        If (hTable <> 0) Begin
87792>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87795>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87798>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87801>>>>>>>        End
87801>>>>>>>>
87801>>>>>>>        
87801>>>>>>>        Close hTable
87802>>>>>>>        Function_Return (hTable <> 0)
87803>>>>>>>    End_Function
87804>>>>>>>
87804>>>>>>>    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
87806>>>>>>>        Handle hTable
87806>>>>>>>        Boolean bOK
87806>>>>>>>
87806>>>>>>>        Get AutoConnectionIDLogin to bOK
87807>>>>>>>        Move False to Err
87808>>>>>>>        Open hTableTo Mode DF_EXCLUSIVE
87810>>>>>>>        Move hTableTo to hTable
87811>>>>>>>
87811>>>>>>>        Structure_Start hTable
87812>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87815>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE
87817>>>>>>>
87817>>>>>>>        Close hTableTo
87818>>>>>>>        Function_Return (Err = False)
87819>>>>>>>    End_Function
87820>>>>>>>
87820>>>>>>>    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87822>>>>>>>        String sPhysicalName sDataPath sDriverID
87822>>>>>>>        Boolean bOK bExists
87822>>>>>>>        Integer iRetval
87822>>>>>>>
87822>>>>>>>        Move False to Err
87823>>>>>>>        Get psDataPathFirstPart to sDataPath
87824>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87827>>>>>>>
87827>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87830>>>>>>>        Close hTable
87831>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87833>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
87834>>>>>>>            If (bExists = True) Begin
87836>>>>>>>                If (Uppercase(sPhysicalName) = Uppercase(sRootName)) Begin
87838>>>>>>>                    Function_Return False
87839>>>>>>>                End
87839>>>>>>>>
87839>>>>>>>            End
87839>>>>>>>>
87839>>>>>>>            Copy_db (sDataPath + sPhysicalName) to (sDataPath + sRootName)
87842>>>>>>>        End
87842>>>>>>>>
87842>>>>>>>
87842>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87844>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87845>>>>>>>        End
87845>>>>>>>>
87845>>>>>>>
87845>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87848>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87851>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87854>>>>>>>
87854>>>>>>>        // We need a short break here before attempting to delete the physical file or Windows
87854>>>>>>>        // might report "File in use..." and the deletion will fail.
87854>>>>>>>        Sleep 2
87855>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87857>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalName + ".*") to bOK
87858>>>>>>>        End
87858>>>>>>>>
87858>>>>>>>
87858>>>>>>>        Function_Return (Err = False)
87859>>>>>>>    End_Function
87860>>>>>>>
87860>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87862>>>>>>>        Move False to Err
87863>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87866>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87869>>>>>>>
87869>>>>>>>        Function_Return (Err = False)
87870>>>>>>>    End_Function                        
87871>>>>>>>    
87871>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
87871>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
87871>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
87873>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
87873>>>>>>>        Boolean bTheSame bIsSQL 
87873>>>>>>>        Handle hTable
87873>>>>>>>        
87873>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87873>>>>>>>        Move APITableInfo.iTableNumber      to hTable
87874>>>>>>>        Get UtilTableIsSQL hTable           to bIsSQL
87875>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
87876>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo  
87879>>>>>>>        Get _TableNameOnly sRootNameTo                to sRootNameTo
87880>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87883>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
87886>>>>>>>        
87886>>>>>>>        If (bCompareFilelistUppercase = True) Begin
87888>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bTheSame                  
87889>>>>>>>        End
87889>>>>>>>>
87889>>>>>>>        Else Begin
87890>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bTheSame                  
87891>>>>>>>        End
87891>>>>>>>>
87891>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
87891>>>>>>>            
87891>>>>>>>        Function_Return bTheSame
87892>>>>>>>    End_Function  
87893>>>>>>>    
87893>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87895>>>>>>>        Handle hFile hTable 
87895>>>>>>>        String sTableName sLogicalName sDisplayName 
87895>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
87895>>>>>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
87895>>>>>>>        Boolean bOk bExists bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened bSameColumnDefinitions
87895>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase bExistingTable
87895>>>>>>>        Boolean bIsSame bSameTableNames bIsOpen bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
87895>>>>>>>        tSQLConnection SQLConnection  
87895>>>>>>>        tSQLConnection SQLConnection  
87895>>>>>>>        tColumnType    ColumnType
87895>>>>>>>        tColumnType    ColumnType
87895>>>>>>>        tAPITable      APITableFrom APITableTo
87895>>>>>>>        tAPITable      APITableFrom APITableTo
87895>>>>>>>        
87895>>>>>>>        // We don't allow update of the framework's DbVersion table.
87895>>>>>>>        If (Uppercase(sTableName) = "DBVERSION") Begin
87897>>>>>>>            Function_Return False
87898>>>>>>>        End
87898>>>>>>>>
87898>>>>>>>        
87898>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87899>>>>>>>        Get piDbType                            to iDbType
87900>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87901>>>>>>>        Get pbRecnum                            to bRecnum
87902>>>>>>>        Get pbToANSI                            to bToANSI
87903>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87904>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87905>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase 
87906>>>>>>>        
87906>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
87907>>>>>>>        If (bToANSI = False) Begin
87909>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
87910>>>>>>>        End
87910>>>>>>>>
87910>>>>>>>        Move APITableNameInfoFrom.sRootName  to sTableName
87911>>>>>>>        Get _TableNameOnly sTableName        to sTableName
87912>>>>>>>        If (sDriverIDFrom = DATAFLEX_ID) Begin
87914>>>>>>>            Move sTableName to sPhysicalFile
87915>>>>>>>        End
87915>>>>>>>>
87915>>>>>>>
87915>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
87915>>>>>>>        // is a programmer's error and we auto-correct for it here.
87915>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
87915>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
87915>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
87915>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
87915>>>>>>>        Get IsMertechDriver sDriverIDFrom to bMertechDriver
87916>>>>>>>        If (bMertechDriver = True) Begin
87918>>>>>>>            If (bUseConnectionID = True) Begin
87920>>>>>>>                Move False to bUseConnectionID
87921>>>>>>>            End
87921>>>>>>>>
87921>>>>>>>            Move sDriverIDFrom to sOriginalDriverID
87922>>>>>>>            Move DATAFLEX_ID to sDriverIDFrom
87923>>>>>>>        End
87923>>>>>>>>
87923>>>>>>>        
87923>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87924>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87925>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87926>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87927>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87928>>>>>>>        Move APITableNameInfoFrom.sRootName     to sRootName
87929>>>>>>>        Move APITableNameInfoFrom.sLogicalName  to sLogicalName
87930>>>>>>>        Move APITableNameInfoFrom.sDisplayName  to sDisplayName
87931>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87932>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87933>>>>>>>        
87933>>>>>>>        // 'To' table properties:
87933>>>>>>>        Get UtilTableIsAlias hTable             to bIsAliasTo
87934>>>>>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
87935>>>>>>>        If (bIsSQLTableTo = False) Begin
87937>>>>>>>            Move DATAFLEX_ID to sDriverIDTo
87938>>>>>>>        End                                
87938>>>>>>>>
87938>>>>>>>        Else Begin
87939>>>>>>>            Move sDriverIDFrom to sDriverIDTo
87940>>>>>>>        End
87940>>>>>>>>
87940>>>>>>>        
87940>>>>>>>        // Does the 'To' table exist in Filelist.cfg _and_ on disk (embedded) or on the SQL back-end.
87940>>>>>>>        Get UtilTableExists  hTable             to bExistingTable
87941>>>>>>>        If (bExistingTable = False and bIsSQLTableFrom = True and bMertechDriver = False) Begin
87943>>>>>>>            Move True                           to bIsSQLTableTo 
87944>>>>>>>            Move sDriverIDFrom                  to sDriverIDTo   
87945>>>>>>>        End
87945>>>>>>>>
87945>>>>>>>        // Does table exist in Filelist.cfg:
87945>>>>>>>        Get UtilTableNumberIsInUse hTable       to bExistsInFilelist 
87946>>>>>>>
87946>>>>>>>        If (bIsSQLTableFrom = False and sDriverIDFrom <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverIDFrom)) Begin
87948>>>>>>>            Move (sDriverIDFrom + ":" + sRootName) to sRootName
87949>>>>>>>        End
87949>>>>>>>>
87949>>>>>>>
87949>>>>>>>        If (ghoProgressBar <> 0) Begin
87951>>>>>>>            Send DoAdvance of ghoProgressBar   
87952>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sTableName) * "Number:" * String(hTable))
87953>>>>>>>        End   
87953>>>>>>>>
87953>>>>>>>        
87953>>>>>>>        // a) The table is an Alias table:
87953>>>>>>>        //
87953>>>>>>>        // If this is an Alias file the Logical or Display name might have changed. Other than that
87953>>>>>>>        // there is nothing that can be updated for an Alias table.
87953>>>>>>>        // But we change all three attributes in case this is a new Alias table.
87953>>>>>>>        If (bIsAliasFrom = True) Begin           
87955>>>>>>>            // ToDo: The first param needs to be paramerized:
87955>>>>>>>            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
87956>>>>>>>            If (bSameTableNames = True) Begin
87958>>>>>>>                Function_Return True
87959>>>>>>>            End
87959>>>>>>>>
87959>>>>>>>            Else Begin 
87960>>>>>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87962>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sTableName
87965>>>>>>>                End                                                           
87965>>>>>>>>
87965>>>>>>>                Else Begin
87966>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName  
87969>>>>>>>                End
87969>>>>>>>>
87969>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87972>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName                        
87975>>>>>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87977>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverIDFrom sConnectionID True False to bOk
87978>>>>>>>                End
87978>>>>>>>>
87978>>>>>>>            End  
87978>>>>>>>>
87978>>>>>>>            Function_Return True
87979>>>>>>>        End                                                           
87979>>>>>>>>
87979>>>>>>>        
87979>>>>>>>        Move hTable         to APITableTo.ApiTableInfo.iTableNumber
87980>>>>>>>        If (bIsSQLTableTo = True) Begin
87982>>>>>>>            Move sRootName  to APITableTo.ApiTableInfo.sRootName
87983>>>>>>>        End 
87983>>>>>>>>
87983>>>>>>>        Else Begin
87984>>>>>>>            Move sTableName to APITableTo.ApiTableInfo.sRootName
87985>>>>>>>        End
87985>>>>>>>>
87985>>>>>>>        
87985>>>>>>>        Move sLogicalName   to APITableTo.ApiTableInfo.sLogicalName
87986>>>>>>>        Move sDisplayName   to APITableTo.ApiTableInfo.sDisplayName
87987>>>>>>>        Move bIsAliasTo     to APITableTo.ApiTableInfo.bIsAlias
87988>>>>>>>        Move bIsSQLTableTo  to APITableTo.ApiTableInfo.bIsSQL
87989>>>>>>>        
87989>>>>>>>        // b) Table exists in Filelist.cfg. We will then compare & check the Filelist.cfg entries for differences.
87989>>>>>>>        If (bExistsInFilelist = True) Begin
87991>>>>>>>            // ToDo: The first param needs to be paramerized:
87991>>>>>>>            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
87992>>>>>>>            If (bSameTableNames = False) Begin
87994>>>>>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87996>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87999>>>>>>>                End
87999>>>>>>>>
87999>>>>>>>                Else Begin
88000>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to APITableFrom.ApiTableInfo.sRootName
88003>>>>>>>                End
88003>>>>>>>>
88003>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableFrom.ApiTableInfo.sLogicalName
88006>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableFrom.ApiTableInfo.sDisplayName                        
88009>>>>>>>            End  
88009>>>>>>>>
88009>>>>>>>        End                                     
88009>>>>>>>>
88009>>>>>>>        
88009>>>>>>>        // c) Both exists in Filelist.cfg and the table exists on disk (embedded) or as an SQL table. 
88009>>>>>>>        //    We then check for differences.
88009>>>>>>>        If (bExistingTable = True) Begin 
88011>>>>>>>            Get UtilColumnsStructFill  hTable to APITableTo.aApiColumns
88012>>>>>>>            Get UtilIndexesStructFill  hTable to APITableTo.aApiIndexes
88013>>>>>>>            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
88014>>>>>>>        
88014>>>>>>>            Move False to bFilelistError
88015>>>>>>>            Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
88016>>>>>>>            // If there was a "Filelist" error (aka the logical names for the 'From' and 'To' tables weren't the same,
88016>>>>>>>            // we will _not_ attempt to make any table changes. An error has by now been generated and will
88016>>>>>>>            // appear in the logfile.
88016>>>>>>>            // Of course, if the tables were the same we also do nothing.
88016>>>>>>>            If (bFilelistError = True or bIsSame = True) Begin
88018>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
88019>>>>>>>                Function_Return True
88020>>>>>>>            End
88020>>>>>>>>
88020>>>>>>>        End
88020>>>>>>>>
88020>>>>>>>        
88020>>>>>>>        // d) Create as new Table?
88020>>>>>>>        //
88020>>>>>>>        Move False to Err
88021>>>>>>>        If (bExistingTable = False) Begin
88023>>>>>>>            Get ApiTableCreate hTable sRootName sDisplayName sTableName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
88024>>>>>>>            Function_Return bOk // And we're done.
88025>>>>>>>        End
88025>>>>>>>>
88025>>>>>>>        
88025>>>>>>>        // e) If we got this far we need to Update the table:
88025>>>>>>>        //    This is the last case (a-e).
88025>>>>>>>        If (ghoProgressBar <> 0) Begin
88027>>>>>>>            Send DoAdvance of ghoProgressBar   
88028>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Updating Table:" * String(sTableName) * "Number:" * String(hTable))
88029>>>>>>>        End
88029>>>>>>>>
88029>>>>>>>        
88029>>>>>>>        // If an SQL 'To' table we fetch the connection details for login & Schema:
88029>>>>>>>        If (bIsSQLTableTo = True) Begin
88031>>>>>>>
88031>>>>>>>            // Get connection properties
88031>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
88032>>>>>>>            Move SQLConnection.sSchema to sSchema
88033>>>>>>>            If (sSchema = "") Begin
88035>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
88036>>>>>>>            End                                            
88036>>>>>>>>
88036>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
88037>>>>>>>
88037>>>>>>>            // If a DAW driver and using a connection id we need to check if it exists;
88037>>>>>>>            // else we create it before attempting creating the table
88037>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
88039>>>>>>>                Get IsConnectionID sConnectionID sDriverIDFrom to bExists
88040>>>>>>>                If (bExists = False) Begin
88042>>>>>>>                    Get UtilCreateConnectionID sConnectionID to bOk
88043>>>>>>>                    If (bOk = False) Begin
88045>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
88046>>>>>>>>
88046>>>>>>>                        Function_Return False
88047>>>>>>>                    End
88047>>>>>>>>
88047>>>>>>>                End
88047>>>>>>>>
88047>>>>>>>            End
88047>>>>>>>>
88047>>>>>>>
88047>>>>>>>            Move (sTableName + ".int") to sPhysicalFile
88048>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
88049>>>>>>>            // Pre-face the DisplayName with the schema name;
88049>>>>>>>            // that is how DAW's tools does it.
88049>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
88051>>>>>>>                Move (Lowercase(sSchema) + "." + sLogicalName) to sDisplayName
88052>>>>>>>            End
88052>>>>>>>>
88052>>>>>>>        End 
88052>>>>>>>>
88052>>>>>>>        
88052>>>>>>>        Open hTable Mode DF_EXCLUSIVE
88054>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88057>>>>>>>        If (bOpened = False) Begin
88059>>>>>>>            Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
88060>>>>>>>            Function_Return False
88061>>>>>>>        End
88061>>>>>>>>
88061>>>>>>>                
88061>>>>>>>        Move False to Err
88062>>>>>>>        Move hTable to hFile
88063>>>>>>>
88063>>>>>>>        // This will create new columns or update existing ones.     
88063>>>>>>>        Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
88064>>>>>>>                
88064>>>>>>>        If (bOk = True) Begin             
88066>>>>>>>            If (bExistingTable = False) Begin
88068>>>>>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88070>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88073>>>>>>>                End                                                            
88073>>>>>>>>
88073>>>>>>>                Else Begin
88074>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
88077>>>>>>>                End
88077>>>>>>>>
88077>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
88080>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName 
88083>>>>>>>                If (bIsSQLTableTo = True) Begin
88085>>>>>>>                    Get SqlUtilUpdateIntFile hTable to bOk
88086>>>>>>>                End
88086>>>>>>>>
88086>>>>>>>            End
88086>>>>>>>>
88086>>>>>>>
88086>>>>>>>            // Compare Indexes and if different; either create or change them 
88086>>>>>>>            Get UtilIndexesStructFill hTable to APITableTo.aApiIndexes
88087>>>>>>>            Get UtilIndexesCompare hTable APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
88088>>>>>>>            If (bIsSame = False) Begin
88090>>>>>>>                Get UtilIndexesUpdate hFile APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
88091>>>>>>>            End
88091>>>>>>>>
88091>>>>>>>            
88091>>>>>>>            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
88092>>>>>>>            Get UtilRelationsCompare hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
88093>>>>>>>            If (bIsSame = False) Begin
88095>>>>>>>                Get UtilRelationsUpdate hFile APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
88096>>>>>>>            End
88096>>>>>>>>
88096>>>>>>>        End
88096>>>>>>>>
88096>>>>>>>        
88096>>>>>>>        Close hTable
88097>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
88098>>>>>>>
88098>>>>>>>        Function_Return (bOK = True)
88099>>>>>>>    End_Function                                                                                                        
88100>>>>>>>
88100>>>>>>>    // *** Field/Column Level Functions: ***
88100>>>>>>>    //
88100>>>>>>>    // Adds a column name to the passed table number.
88100>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
88102>>>>>>>        Integer iColumn iCount iFile iPrecision
88102>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
88102>>>>>>>        String sDdSrcPath sTableName sColumnValue
88102>>>>>>>
88102>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists  
88103>>>>>>>        Move False to Err
88104>>>>>>>        If (bExists = True) Begin
88106>>>>>>>            Function_Return False
88107>>>>>>>        End 
88107>>>>>>>>
88107>>>>>>>        If (num_arguments > 4) Begin
88109>>>>>>>            Move iPrec to iPrecision
88110>>>>>>>        End
88110>>>>>>>>
88110>>>>>>>        If (num_arguments > 6) Begin
88112>>>>>>>            Move bInitVal to bInitializeValue
88113>>>>>>>            Move sColVal  to sColumnValue
88114>>>>>>>        End
88114>>>>>>>>
88114>>>>>>>        If (iType < -1490) Begin
88116>>>>>>>            Move (iType + 1500) to iType
88117>>>>>>>        End
88117>>>>>>>>
88117>>>>>>>        
88117>>>>>>>        Get AutoConnectionIDLogin to bOK
88118>>>>>>>        Move False to Err
88119>>>>>>>        // Structure_start will change the value of hTable...
88119>>>>>>>        Move hTable to iFile
88120>>>>>>>        Open iFile Mode DF_EXCLUSIVE
88122>>>>>>>
88122>>>>>>>        Structure_Start iFile
88123>>>>>>>            Move 0 to iColumn
88124>>>>>>>            Create_Field hTable At iColumn
88125>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
88128>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
88131>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to iLength
88134>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
88137>>>>>>>        Structure_End iFile
88139>>>>>>>
88139>>>>>>>        // If in development environment; create .fd file:
88139>>>>>>>        Open hTable
88141>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88142>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88143>>>>>>>        If (iCount > 1) Begin
88145>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
88146>>>>>>>        End
88146>>>>>>>>
88146>>>>>>>        Get vFolderExists sDDSrcPath to bExists
88147>>>>>>>        If (bExists = True) Begin
88149>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
88150>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88153>>>>>>>            Get _TableNameOnly sTableName to sTableName
88154>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88156>>>>>>>        End
88156>>>>>>>>
88156>>>>>>>        
88156>>>>>>>        // Check for a default value
88156>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
88158>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
88159>>>>>>>        End
88159>>>>>>>>
88159>>>>>>>        Close hTable
88160>>>>>>>
88160>>>>>>>        Function_Return (Err = False)
88161>>>>>>>    End_Function   
88162>>>>>>>    
88162>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean 
88162>>>>>>>//        Integer iColumn iCount iFile
88162>>>>>>>//        Boolean bExists bOK  
88162>>>>>>>//        String sDdSrcPath sTableName
88162>>>>>>>//    
88162>>>>>>>//        Get AutoConnectionIDLogin to bOK
88162>>>>>>>//        Move False to Err   
88162>>>>>>>//        
88162>>>>>>>//        // Structure_start will change the value of hTable...
88162>>>>>>>//        Move hTable to iFile
88162>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
88162>>>>>>>//        
88162>>>>>>>//        Structure_Start iFile
88162>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
88162>>>>>>>//        Structure_End iFile
88162>>>>>>>//        
88162>>>>>>>//        // If in development environment; create .fd file:
88162>>>>>>>//        Open hTable
88162>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
88162>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
88162>>>>>>>//        If (iCount > 1) Begin
88162>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath    
88162>>>>>>>//        End 
88162>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
88162>>>>>>>//        If (bExists = True) Begin                                   
88162>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath 
88162>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88162>>>>>>>//            Get _TableNameOnly sTableName to sTableName 
88162>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88162>>>>>>>//        End
88162>>>>>>>//        Close hTable
88162>>>>>>>//
88162>>>>>>>//        Function_Return (Err = False)
88162>>>>>>>//    End_Function
88162>>>>>>>
88162>>>>>>>    // To update all records for a table column with a fixed value.
88162>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
88164>>>>>>>        Integer iRecs iCurrErr iField iRecord
88164>>>>>>>        Boolean bRetval bOpen
88164>>>>>>>        
88164>>>>>>>        Move 0 to iRecs                
88165>>>>>>>        Move False to bRetval 
88166>>>>>>>        Move Err to iCurrErr
88167>>>>>>>        Move False to Err
88168>>>>>>>        
88168>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88171>>>>>>>        If (bOpen = False) Begin
88173>>>>>>>            Open hTable
88175>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88178>>>>>>>            If (bOpen = False) Begin
88180>>>>>>>                Function_Return bRetval
88181>>>>>>>            End
88181>>>>>>>>
88181>>>>>>>        End
88181>>>>>>>>
88181>>>>>>>        
88181>>>>>>>        Field_Map hTable sFieldName to iField
88183>>>>>>>        If (iField <> 0) Begin
88185>>>>>>>            Clear hTable
88186>>>>>>>            Repeat
88186>>>>>>>>
88186>>>>>>>                Vfind hTable 0 GT
88188>>>>>>>                If (Found) Begin
88190>>>>>>>                    If (ghoStatusPanel <> 0) Begin
88192>>>>>>>                        Get_Field_Value hTable 0 to iRecord
88195>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
88196>>>>>>>                    End
88196>>>>>>>>
88196>>>>>>>                    Reread hTable
88200>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
88203>>>>>>>                        SaveRecord hTable
88204>>>>>>>                    Unlock   
88205>>>>>>>>
88205>>>>>>>                End
88205>>>>>>>>
88205>>>>>>>           Until (not(Found))
88207>>>>>>>        End
88207>>>>>>>>
88207>>>>>>>        
88207>>>>>>>        Move (Err = False) to bRetval
88208>>>>>>>        Move iCurrErr to Err
88209>>>>>>>        
88209>>>>>>>        Function_Return bRetval
88210>>>>>>>    End_Function  
88211>>>>>>>    
88211>>>>>>>    Procedure ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating
88213>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
88213>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen
88213>>>>>>>        String sFieldName sDriverID sTableName
88213>>>>>>>        
88213>>>>>>>        Get psDriverID to sDriverID                      
88214>>>>>>>        Get piDbType to iDbType
88215>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88216>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
88217>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver                     
88218>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable 
88219>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
88221>>>>>>>            Move True to bIsSqlTable
88222>>>>>>>        End
88222>>>>>>>>
88222>>>>>>>        Move False to bIsOpen
88223>>>>>>>        If (hTable > 0) Begin
88225>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88228>>>>>>>        End
88228>>>>>>>>
88228>>>>>>>        If (bIsOpen = True) Begin
88230>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88233>>>>>>>        End 
88233>>>>>>>>
88233>>>>>>>        Else Begin
88234>>>>>>>            Move True to bRecnumTable
88235>>>>>>>        End
88235>>>>>>>>
88235>>>>>>>        
88235>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
88236>>>>>>>        Decrement iSize
88237>>>>>>>        for iCount from 0 to iSize   
88243>>>>>>>>
88243>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
88244>>>>>>>            If (hTable > 0) Begin    
88246>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88247>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88248>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
88251>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
88252>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88253>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88254>>>>>>>            End
88254>>>>>>>>
88254>>>>>>>            Else Begin
88255>>>>>>>                Move False to bFieldExists
88256>>>>>>>            End
88256>>>>>>>>
88256>>>>>>>            
88256>>>>>>>            If (bFieldExists = False) Begin 
88258>>>>>>>                Move 0 to iColumn
88259>>>>>>>                Create_Field hTable At iColumn                                                   
88260>>>>>>>            End  
88260>>>>>>>>
88260>>>>>>>            Else Begin
88261>>>>>>>                Move iCount to iColumn
88262>>>>>>>            End
88262>>>>>>>>
88262>>>>>>>            
88262>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
88263>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName                             
88266>>>>>>>
88266>>>>>>>            Move aColumns[iCount].iType to iType
88267>>>>>>>            Move (not(iType < -1490)) to bNativeType
88268>>>>>>>            If (iType < -1490) Begin
88270>>>>>>>                Move (iType + 1500) to iType
88271>>>>>>>            End
88271>>>>>>>>
88271>>>>>>>            
88271>>>>>>>            If (bIsSqlTable = True) Begin
88273>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
88275>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
88276>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iDataFlexType
88279>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType  
88282>>>>>>>                End
88282>>>>>>>>
88282>>>>>>>                Else Begin
88283>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
88286>>>>>>>                End
88286>>>>>>>>
88286>>>>>>>            End
88286>>>>>>>>
88286>>>>>>>            Else Begin
88287>>>>>>>                If (bCreating = False) Begin
88289>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
88290>>>>>>>                End
88290>>>>>>>>
88290>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
88293>>>>>>>            End
88293>>>>>>>>
88293>>>>>>>            
88293>>>>>>>            Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
88296>>>>>>>            Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
88299>>>>>>>            
88299>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
88301>>>>>>>                If (bRecnumTable = False) Begin
88303>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True 
88306>>>>>>>                End
88306>>>>>>>>
88306>>>>>>>                
88306>>>>>>>                Move 0 to iIndex 
88307>>>>>>>                Create_Index hTable at iIndex
88308>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
88311>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn  
88314>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
88317>>>>>>>                
88317>>>>>>>                // If we have an identity table - we must create a primary_key table. 
88317>>>>>>>                If (bIsSqlTable = True) Begin
88319>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True     
88322>>>>>>>                End
88322>>>>>>>>
88322>>>>>>>            End
88322>>>>>>>>
88322>>>>>>>        Loop
88323>>>>>>>>
88323>>>>>>>    End_Procedure
88324>>>>>>>
88324>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88326>>>>>>>        Integer iCount iSize iColumn iType iIndex iColumnsToSize hFile
88326>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsSame bOK bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen
88326>>>>>>>        String sFieldName sTableName sDriverTo
88326>>>>>>>        
88326>>>>>>>        Move False to Err
88327>>>>>>>        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
88328>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
88329>>>>>>>        If (bIsSQLTableTo = False) Begin
88331>>>>>>>            Move DATAFLEX_ID to sDriverTo
88332>>>>>>>        End                            
88332>>>>>>>>
88332>>>>>>>        Else Begin
88333>>>>>>>            Get psDriverID to sDriverTo
88334>>>>>>>        End
88334>>>>>>>>
88334>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88335>>>>>>>        
88335>>>>>>>        Move (SizeOfArray(aColumnsFrom)) to iSize 
88336>>>>>>>        Move (SizeOfArray(aColumnsTo)) to iColumnsToSize
88337>>>>>>>        Get OpenTableExclusive hTable to bOpened
88338>>>>>>>        
88338>>>>>>>        Decrement iSize
88339>>>>>>>        For iCount from 0 to iSize   
88345>>>>>>>>
88345>>>>>>>            Move aColumnsFrom[iCount].sFieldName   to sFieldName
88346>>>>>>>            Move aColumnsFrom[iCount].iFieldNumber to iColumn
88347>>>>>>>            If (hTable > 0) Begin                       
88349>>>>>>>                Move False to bFieldExists
88350>>>>>>>                If (iCount < iColumnsToSize) Begin
88352>>>>>>>                    Move aColumnsTo[iCount].sFieldName to sFieldName
88353>>>>>>>                    Move (Trim(sFieldName) <> "") to bFieldExists
88354>>>>>>>                End
88354>>>>>>>>
88354>>>>>>>            End
88354>>>>>>>>
88354>>>>>>>            Else Begin
88355>>>>>>>                Move False to bFieldExists
88356>>>>>>>            End
88356>>>>>>>>
88356>>>>>>>            
88356>>>>>>>            If (bFieldExists = True) Begin     
88358>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88359>>>>>>>                Get UtilColumnCompare sDriverIDFrom bIsSQLTableFrom bIsSQLTableTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DateTime to bIsSame
88360>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88361>>>>>>>                If (bIsSame = False) Begin  
88363>>>>>>>                    // ToDo: We might need to set more properties for the field than what currently is set...
88363>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88364>>>>>>>                    Get ApiColumnChangeByColumnNumber sDriverIDFrom bIsSQLTableFrom hTable bIsSQLTableTo aColumnsFrom[iCount].sFieldName aColumnsFrom[iCount].iFieldNumber aColumnsFrom[iCount].iType aColumnsFrom[iCount].iLength aColumnsFrom[iCount].iPrecision aColumnsFrom[iCount].iOptions to bOK
88365>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
88366>>>>>>>                End
88366>>>>>>>>
88366>>>>>>>            End
88366>>>>>>>>
88366>>>>>>>            
88366>>>>>>>            If (bFieldExists = False) Begin  
88368>>>>>>>                Move False to bIsOpen
88369>>>>>>>                If (hTable > 0) Begin        
88371>>>>>>>                    Close hTable
88372>>>>>>>                    Open hTable Mode DF_EXCLUSIVE
88374>>>>>>>                    Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88377>>>>>>>                End
88377>>>>>>>>
88377>>>>>>>                If (bIsOpen = True) Begin
88379>>>>>>>                    Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88382>>>>>>>                End 
88382>>>>>>>>
88382>>>>>>>                Else Begin
88383>>>>>>>                    Move True to bRecnumTable
88384>>>>>>>                End
88384>>>>>>>>
88384>>>>>>>
88384>>>>>>>                Move hTable to hFile
88385>>>>>>>                Structure_Start hFile sDriverIDFrom
88386>>>>>>>                    Move aColumnsFrom[iCount].iFieldNumber to iColumn
88387>>>>>>>                    Create_Field hFile At iColumn                                                   
88388>>>>>>>                    Set_Attribute DF_FIELD_NAME   of hFile iColumn to aColumnsFrom[iCount].sFieldName                                 
88391>>>>>>>//                    If (bIsSQLTable = True) Begin
88391>>>>>>>//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength - aColumnsFrom[iCount].iPrecision)
88391>>>>>>>                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to aColumnsFrom[iCount].iLength
88394>>>>>>>//                    End
88394>>>>>>>//                    Else Begin
88394>>>>>>>//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength + aColumnsFrom[iCount].iPrecision)
88394>>>>>>>//                    End
88394>>>>>>>                    
88394>>>>>>>                    If (aColumnsFrom[iCount].iPrecision > 0) Begin
88396>>>>>>>                        Set_Attribute DF_FIELD_PRECISION of hFile iColumn to aColumnsFrom[iCount].iPrecision
88399>>>>>>>                    End
88399>>>>>>>>
88399>>>>>>>                    
88399>>>>>>>                    Move aColumnsFrom[iCount].iType to iType
88400>>>>>>>                    Move (not(iType < -1490)) to bNativeType
88401>>>>>>>                    If (iType < -1490) Begin
88403>>>>>>>                        Move (iType + 1500) to iType
88404>>>>>>>                    End
88404>>>>>>>>
88404>>>>>>>                    // ToDo: This test is not enough. Do check for bSQLTableFrom
88404>>>>>>>                    If (bIsSQLTableTo = True) Begin
88406>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
88409>>>>>>>                    End
88409>>>>>>>>
88409>>>>>>>                    Else Begin
88410>>>>>>>                        Set_Attribute DF_FIELD_TYPE of hFile iColumn to iType
88413>>>>>>>                    End
88413>>>>>>>>
88413>>>>>>>                    
88413>>>>>>>                    If (aColumnsFrom[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
88415>>>>>>>                        If (bRecnumTable = False) Begin
88417>>>>>>>                            Set_Attribute DF_FIELD_IS_IDENTITY     of hFile iColumn to True 
88420>>>>>>>                        End
88420>>>>>>>>
88420>>>>>>>                        // If we have an identity table - we must create a primary_key table. 
88420>>>>>>>                        Move 0 to iIndex 
88421>>>>>>>                        Create_Index hFile at iIndex
88422>>>>>>>                        Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88425>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn  
88428>>>>>>>                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile iIndex to 1
88431>>>>>>>                        If (bIsSQLDriver = True) Begin
88433>>>>>>>                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True     
88436>>>>>>>                        End
88436>>>>>>>>
88436>>>>>>>                    End  
88436>>>>>>>>
88436>>>>>>>                Structure_End hFile
88438>>>>>>>    
88438>>>>>>>            End
88438>>>>>>>>
88438>>>>>>>        Loop
88439>>>>>>>>
88439>>>>>>>            
88439>>>>>>>        Function_Return (Err = False)
88440>>>>>>>    End_Function
88441>>>>>>>
88441>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88441>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
88443>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
88443>>>>>>>        Boolean bOK bIsSqlTable  
88443>>>>>>>        String sFieldNameTo
88443>>>>>>>
88443>>>>>>>        If (num_arguments > 4) Begin
88445>>>>>>>            Move iPrec to iPrecFrom
88446>>>>>>>        End
88446>>>>>>>>
88446>>>>>>>        If (iTypeFrom < -1490) Begin
88448>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88449>>>>>>>        End
88449>>>>>>>>
88449>>>>>>>        
88449>>>>>>>        Get AutoConnectionIDLogin to bOK
88450>>>>>>>        Move False to Err
88451>>>>>>>        Get OpenTableExclusive hTable to bOK
88452>>>>>>>        If (bOK = False) Begin
88454>>>>>>>            Function_Return False
88455>>>>>>>        End  
88455>>>>>>>>
88455>>>>>>>        
88455>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88456>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88457>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
88459>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88460>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88461>>>>>>>        If (Err = True) Begin
88463>>>>>>>            Function_Return False
88464>>>>>>>        End
88464>>>>>>>>
88464>>>>>>>        
88464>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88467>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
88468>>>>>>>        If (bIsSqlTable = False) Begin
88470>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88473>>>>>>>        End
88473>>>>>>>>
88473>>>>>>>        Else Begin
88474>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
88477>>>>>>>        End 
88477>>>>>>>>
88477>>>>>>>        // Let the driver decide the other values;
88477>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88480>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
88483>>>>>>>        
88483>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
88485>>>>>>>            Function_Return False
88486>>>>>>>        End
88486>>>>>>>>
88486>>>>>>>
88486>>>>>>>        Structure_Start hTable      
88487>>>>>>>            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88490>>>>>>>            If (bIsSqlTable = False) Begin
88492>>>>>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
88495>>>>>>>            End
88495>>>>>>>>
88495>>>>>>>            Else Begin
88496>>>>>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
88499>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
88502>>>>>>>            End
88502>>>>>>>>
88502>>>>>>>            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88505>>>>>>>            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88508>>>>>>>        Structure_End hTable
88510>>>>>>>
88510>>>>>>>        Function_Return (Err = False)
88511>>>>>>>    End_Function
88512>>>>>>>
88512>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
88512>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverID Boolean bIsSQLTableFrom Handle hTable Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
88514>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType
88514>>>>>>>        Boolean bOK bIsSQL bCompareDate_DateTime bSkip
88514>>>>>>>        String sFieldNameTo    
88514>>>>>>>        tColumnType ColumnType
88514>>>>>>>        tColumnType ColumnType
88514>>>>>>>        
88514>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
88515>>>>>>>        Get piDbType to iDbType
88516>>>>>>>        If (num_arguments > 4) Begin
88518>>>>>>>            Move iPrec to iPrecFrom                                    
88519>>>>>>>            Move iOpt  to iOptionFrom
88520>>>>>>>        End
88520>>>>>>>>
88520>>>>>>>        If (iTypeFrom < -1490) Begin
88522>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
88523>>>>>>>        End
88523>>>>>>>>
88523>>>>>>>        
88523>>>>>>>        Get UtilTableIsSql hTable to bIsSQL
88524>>>>>>>        Get AutoConnectionIDLogin to bOK
88525>>>>>>>        Move False to Err
88526>>>>>>>        Get OpenTableExclusive hTable to bOK
88527>>>>>>>        If (bOK = False) Begin
88529>>>>>>>            Function_Return False
88530>>>>>>>        End  
88530>>>>>>>>
88530>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88533>>>>>>>        
88533>>>>>>>        If (bIsSQLTableTo = True) Begin
88535>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
88538>>>>>>>        End
88538>>>>>>>>
88538>>>>>>>        Else Begin
88539>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88542>>>>>>>        End
88542>>>>>>>>
88542>>>>>>>        
88542>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88545>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
88548>>>>>>>        Get_Attribute DF_FIELD_IS_IDENTITY          of hTable iColumn to iOptionTo
88551>>>>>>>        
88551>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
88551>>>>>>>        // data types between Embedded and SQL.
88551>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88553>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iTypeFrom
88554>>>>>>>        End
88554>>>>>>>>
88554>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88557>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeTo   iLengthTo   to iTypeTo
88558>>>>>>>        End
88558>>>>>>>>
88558>>>>>>>        
88558>>>>>>>        
88558>>>>>>>        If (bCompareDate_DateTime = False) Begin
88560>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
88561>>>>>>>            If (bSkip = True) Begin
88563>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88565>>>>>>>                    Function_Return False
88566>>>>>>>                End
88566>>>>>>>>
88566>>>>>>>            End
88566>>>>>>>>
88566>>>>>>>        End
88566>>>>>>>>
88566>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88569>>>>>>>            Function_Return False
88570>>>>>>>        End
88570>>>>>>>>
88570>>>>>>>
88570>>>>>>>        Structure_Start hTable      
88571>>>>>>>            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88574>>>>>>>            If (bIsSQLTableTo = False) Begin
88576>>>>>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
88579>>>>>>>            End
88579>>>>>>>>
88579>>>>>>>            Else Begin
88580>>>>>>>                Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iDataFlexType
88581>>>>>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iDataFlexType
88584>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
88587>>>>>>>            End
88587>>>>>>>>
88587>>>>>>>            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88590>>>>>>>            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88593>>>>>>>            
88593>>>>>>>            If (bIsSQL = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88595>>>>>>>                Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
88598>>>>>>>            End
88598>>>>>>>>
88598>>>>>>>        Structure_End hTable
88600>>>>>>>
88600>>>>>>>        Function_Return (Err = False)
88601>>>>>>>    End_Function
88602>>>>>>>
88602>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
88604>>>>>>>        Boolean bOK
88604>>>>>>>
88604>>>>>>>        Get AutoConnectionIDLogin to bOK
88605>>>>>>>        Move False to Err
88606>>>>>>>        Get OpenTableExclusive hTable to bOK
88607>>>>>>>        If (bOK = False) Begin
88609>>>>>>>            Function_Return False
88610>>>>>>>        End
88610>>>>>>>>
88610>>>>>>>
88610>>>>>>>        Structure_Start hTable
88611>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
88614>>>>>>>        Structure_End hTable
88616>>>>>>>
88616>>>>>>>        Function_Return (Err = False)
88617>>>>>>>    End_Function
88618>>>>>>>
88618>>>>>>>    // To move an existing field to another position in a table.
88618>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Returns Boolean
88620>>>>>>>        String sColumn sDriverID
88620>>>>>>>        Integer iType iLength iPrecision
88620>>>>>>>        Boolean bOK
88620>>>>>>>
88620>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88623>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
88625>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
88626>>>>>>>>
88626>>>>>>>            Function_Return False
88627>>>>>>>        End
88627>>>>>>>>
88627>>>>>>>
88627>>>>>>>        Close hTable
88628>>>>>>>        Get AutoConnectionIDLogin to bOK
88629>>>>>>>        Get OpenTableExclusive hTable to bOK
88630>>>>>>>        If (bOK = False) Begin
88632>>>>>>>            Function_Return False
88633>>>>>>>        End
88633>>>>>>>>
88633>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
88636>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
88639>>>>>>>
88639>>>>>>>        If (iType <> DF_DATE) Begin
88641>>>>>>>            Get_Attribute DF_FIELD_LENGTH of hTable iOld to iLength
88644>>>>>>>        End
88644>>>>>>>>
88644>>>>>>>
88644>>>>>>>        If (iType = DF_BCD) Begin
88646>>>>>>>            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
88649>>>>>>>        End
88649>>>>>>>>
88649>>>>>>>        Move False to Err
88650>>>>>>>
88650>>>>>>>        Structure_Start hTable
88651>>>>>>>            Delete_Field hTable iOld
88652>>>>>>>            Create_Field hTable At iNew
88653>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
88656>>>>>>>            Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
88659>>>>>>>
88659>>>>>>>            If (iType <> DF_DATE) Begin
88661>>>>>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
88664>>>>>>>            End
88664>>>>>>>>
88664>>>>>>>
88664>>>>>>>            If (iType = DF_BCD) Begin
88666>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
88669>>>>>>>            End
88669>>>>>>>>
88669>>>>>>>
88669>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
88672>>>>>>>        Structure_End hTable
88674>>>>>>>
88674>>>>>>>        Function_Return (Err = False)
88675>>>>>>>    End_Function
88676>>>>>>>
88676>>>>>>>    // Deletes a column name for the passed table number (and column number).
88676>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
88678>>>>>>>        Integer iColumn
88678>>>>>>>        Boolean bOK
88678>>>>>>>
88678>>>>>>>        Get AutoConnectionIDLogin to bOK 
88679>>>>>>>        Move False to Err
88680>>>>>>>        Close hTable
88681>>>>>>>        Get OpenTableExclusive hTable to bOK
88682>>>>>>>        If (bOK = False) Begin
88684>>>>>>>            Function_Return False
88685>>>>>>>        End
88685>>>>>>>>
88685>>>>>>>        
88685>>>>>>>        If (not(Err)) Begin
88687>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88688>>>>>>>            Field_Map hTable sFieldName to iColumn
88690>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88691>>>>>>>            If (Err = True) Begin
88693>>>>>>>                Function_Return False
88694>>>>>>>            End
88694>>>>>>>>
88694>>>>>>>            Move False to Err
88695>>>>>>>    
88695>>>>>>>            Structure_Start hTable
88696>>>>>>>                Delete_Field hTable iColumn
88697>>>>>>>            Structure_End hTable
88699>>>>>>>        End  
88699>>>>>>>>
88699>>>>>>>        Else Begin
88700>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
88701>>>>>>>>
88701>>>>>>>        End
88701>>>>>>>>
88701>>>>>>>
88701>>>>>>>        Function_Return (Err = False)
88702>>>>>>>    End_Function
88703>>>>>>>
88703>>>>>>>    // Renames a field for the passed table number & old field name & new field name
88703>>>>>>>    // Returns True if no errors occured.
88703>>>>>>>    // Sample usage:
88703>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
88703>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
88705>>>>>>>        Integer iField
88705>>>>>>>        Boolean bOK
88705>>>>>>>
88705>>>>>>>        Get AutoConnectionIDLogin to bOK
88706>>>>>>>        Move False to Err
88707>>>>>>>        Get OpenTableExclusive hTable to bOK
88708>>>>>>>        If (bOK = False) Begin
88710>>>>>>>            Function_Return False
88711>>>>>>>        End
88711>>>>>>>>
88711>>>>>>>
88711>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88712>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88713>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88714>>>>>>>        Structure_Start hTable
88715>>>>>>>            Field_Map hTable sOldFieldName to iField
88717>>>>>>>            If (iField > 0) Begin
88719>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
88722>>>>>>>            End
88722>>>>>>>>
88722>>>>>>>            Else Begin
88723>>>>>>>                Move 0 to LastErr
88724>>>>>>>                Move False to Err
88725>>>>>>>            End
88725>>>>>>>>
88725>>>>>>>        Structure_End hTable
88727>>>>>>>
88727>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88728>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88729>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88730>>>>>>>
88730>>>>>>>        Function_Return (Err = False)
88731>>>>>>>    End_Function
88732>>>>>>>
88732>>>>>>>    // *** Index Level Functions: ***
88732>>>>>>>    //
88732>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88732>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88732>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88732>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88734>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
88734>>>>>>>        String sDriverID
88734>>>>>>>        Boolean bOK
88734>>>>>>>
88734>>>>>>>        Get AutoConnectionIDLogin to bOK
88735>>>>>>>        Move -1 to iSegment1
88736>>>>>>>        Move -1 to iSegment2
88737>>>>>>>        Move -1 to iSegment3
88738>>>>>>>        Move -1 to iSegment4
88739>>>>>>>        Move -1 to iSegment5
88740>>>>>>>        Move -1 to iSegment6
88741>>>>>>>        Move -1 to iSegment7
88742>>>>>>>        Move -1 to iSegment8
88743>>>>>>>        Move -1 to iSegment9
88744>>>>>>>        Move -1 to iSegment10
88745>>>>>>>
88745>>>>>>>        If (num_arguments > 3) Begin
88747>>>>>>>            Move iSgmnt1 to iSegment1
88748>>>>>>>        End
88748>>>>>>>>
88748>>>>>>>        If (num_arguments > 4) Begin
88750>>>>>>>            Move iSgmnt2 to iSegment2
88751>>>>>>>        End
88751>>>>>>>>
88751>>>>>>>        If (num_arguments > 5) Begin
88753>>>>>>>            Move iSgmnt3 to iSegment3
88754>>>>>>>        End
88754>>>>>>>>
88754>>>>>>>        If (num_arguments > 6) Begin
88756>>>>>>>            Move iSgmnt4 to iSegment4
88757>>>>>>>        End
88757>>>>>>>>
88757>>>>>>>        If (num_arguments > 7) Begin
88759>>>>>>>            Move iSgmnt5 to iSegment5
88760>>>>>>>        End
88760>>>>>>>>
88760>>>>>>>        If (num_arguments > 8) Begin
88762>>>>>>>            Move iSgmnt6 to iSegment6
88763>>>>>>>        End
88763>>>>>>>>
88763>>>>>>>        If (num_arguments > 9) Begin
88765>>>>>>>            Move iSgmnt7 to iSegment7
88766>>>>>>>        End
88766>>>>>>>>
88766>>>>>>>        If (num_arguments > 10) Begin
88768>>>>>>>            Move iSgmnt8 to iSegment8
88769>>>>>>>        End
88769>>>>>>>>
88769>>>>>>>        If (num_arguments > 11) Begin
88771>>>>>>>            Move iSgmnt9 to iSegment9
88772>>>>>>>        End
88772>>>>>>>>
88772>>>>>>>        If (num_arguments > 12) Begin
88774>>>>>>>            Move iSgmnt10 to iSegment10
88775>>>>>>>        End
88775>>>>>>>>
88775>>>>>>>
88775>>>>>>>        Move False to Err
88776>>>>>>>        Move hTable to iTableNo
88777>>>>>>>        Get OpenTableExclusive hTable to bOK
88778>>>>>>>        If (bOK = False) Begin
88780>>>>>>>            Function_Return False
88781>>>>>>>        End
88781>>>>>>>>
88781>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88784>>>>>>>
88784>>>>>>>        // We start by deleting the index
88784>>>>>>>        Structure_Start hTable sDriverID
88785>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88786>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88787>>>>>>>            Delete_Index iTableNo iIndex
88788>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88789>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88790>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88792>>>>>>>
88792>>>>>>>        Move False to Err
88793>>>>>>>        Move iTableNo to hTable
88794>>>>>>>        Get OpenTableExclusive hTable to bOK
88795>>>>>>>        If (bOK = False) Begin
88797>>>>>>>            Function_Return False
88798>>>>>>>        End
88798>>>>>>>>
88798>>>>>>>
88798>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88799>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88799>>>>>>>        Structure_Start hTable sDriverID
88800>>>>>>>            Create_Index hTable At iIndex
88801>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88804>>>>>>>
88804>>>>>>>            If (iSgmnt1 <> -1) Begin
88806>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88809>>>>>>>            End
88809>>>>>>>>
88809>>>>>>>            If (iSegment2 <> -1) Begin
88811>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88814>>>>>>>            End
88814>>>>>>>>
88814>>>>>>>            If (iSegment3 <> -1) Begin
88816>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88819>>>>>>>            End
88819>>>>>>>>
88819>>>>>>>            If (iSegment4 <> -1) Begin
88821>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88824>>>>>>>            End
88824>>>>>>>>
88824>>>>>>>            If (iSegment5 <> -1) Begin
88826>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88829>>>>>>>            End
88829>>>>>>>>
88829>>>>>>>            If (iSegment6 <> -1) Begin
88831>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88834>>>>>>>            End
88834>>>>>>>>
88834>>>>>>>            If (iSegment7 <> -1) Begin
88836>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88839>>>>>>>            End
88839>>>>>>>>
88839>>>>>>>            If (iSegment8 <> -1) Begin
88841>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88844>>>>>>>            End
88844>>>>>>>>
88844>>>>>>>            If (iSegment9 <> -1) Begin
88846>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88849>>>>>>>            End
88849>>>>>>>>
88849>>>>>>>            If (iSegment10 <> -1) Begin
88851>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88854>>>>>>>            End
88854>>>>>>>>
88854>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88856>>>>>>>
88856>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88857>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
88857>>>>>>>
88857>>>>>>>        Function_Return (Err = False)
88858>>>>>>>    End_Function
88859>>>>>>>
88859>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex Integer iIndex tAPIIndexSegment[] aIndexSegments Returns Boolean 
88861>>>>>>>        String[] aFields
88862>>>>>>>        Integer iCount iSize iMax iTableNo iField iSegments
88862>>>>>>>        String sDriverID
88862>>>>>>>        Boolean bOK 
88862>>>>>>>
88862>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSize
88863>>>>>>>        If (iSize = 0) Begin
88865>>>>>>>            Function_Return False                                                            
88866>>>>>>>        End
88866>>>>>>>>
88866>>>>>>>        Decrement iSize
88867>>>>>>>        
88867>>>>>>>        Move hTable to iTableNo
88868>>>>>>>        Get AutoConnectionIDLogin to bOK
88869>>>>>>>        Move False to Err
88870>>>>>>>        Get OpenTableExclusive hTable to bOK
88871>>>>>>>        If (bOK = False) Begin
88873>>>>>>>            Function_Return False
88874>>>>>>>        End
88874>>>>>>>>
88874>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88877>>>>>>>        
88877>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER 
88878>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88879>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
88880>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88881>>>>>>>        // We will only attempt to delete the index in case it exists.
88881>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88884>>>>>>>        If (iSegments > 0) Begin
88886>>>>>>>            // We start by deleting the index
88886>>>>>>>            Structure_Start hTable sDriverID 
88887>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88888>>>>>>>                Delete_Index iTableNo iIndex
88889>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88890>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE
88892>>>>>>>        End
88892>>>>>>>>
88892>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER 
88893>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88894>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
88895>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88896>>>>>>>        
88896>>>>>>>        Move False to Err
88897>>>>>>>        Move 0 to LastErr
88898>>>>>>>        Move iTableNo to hTable
88899>>>>>>>        Get OpenTableExclusive hTable to bOK
88900>>>>>>>        If (bOK = False) Begin
88902>>>>>>>            Function_Return False
88903>>>>>>>        End
88903>>>>>>>>
88903>>>>>>>    
88903>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88904>>>>>>>        Structure_Start hTable sDriverID
88905>>>>>>>            Create_Index hTable At iIndex
88906>>>>>>>            Set_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndex.sSQLIndexName
88909>>>>>>>            Set_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88912>>>>>>>            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndex.bIsPrimaryKey
88915>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iSize + 1)
88918>>>>>>>            for iCount from 0 to iSize
88924>>>>>>>>
88924>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iField
88925>>>>>>>                If (iField <> -1) Begin 
88927>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iCount + 1) to iField
88930>>>>>>>                End
88930>>>>>>>>
88930>>>>>>>            Loop
88931>>>>>>>>
88931>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88933>>>>>>>
88933>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88934>>>>>>>        Function_Return (Err = False)
88935>>>>>>>    End_Function
88936>>>>>>>    
88936>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88938>>>>>>>        Boolean bOK
88938>>>>>>>
88938>>>>>>>        Get AutoConnectionIDLogin to bOK
88939>>>>>>>        Move False to Err
88940>>>>>>>        Get OpenTableExclusive hTable to bOK
88941>>>>>>>        If (bOK = False) Begin
88943>>>>>>>            Function_Return False
88944>>>>>>>        End
88944>>>>>>>>
88944>>>>>>>        Structure_Start hTable
88945>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88948>>>>>>>        Structure_End hTable
88950>>>>>>>
88950>>>>>>>        Function_Return (Err = False)
88951>>>>>>>    End_Function
88952>>>>>>>
88952>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88954>>>>>>>        Integer iCase
88954>>>>>>>        Boolean bOK
88954>>>>>>>
88954>>>>>>>        If (bUppercase = True) Begin
88956>>>>>>>            Move DF_CASE_IGNORED to iCase
88957>>>>>>>        End
88957>>>>>>>>
88957>>>>>>>        Else Begin
88958>>>>>>>            Move DF_CASE_USED to iCase
88959>>>>>>>        End
88959>>>>>>>>
88959>>>>>>>
88959>>>>>>>        Get AutoConnectionIDLogin to bOK
88960>>>>>>>        Move False to Err
88961>>>>>>>        Get OpenTableExclusive hTable to bOK
88962>>>>>>>        If (bOK = False) Begin
88964>>>>>>>            Function_Return False
88965>>>>>>>        End
88965>>>>>>>>
88965>>>>>>>        Structure_Start hTable
88966>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88969>>>>>>>        Structure_End hTable
88971>>>>>>>
88971>>>>>>>        Function_Return (Err = False)
88972>>>>>>>    End_Function
88973>>>>>>>
88973>>>>>>>    // To delete an index
88973>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88975>>>>>>>        Integer iTableNo iNumSegments
88975>>>>>>>        String sDriverID
88975>>>>>>>        Boolean bOK
88975>>>>>>>
88975>>>>>>>        Get AutoConnectionIDLogin to bOK
88976>>>>>>>        Move False to Err
88977>>>>>>>        Move hTable to iTableNo
88978>>>>>>>        Get OpenTableExclusive hTable to bOK
88979>>>>>>>        If (bOK = False) Begin
88981>>>>>>>            Function_Return False
88982>>>>>>>        End
88982>>>>>>>>
88982>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88985>>>>>>>
88985>>>>>>>        // Check to see if the index exists or not...
88985>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88988>>>>>>>        If (iNumSegments = 0) Begin
88990>>>>>>>            Function_Return False
88991>>>>>>>        End
88991>>>>>>>>
88991>>>>>>>
88991>>>>>>>        Structure_Start hTable sDriverID
88992>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88993>>>>>>>            Delete_Index iTableNo iIndex
88994>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88995>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88997>>>>>>>
88997>>>>>>>        Function_Return (Err = False)
88998>>>>>>>    End_Function
88999>>>>>>>
88999>>>>>>>    // Delete an Index Segment
88999>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
89001>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary
89001>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
89001>>>>>>>        Integer iIndexType
89001>>>>>>>        String sDriverID 
89001>>>>>>>
89001>>>>>>>        Get AutoConnectionIDLogin to bOK
89002>>>>>>>        Move False to Err
89003>>>>>>>    
89003>>>>>>>        Get OpenTableExclusive hTable to bOK
89004>>>>>>>        If (bOK = False) Begin
89006>>>>>>>            Function_Return False
89007>>>>>>>        End
89007>>>>>>>>
89007>>>>>>>        
89007>>>>>>>        // Check to see if the index exists or not...
89007>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89010>>>>>>>        If (iNumSegments = 0) Begin
89012>>>>>>>            Function_Return False
89013>>>>>>>        End
89013>>>>>>>>
89013>>>>>>>        
89013>>>>>>>        Move False to bIndexTemporary
89014>>>>>>>        Get psDriverID to sDriverID
89015>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89016>>>>>>>        If (bSQLDriver) Begin
89018>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89021>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89024>>>>>>>                Move True to bIndexTemporary
89025>>>>>>>        End
89025>>>>>>>>
89025>>>>>>>    
89025>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89025>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89027>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89030>>>>>>>            If (iSegment = iNumSegments) Begin
89032>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89035>>>>>>>            End
89035>>>>>>>>
89035>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89038>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89044>>>>>>>>
89044>>>>>>>                    //*** Move index segment attributes
89044>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89047>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89050>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89053>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89056>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89059>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89062>>>>>>>                Loop
89063>>>>>>>>
89063>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89066>>>>>>>            End
89066>>>>>>>>
89066>>>>>>>        End
89066>>>>>>>>
89066>>>>>>>
89066>>>>>>>        Else Begin
89067>>>>>>>           Structure_Start hTable
89068>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89071>>>>>>>               If (iSegment = iNumSegments) Begin
89073>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89076>>>>>>>               End
89076>>>>>>>>
89076>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89079>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89085>>>>>>>>
89085>>>>>>>                       //*** Move index segment attributes
89085>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89088>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89091>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89094>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89097>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89100>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89103>>>>>>>                   Loop
89104>>>>>>>>
89104>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89107>>>>>>>               End
89107>>>>>>>>
89107>>>>>>>           Structure_End hTable
89109>>>>>>>        End
89109>>>>>>>>
89109>>>>>>>        
89109>>>>>>>        Function_Return (Err = False)
89110>>>>>>>    End_Function
89111>>>>>>>    
89111>>>>>>>    // Add/Insert an Index Segment
89111>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89113>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary
89113>>>>>>>        Integer iSQLType iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89113>>>>>>>        Integer iIndexType
89113>>>>>>>        String sDriverId
89113>>>>>>>        
89113>>>>>>>        Get AutoConnectionIDLogin to bOK
89114>>>>>>>        Move False to Err
89115>>>>>>>    
89115>>>>>>>        Get OpenTableExclusive hTable to bOK
89116>>>>>>>        If (bOK = False) Begin
89118>>>>>>>            Function_Return False
89119>>>>>>>        End
89119>>>>>>>>
89119>>>>>>>        
89119>>>>>>>        Move False to bIndexTemporary
89120>>>>>>>        // Check to see if the index exists or not...
89120>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89123>>>>>>>        If (iNumSegments = 0) Begin
89125>>>>>>>            Function_Return False
89126>>>>>>>        End
89126>>>>>>>>
89126>>>>>>>    
89126>>>>>>>        Get psDriverID to sDriverID
89127>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89128>>>>>>>        If (bSQLDriver) Begin
89130>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89133>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89136>>>>>>>                Move True to bIndexTemporary
89137>>>>>>>        End
89137>>>>>>>>
89137>>>>>>>
89137>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89137>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89139>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89142>>>>>>>    
89142>>>>>>>           If (iSegment > iNumSegments) Begin
89144>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89147>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89148>>>>>>>           End
89148>>>>>>>>
89148>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89151>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89154>>>>>>>               Move iNumSegments to iCurSegment
89155>>>>>>>           
89155>>>>>>>               While (iCurSegment > iSegment)
89159>>>>>>>                   //*** Move index segment attributes
89159>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89162>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89165>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89168>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89171>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89174>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89177>>>>>>>                   Decrement iCurSegment
89178>>>>>>>               End
89179>>>>>>>>
89179>>>>>>>           
89179>>>>>>>               //*** Now set new segment attributes
89179>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89182>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89185>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89188>>>>>>>           End
89188>>>>>>>>
89188>>>>>>>        End
89188>>>>>>>>
89188>>>>>>>        
89188>>>>>>>        Else Begin
89189>>>>>>>           Structure_Start hTable
89190>>>>>>>              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89193>>>>>>>           
89193>>>>>>>              If (iSegment > iNumSegments) Begin
89195>>>>>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89198>>>>>>>                  Move (iNumSegments + 1) to iCurSegment
89199>>>>>>>              End
89199>>>>>>>>
89199>>>>>>>              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89202>>>>>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89205>>>>>>>                  Move iNumSegments to iCurSegment
89206>>>>>>>              
89206>>>>>>>                  While (iCurSegment > iSegment)
89210>>>>>>>                      //*** Move index segment attributes
89210>>>>>>>                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89213>>>>>>>                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89216>>>>>>>                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89219>>>>>>>                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89222>>>>>>>                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89225>>>>>>>                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89228>>>>>>>                      Decrement iCurSegment
89229>>>>>>>                  End
89230>>>>>>>>
89230>>>>>>>              
89230>>>>>>>                  //*** Now set new segment attributes
89230>>>>>>>                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89233>>>>>>>                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89236>>>>>>>                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89239>>>>>>>              End
89239>>>>>>>>
89239>>>>>>>           Structure_End hTable
89241>>>>>>>        End
89241>>>>>>>>
89241>>>>>>>        
89241>>>>>>>        Function_Return (Err = False)
89242>>>>>>>    End_Function
89243>>>>>>>    
89243>>>>>>>    // Returns an SQL Driver ID if it appears as a prefix for the passed sRootName
89243>>>>>>>    // If no driver found the DATAFLEX_ID is returned
89243>>>>>>>//    Function UtilDriverIDFromRootName String sRootName Returns String
89243>>>>>>>//        String sDriverID
89243>>>>>>>//        Integer iPos
89243>>>>>>>//        Move (Pos(":", sRootName)) to iPos
89243>>>>>>>//        If (iPos <> 0) Begin
89243>>>>>>>//            Move (Left(sRootName, (iPos -1))) to sDriverID
89243>>>>>>>//        End
89243>>>>>>>//        Else Begin
89243>>>>>>>//            Move DATAFLEX_ID to sDriverID
89243>>>>>>>//        End
89243>>>>>>>//        Function_Return sDriverID
89243>>>>>>>//    End_Function              
89243>>>>>>>    
89243>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89243>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89243>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfoFrom tAPITableNameInfo APITableInfoTo Returns Boolean
89245>>>>>>>        Boolean bTheSame 
89245>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89245>>>>>>>        
89245>>>>>>>        Get _TableNameOnly APITableInfoFrom.sRootName to sRootNameFrom
89246>>>>>>>        Get _TableNameOnly APITableInfoTo.sRootName   to sRootNameTo                                    
89247>>>>>>>        Move APITableInfoFrom.sLogicalName            to sLogicalNameFrom
89248>>>>>>>        Move APITableInfoTo.sLogicalName              to sLogicalNameTo
89249>>>>>>>        Move APITableInfoFrom.sDisplayName            to sDisplayNameFrom
89250>>>>>>>        Move APITableInfoTo.sDisplayName              to sDisplayNameTo
89251>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89253>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bTheSame
89254>>>>>>>        End
89254>>>>>>>>
89254>>>>>>>        Else Begin
89255>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bTheSame                  
89256>>>>>>>        End
89256>>>>>>>>
89256>>>>>>>            
89256>>>>>>>        Function_Return bTheSame
89257>>>>>>>    End_Function                
89258>>>>>>>    
89258>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89260>>>>>>>        Handle hTableFrom hTableTo 
89260>>>>>>>        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
89260>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase 
89260>>>>>>>        String sRootName sDriverID
89260>>>>>>>
89260>>>>>>>        Move False to bFilelistError
89261>>>>>>>        Move True to bIsSame
89262>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89263>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89264>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89265>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89266>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo          
89267>>>>>>>        
89267>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89268>>>>>>>        Get _TableNameOnly sRootName             to sRootName
89269>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89270>>>>>>>
89270>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89270>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89270>>>>>>>        If (bCodeGenerateMode = True) Begin
89272>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89272>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89274>>>>>>>                Function_Return False
89275>>>>>>>            End
89275>>>>>>>>
89275>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89276>>>>>>>            If (bIsSame = False) Begin   
89278>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89279>>>>>>>                Move True to bFilelistError
89280>>>>>>>                Function_Return False
89281>>>>>>>            End
89281>>>>>>>>
89281>>>>>>>        End
89281>>>>>>>>
89281>>>>>>>        
89281>>>>>>>        If (bCodeGenerateMode = False) Begin
89283>>>>>>>            // Then we want to create this table
89283>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89285>>>>>>>                Function_Return False
89286>>>>>>>            End
89286>>>>>>>>
89286>>>>>>>                
89286>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89287>>>>>>>            If (bIsSame = False) Begin
89289>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89290>>>>>>>>
89290>>>>>>>                Move True to bFilelistError
89291>>>>>>>                Function_Return False
89292>>>>>>>            End
89292>>>>>>>>
89292>>>>>>>        End
89292>>>>>>>>
89292>>>>>>>
89292>>>>>>>        // Check columns:                        
89292>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89293>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89294>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom 
89295>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89296>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverID
89297>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns  
89298>>>>>>>        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bIsSame
89299>>>>>>>        If (bIsSame = False) Begin
89301>>>>>>>            Function_Return False
89302>>>>>>>        End
89302>>>>>>>>
89302>>>>>>>        
89302>>>>>>>        // ...then check indexes:
89302>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89303>>>>>>>        Get UtilIndexesCompare    hTableFrom APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
89304>>>>>>>        If (bIsSame = False) Begin
89306>>>>>>>            Function_Return False
89307>>>>>>>        End
89307>>>>>>>>
89307>>>>>>>        
89307>>>>>>>        // ...and finally relationships:
89307>>>>>>>        Get UtilRelationStructFill hTableFrom to APITableTo.aApiRelations
89308>>>>>>>        Get UtilRelationsCompare      hTableFrom APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
89309>>>>>>>        
89309>>>>>>>        Function_Return (bIsSame = True)
89310>>>>>>>    End_Function
89311>>>>>>>    
89311>>>>>>>    // Similar to UtilTableCompare, but takes two tAPITable struct arrays as parameters and a apitableboolean struct as params.
89311>>>>>>>    Function UtilTableCompare_Ex tAPITable CompareTableFrom tAPITable CompareTableTo tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89313>>>>>>>        Handle hTableFrom hTableTo 
89313>>>>>>>        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
89313>>>>>>>        tAPITableNameInfo APITableInfoFrom APITableInfoTo
89313>>>>>>>        tAPITableNameInfo APITableInfoFrom APITableInfoTo
89313>>>>>>>        tAPIIndex[]    aIndexesFrom   aIndexesTo
89313>>>>>>>        tAPIIndex[]    aIndexesFrom   aIndexesTo
89315>>>>>>>        tAPIColumn[]   aColumnsFrom   aColumnsTo
89315>>>>>>>        tAPIColumn[]   aColumnsFrom   aColumnsTo
89317>>>>>>>        tAPIRelation[] aRelationsFrom aRelationsTo        
89317>>>>>>>        tAPIRelation[] aRelationsFrom aRelationsTo        
89319>>>>>>>        String sRootName sDriverID
89319>>>>>>>        
89319>>>>>>>        If (CompareTableFrom.ApiTableInfo.iTableNumber < 0 or CompareTableTo.ApiTableInfo.iTableNumber < 0) Begin
89321>>>>>>>            Move True to bFilelistError
89322>>>>>>>            Function_Return False    
89323>>>>>>>        End 
89323>>>>>>>>
89323>>>>>>>        
89323>>>>>>>        Move True  to bIsSame 
89324>>>>>>>        Move False to bFilelistError
89325>>>>>>>        
89325>>>>>>>        Move CompareTableFrom.ApiTableInfo  to APITableInfoFrom
89326>>>>>>>        Move CompareTableFrom.aApiColumns   to aColumnsFrom
89327>>>>>>>        Move CompareTableFrom.aApiIndexes   to aIndexesFrom
89328>>>>>>>        Move CompareTableFrom.aApiRelations to aRelationsFrom  
89329>>>>>>>        Move APITableInfoFrom.iTableNumber  to hTableFrom 
89330>>>>>>>        Move APITableInfoFrom.bIsSQL        to bIsSQLFrom         
89331>>>>>>>        Move APITableInfoFrom.sDriverID     to sDriverID
89332>>>>>>>        
89332>>>>>>>        Move CompareTableTo.ApiTableInfo    to APITableInfoTo
89333>>>>>>>        Move CompareTableTo.aApiColumns     to aColumnsTo
89334>>>>>>>        Move CompareTableTo.aApiIndexes     to aIndexesTo
89335>>>>>>>        Move CompareTableTo.aApiRelations   to aRelationsTo
89336>>>>>>>        Move APITableInfoTo.iTableNumber    to hTableTo          
89337>>>>>>>        Move APITableInfoTo.bIsSQL          to bIsSQLTo
89338>>>>>>>        
89338>>>>>>>        Move APITableInfoTo.sRootName       to sRootName
89339>>>>>>>        Get _TableNameOnly sRootName        to sRootName
89340>>>>>>>
89340>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89340>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89340>>>>>>>        If (bCodeGenerateMode = True) Begin
89342>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89342>>>>>>>            If (Trim(APITableInfoTo.sLogicalName) = "") Begin
89344>>>>>>>                Function_Return False
89345>>>>>>>            End                                                                    
89345>>>>>>>>
89345>>>>>>>            Move (Uppercase(APITableInfoFrom.sLogicalName) = Uppercase(APITableInfoTo.sLogicalName)) to bIsSame
89346>>>>>>>            If (bIsSame = False) Begin
89348>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableInfoFrom.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableInfoTo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89349>>>>>>>                Move True to bFilelistError
89350>>>>>>>                Function_Return False
89351>>>>>>>            End
89351>>>>>>>>
89351>>>>>>>        End
89351>>>>>>>>
89351>>>>>>>        
89351>>>>>>>        If (bCodeGenerateMode = False) Begin
89353>>>>>>>            If (Trim(Uppercase(APITableInfoTo.sLogicalName)) = "") Begin
89355>>>>>>>                // Then we might want to create this table
89355>>>>>>>                Function_Return False
89356>>>>>>>            End
89356>>>>>>>>
89356>>>>>>>            
89356>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableInfoFrom APITableInfoTo to bIsSame
89357>>>>>>>            If (bIsSame = False) Begin
89359>>>>>>>                Function_Return False
89360>>>>>>>            End
89360>>>>>>>>
89360>>>>>>>        End
89360>>>>>>>>
89360>>>>>>>
89360>>>>>>>        // Check columns:         
89360>>>>>>>        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom aColumnsTo CompareTableBooleans.bCompareDate_DateTime to bIsSame
89361>>>>>>>        If (bIsSame = False) Begin
89363>>>>>>>            Function_Return False
89364>>>>>>>        End
89364>>>>>>>>
89364>>>>>>>        
89364>>>>>>>        // ...then check indexes:
89364>>>>>>>        Get UtilIndexesCompare hTableFrom aIndexesFrom aIndexesTo CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89365>>>>>>>        If (bIsSame = False) Begin
89367>>>>>>>            Function_Return False
89368>>>>>>>        End
89368>>>>>>>>
89368>>>>>>>        
89368>>>>>>>        // ...and finally relationships:
89368>>>>>>>        Get UtilRelationsCompare hTableFrom aRelationsFrom aRelationsTo to bIsSame
89369>>>>>>>        
89369>>>>>>>        Function_Return (bIsSame = True)
89370>>>>>>>    End_Function
89371>>>>>>>    
89371>>>>>>>    // Compare multiple columns. (For 'From' & 'To' tables)
89371>>>>>>>    Function UtilColumnsCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
89373>>>>>>>        Boolean bIsSame        
89373>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iColumn iType iLength
89373>>>>>>>        String sColumnNameFrom sColumnNameTo
89373>>>>>>>        
89373>>>>>>>        Move True to bIsSame
89374>>>>>>>        Move (SizeOfArray(aColumnsFrom)) to iSizeFrom
89375>>>>>>>        Move (SizeOfArray(aColumnsTo))   to iSizeTo
89376>>>>>>>        If (iSizeFrom <> iSizeTo) Begin
89378>>>>>>>            Function_Return False
89379>>>>>>>        End          
89379>>>>>>>>
89379>>>>>>>        Move (iSizeFrom max iSizeTo)     to iSize 
89380>>>>>>>        Set piMaximum of ghoProgressBar  to iSize
89381>>>>>>>        
89381>>>>>>>        Decrement iSize
89382>>>>>>>        for iCount from 0 to iSize       
89388>>>>>>>>
89388>>>>>>>            Set piPosition of ghoProgressBar to iCount
89389>>>>>>>            If (iCount <= iSizeFrom and iCount <= iSizeTo) Begin
89391>>>>>>>                Get UtilColumnCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DataTime to bIsSame
89392>>>>>>>            End 
89392>>>>>>>>
89392>>>>>>>            Else Begin
89393>>>>>>>                Move False to bIsSame
89394>>>>>>>            End
89394>>>>>>>>
89394>>>>>>>            
89394>>>>>>>            If (bIsSame = False) Begin
89396>>>>>>>                Function_Return False
89397>>>>>>>            End
89397>>>>>>>>
89397>>>>>>>        Loop
89398>>>>>>>>
89398>>>>>>>        
89398>>>>>>>        Function_Return (bIsSame = True)
89399>>>>>>>    End_Function
89400>>>>>>>    
89400>>>>>>>    // Compares a single column (For 'From' & 'To' tables)
89400>>>>>>>    Function UtilColumnCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn aColumnsFrom tAPIColumn aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
89402>>>>>>>        Boolean bIsSame 
89402>>>>>>>        Integer iFromType iToType iDbType                    
89402>>>>>>>        tColumnType ColumnType
89402>>>>>>>        tColumnType ColumnType
89402>>>>>>>        
89402>>>>>>>        Get piDbType to iDbType
89403>>>>>>>        Move (aColumnsFrom.iFieldNumber <> 0 and aColumnsTo.iFieldNumber <> 0) to bIsSame
89404>>>>>>>        // Check that _both_ field_number and field_name are the same
89404>>>>>>>        // else they needs to be changed...                                  
89404>>>>>>>        If (bIsSame = False) Begin
89406>>>>>>>            Move (aColumnsFrom.iFieldNumber = aColumnsTo.iFieldNumber) to bIsSame
89407>>>>>>>        End
89407>>>>>>>>
89407>>>>>>>        If (bIsSame = False) Begin
89409>>>>>>>            Function_Return False
89410>>>>>>>        End
89410>>>>>>>>
89410>>>>>>>        Move (aColumnsFrom.sFieldName = aColumnsTo.sFieldName) to bIsSame
89411>>>>>>>        If (bIsSame = False) Begin
89413>>>>>>>            Function_Return False
89414>>>>>>>        End
89414>>>>>>>>
89414>>>>>>>        
89414>>>>>>>        Move aColumnsFrom.iType to iFromType
89415>>>>>>>        Move aColumnsTo.iType   to iToType
89416>>>>>>>        
89416>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
89416>>>>>>>        // data types between Embedded and SQL.
89416>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
89418>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iFromType aColumnsFrom.iLength to iFromType
89419>>>>>>>        End
89419>>>>>>>>
89419>>>>>>>        Else If (bIsSQLFrom = False and bIsSQLTo = True) Begin
89422>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iToType   aColumnsFrom.iLength to iToType
89423>>>>>>>        End
89423>>>>>>>>
89423>>>>>>>        
89423>>>>>>>        // *** THIS NEEDS TO BE REDONE ***
89423>>>>>>>        
89423>>>>>>>        // Make Date and DateTime comparison?
89423>>>>>>>        If (bCompareDate_DataTime = True and iFromType = DF_DATE or iFromType = DF_DATETIME or iFromType = SQL_TYPE_TIMESTAMP or iFromType = SQL_TYPE_TIMESTAMP2) Begin
89425>>>>>>>            Move (iFromType = iToType) to bIsSame
89426>>>>>>>            If (bIsSame = False) Begin
89428>>>>>>>                Function_Return False
89429>>>>>>>            End
89429>>>>>>>>
89429>>>>>>>        End
89429>>>>>>>>
89429>>>>>>>        
89429>>>>>>>        // This is when checking for other field types than dates...
89429>>>>>>>//        If (bCompareDate_DataTime = False and iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
89429>>>>>>>            Move (iFromType = iToType) to bIsSame
89430>>>>>>>            If (bIsSame = False) Begin
89432>>>>>>>                Function_Return False
89433>>>>>>>            End
89433>>>>>>>>
89433>>>>>>>//        End
89433>>>>>>>        
89433>>>>>>>        // If the field is of Date type (any of them) we don't compare length & precision.
89433>>>>>>>        If (iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
89435>>>>>>>            Move (aColumnsFrom.iLength = aColumnsTo.iLength) to bIsSame
89436>>>>>>>            If (bIsSame = False) Begin
89438>>>>>>>                Function_Return False
89439>>>>>>>            End                                               
89439>>>>>>>>
89439>>>>>>>            Move (aColumnsFrom.iPrecision = aColumnsTo.iPrecision) to bIsSame
89440>>>>>>>            If (bIsSame = False) Begin
89442>>>>>>>                Function_Return False
89443>>>>>>>            End                                               
89443>>>>>>>>
89443>>>>>>>        End
89443>>>>>>>>
89443>>>>>>>        
89443>>>>>>>        Move (aColumnsFrom.iOptions = aColumnsTo.iOptions) to bIsSame
89444>>>>>>>        If (bIsSame = False) Begin
89446>>>>>>>            Function_Return False
89447>>>>>>>        End                                               
89447>>>>>>>>
89447>>>>>>>
89447>>>>>>>        Function_Return True
89448>>>>>>>    End_Function
89449>>>>>>>    
89449>>>>>>>    // Compares multiple indexes for a 'From' and a 'To' table.
89449>>>>>>>    Function UtilIndexesCompare Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
89451>>>>>>>        Boolean bIsSame bDAWSQLDriver 
89451>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iSegment iNumSegments iColumn
89451>>>>>>>        String sIndexNameFrom sIndexNameTo sDriverID sColumnNameFrom
89451>>>>>>>        
89451>>>>>>>        Move True to bIsSame
89452>>>>>>>        Get psDriverID to sDriverID
89453>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
89454>>>>>>>        
89454>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
89455>>>>>>>        Move (SizeOfArray(aIndexesTo))   to iSizeTo  
89456>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89458>>>>>>>            Function_Return True
89459>>>>>>>        End
89459>>>>>>>>
89459>>>>>>>        If (iSizeFrom <> iSizeTo) Begin
89461>>>>>>>            Function_Return False
89462>>>>>>>        End          
89462>>>>>>>>
89462>>>>>>>        Move (iSizeFrom max iSizeTo) to iSize
89463>>>>>>>
89463>>>>>>>        Decrement iSize
89464>>>>>>>        For iCount from 0 to iSize 
89470>>>>>>>>
89470>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89471>>>>>>>            Get UtilIndexCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
89472>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89473>>>>>>>            If (bIsSame = False) Begin
89475>>>>>>>                Function_Return False
89476>>>>>>>            End
89476>>>>>>>>
89476>>>>>>>        Loop
89477>>>>>>>>
89477>>>>>>>        
89477>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89478>>>>>>>        Function_Return bIsSame
89479>>>>>>>    End_Function
89480>>>>>>>    
89480>>>>>>>    // Compares a single index for a 'From' and a 'To' table.
89480>>>>>>>    Function UtilIndexCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
89482>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
89482>>>>>>>        String sDriverID  
89482>>>>>>>        Integer iSegment
89482>>>>>>>        
89482>>>>>>>        Move True to bIsSame
89483>>>>>>>        Get psDriverID to sDriverID
89484>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
89485>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
89486>>>>>>>        If (bIsSqlTable = True) Begin
89488>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
89489>>>>>>>        End
89489>>>>>>>>
89489>>>>>>>        
89489>>>>>>>        Move True to bIsSame
89490>>>>>>>        If (bIsSqlTable = True) Begin
89492>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
89493>>>>>>>            If (bIsSame = False) Begin
89495>>>>>>>                Function_Return False
89496>>>>>>>            End
89496>>>>>>>>
89496>>>>>>>            Move (aIndexFrom.bIsPrimaryKey = aIndexTo.bIsPrimaryKey) to bIsSame
89497>>>>>>>            If (bIsSame = False) Begin
89499>>>>>>>                Function_Return False
89500>>>>>>>            End
89500>>>>>>>>
89500>>>>>>>            Move (aIndexFrom.sSQLIndexName = aIndexTo.sSQLIndexName) to bIsSame
89501>>>>>>>            If (bIsSame = False) Begin
89503>>>>>>>                Function_Return False
89504>>>>>>>            End
89504>>>>>>>>
89504>>>>>>>        End
89504>>>>>>>>
89504>>>>>>>        
89504>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89505>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
89506>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89507>>>>>>>        If (bIsSame = False) Begin
89509>>>>>>>            Function_Return False
89510>>>>>>>        End                      
89510>>>>>>>>
89510>>>>>>>        
89510>>>>>>>        Get UtilIndexSegmentsCompare aIndexFrom aIndexTo bCompareIndexUppercase bCompareIndexAscending to iSegment
89511>>>>>>>        If (iSegment = -1) Begin
89513>>>>>>>            Move True to bIsSame
89514>>>>>>>        End  
89514>>>>>>>>
89514>>>>>>>        Else Begin                                                         
89515>>>>>>>            Move True to aIndexTo.bShouldChange
89516>>>>>>>            Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
89517>>>>>>>        End
89517>>>>>>>>
89517>>>>>>>        
89517>>>>>>>        Function_Return (bIsSame = True)
89518>>>>>>>    End_Function
89519>>>>>>>    
89519>>>>>>>    // Compares each segment for the passed index.
89519>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
89519>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
89521>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment                                                
89521>>>>>>>        Boolean bIsSame
89521>>>>>>>        
89521>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89522>>>>>>>        Move (SizeOfArray(aIndexFrom.IndexSegmentArray)) to iNumSegmentsFrom
89523>>>>>>>        Move (SizeOfArray(aIndexTo.IndexSegmentArray))   to iNumSegmentsTo
89524>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo)       to iNumSegments
89525>>>>>>>        
89525>>>>>>>        Decrement iNumSegments
89526>>>>>>>        for iSegment from 0 to iNumSegments  
89532>>>>>>>>
89532>>>>>>>            Move False to bIsSame
89533>>>>>>>            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
89535>>>>>>>                Get UtilIndexSegmentCompare aIndexFrom.IndexSegmentArray[iSegment] aIndexTo.IndexSegmentArray[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
89536>>>>>>>            End
89536>>>>>>>>
89536>>>>>>>            If (bIsSame = False) Begin
89538>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89539>>>>>>>                Move True to aIndexTo.bShouldChange
89540>>>>>>>                Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
89541>>>>>>>                Function_Return iSegment
89542>>>>>>>            End
89542>>>>>>>>
89542>>>>>>>        Loop             
89543>>>>>>>>
89543>>>>>>>        
89543>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89544>>>>>>>        Function_Return -1 // This means bIsSame = True
89545>>>>>>>    End_Function
89546>>>>>>>    
89546>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
89548>>>>>>>        Integer iNumSegments iSegment                                                
89548>>>>>>>        Boolean bIsSame
89548>>>>>>>
89548>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
89549>>>>>>>        If (bIsSame = False) Begin
89551>>>>>>>            Function_Return False
89552>>>>>>>        End
89552>>>>>>>>
89552>>>>>>>        If (bCompareIndexUppercase = True) Begin
89554>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
89555>>>>>>>            If (bIsSame = False) Begin
89557>>>>>>>                Function_Return False
89558>>>>>>>            End
89558>>>>>>>>
89558>>>>>>>        End
89558>>>>>>>>
89558>>>>>>>        If (bCompareIndexAscending = True) Begin
89560>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
89561>>>>>>>            If (bIsSame = False) Begin
89563>>>>>>>                Function_Return False
89564>>>>>>>            End
89564>>>>>>>>
89564>>>>>>>        End
89564>>>>>>>>
89564>>>>>>>        
89564>>>>>>>        Function_Return True
89565>>>>>>>    End_Function
89566>>>>>>>    
89566>>>>>>>    // This is the same as the UtilIndexCompare function _except_ it only checks if the Index type and number are equal or not.
89566>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
89568>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
89568>>>>>>>        Integer iCount iSize iSegment iNumSegments iIndexSegment
89568>>>>>>>        String sDriverID 
89568>>>>>>>        
89568>>>>>>>        Move True to bIsSame
89569>>>>>>>        Get psDriverID to sDriverID
89570>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
89571>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
89572>>>>>>>        If (bIsSqlTable = True) Begin
89574>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
89575>>>>>>>        End
89575>>>>>>>>
89575>>>>>>>        
89575>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89576>>>>>>>        Move True to bIsSame
89577>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
89579>>>>>>>            // Don't think we should do this. Or should we?
89579>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
89579>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
89580>>>>>>>            If (bIsSame = False) Begin
89582>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89583>>>>>>>                Function_Return False
89584>>>>>>>            End
89584>>>>>>>>
89584>>>>>>>        End
89584>>>>>>>>
89584>>>>>>>        
89584>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
89585>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89586>>>>>>>        If (bIsSame = False) Begin
89588>>>>>>>            Function_Return False
89589>>>>>>>        End                      
89589>>>>>>>>
89589>>>>>>>        
89589>>>>>>>        Function_Return bIsSame
89590>>>>>>>    End_Function
89591>>>>>>>    
89591>>>>>>>    // Compares multiple relationships for a 'From' and a 'To' table
89591>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
89593>>>>>>>        Boolean bIsSame
89593>>>>>>>        Integer iSize iCount
89593>>>>>>>        
89593>>>>>>>        Move True to bIsSame
89594>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
89595>>>>>>>        Decrement iSize
89596>>>>>>>        For iCount from 0 to iSize   
89602>>>>>>>>
89602>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89603>>>>>>>            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
89604>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89605>>>>>>>            If (bIsSame = False) Begin
89607>>>>>>>                Function_Return False
89608>>>>>>>            End
89608>>>>>>>>
89608>>>>>>>        Loop
89609>>>>>>>>
89609>>>>>>>        
89609>>>>>>>        Function_Return bIsSame
89610>>>>>>>    End_Function
89611>>>>>>>
89611>>>>>>>    // Compares a single relationship for a 'From' and a 'To' table
89611>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelation aRelationsFrom tAPIRelation aRelationsTo Returns Boolean
89613>>>>>>>        Boolean bIsSame
89613>>>>>>>        Integer iSize iCount
89613>>>>>>>        
89613>>>>>>>        Move True to bIsSame
89614>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89615>>>>>>>        Move (aRelationsFrom.hTableFrom = aRelationsTo.hTableFrom) to bIsSame
89616>>>>>>>        If (bIsSame = False) Begin
89618>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89619>>>>>>>            Function_Return False
89620>>>>>>>        End
89620>>>>>>>>
89620>>>>>>>        Move (aRelationsFrom.hTableTo = aRelationsTo.hTableTo) to bIsSame
89621>>>>>>>        If (bIsSame = False) Begin
89623>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89624>>>>>>>            Function_Return False
89625>>>>>>>        End
89625>>>>>>>>
89625>>>>>>>        Move (aRelationsFrom.iColumnFrom = aRelationsTo.iColumnFrom) to bIsSame
89626>>>>>>>        If (bIsSame = False) Begin
89628>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89629>>>>>>>            Function_Return False
89630>>>>>>>        End
89630>>>>>>>>
89630>>>>>>>        
89630>>>>>>>        Move (aRelationsFrom.iColumnTo = aRelationsTo.iColumnTo) to bIsSame
89631>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89632>>>>>>>
89632>>>>>>>        Function_Return bIsSame
89633>>>>>>>    End_Function
89634>>>>>>>
89634>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
89634>>>>>>>    // already exists. Instead it checks if the table needs to be updated with any of the struct arrays,
89634>>>>>>>    // for fields, indexes or relations.
89634>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
89636>>>>>>>        Boolean bIsSame bOK
89636>>>>>>>        Integer iSize iCount 
89636>>>>>>>        
89636>>>>>>>        Move True to bOK
89637>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
89638>>>>>>>        Decrement iSize
89639>>>>>>>        for iCount from 0 to iSize
89645>>>>>>>>
89645>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89646>>>>>>>            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
89647>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89648>>>>>>>            If (bIsSame = False) Begin
89650>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89651>>>>>>>                Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo to bOK
89652>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89653>>>>>>>            End
89653>>>>>>>>
89653>>>>>>>        Loop
89654>>>>>>>>
89654>>>>>>>        
89654>>>>>>>        Function_Return bOK
89655>>>>>>>    End_Function
89656>>>>>>>    
89656>>>>>>>    Function UtilIndexesUpdate Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
89658>>>>>>>        Boolean bIsSame bOK
89658>>>>>>>        Integer iSizeFrom iSizeTo iCount iIndexSegment                   
89658>>>>>>>        String sIndexFields
89658>>>>>>>        
89658>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
89659>>>>>>>        Move (SizeOfArray(aIndexesTo))   to iSizeTo 
89660>>>>>>>        Decrement iSizeTo
89661>>>>>>>        Decrement iSizeFrom
89662>>>>>>>        for iCount from 0 to iSizeFrom
89668>>>>>>>>
89668>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89669>>>>>>>            Get UtilIndexTypeNumberCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] to bIsSame
89670>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89671>>>>>>>            If (bIsSame = False and iSizeTo <> 0 and iCount <= iSizeTo) Begin
89673>>>>>>>                Get APIIndexCreateByFieldNames hTable iCount aIndexesFrom[iCount] aIndexesFrom[iCount].IndexSegmentArray to bOK
89674>>>>>>>            End
89674>>>>>>>>
89674>>>>>>>            If (bIsSame = True) Begin
89676>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT 
89677>>>>>>>                Move 0 to iIndexSegment
89678>>>>>>>                Get UtilIndexSegmentsCompare aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to iIndexSegment
89679>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89680>>>>>>>                If (iIndexSegment <> -1) Begin
89682>>>>>>>                    Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount].iIndexNumber aIndexesFrom[iCount].IndexSegmentArray to bOK
89683>>>>>>>                End
89683>>>>>>>>
89683>>>>>>>            End
89683>>>>>>>>
89683>>>>>>>        Loop
89684>>>>>>>>
89684>>>>>>>    
89684>>>>>>>        Function_Return bOK
89685>>>>>>>    End_Function  
89686>>>>>>>    
89686>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
89686>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
89686>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
89686>>>>>>>//        String sFieldName sDriverID
89686>>>>>>>//        
89686>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89686>>>>>>>//        If (bIsOpen = False) Begin
89686>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89686>>>>>>>//            Open hTable
89686>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89686>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89686>>>>>>>//            If (bIsOpen = False) Begin
89686>>>>>>>//                Function_Return False
89686>>>>>>>//            End
89686>>>>>>>//        End
89686>>>>>>>//
89686>>>>>>>//        Move True to bEqual
89686>>>>>>>//        Get psDriverID to sDriverID
89686>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
89686>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
89686>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
89686>>>>>>>//        Decrement iSize   
89686>>>>>>>//        
89686>>>>>>>//        For iCount from 0 to iSize
89686>>>>>>>//            Move 0 to iOptions    
89686>>>>>>>//            Move False to bIdentityKey
89686>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName               
89686>>>>>>>//            
89686>>>>>>>//            // We need to use the column name - not the column integer as
89686>>>>>>>//            // the order does not need to be the same, and the logic should still work.
89686>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
89686>>>>>>>//            If (iColumn > 0) Begin
89686>>>>>>>//                If (bDawSqlDriver = True) Begin
89686>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89686>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
89686>>>>>>>//                    If (iType <> aColumns[iCount].iType) Begin
89686>>>>>>>//                        Move False to bEqual
89686>>>>>>>//                    End
89686>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
89686>>>>>>>//                    If (bIdentityKey = True) Begin
89686>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
89686>>>>>>>//                    End
89686>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
89686>>>>>>>//                        Move False to bEqual
89686>>>>>>>//                    End
89686>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89686>>>>>>>//                End
89686>>>>>>>//                Else Begin
89686>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
89686>>>>>>>//                    If (iType <> aColumns[iCount].iType) Begin
89686>>>>>>>//                        Move False to bEqual
89686>>>>>>>//                    End
89686>>>>>>>//                End
89686>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
89686>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
89686>>>>>>>//                    Move False to bEqual
89686>>>>>>>//                End
89686>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
89686>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
89686>>>>>>>//                    Move False to bEqual
89686>>>>>>>//                End
89686>>>>>>>//                If (bEqual = False) Begin
89686>>>>>>>//                    Function_Return False
89686>>>>>>>//                End
89686>>>>>>>//            End
89686>>>>>>>//                    
89686>>>>>>>//            Else Begin
89686>>>>>>>//                Function_Return False
89686>>>>>>>//            End
89686>>>>>>>//        Loop
89686>>>>>>>//        
89686>>>>>>>//        Function_Return bEqual
89686>>>>>>>//    End_Function  
89686>>>>>>>    
89686>>>>>>>    // To fill a complete Table structure (tAPITable) with data.
89686>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89686>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89686>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89686>>>>>>>    Function UtilTableStructFill Boolean bStatusPanel Boolean bFromTables Returns tAPITable[]
89688>>>>>>>        tAPIColumn[]    aApiColumns   
89688>>>>>>>        tAPIColumn[]    aApiColumns   
89689>>>>>>>        tAPIIndex[]     aApiIndexes   
89689>>>>>>>        tAPIIndex[]     aApiIndexes   
89690>>>>>>>        tAPIRelation[]  aApiRelations 
89690>>>>>>>        tAPIRelation[]  aApiRelations 
89691>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
89691>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
89693>>>>>>>        Handle hTable
89693>>>>>>>        Integer iCount iPos 
89693>>>>>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
89693>>>>>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID
89693>>>>>>>        
89693>>>>>>>        Move 0 to hTable    
89694>>>>>>>        If (bFromTables = True) Begin
89696>>>>>>>            Set Message_Text of ghoStatusPanel to "Reading 'From' Table Structure:"
89697>>>>>>>        End 
89697>>>>>>>>
89697>>>>>>>        Else Begin
89698>>>>>>>            Set Message_Text of ghoStatusPanel to "Reading 'To' Table Structure:"
89699>>>>>>>        End
89699>>>>>>>>
89699>>>>>>>        Get UtilFilelistNoOfTables to iCount
89700>>>>>>>        Set piMaximum of ghoProgressBarOverall to iCount
89701>>>>>>>        Move 0 to iCount                                
89702>>>>>>>        
89702>>>>>>>        Repeat
89702>>>>>>>>
89702>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89705>>>>>>>            If (hTable > 0 and hTable <> 50) Begin           
89707>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable    to sRootName   
89710>>>>>>>                Get _TableNameOnly sRootName                 to sTableName
89711>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName   
89714>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89717>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bIsOpen
89718>>>>>>>                Get_Attribute DF_FILE_DRIVER       of hTable to sDriverID
89721>>>>>>>                Set piPosition of ghoProgressBarOverall to iCount
89722>>>>>>>                Set Action_Text of ghoStatusPanel  to (sTableName * "Number:" * String(hTable))
89723>>>>>>>                
89723>>>>>>>                Get UtilColumnsStructFill  hTable to aApiColumns
89724>>>>>>>                Get UtilIndexesStructFill  hTable to aApiIndexes
89725>>>>>>>                Get UtilRelationStructFill hTable to aApiRelations
89726>>>>>>>                Get UtilTableIsAlias       hTable to bIsAlias  
89727>>>>>>>                Get UtilTableIsSQL         hTable to bIsSQL
89728>>>>>>>                
89728>>>>>>>                Move hTable                                  to aApiTables[iCount].ApiTableInfo.iTableNumber
89729>>>>>>>                Move sRootName                               to aApiTables[iCount].ApiTableInfo.sRootName
89730>>>>>>>                Move sLogicalName                            to aApiTables[iCount].ApiTableInfo.sLogicalName
89731>>>>>>>                Move sDisplayName                            to aApiTables[iCount].ApiTableInfo.sDisplayName
89732>>>>>>>                Move sDriverID                               to aApiTables[iCount].ApiTableInfo.sDriverID
89733>>>>>>>                Move bIsAlias                                to aApiTables[iCount].ApiTableInfo.bIsAlias
89734>>>>>>>                Move bIsSQL                                  to aApiTables[iCount].ApiTableInfo.bIsSQL
89735>>>>>>>                Move aApiColumns                             to aApiTables[iCount].aApiColumns
89736>>>>>>>                Move aApiIndexes                             to aApiTables[iCount].aApiIndexes
89737>>>>>>>                Move aApiRelations                           to aApiTables[iCount].aApiRelations
89738>>>>>>>                Increment iCount
89739>>>>>>>            End     
89739>>>>>>>>
89739>>>>>>>            
89739>>>>>>>            If (bStatusPanel = True) Begin
89741>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89742>>>>>>>                If (bUserCancel = True) Begin
89744>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
89745>>>>>>>                    Function_Return aApiTablesEmpty
89746>>>>>>>                End
89746>>>>>>>>
89746>>>>>>>            End
89746>>>>>>>>
89746>>>>>>>
89746>>>>>>>        Until (hTable = 0)    
89748>>>>>>>    
89748>>>>>>>        Function_Return aApiTables    
89749>>>>>>>    End_Function
89750>>>>>>>
89750>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
89752>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
89752>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
89752>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89752>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89754>>>>>>>        String sDriverID sFieldName sRootName sLogicalName sValue
89754>>>>>>>        
89754>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
89755>>>>>>>        Get piDbType to iDbType
89756>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89759>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89762>>>>>>>        Open hTable
89764>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89767>>>>>>>        If (bIsOpen = False) Begin
89769>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89770>>>>>>>            Open hTable
89772>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89773>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89776>>>>>>>            If (bIsOpen = False) Begin
89778>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT 
89779>>>>>>>                Function_Return APIColumnsEmpty
89780>>>>>>>            End
89780>>>>>>>>
89780>>>>>>>        End
89780>>>>>>>>
89780>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89783>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
89784>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver       
89785>>>>>>>        
89785>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
89787>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
89788>>>>>>>            If (bIsSqlTable = True) Begin
89790>>>>>>>                Get UtilTableExists hTable to bExists
89791>>>>>>>                If (bExists = False) Begin
89793>>>>>>>                    Function_Return APIColumnsEmpty
89794>>>>>>>                End
89794>>>>>>>>
89794>>>>>>>            End                                    
89794>>>>>>>>
89794>>>>>>>        End
89794>>>>>>>>
89794>>>>>>>        
89794>>>>>>>        Move 0 to iCount
89795>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89798>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
89799>>>>>>>        
89799>>>>>>>        for iColumn from 1 to iNumColumns
89805>>>>>>>>
89805>>>>>>>            Move 0 to iOptions       
89806>>>>>>>            Move False to bIdentityKey         
89807>>>>>>>            Move False to Err
89808>>>>>>>            Move 0     to LastErr     
89809>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
89810>>>>>>>            Set piPosition of ghoProgressBar to iColumn
89811>>>>>>>            If (bDawSqlDriver = True) Begin
89813>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE   
89814>>>>>>>                If (bIsSqlTable = True) Begin
89816>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
89819>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
89822>>>>>>>                End
89822>>>>>>>>
89822>>>>>>>                Else Begin
89823>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType 
89826>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
89827>>>>>>>                End
89827>>>>>>>>
89827>>>>>>>                
89827>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
89827>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
89830>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
89831>>>>>>>                If (bExists = False) Begin
89833>>>>>>>                    Move 0 to APIColumns[iCount].iType
89834>>>>>>>                End
89834>>>>>>>>
89834>>>>>>>                If (bExists = True) Begin
89836>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey                
89839>>>>>>>                End
89839>>>>>>>>
89839>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89840>>>>>>>                If (bIdentityKey = True) Begin
89842>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
89843>>>>>>>                End
89843>>>>>>>>
89843>>>>>>>            End
89843>>>>>>>>
89843>>>>>>>            Else Begin
89844>>>>>>>                Move False to Err
89845>>>>>>>                Move 0     to LastErr
89846>>>>>>>                If (bIsSqlTable = True) Begin
89848>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
89851>>>>>>>                End
89851>>>>>>>>
89851>>>>>>>                Else Begin
89852>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
89855>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
89856>>>>>>>                End
89856>>>>>>>>
89856>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
89856>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists           
89857>>>>>>>                If (bExists = False) Begin
89859>>>>>>>                    Move 0 to APIColumns[iCount].iType
89860>>>>>>>                End
89860>>>>>>>>
89860>>>>>>>            End
89860>>>>>>>>
89860>>>>>>>            
89860>>>>>>>            If (bExists = True) Begin                                                          
89862>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
89863>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
89866>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems. 
89866>>>>>>>//                If (bIsSqlTable = True) Begin
89866>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
89866>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
89866>>>>>>>//                End
89866>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
89869>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
89872>>>>>>>                
89872>>>>>>>                // If the length was zero we might have an Overlap(!) field.
89872>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
89872>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
89874>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
89877>>>>>>>                    If (iType = DF_OVERLAP) Begin
89879>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
89880>>>>>>>                        Move 0 to APIColumns[iCount].iLength
89881>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
89882>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
89883>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
89884>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
89885>>>>>>>                        Decrement iCount
89886>>>>>>>                    End                                                          
89886>>>>>>>>
89886>>>>>>>                End
89886>>>>>>>>
89886>>>>>>>            End
89886>>>>>>>>
89886>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89887>>>>>>>            If (bUserCancel = True) Begin
89889>>>>>>>                Send Stop_StatusPanel of ghoStatusPanel
89890>>>>>>>                Send Info_Box "Process interrupted..."
89891>>>>>>>                Function_Return APIColumnsEmpty
89892>>>>>>>            End
89892>>>>>>>>
89892>>>>>>>            Increment iCount
89893>>>>>>>        Loop
89894>>>>>>>>
89894>>>>>>>        
89894>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89895>>>>>>>        Function_Return APIColumns                          
89896>>>>>>>    End_Function        
89897>>>>>>>    
89897>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
89899>>>>>>>        tAPIIndex[] APIIndexes
89899>>>>>>>        tAPIIndex[] APIIndexes
89900>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn iIndexType iCase
89900>>>>>>>        String sDriverID
89900>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsPrimaryKey
89900>>>>>>>        
89900>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89901>>>>>>>        Get psDriverID to sDriverID
89902>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver 
89903>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
89904>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89907>>>>>>>        If (bIsOpen = False) Begin
89909>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89910>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89911>>>>>>>            Open hTable
89913>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89914>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89915>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89918>>>>>>>            If (bIsOpen = False) Begin
89920>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89921>>>>>>>                Function_Return APIIndexes
89922>>>>>>>            End
89922>>>>>>>>
89922>>>>>>>        End
89922>>>>>>>>
89922>>>>>>>        
89922>>>>>>>        Move 0 to iCount
89923>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
89926>>>>>>>        for iIndex from 1 to iIndexes                                              
89932>>>>>>>>
89932>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
89932>>>>>>>            // numbers doesn not need to be consequitive:
89932>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89935>>>>>>>            If (iNumSegments > 0) Begin
89937>>>>>>>            
89937>>>>>>>                Move iIndex to APIIndexes[iCount].iIndexNumber    
89938>>>>>>>                If (bIsSQLTable = True) Begin
89940>>>>>>>                    Get_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndexes[iCount].sSQLIndexName
89943>>>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89946>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsPrimaryKey
89949>>>>>>>                End
89949>>>>>>>>
89949>>>>>>>    
89949>>>>>>>                Move 0 to iSegmentCount
89950>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments       
89953>>>>>>>                for iSegment from 1 to iNumSegments     
89959>>>>>>>>
89959>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
89962>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
89963>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
89966>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
89969>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
89972>>>>>>>                    Increment iSegmentCount
89973>>>>>>>                Loop                                                                                       
89974>>>>>>>>
89974>>>>>>>            End
89974>>>>>>>>
89974>>>>>>>    
89974>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89975>>>>>>>            Increment iCount
89976>>>>>>>        Loop                              
89977>>>>>>>>
89977>>>>>>>        
89977>>>>>>>        Function_Return APIIndexes
89978>>>>>>>    End_Function
89979>>>>>>>    
89979>>>>>>>    Function UtilRelationStructFill Handle hTable Returns tAPIRelation[]
89981>>>>>>>        tAPIRelation[] APIRelations
89981>>>>>>>        tAPIRelation[] APIRelations
89982>>>>>>>        Integer iColumn iNumColumns iCount
89982>>>>>>>        Handle hParent 
89982>>>>>>>        Boolean bIsOpen
89982>>>>>>>        
89982>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89983>>>>>>>        Move 0 to iCount
89984>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89987>>>>>>>        If (bIsOpen = False) Begin
89989>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89990>>>>>>>            Open hTable
89992>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89993>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89996>>>>>>>            If (bIsOpen = False) Begin
89998>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89999>>>>>>>                Function_Return APIRelations
90000>>>>>>>            End
90000>>>>>>>>
90000>>>>>>>        End
90000>>>>>>>>
90000>>>>>>>
90000>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90003>>>>>>>        For iColumn from 1 to iNumColumns
90009>>>>>>>>
90009>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
90012>>>>>>>            If (hParent <> 0) Begin
90014>>>>>>>                Move (String(hTable))  to APIRelations[iCount].hTableFrom
90015>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APIRelations[iCount].sLogicalNameFrom
90018>>>>>>>                Move (String(iColumn)) to APIRelations[iCount].iColumnFrom                          
90019>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to APIRelations[iCount].sFieldNameFrom
90022>>>>>>>
90022>>>>>>>                Move (String(hParent)) to APIRelations[iCount].hTableTo
90023>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent to APIRelations[iCount].sLogicalNameTo
90026>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to APIRelations[iCount].iColumnTo
90029>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable APIRelations[iCount].iColumnTo to APIRelations[iCount].sFieldNameTo
90032>>>>>>>                Increment iCount
90033>>>>>>>            End         
90033>>>>>>>>
90033>>>>>>>        Loop                                                    
90034>>>>>>>>
90034>>>>>>>        
90034>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90035>>>>>>>        Function_Return APIRelations
90036>>>>>>>    End_Function
90037>>>>>>>    
90037>>>>>>>    // Checks if a field name exists in a table definition
90037>>>>>>>    // Returns True if it does
90037>>>>>>>    // Sample:
90037>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90037>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90039>>>>>>>        Integer iNumColumns iColumn
90039>>>>>>>        String sColumn
90039>>>>>>>        Boolean bExists bOK bOpen
90039>>>>>>>
90039>>>>>>>        Get AutoConnectionIDLogin to bOK
90040>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90041>>>>>>>        Open hTable
90043>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90044>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90047>>>>>>>        If (bOpen = False) Begin
90049>>>>>>>            Function_Return False
90050>>>>>>>        End
90050>>>>>>>>
90050>>>>>>>
90050>>>>>>>        Move False to bExists
90051>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90054>>>>>>>        for iColumn from 1 to iNumColumns
90060>>>>>>>>
90060>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90063>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90065>>>>>>>                Move iNumColumns to iColumn
90066>>>>>>>                Move True to bExists
90067>>>>>>>            End
90067>>>>>>>>
90067>>>>>>>        Loop
90068>>>>>>>>
90068>>>>>>>        Close hTable
90069>>>>>>>
90069>>>>>>>        Function_Return bExists
90070>>>>>>>    End_Function
90071>>>>>>>    
90071>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
90071>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90073>>>>>>>        Integer iNumColumns iColumn iRetval
90073>>>>>>>        String sColumn
90073>>>>>>>        Boolean bExists bOK bOpen
90073>>>>>>>
90073>>>>>>>        Get AutoConnectionIDLogin to bOK
90074>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90075>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90076>>>>>>>        Open hTable
90078>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90079>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90082>>>>>>>        If (bOpen = False) Begin
90084>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90085>>>>>>>            Function_Return False
90086>>>>>>>        End
90086>>>>>>>>
90086>>>>>>>        
90086>>>>>>>        Move 0 to iColumn                  
90087>>>>>>>        Move 0 to iRetval
90088>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90091>>>>>>>        for iColumn from 1 to iNumColumns
90097>>>>>>>>
90097>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90100>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90102>>>>>>>                Move iColumn to iRetval
90103>>>>>>>                Move iNumColumns to iColumn
90104>>>>>>>            End
90104>>>>>>>>
90104>>>>>>>        Loop
90105>>>>>>>>
90105>>>>>>>        Close hTable
90106>>>>>>>
90106>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90107>>>>>>>        Function_Return iRetval
90108>>>>>>>    End_Function
90109>>>>>>>
90109>>>>>>>    // Checks if the current psConnectionID is logged in; if not
90109>>>>>>>    // attempts to make a login.
90109>>>>>>>    // Because
90109>>>>>>>    // Returns True if already logged in or the new login was successful.
90109>>>>>>>    // *** Utility Messages ***
90109>>>>>>>    //
90109>>>>>>>    //
90109>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
90109>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
90109>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
90109>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
90111>>>>>>>        Boolean bError bFound
90111>>>>>>>
90111>>>>>>>        Move False to Err
90112>>>>>>>        Open CodeMast
90114>>>>>>>        Open CodeType
90116>>>>>>>
90116>>>>>>>        If (bCodeType = True) Begin
90118>>>>>>>            Clear CodeType
90119>>>>>>>            Move sTypeValue to CODETYPE.Type
90120>>>>>>>            Find eq CODETYPE.Type
90121>>>>>>>>
90121>>>>>>>            Move (Found = True) to bFound
90122>>>>>>>            If (bFound = True) Begin
90124>>>>>>>                Reread CodeType
90128>>>>>>>            End
90128>>>>>>>>
90128>>>>>>>            If (bFound = False) Begin
90130>>>>>>>                Clear CodeType
90131>>>>>>>            End
90131>>>>>>>>
90131>>>>>>>                Move sTypeValue to CODETYPE.Type
90132>>>>>>>                Move sValue2    to CODETYPE.Description
90133>>>>>>>                Move sValue3    to CODETYPE.Comment
90134>>>>>>>                SaveRecord CODETYPE
90135>>>>>>>            If (bFound = True) Begin
90137>>>>>>>                Unlock
90138>>>>>>>>
90138>>>>>>>            End
90138>>>>>>>>
90138>>>>>>>        End
90138>>>>>>>>
90138>>>>>>>
90138>>>>>>>        If (bCodeType = False) Begin
90140>>>>>>>            Clear CODEMAST
90141>>>>>>>            Move sTypeValue to CODEMAST.Type
90142>>>>>>>            Move sValue2    to CODEMAST.Code
90143>>>>>>>            Find eq CODEMAST.Code
90144>>>>>>>>
90144>>>>>>>            Move (Found = True) to bFound
90145>>>>>>>            If (bFound = True) Begin
90147>>>>>>>                Reread CODEMAST
90151>>>>>>>            End
90151>>>>>>>>
90151>>>>>>>            If (bFound = False) Begin
90153>>>>>>>                Clear CODEMAST
90154>>>>>>>            End
90154>>>>>>>>
90154>>>>>>>                Move sTypeValue to CODEMAST.Type
90155>>>>>>>                Move sValue2    to CODEMAST.Code
90156>>>>>>>                Move sValue3    to CODEMAST.Description
90157>>>>>>>                SaveRecord CODEMAST
90158>>>>>>>            If (bFound = True) Begin
90160>>>>>>>            Unlock
90161>>>>>>>>
90161>>>>>>>            End
90161>>>>>>>>
90161>>>>>>>        End
90161>>>>>>>>
90161>>>>>>>
90161>>>>>>>        Close CodeMast
90162>>>>>>>        Close CodeType
90163>>>>>>>
90163>>>>>>>        Function_Return (Err = False)
90164>>>>>>>    End_Function
90165>>>>>>>
90165>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
90165>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
90165>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
90167>>>>>>>        Boolean bFound
90167>>>>>>>
90167>>>>>>>        Move False to Err
90168>>>>>>>        Open CodeMast
90170>>>>>>>        Open CodeType
90172>>>>>>>
90172>>>>>>>        Clear CodeType
90173>>>>>>>        Move sFromValue to CODETYPE.Type
90174>>>>>>>        Find eq CODETYPE.Type
90175>>>>>>>>
90175>>>>>>>        If (Found = True) Begin
90177>>>>>>>            Reread CODETYPE
90181>>>>>>>                Move sToValue to CODETYPE.Type
90182>>>>>>>                SaveRecord CODETYPE
90183>>>>>>>            Unlock
90184>>>>>>>>
90184>>>>>>>        End
90184>>>>>>>>
90184>>>>>>>
90184>>>>>>>        Clear CODEMAST
90185>>>>>>>        Find gt CODEMAST by Recnum
90186>>>>>>>>
90186>>>>>>>        While (Found = True)
90190>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
90191>>>>>>>            If (bFound = True) Begin
90193>>>>>>>                Reread CODEMAST
90197>>>>>>>                    Move sToValue to CODEMAST.Type
90198>>>>>>>                    SaveRecord CODEMAST
90199>>>>>>>                Unlock
90200>>>>>>>>
90200>>>>>>>            End
90200>>>>>>>>
90200>>>>>>>            Find gt CODEMAST by Recnum
90201>>>>>>>>
90201>>>>>>>        Loop
90202>>>>>>>>
90202>>>>>>>
90202>>>>>>>        Close CodeMast
90203>>>>>>>        Close CodeType
90204>>>>>>>
90204>>>>>>>        Function_Return (Err = False)
90205>>>>>>>    End_Function
90206>>>>>>>
90206>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
90206>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
90208>>>>>>>        Boolean bError bFound
90208>>>>>>>
90208>>>>>>>        Move False to Err
90209>>>>>>>        Open CodeMast
90211>>>>>>>
90211>>>>>>>        Clear CODEMAST
90212>>>>>>>        Move sTypeValue to CODEMAST.Type
90213>>>>>>>        Move sValue2    to CODEMAST.Code
90214>>>>>>>        Find eq CODEMAST.Code
90215>>>>>>>>
90215>>>>>>>        Move (Found = True) to bFound
90216>>>>>>>        If (bFound = True) Begin
90218>>>>>>>            Delete CODEMAST
90219>>>>>>>        End
90219>>>>>>>>
90219>>>>>>>
90219>>>>>>>        Close CodeMast
90220>>>>>>>
90220>>>>>>>        Function_Return (Err = False)
90221>>>>>>>    End_Function
90222>>>>>>>
90222>>>>>>>    // Note:
90222>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90222>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90222>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90222>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90222>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90222>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90224>>>>>>>        String sTableName
90224>>>>>>>        Boolean bOpen bExists bRecnum bOK
90224>>>>>>>
90224>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
90225>>>>>>>        If (bExists = False) Begin
90227>>>>>>>            Function_Return ""
90228>>>>>>>        End
90228>>>>>>>>
90228>>>>>>>
90228>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90229>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90232>>>>>>>        If (bOpen = False) Begin
90234>>>>>>>            Get AutoConnectionIDLogin to bOK
90235>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90236>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90237>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90238>>>>>>>            Open hTable
90240>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90241>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90242>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90243>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90246>>>>>>>        End
90246>>>>>>>>
90246>>>>>>>        If (bOpen = True) Begin
90248>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90249>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90252>>>>>>>            // If blank it is an embedded table:
90252>>>>>>>            If (sTableName = "") Begin
90254>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90257>>>>>>>                Move 0 to LastErr
90258>>>>>>>                Move False to Err
90259>>>>>>>            End
90259>>>>>>>>
90259>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90260>>>>>>>        End
90260>>>>>>>>
90260>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90261>>>>>>>
90261>>>>>>>        Function_Return sTableName
90262>>>>>>>    End_Function
90263>>>>>>>
90263>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90263>>>>>>>    // Returns 0 if unsuccessful.
90263>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90263>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90265>>>>>>>        String sValue sPrefixTableName sDriverID
90265>>>>>>>        Handle hTable hRetval
90265>>>>>>>
90265>>>>>>>        Get psDriverID to sDriverID
90266>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90268>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90269>>>>>>>        End
90269>>>>>>>>
90269>>>>>>>        Move 0 to hTable
90270>>>>>>>        Move 0 to hRetval
90271>>>>>>>        Repeat
90271>>>>>>>>
90271>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90274>>>>>>>            If (hTable <> 0) Begin
90276>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90279>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90281>>>>>>>                    Move hTable to hRetval
90282>>>>>>>                    Move 0 to hTable
90283>>>>>>>                End
90283>>>>>>>>
90283>>>>>>>            End
90283>>>>>>>>
90283>>>>>>>        Until (hTable = 0)
90285>>>>>>>
90285>>>>>>>        Function_Return hRetval
90286>>>>>>>    End_Function
90287>>>>>>>
90287>>>>>>>    // Check if the file exists in the Data folder,
90287>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
90287>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
90289>>>>>>>        String sPath sDataPath
90289>>>>>>>        Boolean bExists
90289>>>>>>>
90289>>>>>>>        Get psDataPathFirstPart to sPath
90290>>>>>>>        Move (sPath + sFileName) to sFileName
90291>>>>>>>        Get vFilePathExists sFileName to bExists
90292>>>>>>>
90292>>>>>>>        If (bExists = False) Begin
90294>>>>>>>            // Read from memory & create file on disk.
90294>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
90295>>>>>>>            Get vFilePathExists sFileName to bExists
90296>>>>>>>        End
90296>>>>>>>>
90296>>>>>>>        Function_Return bExists
90297>>>>>>>    End_Function
90298>>>>>>>
90298>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90298>>>>>>>    // The reciprocal function of UtilColumnTypeToInteger.
90298>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90300>>>>>>>        tColumnType RetvalType
90300>>>>>>>        tColumnType RetvalType
90300>>>>>>>
90300>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90301>>>>>>>        Function_Return RetvalType.iType
90302>>>>>>>    End_Function
90303>>>>>>>
90303>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90303>>>>>>>    // The reciprocal function of UtilColumnTypeToString.
90303>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90305>>>>>>>        tColumnType RetvalType
90305>>>>>>>        tColumnType RetvalType
90305>>>>>>>        String sValue
90305>>>>>>>
90305>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90306>>>>>>>        Function_Return RetvalType.sType
90307>>>>>>>    End_Function
90308>>>>>>>
90308>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
90310>>>>>>>        tColumnType RetvalType 
90310>>>>>>>        tColumnType RetvalType 
90310>>>>>>>        Integer iRetval
90310>>>>>>>        
90310>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90311>>>>>>>        Move RetvalType.iDataFlexType to iRetval
90312>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
90314>>>>>>>            If (iLength <= 255) Begin
90316>>>>>>>                Move DF_ASCII to iRetval
90317>>>>>>>            End
90317>>>>>>>>
90317>>>>>>>        End                             
90317>>>>>>>>
90317>>>>>>>        Function_Return iRetval
90318>>>>>>>    End_Function
90319>>>>>>>
90319>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90321>>>>>>>        tColumnType RetvalType
90321>>>>>>>        tColumnType RetvalType
90321>>>>>>>        String sValue
90321>>>>>>>
90321>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90322>>>>>>>        Function_Return RetvalType.sPrecision
90323>>>>>>>    End_Function
90324>>>>>>>
90324>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90326>>>>>>>        tColumnType RetvalType
90326>>>>>>>        tColumnType RetvalType
90326>>>>>>>        String sValue
90326>>>>>>>
90326>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90327>>>>>>>        Function_Return RetvalType.bFixedSize
90328>>>>>>>    End_Function
90329>>>>>>>
90329>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90331>>>>>>>        tColumnType RetvalType
90331>>>>>>>        tColumnType RetvalType
90331>>>>>>>        String sValue
90331>>>>>>>        Integer iRetval iPos
90331>>>>>>>
90331>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90332>>>>>>>        Move RetvalType.sPrecision to sValue
90333>>>>>>>        Move (Pos(".", sValue)) to iPos
90334>>>>>>>        If (iPos <> 0) Begin
90336>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
90337>>>>>>>        End
90337>>>>>>>>
90337>>>>>>>        Else Begin
90338>>>>>>>            Move sValue to iRetval
90339>>>>>>>        End
90339>>>>>>>>
90339>>>>>>>        Function_Return iRetval
90340>>>>>>>    End_Function
90341>>>>>>>
90341>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90343>>>>>>>        tColumnType RetvalType
90343>>>>>>>        tColumnType RetvalType
90343>>>>>>>        String sValue
90343>>>>>>>        Integer iRetval iPos
90343>>>>>>>
90343>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90344>>>>>>>        Move RetvalType.sPrecision to sValue
90345>>>>>>>        Move (Pos(".", sValue)) to iPos
90346>>>>>>>        If (iPos = 0) Begin
90348>>>>>>>            Function_Return 0
90349>>>>>>>        End
90349>>>>>>>>
90349>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90350>>>>>>>
90350>>>>>>>        Function_Return iRetval
90351>>>>>>>    End_Function
90352>>>>>>>
90352>>>>>>>    // The default value used for a datatype as specified in the driver int file.
90352>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
90354>>>>>>>        String sRetval sServer
90354>>>>>>>        tColumnType RetvalType
90354>>>>>>>        tColumnType RetvalType
90354>>>>>>>        Integer iDriver iDataFlexType
90354>>>>>>>        Handle hDatabase
90354>>>>>>>
90354>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90355>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
90356>>>>>>>        Get DriverIndex sDriverID to iDriver
90357>>>>>>>        Get psServer to sServer
90358>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
90359>>>>>>>        If (hDatabase = 0) Begin
90361>>>>>>>            Function_Return ""
90362>>>>>>>        End
90362>>>>>>>>
90362>>>>>>>
90362>>>>>>>        Case Begin
90362>>>>>>>            Case (iDataFlexType = DF_ASCII)
90364>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
90367>>>>>>>                Case Break
90368>>>>>>>            Case (iDataFlexType = DF_BCD)
90371>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
90374>>>>>>>                Case Break
90375>>>>>>>            Case (iDataFlexType = DF_BINARY)
90378>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
90381>>>>>>>                Case Break
90382>>>>>>>            Case (iDataFlexType = DF_DATE)
90385>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
90388>>>>>>>                Case Break
90389>>>>>>>            Case (iDataFlexType = DF_DATETIME)
90392>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
90395>>>>>>>                Case Break
90396>>>>>>>            Case (iDataFlexType = DF_TEXT)
90399>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
90402>>>>>>>                Case Break
90403>>>>>>>            Case Else
90403>>>>>>>                Move "" to sRetval
90404>>>>>>>        Case End
90404>>>>>>>
90404>>>>>>>        Function_Return sRetval
90405>>>>>>>    End_Function 
90406>>>>>>>    
90406>>>>>>>    Procedure Set DF_DATABASE_DEFAULT_DEFAULT_DATE_DUF String sDateValue
90408>>>>>>>        String sDriverID sRetval sServer
90408>>>>>>>        tColumnType RetvalType
90408>>>>>>>        tColumnType RetvalType
90408>>>>>>>        Integer iDbType iDriver iDataFlexType
90408>>>>>>>        Handle hDatabase
90408>>>>>>>        
90408>>>>>>>        Get psDriverID to sDriverID
90409>>>>>>>        Get piDbType   to iDbType
90410>>>>>>>        Get DriverIndex sDriverID to iDriver
90411>>>>>>>        Get psServer to sServer
90412>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
90413>>>>>>>        If (hDatabase = 0) Begin
90415>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database."
90416>>>>>>>>
90416>>>>>>>            Procedure_Return
90417>>>>>>>        End                      
90417>>>>>>>>
90417>>>>>>>        
90417>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
90420>>>>>>>
90420>>>>>>>    End_Procedure
90421>>>>>>>
90421>>>>>>>    Procedure Set DF_DATABASE_DEFAULT_DEFAULT_DATETIME_DUF String sDateValue
90423>>>>>>>        String sDriverID sRetval sServer
90423>>>>>>>        tColumnType RetvalType
90423>>>>>>>        tColumnType RetvalType
90423>>>>>>>        Integer iDbType iDriver iDataFlexType
90423>>>>>>>        Handle hDatabase
90423>>>>>>>        
90423>>>>>>>        Get psDriverID to sDriverID
90424>>>>>>>        Get piDbType   to iDbType
90425>>>>>>>        Get DriverIndex sDriverID to iDriver
90426>>>>>>>        Get psServer to sServer
90427>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
90428>>>>>>>        If (hDatabase = 0) Begin
90430>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
90431>>>>>>>>
90431>>>>>>>            Procedure_Return
90432>>>>>>>        End                      
90432>>>>>>>>
90432>>>>>>>        
90432>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
90435>>>>>>>
90435>>>>>>>    End_Procedure
90436>>>>>>>
90436>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
90436>>>>>>>    // are mapped to the standard DataFlex data types.
90436>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
90436>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
90438>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
90438>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
90440>>>>>>>        String sDataType
90440>>>>>>>        Integer iDataType iDriverID iCount  
90440>>>>>>>        Boolean bSQLDriver
90440>>>>>>>
90440>>>>>>>        Move 0 to iCount
90441>>>>>>>        Get DriverIndex sDriverID to iDriverID
90442>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
90443>>>>>>>        If (bSQLDriver = False) Begin
90445>>>>>>>            Function_Return EmptyArray
90446>>>>>>>        End
90446>>>>>>>>
90446>>>>>>>
90446>>>>>>>        // DF_ASCII
90446>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
90448>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
90451>>>>>>>        End
90451>>>>>>>>
90451>>>>>>>        Else Begin
90452>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
90455>>>>>>>        End
90455>>>>>>>>
90455>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90456>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
90457>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
90458>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90459>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90460>>>>>>>        Increment iCount
90461>>>>>>>
90461>>>>>>>        // DF_BINARY
90461>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
90463>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
90466>>>>>>>        End
90466>>>>>>>>
90466>>>>>>>        Else Begin
90467>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
90470>>>>>>>        End
90470>>>>>>>>
90470>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90471>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
90472>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
90473>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90474>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90475>>>>>>>        Increment iCount
90476>>>>>>>
90476>>>>>>>        // DF_DATE
90476>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
90478>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
90481>>>>>>>        End
90481>>>>>>>>
90481>>>>>>>        Else Begin
90482>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
90485>>>>>>>        End
90485>>>>>>>>
90485>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90486>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
90487>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
90488>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90489>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90490>>>>>>>        Increment iCount
90491>>>>>>>
90491>>>>>>>        // DF_DATETIME
90491>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
90493>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
90496>>>>>>>        End
90496>>>>>>>>
90496>>>>>>>        Else Begin
90497>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
90500>>>>>>>        End
90500>>>>>>>>
90500>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90501>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
90502>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
90503>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90504>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90505>>>>>>>        Increment iCount
90506>>>>>>>
90506>>>>>>>        // DF_NUMERIC
90506>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
90506>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
90506>>>>>>>        // we make them here all "Numeric"... 
90506>>>>>>>        Case Begin
90506>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90508>>>>>>>                Move SQL_NUMERIC to iDataType 
90509>>>>>>>                Move "numeric"   to sDataType
90510>>>>>>>                Case Break
90511>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90514>>>>>>>                Move SQL_NUMERIC to iDataType
90515>>>>>>>                Move "NUMERIC"   to sDataType
90516>>>>>>>                Case Break                   
90517>>>>>>>            Case (sDriverID = SQLFLEX)
90520>>>>>>>                Move eSQLServer_NUMERIC to iDataType
90521>>>>>>>                Move "numeric"   to sDataType
90522>>>>>>>                Case Break                   
90523>>>>>>>            Case (sDriverID = MDSMySQL)
90526>>>>>>>                Move eMySQL_DECIMAL to iDataType
90527>>>>>>>                Move "decimal"   to sDataType
90528>>>>>>>                Case Break       
90529>>>>>>>            Case (sDriverID = ORAFLEX)
90532>>>>>>>                Move eOracle_NUMBER to iDataType
90533>>>>>>>                Move "NUMBER"   to sDataType
90534>>>>>>>                Case Break       
90535>>>>>>>            Case (sDriverID = MDSPgSQL)
90538>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
90539>>>>>>>                Move "decimal"   to sDataType
90540>>>>>>>                Case Break       
90541>>>>>>>            Case Else
90541>>>>>>>                Move DF_BCD      to iDataType
90542>>>>>>>                Move "Numeric"   to sDataType
90543>>>>>>>        Case End
90543>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
90544>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
90545>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90546>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90547>>>>>>>        Increment iCount
90548>>>>>>>
90548>>>>>>>        // DF_TEXT
90548>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
90550>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
90553>>>>>>>        End
90553>>>>>>>>
90553>>>>>>>        Else Begin
90554>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
90557>>>>>>>        End
90557>>>>>>>>
90557>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90558>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
90559>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
90560>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90561>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90562>>>>>>>
90562>>>>>>>        Function_Return ColumnTypeArray
90563>>>>>>>    End_Function 
90564>>>>>>>    
90564>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
90566>>>>>>>        tColumnType[] ColumnTypeArray
90566>>>>>>>        tColumnType[] ColumnTypeArray
90567>>>>>>>        tColumnType   ColumnType 
90567>>>>>>>        tColumnType   ColumnType 
90567>>>>>>>        Integer iCount iSize
90567>>>>>>>        
90567>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
90568>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
90569>>>>>>>        Decrement iSize
90570>>>>>>>        
90570>>>>>>>        for iCount from 0 to iSize
90576>>>>>>>>
90576>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
90578>>>>>>>                Move ColumnTypeArray[iCount].bFixedSize     to ColumnType.bFixedSize
90579>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
90580>>>>>>>                Move ColumnTypeArray[iCount].iType          to ColumnType.iType
90581>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
90582>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
90583>>>>>>>                Move ColumnTypeArray[iCount].sType          to ColumnType.sType
90584>>>>>>>                Move iSize to iCount
90585>>>>>>>            End
90585>>>>>>>>
90585>>>>>>>        Loop
90586>>>>>>>>
90586>>>>>>>        
90586>>>>>>>        Function_Return ColumnType
90587>>>>>>>    End_Function
90588>>>>>>>
90588>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
90588>>>>>>>    // are mapped to a framework DataFlex data type.
90588>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
90590>>>>>>>        tColumnType ColumnType
90590>>>>>>>        tColumnType ColumnType
90590>>>>>>>        String sDataType
90590>>>>>>>        Integer iDriverID iDataType iCount
90590>>>>>>>
90590>>>>>>>        Move 0 to iCount
90591>>>>>>>        Get DriverIndex sDriverID to iDriverID
90592>>>>>>>            
90592>>>>>>>        Case Begin
90592>>>>>>>            // DF_ASCII
90592>>>>>>>            Case (iType = DF_ASCII_DUF)
90594>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
90596>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
90599>>>>>>>                End
90599>>>>>>>>
90599>>>>>>>                Else Begin
90600>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType 
90603>>>>>>>                End
90603>>>>>>>>
90603>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
90604>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
90605>>>>>>>                Move sDataType   to ColumnType.sType
90606>>>>>>>                Move DF_ASCII    to ColumnType.iType
90607>>>>>>>                Move False       to ColumnType.bFixedSize
90608>>>>>>>                Case Break
90609>>>>>>>                
90609>>>>>>>            // DF_BINARY
90609>>>>>>>            Case (iType = DF_BINARY_DUF)
90612>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
90614>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
90617>>>>>>>                End
90617>>>>>>>>
90617>>>>>>>                Else Begin
90618>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
90621>>>>>>>                End
90621>>>>>>>>
90621>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
90622>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
90623>>>>>>>                Move sDataType   to ColumnType.sType
90624>>>>>>>                Move DF_BINARY   to ColumnType.iType
90625>>>>>>>                Move False       to ColumnType.bFixedSize
90626>>>>>>>                Case Break
90627>>>>>>>    
90627>>>>>>>            // DF_DATE
90627>>>>>>>            Case (iType = DF_DATE_DUF)
90630>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
90632>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
90635>>>>>>>                End
90635>>>>>>>>
90635>>>>>>>                Else Begin
90636>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
90639>>>>>>>                End
90639>>>>>>>>
90639>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
90640>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
90641>>>>>>>                Move sDataType   to ColumnType.sType
90642>>>>>>>                Move DF_DATE     to ColumnType.iType
90643>>>>>>>                Move True        to ColumnType.bFixedSize
90644>>>>>>>                Case Break
90645>>>>>>>    
90645>>>>>>>            // DF_DATETIME       
90645>>>>>>>            Case (iType = DF_DATETIME_DUF)
90648>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
90650>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
90653>>>>>>>                End
90653>>>>>>>>
90653>>>>>>>                Else Begin
90654>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
90657>>>>>>>                End
90657>>>>>>>>
90657>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
90658>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
90659>>>>>>>                Move sDataType   to ColumnType.sType
90660>>>>>>>                Move DF_DATETIME to ColumnType.iType
90661>>>>>>>                Move True        to ColumnType.bFixedSize
90662>>>>>>>                Case Break
90663>>>>>>>    
90663>>>>>>>            // DF_NUMERIC
90663>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
90663>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
90663>>>>>>>            // we make them here all "Numeric"...
90663>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
90663>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
90663>>>>>>>            // End
90663>>>>>>>            // Else Begin
90663>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
90663>>>>>>>            // End 
90663>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
90663>>>>>>>            Case (iType = DF_BCD_DUF)
90666>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
90667>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
90668>>>>>>>                Move "Numeric"   to ColumnType.sType
90669>>>>>>>                Move SQL_NUMERIC to ColumnType.iType
90670>>>>>>>                Move False       to ColumnType.bFixedSize
90671>>>>>>>                Case Break
90672>>>>>>>                
90672>>>>>>>            // DF_TEXT
90672>>>>>>>            Case (iType = DF_TEXT_DUF)
90675>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
90677>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
90680>>>>>>>                End
90680>>>>>>>>
90680>>>>>>>                Else Begin
90681>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
90684>>>>>>>                End
90684>>>>>>>>
90684>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
90685>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
90686>>>>>>>                Move sDataType   to ColumnType.sType
90687>>>>>>>                Move DF_TEXT     to ColumnType.iType
90688>>>>>>>                Move False       to ColumnType.bFixedSize
90689>>>>>>>                Case Break
90690>>>>>>>                
90690>>>>>>>            Case Else
90690>>>>>>>                Move -1999       to ColumnType.iDataFlexType
90691>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
90692>>>>>>>                Move "Undefined" to ColumnType.sType
90693>>>>>>>                Move -1999       to ColumnType.iType
90694>>>>>>>                Move True        to ColumnType.bFixedSize
90695>>>>>>>
90695>>>>>>>        Case End
90695>>>>>>>
90695>>>>>>>        Function_Return ColumnType
90696>>>>>>>    End_Function
90697>>>>>>>
90697>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
90699>>>>>>>        String sDataPath sDriverID
90699>>>>>>>        Boolean bMertechDriver bOK
90699>>>>>>>        Integer iPos
90699>>>>>>>
90699>>>>>>>        If (sTableName contains ".") Begin
90701>>>>>>>            Move (Pos(".", sTableName)) to iPos
90702>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
90703>>>>>>>        End
90703>>>>>>>>
90703>>>>>>>
90703>>>>>>>        Get psDriverID to sDriverID
90704>>>>>>>        Get psDataPathFirstPart to sDataPath
90705>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
90706>>>>>>>        // First delete the cache file:
90706>>>>>>>        If (bMertechDriver = False) Begin
90708>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
90709>>>>>>>        End
90709>>>>>>>>
90709>>>>>>>        Else Begin
90710>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
90711>>>>>>>        End
90711>>>>>>>>
90711>>>>>>>
90711>>>>>>>        Function_Return bOK
90712>>>>>>>    End_Function
90713>>>>>>>
90713>>>>>>>    // Changes source code files.
90713>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
90713>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
90713>>>>>>>    // to use a Connection ID.
90713>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
90713>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
90713>>>>>>>    // Returns True if no errors occured.
90713>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
90715>>>>>>>        Integer iCh iRow iItems iCount
90715>>>>>>>        String sValue sRow
90715>>>>>>>        String[] sFileArray
90716>>>>>>>        Boolean bExists bIsActive
90716>>>>>>>
90716>>>>>>>        Move False to Err
90717>>>>>>>        Move 0 to iRow
90718>>>>>>>
90718>>>>>>>        If (ghoStatusPanel <> 0) Begin
90720>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
90721>>>>>>>        End
90721>>>>>>>>
90721>>>>>>>
90721>>>>>>>        Get vFilePathExists sFileName to bExists
90722>>>>>>>        If (bExists = False) Begin
90724>>>>>>>            If (bShowResult = True) Begin                  
90726>>>>>>>                If (bIsActive = True) Begin
90728>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
90729>>>>>>>                End 
90729>>>>>>>>
90729>>>>>>>                Else Begin
90730>>>>>>>                    Showln "File does not exist: " sFileName
90733>>>>>>>                End
90733>>>>>>>>
90733>>>>>>>            End
90733>>>>>>>>
90733>>>>>>>            Function_Return False
90734>>>>>>>        End
90734>>>>>>>>
90734>>>>>>>
90734>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
90735>>>>>>>        If (iCh < 1) Begin
90737>>>>>>>            Function_Return False
90738>>>>>>>        End
90738>>>>>>>>
90738>>>>>>>
90738>>>>>>>        If (bShowResult = True) Begin      
90740>>>>>>>            If (ghoStatusPanel <> 0) Begin
90742>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
90743>>>>>>>                If (bIsActive = True) Begin
90745>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
90746>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo)) 
90747>>>>>>>                    Send DoAdvance of ghoProgressBar
90748>>>>>>>                End
90748>>>>>>>>
90748>>>>>>>            End
90748>>>>>>>>
90748>>>>>>>            Else Begin
90749>>>>>>>                Showln ""
90751>>>>>>>                Showln "sFileName = " sFileName
90754>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
90759>>>>>>>            End
90759>>>>>>>>
90759>>>>>>>        End
90759>>>>>>>>
90759>>>>>>>
90759>>>>>>>        While (not(SeqEof))
90763>>>>>>>            Readln channel iCh sRow
90765>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
90767>>>>>>>//                If (bShowResult = True) Begin  
90767>>>>>>>//                    If (bIsActive = True) Begin
90767>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
90767>>>>>>>//                    End
90767>>>>>>>//                    Else Begin
90767>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
90767>>>>>>>//                    End
90767>>>>>>>//                End
90767>>>>>>>                // Change the whole line to the new connection id:
90767>>>>>>>                Move sChangeTo to sRow
90768>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
90768>>>>>>>            End
90768>>>>>>>>
90768>>>>>>>            Move sRow to sFileArray[iRow]
90769>>>>>>>            Increment iRow
90770>>>>>>>        End
90771>>>>>>>>
90771>>>>>>>        Send Seq_Close_Channel iCh
90772>>>>>>>
90772>>>>>>>        Sleep 1 // Wait for Windows to close the file
90773>>>>>>>
90773>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
90774>>>>>>>        If (iCh < 1) Begin
90776>>>>>>>            Function_Return False
90777>>>>>>>        End
90777>>>>>>>>
90777>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
90778>>>>>>>        Decrement iItems
90779>>>>>>>
90779>>>>>>>        For iCount from 0 to iItems
90785>>>>>>>>
90785>>>>>>>            Move sFileArray[iCount] to sValue
90786>>>>>>>            Writeln channel iCh sValue
90789>>>>>>>        Loop
90790>>>>>>>>
90790>>>>>>>        Send Seq_Close_Channel iCh
90791>>>>>>>
90791>>>>>>>        Function_Return (Err = False)
90792>>>>>>>    End_Function
90793>>>>>>>
90793>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
90793>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
90793>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
90793>>>>>>>    Function UtilCreateConnectionID String sConnectionID Returns Boolean
90795>>>>>>>        String sConnectionString sDriverID
90795>>>>>>>        Boolean bOK bSilent bDawDriver
90795>>>>>>>        Handle hoCLI
90795>>>>>>>
90795>>>>>>>        Move False to bOK
90796>>>>>>>        Get psDriverID to sDriverID
90797>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawDriver
90798>>>>>>>        If (bDawDriver = False) Begin
90800>>>>>>>            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
90801>>>>>>>>
90801>>>>>>>            Function_Return False
90802>>>>>>>        End
90802>>>>>>>>
90802>>>>>>>
90802>>>>>>>        Get psConnectionString to sConnectionString
90803>>>>>>>        Get pbSilentLogin      to bSilent
90804>>>>>>>
90804>>>>>>>        Get phoCLIHandler to hoCLI
90805>>>>>>>        If (hoCLI <> 0) Begin
90807>>>>>>>            Set psDriverID of hoCLI to sDriverID
90808>>>>>>>            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
90809>>>>>>>        End
90809>>>>>>>>
90809>>>>>>>
90809>>>>>>>        Function_Return (bOK = False)
90810>>>>>>>    End_Function
90811>>>>>>>
90811>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
90811>>>>>>>    // and opens it in "notepad.exe".
90811>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
90811>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
90811>>>>>>>    Procedure UtilShowErrorList
90813>>>>>>>        tSqlErrorArray aSqlErrorArray
90813>>>>>>>        tSqlErrorArray aSqlErrorArray
90813>>>>>>>        Integer iRows iCount iCh iErrorNum
90813>>>>>>>        String sPath sFileName sErrorTxt sStatement
90813>>>>>>>
90813>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
90814>>>>>>>        Get vFolderFormat sPath to sPath
90815>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
90816>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
90817>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
90818>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
90819>>>>>>>            If (iRows > 0) Begin
90821>>>>>>>                Decrement iRows
90822>>>>>>>                for iCount from 0 to iRows
90828>>>>>>>>
90828>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
90829>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
90830>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
90831>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
90837>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
90841>>>>>>>                Loop
90842>>>>>>>>
90842>>>>>>>            End
90842>>>>>>>>
90842>>>>>>>        Send Seq_Close_Channel iCh
90843>>>>>>>
90843>>>>>>>        If (iRows > 0) Begin
90845>>>>>>>            Runprogram Background "Notepad.exe" (sPath + sFileName)
90846>>>>>>>        End
90846>>>>>>>>
90846>>>>>>>    End_Procedure
90847>>>>>>>    
90847>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
90847>>>>>>>    // and the table needs to exist as an SQL table.
90847>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
90849>>>>>>>        String sRootName sLogicalName sDriverID
90849>>>>>>>        Boolean bIsSQL
90849>>>>>>>        
90849>>>>>>>        Move False to bIsSQL
90850>>>>>>>        If (hTable > 0) Begin
90852>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90855>>>>>>>            Move (sRootName contains ":") to bIsSQL
90856>>>>>>>            If (bIsSQL = True) Begin               
90858>>>>>>>                Get psDriverID to sDriverID
90859>>>>>>>                Get _TableNameOnly sRootName to sRootName
90860>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
90861>>>>>>>            End
90861>>>>>>>>
90861>>>>>>>        End
90861>>>>>>>>
90861>>>>>>>
90861>>>>>>>        Function_Return bIsSQL
90862>>>>>>>    End_Function
90863>>>>>>>
90863>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
90865>>>>>>>        Boolean bIsSQL
90865>>>>>>>        Move (sRootName contains ":") to bIsSQL
90866>>>>>>>        Function_Return bIsSQL
90867>>>>>>>    End_Function
90868>>>>>>>
90868>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
90868>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
90868>>>>>>>    // but the Logical name is different.
90868>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
90868>>>>>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
90868>>>>>>>//        String sPhysicalName sPhysicalNameCompare
90868>>>>>>>//        Boolean bWasOpen bOpened bOK
90868>>>>>>>//        Integer iCount 
90868>>>>>>>//        
90868>>>>>>>//        Move 0 to iCount    
90868>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
90868>>>>>>>//        If (bWasOpen = False) Begin
90868>>>>>>>//            Open hTable
90868>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
90868>>>>>>>//            If (bOpened = False) Begin
90868>>>>>>>//                Function_Return False
90868>>>>>>>//            End  
90868>>>>>>>//        End
90868>>>>>>>//        
90868>>>>>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
90868>>>>>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
90868>>>>>>>//        If (bWasOpen = False and bOpened = True) Begin
90868>>>>>>>//            Close hTable
90868>>>>>>>//        End
90868>>>>>>>//
90868>>>>>>>//        Move 0 to hTable
90868>>>>>>>//        Repeat
90868>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90868>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
90868>>>>>>>//                Open hTable
90868>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
90868>>>>>>>//                If (bOpened = True) Begin
90868>>>>>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
90868>>>>>>>//                    Close hTable
90868>>>>>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
90868>>>>>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
90868>>>>>>>//                        Increment iCount 
90868>>>>>>>//                    End
90868>>>>>>>//                End
90868>>>>>>>//            End
90868>>>>>>>//        Until (hTable = 0)
90868>>>>>>>//        
90868>>>>>>>//        If (iCount > 1) Begin
90868>>>>>>>//            Function_Return True
90868>>>>>>>//        End
90868>>>>>>>//
90868>>>>>>>//        Function_Return False
90868>>>>>>>//    End_Function  
90868>>>>>>>
90868>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
90870>>>>>>>        String sPhysicalName sPhysicalNameCompare
90870>>>>>>>        Integer iCount iMaster iAlias iInTable
90870>>>>>>>        
90870>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
90873>>>>>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
90874>>>>>>>        Move hTable to iInTable
90875>>>>>>>        Move 0 to hTable                      
90876>>>>>>>        Move 0 to iCount    
90877>>>>>>>        
90877>>>>>>>        Repeat
90877>>>>>>>>
90877>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90880>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
90882>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
90885>>>>>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
90886>>>>>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
90888>>>>>>>                
90888>>>>>>>                    If (iCount = 0) Begin
90890>>>>>>>                        Move hTable to iMaster
90891>>>>>>>                    End
90891>>>>>>>>
90891>>>>>>>                    If (iCount > 0) Begin
90893>>>>>>>                        Move hTable to iAlias
90894>>>>>>>                    End
90894>>>>>>>>
90894>>>>>>>                    Increment iCount 
90895>>>>>>>                End
90895>>>>>>>>
90895>>>>>>>            End
90895>>>>>>>>
90895>>>>>>>        Until (hTable = 0)
90897>>>>>>>        
90897>>>>>>>        If (iCount > 1) Begin
90899>>>>>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
90900>>>>>>>        End
90900>>>>>>>>
90900>>>>>>>
90900>>>>>>>        Function_Return False
90901>>>>>>>    End_Function  
90902>>>>>>>    
90902>>>>>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
90902>>>>>>>//        String sDDSrcPath sDataPath sLogicalName
90902>>>>>>>//        Boolean bOK bExists
90902>>>>>>>//        
90902>>>>>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath  
90902>>>>>>>//        If (Right(sDataPath, 1) = "\") Begin
90902>>>>>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
90902>>>>>>>//        End
90902>>>>>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
90902>>>>>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
90902>>>>>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
90902>>>>>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
90902>>>>>>>//        
90902>>>>>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90902>>>>>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
90902>>>>>>>//        
90902>>>>>>>//        Function_Return bExists
90902>>>>>>>//    End_Function  
90902>>>>>>>
90902>>>>>>>    // To Open a table with any driver.
90902>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
90902>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
90902>>>>>>>    //
90902>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
90902>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
90902>>>>>>>    // returns a True if successful (table could be opened).
90902>>>>>>>    //
90902>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
90902>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
90902>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
90902>>>>>>>    // set properly we can open the table.
90902>>>>>>>    //
90902>>>>>>>    // DAW Driver Syntax:
90902>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
90902>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
90902>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
90902>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
90902>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
90902>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
90902>>>>>>>    //
90902>>>>>>>    // DAW Driver Sample:
90902>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
90902>>>>>>>    //
90902>>>>>>>    // Mertech Driver Samples:
90902>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
90902>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
90902>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
90902>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
90902>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
90904>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
90904>>>>>>>        Boolean bOpen bMertechDriver bOK
90904>>>>>>>        Integer iRetval
90904>>>>>>>        tSQLConnection SQLConnection
90904>>>>>>>        tSQLConnection SQLConnection
90904>>>>>>>
90904>>>>>>>        Move sTableName to sTableNameOrg
90905>>>>>>>        If (hTable > 0) Begin
90907>>>>>>>//        If (hTable > 0 and Trim(sTableName) = "") Begin
90907>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
90908>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90909>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
90910>>>>>>>            Open hTable
90912>>>>>>>            Send Trap_Error of Error_Object_Id 20529
90913>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90914>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND  
90915>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90918>>>>>>>            If (bOpen = True) Begin
90920>>>>>>>                Function_Return True
90921>>>>>>>            End
90921>>>>>>>>
90921>>>>>>>        End
90921>>>>>>>>
90921>>>>>>>
90921>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90922>>>>>>>        Move SQLConnection.sDriverID to sDriverID
90923>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
90924>>>>>>>        Move SQLConnection.sConnectionString to sConnection
90925>>>>>>>        Move SQLConnection.sSchema to sSchema
90926>>>>>>>        If (sSchema = "") Begin
90928>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90929>>>>>>>        End
90929>>>>>>>>
90929>>>>>>>
90929>>>>>>>        // We need to remove the ".int" part of the table name because
90929>>>>>>>        // the table name after the "#" in the connection syntax below wants the
90929>>>>>>>        // "bare" table name without any extension.
90929>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
90931>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
90933>>>>>>>                Get ParseFileExtension sTableName to sExt
90934>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
90935>>>>>>>            End
90935>>>>>>>>
90935>>>>>>>            Else Begin
90936>>>>>>>                Move sTableName to sTableNameShort
90937>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
90938>>>>>>>            End
90938>>>>>>>>
90938>>>>>>>            If (bMertechDriver = False) Begin
90940>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
90941>>>>>>>                Move sConnection to sTableName
90942>>>>>>>            End
90942>>>>>>>>
90942>>>>>>>        End
90942>>>>>>>>
90942>>>>>>>
90942>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90943>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
90944>>>>>>>        If (hTable = 0) Begin
90946>>>>>>>            Get NextFreeFilelistSlot to hTable
90947>>>>>>>        End
90947>>>>>>>>
90947>>>>>>>
90947>>>>>>>        Case Begin
90947>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90949>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90949>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
90951>>>>>>>                    Open sTableName as hTable
90953>>>>>>>                End
90953>>>>>>>>
90953>>>>>>>                Else Begin
90954>>>>>>>                    Get OpenTableExclusive hTable to bOK
90955>>>>>>>                    If (bOK = False) Begin
90957>>>>>>>                        Function_Return False
90958>>>>>>>                    End
90958>>>>>>>>
90958>>>>>>>                End
90958>>>>>>>>
90958>>>>>>>                Case Break
90959>>>>>>>
90959>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90962>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90962>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
90964>>>>>>>                    Open sTableName as hTable
90966>>>>>>>                End
90966>>>>>>>>
90966>>>>>>>                Else Begin
90967>>>>>>>                    Get OpenTableExclusive hTable to bOK
90968>>>>>>>                    If (bOK = False) Begin
90970>>>>>>>                        Function_Return False
90971>>>>>>>                    End
90971>>>>>>>>
90971>>>>>>>                End
90971>>>>>>>>
90971>>>>>>>                Case Break
90972>>>>>>>
90972>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
90975>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90975>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
90977>>>>>>>                    Open sTableName as hTable
90979>>>>>>>                End
90979>>>>>>>>
90979>>>>>>>                Else Begin
90980>>>>>>>                    Get OpenTableExclusive hTable to bOK
90981>>>>>>>                    If (bOK = False) Begin
90983>>>>>>>                        Function_Return False
90984>>>>>>>                    End
90984>>>>>>>>
90984>>>>>>>                End
90984>>>>>>>>
90984>>>>>>>                Case Break
90985>>>>>>>
90985>>>>>>>            Case (sDriverID = SQLFLEX)
90988>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
90988>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
90988>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
90989>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90989>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
90991>>>>>>>                    Open sTableName as hTable
90993>>>>>>>                End
90993>>>>>>>>
90993>>>>>>>                Else Begin
90994>>>>>>>                    Get OpenTableExclusive hTable to bOK
90995>>>>>>>                    If (bOK = False) Begin
90997>>>>>>>                        Function_Return False
90998>>>>>>>                    End
90998>>>>>>>>
90998>>>>>>>                End
90998>>>>>>>>
90998>>>>>>>                Case Break
90999>>>>>>>
90999>>>>>>>            Case (sDriverID = MDSMySQL)
91002>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
91002>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
91003>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91003>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91005>>>>>>>                    Open sTableName as hTable
91007>>>>>>>                End
91007>>>>>>>>
91007>>>>>>>                Else Begin
91008>>>>>>>                    Get OpenTableExclusive hTable to bOK
91009>>>>>>>                    If (bOK = False) Begin
91011>>>>>>>                        Function_Return False
91012>>>>>>>                    End
91012>>>>>>>>
91012>>>>>>>                End
91012>>>>>>>>
91012>>>>>>>                Case Break
91013>>>>>>>
91013>>>>>>>            Case (sDriverID = MDSPgSQL)
91016>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
91016>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
91017>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91017>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91019>>>>>>>                    Open sTableName as hTable
91021>>>>>>>                End
91021>>>>>>>>
91021>>>>>>>                Else Begin
91022>>>>>>>                    Get OpenTableExclusive hTable to bOK
91023>>>>>>>                    If (bOK = False) Begin
91025>>>>>>>                        Function_Return False
91026>>>>>>>                    End
91026>>>>>>>>
91026>>>>>>>                End
91026>>>>>>>>
91026>>>>>>>                Case Break
91027>>>>>>>
91027>>>>>>>            Case (sDriverID = ORAFLEX)
91030>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
91030>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
91030>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
91031>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91031>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91033>>>>>>>                    Open sTableName as hTable
91035>>>>>>>                End
91035>>>>>>>>
91035>>>>>>>                Else Begin
91036>>>>>>>                    Get OpenTableExclusive hTable to bOK
91037>>>>>>>                    If (bOK = False) Begin
91039>>>>>>>                        Function_Return False
91040>>>>>>>                    End
91040>>>>>>>>
91040>>>>>>>                End
91040>>>>>>>>
91040>>>>>>>                Case Break
91041>>>>>>>
91041>>>>>>>            Case (sDriverID = DATAFLEX_ID)
91044>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91046>>>>>>>                    Open sTableName as hTable
91048>>>>>>>                End
91048>>>>>>>>
91048>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91051>>>>>>>                    Get OpenTableExclusive hTable to bOK
91052>>>>>>>                    If (bOK = False) Begin
91054>>>>>>>                        Function_Return False
91055>>>>>>>                    End
91055>>>>>>>>
91055>>>>>>>                End
91055>>>>>>>>
91055>>>>>>>                Else Begin
91056>>>>>>>                    Open hTable
91058>>>>>>>                End
91058>>>>>>>>
91058>>>>>>>                Case Break
91059>>>>>>>
91059>>>>>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
91059>>>>>>>
91059>>>>>>>            Case Else
91059>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91060>>>>>>>>
91060>>>>>>>        Case End
91060>>>>>>>
91060>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91061>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91062>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91064>>>>>>>            Move False to Found
91065>>>>>>>        End
91065>>>>>>>>
91065>>>>>>>        // If open failed, the Err is set to true,
91065>>>>>>>        // but we don't want that because it could end our loop.
91065>>>>>>>        Move False to Err
91066>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91069>>>>>>>
91069>>>>>>>        Function_Return bOpen
91070>>>>>>>    End_Function
91071>>>>>>>
91071>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
91071>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
91071>>>>>>>    // if it is an SQL table
91071>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
91073>>>>>>>        Boolean bExists bIsSQLTable
91073>>>>>>>        String sDataPath sRootName
91073>>>>>>>        
91073>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
91074>>>>>>>        If (bExists = False) Begin
91076>>>>>>>            Function_Return False
91077>>>>>>>        End
91077>>>>>>>>
91077>>>>>>>        
91077>>>>>>>        Move False to bIsSQLTable
91078>>>>>>>        If (hTable > 0) Begin
91080>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91083>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
91084>>>>>>>        End
91084>>>>>>>>
91084>>>>>>>        If (bIsSQLTable = True) Begin
91086>>>>>>>            Get UtilTableIsSQL hTable to bExists
91087>>>>>>>            Function_Return bExists
91088>>>>>>>        End
91088>>>>>>>>
91088>>>>>>>        Else Begin
91089>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91090>>>>>>>            Get vFolderFormat sDataPath to sDataPath
91091>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
91092>>>>>>>        End
91092>>>>>>>>
91092>>>>>>>        
91092>>>>>>>        Function_Return bExists
91093>>>>>>>    End_Function               
91094>>>>>>>    
91094>>>>>>>    // Pass a table handle
91094>>>>>>>    // Returns True if the table exists in filelist.cfg.
91094>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
91096>>>>>>>        Handle hTable
91096>>>>>>>        Boolean bFound
91096>>>>>>>
91096>>>>>>>        Move False to bFound
91097>>>>>>>        Move 0 to hTable
91098>>>>>>>        Repeat
91098>>>>>>>>
91098>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91101>>>>>>>            If (hTable > 0) Begin
91103>>>>>>>                If (hTable = hCheckTable) Begin
91105>>>>>>>                    Move True to bFound
91106>>>>>>>                End
91106>>>>>>>>
91106>>>>>>>            End
91106>>>>>>>>
91106>>>>>>>            If (bFound = True) Break
91109>>>>>>>        Until (hTable = 0)
91111>>>>>>>
91111>>>>>>>        Function_Return (bFound = True)
91112>>>>>>>    End_Function
91113>>>>>>>
91113>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
91113>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
91115>>>>>>>        Handle hTable
91115>>>>>>>        Integer iRetval
91115>>>>>>>
91115>>>>>>>        Move 0 to hTable         
91116>>>>>>>        Move 0 to iRetval
91117>>>>>>>        
91117>>>>>>>        Repeat
91117>>>>>>>>
91117>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91120>>>>>>>            If (hTable > 0) Begin
91122>>>>>>>                Increment iRetval
91123>>>>>>>            End
91123>>>>>>>>
91123>>>>>>>        Until (hTable = 0)
91125>>>>>>>
91125>>>>>>>        Function_Return iRetval
91126>>>>>>>    End_Function
91127>>>>>>>
91127>>>>>>>    // Pass a table's logical name
91127>>>>>>>    // Returns True if the table exists in filelist.cfg.
91127>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91129>>>>>>>        Handle hTable
91129>>>>>>>        Boolean bFound                           
91129>>>>>>>        String sCompareTable
91129>>>>>>>
91129>>>>>>>        Move False to bFound
91130>>>>>>>        Move 0 to hTable
91131>>>>>>>        Repeat
91131>>>>>>>>
91131>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91134>>>>>>>            If (hTable > 0) Begin
91136>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91139>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91141>>>>>>>                    Move True to bFound
91142>>>>>>>                End
91142>>>>>>>>
91142>>>>>>>            End
91142>>>>>>>>
91142>>>>>>>            If (bFound = True) Break
91145>>>>>>>        Until (hTable = 0)
91147>>>>>>>
91147>>>>>>>        Function_Return (bFound = True)
91148>>>>>>>    End_Function    
91149>>>>>>>    
91149>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91151>>>>>>>        Boolean bOK bRecnum bToAnsi
91151>>>>>>>        Integer iCh                   
91151>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91151>>>>>>>        
91151>>>>>>>        If (Trim(sDataPath) = "") Begin
91153>>>>>>>            Function_Return False
91154>>>>>>>        End
91154>>>>>>>>
91154>>>>>>>        
91154>>>>>>>        Move False to Err
91155>>>>>>>        Get psDriverID     to sDriverID
91156>>>>>>>        Get psConnectionID to sConnectionID
91157>>>>>>>        Get psSchema       to sSchemaName
91158>>>>>>>        Get True           to bRecnum
91159>>>>>>>        Get pbToANSI       to bToAnsi
91160>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91161>>>>>>>        If (bToAnsi = False) Begin
91163>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91164>>>>>>>        End
91164>>>>>>>>
91164>>>>>>>        
91164>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91165>>>>>>>        Move "CodeMast.int"         to sFileName
91166>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91167>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91170>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91173>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91176>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91179>>>>>>>            Writeln channel iCh ("")
91182>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91185>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91188>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91191>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91194>>>>>>>            Writeln channel iCh ("")
91197>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91200>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91203>>>>>>>            Writeln channel iCh ("")
91206>>>>>>>        Send Seq_Close_Channel iCh
91207>>>>>>>        
91207>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91208>>>>>>>        Move "CodeType.int"         to sFileName
91209>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91210>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91213>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91216>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91219>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91222>>>>>>>            Writeln channel iCh ("")
91225>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91228>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91231>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91234>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91237>>>>>>>            Writeln channel iCh ("")
91240>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91243>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91246>>>>>>>            Writeln channel iCh ("")
91249>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91252>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91255>>>>>>>            Writeln channel iCh ("")
91258>>>>>>>        Send Seq_Close_Channel iCh
91259>>>>>>>    
91259>>>>>>>        Function_Return (Err = False)
91260>>>>>>>    End_Function
91261>>>>>>>
91261>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
91263>>>>>>>        String  sRetval sColumnName
91263>>>>>>>        String[] sOverlapFieldsArray
91264>>>>>>>        Integer iType iColumn iColumns
91264>>>>>>>        Boolean bOpen bOverlap
91264>>>>>>>
91264>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91267>>>>>>>        If (bOpen = False) Begin
91269>>>>>>>            Open hTable
91271>>>>>>>        End
91271>>>>>>>>
91271>>>>>>>
91271>>>>>>>        Move "" to sRetval
91272>>>>>>>
91272>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
91275>>>>>>>
91275>>>>>>>        for iColumn from 0 to iColumns
91281>>>>>>>>
91281>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
91284>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
91286>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
91289>>>>>>>                If (bOverlap) Begin
91291>>>>>>>                    If (sRetval <> "") Begin
91293>>>>>>>                        Append sRetval ","
91294>>>>>>>                    End
91294>>>>>>>>
91294>>>>>>>                    Append sRetval iColumn
91295>>>>>>>                End
91295>>>>>>>>
91295>>>>>>>            End
91295>>>>>>>>
91295>>>>>>>        Loop
91296>>>>>>>>
91296>>>>>>>
91296>>>>>>>        If (bOpen = False) Begin
91298>>>>>>>            Close hTable
91299>>>>>>>        End
91299>>>>>>>>
91299>>>>>>>
91299>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
91300>>>>>>>
91300>>>>>>>        Function_Return sOverlapFieldsArray
91301>>>>>>>    End_Function
91302>>>>>>>
91302>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
91302>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
91304>>>>>>>        tColumnType[] ColumnType
91304>>>>>>>        tColumnType[] ColumnType
91305>>>>>>>
91305>>>>>>>        Case Begin
91305>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
91307>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
91308>>>>>>>                Case Break
91309>>>>>>>
91309>>>>>>>            Case (iDbType = EN_DbTypeDB2)
91312>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
91313>>>>>>>                Case Break
91314>>>>>>>
91314>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
91317>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
91318>>>>>>>                Case Break
91319>>>>>>>
91319>>>>>>>            Case (sDriverID = MDSMySQL)
91322>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
91323>>>>>>>                Case Break
91324>>>>>>>
91324>>>>>>>            Case (sDriverID = ORAFLEX)
91327>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
91328>>>>>>>                Case Break
91329>>>>>>>
91329>>>>>>>            Case (sDriverID = MDSPgSQL)
91332>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
91333>>>>>>>                Case Break
91334>>>>>>>        Case End
91334>>>>>>>
91334>>>>>>>        Function_Return ColumnType
91335>>>>>>>    End_Function 
91336>>>>>>>    
91336>>>>>>>    Function UtilEnumerateMSSQLODBCDrivers Returns String
91338>>>>>>>        Handle hoRegistry hoODBCDriverNames
91338>>>>>>>        Boolean bExists bKeyOpened
91338>>>>>>>        String sKey
91338>>>>>>>        String[] sDrivers
91339>>>>>>>        Integer iDriverNames iDriverName
91339>>>>>>>        
91339>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
91340>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91341>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
91342>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
91343>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
91344>>>>>>>        If (bExists) Begin
91346>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
91347>>>>>>>            If (bKeyOpened) Begin
91349>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
91350>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
91351>>>>>>>                If (iDriverNames > 0) Begin
91353>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
91354>>>>>>>                    Decrement iDriverNames
91355>>>>>>>                    for iDriverName from 0 to iDriverNames
91361>>>>>>>>
91361>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
91362>>>>>>>                      Loop
91363>>>>>>>>
91363>>>>>>>                End
91363>>>>>>>>
91363>>>>>>>                Send CloseKey of hoRegistry
91364>>>>>>>            End
91364>>>>>>>>
91364>>>>>>>        End
91364>>>>>>>>
91364>>>>>>>        Send Destroy of hoRegistry
91365>>>>>>>        
91365>>>>>>>        Function_Return sDrivers
91366>>>>>>>    End_Function
91367>>>>>>>
91367>>>>>>>    // DataFlex Embedded Database Data Types:
91367>>>>>>>    // Helper function for UtilEnumerateColumnTypes
91367>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
91369>>>>>>>        tColumnType[] ColumnType
91369>>>>>>>        tColumnType[] ColumnType
91370>>>>>>>        Integer i
91370>>>>>>>
91370>>>>>>>        Move DF_ASCII           to ColumnType[i].iType
91371>>>>>>>        Move "ASCII"            to ColumnType[i].sType
91372>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91373>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91374>>>>>>>        Move "254"              to ColumnType[i].sPrecision
91375>>>>>>>        Increment i
91376>>>>>>>
91376>>>>>>>        Move DF_BCD             to ColumnType[i].iType
91377>>>>>>>        Move "Numeric"          to ColumnType[i].sType
91378>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91379>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91380>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
91381>>>>>>>        Increment i
91382>>>>>>>
91382>>>>>>>        Move DF_DATE            to ColumnType[i].iType
91383>>>>>>>        Move "Date"             to ColumnType[i].sType
91384>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
91385>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
91386>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
91387>>>>>>>        Move True               to ColumnType[i].bFixedSize
91388>>>>>>>        Increment i
91389>>>>>>>
91389>>>>>>>        Move DF_TEXT            to ColumnType[i].iType
91390>>>>>>>        Move "Text"             to ColumnType[i].sType
91391>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91392>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
91393>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
91394>>>>>>>        Increment i
91395>>>>>>>
91395>>>>>>>        Move DF_BINARY          to ColumnType[i].iType
91396>>>>>>>        Move "Binary"           to ColumnType[i].sType
91397>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91398>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91399>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
91400>>>>>>>        Increment i
91401>>>>>>>
91401>>>>>>>        Move DF_DATETIME        to ColumnType[i].iType
91402>>>>>>>        Move "DateTime"         to ColumnType[i].sType
91403>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91404>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
91405>>>>>>>        Move "23"               to ColumnType[i].sPrecision
91406>>>>>>>        Move True               to ColumnType[i].bFixedSize
91407>>>>>>>        Increment i
91408>>>>>>>
91408>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iType
91409>>>>>>>        Move "Overlap"          to ColumnType[i].sType
91410>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
91411>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
91412>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
91413>>>>>>>
91413>>>>>>>        Function_Return ColumnType
91414>>>>>>>    End_Function
91415>>>>>>>
91415>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
91417>>>>>>>        tColumnType[] ColumnType
91417>>>>>>>        tColumnType[] ColumnType
91418>>>>>>>        Integer i
91418>>>>>>>
91418>>>>>>>        Move SQL_DBCLOB         to ColumnType[i].iType
91419>>>>>>>        Move "DBCLOB"           to ColumnType[i].sType
91420>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91421>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
91422>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
91423>>>>>>>        Increment i
91424>>>>>>>
91424>>>>>>>        Move SQL_BIGINT         to ColumnType[i].iType
91425>>>>>>>        Move "BIGINT"           to ColumnType[i].sType
91426>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91427>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91428>>>>>>>        Move "14.0"             to ColumnType[i].sPrecision
91429>>>>>>>        Increment i
91430>>>>>>>
91430>>>>>>>        Move SQL_BLOB           to ColumnType[i].iType
91431>>>>>>>        Move "BLOB"             to ColumnType[i].sType
91432>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91433>>>>>>>        Move "BINARY"           to ColumnType[i].sDataFlexType
91434>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
91435>>>>>>>        Increment i
91436>>>>>>>
91436>>>>>>>        Move SQL_CHAR           to ColumnType[i].iType
91437>>>>>>>        Move "CHAR"             to ColumnType[i].sType
91438>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91439>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91440>>>>>>>        Move "254"              to ColumnType[i].sPrecision
91441>>>>>>>        Increment i
91442>>>>>>>
91442>>>>>>>        // ToDo: We need to change the sType when using this!
91442>>>>>>>        Move SQL_CHARBIT            to ColumnType[i].iType
91443>>>>>>>        Move "CHAR FOR BIT DATA"    to ColumnType[i].sType
91444>>>>>>>        Move DF_BINARY              to ColumnType[i].iDataFlexType
91445>>>>>>>        Move "Binary"               to ColumnType[i].sDataFlexType
91446>>>>>>>        Move "254"                  to ColumnType[i].sPrecision
91447>>>>>>>        Increment i
91448>>>>>>>
91448>>>>>>>        Move SQL_DATE           to ColumnType[i].iType
91449>>>>>>>        Move "DATE"             to ColumnType[i].sType
91450>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
91451>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
91452>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
91453>>>>>>>        Move True               to ColumnType[i].bFixedSize
91454>>>>>>>        Increment i
91455>>>>>>>
91455>>>>>>>        Move SQL_CLOB           to ColumnType[i].iType
91456>>>>>>>        Move "CLOB"             to ColumnType[i].sType
91457>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91458>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
91459>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
91460>>>>>>>        Increment i
91461>>>>>>>
91461>>>>>>>        Move SQL_DECIMAL        to ColumnType[i].iType
91462>>>>>>>        Move "DECIMAL"          to ColumnType[i].sType
91463>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91464>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91465>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
91466>>>>>>>        Increment i
91467>>>>>>>
91467>>>>>>>        Move SQL_DOUBLE         to ColumnType[i].iType
91468>>>>>>>        Move "DOUBLE"           to ColumnType[i].sType
91469>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91470>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91471>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
91472>>>>>>>        Increment i
91473>>>>>>>
91473>>>>>>>        Move SQL_FLOAT          to ColumnType[i].iType
91474>>>>>>>        Move "FLOAT"            to ColumnType[i].sType
91475>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91476>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91477>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
91478>>>>>>>        Increment i
91479>>>>>>>
91479>>>>>>>        Move SQL_GRAPHIC        to ColumnType[i].iType
91480>>>>>>>        Move "GRAPHIC"          to ColumnType[i].sType
91481>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91482>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91483>>>>>>>        Move "255"              to ColumnType[i].sPrecision
91484>>>>>>>        Increment i
91485>>>>>>>
91485>>>>>>>        Move SQL_INTEGER        to ColumnType[i].iType
91486>>>>>>>        Move "INTEGER"          to ColumnType[i].sType
91487>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91488>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91489>>>>>>>        Move "9.0"              to ColumnType[i].sPrecision
91490>>>>>>>        Increment i
91491>>>>>>>
91491>>>>>>>        Move SQL_LONGVARCHAR    to ColumnType[i].iType
91492>>>>>>>        Move "LONG VARCHAR"     to ColumnType[i].sType
91493>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91494>>>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91495>>>>>>>        Move "32000"            to ColumnType[i].sPrecision
91496>>>>>>>        Increment i
91497>>>>>>>
91497>>>>>>>        Move SQL_LONGVARCHARBIT to ColumnType[i].iType
91498>>>>>>>        Move "LONG VARCHAR BIT" to ColumnType[i].sType
91499>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91500>>>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91501>>>>>>>        Move "32000"            to ColumnType[i].sPrecision
91502>>>>>>>        Increment i
91503>>>>>>>
91503>>>>>>>        Move SQL_LONGVARGRAPHIC to ColumnType[i].iType
91504>>>>>>>        Move "LONG VARGRAPHIC"  to ColumnType[i].sType
91505>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91506>>>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91507>>>>>>>        Move "32000"            to ColumnType[i].sPrecision
91508>>>>>>>        Increment i
91509>>>>>>>
91509>>>>>>>        Move SQL_NUMERIC        to ColumnType[i].iType
91510>>>>>>>        Move "NUMERIC"          to ColumnType[i].sType
91511>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91512>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91513>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
91514>>>>>>>        Increment i
91515>>>>>>>
91515>>>>>>>        Move SQL_REAL           to ColumnType[i].iType
91516>>>>>>>        Move "REAL"             to ColumnType[i].sType
91517>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91518>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91519>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
91520>>>>>>>        Increment i
91521>>>>>>>
91521>>>>>>>        Move SQL_SMALLINT       to ColumnType[i].iType
91522>>>>>>>        Move "SMALLINT"         to ColumnType[i].sType
91523>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91524>>>>>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
91525>>>>>>>        Move "5.0"              to ColumnType[i].sPrecision
91526>>>>>>>        Increment i
91527>>>>>>>
91527>>>>>>>        Move SQL_TIME           to ColumnType[i].iType
91528>>>>>>>        Move "TIME"             to ColumnType[i].sType
91529>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91530>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91531>>>>>>>        Move "19.0"             to ColumnType[i].sPrecision
91532>>>>>>>        Move True               to ColumnType[i].bFixedSize
91533>>>>>>>        Increment i
91534>>>>>>>
91534>>>>>>>        Move SQL_TIMESTAMP      to ColumnType[i].iType
91535>>>>>>>        Move "TIMESTAMP"        to ColumnType[i].sType
91536>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91537>>>>>>>        Move "DATETIME"         to ColumnType[i].sDataFlexType
91538>>>>>>>        Move "23.6"             to ColumnType[i].sPrecision
91539>>>>>>>        Move True               to ColumnType[i].bFixedSize
91540>>>>>>>        Increment i
91541>>>>>>>
91541>>>>>>>        Move SQL_VARCHAR        to ColumnType[i].iType
91542>>>>>>>        Move "VARCHAR"          to ColumnType[i].sType
91543>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91544>>>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91545>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
91546>>>>>>>        Increment i
91547>>>>>>>
91547>>>>>>>        // ToDo: We need to change the sType when using this!
91547>>>>>>>        Move SQL_VARCHARBIT         to ColumnType[i].iType
91548>>>>>>>        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sType
91549>>>>>>>        Move DF_TEXT                to ColumnType[i].iDataFlexType
91550>>>>>>>        Move "TEXT"                 to ColumnType[i].sDataFlexType
91551>>>>>>>        Move "16384"                to ColumnType[i].sPrecision
91552>>>>>>>        Increment i
91553>>>>>>>
91553>>>>>>>        Move SQL_VARGRAPHIC     to ColumnType[i].iType
91554>>>>>>>        Move "VARGRAPHIC"       to ColumnType[i].sType
91555>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91556>>>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91557>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
91558>>>>>>>
91558>>>>>>>        Move SQL_XML            to ColumnType[i].iType
91559>>>>>>>        Move "XML"              to ColumnType[i].sType
91560>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91561>>>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91562>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
91563>>>>>>>
91563>>>>>>>        Function_Return ColumnType
91564>>>>>>>    End_Function
91565>>>>>>>
91565>>>>>>>    // Microsoft SQL Server Database Data Types:
91565>>>>>>>    // Helper function for UtilEnumerateColumnTypes
91565>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
91567>>>>>>>        tColumnType[] ColumnType
91567>>>>>>>        tColumnType[] ColumnType
91568>>>>>>>        Integer i
91568>>>>>>>
91568>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
91570>>>>>>>            Move SQL_BIGINT         to ColumnType[i].iType
91571>>>>>>>            Move "bigint"           to ColumnType[i].sType
91572>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91573>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91574>>>>>>>            Move "14.0"             to ColumnType[i].sPrecision
91575>>>>>>>            Move True               to ColumnType[i].bFixedSize
91576>>>>>>>            Increment i
91577>>>>>>>
91577>>>>>>>            Move SQL_BINARY         to ColumnType[i].iType
91578>>>>>>>            Move "binary"           to ColumnType[i].sType
91579>>>>>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
91580>>>>>>>            Move "Binary"           to ColumnType[i].sDataFlexType
91581>>>>>>>            Move "8000"             to ColumnType[i].sPrecision
91582>>>>>>>            Increment i
91583>>>>>>>
91583>>>>>>>            Move SQL_BIT            to ColumnType[i].iType
91584>>>>>>>            Move "bit"              to ColumnType[i].sType
91585>>>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91586>>>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91587>>>>>>>            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
91588>>>>>>>            Move True               to ColumnType[i].bFixedSize
91589>>>>>>>            Increment i
91590>>>>>>>
91590>>>>>>>            Move SQL_CHAR           to ColumnType[i].iType
91591>>>>>>>            Move "char"             to ColumnType[i].sType
91592>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91593>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91594>>>>>>>            Move "8000"             to ColumnType[i].sPrecision
91595>>>>>>>            Increment i
91596>>>>>>>
91596>>>>>>>            Move SQL_DATE           to ColumnType[i].iType
91597>>>>>>>            Move "date"             to ColumnType[i].sType
91598>>>>>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
91599>>>>>>>            Move "Date"             to ColumnType[i].sDataFlexType
91600>>>>>>>            Move "6.0"              to ColumnType[i].sPrecision
91601>>>>>>>            Move True               to ColumnType[i].bFixedSize
91602>>>>>>>            Increment i
91603>>>>>>>
91603>>>>>>>            Move SQL_DATETIME       to ColumnType[i].iType
91604>>>>>>>            Move "datetime"         to ColumnType[i].sType
91605>>>>>>>            Move DF_DATETIME        to ColumnType[i].iDataFlexType
91606>>>>>>>            Move "DateTime"         to ColumnType[i].sDataFlexType
91607>>>>>>>            Move "23.3"             to ColumnType[i].sPrecision
91608>>>>>>>            Move True               to ColumnType[i].bFixedSize
91609>>>>>>>            Increment i
91610>>>>>>>
91610>>>>>>>            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iType
91611>>>>>>>            Move "datetime2"         to ColumnType[i].sType
91612>>>>>>>            Move DF_DATETIME         to ColumnType[i].iDataFlexType
91613>>>>>>>            Move "DateTime"          to ColumnType[i].sDataFlexType
91614>>>>>>>            Move "23.6"              to ColumnType[i].sPrecision
91615>>>>>>>            Move True                to ColumnType[i].bFixedSize
91616>>>>>>>            Increment i
91617>>>>>>>
91617>>>>>>>            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iType
91618>>>>>>>            Move "datetimeoffset"       to ColumnType[i].sType
91619>>>>>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
91620>>>>>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
91621>>>>>>>            Move "34.0"                 to ColumnType[i].sPrecision
91622>>>>>>>            Move True                   to ColumnType[i].bFixedSize
91623>>>>>>>            Increment i
91624>>>>>>>
91624>>>>>>>            Move SQL_DECIMAL        to ColumnType[i].iType
91625>>>>>>>            Move "decimal"          to ColumnType[i].sType
91626>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91627>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91628>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91629>>>>>>>            Increment i
91630>>>>>>>
91630>>>>>>>            Move SQL_FLOAT          to ColumnType[i].iType
91631>>>>>>>            Move "float"            to ColumnType[i].sType
91632>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91633>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91634>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91635>>>>>>>            Increment i
91636>>>>>>>
91636>>>>>>>            Move SQL_INTEGER        to ColumnType[i].iType
91637>>>>>>>            Move "int"              to ColumnType[i].sType
91638>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91639>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91640>>>>>>>            Move "8.0"              to ColumnType[i].sPrecision
91641>>>>>>>            Move True               to ColumnType[i].bFixedSize
91642>>>>>>>            Increment i
91643>>>>>>>
91643>>>>>>>            Move SQL_TYPE_MONEY     to ColumnType[i].iType
91644>>>>>>>            Move "money"            to ColumnType[i].sType
91645>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91646>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91647>>>>>>>            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
91648>>>>>>>            Increment i
91649>>>>>>>
91649>>>>>>>            Move SQL_WCHAR          to ColumnType[i].iType
91650>>>>>>>            Move "nchar"            to ColumnType[i].sType
91651>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91652>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91653>>>>>>>            Move "4000"             to ColumnType[i].sPrecision
91654>>>>>>>            Increment i
91655>>>>>>>
91655>>>>>>>            Move SQL_WLONGVARCHAR   to ColumnType[i].iType
91656>>>>>>>            Move "ntext"            to ColumnType[i].sType
91657>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91658>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91659>>>>>>>            Move "16384"            to ColumnType[i].sPrecision
91660>>>>>>>            Increment i
91661>>>>>>>
91661>>>>>>>            Move SQL_NUMERIC        to ColumnType[i].iType
91662>>>>>>>            Move "numeric"          to ColumnType[i].sType
91663>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91664>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91665>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91666>>>>>>>            Increment i
91667>>>>>>>
91667>>>>>>>            Move SQL_WVARCHAR       to ColumnType[i].iType
91668>>>>>>>            Move "nvarchar"         to ColumnType[i].sType
91669>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91670>>>>>>>            Move "Text"             to ColumnType[i].sDataFlexType
91671>>>>>>>            Move "4000"             to ColumnType[i].sPrecision
91672>>>>>>>            Increment i
91673>>>>>>>
91673>>>>>>>            Move SQL_VARCHARMAX     to ColumnType[i].iType
91674>>>>>>>            Move "nvarchar(max)"    to ColumnType[i].sType
91675>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91676>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91677>>>>>>>            Move "16384"            to ColumnType[i].sPrecision
91678>>>>>>>            Move True               to ColumnType[i].bFixedSize
91679>>>>>>>            Increment i
91680>>>>>>>
91680>>>>>>>            Move SQL_REAL           to ColumnType[i].iType
91681>>>>>>>            Move "real"             to ColumnType[i].sType
91682>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91683>>>>>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
91684>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91685>>>>>>>            Increment i
91686>>>>>>>
91686>>>>>>>            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iType
91687>>>>>>>            Move "smalldatetime"        to ColumnType[i].sType
91688>>>>>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
91689>>>>>>>            Move "DATETIME"             to ColumnType[i].sDataFlexType
91690>>>>>>>            Move "23.0"                 to ColumnType[i].sPrecision
91691>>>>>>>            Move True                   to ColumnType[i].bFixedSize
91692>>>>>>>            Increment i
91693>>>>>>>
91693>>>>>>>            Move SQL_SMALLINT       to ColumnType[i].iType
91694>>>>>>>            Move "smallint"         to ColumnType[i].sType
91695>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91696>>>>>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
91697>>>>>>>            Move "4.0"              to ColumnType[i].sPrecision
91698>>>>>>>            Move True               to ColumnType[i].bFixedSize
91699>>>>>>>            Increment i
91700>>>>>>>
91700>>>>>>>            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iType
91701>>>>>>>            Move "smallmoney"        to ColumnType[i].sType
91702>>>>>>>            Move DF_BCD              to ColumnType[i].iDataFlexType
91703>>>>>>>            Move "NUMERIC"           to ColumnType[i].sDataFlexType
91704>>>>>>>            Move "10.0"              to ColumnType[i].sPrecision
91705>>>>>>>            Increment i
91706>>>>>>>
91706>>>>>>>            Move SQL_TEXT           to ColumnType[i].iType
91707>>>>>>>            Move "text"             to ColumnType[i].sType
91708>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91709>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91710>>>>>>>            Move "8000"             to ColumnType[i].sPrecision
91711>>>>>>>            Move True               to ColumnType[i].bFixedSize
91712>>>>>>>            Increment i
91713>>>>>>>
91713>>>>>>>            Move SQL_TIME           to ColumnType[i].iType
91714>>>>>>>            Move "time"             to ColumnType[i].sType
91715>>>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91716>>>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91717>>>>>>>            Move "19.0"             to ColumnType[i].sPrecision
91718>>>>>>>            Move True               to ColumnType[i].bFixedSize
91719>>>>>>>            Increment i
91720>>>>>>>
91720>>>>>>>            Move SQL_TINYINT        to ColumnType[i].iType
91721>>>>>>>            Move "tinyint"          to ColumnType[i].sType
91722>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91723>>>>>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
91724>>>>>>>            Move "2.0"              to ColumnType[i].sPrecision
91725>>>>>>>            Move True               to ColumnType[i].bFixedSize
91726>>>>>>>            Increment i
91727>>>>>>>
91727>>>>>>>            Move SQL_GUID           to ColumnType[i].iType
91728>>>>>>>            Move "uniqueidentifier" to ColumnType[i].sType
91729>>>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91730>>>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91731>>>>>>>            Move "36"               to ColumnType[i].sPrecision
91732>>>>>>>            Move True               to ColumnType[i].bFixedSize
91733>>>>>>>            Increment i
91734>>>>>>>
91734>>>>>>>            Move SQL_VARBINARY      to ColumnType[i].iType
91735>>>>>>>            Move "varbinary"        to ColumnType[i].sType
91736>>>>>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
91737>>>>>>>            Move "BINARY"           to ColumnType[i].sDataFlexType
91738>>>>>>>            Move "16384"            to ColumnType[i].sPrecision
91739>>>>>>>            Increment i
91740>>>>>>>
91740>>>>>>>            Move SQL_LONGVARBINARY  to ColumnType[i].iType
91741>>>>>>>            Move "varbinary(max)"   to ColumnType[i].sType
91742>>>>>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
91743>>>>>>>            Move "BINARY"           to ColumnType[i].sDataFlexType
91744>>>>>>>            Move "16384"            to ColumnType[i].sPrecision
91745>>>>>>>            Move True               to ColumnType[i].bFixedSize
91746>>>>>>>            Increment i
91747>>>>>>>
91747>>>>>>>            Move SQL_VARCHAR        to ColumnType[i].iType
91748>>>>>>>            Move "varchar"          to ColumnType[i].sType
91749>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
91750>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91751>>>>>>>            Move "8000"             to ColumnType[i].sPrecision
91752>>>>>>>            Increment i
91753>>>>>>>
91753>>>>>>>            Move SQL_LONGVARCHAR    to ColumnType[i].iType
91754>>>>>>>            Move "varchar(max)"     to ColumnType[i].sType
91755>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91756>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91757>>>>>>>            Move "16384"            to ColumnType[i].sPrecision
91758>>>>>>>            Move True               to ColumnType[i].bFixedSize
91759>>>>>>>            Increment i
91760>>>>>>>
91760>>>>>>>            Move SQL_SS_XML         to ColumnType[i].iType
91761>>>>>>>            Move "xml"              to ColumnType[i].sType
91762>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91763>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91764>>>>>>>            Move "16384"            to ColumnType[i].sPrecision
91765>>>>>>>            Increment i
91766>>>>>>>
91766>>>>>>>            Move SQL_TYPE_DATE      to ColumnType[i].iType
91767>>>>>>>            Move "DATE"             to ColumnType[i].sType
91768>>>>>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
91769>>>>>>>            Move "date"             to ColumnType[i].sDataFlexType
91770>>>>>>>            Move "6.0"              to ColumnType[i].sPrecision
91771>>>>>>>            Move True               to ColumnType[i].bFixedSize
91772>>>>>>>            Increment i
91773>>>>>>>
91773>>>>>>>            Move SQL_TYPE_TIME      to ColumnType[i].iType
91774>>>>>>>            Move "time"             to ColumnType[i].sType
91775>>>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91776>>>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91777>>>>>>>            Move "8.7"              to ColumnType[i].sPrecision
91778>>>>>>>            Move True               to ColumnType[i].bFixedSize
91779>>>>>>>            Increment i
91780>>>>>>>
91780>>>>>>>            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iType
91781>>>>>>>            Move "datetime"         to ColumnType[i].sType
91782>>>>>>>            Move DF_DATETIME        to ColumnType[i].iDataFlexType
91783>>>>>>>            Move "DateTime"         to ColumnType[i].sDataFlexType
91784>>>>>>>            Move "23.6"             to ColumnType[i].sPrecision
91785>>>>>>>            Move True               to ColumnType[i].bFixedSize
91786>>>>>>>            Increment i
91787>>>>>>>
91787>>>>>>>        End
91787>>>>>>>>
91787>>>>>>>
91787>>>>>>>        // Mertech SQLFlex driver
91787>>>>>>>        If (sDriverID = SQLFLEX) Begin
91789>>>>>>>            Move eSQLServer_BIGINT  to ColumnType[i].iType
91790>>>>>>>            Move "BigInt"           to ColumnType[i].sType
91791>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91792>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91793>>>>>>>            Move "14.0"             to ColumnType[i].sPrecision
91794>>>>>>>            Move True               to ColumnType[i].bFixedSize
91795>>>>>>>            Increment i
91796>>>>>>>
91796>>>>>>>            Move eSQLServer_BINARY  to ColumnType[i].iType
91797>>>>>>>            Move "Binary"           to ColumnType[i].sType
91798>>>>>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
91799>>>>>>>            Move "Binary"           to ColumnType[i].sDataFlexType
91800>>>>>>>            Move "8000"             to ColumnType[i].sPrecision
91801>>>>>>>            Increment i
91802>>>>>>>
91802>>>>>>>            Move eSQLServer_BIT     to ColumnType[i].iType
91803>>>>>>>            Move "Bit"              to ColumnType[i].sType
91804>>>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91805>>>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91806>>>>>>>            Move "1.0"              to ColumnType[i].sPrecision
91807>>>>>>>            Move True               to ColumnType[i].bFixedSize // In SQL allows 1, 0, or "NULL"
91808>>>>>>>            Increment i
91809>>>>>>>
91809>>>>>>>            Move eSQLServer_CHAR    to ColumnType[i].iType
91810>>>>>>>            Move "Char"             to ColumnType[i].sType
91811>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91812>>>>>>>            Move "Text"             to ColumnType[i].sDataFlexType
91813>>>>>>>            Move "8000"             to ColumnType[i].sPrecision
91814>>>>>>>            Increment i
91815>>>>>>>
91815>>>>>>>            Move eSQLServer_DATE    to ColumnType[i].iType
91816>>>>>>>            Move "Date"             to ColumnType[i].sType
91817>>>>>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
91818>>>>>>>            Move "Date"             to ColumnType[i].sDataFlexType
91819>>>>>>>            Move "6.0"              to ColumnType[i].sPrecision
91820>>>>>>>            Move True               to ColumnType[i].bFixedSize
91821>>>>>>>            Increment i
91822>>>>>>>
91822>>>>>>>            Move eSQLServer_DATETIME    to ColumnType[i].iType
91823>>>>>>>            Move "DateTime"             to ColumnType[i].sType
91824>>>>>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
91825>>>>>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
91826>>>>>>>            Move "23.3"                 to ColumnType[i].sPrecision
91827>>>>>>>            Move True                   to ColumnType[i].bFixedSize
91828>>>>>>>            Increment i
91829>>>>>>>
91829>>>>>>>            Move eSQLServer_DATETIME2   to ColumnType[i].iType
91830>>>>>>>            Move "DateTime2"            to ColumnType[i].sType
91831>>>>>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
91832>>>>>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
91833>>>>>>>            Move "23.6"                 to ColumnType[i].sPrecision
91834>>>>>>>            Move True                   to ColumnType[i].bFixedSize
91835>>>>>>>            Increment i
91836>>>>>>>
91836>>>>>>>            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iType
91837>>>>>>>            Move "DateTimeOffest"           to ColumnType[i].sType
91838>>>>>>>            Move DF_DATETIME                to ColumnType[i].iDataFlexType
91839>>>>>>>            Move "DateTime"                 to ColumnType[i].sDataFlexType
91840>>>>>>>            Move "23.0"                     to ColumnType[i].sPrecision
91841>>>>>>>            Move True                       to ColumnType[i].bFixedSize
91842>>>>>>>            Increment i
91843>>>>>>>
91843>>>>>>>            Move eSQLServer_DECIMAL to ColumnType[i].iType
91844>>>>>>>            Move "Decimal"          to ColumnType[i].sType
91845>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91846>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91847>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91848>>>>>>>            Increment i
91849>>>>>>>
91849>>>>>>>            Move eSQLServer_DOUBLE  to ColumnType[i].iType
91850>>>>>>>            Move "Double"           to ColumnType[i].sType
91851>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91852>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91853>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91854>>>>>>>            Increment i
91855>>>>>>>
91855>>>>>>>            Move eSQLServer_FLOAT   to ColumnType[i].iType
91856>>>>>>>            Move "Float"            to ColumnType[i].sType
91857>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91858>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91859>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91860>>>>>>>            Increment i
91861>>>>>>>
91861>>>>>>>            Move eSQLServer_INT     to ColumnType[i].iType
91862>>>>>>>            Move "Int"              to ColumnType[i].sType
91863>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91864>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91865>>>>>>>            Move "11.0"             to ColumnType[i].sPrecision
91866>>>>>>>            Increment i
91867>>>>>>>
91867>>>>>>>            Move eSQLServer_NCHAR   to ColumnType[i].iType
91868>>>>>>>            Move "Nchar"            to ColumnType[i].sType
91869>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91870>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91871>>>>>>>            Move "4000"             to ColumnType[i].sPrecision
91872>>>>>>>            Increment i
91873>>>>>>>
91873>>>>>>>            Move eSQLServer_NTEXT   to ColumnType[i].iType
91874>>>>>>>            Move "Ntext"            to ColumnType[i].sType
91875>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91876>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91877>>>>>>>            Move "16384"            to ColumnType[i].sPrecision
91878>>>>>>>            Increment i
91879>>>>>>>
91879>>>>>>>            Move eSQLServer_NUMERIC to ColumnType[i].iType
91880>>>>>>>            Move "Numeric"          to ColumnType[i].sType
91881>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91882>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91883>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91884>>>>>>>            Increment i
91885>>>>>>>
91885>>>>>>>            Move eSQLServer_NVARCHAR    to ColumnType[i].iType
91886>>>>>>>            Move "NvarChar"             to ColumnType[i].sType
91887>>>>>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
91888>>>>>>>            Move "Text"                 to ColumnType[i].sDataFlexType
91889>>>>>>>            Move "4000"                 to ColumnType[i].sPrecision
91890>>>>>>>            Increment i
91891>>>>>>>
91891>>>>>>>            Move eSQLServer_NVARCHARMAX to ColumnType[i].iType
91892>>>>>>>            Move "NvarCharMax"          to ColumnType[i].sType
91893>>>>>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
91894>>>>>>>            Move "Text"                 to ColumnType[i].sDataFlexType
91895>>>>>>>            Move "16384"                to ColumnType[i].sPrecision
91896>>>>>>>            Move True                   to ColumnType[i].bFixedSize
91897>>>>>>>            Increment i
91898>>>>>>>
91898>>>>>>>            Move eSQLServer_REAL    to ColumnType[i].iType
91899>>>>>>>            Move "Real"             to ColumnType[i].sType
91900>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91901>>>>>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
91902>>>>>>>            Move "14.8"             to ColumnType[i].sPrecision
91903>>>>>>>            Increment i
91904>>>>>>>
91904>>>>>>>            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iType
91905>>>>>>>            Move "SmallDateTime"            to ColumnType[i].sType
91906>>>>>>>            Move DF_DATETIME                to ColumnType[i].iDataFlexType
91907>>>>>>>            Move "DATETIME"                 to ColumnType[i].sDataFlexType
91908>>>>>>>            Move "23.0"                     to ColumnType[i].sPrecision
91909>>>>>>>            Move True                       to ColumnType[i].bFixedSize
91910>>>>>>>            Increment i
91911>>>>>>>
91911>>>>>>>            Move eSQLServer_SMALLINT    to ColumnType[i].iType
91912>>>>>>>            Move "SmallInt"             to ColumnType[i].sType
91913>>>>>>>            Move DF_BCD                 to ColumnType[i].iDataFlexType
91914>>>>>>>            Move "NUMERIC"              to ColumnType[i].sDataFlexType
91915>>>>>>>            Move "6.0"                  to ColumnType[i].sPrecision
91916>>>>>>>            Increment i
91917>>>>>>>
91917>>>>>>>            Move eSQLServer_TEXT    to ColumnType[i].iType
91918>>>>>>>            Move "Text"             to ColumnType[i].sType
91919>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91920>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91921>>>>>>>            Move "8000"             to ColumnType[i].sPrecision
91922>>>>>>>            Move True               to ColumnType[i].bFixedSize
91923>>>>>>>            Increment i
91924>>>>>>>
91924>>>>>>>            Move eSQLServer_TIME    to ColumnType[i].iType
91925>>>>>>>            Move "Time"             to ColumnType[i].sType
91926>>>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91927>>>>>>>            Move "Date"             to ColumnType[i].sDataFlexType
91928>>>>>>>            Move "16.0"             to ColumnType[i].sPrecision
91929>>>>>>>            Move True               to ColumnType[i].bFixedSize
91930>>>>>>>            Increment i
91931>>>>>>>
91931>>>>>>>            Move eSQLServer_TIMESTAMP   to ColumnType[i].iType
91932>>>>>>>            Move "TimeStamp"            to ColumnType[i].sType
91933>>>>>>>            Move DF_ASCII               to ColumnType[i].iDataFlexType
91934>>>>>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
91935>>>>>>>            Move "8.0"                  to ColumnType[i].sPrecision
91936>>>>>>>            Move True                   to ColumnType[i].bFixedSize
91937>>>>>>>            Increment i
91938>>>>>>>
91938>>>>>>>            Move eSQLServer_TINYINT to ColumnType[i].iType
91939>>>>>>>            Move "TinyInt"          to ColumnType[i].sType
91940>>>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91941>>>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91942>>>>>>>            Move "3.0"              to ColumnType[i].sPrecision
91943>>>>>>>            Increment i
91944>>>>>>>
91944>>>>>>>            Move eSQLServer_GUID    to ColumnType[i].iType
91945>>>>>>>            Move "UniqueIdentifier" to ColumnType[i].sType
91946>>>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91947>>>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91948>>>>>>>            Move "38"               to ColumnType[i].sPrecision
91949>>>>>>>            Move True               to ColumnType[i].bFixedSize
91950>>>>>>>            Increment i
91951>>>>>>>
91951>>>>>>>            Move eSQLServer_VARBINARY   to ColumnType[i].iType
91952>>>>>>>            Move "VarBinary"            to ColumnType[i].sType
91953>>>>>>>            Move DF_BINARY              to ColumnType[i].iDataFlexType
91954>>>>>>>            Move "BINARY"               to ColumnType[i].sDataFlexType
91955>>>>>>>            Move "8000"                 to ColumnType[i].sPrecision
91956>>>>>>>            Increment i
91957>>>>>>>
91957>>>>>>>            Move eSQLServer_VARBINARYMAX to ColumnType[i].iType
91958>>>>>>>            Move "VarBinary(Max)"        to ColumnType[i].sType
91959>>>>>>>            Move DF_BINARY               to ColumnType[i].iDataFlexType
91960>>>>>>>            Move "BINARY"                to ColumnType[i].sDataFlexType
91961>>>>>>>            Move "16384"                 to ColumnType[i].sPrecision
91962>>>>>>>            Move True                    to ColumnType[i].bFixedSize
91963>>>>>>>            Increment i
91964>>>>>>>
91964>>>>>>>            Move eSQLServer_VARCHAR to ColumnType[i].iType
91965>>>>>>>            Move "VarChar"          to ColumnType[i].sType
91966>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
91967>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91968>>>>>>>            Move "8000"             to ColumnType[i].sPrecision
91969>>>>>>>            Increment i
91970>>>>>>>
91970>>>>>>>            Move eSQLServer_VARCHARMAX  to ColumnType[i].iType
91971>>>>>>>            Move "VarChar(Max)"         to ColumnType[i].sType
91972>>>>>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
91973>>>>>>>            Move "TEXT"                 to ColumnType[i].sDataFlexType
91974>>>>>>>            Move "16384"                to ColumnType[i].sPrecision
91975>>>>>>>            Move True                   to ColumnType[i].bFixedSize
91976>>>>>>>            Increment i
91977>>>>>>>
91977>>>>>>>            Move eSQLServer_SQLVARIANT  to ColumnType[i].iType
91978>>>>>>>            Move "SQL_Variant"          to ColumnType[i].sType
91979>>>>>>>            Move DF_BINARY              to ColumnType[i].iDataFlexType
91980>>>>>>>            Move "Binary"               to ColumnType[i].sDataFlexType
91981>>>>>>>            Move "8016"                 to ColumnType[i].sPrecision
91982>>>>>>>            Move True                   to ColumnType[i].bFixedSize
91983>>>>>>>            Increment i
91984>>>>>>>
91984>>>>>>>            Move eSQLServer_XML     to ColumnType[i].iType
91985>>>>>>>            Move "XML"              to ColumnType[i].sType
91986>>>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91987>>>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91988>>>>>>>            Move "16384"            to ColumnType[i].sPrecision
91989>>>>>>>        End
91989>>>>>>>>
91989>>>>>>>
91989>>>>>>>        Function_Return ColumnType
91990>>>>>>>    End_Function
91991>>>>>>>
91991>>>>>>>    // MySQL Data Types
91991>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
91993>>>>>>>        tColumnType[] ColumnType
91993>>>>>>>        tColumnType[] ColumnType
91994>>>>>>>        Integer i
91994>>>>>>>
91994>>>>>>>        Move eMySQL_LONGLONG    to ColumnType[i].iType
91995>>>>>>>        Move "bigint"           to ColumnType[i].sType
91996>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91997>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91998>>>>>>>        Move "14.0"             to ColumnType[i].sPrecision
91999>>>>>>>        Increment i
92000>>>>>>>
92000>>>>>>>        Move eMySQL_BIT         to ColumnType[i].iType
92001>>>>>>>        Move "bit"              to ColumnType[i].sType
92002>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92003>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92004>>>>>>>        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
92005>>>>>>>        Move True               to ColumnType[i].bFixedSize
92006>>>>>>>        Increment i
92007>>>>>>>
92007>>>>>>>        Move eMySQL_BLOB        to ColumnType[i].iType
92008>>>>>>>        Move "blob"             to ColumnType[i].sType
92009>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92010>>>>>>>        Move "BINARY"           to ColumnType[i].sDataFlexType
92011>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92012>>>>>>>        Increment i
92013>>>>>>>
92013>>>>>>>        Move eMySQL_STRING      to ColumnType[i].iType
92014>>>>>>>        Move "char"             to ColumnType[i].sType
92015>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92016>>>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
92017>>>>>>>        Move "254"              to ColumnType[i].sPrecision
92018>>>>>>>        Increment i
92019>>>>>>>
92019>>>>>>>        Move eMySQL_DATE        to ColumnType[i].iType
92020>>>>>>>        Move "date"             to ColumnType[i].sType
92021>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
92022>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
92023>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
92024>>>>>>>        Move True               to ColumnType[i].bFixedSize
92025>>>>>>>        Increment i
92026>>>>>>>
92026>>>>>>>        Move eMySQL_DATETIME    to ColumnType[i].iType
92027>>>>>>>        Move "datetime"         to ColumnType[i].sType
92028>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92029>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92030>>>>>>>        Move "23.0"             to ColumnType[i].sPrecision
92031>>>>>>>        Move True               to ColumnType[i].bFixedSize
92032>>>>>>>        Increment i
92033>>>>>>>
92033>>>>>>>        Move eMySQL_DECIMAL     to ColumnType[i].iType
92034>>>>>>>        Move "decimal"          to ColumnType[i].sType
92035>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92036>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92037>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
92038>>>>>>>        Increment i
92039>>>>>>>
92039>>>>>>>        Move eMySQL_DOUBLE      to ColumnType[i].iType
92040>>>>>>>        Move "double"           to ColumnType[i].sType
92041>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92042>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92043>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
92044>>>>>>>        Increment i
92045>>>>>>>
92045>>>>>>>        Move eMySQL_ENUM        to ColumnType[i].iType
92046>>>>>>>        Move "enum"             to ColumnType[i].sType
92047>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92048>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92049>>>>>>>        Move "254"              to ColumnType[i].sPrecision
92050>>>>>>>        Increment i
92051>>>>>>>
92051>>>>>>>        Move eMySQL_FLOAT       to ColumnType[i].iType
92052>>>>>>>        Move "float"            to ColumnType[i].sType
92053>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92054>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92055>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
92056>>>>>>>        Increment i
92057>>>>>>>
92057>>>>>>>        Move eMySQL_INT24       to ColumnType[i].iType
92058>>>>>>>        Move "int"              to ColumnType[i].sType
92059>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92060>>>>>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
92061>>>>>>>        Move "11.0"             to ColumnType[i].sPrecision
92062>>>>>>>        Increment i
92063>>>>>>>
92063>>>>>>>        Move eMySQL_LONG_BLOB   to ColumnType[i].iType
92064>>>>>>>        Move "longblob"         to ColumnType[i].sType
92065>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92066>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92067>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92068>>>>>>>        Increment i
92069>>>>>>>
92069>>>>>>>        Move eMySQL_LONG_TEXT   to ColumnType[i].iType
92070>>>>>>>        Move "longtext"         to ColumnType[i].sType
92071>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92072>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92073>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92074>>>>>>>        Increment i
92075>>>>>>>
92075>>>>>>>        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iType
92076>>>>>>>        Move "mediumblob"       to ColumnType[i].sType
92077>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92078>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92079>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92080>>>>>>>        Increment i
92081>>>>>>>
92081>>>>>>>        Move eMySQL_INT24       to ColumnType[i].iType
92082>>>>>>>        Move "mediumint"        to ColumnType[i].sType
92083>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92084>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92085>>>>>>>        Move "9.0"              to ColumnType[i].sPrecision
92086>>>>>>>
92086>>>>>>>        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iType
92087>>>>>>>        Move "mediumtext"       to ColumnType[i].sType
92088>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92089>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92090>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92091>>>>>>>        Increment i
92092>>>>>>>
92092>>>>>>>        Move eMySQL_SET         to ColumnType[i].iType
92093>>>>>>>        Move "set"              to ColumnType[i].sType
92094>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92095>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92096>>>>>>>        Move "254"              to ColumnType[i].sPrecision
92097>>>>>>>        Increment i
92098>>>>>>>
92098>>>>>>>        Move eMySQL_SHORT       to ColumnType[i].iType
92099>>>>>>>        Move "smallint"         to ColumnType[i].sType
92100>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92101>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92102>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
92103>>>>>>>        Increment i
92104>>>>>>>
92104>>>>>>>        Move eMySQL_TEXT        to ColumnType[i].iType
92105>>>>>>>        Move "text"             to ColumnType[i].sType
92106>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92107>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92108>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92109>>>>>>>        Increment i
92110>>>>>>>
92110>>>>>>>        Move eMySQL_TIME        to ColumnType[i].iType
92111>>>>>>>        Move "time"             to ColumnType[i].sType
92112>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92113>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92114>>>>>>>        Move "10.0"             to ColumnType[i].sPrecision
92115>>>>>>>        Move True               to ColumnType[i].bFixedSize
92116>>>>>>>        Increment i
92117>>>>>>>
92117>>>>>>>        Move eMySQL_TIMESTAMP   to ColumnType[i].iType
92118>>>>>>>        Move "timestamp"        to ColumnType[i].sType
92119>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92120>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92121>>>>>>>        Move "23.0"             to ColumnType[i].sPrecision
92122>>>>>>>        Move True               to ColumnType[i].bFixedSize
92123>>>>>>>        Increment i
92124>>>>>>>
92124>>>>>>>        Move eMySQL_TINY_BLOB   to ColumnType[i].iType
92125>>>>>>>        Move "tinyblob"         to ColumnType[i].sType
92126>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92127>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92128>>>>>>>        Move "254"              to ColumnType[i].sPrecision
92129>>>>>>>        Increment i
92130>>>>>>>
92130>>>>>>>        Move eMySQL_TINY        to ColumnType[i].iType
92131>>>>>>>        Move "tinyint"          to ColumnType[i].sType
92132>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92133>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92134>>>>>>>        Move "4.0"              to ColumnType[i].sPrecision
92135>>>>>>>        Increment i
92136>>>>>>>
92136>>>>>>>        Move eMySQL_TINY_TEXT   to ColumnType[i].iType
92137>>>>>>>        Move "tinytext"         to ColumnType[i].sType
92138>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92139>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92140>>>>>>>        Move "254"              to ColumnType[i].sPrecision
92141>>>>>>>        Increment i
92142>>>>>>>
92142>>>>>>>        Move eMySQL_VAR_STRING  to ColumnType[i].iType
92143>>>>>>>        Move "varchar"          to ColumnType[i].sType
92144>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92145>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92146>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92147>>>>>>>        Increment i
92148>>>>>>>
92148>>>>>>>        Move eMySQL_YEAR        to ColumnType[i].iType
92149>>>>>>>        Move "year"             to ColumnType[i].sType
92150>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92151>>>>>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
92152>>>>>>>        Move "4.0"              to ColumnType[i].sPrecision
92153>>>>>>>        Move True               to ColumnType[i].bFixedSize
92154>>>>>>>        Increment i
92155>>>>>>>
92155>>>>>>>        Function_Return ColumnType
92156>>>>>>>    End_Function
92157>>>>>>>
92157>>>>>>>    // Oracle Data Types
92157>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
92159>>>>>>>        tColumnType[] ColumnType
92159>>>>>>>        tColumnType[] ColumnType
92160>>>>>>>        Integer i
92160>>>>>>>
92160>>>>>>>        Move eOracle_BLOB       to ColumnType[i].iType
92161>>>>>>>        Move "BLOB"             to ColumnType[i].sType
92162>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92163>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92164>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92165>>>>>>>        Increment i
92166>>>>>>>
92166>>>>>>>        Move eOracle_CHAR       to ColumnType[i].iType
92167>>>>>>>        Move "CHAR"             to ColumnType[i].sType
92168>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92169>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92170>>>>>>>        Move "2000"             to ColumnType[i].sPrecision
92171>>>>>>>        Increment i
92172>>>>>>>
92172>>>>>>>        Move eOracle_CLOB       to ColumnType[i].iType
92173>>>>>>>        Move "CLOB"             to ColumnType[i].sType
92174>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92175>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92176>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92177>>>>>>>        Increment i
92178>>>>>>>
92178>>>>>>>        Move eOracle_DATE       to ColumnType[i].iType
92179>>>>>>>        Move "DATE"             to ColumnType[i].sType
92180>>>>>>>        Move DF_Date            to ColumnType[i].iDataFlexType
92181>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
92182>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
92183>>>>>>>        Move True               to ColumnType[i].bFixedSize
92184>>>>>>>        Increment i
92185>>>>>>>
92185>>>>>>>        Move eOracle_FLOAT      to ColumnType[i].iType
92186>>>>>>>        Move "FLOAT"            to ColumnType[i].sType
92187>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92188>>>>>>>        Move "Number"           to ColumnType[i].sDataFlexType
92189>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
92190>>>>>>>        Increment i
92191>>>>>>>
92191>>>>>>>        Move eOracle_INT        to ColumnType[i].iType
92192>>>>>>>        Move "INT"              to ColumnType[i].sType
92193>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92194>>>>>>>        Move "Number"           to ColumnType[i].sDataFlexType
92195>>>>>>>        Move "14.0"             to ColumnType[i].sPrecision
92196>>>>>>>        Increment i
92197>>>>>>>
92197>>>>>>>        Move eOracle_INTERVALDS to ColumnType[i].iType
92198>>>>>>>        Move "INTERVALDAYTOSEC" to ColumnType[i].sType
92199>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92200>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92201>>>>>>>        Move "23.0"             to ColumnType[i].sPrecision
92202>>>>>>>        Move True               to ColumnType[i].bFixedSize
92203>>>>>>>        Increment i
92204>>>>>>>
92204>>>>>>>        Move eOracle_INTERVALYM  to ColumnType[i].iType
92205>>>>>>>        Move "INTERVALYEARTOMON" to ColumnType[i].sType
92206>>>>>>>        Move DF_DATETIME         to ColumnType[i].iDataFlexType
92207>>>>>>>        Move "DateTime"          to ColumnType[i].sDataFlexType
92208>>>>>>>        Move "23.0"              to ColumnType[i].sPrecision
92209>>>>>>>        Move True                to ColumnType[i].bFixedSize
92210>>>>>>>        Increment i
92211>>>>>>>
92211>>>>>>>        Move eOracle_RAW        to ColumnType[i].iType
92212>>>>>>>        Move "LONG"             to ColumnType[i].sType
92213>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92214>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92215>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92216>>>>>>>        Increment i
92217>>>>>>>
92217>>>>>>>        Move eOracle_LONGRAW    to ColumnType[i].iType
92218>>>>>>>        Move "LONG RAW"         to ColumnType[i].sType
92219>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92220>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92221>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92222>>>>>>>        Increment i
92223>>>>>>>
92223>>>>>>>        Move eOracle_NCHAR      to ColumnType[i].iType
92224>>>>>>>        Move "NCHAR"            to ColumnType[i].sType
92225>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92226>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92227>>>>>>>        Move "2000"             to ColumnType[i].sPrecision
92228>>>>>>>        Increment i
92229>>>>>>>
92229>>>>>>>        Move eOracle_NCLOB      to ColumnType[i].iType
92230>>>>>>>        Move "NCLOB"            to ColumnType[i].sType
92231>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92232>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92233>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92234>>>>>>>        Increment i
92235>>>>>>>
92235>>>>>>>        Move eOracle_NUMBER     to ColumnType[i].iType
92236>>>>>>>        Move "NUMBER"           to ColumnType[i].sType
92237>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92238>>>>>>>        Move "Number"           to ColumnType[i].sDataFlexType
92239>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
92240>>>>>>>        Increment i
92241>>>>>>>
92241>>>>>>>        Move eOracle_NVARCHAR2  to ColumnType[i].iType
92242>>>>>>>        Move "NVARCHAR2"        to ColumnType[i].sType
92243>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92244>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92245>>>>>>>        Move "4000"             to ColumnType[i].sPrecision
92246>>>>>>>        Increment i
92247>>>>>>>
92247>>>>>>>        Move eOracle_RAW        to ColumnType[i].iType
92248>>>>>>>        Move "RAW"              to ColumnType[i].sType
92249>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92250>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92251>>>>>>>        Move "2000"             to ColumnType[i].sPrecision
92252>>>>>>>        Increment i
92253>>>>>>>
92253>>>>>>>        Move eOracle_ROWID      to ColumnType[i].iType
92254>>>>>>>        Move "ROWID"            to ColumnType[i].sType
92255>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92256>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92257>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92258>>>>>>>        Increment i
92259>>>>>>>
92259>>>>>>>        Move eOracle_TIMESTAMP  to ColumnType[i].iType
92260>>>>>>>        Move "TimeStamp"        to ColumnType[i].sType
92261>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92262>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92263>>>>>>>        Move "11.0"             to ColumnType[i].sPrecision
92264>>>>>>>        Move True               to ColumnType[i].bFixedSize
92265>>>>>>>        Increment i
92266>>>>>>>
92266>>>>>>>        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iType
92267>>>>>>>        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sType
92268>>>>>>>        Move DF_DATETIME            to ColumnType[i].iDataFlexType
92269>>>>>>>        Move "DateTime"             to ColumnType[i].sDataFlexType
92270>>>>>>>        Move "13.0"                 to ColumnType[i].sPrecision
92271>>>>>>>        Move True                   to ColumnType[i].bFixedSize
92272>>>>>>>        Increment i
92273>>>>>>>
92273>>>>>>>        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iType
92274>>>>>>>        Move "TIMEZONETIMEZONE"     to ColumnType[i].sType
92275>>>>>>>        Move DF_DATETIME            to ColumnType[i].iDataFlexType
92276>>>>>>>        Move "DateTime"             to ColumnType[i].sDataFlexType
92277>>>>>>>        Move "11.0"                 to ColumnType[i].sPrecision
92278>>>>>>>        Move True                   to ColumnType[i].bFixedSize
92279>>>>>>>        Increment i
92280>>>>>>>
92280>>>>>>>        Move eOracle_VARCHAR2   to ColumnType[i].iType
92281>>>>>>>        Move "VARCHAR"          to ColumnType[i].sType
92282>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92283>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92284>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92285>>>>>>>
92285>>>>>>>        Function_Return ColumnType
92286>>>>>>>    End_Function
92287>>>>>>>
92287>>>>>>>    // PostgreSQL Data Types
92287>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
92289>>>>>>>        tColumnType[] ColumnType
92289>>>>>>>        tColumnType[] ColumnType
92290>>>>>>>        Integer i
92290>>>>>>>
92290>>>>>>>        Move ePgSQL_INT8        to ColumnType[i].iType
92291>>>>>>>        Move "bigint"           to ColumnType[i].sType
92292>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92293>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92294>>>>>>>        Move "14.0"             to ColumnType[i].sPrecision
92295>>>>>>>        Move True               to ColumnType[i].bFixedSize
92296>>>>>>>        Increment i
92297>>>>>>>
92297>>>>>>>        Move ePgSQL_BIT         to ColumnType[i].iType
92298>>>>>>>        Move "bit"              to ColumnType[i].sType
92299>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92300>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92301>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92302>>>>>>>        Increment i
92303>>>>>>>
92303>>>>>>>        Move ePgSQL_BOOL        to ColumnType[i].iType
92304>>>>>>>        Move "boolean"          to ColumnType[i].sType
92305>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92306>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92307>>>>>>>        Move "1"                to ColumnType[i].sPrecision
92308>>>>>>>        Increment i
92309>>>>>>>
92309>>>>>>>        Move ePgSQL_BYTEA       to ColumnType[i].iType
92310>>>>>>>        Move "bytea"            to ColumnType[i].sType
92311>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92312>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92313>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92314>>>>>>>        Increment i
92315>>>>>>>
92315>>>>>>>        Move ePgSQL_CHAR        to ColumnType[i].iType
92316>>>>>>>        Move "char"             to ColumnType[i].sType
92317>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92318>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92319>>>>>>>        Move "2000"             to ColumnType[i].sPrecision
92320>>>>>>>        Increment i
92321>>>>>>>
92321>>>>>>>        Move ePgSQL_CITEXT      to ColumnType[i].iType
92322>>>>>>>        Move "citext"           to ColumnType[i].sType
92323>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92324>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92325>>>>>>>        Move "254"              to ColumnType[i].sPrecision
92326>>>>>>>        Increment i
92327>>>>>>>
92327>>>>>>>        Move ePgSQL_DATE        to ColumnType[i].iType
92328>>>>>>>        Move "date"             to ColumnType[i].sType
92329>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
92330>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
92331>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
92332>>>>>>>        Move True               to ColumnType[i].bFixedSize
92333>>>>>>>        Increment i
92334>>>>>>>
92334>>>>>>>        Move ePgSQL_FLOAT4      to ColumnType[i].iType
92335>>>>>>>        Move "decimal"          to ColumnType[i].sType
92336>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92337>>>>>>>        Move "Decimal"          to ColumnType[i].sDataFlexType
92338>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
92339>>>>>>>        Increment i
92340>>>>>>>
92340>>>>>>>        Move ePgSQL_FLOAT8      to ColumnType[i].iType
92341>>>>>>>        Move "double"           to ColumnType[i].sType
92342>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92343>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92344>>>>>>>        Move "22"               to ColumnType[i].sPrecision
92345>>>>>>>        Increment i
92346>>>>>>>
92346>>>>>>>        Move ePgSQL_INT4        to ColumnType[i].iType
92347>>>>>>>        Move "integer"          to ColumnType[i].sType
92348>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92349>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92350>>>>>>>        Move "8.0"              to ColumnType[i].sPrecision
92351>>>>>>>        Increment i
92352>>>>>>>
92352>>>>>>>        Move ePgSQL_MONEY       to ColumnType[i].iType
92353>>>>>>>        Move "money"            to ColumnType[i].sType
92354>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92355>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92356>>>>>>>        Move "8.0"              to ColumnType[i].sPrecision
92357>>>>>>>        Increment i
92358>>>>>>>
92358>>>>>>>        Move ePgSQL_OID         to ColumnType[i].iType
92359>>>>>>>        Move "oid"              to ColumnType[i].sType
92360>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92361>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92362>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92363>>>>>>>        Increment i
92364>>>>>>>
92364>>>>>>>        Move ePgSQL_FLOAT4      to ColumnType[i].iType
92365>>>>>>>        Move "real"             to ColumnType[i].sType
92366>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92367>>>>>>>        Move "Real"             to ColumnType[i].sDataFlexType
92368>>>>>>>        Move "6.6"              to ColumnType[i].sPrecision
92369>>>>>>>        Increment i
92370>>>>>>>
92370>>>>>>>        Move ePgSQL_REGPROC     to ColumnType[i].iType
92371>>>>>>>        Move "regproc"          to ColumnType[i].sType
92372>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92373>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92374>>>>>>>        Move "64"               to ColumnType[i].sPrecision
92375>>>>>>>        Increment i
92376>>>>>>>
92376>>>>>>>        Move ePgSQL_INT2        to ColumnType[i].iType
92377>>>>>>>        Move "smallint"         to ColumnType[i].sType
92378>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92379>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92380>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
92381>>>>>>>        Increment i
92382>>>>>>>
92382>>>>>>>        Move ePgSQL_TEXT        to ColumnType[i].iType
92383>>>>>>>        Move "text"             to ColumnType[i].sType
92384>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92385>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92386>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92387>>>>>>>        Increment i
92388>>>>>>>
92388>>>>>>>        Move ePgSQL_TIME        to ColumnType[i].iType
92389>>>>>>>        Move "time"             to ColumnType[i].sType
92390>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92391>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92392>>>>>>>        Move "15.0"             to ColumnType[i].sPrecision
92393>>>>>>>        Increment i
92394>>>>>>>
92394>>>>>>>        Move ePgSQL_TIMESTAMP   to ColumnType[i].iType
92395>>>>>>>        Move "timestamp"        to ColumnType[i].sType
92396>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92397>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92398>>>>>>>        Move "23.0"             to ColumnType[i].sPrecision
92399>>>>>>>        Move True               to ColumnType[i].bFixedSize
92400>>>>>>>        Increment i
92401>>>>>>>
92401>>>>>>>        Move ePgSQL_UUID        to ColumnType[i].iType
92402>>>>>>>        Move "uuid"             to ColumnType[i].sType
92403>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92404>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92405>>>>>>>        Move "40"               to ColumnType[i].sPrecision
92406>>>>>>>        Move True               to ColumnType[i].bFixedSize
92407>>>>>>>        Increment i
92408>>>>>>>
92408>>>>>>>        Move ePgSQL_VARCHAR     to ColumnType[i].iType
92409>>>>>>>        Move "varchar"          to ColumnType[i].sType
92410>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92411>>>>>>>        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
92412>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92413>>>>>>>        Increment i
92414>>>>>>>
92414>>>>>>>        Function_Return ColumnType
92415>>>>>>>    End_Function
92416>>>>>>>
92416>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
92416>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
92418>>>>>>>        Integer iValue iSize iCount iStart iDriverID
92418>>>>>>>        tColumnType[] ColumnTypeArray
92418>>>>>>>        tColumnType[] ColumnTypeArray
92419>>>>>>>        tColumnType RetvalType
92419>>>>>>>        tColumnType RetvalType
92419>>>>>>>        String sValue  
92419>>>>>>>        Boolean bFrameworkDataFlexType
92419>>>>>>>
92419>>>>>>>        Move "Undefined" to RetvalType.sType
92420>>>>>>>        Move -1999       to RetvalType.iType
92421>>>>>>>
92421>>>>>>>        Move 0 to iStart
92422>>>>>>>        Move (Uppercase(sType)) to sType
92423>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
92424>>>>>>>        If (bFrameworkDataFlexType = True) Begin
92426>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
92427>>>>>>>            Function_Return RetvalType
92428>>>>>>>        End
92428>>>>>>>>
92428>>>>>>>
92428>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
92429>>>>>>>
92429>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92430>>>>>>>        Decrement iSize
92431>>>>>>>
92431>>>>>>>        for iCount from iStart to iSize
92437>>>>>>>>
92437>>>>>>>            Move ColumnTypeArray[iCount].iType to iValue
92438>>>>>>>            Move ColumnTypeArray[iCount].sType to sValue
92439>>>>>>>            If (bIntegerInputType = True) Begin
92441>>>>>>>                If (iValue = iType) Begin
92443>>>>>>>                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
92444>>>>>>>                    Move iType                                  to RetvalType.iType
92445>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
92446>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
92447>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
92448>>>>>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
92449>>>>>>>                    Move iSize to iCount // We're done!
92450>>>>>>>                End
92450>>>>>>>>
92450>>>>>>>            End
92450>>>>>>>>
92450>>>>>>>            Else Begin
92451>>>>>>>                Move (Uppercase(sValue)) to sValue
92452>>>>>>>                If (sValue = sType) Begin
92454>>>>>>>                    Move sType                                  to RetvalType.sType
92455>>>>>>>                    Move ColumnTypeArray[iCount].iType          to RetvalType.iType
92456>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
92457>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
92458>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
92459>>>>>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
92460>>>>>>>                    Move iSize to iCount // We're done!
92461>>>>>>>                End
92461>>>>>>>>
92461>>>>>>>            End
92461>>>>>>>>
92461>>>>>>>        Loop            
92462>>>>>>>>
92462>>>>>>>        
92462>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
92462>>>>>>>        // In which case we search for a match in DataFlex standard types:
92462>>>>>>>        If (RetvalType.sType = "Undefined") Begin
92464>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
92465>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
92466>>>>>>>            Decrement iSize
92467>>>>>>>    
92467>>>>>>>            for iCount from iStart to iSize
92473>>>>>>>>
92473>>>>>>>                Move ColumnTypeArray[iCount].iType to iValue
92474>>>>>>>                Move ColumnTypeArray[iCount].sType to sValue
92475>>>>>>>                If (iValue = iType) Begin
92477>>>>>>>                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
92478>>>>>>>                    Move iType                                  to RetvalType.iType
92479>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
92480>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
92481>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
92482>>>>>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
92483>>>>>>>                    Move iSize to iCount // We're done!
92484>>>>>>>                End
92484>>>>>>>>
92484>>>>>>>            Loop    
92485>>>>>>>>
92485>>>>>>>        End
92485>>>>>>>>
92485>>>>>>>
92485>>>>>>>        Function_Return RetvalType
92486>>>>>>>    End_Function
92487>>>>>>>
92487>>>>>>>    Function _AllTablesToConvert Returns Integer[]
92489>>>>>>>        Integer[] iTableConvertExceptions iTablesArray
92491>>>>>>>        Handle hTable
92491>>>>>>>        Integer iIndex
92491>>>>>>>        String sTableName
92491>>>>>>>        Boolean bFlexErrs
92491>>>>>>>
92491>>>>>>>        // a) Get the exception table array the developer has specified
92491>>>>>>>        Get piTableConvertExceptions to iTableConvertExceptions
92492>>>>>>>
92492>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
92492>>>>>>>        Repeat
92492>>>>>>>>
92492>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92495>>>>>>>            If (hTable <> 0) Begin
92497>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92500>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
92501>>>>>>>                If (bFlexErrs = False) Begin
92503>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
92505>>>>>>>                        Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
92506>>>>>>>                        If (iIndex = -1) Begin
92508>>>>>>>                            Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
92509>>>>>>>                        End
92509>>>>>>>>
92509>>>>>>>                    End
92509>>>>>>>>
92509>>>>>>>                End
92509>>>>>>>>
92509>>>>>>>            End
92509>>>>>>>>
92509>>>>>>>        Until (hTable = 0)
92511>>>>>>>
92511>>>>>>>        Move 0 to hTable
92512>>>>>>>
92512>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
92512>>>>>>>        Repeat
92512>>>>>>>>
92512>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92515>>>>>>>            If (hTable > 0) Begin
92517>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92520>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
92521>>>>>>>                If (bFlexErrs = False) Begin
92523>>>>>>>                    Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
92524>>>>>>>                    If (iIndex = -1) Begin
92526>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
92527>>>>>>>                    End
92527>>>>>>>>
92527>>>>>>>                End
92527>>>>>>>>
92527>>>>>>>            End
92527>>>>>>>>
92527>>>>>>>        Until (hTable = 0)
92529>>>>>>>
92529>>>>>>>        Function_Return iTablesArray
92530>>>>>>>    End_Function
92531>>>>>>>
92531>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[] 
92533>>>>>>>        tAPIColumn NewAPIColumn 
92533>>>>>>>        tAPIColumn NewAPIColumn 
92533>>>>>>>        
92533>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
92534>>>>>>>        Move iType      to NewAPIColumn.iType
92535>>>>>>>        Move iLength    to NewAPIColumn.iLength
92536>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
92537>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
92538>>>>>>>        
92538>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
92539>>>>>>>        
92539>>>>>>>        Function_Return aCurrent
92540>>>>>>>    End_Function
92541>>>>>>>
92541>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
92543>>>>>>>        String sRetval sFieldName
92543>>>>>>>        Integer iCount iSize
92543>>>>>>>        
92543>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
92544>>>>>>>        Decrement iSize
92545>>>>>>>        for iCount from 0 to iSize
92551>>>>>>>>
92551>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
92552>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
92553>>>>>>>        Loop                                                
92554>>>>>>>>
92554>>>>>>>        Move (Trim(sRetval)) to sRetval
92555>>>>>>>        
92555>>>>>>>        Function_Return sRetval
92556>>>>>>>    End_Function
92557>>>>>>>
92557>>>>>>>    // *** Miscellaneous other functions ***
92557>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
92557>>>>>>>    //
92557>>>>>>>
92557>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
92557>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
92559>>>>>>>        Integer iRetval iPos iPerc
92559>>>>>>>        String sVal1 sVal2
92559>>>>>>>        Number nReady nTotal
92559>>>>>>>
92559>>>>>>>        Send DoAdvance of ghoProgressBar
92560>>>>>>>
92560>>>>>>>        If (sCallback_Text contains "Copy records") Begin
92562>>>>>>>            Move CS_SQLCopyingData to sCallback_Text
92563>>>>>>>        End
92563>>>>>>>>
92563>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
92565>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
92566>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
92567>>>>>>>        End
92567>>>>>>>>
92567>>>>>>>        If (sCallback_Text contains "Creating index") Begin
92569>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
92570>>>>>>>        End
92570>>>>>>>>
92570>>>>>>>
92570>>>>>>>        Case Begin
92570>>>>>>>            Case (iCallback_Type = DF_Message_Text)
92572>>>>>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
92572>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
92573>>>>>>>                Case Break
92574>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
92577>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92578>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
92579>>>>>>>                Case Break
92580>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
92583>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92584>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
92585>>>>>>>                Case Break
92586>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
92589>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92590>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
92591>>>>>>>                Case Break
92592>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
92595>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92596>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
92597>>>>>>>                Case Break
92598>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
92601>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92602>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
92603>>>>>>>                Case Break
92604>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
92607>>>>>>>                Send None
92608>>>>>>>                Case Break
92609>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
92612>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92613>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
92614>>>>>>>                Case Break
92615>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
92618>>>>>>>                //*** Interpret numbers
92618>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
92619>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
92620>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
92621>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
92622>>>>>>>                Case Break
92623>>>>>>>            Case Else
92623>>>>>>>                Set Message_Text to ""
92624>>>>>>>                Set Action_Text  to ""
92625>>>>>>>        Case End
92625>>>>>>>
92625>>>>>>>        Send ProcessEvents of ghoStatusPanel
92626>>>>>>>        Function_Return False
92627>>>>>>>    End_Function
92628>>>>>>>
92628>>>>>>>    Procedure IncreaseSortBufferSize
92630>>>>>>>        String sNull
92630>>>>>>>        Integer iSortBufferSize
92630>>>>>>>        Boolean bBufferSet
92630>>>>>>>
92630>>>>>>>        Move "" to sNull
92631>>>>>>>        Move (1024 * 128) to iSortBufferSize
92632>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback Self Passing sNull sNull iSortBufferSize Result bBufferSet
92637>>>>>>>
92637>>>>>>>    End_Procedure
92638>>>>>>>
92638>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable
92640>>>>>>>        Integer iLastIndex iIndex iNumSegments iIndexType
92640>>>>>>>        String sTable
92640>>>>>>>        Boolean bOK
92640>>>>>>>        
92640>>>>>>>        If (hTable > 0) Begin
92642>>>>>>>            Close hTable
92643>>>>>>>            Get OpenTableExclusive hTable to bOK
92644>>>>>>>            If (bOK = False) Begin
92646>>>>>>>                Function_Return False
92647>>>>>>>            End
92647>>>>>>>>
92647>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92650>>>>>>>            for iIndex from 1 to iLastIndex
92656>>>>>>>>
92656>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92659>>>>>>>                If (iNumSegments > 0) Begin
92661>>>>>>>                    Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92664>>>>>>>                End
92664>>>>>>>>
92664>>>>>>>            Loop
92665>>>>>>>>
92665>>>>>>>            Close hTable
92666>>>>>>>        End
92666>>>>>>>>
92666>>>>>>>    End_Procedure
92667>>>>>>>
92667>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92669>>>>>>>        Handle hTable
92669>>>>>>>
92669>>>>>>>        Move 0 to hTable
92670>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92673>>>>>>>
92673>>>>>>>        Function_Return hTable
92674>>>>>>>    End_Function
92675>>>>>>>
92675>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92675>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92677>>>>>>>        Integer iCh
92677>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92678>>>>>>>            Write channel iCh sStmt
92680>>>>>>>        Send Seq_Close_Channel iCh
92681>>>>>>>    End_Procedure
92682>>>>>>>
92682>>>>>>>    // Returns the integer number for the passed Driver ID that is
92682>>>>>>>    // needed by some database API calls.
92682>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92684>>>>>>>        String  sCurrentDriver
92684>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92684>>>>>>>
92684>>>>>>>        Move 0 to iDriver
92685>>>>>>>
92685>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92688>>>>>>>        for iCount from 1 to iNumberOfDrivers
92694>>>>>>>>
92694>>>>>>>
92694>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92697>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92699>>>>>>>                Move iCount to iDriver
92700>>>>>>>            End
92700>>>>>>>>
92700>>>>>>>        Loop
92701>>>>>>>>
92701>>>>>>>
92701>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92701>>>>>>>        If (iDriver = 0) Begin
92703>>>>>>>            Move False to Err
92704>>>>>>>            Load_Driver sDriverID
92705>>>>>>>            If (Err = False) Begin
92707>>>>>>>                Move 1 to iDriver
92708>>>>>>>            End
92708>>>>>>>>
92708>>>>>>>        End
92708>>>>>>>>
92708>>>>>>>
92708>>>>>>>        Function_Return iDriver
92709>>>>>>>    End_Function
92710>>>>>>>
92710>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE  
92710>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92710>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92710>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92712>>>>>>>        Integer iMode
92712>>>>>>>        Boolean bOpened bCodeMasterType                        
92712>>>>>>>        String sTableName
92712>>>>>>>        
92712>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92713>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92716>>>>>>>        If (bOpened) Begin
92718>>>>>>>            If (IsDebuggerPresent()) Begin
92720>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92723>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92725>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92726>>>>>>>                    Function_Return True
92727>>>>>>>                End
92727>>>>>>>>
92727>>>>>>>            End
92727>>>>>>>>
92727>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92730>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
92732>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92733>>>>>>>                Function_Return True
92734>>>>>>>            End
92734>>>>>>>>
92734>>>>>>>            Close hTable
92735>>>>>>>        End
92735>>>>>>>>
92735>>>>>>>        Else Begin
92736>>>>>>>            Open hTable
92738>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92741>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92743>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92746>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92748>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92749>>>>>>>                    Function_Return True
92750>>>>>>>                End
92750>>>>>>>>
92750>>>>>>>            End
92750>>>>>>>>
92750>>>>>>>            
92750>>>>>>>        End
92750>>>>>>>>
92750>>>>>>>
92750>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92752>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92755>>>>>>>
92755>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92756>>>>>>>        Function_Return bOpened
92757>>>>>>>    End_Function
92758>>>>>>>    
92758>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92760>>>>>>>        String sConnectionID sConnectionString sDriverID
92760>>>>>>>        Boolean bExists bOK bDAWDriver bSQLDriver
92760>>>>>>>        Handle hoCLI hoDriver
92760>>>>>>>        Integer iRetval
92760>>>>>>>        tSQLConnection SQLConnection
92760>>>>>>>        tSQLConnection SQLConnection
92760>>>>>>>        
92760>>>>>>>        Get psDriverID to sDriverID
92761>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92762>>>>>>>        If (bSQLDriver = False) Begin
92764>>>>>>>            Function_Return True
92765>>>>>>>        End                     
92765>>>>>>>>
92765>>>>>>>        
92765>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92766>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92767>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92768>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
92769>>>>>>>        If (bOK = True) Begin
92771>>>>>>>//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
92771>>>>>>>        End
92771>>>>>>>>
92771>>>>>>>        If (bOK = False) Begin
92773>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
92774>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92775>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
92776>>>>>>>            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
92778>>>>>>>                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92779>>>>>>>                Send Destroy of hoDriver
92780>>>>>>>            End
92780>>>>>>>>
92780>>>>>>>            Function_Return False
92781>>>>>>>        End
92781>>>>>>>>
92781>>>>>>>
92781>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92782>>>>>>>
92782>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92783>>>>>>>        If (bExists = False) Begin
92785>>>>>>>            // We always start by deleting the current connection - if any - because the
92785>>>>>>>            // login details my have changed.
92785>>>>>>>            Get phoCLIHandler to hoCLI
92786>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92787>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92788>>>>>>>            Get UtilCreateConnectionID sConnectionID to bOk
92789>>>>>>>            If (bOk = False) Begin
92791>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92792>>>>>>>>
92792>>>>>>>                Function_Return False
92793>>>>>>>            End
92793>>>>>>>>
92793>>>>>>>            Move bOK to bExists
92794>>>>>>>        End
92794>>>>>>>>
92794>>>>>>>
92794>>>>>>>        Function_Return (bExists = True)
92795>>>>>>>    End_Function
92796>>>>>>>
92796>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92796>>>>>>>    // Returns: False if nobody else is running
92796>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92796>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92796>>>>>>>    //      tables are not locked as DataFlex tables are.
92796>>>>>>>    Function IsDatabaseInUse Returns Boolean
92798>>>>>>>        Handle  hTable
92798>>>>>>>        Integer iTemp
92798>>>>>>>        String  sRootName sOrgOpenPath sOrgFileList
92798>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
92798>>>>>>>
92798>>>>>>>        Get AutoConnectionIDLogin to bOK
92799>>>>>>>        Move 0 to hTable
92800>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92803>>>>>>>        Move False to bErr
92804>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92805>>>>>>>
92805>>>>>>>        Repeat
92805>>>>>>>>
92805>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92808>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92809>>>>>>>
92809>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92809>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
92810>>>>>>>            Move False to bOpen
92811>>>>>>>
92811>>>>>>>            // Don't bother about FlexErrs (Normally table 50)
92811>>>>>>>            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
92813>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92814>>>>>>>                Open hTable
92816>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92819>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92820>>>>>>>                If (bOpen = True) Begin
92822>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92822>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92823>>>>>>>                    If (bAlias = False) Begin 
92825>>>>>>>                        Close hTable
92826>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92827>>>>>>>                        If (bOpen = False) Begin
92829>>>>>>>                            Move True to bErr
92830>>>>>>>                        End
92830>>>>>>>>
92830>>>>>>>                    End
92830>>>>>>>>
92830>>>>>>>                End 
92830>>>>>>>>
92830>>>>>>>                Close hTable
92831>>>>>>>            End
92831>>>>>>>>
92831>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92834>>>>>>>            If (bErr = True ) Break
92837>>>>>>>        Until (not(hTable))
92839>>>>>>>
92839>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92840>>>>>>>        Move False to Err
92841>>>>>>>
92841>>>>>>>        Function_Return bErr
92842>>>>>>>    End_Function
92843>>>>>>>
92843>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
92843>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
92843>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
92843>>>>>>>    // NOTE: Only applicable for DAW drivers.
92843>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
92845>>>>>>>        String sID sConnString
92845>>>>>>>        Integer iDriver iNumConn iCount
92845>>>>>>>        Handle hoCLI
92845>>>>>>>        Boolean bOK
92845>>>>>>>
92845>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
92846>>>>>>>        If (bOK = False) Begin
92848>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
92849>>>>>>>>
92849>>>>>>>            Function_Return False
92850>>>>>>>        End
92850>>>>>>>>
92850>>>>>>>
92850>>>>>>>        Move False to bOK
92851>>>>>>>        Get phoCLIHandler to hoCLI
92852>>>>>>>        If (hoCLI <> 0) Begin
92854>>>>>>>            Set psDriverID of hoCLI to sDriverID
92855>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
92856>>>>>>>
92856>>>>>>>            // If driver not loaded; load it.
92856>>>>>>>            If (iDriver = 0) Begin
92858>>>>>>>                Load_Driver sDriverID
92859>>>>>>>                Get DriverIndex sDriverID to iDriver
92860>>>>>>>            End
92860>>>>>>>>
92860>>>>>>>            If (iDriver <> 0) Begin
92862>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
92865>>>>>>>                Decrement iNumConn
92866>>>>>>>                for iCount from 0 to iNumConn
92872>>>>>>>>
92872>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
92875>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
92878>>>>>>>                    If (sID = sConnectionID) Move True to bOK
92881>>>>>>>                Loop
92882>>>>>>>>
92882>>>>>>>            End
92882>>>>>>>>
92882>>>>>>>        End
92882>>>>>>>>
92882>>>>>>>
92882>>>>>>>        Function_Return bOK
92883>>>>>>>    End_Function
92884>>>>>>>
92884>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
92886>>>>>>>        Boolean bOK
92886>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
92887>>>>>>>        Function_Return bOK
92888>>>>>>>    End_Function
92889>>>>>>>
92889>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
92891>>>>>>>        Boolean bOK
92891>>>>>>>        Move False to bOK
92892>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
92893>>>>>>>        Function_Return bOK
92894>>>>>>>    End_Function
92895>>>>>>>
92895>>>>>>>    Function IsMSSQLDriver Returns Boolean
92897>>>>>>>        Handle ho
92897>>>>>>>        Integer iDriverIndex
92897>>>>>>>
92897>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
92898>>>>>>>
92898>>>>>>>        Function_Return (iDriverIndex <> 0)
92899>>>>>>>    End_Function
92900>>>>>>>
92900>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
92900>>>>>>>    // attempt to load the driver.
92900>>>>>>>    // Returns true if the passed driver is SQL based.
92900>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
92902>>>>>>>        Boolean bOK
92902>>>>>>>        Integer iDriver
92902>>>>>>>
92902>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
92903>>>>>>>
92903>>>>>>>        If (bOK = False) Begin
92905>>>>>>>            Get IsMertechDriver sDriverID to bOK
92906>>>>>>>        End
92906>>>>>>>>
92906>>>>>>>
92906>>>>>>>        Function_Return bOK
92907>>>>>>>    End_Function
92908>>>>>>>
92908>>>>>>>    // *** Error Handler ***
92908>>>>>>>    //
92908>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
92908>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
92908>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
92910>>>>>>>        String sText
92910>>>>>>>        Integer iSize iErrorMode
92910>>>>>>>        tSqlErrorArray aSqlErrorArray
92910>>>>>>>        tSqlErrorArray aSqlErrorArray
92910>>>>>>>
92910>>>>>>>        If (pbProcessingError(Self)) Begin
92912>>>>>>>            Procedure_Return
92913>>>>>>>        End
92913>>>>>>>>
92913>>>>>>>
92913>>>>>>>        Get Error_Report_Mode to iErrorMode
92914>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
92916>>>>>>>            Procedure_Return
92917>>>>>>>        End
92917>>>>>>>>
92917>>>>>>>
92917>>>>>>>        Set pbProcessingError to True
92918>>>>>>>        Set pbSqlError to True
92919>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
92920>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
92921>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
92922>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
92923>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
92924>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
92925>>>>>>>        Set pbProcessingError to False
92926>>>>>>>    End_Procedure
92927>>>>>>>
92927>>>>>>>    // *** Miscellanous Helper Functions ***
92927>>>>>>>    //
92927>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
92927>>>>>>>    // returns the table name only; stripped of any path or filename extension.
92927>>>>>>>    Function _TableNameOnly String sName Returns String
92929>>>>>>>        String sPath sExt
92929>>>>>>>
92929>>>>>>>        Get ParseFolderName sName to sPath
92930>>>>>>>        If (sPath <> "") Begin
92932>>>>>>>            Move (Replace(sPath, sName, "")) to sName
92933>>>>>>>        End
92933>>>>>>>>
92933>>>>>>>        Get ParseFileExtension sName to sExt
92934>>>>>>>        If (sExt <> "") Begin
92936>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
92937>>>>>>>        End
92937>>>>>>>>
92937>>>>>>>
92937>>>>>>>        Function_Return sName
92938>>>>>>>    End_Function
92939>>>>>>>
92939>>>>>>>    // Returns the first datapath found in the psDataPath property.
92939>>>>>>>    // The returned path always ends with a "\"
92939>>>>>>>    Function psDataPathFirstPart Returns String
92941>>>>>>>        String sDataPath
92941>>>>>>>        Integer iCount
92941>>>>>>>
92941>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92942>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
92943>>>>>>>        If (iCount > 1) Begin
92945>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
92946>>>>>>>        End
92946>>>>>>>>
92946>>>>>>>        If (sDataPath <> "") Begin
92948>>>>>>>            Get vFolderFormat sDataPath to sDataPath
92949>>>>>>>        End
92949>>>>>>>>
92949>>>>>>>
92949>>>>>>>        Function_Return sDataPath
92950>>>>>>>    End_Function
92951>>>>>>>
92951>>>>>>>    // *** Property Messages ***
92951>>>>>>>    //
92951>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
92951>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
92951>>>>>>>    //
92951>>>>>>>
92951>>>>>>>    Function pSQLConnection Returns tSQLConnection
92953>>>>>>>        tSQLConnection SQLConnection
92953>>>>>>>        tSQLConnection SQLConnection
92953>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92955>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
92955>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92956>>>>>>>>
92956>>>>>>>            Function_Return
92957>>>>>>>        End
92957>>>>>>>>
92957>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92958>>>>>>>        Function_Return SQLConnection
92959>>>>>>>    End_Function
92960>>>>>>>
92960>>>>>>>    Procedure Set psServer String sValue
92962>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92964>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
92964>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92965>>>>>>>>
92965>>>>>>>            Procedure_Return
92966>>>>>>>        End
92966>>>>>>>>
92966>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
92967>>>>>>>    End_Procedure
92968>>>>>>>
92968>>>>>>>    Function psServer Returns String
92970>>>>>>>        String sValue
92970>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92972>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92973>>>>>>>>
92973>>>>>>>            Function_Return
92974>>>>>>>        End
92974>>>>>>>>
92974>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
92975>>>>>>>        Function_Return sValue
92976>>>>>>>    End_Function
92977>>>>>>>
92977>>>>>>>    Procedure Set psDatabase String sValue
92979>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92981>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92982>>>>>>>>
92982>>>>>>>            Procedure_Return
92983>>>>>>>        End
92983>>>>>>>>
92983>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
92984>>>>>>>    End_Procedure
92985>>>>>>>
92985>>>>>>>    Function psDatabase Returns String
92987>>>>>>>        String sValue
92987>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92989>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92990>>>>>>>>
92990>>>>>>>            Function_Return
92991>>>>>>>        End
92991>>>>>>>>
92991>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
92992>>>>>>>        Function_Return sValue
92993>>>>>>>    End_Function
92994>>>>>>>
92994>>>>>>>    Procedure Set psUserID String sValue
92996>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
92998>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92999>>>>>>>>
92999>>>>>>>            Function_Return
93000>>>>>>>        End
93000>>>>>>>>
93000>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
93001>>>>>>>    End_Procedure
93002>>>>>>>
93002>>>>>>>    Function psUserID Returns String
93004>>>>>>>        String sValue
93004>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93006>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93007>>>>>>>>
93007>>>>>>>            Function_Return
93008>>>>>>>        End
93008>>>>>>>>
93008>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
93009>>>>>>>        Function_Return sValue
93010>>>>>>>    End_Function
93011>>>>>>>
93011>>>>>>>    Procedure Set psPassword String sValue
93013>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93015>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93016>>>>>>>>
93016>>>>>>>            Procedure_Return
93017>>>>>>>        End
93017>>>>>>>>
93017>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
93018>>>>>>>    End_Procedure
93019>>>>>>>
93019>>>>>>>    Function psPassword Returns String
93021>>>>>>>        String sValue
93021>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93023>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93024>>>>>>>>
93024>>>>>>>            Function_Return
93025>>>>>>>        End
93025>>>>>>>>
93025>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
93026>>>>>>>        Function_Return sValue
93027>>>>>>>    End_Function
93028>>>>>>>
93028>>>>>>>    Procedure Set pbTrusted Boolean bValue
93030>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93032>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93033>>>>>>>>
93033>>>>>>>            Procedure_Return
93034>>>>>>>        End
93034>>>>>>>>
93034>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
93035>>>>>>>    End_Procedure
93036>>>>>>>
93036>>>>>>>    Function pbTrusted Returns Boolean
93038>>>>>>>        Boolean bValue
93038>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93040>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93041>>>>>>>>
93041>>>>>>>            Function_Return
93042>>>>>>>        End
93042>>>>>>>>
93042>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
93043>>>>>>>        Function_Return bValue
93044>>>>>>>    End_Function
93045>>>>>>>
93045>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
93047>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93049>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93050>>>>>>>>
93050>>>>>>>            Procedure_Return
93051>>>>>>>        End
93051>>>>>>>>
93051>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
93052>>>>>>>    End_Procedure
93053>>>>>>>
93053>>>>>>>    Function pbSilentLogin Returns Boolean
93055>>>>>>>        Boolean bValue
93055>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93057>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93058>>>>>>>>
93058>>>>>>>            Function_Return
93059>>>>>>>        End
93059>>>>>>>>
93059>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
93060>>>>>>>        Function_Return bValue
93061>>>>>>>    End_Function
93062>>>>>>>
93062>>>>>>>    Procedure Set psConnectionID String sValue
93064>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93066>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93067>>>>>>>>
93067>>>>>>>            Procedure_Return
93068>>>>>>>        End
93068>>>>>>>>
93068>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
93069>>>>>>>    End_Procedure
93070>>>>>>>
93070>>>>>>>    Function psConnectionID Returns String
93072>>>>>>>        String sValue
93072>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93074>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93075>>>>>>>>
93075>>>>>>>            Function_Return
93076>>>>>>>        End
93076>>>>>>>>
93076>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
93077>>>>>>>        Function_Return sValue
93078>>>>>>>    End_Function
93079>>>>>>>
93079>>>>>>>    Procedure Set psConnectionString String sValue
93081>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93083>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93084>>>>>>>>
93084>>>>>>>            Procedure_Return
93085>>>>>>>        End
93085>>>>>>>>
93085>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
93086>>>>>>>    End_Procedure
93087>>>>>>>
93087>>>>>>>    Function psConnectionString Returns String
93089>>>>>>>        String sValue
93089>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93091>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93092>>>>>>>>
93092>>>>>>>            Function_Return
93093>>>>>>>        End
93093>>>>>>>>
93093>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
93094>>>>>>>        Function_Return sValue
93095>>>>>>>    End_Function
93096>>>>>>>
93096>>>>>>>    // The normal connection string looks something like this;
93096>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
93096>>>>>>>    // ...and the full connection string looks like this;
93096>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
93096>>>>>>>    Function psFullConnectionString Returns String
93098>>>>>>>        String sConnectionID sConnectionString
93098>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93100>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93101>>>>>>>>
93101>>>>>>>            Function_Return
93102>>>>>>>        End
93102>>>>>>>>
93102>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
93103>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
93104>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
93105>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
93106>>>>>>>    End_Function
93107>>>>>>>
93107>>>>>>>    Function piConnectionOptions Returns Integer
93109>>>>>>>        Integer iValue
93109>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93111>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93112>>>>>>>>
93112>>>>>>>            Function_Return
93113>>>>>>>        End
93113>>>>>>>>
93113>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
93114>>>>>>>        Function_Return iValue
93115>>>>>>>    End_Function
93116>>>>>>>
93116>>>>>>>    Procedure Set psSchema String sValue
93118>>>>>>>        tSQLConnection SQLConnection
93118>>>>>>>        tSQLConnection SQLConnection
93118>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93120>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93121>>>>>>>>
93121>>>>>>>            Procedure_Return
93122>>>>>>>        End
93122>>>>>>>>
93122>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
93123>>>>>>>    End_Procedure
93124>>>>>>>
93124>>>>>>>    Function psSchema Returns String
93126>>>>>>>        String sRetval
93126>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93128>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93129>>>>>>>>
93129>>>>>>>            Function_Return
93130>>>>>>>        End
93130>>>>>>>>
93130>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
93131>>>>>>>        Function_Return sRetval
93132>>>>>>>    End_Function
93133>>>>>>>
93133>>>>>>>    Procedure Set psBaseTableSpace String sValue
93135>>>>>>>        String sRetval
93135>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93137>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93138>>>>>>>>
93138>>>>>>>            Procedure_Return
93139>>>>>>>        End
93139>>>>>>>>
93139>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
93140>>>>>>>    End_Procedure
93141>>>>>>>
93141>>>>>>>    Function psBaseTableSpace Returns String
93143>>>>>>>        String sRetval
93143>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93145>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93146>>>>>>>>
93146>>>>>>>            Function_Return
93147>>>>>>>        End
93147>>>>>>>>
93147>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
93148>>>>>>>        Function_Return sRetval
93149>>>>>>>    End_Function
93150>>>>>>>
93150>>>>>>>    Procedure Set psLongTableSpace String sValue
93152>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93154>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93155>>>>>>>>
93155>>>>>>>            Procedure_Return
93156>>>>>>>        End
93156>>>>>>>>
93156>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
93157>>>>>>>    End_Procedure
93158>>>>>>>
93158>>>>>>>    Function psLongTableSpace Returns String
93160>>>>>>>        String sRetval
93160>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93162>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93163>>>>>>>>
93163>>>>>>>            Function_Return
93164>>>>>>>        End
93164>>>>>>>>
93164>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
93165>>>>>>>        Function_Return sRetval
93166>>>>>>>    End_Function
93167>>>>>>>
93167>>>>>>>    Procedure Set psIndexTableSpace String sValue
93169>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93171>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93172>>>>>>>>
93172>>>>>>>            Procedure_Return
93173>>>>>>>        End
93173>>>>>>>>
93173>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
93174>>>>>>>    End_Procedure
93175>>>>>>>
93175>>>>>>>    Function psIndexTableSpace Returns String
93177>>>>>>>        String sRetval
93177>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93179>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93180>>>>>>>>
93180>>>>>>>            Function_Return
93181>>>>>>>        End
93181>>>>>>>>
93181>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
93182>>>>>>>        Function_Return sRetval
93183>>>>>>>    End_Function
93184>>>>>>>
93184>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
93186>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93188>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93189>>>>>>>>
93189>>>>>>>            Procedure_Return
93190>>>>>>>        End
93190>>>>>>>>
93190>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
93191>>>>>>>    End_Procedure
93192>>>>>>>
93192>>>>>>>    Function pbUseConnectionID Returns Boolean
93194>>>>>>>        Boolean bState
93194>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93196>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93197>>>>>>>>
93197>>>>>>>            Function_Return
93198>>>>>>>        End
93198>>>>>>>>
93198>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
93199>>>>>>>        Function_Return bState
93200>>>>>>>    End_Function
93201>>>>>>>
93201>>>>>>>    Procedure Set pbToANSI Boolean bState
93203>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93205>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93206>>>>>>>>
93206>>>>>>>            Procedure_Return
93207>>>>>>>        End
93207>>>>>>>>
93207>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
93208>>>>>>>    End_Procedure
93209>>>>>>>
93209>>>>>>>    Function pbToANSI Returns Boolean
93211>>>>>>>        Boolean bState
93211>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93213>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93214>>>>>>>>
93214>>>>>>>            Function_Return
93215>>>>>>>        End
93215>>>>>>>>
93215>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
93216>>>>>>>        Function_Return bState
93217>>>>>>>    End_Function
93218>>>>>>>
93218>>>>>>>    Procedure Set pbRecnum Boolean bState
93220>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93222>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93223>>>>>>>>
93223>>>>>>>            Procedure_Return
93224>>>>>>>        End
93224>>>>>>>>
93224>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
93225>>>>>>>    End_Procedure
93226>>>>>>>
93226>>>>>>>    Function pbRecnum Returns Boolean
93228>>>>>>>        Boolean bState
93228>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93230>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93231>>>>>>>>
93231>>>>>>>            Function_Return
93232>>>>>>>        End
93232>>>>>>>>
93232>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
93233>>>>>>>        Function_Return bState
93234>>>>>>>    End_Function
93235>>>>>>>
93235>>>>>>>    Procedure Set pbCopyData Boolean bState
93237>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93239>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93240>>>>>>>>
93240>>>>>>>            Procedure_Return
93241>>>>>>>        End
93241>>>>>>>>
93241>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
93242>>>>>>>    End_Procedure
93243>>>>>>>
93243>>>>>>>    Function pbCopyData Returns Boolean
93245>>>>>>>        Boolean bState
93245>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93247>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93248>>>>>>>>
93248>>>>>>>            Function_Return
93249>>>>>>>        End
93249>>>>>>>>
93249>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
93250>>>>>>>        Function_Return bState
93251>>>>>>>    End_Function
93252>>>>>>>
93252>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
93254>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93256>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93257>>>>>>>>
93257>>>>>>>            Procedure_Return
93258>>>>>>>        End
93258>>>>>>>>
93258>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
93259>>>>>>>    End_Procedure
93260>>>>>>>
93260>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
93262>>>>>>>        Boolean bState
93262>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93264>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93265>>>>>>>>
93265>>>>>>>            Function_Return
93266>>>>>>>        End
93266>>>>>>>>
93266>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
93267>>>>>>>        Function_Return bState
93268>>>>>>>    End_Function
93269>>>>>>>
93269>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
93271>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93273>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93274>>>>>>>>
93274>>>>>>>            Procedure_Return
93275>>>>>>>        End
93275>>>>>>>>
93275>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93276>>>>>>>    End_Procedure
93277>>>>>>>
93277>>>>>>>    Function pbCompareIndexAscending Returns Boolean
93279>>>>>>>        Boolean bState
93279>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93281>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93282>>>>>>>>
93282>>>>>>>            Function_Return
93283>>>>>>>        End
93283>>>>>>>>
93283>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93284>>>>>>>        Function_Return bState
93285>>>>>>>    End_Function
93286>>>>>>>
93286>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
93288>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93290>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93291>>>>>>>>
93291>>>>>>>            Procedure_Return
93292>>>>>>>        End
93292>>>>>>>>
93292>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93293>>>>>>>    End_Procedure
93294>>>>>>>
93294>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
93296>>>>>>>        Boolean bState
93296>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93298>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93299>>>>>>>>
93299>>>>>>>            Function_Return
93300>>>>>>>        End
93300>>>>>>>>
93300>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93301>>>>>>>        Function_Return bState
93302>>>>>>>    End_Function
93303>>>>>>>
93303>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
93305>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93307>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93308>>>>>>>>
93308>>>>>>>            Procedure_Return
93309>>>>>>>        End
93309>>>>>>>>
93309>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
93310>>>>>>>    End_Procedure
93311>>>>>>>
93311>>>>>>>    Function psDriverDefaultValueASCII Returns String
93313>>>>>>>        String sRetval
93313>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93315>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93316>>>>>>>>
93316>>>>>>>            Function_Return
93317>>>>>>>        End
93317>>>>>>>>
93317>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
93318>>>>>>>        Function_Return sRetval
93319>>>>>>>    End_Function
93320>>>>>>>
93320>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
93322>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93324>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93325>>>>>>>>
93325>>>>>>>            Procedure_Return
93326>>>>>>>        End
93326>>>>>>>>
93326>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
93327>>>>>>>    End_Procedure
93328>>>>>>>
93328>>>>>>>    Function psDriverDefaultValueBinary Returns String
93330>>>>>>>        String sRetval
93330>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93332>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93333>>>>>>>>
93333>>>>>>>            Function_Return
93334>>>>>>>        End
93334>>>>>>>>
93334>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
93335>>>>>>>        Function_Return sRetval
93336>>>>>>>    End_Function
93337>>>>>>>
93337>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
93339>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93341>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93342>>>>>>>>
93342>>>>>>>            Procedure_Return
93343>>>>>>>        End
93343>>>>>>>>
93343>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
93344>>>>>>>    End_Procedure
93345>>>>>>>
93345>>>>>>>    Function psDriverDefaultValueDate Returns String
93347>>>>>>>        String sRetval
93347>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93349>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93350>>>>>>>>
93350>>>>>>>            Function_Return
93351>>>>>>>        End
93351>>>>>>>>
93351>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
93352>>>>>>>        Function_Return sRetval
93353>>>>>>>    End_Function
93354>>>>>>>
93354>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93356>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93358>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93359>>>>>>>>
93359>>>>>>>            Procedure_Return
93360>>>>>>>        End
93360>>>>>>>>
93360>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
93361>>>>>>>    End_Procedure
93362>>>>>>>
93362>>>>>>>    Function psDriverDefaultValueDateTime Returns String
93364>>>>>>>        String sRetval
93364>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93366>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93367>>>>>>>>
93367>>>>>>>            Function_Return
93368>>>>>>>        End
93368>>>>>>>>
93368>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
93369>>>>>>>        Function_Return sRetval
93370>>>>>>>    End_Function
93371>>>>>>>
93371>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93373>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93375>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93376>>>>>>>>
93376>>>>>>>            Procedure_Return
93377>>>>>>>        End
93377>>>>>>>>
93377>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
93378>>>>>>>    End_Procedure
93379>>>>>>>
93379>>>>>>>    Function psDriverDefaultValueNumeric Returns String
93381>>>>>>>        String sRetval
93381>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93383>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93384>>>>>>>>
93384>>>>>>>            Function_Return
93385>>>>>>>        End
93385>>>>>>>>
93385>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
93386>>>>>>>        Function_Return sRetval
93387>>>>>>>    End_Function
93388>>>>>>>
93388>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
93390>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93392>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93393>>>>>>>>
93393>>>>>>>            Procedure_Return
93394>>>>>>>        End
93394>>>>>>>>
93394>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
93395>>>>>>>    End_Procedure
93396>>>>>>>
93396>>>>>>>    Function psDriverDefaultValueText Returns String
93398>>>>>>>        String sRetval
93398>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93400>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93401>>>>>>>>
93401>>>>>>>            Function_Return
93402>>>>>>>        End
93402>>>>>>>>
93402>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
93403>>>>>>>        Function_Return sRetval
93404>>>>>>>    End_Function
93405>>>>>>>
93405>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93407>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93409>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93410>>>>>>>>
93410>>>>>>>            Procedure_Return
93411>>>>>>>        End
93411>>>>>>>>
93411>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
93412>>>>>>>    End_Procedure
93413>>>>>>>
93413>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93415>>>>>>>        Boolean bState
93415>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93417>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93418>>>>>>>>
93418>>>>>>>            Function_Return
93419>>>>>>>        End
93419>>>>>>>>
93419>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
93420>>>>>>>        Function_Return bState
93421>>>>>>>    End_Function
93422>>>>>>>
93422>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93424>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93426>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93427>>>>>>>>
93427>>>>>>>            Procedure_Return
93428>>>>>>>        End
93428>>>>>>>>
93428>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
93429>>>>>>>    End_Procedure
93430>>>>>>>
93430>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93432>>>>>>>        Boolean bState
93432>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93434>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93435>>>>>>>>
93435>>>>>>>            Function_Return
93436>>>>>>>        End
93436>>>>>>>>
93436>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
93437>>>>>>>        Function_Return bState
93438>>>>>>>    End_Function
93439>>>>>>>
93439>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93441>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93443>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93444>>>>>>>>
93444>>>>>>>            Procedure_Return
93445>>>>>>>        End
93445>>>>>>>>
93445>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
93446>>>>>>>    End_Procedure
93447>>>>>>>
93447>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
93449>>>>>>>        Boolean bState
93449>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93451>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93452>>>>>>>>
93452>>>>>>>            Function_Return
93453>>>>>>>        End
93453>>>>>>>>
93453>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
93454>>>>>>>        Function_Return bState
93455>>>>>>>    End_Function
93456>>>>>>>
93456>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
93458>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93460>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93461>>>>>>>>
93461>>>>>>>            Procedure_Return
93462>>>>>>>        End
93462>>>>>>>>
93462>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
93463>>>>>>>    End_Procedure
93464>>>>>>>
93464>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
93466>>>>>>>        Boolean bState
93466>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93468>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93469>>>>>>>>
93469>>>>>>>            Function_Return
93470>>>>>>>        End
93470>>>>>>>>
93470>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
93471>>>>>>>        Function_Return bState
93472>>>>>>>    End_Function
93473>>>>>>>
93473>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
93475>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93477>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93478>>>>>>>>
93478>>>>>>>            Procedure_Return
93479>>>>>>>        End
93479>>>>>>>>
93479>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
93480>>>>>>>    End_Procedure
93481>>>>>>>
93481>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
93483>>>>>>>        Boolean bState
93483>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93485>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93486>>>>>>>>
93486>>>>>>>            Function_Return
93487>>>>>>>        End
93487>>>>>>>>
93487>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
93488>>>>>>>        Function_Return bState
93489>>>>>>>    End_Function
93490>>>>>>>
93490>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
93492>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93494>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93495>>>>>>>>
93495>>>>>>>            Procedure_Return
93496>>>>>>>        End
93496>>>>>>>>
93496>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
93497>>>>>>>    End_Procedure
93498>>>>>>>
93498>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
93500>>>>>>>        Boolean bState
93500>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
93502>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93503>>>>>>>>
93503>>>>>>>            Function_Return
93504>>>>>>>        End
93504>>>>>>>>
93504>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
93505>>>>>>>        Function_Return bState
93506>>>>>>>    End_Function
93507>>>>>>>
93507>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
93507>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
93507>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
93507>>>>>>>    //       for a connection string has the wrong format for that driver.
93507>>>>>>>    Procedure Set psDriverID String sValue
93509>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93510>>>>>>>        Delegate Set psDriverID to sValue
93512>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93513>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
93514>>>>>>>    End_Procedure
93515>>>>>>>
93515>>>>>>>    Function psDriverID Returns String
93517>>>>>>>        String sDriverID
93517>>>>>>>
93517>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93518>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
93518>>>>>>>        Delegate Get psDriverID to sDriverID
93520>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93521>>>>>>>        Move False to Err
93522>>>>>>>
93522>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
93522>>>>>>>        // probably used as "utilites" from a special made program and
93522>>>>>>>        // the ghoSQLConnectionHandler must have been setup
93522>>>>>>>        If (sDriverID = "") Begin
93524>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
93525>>>>>>>        End
93525>>>>>>>>
93525>>>>>>>        Function_Return sDriverID
93526>>>>>>>    End_Function
93527>>>>>>>
93527>>>>>>>    Procedure Set piDbType Integer iValue
93529>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93530>>>>>>>        Delegate Set piDbType to iValue
93532>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93533>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
93534>>>>>>>    End_Procedure
93535>>>>>>>
93535>>>>>>>    Function piDbType Returns String
93537>>>>>>>        Integer iRetval
93537>>>>>>>
93537>>>>>>>//        Move False to Err
93537>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93537>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
93537>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93537>>>>>>>//        Delegate Get piDbType to iRetval
93537>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
93537>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93537>>>>>>>
93537>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
93537>>>>>>>        // probably used as "utilites" from a special made program and
93537>>>>>>>        // the ghoSQLConnectionHandler must have been setup
93537>>>>>>>//        If (Err = True) Begin
93537>>>>>>>            Get piDbType of ghoSQLConnectionHandler to iRetval
93538>>>>>>>//        End
93538>>>>>>>
93538>>>>>>>//        Move False to Err
93538>>>>>>>        Function_Return iRetval
93539>>>>>>>    End_Function  
93540>>>>>>>    
93540>>>>>>>    Function phoLogFile Returns Handle
93542>>>>>>>        Handle hoLogFile
93542>>>>>>>        
93542>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93543>>>>>>>        Delegate Get phoLogFile to hoLogFile
93545>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93546>>>>>>>
93546>>>>>>>        Function_Return hoLogFile
93547>>>>>>>    End_Function
93548>>>>>>>
93548>>>>>>>    Function pnCurrentVersionUpdate Returns Number
93550>>>>>>>        Number nCurrentVersionUpdate
93550>>>>>>>
93550>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93551>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
93553>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93554>>>>>>>
93554>>>>>>>        Function_Return nCurrentVersionUpdate
93555>>>>>>>    End_Function
93556>>>>>>>    
93556>>>>>>>    Procedure LogError String sText Boolean bError
93558>>>>>>>        Handle hoLogFile 
93558>>>>>>>        Number nCurrentVersionUpdate
93558>>>>>>>        
93558>>>>>>>        Get phoLogFile to hoLogFile
93559>>>>>>>        If (hoLogFile = 0) Begin
93561>>>>>>>            Procedure_Return
93562>>>>>>>        End 
93562>>>>>>>>
93562>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
93563>>>>>>>        
93563>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93564>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
93565>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93566>>>>>>>    End_Procedure        
93567>>>>>>>    
93567>>>>>>>    Function pbContinueOnError Returns Boolean
93569>>>>>>>        Boolean bContinueOnError
93569>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
93571>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
93572>>>>>>>        End
93572>>>>>>>>
93572>>>>>>>        Function_Return bContinueOnError
93573>>>>>>>    End_Function
93574>>>>>>>
93574>>>>>>>    // Messages not available in pre DF18 versions:
93574>>>>>>>
93574>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer 
93576>>>>>>>        Integer iMax iPos 
93576>>>>>>>        String sName 
93576>>>>>>>        
93576>>>>>>>        Move (Lowercase(sField)) to sField
93577>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax 
93580>>>>>>>        for iPos from 0 to iMax 
93586>>>>>>>>
93586>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName 
93589>>>>>>>            Move (Lowercase(sName)) to sName 
93590>>>>>>>            If (sName = sField) Begin
93592>>>>>>>                Function_Return iPos 
93593>>>>>>>            End
93593>>>>>>>>
93593>>>>>>>        Loop
93594>>>>>>>>
93594>>>>>>>        Function_Return -1 
93595>>>>>>>    End_Function
93596>>>>>>>
93596>>>>>>>
93596>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
93596>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
93596>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
93596>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
93596>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
93596>>>>>>>    //   ALTER TABLE MyTable
93596>>>>>>>    //       REBUILD
93596>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
93598>>>>>>>        Boolean bOK
93598>>>>>>>
93598>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
93600>>>>>>>            Function_Return False
93601>>>>>>>        End
93601>>>>>>>>
93601>>>>>>>
93601>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
93601>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
93602>>>>>>>
93602>>>>>>>        Function_Return (bOK = True)
93603>>>>>>>    End_Function
93604>>>>>>>
93604>>>>>>>
93604>>>>>>>    // *** Helper functions with compiled sql script code ***
93604>>>>>>>    //
93604>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
93604>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
93604>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
93604>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
93604>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
93604>>>>>>>    //   ALTER TABLE MyTable
93604>>>>>>>    //       REBUILD
93604>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
93606>>>>>>>        tSQLScriptArray SQLScriptArray
93606>>>>>>>        tSQLScriptArray SQLScriptArray
93606>>>>>>>        String sDriverID sVal
93606>>>>>>>        Boolean bOK
93606>>>>>>>        Integer iSize iCount
93606>>>>>>>
93606>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
93608>>>>>>>            Function_Return False
93609>>>>>>>        End
93609>>>>>>>>
93609>>>>>>>
93609>>>>>>>        Get psDriverID to sDriverID
93610>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
93611>>>>>>>        If (SQLScriptArray.bError = True) Begin
93613>>>>>>>            Function_Return False
93614>>>>>>>        End
93614>>>>>>>>
93614>>>>>>>
93614>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
93615>>>>>>>        Decrement iSize
93616>>>>>>>
93616>>>>>>>        for iCount from 0 to iSize
93622>>>>>>>>
93622>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
93624>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
93625>>>>>>>            End
93625>>>>>>>>
93625>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
93627>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
93628>>>>>>>            End
93628>>>>>>>>
93628>>>>>>>        Loop
93629>>>>>>>>
93629>>>>>>>
93629>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
93630>>>>>>>
93630>>>>>>>        Function_Return (bOK = True)
93631>>>>>>>    End_Function
93632>>>>>>>
93632>>>>>>>    // *** Helper functions for Mertech Drivers ***
93632>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
93632>>>>>>>    // and commands that the Studio editor knows nothing about.
93632>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Integer
93634>>>>>>>        Integer iRetval
93634>>>>>>>        String sPath
93634>>>>>>>
93634>>>>>>>        If (sPath = "" or sTableName = "") Begin
93636>>>>>>>            Function_Return 0
93637>>>>>>>        End
93637>>>>>>>>
93637>>>>>>>
93637>>>>>>>        Get vFolderFormat sPath to sPath
93638>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
93639>>>>>>>        Function_Return iRetval
93640>>>>>>>    End_Function
93641>>>>>>>
93641>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
93643>>>>>>>        Move False to Err
93644>>>>>>>        Function_Return (Err = False)
93645>>>>>>>    End_Function
93646>>>>>>>
93646>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
93648>>>>>>>        Integer iNumItems iCount
93648>>>>>>>        String[] sReturnArray
93649>>>>>>>        String sServer
93649>>>>>>>
93649>>>>>>>
93649>>>>>>>        Function_Return sReturnArray
93650>>>>>>>    End_Function
93651>>>>>>>
93651>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
93653>>>>>>>        String[] sReturnArray
93654>>>>>>>        String sServer
93654>>>>>>>
93654>>>>>>>
93654>>>>>>>        Function_Return sReturnArray
93655>>>>>>>    End_Function
93656>>>>>>>
93656>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
93658>>>>>>>        Handle hoSQLHandler hoSQLConnect
93658>>>>>>>
93658>>>>>>>        Move 0 to hoSQLConnect
93659>>>>>>>
93659>>>>>>>        Function_Return hoSQLConnect
93660>>>>>>>    End_Function
93661>>>>>>>
93661>>>>>>>    // Returns the handle of the Mertech SQL handler.
93661>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
93661>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
93661>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
93663>>>>>>>        Handle hoSQLHandler
93663>>>>>>>        String sDriverID sServer sDatabase
93663>>>>>>>
93663>>>>>>>        Move 0 to hoSQLHandler
93664>>>>>>>        Get psDriverID to sDriverID
93665>>>>>>>        Get psServer   to sServer
93666>>>>>>>        Get psDatabase to sDatabase
93667>>>>>>>
93667>>>>>>>        Function_Return hoSQLHandler
93668>>>>>>>    End_Function
93669>>>>>>>
93669>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
93669>>>>>>>    // macro-commands <sigh!>
93669>>>>>>>    // Note: The function sets the Err flag.
93669>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
93671>>>>>>>        Move False to Err
93672>>>>>>>
93672>>>>>>>
93672>>>>>>>        Function_Return (Err = False)
93673>>>>>>>    End_Function
93674>>>>>>>
93674>>>>>>>End_Class
93675>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\for_all.pkg)
93675>>>>>>>//************************************************************************
93675>>>>>>>//
93675>>>>>>>// Confidential Trade Secret.
93675>>>>>>>// Copyright 1987-1992 Data Access Corporation, Miami FL, USA
93675>>>>>>>// All Rights reserved
93675>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
93675>>>>>>>//
93675>>>>>>>//
93675>>>>>>>//     $Source: k:\RCS\.\pkg\for_all.pkg,v $
93675>>>>>>>//     $Revision: 1 $
93675>>>>>>>//     $State: Exp $
93675>>>>>>>//     $Author: james $
93675>>>>>>>//     $Date: Jun 05 14:37:09 1995 $
93675>>>>>>>//     $Locker:  $
93675>>>>>>>//
93675>>>>>>>//     $Log: for_all.pkg,v $
93675>>>>>>>//Revision 2.1  1993/08/25  17:48:09  james
93675>>>>>>>//Adding new main branch
93675>>>>>>>//
93675>>>>>>>//Revision 1.2  1993/04/28  00:20:34  james
93675>>>>>>>//Initializing 3.04 source code.
93675>>>>>>>//
93675>>>>>>>//Revision 1.1  1992/09/08  14:43:05  james
93675>>>>>>>//Initial revision
93675>>>>>>>//
93675>>>>>>>//Revision 1.4  92/05/14  16:49:32  SWM
93675>>>>>>>//Updated Copyright slug.
93675>>>>>>>//
93675>>>>>>>//Revision 1.3  92/03/09  19:02:09  james
93675>>>>>>>//Added #CHKSUB directive to insure source
93675>>>>>>>//only compiled with correct revision of
93675>>>>>>>//compiler.
93675>>>>>>>//
93675>>>>>>>//Revision 1.2  92/02/18  20:04:39  steve-l
93675>>>>>>>//altered main command to permit use of file.field instead of index.#
93675>>>>>>>//
93675>>>>>>>//Revision 1.1  91/10/23  10:20:51  elsa
93675>>>>>>>//Initial revision
93675>>>>>>>//
93675>>>>>>>//************************************************************************/
93675>>>>>>>
93675>>>>>>>//************************************************************************
93675>>>>>>>//     File Name: For_All.Pkg
93675>>>>>>>// Creation Date: January 1, 1991
93675>>>>>>>// Modified Date: May 23, 1991
93675>>>>>>>//     Author(s): Steven A. Lowe
93675>>>>>>>//
93675>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
93675>>>>>>>//
93675>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
93675>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
93675>>>>>>>// conjunction with constraint-clauses.
93675>>>>>>>//
93675>>>>>>>// SYNTAX:
93675>>>>>>>//
93675>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
93675>>>>>>>//    <Constraints...>
93675>>>>>>>//    {DO}
93675>>>>>>>//      <loop body>
93675>>>>>>>//  End_For_All
93675>>>>>>>//
93675>>>>>>>// This set of macros implements a constraint-oriented file enumeration
93675>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
93675>>>>>>>//
93675>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
93675>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93675>>>>>>>//   End_For_All
93675>>>>>>>//
93675>>>>>>>// To list only Customers with a Balance greater than their credit limit:
93675>>>>>>>//
93675>>>>>>>//   For_All Customer BY Index.1
93675>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
93675>>>>>>>//     DO
93675>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93675>>>>>>>//   End_For_All
93675>>>>>>>//
93675>>>>>>>// Constraint clauses are:
93675>>>>>>>//
93675>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
93675>>>>>>>//   CONSTRAIN <File> AS <Expression>
93675>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
93675>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
93675>>>>>>>//
93675>>>>>>>// For example, to list all customers with a bad status whose names start
93675>>>>>>>// with "A" and which have not made a payment in thirty days:
93675>>>>>>>//
93675>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
93675>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
93675>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
93675>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
93675>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
93675>>>>>>>//      DO
93675>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
93675>>>>>>>//    End_For_All
93675>>>>>>>//
93675>>>>>>>//************************************************************************/
93675>>>>>>>
93675>>>>>>>
93675>>>>>>>
93675>>>>>>>//
93675>>>>>>>//DO
93675>>>>>>>//
93675>>>>>>>//This command starts the loop process body when constraints are used;
93675>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
93675>>>>>>>//command line, and not on a line by itself
93675>>>>>>>//
93675>>>>>>>
93675>>>>>>>//
93675>>>>>>>//END_FOR_ALL
93675>>>>>>>//
93675>>>>>>>//Ends a For_All loop
93675>>>>>>>//
93675>>>>>>>
93675>>>>>
93675>>>>>
93675>>>>>
93675>>>>>Class cDbUpdateVersion is a cObject
93676>>>>>
93676>>>>>    Procedure Construct_Object
93678>>>>>        String[] aSQLQueryMessages
93679>>>>>        Forward Send Construct_Object
93681>>>>>        
93681>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
93681>>>>>        // event was triggered, thus an actual change of the database was made.
93681>>>>>        Property Boolean pbVersionUpdate False
93682>>>>>
93682>>>>>        // This property must be manually set within each cDbUpdateVersion object
93682>>>>>        // by the programmer, to a consecutive number.
93682>>>>>        Property Number pnVersionNumber
93683>>>>>
93683>>>>>        Property Boolean pbUseConnectionID True
93684>>>>>        Property Boolean private.pbToANSI   True
93685>>>>>        Property Boolean private.pbRecnum   True
93686>>>>>        Property Boolean private.pbCopyData True
93687>>>>>        Property Boolean private.pbCompareDate_DateTime False
93688>>>>>        Property Boolean private.pbCompareIndexAscending False
93689>>>>>        Property Boolean private.pbCompareIndexUppercase False
93690>>>>>        Property String private.psSchema
93691>>>>>        Property String private.psBaseTableSpace
93692>>>>>        Property String private.psLongTableSpace
93693>>>>>        Property String private.psIndexTableSpace
93694>>>>>
93694>>>>>        // Driver default value settings:
93694>>>>>        Property String private.psDriverDefaultValueASCII    ""
93695>>>>>        Property String private.psDriverDefaultValueBinary   ""
93696>>>>>        Property String private.psDriverDefaultValueDate     ""
93697>>>>>        Property String private.psDriverDefaultValueDateTime ""
93698>>>>>        Property String private.psDriverDefaultValueNumeric  ""
93699>>>>>        Property String private.psDriverDefaultValueText     ""
93700>>>>>
93700>>>>>        // Driver "nullability" settings:
93700>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
93701>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
93702>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
93703>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
93704>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
93705>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
93706>>>>>
93706>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
93706>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
93706>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
93706>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
93706>>>>>        // We reset it here for each cDbUpdateVersion object
93706>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
93708>>>>>    End_Procedure
93709>>>>>
93709>>>>>    // *** Main hook event message ***
93709>>>>>    // Place your database update logic here!
93709>>>>>    Procedure OnUpdate
93711>>>>>    End_Procedure
93712>>>>>
93712>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
93712>>>>>    // imported to the cDbUpdateHandler container class which should be a
93712>>>>>    // parent object to this object. To have the Studio's Property Panel
93712>>>>>    // "behave" aka show these properties we need to duplicate them in this
93712>>>>>    // class and "relay" them to the parent object.
93712>>>>>    Procedure Set pbToANSI Boolean bState
93714>>>>>        Set private.pbToANSI  to bState
93715>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93716>>>>>        Delegate Set pbToANSI to bState
93718>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93719>>>>>    End_Procedure
93720>>>>>
93720>>>>>    Function pbToANSI Returns Boolean
93722>>>>>        Function_Return (private.pbToAnsi(Self))
93723>>>>>    End_Function
93724>>>>>
93724>>>>>    Procedure Set pbRecnum Boolean bState
93726>>>>>        Set private.pbRecnum  to bState
93727>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93728>>>>>        Delegate Set pbRecnum to bState
93730>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93731>>>>>    End_Procedure
93732>>>>>
93732>>>>>    Function pbRecnum Returns Boolean
93734>>>>>        Function_Return (private.pbRecnum(Self))
93735>>>>>    End_Function
93736>>>>>
93736>>>>>    Procedure Set pbCopyData Boolean bState
93738>>>>>        Set private.pbCopyData  to bState
93739>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93740>>>>>        Delegate Set pbCopyData to bState
93742>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93743>>>>>    End_Procedure
93744>>>>>
93744>>>>>    Function pbCopyData Returns Boolean
93746>>>>>        Function_Return (private.pbCopyData(Self))
93747>>>>>    End_Function           
93748>>>>>    
93748>>>>>    // ToDo: Should we put these three properties under another "Property Panel" section?
93748>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
93750>>>>>        Set private.pbCompareDate_DateTime  to bState
93751>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93752>>>>>        Delegate Set pbCompareDate_DateTime to bState
93754>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93755>>>>>    End_Procedure
93756>>>>>
93756>>>>>    Function pbCompareDate_DateTime Returns Boolean
93758>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
93759>>>>>    End_Function           
93760>>>>>    
93760>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
93762>>>>>        Set private.pbCompareIndexAscending  to bState
93763>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93764>>>>>        Delegate Set pbCompareIndexAscending to bState
93766>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93767>>>>>    End_Procedure
93768>>>>>
93768>>>>>    Function pbCompareIndexAscending Returns Boolean
93770>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
93771>>>>>    End_Function           
93772>>>>>    
93772>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
93774>>>>>        Set private.pbCompareIndexUppercase  to bState
93775>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93776>>>>>        Delegate Set pbCompareIndexUppercase to bState
93778>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93779>>>>>    End_Procedure
93780>>>>>
93780>>>>>    Function pbCompareIndexUppercase Returns Boolean
93782>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
93783>>>>>    End_Function           
93784>>>>>    
93784>>>>>    Procedure Set psSchema String sValue
93786>>>>>        Set private.psSchema  to sValue
93787>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93788>>>>>        Delegate Set psSchema to sValue
93790>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93791>>>>>    End_Procedure
93792>>>>>
93792>>>>>    // First retrieve the private value that might have been set in the object.
93792>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93792>>>>>    // it might have been specified in the SQLConnections.ini file.
93792>>>>>    Function psSchema Returns String
93794>>>>>        String sValue
93794>>>>>        Get private.psSchema to sValue
93795>>>>>        If (sValue = "") Begin
93797>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
93798>>>>>        End
93798>>>>>>
93798>>>>>        Function_Return sValue
93799>>>>>    End_Function
93800>>>>>
93800>>>>>    Procedure Set psBaseTableSpace String sValue
93802>>>>>        Set private.psBaseTableSpace  to sValue
93803>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93804>>>>>        Delegate Set psBaseTableSpace to sValue
93806>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93807>>>>>    End_Procedure
93808>>>>>
93808>>>>>    // First retrieve the private value that might have been set in the object.
93808>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93808>>>>>    // it might have been specified in the SQLConnections.ini file.
93808>>>>>    Function psBaseTableSpace Returns String
93810>>>>>        String sValue
93810>>>>>        Get private.psBaseTableSpace to sValue
93811>>>>>        If (sValue = "") Begin
93813>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
93814>>>>>        End
93814>>>>>>
93814>>>>>        Function_Return sValue
93815>>>>>    End_Function
93816>>>>>
93816>>>>>    Procedure Set psLongTableSpace String sValue
93818>>>>>        Set private.psLongTableSpace  to sValue
93819>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93820>>>>>        Delegate Set psLongTableSpace to sValue
93822>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93823>>>>>    End_Procedure
93824>>>>>
93824>>>>>    // First retrieve the private value that might have been set in the object.
93824>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93824>>>>>    // it might have been specified in the SQLConnections.ini file.
93824>>>>>    Function psLongTableSpace Returns String
93826>>>>>        String sValue
93826>>>>>        Get private.psLongTableSpace to sValue
93827>>>>>        If (sValue = "") Begin
93829>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
93830>>>>>        End
93830>>>>>>
93830>>>>>        Function_Return sValue
93831>>>>>    End_Function
93832>>>>>
93832>>>>>    Procedure Set psIndexTableSpace String sValue
93834>>>>>        Set private.psIndexTableSpace  to sValue
93835>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93836>>>>>        Delegate Set psIndexTableSpace to sValue
93838>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93839>>>>>    End_Procedure
93840>>>>>
93840>>>>>    // First retrieve the private value that might have been set in the object.
93840>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
93840>>>>>    // it might have been specified in the SQLConnections.ini file.
93840>>>>>    Function psIndexTableSpace Returns String
93842>>>>>        String sValue
93842>>>>>        Get private.psIndexTableSpace to sValue
93843>>>>>        If (sValue = "") Begin
93845>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
93846>>>>>        End
93846>>>>>>
93846>>>>>        Function_Return sValue
93847>>>>>    End_Function
93848>>>>>
93848>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
93850>>>>>        Set private.psDriverDefaultValueASCII  to sValue
93851>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93852>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
93854>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93855>>>>>    End_Procedure
93856>>>>>
93856>>>>>    // First retrieve the private value that might have been set in the object.
93856>>>>>    // If blank; get it from the parent object
93856>>>>>    Function psDriverDefaultValueASCII Returns String
93858>>>>>        String sValue
93858>>>>>        Get private.psDriverDefaultValueASCII to sValue
93859>>>>>        If (sValue = "") Begin
93861>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
93863>>>>>        End
93863>>>>>>
93863>>>>>        Function_Return sValue
93864>>>>>    End_Function
93865>>>>>
93865>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
93867>>>>>        Set private.psDriverDefaultValueBinary  to sValue
93868>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93869>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
93871>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93872>>>>>    End_Procedure
93873>>>>>
93873>>>>>    // First retrieve the private value that might have been set in the object.
93873>>>>>    // If blank; get it from the parent object
93873>>>>>    Function psDriverDefaultValueBinary Returns String
93875>>>>>        String sValue
93875>>>>>        Get private.psDriverDefaultValueBinary to sValue
93876>>>>>        If (sValue = "") Begin
93878>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
93880>>>>>        End
93880>>>>>>
93880>>>>>        Function_Return sValue
93881>>>>>    End_Function
93882>>>>>
93882>>>>>    Procedure Set psDriverDefaultValueDate String sValue
93884>>>>>        Set private.psDriverDefaultValueDate  to sValue
93885>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93886>>>>>        Delegate Set psDriverDefaultValueDate to sValue
93888>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93889>>>>>    End_Procedure
93890>>>>>
93890>>>>>    // First retrieve the private value that might have been set in the object.
93890>>>>>    // If blank; get it from the parent object
93890>>>>>    Function psDriverDefaultValueDate Returns String
93892>>>>>        String sValue
93892>>>>>        Get private.psDriverDefaultValueDate to sValue
93893>>>>>        If (sValue = "") Begin
93895>>>>>            Delegate Get psDriverDefaultValueDate to sValue
93897>>>>>        End
93897>>>>>>
93897>>>>>        Function_Return sValue
93898>>>>>    End_Function
93899>>>>>
93899>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93901>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
93902>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93903>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
93905>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93906>>>>>    End_Procedure
93907>>>>>
93907>>>>>    // First retrieve the private value that might have been set in the object.
93907>>>>>    // If blank; get it from the parent object
93907>>>>>    Function psDriverDefaultValueDateTime Returns String
93909>>>>>        String sValue
93909>>>>>        Get private.psDriverDefaultValueDateTime to sValue
93910>>>>>        If (sValue = "") Begin
93912>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
93914>>>>>        End
93914>>>>>>
93914>>>>>        Function_Return sValue
93915>>>>>    End_Function
93916>>>>>
93916>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93918>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
93919>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93920>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
93922>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93923>>>>>    End_Procedure
93924>>>>>
93924>>>>>    // First retrieve the private value that might have been set in the object.
93924>>>>>    // If blank; get it from the parent object
93924>>>>>    Function psDriverDefaultValueNumeric Returns String
93926>>>>>        String sValue
93926>>>>>        Get private.psDriverDefaultValueNumeric to sValue
93927>>>>>        If (sValue = "") Begin
93929>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
93931>>>>>        End
93931>>>>>>
93931>>>>>        Function_Return sValue
93932>>>>>    End_Function
93933>>>>>
93933>>>>>    Procedure Set psDriverDefaultValueText String sValue
93935>>>>>        Set private.psDriverDefaultValueText  to sValue
93936>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93937>>>>>        Delegate Set psDriverDefaultValueText to sValue
93939>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93940>>>>>    End_Procedure
93941>>>>>
93941>>>>>    // First retrieve the private value that might have been set in the object.
93941>>>>>    // If blank; get it from the parent object
93941>>>>>    Function psDriverDefaultValueText Returns String
93943>>>>>        String sValue
93943>>>>>        Get private.psDriverDefaultValueText to sValue
93944>>>>>        If (sValue = "") Begin
93946>>>>>            Delegate Get psDriverDefaultValueText to sValue
93948>>>>>        End
93948>>>>>>
93948>>>>>        Function_Return sValue
93949>>>>>    End_Function
93950>>>>>
93950>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93952>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
93953>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93954>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
93956>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93957>>>>>    End_Procedure
93958>>>>>
93958>>>>>    // First retrieve the private value that might have been set in the object.
93958>>>>>    // If blank; get it from the parent object
93958>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93960>>>>>        Boolean bState
93960>>>>>        Get private.pbDriverDefaultNullableASCII to bState
93961>>>>>        If (bState = False) Begin
93963>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
93965>>>>>        End
93965>>>>>>
93965>>>>>        Function_Return bState
93966>>>>>    End_Function
93967>>>>>
93967>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93969>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
93970>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93971>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
93973>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93974>>>>>    End_Procedure
93975>>>>>
93975>>>>>    // First retrieve the private value that might have been set in the object.
93975>>>>>    // If blank; get it from the parent object
93975>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93977>>>>>        Boolean bState
93977>>>>>        Get private.pbDriverDefaultNullableBinary to bState
93978>>>>>        If (bState = False) Begin
93980>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
93982>>>>>        End
93982>>>>>>
93982>>>>>        Function_Return bState
93983>>>>>    End_Function
93984>>>>>
93984>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93986>>>>>        Set private.pbDriverDefaultNullableDate  to bState
93987>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93988>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
93990>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93991>>>>>    End_Procedure
93992>>>>>
93992>>>>>    // First retrieve the private value that might have been set in the object.
93992>>>>>    // If blank; get it from the parent object
93992>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
93994>>>>>        Boolean bState
93994>>>>>        Get private.pbDriverDefaultNullableDate to bState
93995>>>>>        If (bState = False) Begin
93997>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
93999>>>>>        End
93999>>>>>>
93999>>>>>        Function_Return bState
94000>>>>>    End_Function
94001>>>>>
94001>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
94003>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
94004>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94005>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
94007>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94008>>>>>    End_Procedure
94009>>>>>
94009>>>>>    // First retrieve the private value that might have been set in the object.
94009>>>>>    // If blank; get it from the parent object
94009>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
94011>>>>>        Boolean bState
94011>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
94012>>>>>        If (bState = False) Begin
94014>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
94016>>>>>        End
94016>>>>>>
94016>>>>>        Function_Return bState
94017>>>>>    End_Function
94018>>>>>
94018>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
94020>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
94021>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94022>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
94024>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94025>>>>>    End_Procedure
94026>>>>>
94026>>>>>    // First retrieve the private value that might have been set in the object.
94026>>>>>    // If blank; get it from the parent object
94026>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
94028>>>>>        Boolean bState
94028>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
94029>>>>>        If (bState = False) Begin
94031>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
94033>>>>>        End
94033>>>>>>
94033>>>>>        Function_Return bState
94034>>>>>    End_Function
94035>>>>>
94035>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
94037>>>>>        Set private.pbDriverDefaultNullableText  to bState
94038>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94039>>>>>        Delegate Set pbDriverDefaultNullableText to bState
94041>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94042>>>>>    End_Procedure
94043>>>>>
94043>>>>>    // First retrieve the private value that might have been set in the object.
94043>>>>>    // If blank; get it from the parent object
94043>>>>>    Function pbDriverDefaultNullableText Returns Boolean
94045>>>>>        Boolean bState
94045>>>>>        Get private.pbDriverDefaultNullableText to bState
94046>>>>>        If (bState = False) Begin
94048>>>>>            Delegate Get pbDriverDefaultNullableText to bState
94050>>>>>        End
94050>>>>>>
94050>>>>>        Function_Return bState
94051>>>>>    End_Function
94052>>>>>
94052>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
94054>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
94054>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
94054>>>>>
94054>>>>>        Get psDriverID to sDriverID
94055>>>>>        Get psSchema to sSchema
94056>>>>>
94056>>>>>        Get psBaseTableSpace to sBaseTableSpace
94057>>>>>        If (sBaseTableSpace <> "") Begin
94059>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94060>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
94062>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94063>>>>>        End
94063>>>>>>
94063>>>>>
94063>>>>>        Get psLongTableSpace to sLongTableSpace
94064>>>>>        If (sLongTableSpace <> "") Begin
94066>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94067>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
94069>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94070>>>>>        End
94070>>>>>>
94070>>>>>
94070>>>>>        Get psIndexTableSpace to sIndexTableSpace
94071>>>>>        If (sIndexTableSpace <> "") Begin
94073>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
94074>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
94076>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
94077>>>>>        End
94077>>>>>>
94077>>>>>
94077>>>>>        Get pbUseConnectionID to bUseConnectionID
94078>>>>>        Get pbToANSI          to bToANSI
94079>>>>>//ToDo: Why was this changed?
94079>>>>>//        Move True             to bRecnum
94079>>>>>//        Move True             to bCopyData
94079>>>>>        Get pbRecnum          to bRecnum
94080>>>>>        Get pbCopyData        to bCopyData
94081>>>>>
94081>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
94082>>>>>
94082>>>>>        Function_Return bOK
94083>>>>>    End_Function
94084>>>>>
94084>>>>>    // This is automatically called after the OnUpdate
94084>>>>>    // event has been executed. It will automatically update the
94084>>>>>    // version database field/column with the "pnVersionNumber"
94084>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
94084>>>>>    Procedure UpdateVersionColumnValue
94086>>>>>        Number nVersion nCurrentValue
94086>>>>>        Integer hTable iColumn
94086>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured
94086>>>>>
94086>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
94086>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
94086>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
94088>>>>>        Get pbVersionUpdate to bVersionUpdate
94089>>>>>
94089>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
94091>>>>>            Get pnVersionNumber    to nVersion
94092>>>>>            Get Private.Data_File  to hTable
94093>>>>>            Get Private.Data_Field to iColumn
94094>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
94094>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
94094>>>>>            Close DF_ALL DF_PERMANENT
94095>>>>>
94095>>>>>            Open hTable
94097>>>>>
94097>>>>>            // It is then the developer responsibility to take care of finding
94097>>>>>            // the correct record that is to be updated (The DbVersion table is not used).
94097>>>>>
94097>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
94100>>>>>            If (nCurrentValue < nVersion) Begin
94102>>>>>                Lock
94103>>>>>>
94103>>>>>                        Vfind hTable Recnum GE
94105>>>>>                    Set_Field_Value hTable iColumn to nVersion
94108>>>>>                    SaveRecord hTable
94109>>>>>                Unlock
94110>>>>>>
94110>>>>>            End
94110>>>>>>
94110>>>>>            Close hTable
94111>>>>>        End
94111>>>>>>
94111>>>>>    End_Procedure                              
94112>>>>>
94112>>>>>// Property of the container object (cDbUpdateHandler)    
94112>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
94112>>>>>
94112>>>>>    Procedure End_Construct_Object
94114>>>>>        Number nVersion nCurrentValue
94114>>>>>        Integer hTable iColumn iIndex iSize
94114>>>>>        Boolean bDatabaseUpdated bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bExists bOpened bSystemTable
94114>>>>>        String sObjectName sDatabase sDriverID
94114>>>>>        tDbVersionInfo[] dbVersionInfoArray
94114>>>>>        tDbVersionInfo[] dbVersionInfoArray
94115>>>>>        
94115>>>>>        Forward Send End_Construct_Object
94117>>>>>                
94117>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
94119>>>>>
94119>>>>>        // If the programmer forgot to set the version number we do not allow for the application
94119>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
94119>>>>>        // one database update is depended on an earlier update and that earlier version
94119>>>>>        // update was never executed it could lead to disastrous results.
94119>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
94119>>>>>        Get pnVersionNumber to nVersion
94120>>>>>        If (nVersion = 0) Begin
94122>>>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94123>>>>>            Move (Name(Self)) to sObjectName
94124>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
94125>>>>>>
94125>>>>>            Send Exit_Application
94126>>>>>        End                                 
94126>>>>>>
94126>>>>>        
94126>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
94126>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
94126>>>>>        Delegate Send OnPreUpdate
94128>>>>>        Delegate Send CheckAutoCreateDbVersionTable
94130>>>>>
94130>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
94130>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
94130>>>>>        Delegate Get paDbVersionInfoArray to dbVersionInfoArray
94132>>>>>        Move (SizeOfArray(dbVersionInfoArray)) to iSize
94133>>>>>        Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
94134>>>>>        Move (Self)   to dbVersionInfoArray[iSize].hObject
94135>>>>>        Delegate Set paDbVersionInfoArray to dbVersionInfoArray 
94137>>>>>        Delegate Send CheckForDuplicates nVersion
94139>>>>>
94139>>>>>        Get Private.Data_File  to hTable
94140>>>>>        Get Private.Data_Field to iColumn
94141>>>>>
94141>>>>>        // If no table & field/column name has been explicitly set as:
94141>>>>>        //   "Set Data_File_Field to (RefTable(OrdSys)) (RefTable(OrdSys.DbUpdateVersion))"
94141>>>>>        // we try to use the default "DbVersion" table.
94141>>>>>        If (hTable = 0) Begin
94143>>>>>            // And get the table/column properties from parent class (cDbUpdateHandler)
94143>>>>>            Get Data_File  to hTable
94144>>>>>            Get Data_Field to iColumn
94145>>>>>        End
94145>>>>>>
94145>>>>>
94145>>>>>        Open hTable
94147>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94150>>>>>        If (bOpened = False) Begin
94152>>>>>            Send Stop_Box CS_DbUpdateTableMissing
94153>>>>>            Send Exit_Application
94154>>>>>        End
94154>>>>>>
94154>>>>>
94154>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
94157>>>>>        If (bSystemTable = True) Begin
94159>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
94162>>>>>        End
94162>>>>>>
94162>>>>>        Else Begin
94163>>>>>        End
94163>>>>>>
94163>>>>>
94163>>>>>        Close hTable
94164>>>>>
94164>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
94164>>>>>        // If not set we do nothing.
94164>>>>>        If (nCurrentValue < nVersion) Begin
94166>>>>>
94166>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
94166>>>>>            // execution of database update code. So if true _and_ one error
94166>>>>>            // has already occured; we're out of here.
94166>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
94168>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
94170>>>>>            If (bStopOnFirstError = True) Begin
94172>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
94174>>>>>                    Procedure_Return
94175>>>>>                End
94175>>>>>>
94175>>>>>            End
94175>>>>>>
94175>>>>>
94175>>>>>           // This is send to the parent container object (cDbUpdateHandler)
94175>>>>>             Delegate Send InitDatabaseUpdate (Self)
94177>>>>>
94177>>>>>            // If the parent property pbContinueOnError = False, an update
94177>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
94177>>>>>            Delegate Get pbContinueOnError to bContinueOnError
94179>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
94181>>>>>                Procedure_Return
94182>>>>>            End
94182>>>>>>
94182>>>>>
94182>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
94184>>>>>
94184>>>>>            Set Title_Text of ghoStatusPanel to (CS_UpdateVersion * CS_UpdateFromVersion * String(nCurrentValue) * CS_UpdateToVersion * String(nVersion))
94185>>>>>
94185>>>>>            // *** Programmer's main hook message:
94185>>>>>            Send OnUpdate
94186>>>>>
94186>>>>>            Set pbVersionUpdate to True
94187>>>>>            Send UpdateVersionColumnValue
94188>>>>>            Delegate Set pbDatabaseWasUpdated to True
94190>>>>>        End
94190>>>>>>
94190>>>>>
94190>>>>>    End_Procedure
94191>>>>>
94191>>>>>End_Class
94192>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
94192>>>>>//****************************************************************************
94192>>>>>// $Module type: Class
94192>>>>>// $Module name: cDbUpdateUserCount.pkg
94192>>>>>// $Author     : Emil Stojanov Quantaris B.V.
94192>>>>>//
94192>>>>>//               Collected from DAW's newsgroups.
94192>>>>>//
94192>>>>>// Description : It uses the windows API to lock bytes in a file.
94192>>>>>//               If the application or PC craches it will release the lock
94192>>>>>//               automatically.
94192>>>>>//
94192>>>>>// Note 1      : It will count the number of running app's, so if a
94192>>>>>//               user starts the app twice on one machine it will count as two users.
94192>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
94192>>>>>//               However, to not conflict with any other usage of this class it was
94192>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
94192>>>>>//               and cDbUpdateVersion classes)
94192>>>>>//
94192>>>>>// $Rev History:
94192>>>>>//    2008-10-17  Module header created (Militaty data format)
94192>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
94192>>>>>//                for easy translation to other languages.
94192>>>>>//                Added the tUserCount struct for easier passing of parameters.
94192>>>>>//                Added the ApplicationPath message.
94192>>>>>//****************************************************************************
94192>>>>>Use LanguageText.pkg
94192>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
94192>>>>>>>Use GlobalFunctionsProcedures.pkg
94192>>>>>>>// Sample:
94192>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
94192>>>>>>>
94192>>>>>>>
94192>>>>>>>// Symbols used by UserCounting
94192>>>>>>>    Define GENERIC_READ         for |CI$80000000
94192>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
94192>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
94192>>>>>>>    Define GENERIC_ALL          for |CI$10000000
94192>>>>>>>    Define CREATE_NEW           for 1
94192>>>>>>>    Define CREATE_ALWAYS        for 2
94192>>>>>>>    Define OPEN_EXISTING        for 3
94192>>>>>>>    Define OPEN_ALWAYS          for 4
94192>>>>>>>    Define TRUNCATE_EXISTING    for 5
94192>>>>>>>    Define FILE_BEGIN           for 0
94192>>>>>>>    Define FILE_CURRENT         for 1
94192>>>>>>>    Define FILE_END             for 2
94192>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
94192>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
94192>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
94192>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
94192>>>>>>>    Define _MAX_PATH  for 260
94192>>>>>>>    Define _MAX_DRIVE for 3
94192>>>>>>>    Define _MAX_DIR   for 256
94192>>>>>>>    Define _MAX_FNAME for 256
94192>>>>>>>    Define _MAX_EXT   for 256
94192>>>>>>>
94192>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
94193>>>>>>>
94193>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
94194>>>>>>>
94194>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
94195>>>>>>>
94195>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
94196>>>>>>>
94196>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
94197>>>>>>>
94197>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
94198>>>>>>>
94198>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
94199>>>>>>>
94199>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
94200>>>>>>>// Sample:
94200>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
94200>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
94202>>>>>>>    Boolean bReturn
94202>>>>>>>    Move (ToANSI(sPrinter)) to sPrinter
94203>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
94204>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
94205>>>>>>>    Function_Return bReturn
94206>>>>>>>End_Function
94207>>>>>Use vWin32fh.pkg
94207>>>>>Use seq_chnl.pkg
94207>>>>>
94207>>>>>// User interface constant strings:
94207>>>>>    Define CS_UserCountError            for "User count error:"
94207>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
94207>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
94207>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
94207>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>
94207>>>>>    Struct tUserCount
94207>>>>>        Integer iUserCount
94207>>>>>        Integer iError
94207>>>>>        String  sErrorTxt
94207>>>>>    End_Struct
94207>>>>>
94207>>>>>    Define CI_UserCountMaxUsers for 9999
94207>>>>>
94207>>>>>Class cDbUpdateUserCount is a cObject
94208>>>>>    Procedure Construct_Object
94210>>>>>        Forward Send Construct_Object
94212>>>>>
94212>>>>>        Property String  psLockFileName
94213>>>>>        Property Integer piMaxUsers
94214>>>>>        Property Boolean pbCheckDataFlexUserCount True
94215>>>>>
94215>>>>>        Property Handle  phUserCountFile
94216>>>>>        Property Integer pdwLockPosition
94217>>>>>    End_Procedure
94218>>>>>
94218>>>>>    Function IsProgramRunning Returns Boolean
94220>>>>>        tUserCount UserCount
94220>>>>>        tUserCount UserCount
94220>>>>>
94220>>>>>        Get CheckUserCount to UserCount
94221>>>>>
94221>>>>>        Function_Return (UserCount.iUserCount > 1)
94222>>>>>    End_Function
94223>>>>>
94223>>>>>    // Returns the full path of the Application (no trailing "\")
94223>>>>>    Function ApplicationPath Returns String
94225>>>>>        String sApplicationFileName sPath
94225>>>>>        Integer iNumChars iRetval
94225>>>>>
94225>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
94226>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
94227>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
94228>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
94229>>>>>        Move (CString(sApplicationFileName)) to sPath
94230>>>>>
94230>>>>>        Function_Return sPath
94231>>>>>    End_Function
94232>>>>>
94232>>>>>    Function OpenUserCountFile String sFileName Returns Handle
94234>>>>>        Handle  hFile
94234>>>>>        Pointer pFileName
94234>>>>>        String sPath sFile
94234>>>>>        Integer iCh
94234>>>>>
94234>>>>>        GetAddress of sFileName to pFileName
94235>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
94236>>>>>
94236>>>>>        // If lock file doesn't exist, create it.
94236>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
94238>>>>>            Get ApplicationPath to sPath
94239>>>>>            Get vFolderFormat sPath to sPath
94240>>>>>            Move (sPath + psLockFileName(Self)) to sFile
94241>>>>>            Get Seq_Open_Output_Channel sFile to iCh
94242>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
94244>>>>>                Function_Return 0
94245>>>>>            End
94245>>>>>>
94245>>>>>            Direct_Output channel iCh sFile
94247>>>>>                Write channel iCh ""
94249>>>>>            Send Seq_Close_Channel iCh
94250>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
94251>>>>>        End
94251>>>>>>
94251>>>>>
94251>>>>>        Function_Return hFile
94252>>>>>    End_Function
94253>>>>>
94253>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
94255>>>>>        Integer iReturnValue
94255>>>>>
94255>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
94256>>>>>        If (iReturnValue = 0) Begin
94258>>>>>            Function_Return False
94259>>>>>        End
94259>>>>>>
94259>>>>>        Else Begin
94260>>>>>            Function_Return True
94261>>>>>        End
94261>>>>>>
94261>>>>>    End_Function
94262>>>>>
94262>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
94264>>>>>        Integer iReturnValue
94264>>>>>
94264>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
94265>>>>>        If (iReturnValue = 0) Begin
94267>>>>>            Function_Return False
94268>>>>>        End
94268>>>>>>
94268>>>>>        Else Begin
94269>>>>>            Function_Return True
94270>>>>>        End
94270>>>>>>
94270>>>>>    End_Function
94271>>>>>
94271>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
94273>>>>>        dWord dwCurrPos
94273>>>>>
94273>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
94274>>>>>        Function_Return dwCurrPos
94275>>>>>    End_Function
94276>>>>>
94276>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
94278>>>>>        DWord dwCurrPos
94278>>>>>
94278>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
94279>>>>>        Function_Return dwCurrPos
94280>>>>>    End_Function
94281>>>>>
94281>>>>>    Function ReadUserCountFile Handle hFile Returns Integer
94283>>>>>        Integer iReturnValue
94283>>>>>        String  sBuffer
94283>>>>>        Pointer pBuffer
94283>>>>>        String  sSize
94283>>>>>        Pointer pSize
94283>>>>>
94283>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
94284>>>>>        GetAddress of sBuffer to pBuffer
94285>>>>>
94285>>>>>        Move (Repeat((Character(0)),4)) to sSize
94286>>>>>        GetAddress of sSize to pSize
94287>>>>>
94287>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) To iReturnValue
94288>>>>>        If (iReturnValue = 0) Begin
94290>>>>>            Function_Return False
94291>>>>>        End
94291>>>>>>
94291>>>>>        Else Begin
94292>>>>>            Function_Return True
94293>>>>>        End
94293>>>>>>
94293>>>>>    End_Function
94294>>>>>
94294>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
94296>>>>>        Integer iReturnValue
94296>>>>>
94296>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) To iReturnValue
94297>>>>>        Function_Return iReturnValue
94298>>>>>    End_Function
94299>>>>>
94299>>>>>    Procedure DoCheckUserCount
94301>>>>>        tUserCount UserCount
94301>>>>>        tUserCount UserCount
94301>>>>>
94301>>>>>        Get CheckUserCount to UserCount
94302>>>>>        // If all is fine, we're done.
94302>>>>>        If (UserCount.iError = 0) Begin
94304>>>>>            Procedure_Return
94305>>>>>        End
94305>>>>>>
94305>>>>>
94305>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
94306>>>>>
94306>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
94308>>>>>            Abort
94309>>>>>>
94309>>>>>        End
94309>>>>>>
94309>>>>>    End_Procedure
94310>>>>>
94310>>>>>    Function CheckUserCount Returns tUserCount
94312>>>>>        Handle  hFile
94312>>>>>        String  sPath sFile
94312>>>>>        Integer iResult
94312>>>>>        DWord   dwFilePos
94312>>>>>        Integer bLocked
94312>>>>>        Integer iMaxUsers
94312>>>>>        Integer iCurUser
94312>>>>>        tUserCount UserCount
94312>>>>>        tUserCount UserCount
94312>>>>>
94312>>>>>        Move 0 to UserCount.iError
94313>>>>>
94313>>>>>        Get phUserCountFile to hFile
94314>>>>>        If (not(hFile)) Begin
94316>>>>>            Get ApplicationPath to sPath
94317>>>>>            Get vFolderFormat sPath to sPath
94318>>>>>            Move (sPath + psLockFileName(Self)) to sFile
94319>>>>>            Get OpenUserCountFile sFile to hFile
94320>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
94322>>>>>                Move 1 to UserCount.iUserCount
94323>>>>>                Move 1 to UserCount.iError
94324>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
94325>>>>>                Function_Return UserCount
94326>>>>>            End
94326>>>>>>
94326>>>>>            Else Begin
94327>>>>>                Move False to bLocked
94328>>>>>                Set phUserCountFile to hFile
94329>>>>>                Get piMaxUsers to iMaxUsers
94330>>>>>
94330>>>>>                // Set Filepointer to beginning of the file
94330>>>>>                Get ResetUserCountPointer hFile to dwFilePos
94331>>>>>                If (dwFilePos = -1) Begin
94333>>>>>                    Move 1 to UserCount.iUserCount
94334>>>>>                    Move 2 to UserCount.iError
94335>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
94336>>>>>                    Function_Return UserCount
94337>>>>>                End
94337>>>>>>
94337>>>>>                For iCurUser from 1 to iMaxUsers
94343>>>>>>
94343>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
94344>>>>>                    If (not(iResult)) Begin  // byte is locked
94346>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
94347>>>>>                        If (dwFilePos = -1) Begin
94349>>>>>                            Move 1 to UserCount.iUserCount
94350>>>>>                            Move 3 to UserCount.iError
94351>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
94352>>>>>                            Function_Return UserCount
94353>>>>>                        End
94353>>>>>>
94353>>>>>                    End
94353>>>>>>
94353>>>>>                    Else Begin  // byte is not locked
94354>>>>>                        Set pdwLockPosition to dwFilePos
94355>>>>>                        Move True to bLocked
94356>>>>>                        Move iMaxUsers to iCurUser
94357>>>>>                    End
94357>>>>>>
94357>>>>>                Loop
94358>>>>>>
94358>>>>>                If (not(bLocked)) Begin
94360>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
94361>>>>>                    Move 4 to UserCount.iError
94362>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
94363>>>>>                    Function_Return UserCount
94364>>>>>                End
94364>>>>>>
94364>>>>>            End
94364>>>>>>
94364>>>>>        End
94364>>>>>>
94364>>>>>
94364>>>>>        Function_Return UserCount
94365>>>>>    End_Function
94366>>>>>
94366>>>>>
94366>>>>>    Procedure DoReleaseUserCount
94368>>>>>        Integer iResult
94368>>>>>        Handle  hFile
94368>>>>>        DWord   dwLockPos
94368>>>>>
94368>>>>>        Get phUserCountFile to hFile
94369>>>>>        Get pdwLockPosition to dwLockPos
94370>>>>>        If (hFile) Begin
94372>>>>>            If (dwLockPos) Begin
94374>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
94375>>>>>            End
94375>>>>>>
94375>>>>>            Get CloseUserCountFile hFile to iResult
94376>>>>>        End
94376>>>>>>
94376>>>>>    End_Procedure
94377>>>>>
94377>>>>>    Function CurrentNumberOfUsers Returns Integer
94379>>>>>        Handle  hFile
94379>>>>>        Integer iMaxUsers
94379>>>>>        DWord   dwFilePos
94379>>>>>        Integer iCurUser
94379>>>>>        Integer iResult
94379>>>>>        Integer iNumberOfLocks
94379>>>>>        String  sPath sFile
94379>>>>>
94379>>>>>        Move 0 to iNumberOfLocks
94380>>>>>
94380>>>>>        Get ApplicationPath to sPath
94381>>>>>        Get vFolderFormat sPath to sPath
94382>>>>>        Move (sPath + psLockFileName(Self)) to sFile
94383>>>>>        Get OpenUserCountFile sFile to hFile
94384>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
94386>>>>>            Send UserError CS_UnableToInitUserCountSys
94387>>>>>            Abort
94388>>>>>>
94388>>>>>        End
94388>>>>>>
94388>>>>>
94388>>>>>        If (hFile > 0) Begin
94390>>>>>            Get piMaxUsers To iMaxUsers
94391>>>>>
94391>>>>>            // Set Filepointer to beginning of the file
94391>>>>>            Get ResetUserCountPointer hFile to dwFilePos
94392>>>>>            If (dwFilePos = -1) Begin
94394>>>>>                Send UserError CS_UnableResetUserCountSys
94395>>>>>                Abort
94396>>>>>>
94396>>>>>            End
94396>>>>>>
94396>>>>>            For iCurUser from 1 to iMaxUsers
94402>>>>>>
94402>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
94403>>>>>                If (Not(iResult)) Begin  // byte is locked
94405>>>>>                    Increment iNumberOfLocks
94406>>>>>                End
94406>>>>>>
94406>>>>>                Else Begin  // byte is not locked
94407>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
94408>>>>>                End
94408>>>>>>
94408>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
94409>>>>>                If (dwFilePos = -1) Begin
94411>>>>>                    Send UserError CS_ErrorAdvancingPointer
94412>>>>>                    Abort
94413>>>>>>
94413>>>>>                End
94413>>>>>>
94413>>>>>            Loop
94414>>>>>>
94414>>>>>        End
94414>>>>>>
94414>>>>>        Get CloseUserCountFile hFile to iResult
94415>>>>>        Function_Return iNumberOfLocks
94416>>>>>    End_Function
94417>>>>>
94417>>>>>End_Class
94418>>>Use cDbUpdateFunctionLibrary.pkg
94418>>>
94418>>>// ToDo: *** We need a way to set the SQL collation order for the database to be created!
94418>>>
94418>>>Class cDbUpdateHandler is a cObject
94419>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
94419>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
94420>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
94421>>>
94421>>>    Procedure Construct_Object
94423>>>        tUserCount UserCount
94423>>>        tUserCount UserCount
94423>>>        Integer iUserCount
94423>>>        Handle ho
94423>>>
94423>>>        Forward Send Construct_Object
94425>>>        Move Self to ghoDbUpdateHandler
94426>>>
94426>>>        // Struct array that will contain pnVersionNumbers & object id's of
94426>>>        // all child cDbVersion objects.
94426>>>        Property tDbVersionInfo[] paDbVersionInfoArray
94427>>>        
94427>>>        Property Boolean Private.pbUseCustomDbVersion False
94428>>>        Property Boolean Private.pbDbVersionCheckDone False
94429>>>        
94429>>>        // If this property = True _and_ Private.pbUseCustomDbVersion = False, 
94429>>>        // _and_ no DbVersion table exists when the framework is started, 
94429>>>        // a DbVersion table will be created automatically.
94429>>>        Property Boolean pbAutoCreateDbVersionTable True   
94430>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
94430>>>        // the Filelist.cfg slot number indicated by this property will be used
94430>>>        // if a DbVersion table is to be created. If this value = -1
94430>>>        // an Unhandled Exception Error will be genereted and the program halted. So
94430>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
94430>>>        // to a value that corresponds to a free Filelist.cfg slot number.
94430>>>        Property Integer piDbVersionFileSlotNumber -1 
94431>>>                
94431>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
94431>>>        // that creates all library properties
94431>>>        Send CreateDbUpdateLibraryProperties
94432>>>
94432>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
94433>>>
94433>>>
94433>>>        // Error handling:
94433>>>        Property Boolean Private.pbProcessingError False
94434>>>        Property Boolean pbDbUpdateErrorHasOccured False
94435>>>        // Don't touch. It is being used by the cDbUpdateVersion
94435>>>        // subclass to tell if that particular update went OK or not.
94435>>>        Property Boolean Private.pbUpdateVersionObjectError False
94436>>>        Property String[] paSQLQueryMessages
94437>>>
94437>>>        // Error handling:
94437>>>        // We temporarily redirect all errors to this object so we can
94437>>>        // log and write errors to the log file. It will be reset after
94437>>>        // the database updates have been finished.
94437>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
94438>>>        // Temporarily redirect all errors to this object so we can silently
94438>>>        // log all errors that might appear while updating the database.
94438>>>        Move Self to Error_Object_Id
94439>>>
94439>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
94440>>>
94440>>>        // Error Reporting Related
94440>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
94440>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
94441>>>
94441>>>        // If the pbContinueOnError = False, an update
94441>>>        // of another cDbUpdateVersion object will _not_ be
94441>>>        // performed if an error occured in a previous
94441>>>        // cDbUpdateVersion object.
94441>>>        Property Boolean pbContinueOnError False
94442>>>        // Stops execution in other cDbUpdateVersion objecs,
94442>>>        // if errors occurred in one cDbUpdateVersion object.
94442>>>        Property Boolean pbStopOnFirstError False
94443>>>        // If True errors that occured while updating the database
94443>>>        // will be shown in notepad.exe when done.
94443>>>        // Note: The log file will _always_ be created in the Data folder.
94443>>>        Property Boolean pbShowErrorLogPostRun True
94444>>>
94444>>>        // Be _very_ careful to set this property to true!
94444>>>        // If = True, no question will be asked if the update
94444>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
94444>>>        // the error log won't be shown. The logfile itself will still be created though.
94444>>>        // You have to know what you're doing!
94444>>>        Property Boolean pbSilentMode False   
94445>>>        
94445>>>        // Don't touch! Very private. The value is used by the error log to write for which
94445>>>        // cDbUpdateVersion object an error occured.
94445>>>        Property Number pnCurrentVersionUpdate 0
94446>>>
94446>>>        // The user counting logic is used to safe-guard agains anybody else is
94446>>>        // using the application when a database update is to be performed.
94446>>>        // (Garters & suspenders!)
94446>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
94447>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
94448>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
94449>>>
94449>>>        // This lock file is used to guard against somebody else tries to start the
94449>>>        // application while updates are in progress.
94449>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
94450>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
94451>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
94452>>>                                                                                      // Only the current user allowed.
94452>>>        // Properties for the table & column of a system file field/column where
94452>>>        // the database version update number gets saved.
94452>>>        Property Integer Private.Data_File  0
94453>>>        Property Integer Private.Data_Field 0
94454>>>
94454>>>        // Property that is used to indicate that we have already
94454>>>        // started the database update.
94454>>>        Property Boolean Private.pbDatabaseUpdateStarted False
94455>>>
94455>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
94455>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
94455>>>        // change of the database has been made.
94455>>>        Property Boolean Private.pbDatabaseWasUpdated False
94456>>>
94456>>>        // We need to trigger the user counting system so that a bit in the
94456>>>        // user counting file is locked. This is to guard that not more than one user
94456>>>        // is currently runnning the program.
94456>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
94457>>>
94457>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
94458>>>        If (iUserCount > 0) Begin
94460>>>            Send Stop_Box CS_UpdateInProgressTxt
94461>>>            Send Exit_Application
94462>>>        End
94462>>>>
94462>>>
94462>>>        Set pbHandleQueryErrors to False
94463>>>
94463>>>        If (ghoDbUpdateFunctionLibrary = 0) Begin
94465>>>            Move Self to ghoDbUpdateFunctionLibrary
94466>>>        End
94466>>>>
94466>>>
94466>>>        Property Handle phoSQLConnectionHandler 0
94467>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
94467>>>        // we will create one as it is used for all ConnectionID, ConnectionString
94467>>>        // etc information.
94467>>>        If (ghoSQLConnectionHandler = 0) Begin
94469>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
94470>>>            Set phoSQLConnectionHandler to ho
94471>>>        End
94471>>>>
94471>>>
94471>>>    End_Procedure
94472>>>
94472>>>    Procedure End_Construct_Object
94474>>>        Forward Send End_Construct_Object
94476>>>        Send Cleanup
94477>>>    End_Procedure
94478>>>    
94478>>>    Procedure CheckAutoCreateDbVersionTable
94480>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
94480>>>        Integer iDbVersionFileSlotNumber iRetval       
94480>>>        
94480>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
94481>>>        If (bDbVersionCheckDone = True) Begin
94483>>>            Procedure_Return
94484>>>        End
94484>>>>
94484>>>        Get Private.pbUseCustomDbVersion to bUseCustomDbVersion
94485>>>        If (bUseCustomDbVersion = True) Begin
94487>>>            Procedure_Return
94488>>>        End                 
94488>>>>
94488>>>
94488>>>        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary "DbVersion" to iRetval
94489>>>        If (iRetval <> 0) Begin
94491>>>            Procedure_Return
94492>>>        End
94492>>>>
94492>>>        
94492>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
94493>>>        Get piDbVersionFileSlotNumber  to iDbVersionFileSlotNumber
94494>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileSlotNumber = -1) Begin
94496>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94497>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
94498>>>>
94498>>>            Send Exit_Application
94499>>>        End
94499>>>>
94499>>>        
94499>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary iDbVersionFileSlotNumber to bTableExists
94500>>>        If (bTableExists = True) Begin
94502>>>            Set Private.pbDbVersionCheckDone to True
94503>>>            Procedure_Return
94504>>>        End 
94504>>>>
94504>>>        
94504>>>        // Note: If the piDbVersionFileSlotNumber has not been set in the object code,
94504>>>        //       we default to the first free slot in the Filelist.cfg
94504>>>//        If (iDbVersionFileSlotNumber = -1) Begin
94504>>>//            Get_Attribute DF_FILE_NEXT_EMPTY of 0 to iDbVersionFileSlotNumber
94504>>>//        End
94504>>>        Send CreateDbVersionTable iDbVersionFileSlotNumber
94505>>>        
94505>>>        // We only need to these DbVersion checks once, but because this message is called
94505>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
94505>>>        // we use a property to only run these tests once.
94505>>>        Set Private.pbDbVersionCheckDone to True
94506>>>    End_Procedure
94507>>>    
94507>>>    Procedure CreateDbVersionTable Handle hTable
94509>>>        String sTableName sColumnName sInfoTxt sDriverID
94509>>>        Integer iDataType iLength iDecimals
94509>>>        Boolean bTableExists bOK bUseConnectionID 
94509>>>        tAPIColumn[] APIColumn
94509>>>        tAPIColumn[] APIColumn
94510>>>        
94510>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
94511>>>        If (bTableExists = True) Begin
94513>>>            Procedure_Return
94514>>>        End                 
94514>>>>
94514>>>        
94514>>>        Get psDriverID to sDriverID
94515>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
94516>>>        
94516>>>        Move "DbVersion"        to sTableName          
94517>>>        Move 1                  to APIColumn[0].iFieldNumber
94518>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName 
94519>>>        Move DF_BCD             to APIColumn[0].iType  
94520>>>        Move False              to APIColumn[0].bIsSQLType
94521>>>        Move 4                  to APIColumn[0].iLength
94522>>>        Move 2                  to APIColumn[0].iPrecision
94523>>>        
94523>>>        Move False to Err
94524>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
94525>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
94526>>>        
94526>>>        If (bOK = True and Err = False) Begin
94528>>>            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
94529>>>        End
94529>>>>
94529>>>        Else Begin
94530>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
94531>>>        End
94531>>>>
94531>>>        
94531>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
94532>>>    End_Procedure
94533>>>
94533>>>    Procedure Set pbVerboseState Boolean bVerboseState
94535>>>        Handle ho
94535>>>        Get phoLogFile to ho
94536>>>        Set pbVerboseState of ho to bVerboseState
94537>>>    End_Procedure
94538>>>
94538>>>    Function pbVerboseState Returns Boolean
94540>>>        Boolean bVerboseState
94540>>>        Handle ho
94540>>>        Get phoLogFile to ho
94541>>>        Get pbVerboseState of ho to bVerboseState
94542>>>        Function_Return bVerboseState
94543>>>    End_Function
94544>>>
94544>>>    // Callback functionality used when e.g. calling driver functions directly.
94544>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94544>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94546>>>        Integer iRetval iPos iPerc
94546>>>        String sVal1 sVal2
94546>>>        Number nReady nTotal nVersion
94546>>>        Boolean bVerboseState
94546>>>        Handle hoLogFile
94546>>>
94546>>>        Get pbVerboseState to bVerboseState
94547>>>        Get pnCurrentVersionUpdate to nVersion
94548>>>        Get phoLogFile     to hoLogFile
94549>>>        Send DoAdvance of ghoProgressBar
94550>>>
94550>>>        If (sCallback_Text contains "Copy records") Begin
94552>>>            Move CS_SQLCopyingData to sCallback_Text
94553>>>        End
94553>>>>
94553>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94555>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
94556>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
94557>>>        End
94557>>>>
94557>>>        If (sCallback_Text contains "Creating index") Begin
94559>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
94560>>>        End
94560>>>>
94560>>>
94560>>>        Case Begin
94560>>>            Case (iCallback_Type = DF_Message_Text)
94562>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94563>>>                Set Action_Text  of ghoStatusPanel to ""
94564>>>                If (bVerboseState = True) Begin
94566>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False
94567>>>                End
94567>>>>
94567>>>                Case Break
94568>>>            Case (iCallback_Type = DF_Message_Heading_1)
94571>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94572>>>                Set Action_Text  of ghoStatusPanel to ""
94573>>>                If (bVerboseState = True) Begin
94575>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False
94576>>>                End
94576>>>>
94576>>>                Case Break
94577>>>            Case (iCallback_Type = DF_Message_Heading_2)
94580>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94581>>>                Set Action_Text  of ghoStatusPanel to ""
94582>>>                If (bVerboseState = True) Begin
94584>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False
94585>>>                End
94585>>>>
94585>>>                Case Break
94586>>>            Case (iCallback_Type = DF_Message_Heading_3)
94589>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94590>>>                Set Action_Text  of ghoStatusPanel to ""
94591>>>                If (bVerboseState = True) Begin
94593>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False
94594>>>                End
94594>>>>
94594>>>                Case Break
94595>>>            Case (iCallback_Type = DF_Message_Heading_4)
94598>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94599>>>                Set Action_Text  of ghoStatusPanel to ""
94600>>>                If (bVerboseState = True) Begin
94602>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False
94603>>>                End
94603>>>>
94603>>>                Case Break
94604>>>            Case (iCallback_Type = DF_Message_Heading_5)
94607>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94608>>>                Set Action_Text  of ghoStatusPanel to ""
94609>>>                If (bVerboseState = True) Begin
94611>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False
94612>>>                End
94612>>>>
94612>>>                Case Break
94613>>>            Case (iCallback_Type = DF_Message_Warning)
94616>>>                If (bVerboseState = True) Begin
94618>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False
94619>>>                End
94619>>>>
94619>>>                Case Break
94620>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94623>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94624>>>                Set Action_Text  of ghoStatusPanel to ""
94625>>>                If (bVerboseState = True) Begin
94627>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False
94628>>>                End
94628>>>>
94628>>>                Case Break
94629>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94632>>>                //*** Interpret numbers
94632>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94633>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94634>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94635>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94636>>>                Case Break
94637>>>            Case Else
94637>>>                Set Message_Text to ""
94638>>>                Set Action_Text  to ""
94639>>>        Case End
94639>>>
94639>>>        Send ProcessEvents of ghoStatusPanel
94640>>>        Function_Return False
94641>>>    End_Function
94642>>>
94642>>>    // This was made to be a procedure/function pair so we
94642>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94642>>>    Procedure Set psDriverID String sDriverID
94644>>>        If (ghoSQLConnectionHandler = 0) Begin
94646>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94647>>>>
94647>>>            Procedure_Return
94648>>>        End
94648>>>>
94648>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94649>>>    End_Procedure
94650>>>
94650>>>    Function psDriverID Returns String
94652>>>        String sValue
94652>>>        If (ghoSQLConnectionHandler = 0) Begin
94654>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94655>>>>
94655>>>            Procedure_Return
94656>>>        End
94656>>>>
94656>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94657>>>        Function_Return sValue
94658>>>    End_Function
94659>>>
94659>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94661>>>        If (ghoSQLConnectionHandler = 0) Begin
94663>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94664>>>>
94664>>>            Procedure_Return
94665>>>        End
94665>>>>
94665>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94666>>>    End_Procedure
94667>>>
94667>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94669>>>        Integer iRetval
94669>>>        If (ghoSQLConnectionHandler = 0) Begin
94671>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94672>>>>
94672>>>            Function_Return 2
94673>>>        End
94673>>>>
94673>>>
94673>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94674>>>        Function_Return iRetval
94675>>>    End_Function
94676>>>
94676>>>    Procedure Set psConnectionID String sValue
94678>>>        If (ghoSQLConnectionHandler = 0) Begin
94680>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94681>>>>
94681>>>            Procedure_Return
94682>>>        End
94682>>>>
94682>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94683>>>    End_Procedure
94684>>>
94684>>>    Function psConnectionID Returns String
94686>>>        String sValue
94686>>>        If (ghoSQLConnectionHandler = 0) Begin
94688>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94689>>>>
94689>>>            Procedure_Return
94690>>>        End
94690>>>>
94690>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94691>>>
94691>>>        Function_Return sValue
94692>>>    End_Function
94693>>>
94693>>>    // These "properties" are settings of the cCLIHandler class, but are being
94693>>>    // relayed to the ghoSQLConnectionHandler object
94693>>>    // simply by changing one of its parameters.
94693>>>    Procedure Set psServer String sValue
94695>>>        If (ghoSQLConnectionHandler = 0) Begin
94697>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94698>>>>
94698>>>            Procedure_Return
94699>>>        End
94699>>>>
94699>>>        Set psServer of ghoSQLConnectionHandler to sValue
94700>>>    End_Procedure
94701>>>
94701>>>    Function psServer Returns String
94703>>>        String sValue
94703>>>        If (ghoSQLConnectionHandler = 0) Begin
94705>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94706>>>>
94706>>>            Procedure_Return
94707>>>        End
94707>>>>
94707>>>        Get psServer of ghoSQLConnectionHandler to sValue
94708>>>
94708>>>        Function_Return sValue
94709>>>    End_Function
94710>>>
94710>>>    Procedure Set psDatabase String sValue
94712>>>        If (ghoSQLConnectionHandler = 0) Begin
94714>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94715>>>>
94715>>>            Procedure_Return
94716>>>        End
94716>>>>
94716>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94717>>>    End_Procedure
94718>>>
94718>>>    Function psDatabase Returns String
94720>>>        String sValue
94720>>>        If (ghoSQLConnectionHandler = 0) Begin
94722>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94723>>>>
94723>>>            Procedure_Return
94724>>>        End
94724>>>>
94724>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94725>>>
94725>>>        Function_Return sValue
94726>>>    End_Function
94727>>>
94727>>>    Procedure Set psUserID String sValue
94729>>>        If (ghoSQLConnectionHandler = 0) Begin
94731>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94732>>>>
94732>>>            Procedure_Return
94733>>>        End
94733>>>>
94733>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94734>>>    End_Procedure
94735>>>
94735>>>    Function psUserID Returns String
94737>>>        String sValue
94737>>>        If (ghoSQLConnectionHandler = 0) Begin
94739>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94740>>>>
94740>>>            Procedure_Return
94741>>>        End
94741>>>>
94741>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94742>>>
94742>>>        Function_Return sValue
94743>>>    End_Function
94744>>>
94744>>>    Procedure Set psPassword String sValue
94746>>>        If (ghoSQLConnectionHandler = 0) Begin
94748>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94749>>>>
94749>>>            Procedure_Return
94750>>>        End
94750>>>>
94750>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94751>>>    End_Procedure
94752>>>
94752>>>    Function psPassword Returns String
94754>>>        String sValue
94754>>>        If (ghoSQLConnectionHandler = 0) Begin
94756>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94757>>>>
94757>>>            Procedure_Return
94758>>>        End
94758>>>>
94758>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94759>>>
94759>>>        Function_Return sValue
94760>>>    End_Function
94761>>>
94761>>>    Procedure Set pbTrusted Boolean bValue
94763>>>        If (ghoSQLConnectionHandler = 0) Begin
94765>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94766>>>>
94766>>>            Procedure_Return
94767>>>        End
94767>>>>
94767>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94768>>>    End_Procedure
94769>>>
94769>>>    Function pbTrusted Returns Boolean
94771>>>        Boolean bValue
94771>>>        If (ghoSQLConnectionHandler = 0) Begin
94773>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94774>>>>
94774>>>            Procedure_Return
94775>>>        End
94775>>>>
94775>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94776>>>
94776>>>        Function_Return bValue
94777>>>    End_Function
94778>>>
94778>>>    Procedure Set psConnectionString String sValue
94780>>>        If (ghoSQLConnectionHandler = 0) Begin
94782>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94783>>>>
94783>>>            Procedure_Return
94784>>>        End
94784>>>>
94784>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94785>>>    End_Procedure
94786>>>
94786>>>    Function psConnectionString Returns String
94788>>>        String sValue
94788>>>        If (ghoSQLConnectionHandler = 0) Begin
94790>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94791>>>>
94791>>>            Procedure_Return
94792>>>        End
94792>>>>
94792>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94793>>>
94793>>>        Function_Return sValue
94794>>>    End_Function
94795>>>
94795>>>    Function piConnectionOptions Returns Integer
94797>>>        Integer iValue
94797>>>        If (ghoSQLConnectionHandler = 0) Begin
94799>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94800>>>>
94800>>>            Procedure_Return
94801>>>        End
94801>>>>
94801>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94802>>>
94802>>>        Function_Return iValue
94803>>>    End_Function
94804>>>    
94804>>>    
94804>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94806>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94807>>>    End_Procedure
94808>>>
94808>>>    Function pbCheckDataFlexUserCount Returns Boolean
94810>>>        Boolean bState
94810>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94811>>>        Function_Return bState
94812>>>    End_Function
94813>>>    
94813>>>    Procedure Set psLogTextFile String sValue
94815>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94816>>>    End_Procedure
94817>>>
94817>>>    Function psLogTextFile Returns String
94819>>>        String sValue
94819>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94820>>>        Function_Return sValue
94821>>>    End_Procedure
94822>>>
94822>>>    Procedure Set psEditorProgram String sValue
94824>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94825>>>    End_Procedure
94826>>>
94826>>>    Function psEditorProgram Returns String
94828>>>        String sValue
94828>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94829>>>        Function_Return sValue
94830>>>    End_Procedure
94831>>>
94831>>>    Procedure Set pbUseDataTable Boolean bState
94833>>>        Set pbUseDataTable of (phoLogFile(Self)) to bState
94834>>>    End_Procedure
94835>>>
94835>>>    Function pbUseDataTable Returns Boolean
94837>>>        Boolean bState
94837>>>        Get pbUseDataTable of (phoLogFile(Self)) to bState
94838>>>        Function_Return bState
94839>>>    End_Function
94840>>>
94840>>>    Procedure Set pbQuickWrite Boolean bState
94842>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94843>>>    End_Procedure
94844>>>
94844>>>    Function pbQuickWrite Returns Boolean
94846>>>        Boolean bState
94846>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94847>>>        Function_Return bState
94848>>>    End_Function
94849>>>
94849>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94851>>>        Boolean bUpdateVersionObjectError bVerboseState
94851>>>        Integer iSize iCount
94851>>>        Number nVersion
94851>>>        String[] aSQLQueryMessages
94852>>>
94852>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94853>>>        Set Private.pbDatabaseWasUpdated to bState
94854>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94854>>>        // to the log that it was OK.
94854>>>        If (bUpdateVersionObjectError = False) Begin
94856>>>            Get pnCurrentVersionUpdate to nVersion
94857>>>            Send LogError of (phoLogFile(Self)) nVersion 0 "The database was updated successfully!" 0 False
94858>>>        End
94858>>>>
94858>>>
94858>>>        Get pbVerboseState to bVerboseState
94859>>>        If (bVerboseState = True) Begin
94861>>>            Get paSQLQueryMessages to aSQLQueryMessages
94862>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94863>>>            Decrement iSize
94864>>>            For iCount from 0 to iSize
94870>>>>
94870>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94871>>>            Loop
94872>>>>
94872>>>        End
94872>>>>
94872>>>
94872>>>    End_Procedure
94873>>>
94873>>>    Function pbDatabaseWasUpdated Returns Boolean
94875>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94876>>>    End_Function
94877>>>
94877>>>    Procedure Bind_Data Integer iFile Integer iField
94879>>>        Set Data_File  to iFile
94880>>>        Set Data_Field to iField
94881>>>    End_Procedure
94882>>>
94882>>>    // ToDo: Is this possible to show in the Studio's Property panel?
94882>>>    Procedure Set Data_File_Field Integer iFile Integer iField
94884>>>        Set Private.Data_File  to iFile
94885>>>        Set Private.Data_Field to iField
94886>>>    End_Procedure
94887>>>
94887>>>//    { Visibility=Public MethodType=Property Category="Data" }
94887>>>    Procedure Set DataFile Integer iFile
94889>>>        Set Private.Data_File to iFile
94890>>>    End_Procedure
94891>>>
94891>>>//    { Visibility=Public MethodType=Property Category="Data" }
94891>>>    Function DataFile Integer iFile Returns Integer
94893>>>        Function_Return (Private.Data_File(Self))
94894>>>    End_Function
94895>>>
94895>>>//    { Visibility=Public MethodType=Property Category="Data" }
94895>>>    Procedure Set DataField Integer iField
94897>>>        Set Private.Data_Field to iField
94898>>>    End_Procedure
94899>>>
94899>>>//    { Visibility=Public MethodType=Property Category="Data" }
94899>>>    Function DataField Integer iField Returns Integer
94901>>>        Function_Return (Private.Data_Field(Self))
94902>>>    End_Function
94903>>>
94903>>>    // This event is triggered by the cDbUpdateVersion child class when
94903>>>    // a database change is to be started, and is considered private.
94903>>>    // It is only executed once for the first cDbUpateVersion object!
94903>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94905>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94905>>>        Integer iRetval iDataFlexUsers iUserCount iDbType
94905>>>        Handle hoUserCountSystem
94905>>>        tUserCount UserCount
94905>>>        tUserCount UserCount
94905>>>        DateTime dtUpdateStarted
94905>>>        tSQLConnection SQLConnection
94905>>>        tSQLConnection SQLConnection
94905>>>        String sValue sDriverID
94905>>>
94905>>>        // *Important:* If we already started the update; we do no further checking.
94905>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94906>>>        If (bDatabaseUpdateStarted = True) Begin
94908>>>            Procedure_Return
94909>>>        End
94909>>>>
94909>>>
94909>>>        // If not silent mode; Ask user if OK to start database update.
94909>>>        If (pbSilentMode(Self) = False) Begin
94911>>>            Get YesNo_Box CS_DatabaseNeedsUpdate CS_HeaderUpdateText to iRetval
94912>>>            If (iRetval <> MBR_Yes) Begin
94914>>>                Send Exit_Application
94915>>>            End
94915>>>>
94915>>>        End
94915>>>>
94915>>>
94915>>>        Move 0 to iDataFlexUsers
94916>>>        // Make various tests to check that the database is not in use.
94916>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94917>>>        // We also use our own user counting mechanism to guard against the
94917>>>        // database isn't opened already as we need exclusive access to the tables.:
94917>>>        Get phoUserCountSystem to hoUserCountSystem
94918>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94919>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94920>>>
94920>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94921>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94921>>>        If (bCheckDataFlexUserCount = True) Begin
94923>>>            Get_Current_User_Count to iDataFlexUsers
94924>>>            // For some reason DataFlex - in some cases - might think that 2 users
94924>>>            // are in use while debugging from the Studio.
94924>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94926>>>                Decrement iDataFlexUsers
94927>>>            End
94927>>>>
94927>>>        End
94927>>>>
94927>>>
94927>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94929>>>            Get YesNo_Box CS_DatabaseInUseShort to iRetval
94930>>>            If (iRetval <> MBR_Yes) Begin
94932>>>                Send Exit_Application
94933>>>            End
94933>>>>
94933>>>        End 
94933>>>>
94933>>>        
94933>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94935>>>            Send Stop_Box CS_DatabaseInUseText
94936>>>            Send Exit_Application
94937>>>        End
94937>>>>
94937>>>
94937>>>        // This will put a look on the DbUpdateLock.ucf file.
94937>>>        // It is released when the update process is finished
94937>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94938>>>
94938>>>        Move (CurrentDateTime()) to dtUpdateStarted
94939>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94940>>>        Set Private.pbDatabaseUpdateStarted to True
94941>>>
94941>>>        // This will save the status of all open tables including Master/Alias settings,
94941>>>        // so we can restore them later;
94941>>>        Send SaveOpenTables
94942>>>
94942>>>        // OK, we now have done what we can to check that we can update
94942>>>        // the database safely...
94942>>>        Send EnableCancelButton     of ghoStatusPanel False
94943>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_WorkingUpdateText) CS_WorkingHeaderText ""
94944>>>        Send Start_StatusPanel      of ghoStatusPanel
94945>>>
94945>>>        // We need to close all tables before starting to make changes.
94945>>>        Close DF_ALL DF_PERMANENT
94946>>>
94946>>>        // If these properties has not exclicitly been set in the object, set them
94946>>>        // to settings from the SQLConnections.ini file;
94946>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94947>>>        If (psSchema(Self) = "") Begin
94949>>>            Set psSchema            to SQLConnection.sSchema
94950>>>        End
94950>>>>
94950>>>        If (psBaseTableSpace(Self) = "") Begin
94952>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94953>>>        End
94953>>>>
94953>>>        If (psLongTableSpace(Self) = "") Begin
94955>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94956>>>        End
94956>>>>
94956>>>        If (psIndexTableSpace(Self) = "") Begin
94958>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94959>>>        End
94959>>>>
94959>>>
94959>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94960>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94962>>>            Procedure_Return
94963>>>        End
94963>>>>
94963>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94964>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94966>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94967>>>            Send Stop_StatusPanel of ghoStatusPanel
94968>>>            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94969>>>>
94969>>>            Send Exit_Application
94970>>>        End
94970>>>>
94970>>>    End_Procedure
94971>>>
94971>>>    // *** Hook message for pre-processing ***
94971>>>    // The programmer can use this event for putting code that
94971>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94971>>>    // child objects are executed.
94971>>>    Procedure OnPreUpdate
94973>>>    End_Procedure
94974>>>
94974>>>    // *** Hook message for post-processing ***
94974>>>    // The programmer should use this event for putting code that
94974>>>    // needs to be executed _after_ all database updates have finished.
94974>>>    Procedure OnPostUpdate
94976>>>    End_Procedure
94977>>>
94977>>>    // *** Hook message for custom DbVersion record find ***
94977>>>    // The programmer can use this event for putting code that
94977>>>    // needs to be executed to find a *custom* DbVersion table record.
94977>>>    // By default the DbVersion table is used but this can be
94977>>>    // customized by adding this line to the code;
94977>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94977>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94977>>>    //       to save the current database version to. Only if you use your own
94977>>>    //       table _and_ it is not a system table (contains only one record).
94977>>>    Procedure OnFindVersionRecord
94979>>>        // Open MyTable
94979>>>        // Move xx to MyTable.Field1
94979>>>        // Move yy to MyTable.Field2
94979>>>        // Find le MyTable by Index.x
94979>>>    End_Procedure
94980>>>
94980>>>    // Hook event for writing header error text (pre-update) to
94980>>>    // a datatable. Only called if the pbUseDataTable property = True.
94980>>>    // Don't forget to Open the table first (!) as all
94980>>>    // tables have been closed at this stage.
94980>>>    // The start date & time is passed.
94980>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94982>>>    End_Procedure
94983>>>
94983>>>    // Hook event to log errors to a database table.
94983>>>    // Only called if the pbUseDataTable = True.
94983>>>    // Don't forget to Open the table first (!) as all
94983>>>    // tables have been closed at this stage.
94983>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94983>>>    // will contain just one row, as it is called for each error
94983>>>    // that occurred. Else it is called once at the end after all updates
94983>>>    // have run and contains all errors.
94983>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94985>>>    End_Procedure
94986>>>
94986>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94986>>>    Procedure Cleanup
94988>>>        Integer[] iFileMasterArray iFileAliasArray
94990>>>        Boolean bDatabaseWasUpdated bError
94990>>>
94990>>>        Send RestoreOpenTables
94991>>>
94991>>>        // The function library have two purposes; one is to use it in the
94991>>>        // Database Update Framework, but it can also be used on its own.
94991>>>        // If that is the case it has its own error handling system, which
94991>>>        // we temporarily disbled when running updates because we have
94991>>>        // error handling/logging here too... We now restore its setting.
94991>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94993>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94994>>>        End
94994>>>>
94994>>>        Set pbHandleQueryErrors to True
94995>>>
94995>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94996>>>        Get pbDbUpdateErrorHasOccured to bError
94997>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94999>>>
94999>>>            // We should always create the log as it also contains info about
94999>>>            // the update being successful.
94999>>>            Send WriteErrorLog of (phoLogFile(Self))
95000>>>
95000>>>            // This is a programmer's hook message:
95000>>>            Send OnPostUpdate
95001>>>
95001>>>            Send Stop_StatusPanel of ghoStatusPanel
95002>>>
95002>>>            If (pbSilentMode(Self) = False) Begin
95004>>>                If (bError = True) Begin
95006>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
95008>>>                        Send ShowErrorLog of (phoLogFile(Self))
95009>>>                    End
95009>>>>
95009>>>                    Send Info_Box CS_DbUpdatedErrorText
95010>>>                    Send Exit_Application
95011>>>                End
95011>>>>
95011>>>                Else Begin
95012>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
95014>>>                        Send Info_Box CS_DatabaseUpdatedText
95015>>>                    End
95015>>>>
95015>>>                    Else Begin
95016>>>                        Send Info_Box CS_DatabaseCheckedText
95017>>>                    End
95017>>>>
95017>>>
95017>>>                End
95017>>>>
95017>>>            End
95017>>>>
95017>>>        End
95017>>>>
95017>>>
95017>>>        // Restore the standard error handler:
95017>>>        Get piCurrentErrorHandlerID to Error_Object_Id
95018>>>    End_Procedure
95019>>>
95019>>>    // We do this _before_ we close the database to make changes, and save
95019>>>    // all 'Master' & 'Alias' tables settings so we can restore when
95019>>>    // we reopen the database.
95019>>>    Procedure SaveOpenTables
95021>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95021>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95022>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
95023>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
95024>>>    End_Procedure
95025>>>
95025>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
95025>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
95025>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
95027>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95027>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95028>>>        Integer hTable iMasterAliasType iSize
95028>>>        Boolean bOpen
95028>>>
95028>>>        Move 0 to hTable
95029>>>        Repeat
95029>>>>
95029>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95032>>>            If (hTable <> 0) Begin
95034>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95037>>>                If (bOpen = True) Begin
95039>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
95042>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
95043>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
95044>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
95045>>>                End
95045>>>>
95045>>>            End
95045>>>>
95045>>>        Until (hTable = 0)
95047>>>
95047>>>        Function_Return aDbUpdateHandlerMasterAlias
95048>>>    End_Function
95049>>>
95049>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
95049>>>    // Takes one parameter:
95049>>>    //   A struct array with all master & alias
95049>>>    Procedure RestoreOpenTables
95051>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95051>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
95052>>>        Integer hTable iFileAlias iSize iCount
95052>>>        Boolean bOpen
95052>>>        String sRootName
95052>>>
95052>>>        Move 0 to hTable
95053>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
95054>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
95055>>>        Decrement iSize
95056>>>        For iCount from 0 to iSize
95062>>>>
95062>>>            Move aDbUpdateHandlerMasterAlias[iSize].hTable to hTable
95063>>>            // We also need to check that the table hasn't been removed...
95063>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95066>>>            If (hTable <> 0 and sRootName <> "") Begin
95068>>>                Open hTable
95070>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95073>>>                If (bOpen = True) Begin
95075>>>                    Move aDbUpdateHandlerMasterAlias[iSize].iMode to iFileAlias
95076>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
95078>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
95081>>>                    End
95081>>>>
95081>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
95084>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
95087>>>                    End
95087>>>>
95087>>>                End
95087>>>>
95087>>>            End
95087>>>>
95087>>>        Loop
95088>>>>
95088>>>    End_Procedure     
95089>>>    
95089>>>    // This checks for both duplicate pnVersionNumbers _and_ that
95089>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
95089>>>    Procedure CheckForDuplicates Number nVersion 
95091>>>        tDbVersionInfo[] DbVersionInfoArray
95091>>>        tDbVersionInfo[] DbVersionInfoArray
95092>>>        Integer iCount iSize iHits iDuplicateIndex
95092>>>        Number nCompare                                               
95092>>>        Handle hObject1 hObject2
95092>>>        String sObjectName1 sObjectName2
95092>>>        Boolean bObjectOrderError
95092>>>        
95092>>>        Get paDbVersionInfoArray to DbVersionInfoArray
95093>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
95094>>>        Decrement iSize
95095>>>        Move 0 to iHits                                               
95096>>>        Move 0 to nCompare  
95097>>>        Move False to bObjectOrderError
95098>>>        For iCount from 0 to iSize
95104>>>>
95104>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
95106>>>                Increment iHits
95107>>>                If (iHits > 1) Begin
95109>>>                    Move iCount to iDuplicateIndex
95110>>>                    If (nCompare <> 0) Begin
95112>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
95113>>>                    End
95113>>>>
95113>>>                End
95113>>>>
95113>>>            End
95113>>>>
95113>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
95114>>>        Loop
95115>>>>
95115>>>        If (iHits > 1) Begin
95117>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95118>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
95119>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
95120>>>            Move (Name(hObject1)) to sObjectName1
95121>>>            Move (Name(hObject2)) to sObjectName2
95122>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
95123>>>>
95123>>>            Send Exit_Application
95124>>>        End  
95124>>>>
95124>>>        Else If (bObjectOrderError = True) Begin
95127>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
95128>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
95129>>>>
95129>>>            Send Exit_Application
95130>>>        End
95130>>>>
95130>>>    End_Procedure
95131>>>
95131>>>    // We take care of all errors in the Error_Report below and
95131>>>    // collect them all to an array property. So just ignore any
95131>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
95131>>>    // in some other package.
95131>>>    Procedure Ignore_Error Integer iError
95133>>>    End_Procedure
95134>>>
95134>>>    Procedure Trap_Error Integer iError
95136>>>    End_Procedure
95137>>>
95137>>>    // While we update the database we collect all errors in
95137>>>    // the struct array paDbUpdateErrorArray.
95137>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
95139>>>        Integer iSize
95139>>>        Number nVersion
95139>>>        Handle hoLogFile
95139>>>
95139>>>        If (Private.pbProcessingError(Self)) Begin
95141>>>            Procedure_Return
95142>>>        End
95142>>>>
95142>>>
95142>>>        // The UtilTableNameFromHandleToString function does a:
95142>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
95142>>>        // and it generates an error if the table is of the embedded type.
95142>>>        // As we don't want to trigger an error in that very specific case,
95142>>>        // we just ignore it here.
95142>>>        //
95142>>>        // If no report mode, just set the err indicator to true.
95142>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
95144>>>            Move True to Err
95145>>>            Procedure_Return
95146>>>        End
95146>>>>
95146>>>
95146>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
95148>>>            Procedure_Return
95149>>>        End
95149>>>>
95149>>>
95149>>>        Set Private.pbProcessingError to True
95150>>>        Set Private.pbUpdateVersionObjectError to True
95151>>>
95151>>>        Set pbDbUpdateErrorHasOccured to True
95152>>>        Get pnCurrentVersionUpdate to nVersion
95153>>>        Get phoLogFile to hoLogFile
95154>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
95155>>>
95155>>>        Set Private.pbProcessingError to False
95156>>>    End_Procedure
95157>>>
95157>>>End_Class
95158>Use cCJCommandBarSystem.pkg
95158>
95158>Object oHtmlHelp is a cHtmlHelp
95160>End_Object
95161>
95161>Object oApplication is a cApplication
95163>    Set peHelpType to htHtmlHelp
95164>    // Note: The help file settings gets changed by the Help toolbar button(s).
95164>    Set psHelpFile to "DataFlex.chm"  
95165>
95165>    Property Handle phoDbUpdateHandler 
95167>    Property Handle phoTableDUFCodeGenerator_vw 0
95169>    Property Handle phoTableDUFCodeGeneratorFilelist 0
95171>    Property String psFilelistFrom ""
95173>//    Property Boolean pbTagFileNames False
95173>    Property Integer[] piaDifferences
95175>    
95175>    Set psCompany to "RDC Tools International"
95176>    Set psProduct to "Database Update Framework - Code Generator"
95177>    
95177>    Object oConnection is a cConnection
95179>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\LoginEncryption.pkg)
95179>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cLoginEncryption.pkg)
95179>>>>>Use cCryptographer.pkg
95179>>>>>
95179>>>>>Class cLoginEncryption is a cObject
95180>>>>>    
95180>>>>>    Procedure Construct_Object
95182>>>>>        Forward Send Construct_Object
95184>>>>>        // this must be set to a multi (40ish) character random key
95184>>>>>        Property String psEncryptPassword ""
95185>>>>>    
95185>>>>>        Object oDataCrypter is a cCryptographer
95187>>>>>            Set piHash to CALG_SHA_256
95188>>>>>            Set piCipher to CALG_AES_256
95189>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
95190>>>>>            Set piProvider to PROV_RSA_AES
95191>>>>>        End_Object
95192>>>>>    End_Procedure
95193>>>>>        
95193>>>>>    // This can be augmented to return a password encryption key using any
95193>>>>>    // hidden mechanism desired.    
95193>>>>>    Function GetEncryptionPassword Returns String
95195>>>>>        String sPassword
95195>>>>>        Get psEncryptPassword to sPassword    
95196>>>>>        Function_Return sPassword
95197>>>>>    End_Function
95198>>>>>    
95198>>>>>    // EncryptPassword:
95198>>>>>    
95198>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
95198>>>>>    //
95198>>>>>    // Params:
95198>>>>>    //   sPlainText     String to encrypt.
95198>>>>>    // Returns:
95198>>>>>    //   Base64 encoded hash.
95198>>>>>    Function EncryptPassword String sPlainText Returns String
95200>>>>>        String sEncryptPassword sBinary sBase64
95200>>>>>        Address pBase64
95200>>>>>        Integer iVoid
95200>>>>>        
95200>>>>>        //  Encrypt Key
95200>>>>>        Get GetEncryptionPassword to sEncryptPassword
95201>>>>>        If (sEncryptPassword = "") Begin
95203>>>>>            Error DFERR_PROGRAM "No encryption password set" 
95204>>>>>>
95204>>>>>        End
95204>>>>>>
95204>>>>>        
95204>>>>>        Get Encrypt of oDataCrypter sEncryptPassword sPlainText to sBinary
95205>>>>>        
95205>>>>>        If (sPlainText = sBinary or sBinary = "") Begin
95207>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
95208>>>>>>
95208>>>>>            Function_Return ""
95209>>>>>        End
95209>>>>>>
95209>>>>>        
95209>>>>>        //  Encode binary hash to Base64
95209>>>>>        Move (Base64Encode(AddressOf(sBinary), Length(sBinary))) to pBase64
95210>>>>>        Move pBase64 to sBase64
95211>>>>>        Move (Free(pBase64)) to iVoid
95212>>>>>        
95212>>>>>        Function_Return sBase64
95213>>>>>    End_Function
95214>>>>>    
95214>>>>>    
95214>>>>>    // DecryptPassword:
95214>>>>>    
95214>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
95214>>>>>    //
95214>>>>>    // Params:
95214>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
95214>>>>>    // Returns:
95214>>>>>    //   Readable plain text password
95214>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
95216>>>>>        String sEncryptPassword sPlainText sBinary
95216>>>>>        Boolean bIsHex
95216>>>>>        Integer iLen iVoid
95216>>>>>        Address pBinary
95216>>>>>        
95216>>>>>        If (sBase64EncryptedPassword <> "") Begin
95218>>>>>            //  Decode from Base64
95218>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
95219>>>>>            
95219>>>>>            Move (Repeat(Character(0), iLen)) to sBinary
95220>>>>>            Move (CopyMemory(AddressOf(sBinary), pBinary, iLen)) to iVoid
95221>>>>>            
95221>>>>>            Move (Free(pBinary)) to iVoid
95222>>>>>    
95222>>>>>            //  Encrypted binary hash to string
95222>>>>>            Get GetEncryptionPassword to sEncryptPassword
95223>>>>>            Get Decrypt of oDataCrypter sEncryptPassword sBinary to sPlainText
95224>>>>>        End
95224>>>>>>
95224>>>>>        
95224>>>>>        Function_Return sPlainText
95225>>>>>    End_Function
95226>>>>>End_Class
95227>>>>>    
95227>>>
95227>>>Object oLoginEncryption is a cLoginEncryption
95229>>>
95229>>>    // this must be created in your appsrc directory and must contain an encryption
95229>>>    // key that is set to psEncryptPassword. It will look something like this
95229>>>    //
95229>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
95229>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
95229>>>>// Studio generated login encryption key
95229>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
95230>>>>
95230>>>    
95230>>>    // use this to register this object to your cConnection Object. This object
95230>>>    // must be created after the cConnection object
95230>>>    Move Self to ghoLoginEncryption
95231>>>End_Object
95232>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DatabaseLoginDialog.dg)
95232>>>
95232>>>Use Windows.pkg
95232>>>Use cConnection.pkg
95232>>>Use dfLine.pkg
95232>>>
95232>>>Object oDatabaseLoginDialog is a ModalPanel
95234>>>    Set Label to "Database Login"
95235>>>    Set Location to 2 2
95236>>>    Set Size to 110 211
95237>>>
95237>>>    Property String psId
95239>>>    Property Boolean pbOk False
95241>>>    Property Boolean pbChanged False
95243>>>    Property Boolean pbAllowRemember True
95245>>>
95245>>>    // this registers this object with the cConnection object.
95245>>>    Move Self to ghoLoginConnectDialog
95246>>>
95246>>>    Object oUserIDForm is a Form
95248>>>        Set Label to "User Name"
95249>>>        Set Size to 13 85
95250>>>        Set Location to 34 79
95251>>>        Set Label_Col_Offset to 64
95252>>>                Set peAnchors to anTopLeftRight
95253>>>    End_Object
95254>>>
95254>>>    Object oPwdForm is a Form
95256>>>        Set Size to 13 85
95257>>>        Set Location to 49 79
95258>>>        Set Label_Col_Offset to 64
95259>>>        Set Password_State to True
95260>>>                Set peAnchors to anTopLeftRight
95261>>>        Set Label to "Password"
95262>>>    End_Object
95263>>>
95263>>>    Object oTrustedConnection is a CheckBox
95265>>>        Set Size to 10 50
95266>>>        Set Location to 65 79
95267>>>        Set Label to "Trusted Connection"
95268>>>    End_Object
95269>>>
95269>>>    Object oRemember is a CheckBox
95271>>>        Set Size to 10 50
95272>>>        Set Location to 79 14
95273>>>        Set Label to "Remember and don't ask again"
95274>>>        Set Checked_State to True
95275>>>    End_Object
95276>>>
95276>>>    Object oLogin_btn is a Button
95278>>>        Set Label to "&Login"
95279>>>        Set Location to 92 102
95280>>>        Set peAnchors to anBottomRight
95281>>>        Set Default_State to True
95282>>>
95282>>>        Procedure OnClick
95285>>>            Boolean bTrust
95285>>>            String sUser sPwd sConn sErr sId
95285>>>            Integer iError
95285>>>            Get psId to sId
95286>>>            Get Value of oUserIDForm to sUser
95287>>>            Get Value of oPwdForm to sPwd
95288>>>            Get Checked_State of oTrustedConnection to bTrust
95289>>>            
95289>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
95290>>>            If (iError=0) Begin
95292>>>                Set pbOk to True
95293>>>                Set pbChanged to True
95294>>>                // using Stop_UI instead of close_panel keeps it running when the dialog
95294>>>                // is the only dialog and it closes
95294>>>                Send Stop_UI
95295>>>//                Send Close_Panel
95295>>>            End
95295>>>>
95295>>>            Else Begin
95296>>>                Get psErrorText of ghoConnection to sErr
95297>>>                Send UserError sErr "Login Error"
95298>>>            End
95298>>>>
95298>>>        End_Procedure
95299>>>    End_Object
95300>>>
95300>>>    Object oCancel_btn is a Button
95302>>>        Set Label to "&Cancel"
95303>>>        Set Location to 92 157
95304>>>        Set peAnchors to anBottomRight
95305>>>
95305>>>        Procedure OnClick
95308>>>            Send Stop_UI
95309>>>//            Send Close_Panel
95309>>>        End_Procedure
95310>>>    End_Object
95311>>>
95311>>>    Object oConnectionIdInfo is a TextBox
95313>>>        Set Size to 10 50
95314>>>        Set Location to 4 14
95315>>>        Set Label to 'Connection Id='
95316>>>    End_Object
95317>>>
95317>>>    Object oConnectionServerInfo is a TextBox
95319>>>        Set Size to 10 50
95320>>>        Set Location to 16 14
95321>>>        Set Label to 'Server'
95322>>>    End_Object
95323>>>
95323>>>    Object oLineControl1 is a LineControl
95325>>>        Set Size to 2 202
95326>>>        Set Location to 29 5
95327>>>    End_Object
95328>>>
95328>>>    Function LoginConnectIdDialog String sId Returns Boolean
95331>>>         Boolean bOk bChanged bTrusted bAllowRemember bRemember
95331>>>         String sUser sPwd sDescription
95331>>>         tConnection Connect
95331>>>         tConnection Connect
95331>>>         
95331>>>         Get pbAllowRemember to bAllowRemember
95332>>>         
95332>>>
95332>>>         If not bAllowRemember Begin
95334>>>            Set Enabled_State of oRemember to bRemember
95335>>>            Set Visible_State of oRemember to bRemember
95336>>>         End
95336>>>>
95336>>>         
95336>>>         Get ConnectionIdInfo of ghoConnection sId to Connect
95337>>>         Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
95338>>>         Set Value of oConnectionServerInfo to Connect.sString
95339>>>
95339>>>         Set psId to sId
95340>>>         Set pbOk to False
95341>>>         Set pbChanged to False
95342>>>         Set Value of oUserIDForm to Connect.sUID
95343>>>         Set Value of oPwdForm to ""
95344>>>         
95344>>>         Send Popup
95345>>>         
95345>>>         Get pbOk to bOk
95346>>>         Get pbChanged to bChanged
95347>>>         If (bChanged and bOk) Begin
95349>>>            If bAllowRemember Begin
95351>>>                Get Checked_State of oRemember to bRemember
95352>>>                If bRemember Begin
95354>>>                    Get Checked_State of oTrustedConnection to bTrusted
95355>>>                    If not (bTrusted) Begin
95357>>>                        Get Value of oUserIDForm to sUser
95358>>>                        Get Value of oPwdForm to sPwd
95359>>>                    End
95359>>>>
95359>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
95360>>>                 End
95360>>>>
95360>>>             End
95360>>>>
95360>>>         End
95360>>>>
95360>>>         Function_Return bOk
95361>>>    End_Function
95362>>>    
95362>>>    
95362>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
95363>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
95364>>>End_Object
95365>>>
95365>    End_Object
95366>
95366>End_Object
95367>
95367>Object oDbUpdateHandler is a cDbUpdateHandler
95369>    Set Data_File_Field to File_Field DbVersion.DatabaseVersion 
95370>    Set phoDbUpdateHandler of ghoApplication to Self
95371>End_Object
95372>
95372>Object oToolTipController is a cToolTipController
95374>    Move Self to ghoToolTipController
95375>    Set pbBalloonStyle to False
95376>    Set piIcon to TTI_INFO
95377>    Set psTitle to "Information"
95378>    Set piMaxWidth to 400
95379>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
95380>End_Object
95381>
95381>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oEditContextMenu.pkg)
95381>>>Use cCJStandardMenuItemClasses.pkg
95381>>>
95381>>>Object oEditContextMenu is a cCJContextMenu
95383>>>    
95383>>>    Move Self to Default_Form_Floating_Menu_ID
95384>>>    
95384>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95386>>>    End_Object
95387>>>    
95387>>>    Object oCutMenuItem is a cCJCutMenuItem
95389>>>        Set pbControlBeginGroup to True
95390>>>    End_Object
95391>>>    
95391>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95393>>>    End_Object
95394>>>
95394>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95396>>>    End_Object
95397>>>
95397>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95399>>>    End_Object
95400>>>
95400>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95402>>>        Set pbControlBeginGroup to True
95403>>>    End_Object
95404>>>
95404>>>End_Object
95405>>>
95405>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oDEOEditContextMenu17.pkg)
95405>>>Use Windows.pkg
95405>>>Use cCJStandardMenuItemClasses.pkg
95405>>>Use cCJDeoMenuItemClasses.pkg
95405>>>
95405>>>
95405>>>Object oDEOEditContextMenu17 is a cCJContextMenu
95407>>>    
95407>>>    Move Self to Default_dbFloating_Menu_ID
95408>>>    
95408>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95410>>>    End_Object
95411>>>    
95411>>>    Object oCutMenuItem is a cCJCutMenuItem
95413>>>        Set pbControlBeginGroup to True
95414>>>    End_Object
95415>>>    
95415>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95417>>>    End_Object
95418>>>
95418>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95420>>>    End_Object
95421>>>
95421>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95423>>>    End_Object
95424>>>
95424>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95426>>>        Set pbControlBeginGroup to True
95427>>>    End_Object
95428>>>
95428>>>    Object oPromptMenuItem is a cCJPromptMenuItem
95430>>>        Set pbControlBeginGroup to True
95431>>>    End_Object
95432>>>
95432>>>    Object oFindNextMenu is a cCJFindNextMenuItem
95434>>>        Set pbControlBeginGroup to True
95435>>>    End_Object
95436>>>
95436>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95438>>>    End_Object
95439>>>
95439>>>    Object oClearMenuItem is a cCJClearMenuItem
95441>>>        Set pbControlBeginGroup to True
95442>>>    End_Object
95443>>>
95443>>>    Object oClearAllMenu is a cCJClearAllMenuItem
95445>>>    End_Object
95446>>>
95446>>>    Object oSaveMenu is a cCJSaveMenuItem
95448>>>    End_Object
95449>>>    
95449>>>    Object oDeleteMenu is a cCJDeleteMenuItem
95451>>>    End_Object
95452>>>
95452>>>    Object oRememberitem is a cCJRememberFieldMenuItem
95454>>>        Set pbControlBeginGroup to True
95455>>>    End_Object
95456>>>
95456>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
95458>>>    End_Object
95459>>>
95459>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
95461>>>    End_Object
95462>>>
95462>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
95464>>>    End_Object
95465>>>
95465>>>End_Object
95466>
95466>Object oMain is a Panel
95468>    Set Label to "DUF Code Generator and Database Compare Utility"
95469>    Set Location to 4 3
95470>    Set Size to 298 534
95471>    Set piMinSize to 269 486     
95472>    Set Icon to "DUFTableCodeGenerator.ico"
95473>
95473>    Object oCommandBarSystem is a cCJCommandBarSystem
95475>        Set pbTimerUpdate to True
95476>        Set peVisualTheme to xtpThemeOffice2013Outlook
95477>        Set pbAutoResizeIcons to True
95478>        Set pbEnableCustomization to True
95479>        Set peRestoreLayout to rlSaveRestoreFullLayout
95480>        Set pbTabbedWorkspaces to True
95481>
95481>        Procedure OnCreateCommandBars
95484>            Handle hoOptions
95484>            Get OptionsObject to hoOptions
95485>            Forward Send OnCreateCommandBars
95487>        End_Procedure 
95488>        
95488>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95491>            Set ComShowIcons of hoTabPaintManager to True
95492>            Send ComSetIconSize of hoTabPaintManager 24 24
95493>    
95493>            // This will truncate the middle part of long items
95493>            Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95494>        End_Procedure
95495>
95495>        Object oEditToolBar is a cCJToolbar
95497>            Set psTitle to "Edit Toolbar"
95498>
95498>            Object oCutToolbarItem is a cCJCutMenuItem
95500>            End_Object
95501>
95501>            Object oCopyToolbarItem is a cCJCopyMenuItem
95503>            End_Object
95504>
95504>            Object oPasteToolbarItem is a cCJPasteMenuItem
95506>            End_Object
95507>
95507>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95509>                Set pbControlBeginGroup to True
95510>            End_Object
95511>
95511>        End_Object
95512>
95512>//        Object oMenuBar is a cCJMenuBar
95512>//
95512>//            Object oFileMenu is a cCJMenuItem
95512>//                Set peControlType to xtpControlPopup          
95512>//                Set psCaption   to "&File"
95512>//                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
95512>//                Set psCategory to "Menus"
95512>//
95512>//                Object oClearMenuItem is a cCJClearMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                End_Object
95512>//
95512>//                Object oClearAllMenu is a cCJClearAllMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                End_Object
95512>//
95512>//                Object oPromptMenuItem is a cCJPromptMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                    Set pbControlBeginGroup to True
95512>//                End_Object
95512>//
95512>//                Object oFindMenuItem is a cCJFindMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                    Set pbControlBeginGroup to True
95512>//                End_Object
95512>//
95512>//                Object oFindNextMenu is a cCJFindNextMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                End_Object
95512>//
95512>//                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                End_Object
95512>//
95512>//                Object oFindFirstMenu is a cCJFindFirstMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                End_Object
95512>//
95512>//                Object oFindLastMenu is a cCJFindLastMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                End_Object
95512>//
95512>//                Object oSaveMenuItem is a cCJSaveMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                    Set pbControlBeginGroup to True
95512>//                End_Object
95512>//
95512>//                Object oDeleteMenuItem is a cCJDeleteMenuItem
95512>//                    Set pbAddToDesignerMenu to True
95512>//                End_Object
95512>//
95512>//                Object oExitMenu is a cCJExitMenuItem
95512>//                    Set pbControlBeginGroup to True
95512>//                End_Object
95512>//
95512>//            End_Object
95512>//
95512>////            Object oViewMenu is a cCJMenuItem
95512>////                Set peControlType to xtpControlPopup
95512>////                Set psCaption to "&View"
95512>////                Set psToolTip to "View"
95512>////                Set psDescription to "Available Views"
95512>////
95512>////                Object oTableDUFCodeGeneratorMenuItem is a cCJMenuItem
95512>////                    Set psCaption to "TableDUFCodeGenerator"
95512>////                    Set psTooltip to "TableDUFCodeGenerator"
95512>////                
95512>////                    Procedure OnExecute Variant vCommandBarControl
95512>////                        Handle hoClient
95512>////                        Get Client_Id to hoClient
95512>////                        Send Activate_oTableDUFCodeGenerator of hoClient
95512>////                    End_Procedure
95512>////                End_Object
95512>////            End_Object
95512>//            
95512>////            Object oReportMenu is a cCJMenuItem
95512>////                Set peControlType to xtpControlPopup          
95512>////                Set psCaption to "&Report"
95512>////                Set psToolTip to "Report"
95512>////                Set psDescription to "Available Reports"
95512>////            End_Object
95512>//
95512>////            Object oNavigateMenu is a cCJMenuItem
95512>////                Set peControlType to xtpControlPopup      
95512>////                Set psCaption to "&Navigate"    
95512>////                Set psTooltip to "Navigate"    
95512>////                Set psDescription to "Move to different areas of the application"
95512>////
95512>////                Object oNextAreaMenu is a cCJNextAreaMenu
95512>////                End_Object
95512>////
95512>////                Object oPriorAreaMenu is a cCJPriorAreaMenu
95512>////                End_Object
95512>////
95512>////                Object oNextViewMenu is a cCJNextViewMenu
95512>////                End_Object
95512>////
95512>////                Object oPriorViewMenu is a cCJPriorViewMenu
95512>////                End_Object
95512>////
95512>////                Object oPromptMenu is a cCJPromptMenuItem
95512>////                    Set pbControlBeginGroup to True
95512>////                End_Object
95512>////
95512>////                Object oZoomMenu is a cCJZoomMenuItem
95512>////                End_Object
95512>////
95512>////            End_Object
95512>//
95512>////            Object oWindowMenu is a cCJMDIWindowsMenuItem
95512>////                Set peControlType to xtpControlPopup
95512>////                Set psCaption to "&Window"
95512>////                Set psToolTip to "Window"
95512>////                Set psDescription to "Display Current Views and set other display options."    
95512>////
95512>////                // These are the static windows items. More will be created in onInitPopup 
95512>////                Object oDisplayOptionsMenu is a cCJMenuItem
95512>////                    Set peControlType to xtpControlPopup          
95512>////                    Set psCaption to "&Display Options"
95512>////                    Set psToolTip to "Display Options"
95512>////                    Set psDescription to "Set display options"
95512>////
95512>////                    Object oStatusbarMenu is a cCJStatusbarMenuItem
95512>////                    End_Object
95512>////
95512>////                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
95512>////                    End_Object
95512>////
95512>////                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
95512>////                        Set pbControlBeginGroup to True
95512>////                    End_Object
95512>////
95512>////                End_Object
95512>////
95512>////                Object oCascadeMenu is a cCJCascadeMenuItem
95512>////                    Set pbControlBeginGroup to True
95512>////                End_Object
95512>////
95512>////                Object oHorizTile is a cCJTileHorizontally
95512>////                End_Object
95512>////
95512>////                Object oVertTile is a cCJTileVertically
95512>////                End_Object
95512>////
95512>////                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
95512>////                    Set pbControlBeginGroup to True
95512>////                End_Object
95512>////
95512>////                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
95512>////                End_Object
95512>////
95512>////                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
95512>////                    Set pbControlBeginGroup to True
95512>////                End_Object
95512>////
95512>////            End_Object
95512>//
95512>////            Object oHelpMenu is a cCJMenuItem
95512>////                Set peControlType to xtpControlPopup    
95512>////                Set psCaption to "&Help"
95512>////                Set psDescription to "Access Information for learning and using this DataFlex application."
95512>////                Set psToolTip to "Help"
95512>////
95512>////                Object oHelpMenuItem is a cCJHelpMenuItem 
95512>////                End_Object
95512>////
95512>////                Object oAboutMenuItem is a cCJAboutMenuItem
95512>////                End_Object
95512>////
95512>////            End_Object
95512>//
95512>//            Object oHelpMenu is a cCJMenuItem
95512>//                Set peControlType to xtpControlPopup
95512>//                Set psCaption to "&Help"
95512>//                Set psDescription to "Access Information for learning and using this DataFlex application."
95512>//                Set psToolTip to "Help"
95512>//
95512>//                Procedure OnExecute Variant vCommandBarControl
95512>//                    Forward Send OnExecute vCommandBarControl
95512>//                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95512>//                    Send ShowProgramHelp
95512>//                End_Procedure
95512>//
95512>//                Object oHelpMenuItemLocal is a cCJMenuItem
95512>//                    Set psCaption to "Local HTML Help"
95512>//                    Set psImage to "ActionHelp.ico"
95512>//                    Procedure OnExecute Variant vCommandBarControl
95512>//                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95512>//                        Send ShowProgramHelp
95512>//                    End_Procedure
95512>//                End_Object
95512>//
95512>//                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95512>//                    Set psCaption to "Internet Online HTML Help"
95512>//                    Set psImage to "ActionHelp.ico"
95512>//                    Procedure OnExecute Variant vCommandBarControl
95512>//                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95512>//                    End_Procedure
95512>//
95512>//                End_Object
95512>//
95512>//                Object oAboutMenuItem is a cCJAboutMenuItem
95512>//                End_Object
95512>//
95512>//            End_Object
95512>//
95512>//        End_Object
95512>
95512>        Object oFindToolBar is a cCJToolbar
95514>//            Set psTitle to "Finding Toolbar"
95514>//
95514>//            Object oFindFirstTool is a cCJFindFirstMenuItem
95514>//            End_Object
95514>//
95514>//            Object oFindPreviousTool is a cCJFindPreviousMenuItem
95514>//            End_Object
95514>//
95514>//            Object oFindMenuTool is a cCJFindMenuItem
95514>//            End_Object
95514>//
95514>//            Object oFindNextTool is a cCJFindNextMenuItem
95514>//            End_Object
95514>//
95514>//            Object oFindLastTool is a cCJFindLastMenuItem
95514>//            End_Object
95514>//
95514>            Object oPromptToolItem is a cCJPromptMenuItem
95516>                Set pbControlBeginGroup to True
95517>            End_Object
95518>
95518>        End_Object
95519>
95519>        Object oFileToolBar is a cCJToolbar
95521>            Set psTitle to "Data Entry Toolbar"
95522>
95522>            Object oClearToolItem is a cCJClearMenuItem
95524>                Set peControlStyle to xtpButtonIconAndCaption 
95525>                Set psCaption      to "Clear/Add"
95526>                Function IsEnabled Returns Boolean
95529>                    Function_Return True
95530>                End_Function
95531>         
95531>            End_Object
95532>
95532>//            Object oClearAllToolItem2 is a cCJClearAllMenuItem
95532>//                Set peControlStyle to xtpButtonIconAndCaption
95532>//            End_Object
95532>//
95532>//            Object oSaveToolItem is a cCJSaveMenuItem
95532>//                Set peControlStyle to xtpButtonIconAndCaption
95532>//                Set pbControlBeginGroup to True
95532>//            End_Object
95532>//
95532>//            Object oDeleteToolItem is a cCJDeleteMenuItem
95532>//                Set peControlStyle to xtpButtonIconAndCaption
95532>//            End_Object
95532>//
95532>        End_Object
95533>
95533>        Object oCompareToolbar is a cCJToolbar
95535>            Object oCompareToolItem is a cCJMenuItem
95537>                Set peControlStyle to xtpButtonIconAndCaption
95538>                Set psCaption to "SQL Connection Info"
95539>//                Set psDescription to "To compare e.g. a development database with a customer database. You need to have both databases available to be able to compare."
95539>                Set psImage to "SQLConnections.ico"
95540>                Set piShortCutKey to xtpKey_Alt VK_C
95541>//                Set psToolTip to "Compare two databases and report differences."
95541>                
95541>                Procedure OnExecute Variant vCommandBarControl  
95544>//                    Handle hoTableDUFCodeGeneratorFilelist
95544>//                    String sFilelistFrom
95544>                    tSQLConnection Connection
95544>                    tSQLConnection Connection
95544>                    
95544>                    Forward Send OnExecute vCommandBarControl
95546>                    Get pSQLConnection of ghoSQLConnectionHandler to Connection
95547>                    Send Activate_SQLMaintainConnections_dg of (Client_Id(ghoCommandBars)) Connection
95548>
95548>//                    Get phoTableDUFCodeGeneratorFilelist of ghoApplication to hoTableDUFCodeGeneratorFilelist
95548>//                    Get Value of hoTableDUFCodeGeneratorFilelist to sFilelistFrom
95548>//                    Send Activate_CompareDatabases of (Client_Id(ghoCommandBars)) sFilelistFrom
95548>                End_Procedure
95549>            
95549>            End_Object
95550>        
95550>        End_Object
95551>
95551>        Object oHelp_Toolbar is a cCJToolbar
95553>//            Set peStretched to stStretchShared
95553>
95553>            Object oAbout_MenuItem is a cCJMenuItem
95555>                Set psCaption to "About"
95556>                Set psToolTip to "About Info"
95557>                Set psDescription to "About the program"
95558>                Set psImage to "ActionAbout.ico"
95559>                Set pbControlBeginGroup to True
95560>                Procedure OnExecute Variant vCommandBarControl
95563>                    Forward Send OnExecute vCommandBarControl
95565>                    Send Activate_About of (Client_Id(ghoCommandBars))
95566>                End_Procedure
95567>            End_Object
95568>
95568>            Object oHelpMenuItem is a cCJHelpMenuItem
95570>                Set peControlType to xtpControlSplitButtonPopup
95571>
95571>                Procedure OnExecute Variant vCommandBarControl
95574>                    Forward Send OnExecute vCommandBarControl
95576>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
95577>                    Send ShowProgramHelp
95578>                End_Procedure
95579>
95579>                Object oHelpMenuItemLocal is a cCJMenuItem
95581>                    Set psCaption to "Local HTML Help"
95582>                    Set psImage to "ActionHelp.ico"
95583>                    Procedure OnExecute Variant vCommandBarControl
95586>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
95587>                        Send ShowProgramHelp
95588>                    End_Procedure
95589>                End_Object
95590>
95590>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95592>                    Set psCaption to "Internet Online HTML Help"
95593>                    Set psImage to "ActionHelp.ico"
95594>                    Procedure OnExecute Variant vCommandBarControl
95597>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
95598>                    End_Procedure
95599>
95599>                End_Object
95600>
95600>            End_Object
95601>
95601>            Object oExitMenuItem is a cCJExitMenuItem
95603>                Set psImage to "ActionExitApp.ico"
95604>                Set psToolTip to "Exit application"
95605>                Set psDescription to "Exit the program (Alt+F4)"
95606>                Set pbControlBeginGroup to True
95607>            End_Object
95608>
95608>        End_Object
95609>
95609>        Object oStatusBar is a cCJStatusBar
95611>
95611>            Object oStatusPane1 is a cCJStatusBarPane
95613>                Set piID to sbpIDIdlePane
95614>                Set pbStyleStretch to True
95615>            End_Object
95616>
95616>            Object oStatusPane2 is a cCJStatusBarPane
95618>                Set phoViewPane to Self
95619>                Set pbStyleStretch to True
95620>            End_Object
95621>
95621>        End_Object
95622>
95622>    End_Object
95623>
95623>    Object oClientArea is a ClientArea
95625>        Use ReadOnlySQLConnections.dg
Including file: ReadOnlySQLConnections.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ReadOnlySQLConnections.dg)
95625>>>Use Windows.pkg
95625>>>Use Cursor.pkg
95625>>>Use cButtonDPI.pkg
Including file: cButtonDPI.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButtonDPI.pkg)
95625>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
95625>>>>>Class cButtonDPI is a Button
95626>>>>>    Procedure Construct_Object 
95628>>>>>        Integer iIconSize
95628>>>>>        Forward Send Construct_Object
95630>>>>>        Get GetCorrectIconSize to iIconSize
95631>>>>>        Set piImageSize to iIconSize
95632>>>>>    End_Procedure
95633>>>>>
95633>>>>>    // Returns: DPI setting as an integer.
95633>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95633>>>>>    //                      iDPI=120 is "Medium setting" 125%
95633>>>>>    //                      iDPI= 144 is "Large setting" 150%
95633>>>>>    Function GetCurrentDPI Returns Integer
95635>>>>>        Handle hDC
95635>>>>>        Integer iPixelsX
95635>>>>>        Move (GetDC(0)) to hDC
95636>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95637>>>>>        Move (ReleaseDC(0, hDC)) to hDC
95638>>>>>        Function_Return iPixelsX
95639>>>>>    End_Function  
95640>>>>>    
95640>>>>>    Function GetCorrectIconSize Returns Integer
95642>>>>>        Integer iPixelsX iIndex iSize 
95642>>>>>        Integer[] iaSizes
95643>>>>>        
95643>>>>>        Move 16 to iaSizes[0]
95644>>>>>        Move 24 to iaSizes[1]
95645>>>>>        Move 32 to iaSizes[2]
95646>>>>>        Move 48 to iaSizes[3]
95647>>>>>        Move 64 to iaSizes[4]
95648>>>>>        
95648>>>>>        Get piImageSize to iSize  // the "100%" size
95649>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
95650>>>>>        Move (0 max iIndex) to iIndex
95651>>>>>        Get GetCurrentDPI to iPixelsX
95652>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
95652>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
95652>>>>>        // will increment iIndex as many times as we need here.
95652>>>>>        Case Begin
95652>>>>>            Case (iPixelsX > 144)
95654>>>>>                Increment iIndex
95655>>>>>            Case (iPixelsX = 144)
95658>>>>>                Increment iIndex
95659>>>>>            Case (iPixelsX = 120)
95662>>>>>                Increment iIndex  
95663>>>>>        Case End
95663>>>>>        Move (iIndex min 4) to iIndex
95664>>>>>        Function_Return iaSizes[iIndex]
95665>>>>>    End_Function
95666>>>>>    
95666>>>>>//    Function GetCorrectIconSize Returns Integer
95666>>>>>//        Integer iPixelsX iRetval
95666>>>>>//        Get GetCurrentDPI to iPixelsX
95666>>>>>//        Case Begin
95666>>>>>//            Case (iPixelsX < 120)
95666>>>>>//                Move 16 to iRetval
95666>>>>>//                Case Break
95666>>>>>//            Case (iPixelsX = 120)
95666>>>>>//                Move 24 to iRetval
95666>>>>>//                Case Break
95666>>>>>//            Case (iPixelsX = 144)
95666>>>>>//                Move 32 to iRetval
95666>>>>>//                Case Break
95666>>>>>//            Case (iPixelsX > 144)
95666>>>>>//                Move 48 to iRetval
95666>>>>>//                Case Break
95666>>>>>//        Case End                
95666>>>>>//        Function_Return iRetval
95666>>>>>//    End_Function
95666>>>>>
95666>>>>>End_Class
95667>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
95667>>>>>Use Windows.pkg
95667>>>>>
95667>>>>>// Used by the "Page" message below to show
95667>>>>>// a rectangle around ComboForm and Checkbox objects.
95667>>>>>    Define WM_CHANGEUISTATE for |CI$0127
95667>>>>>    Define WM_UPDATEUISTATE for |CI$0128
95667>>>>>    Define WM_QUERYUISTATE  for |CI$0129
95667>>>>>    Define UIS_SET          for 1
95667>>>>>    Define UIS_CLEAR        for 2
95667>>>>>    Define UIS_INITIALIZE   for 3
95667>>>>>    Define UISF_HIDEFOCUS   for |CI$1
95667>>>>>    Define UISF_HIDEACCEL   for |CI$2
95667>>>>>    Define UISF_ACTIVE      for |CI$4
95667>>>>>
95667>>>>>Class cSQLCheckBox is a CheckBox
95668>>>>>    Procedure Construct_Object
95670>>>>>        Forward Send Construct_Object
95672>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95672>>>>>        Property Integer piItem
95673>>>>>    End_Procedure
95674>>>>>
95674>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95676>>>>>    End_Procedure
95677>>>>>
95677>>>>>    Procedure ReadConnectionData String[] sConnectionData
95679>>>>>        Integer iItem
95679>>>>>        Get piItem to iItem
95680>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
95681>>>>>    End_Procedure
95682>>>>>
95682>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95684>>>>>        Boolean bState
95684>>>>>        Integer iItem
95684>>>>>        Get piItem to iItem
95685>>>>>        Get Checked_State to bState
95686>>>>>        Move bState to sConnectionData[iItem]
95687>>>>>    End_Procedure
95688>>>>>
95688>>>>>    // Fix for a bug when using manifest files & running Vista and above.
95688>>>>>    // The bug being that the focus rectangle doesn't show.
95688>>>>>    Procedure Page Integer iPageObject
95690>>>>>        Handle hWnd
95690>>>>>        Integer iRet iState iMajorVersion
95690>>>>>
95690>>>>>        Forward Send Page iPageObject
95692>>>>>
95692>>>>>        If (iPageObject) Begin
95694>>>>>            Get Window_Handle to hWnd
95695>>>>>            If (hWnd) Begin
95697>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
95698>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
95700>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
95701>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
95702>>>>>                End
95702>>>>>>
95702>>>>>            End
95702>>>>>>
95702>>>>>        End
95702>>>>>>
95702>>>>>    End_Procedure
95703>>>>>
95703>>>>>End_Class
95704>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
95704>>>>>Use Windows.pkg
95704>>>>>
95704>>>>>// Used by the "Page" message below to show
95704>>>>>// a rectangle around ComboForm and Checkbox objects.
95704>>>>>
95704>>>>>Class cSQLComboForm is a ComboForm
95705>>>>>    Procedure Construct_Object
95707>>>>>        Forward Send Construct_Object
95709>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95709>>>>>        Property Integer piItem
95710>>>>>    End_Procedure
95711>>>>>
95711>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95713>>>>>    End_Procedure
95714>>>>>
95714>>>>>    Procedure ReadConnectionData String[] sConnectionData
95716>>>>>        Integer iItem
95716>>>>>        Get piItem to iItem
95717>>>>>        Set Value to sConnectionData[iItem]
95718>>>>>    End_Procedure
95719>>>>>
95719>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95721>>>>>        String sValue
95721>>>>>        Integer iItem
95721>>>>>        Get piItem to iItem
95722>>>>>        Get Value to sValue
95723>>>>>        Move sValue to sConnectionData[iItem]
95724>>>>>    End_Procedure
95725>>>>>
95725>>>>>    // Fix for a bug when using manifest files & running Vista and above.
95725>>>>>    // The bug being that the focus rectangle doesn't show.
95725>>>>>    Procedure Page Integer iPageObject
95727>>>>>        Handle hWnd
95727>>>>>        Integer iRet iState iMajorVersion
95727>>>>>
95727>>>>>        Forward Send Page iPageObject
95729>>>>>
95729>>>>>        If (iPageObject) Begin
95731>>>>>            Get Window_Handle to hWnd
95732>>>>>            If (hWnd) Begin
95734>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
95735>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
95737>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
95738>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
95739>>>>>                End
95739>>>>>>
95739>>>>>            End
95739>>>>>>
95739>>>>>        End
95739>>>>>>
95739>>>>>    End_Procedure
95740>>>>>
95740>>>>>End_Class
95741>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLForm.pkg)
95741>>>>>Use Windows.pkg
95741>>>>>
95741>>>>>Class cSQLForm is a Form
95742>>>>>    Procedure Construct_Object
95744>>>>>        Forward Send Construct_Object
95746>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95746>>>>>        Property Integer piItem
95747>>>>>    End_Procedure
95748>>>>>
95748>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95750>>>>>    End_Procedure
95751>>>>>
95751>>>>>    Procedure ReadConnectionData String[] sConnectionData
95753>>>>>        Integer iItem
95753>>>>>        Get piItem to iItem
95754>>>>>        Set Value to sConnectionData[iItem]
95755>>>>>    End_Procedure
95756>>>>>
95756>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95758>>>>>        String sValue
95758>>>>>        Integer iItem
95758>>>>>        Get piItem to iItem
95759>>>>>        Get Value to sValue
95760>>>>>        Move sValue to sConnectionData[iItem]
95761>>>>>    End_Procedure
95762>>>>>
95762>>>>>End_Class
95763>>>Use cSQLConnectionHandler.pkg
95763>>>Use cDbUpdateFunctionLibrary.pkg
95763>>>Use cDbUpdateDatabaseDriver.pkg
95763>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95763>>>>>Use Windows.pkg
95763>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridPromptList.pkg)
95763>>>>>>>Use Windows.pkg
95763>>>>>>>Use cCJGrid.pkg
95763>>>>>>>
95763>>>>>>>
95763>>>>>>>
95763>>>>>>>Class cCJGridPromptList is a cCJGrid
95764>>>>>>>
95764>>>>>>>    Procedure Construct_Object
95766>>>>>>>        Forward Send Construct_Object
95768>>>>>>>
95768>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95769>>>>>>>        Property Boolean Private_pbAutoOrdering True
95770>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95771>>>>>>>        Property Integer peUpdateMode umPromptValue
95772>>>>>>>        Property Integer piUpdateColumn 0
95773>>>>>>>        Property Integer piInitialColumn -1
95774>>>>>>>        Property String  psSeedValue ''
95775>>>>>>>        Property Handle phmPromptUpdateCallback 0
95776>>>>>>>        Property Integer phoInvokingObject
95777>>>>>>>        
95777>>>>>>>        Property Boolean pbStoredAutoSeed
95778>>>>>>>        Property Boolean pbStoredAutoOrdering
95779>>>>>>>        Property Boolean pbStoredAutoSearch
95780>>>>>>>        Property Integer peStoredUpdateMode
95781>>>>>>>        Property Integer piStoredUpdateColumn
95782>>>>>>>        Property Integer piStoredInitialColumn
95783>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
95784>>>>>>>        Property Boolean pbStoredSelectionEnable
95785>>>>>>>        Property Boolean pbStoredMultipleSelection
95786>>>>>>>
95786>>>>>>>        // internally set by list
95786>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
95786>>>>>>>        Property Boolean pbCanceled
95787>>>>>>>        Property Integer[] pSelectedRows
95788>>>>>>>
95788>>>>>>>        Property Boolean pbNeedsNewOrdering
95789>>>>>>>        Property Boolean pbRequestSearch
95790>>>>>>>        Property tGridKeyPair[] pSearchKeys
95791>>>>>>>        
95791>>>>>>>        // these properties makes a prompt list a prompt list
95791>>>>>>>        // and should not be changed.
95791>>>>>>>        Set pbEditOnKeyNavigation to False
95792>>>>>>>        Set pbEditOnClick to False
95793>>>>>>>        Set pbReadOnly to True
95794>>>>>>>        Set pbFocusSubItems to True
95795>>>>>>>        
95795>>>>>>>        // these could maybe be changed
95795>>>>>>>        Set pbShadeSortColumn to True
95796>>>>>>>        Set pbHeaderReorders to True
95797>>>>>>>        Set pbHeaderTogglesDirection to True
95798>>>>>>>        Set pbHeaderSelectsColumn to True
95799>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95800>>>>>>>        Set piFocusCellBackColor to clNone
95801>>>>>>>        Set piFocusCellForeColor to clNone
95802>>>>>>>        Set piFocusCellRectangleColor to clBlack
95803>>>>>>>        Set pbUseFocusCellRectangle to False
95804>>>>>>>        Set pbSelectionEnable to True
95805>>>>>>>        
95805>>>>>>>        On_Key kEnter Send Ok
95806>>>>>>>        On_Key kCancel Send Cancel
95807>>>>>>>
95807>>>>>>>    End_Procedure
95808>>>>>>>    
95808>>>>>>>    // reorder list automatically on column change
95808>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95808>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95810>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95811>>>>>>>        Set pbFocusSubItems to bAutoOrder
95812>>>>>>>    End_Procedure
95813>>>>>>>    
95813>>>>>>>    Function pbAutoOrdering Returns Boolean
95815>>>>>>>        Boolean bAutoOrder
95815>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95816>>>>>>>        Function_Return bAutoOrder
95817>>>>>>>    End_Function
95818>>>>>>>
95818>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95818>>>>>>>    Procedure OnIdle
95820>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
95820>>>>>>>        Handle hoCol
95820>>>>>>>        Integer iKy1 iKy2 iCol
95820>>>>>>>
95820>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
95821>>>>>>>        If bNeedsReorder Begin
95823>>>>>>>            Get SelectedColumn to iCol
95824>>>>>>>            If (iCol<>-1) Begin
95826>>>>>>>                
95826>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
95827>>>>>>>                Set pbHeaderTogglesDirection to False
95828>>>>>>>                Send HeaderReorder iCol
95829>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
95830>>>>>>>                
95830>>>>>>>                Set pbNeedsNewOrdering to False
95831>>>>>>>            End
95831>>>>>>>>
95831>>>>>>>        End
95831>>>>>>>>
95831>>>>>>>        
95831>>>>>>>        Get pbRequestSearch to bSearch
95832>>>>>>>        If bSearch Begin
95834>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
95835>>>>>>>        End
95835>>>>>>>>
95835>>>>>>>        
95835>>>>>>>        Forward Send OnIdle
95837>>>>>>>    End_Procedure
95838>>>>>>>    
95838>>>>>>>    Procedure OnStoreDefaults
95840>>>>>>>        Integer iVal
95840>>>>>>>        Boolean bVal
95840>>>>>>>
95840>>>>>>>        Get pbAutoSeed to bVal           
95841>>>>>>>        Set pbStoredAutoSeed to bVal           
95842>>>>>>>        
95842>>>>>>>        Get pbAutoOrdering to bVal        
95843>>>>>>>        Set pbStoredAutoOrdering to bVal      
95844>>>>>>>        
95844>>>>>>>        Get pbAutoSearch to bVal         
95845>>>>>>>        Set pbStoredAutoSearch to bVal         
95846>>>>>>>        
95846>>>>>>>        Get peUpdateMode to iVal
95847>>>>>>>        Set peStoredUpdateMode to iVal
95848>>>>>>>        
95848>>>>>>>        Get piUpdateColumn to iVal       
95849>>>>>>>        Set piStoredUpdateColumn to iVal       
95850>>>>>>>
95850>>>>>>>        Get piInitialColumn to iVal       
95851>>>>>>>        Set piStoredInitialColumn to iVal       
95852>>>>>>>
95852>>>>>>>        Get phmPromptUpdateCallback to iVal       
95853>>>>>>>        Set phmStoredPromptUpdateCallback to iVal       
95854>>>>>>>
95854>>>>>>>        Get pbSelectionEnable to bVal
95855>>>>>>>        Set pbStoredSelectionEnable to bVal
95856>>>>>>>        
95856>>>>>>>        Get pbMultipleSelection to bVal
95857>>>>>>>        Set pbStoredMultipleSelection to bVal
95858>>>>>>>        
95858>>>>>>>    End_Procedure
95859>>>>>>>
95859>>>>>>>    Procedure OnRestoreDefaults
95861>>>>>>>        Integer iVal
95861>>>>>>>        Boolean bVal
95861>>>>>>>
95861>>>>>>>        Get pbStoredAutoSeed to bVal           
95862>>>>>>>        Set pbAutoSeed to bVal           
95863>>>>>>>        
95863>>>>>>>        Get pbStoredAutoOrdering to bVal        
95864>>>>>>>        Set pbAutoOrdering to bVal      
95865>>>>>>>        
95865>>>>>>>        Get pbStoredAutoSearch to bVal         
95866>>>>>>>        Set pbAutoSearch to bVal         
95867>>>>>>>        
95867>>>>>>>        Get peStoredUpdateMode to iVal
95868>>>>>>>        Set peUpdateMode to iVal
95869>>>>>>>        
95869>>>>>>>        Get piStoredInitialColumn to iVal       
95870>>>>>>>        Set piInitialColumn to iVal       
95871>>>>>>>        
95871>>>>>>>        Get phmStoredPromptUpdateCallback to iVal       
95872>>>>>>>        Set phmPromptUpdateCallback to iVal       
95873>>>>>>>
95873>>>>>>>        Get pbStoredSelectionEnable to bVal
95874>>>>>>>        Set pbSelectionEnable to bVal
95875>>>>>>>        
95875>>>>>>>        Get pbStoredMultipleSelection to bVal
95876>>>>>>>        Set pbMultipleSelection to bVal
95877>>>>>>>
95877>>>>>>>    End_Procedure
95878>>>>>>>    
95878>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
95878>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
95878>>>>>>>    // Suitable for augmentation
95878>>>>>>>    Procedure OnSeedData
95880>>>>>>>        Integer iUpdateColumn iSortColumn
95880>>>>>>>        Boolean bSeed bAuto
95880>>>>>>>        String sValue
95880>>>>>>>        Handle hoCol
95880>>>>>>>
95880>>>>>>>        Get piUpdateColumn to iUpdateColumn
95881>>>>>>>        Get psSeedValue to sValue
95882>>>>>>>        Get pbAutoSeed to bSeed
95883>>>>>>>        Get piSortColumn to iSortColumn
95884>>>>>>>        Get pbAutoOrdering to bAuto
95885>>>>>>>        // if not yet sorted and this is auto ordering we will
95885>>>>>>>        // sort the data for the search column. We do this to make the
95885>>>>>>>        // column search GE logic work properly. 
95885>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
95887>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
95888>>>>>>>            Send SortGridByColumn hoCol False
95889>>>>>>>        End
95889>>>>>>>>
95889>>>>>>>
95889>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
95891>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0  
95892>>>>>>>        End
95892>>>>>>>>
95892>>>>>>>        Else Begin
95893>>>>>>>            Send MovetoFirstRow
95894>>>>>>>        End
95894>>>>>>>>
95894>>>>>>>
95894>>>>>>>    End_Function
95895>>>>>>>
95895>>>>>>>    Procedure OnMoveValueOutByValue
95897>>>>>>>        String sValue
95897>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
95897>>>>>>>        Integer iRow iCol
95897>>>>>>>        Integer[] SelRowsIndexes
95898>>>>>>>
95898>>>>>>>        Get phoInvokingObject to hoInvokingObject
95899>>>>>>>        Get pSelectedRows to SelRowsIndexes
95900>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
95902>>>>>>>            Get piUpdateColumn to iCol
95903>>>>>>>            Get ColumnObject iCol to hoCol
95904>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
95905>>>>>>>            Set Value of hoInvokingObject to sValue
95906>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
95907>>>>>>>        End
95907>>>>>>>>
95907>>>>>>>    End_Procedure
95908>>>>>>>
95908>>>>>>>    Procedure OnMoveValueOutByCustom
95910>>>>>>>    End_Procedure
95911>>>>>>>
95911>>>>>>>    // augment to popup a search window when allowed
95911>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
95913>>>>>>>        Boolean bSubFocus bAutoSearch bChar
95913>>>>>>>        Integer iVal
95913>>>>>>>        
95913>>>>>>>        Get pbFocusSubItems to bSubFocus
95914>>>>>>>        Get pbAutoSearch to bAutoSearch
95915>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
95917>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
95919>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
95921>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
95922>>>>>>>                Move (iVal<>0) to bChar
95923>>>>>>>            End
95923>>>>>>>>
95923>>>>>>>            If bChar Begin
95925>>>>>>>                // this can get called multiple times before a search dialog pops up
95925>>>>>>>                Send AddToSearchKeys llKeyCode llShift
95926>>>>>>>            End
95926>>>>>>>>
95926>>>>>>>        End
95926>>>>>>>>
95926>>>>>>>    End_Procedure
95927>>>>>>>    
95927>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
95929>>>>>>>        Boolean bAutoSearch
95929>>>>>>>        Integer iKeyCode iShiftCode
95929>>>>>>>        Get pbAutoSearch to bAutoSearch
95930>>>>>>>        If bAutoSearch Begin
95932>>>>>>>            // this can get called multiple times before a search dialog pops up
95932>>>>>>>            Get piLastKey to iKeyCode
95933>>>>>>>            Get piLastKey2 to iShiftCode
95934>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
95935>>>>>>>        End
95935>>>>>>>>
95935>>>>>>>        Move True to llCancel
95936>>>>>>>    End_Procedure  // OnComRequestEdit
95937>>>>>>>    
95937>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
95939>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
95940>>>>>>>        Forward Send OnComRowDblClick llRow llItem
95942>>>>>>>    End_Procedure
95943>>>>>>>    
95943>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
95945>>>>>>>        Send Ok
95946>>>>>>>    End_Procedure
95947>>>>>>>    
95947>>>>>>>    
95947>>>>>>>    // we don't want a menu for prompt lists
95947>>>>>>>    Function CreateContextMenu Returns Handle
95949>>>>>>>        Function_Return 0
95950>>>>>>>    End_Function
95951>>>>>>>
95951>>>>>>>    // if we use auto-ordering, change the order when the column changes
95951>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
95953>>>>>>>        Boolean bAutoOrder
95953>>>>>>>        Forward Send ColumnChanged iOld iNew
95955>>>>>>>        Get pbAutoOrdering to bAutoOrder
95956>>>>>>>        If bAutoOrder Begin
95958>>>>>>>            // will be reordered in idle event
95958>>>>>>>            Set pbNeedsNewOrdering to True
95959>>>>>>>        End
95959>>>>>>>>
95959>>>>>>>    End_Procedure
95960>>>>>>>    
95960>>>>>>>
95960>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
95962>>>>>>>        Integer eMode
95962>>>>>>>        Integer[] SelRowsIndexes
95963>>>>>>>        Set pbCanceled to True // assume cancel unless changed
95964>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
95965>>>>>>>        Get peUpdateMode to eMode
95966>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
95968>>>>>>>            Send OnStoreDefaults
95969>>>>>>>        End
95969>>>>>>>>
95969>>>>>>>        Send InitializePromptList
95970>>>>>>>        Forward Send Add_Focus hoParent
95972>>>>>>>        Send LoadData
95973>>>>>>>        Set psSeedValue to ""
95974>>>>>>>    End_Procedure
95975>>>>>>>    
95975>>>>>>>    // called before the list is activated. 
95975>>>>>>>    Procedure InitializePromptList
95977>>>>>>>        Integer hoInvokingObject
95977>>>>>>>        Boolean bAutoColumn bAutoSeed 
95977>>>>>>>        Integer i iOldMode eUpdateMode
95977>>>>>>>        String sValue
95977>>>>>>>        
95977>>>>>>>        Get peUpdateMode to eUpdateMode
95978>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
95980>>>>>>>            Get Focus of Desktop to hoInvokingObject
95981>>>>>>>            If (hoInvokingObject<=Desktop) Begin
95983>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
95984>>>>>>>>
95984>>>>>>>                Procedure_Return
95985>>>>>>>            End
95985>>>>>>>>
95985>>>>>>>
95985>>>>>>>            Set phoInvokingObject to hoInvokingObject
95986>>>>>>>
95986>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
95987>>>>>>>            Get peUpdateMode to eUpdateMode
95988>>>>>>>        End
95988>>>>>>>>
95988>>>>>>>
95988>>>>>>>        Send ClearSearchRequest // clear the search keys
95989>>>>>>>        Set pbNeedsNewOrdering to False
95990>>>>>>>
95990>>>>>>>        Get pbAutoSeed to bAutoSeed
95991>>>>>>>
95991>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
95993>>>>>>>            Get Value of hoInvokingObject to sValue
95994>>>>>>>            Set psSeedValue to sValue
95995>>>>>>>        End
95995>>>>>>>>
95995>>>>>>>        
95995>>>>>>>    End_Procedure
95996>>>>>>>    
95996>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
95996>>>>>>>    Procedure LoadData
95998>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
95998>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
95998>>>>>>>        Integer eUpdateMode
95998>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder 
95998>>>>>>>        
95998>>>>>>>        Get phoDataSource to hoDataSource
95999>>>>>>>        Get peUpdateMode to eUpdateMode
96000>>>>>>>        Get phoInvokingObject to hoInvokingObject
96001>>>>>>>        Get pbAutoSeed to bAutoSeed
96002>>>>>>>        Get piInitialColumn to iInitialColumn
96003>>>>>>>        Get piUpdateColumn to iUpdateColumn
96004>>>>>>>        Get RowCount of hoDataSource to iRows
96005>>>>>>>        
96005>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96005>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96005>>>>>>>        If (iInitialColumn=-1) Begin
96007>>>>>>>            Move iUpdateColumn to iInitialColumn
96008>>>>>>>        End
96008>>>>>>>>
96008>>>>>>>        If (iInitialColumn>=0) Begin
96010>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96011>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96012>>>>>>>        End
96012>>>>>>>>
96012>>>>>>>        Send OnSeedData // find a good starting place for the row
96013>>>>>>>        Get pbFocusSubItems to bSubFocus
96014>>>>>>>        If bSubFocus Begin
96016>>>>>>>            // if column focus, which is normal, go to initialcolumn       
96016>>>>>>>            If hoInitialColumn Begin
96018>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96019>>>>>>>            End
96019>>>>>>>>
96019>>>>>>>            Else Begin
96020>>>>>>>                Send MoveToFirstEnterableColumn
96021>>>>>>>            End
96021>>>>>>>>
96021>>>>>>>        End
96021>>>>>>>>
96021>>>>>>>
96021>>>>>>>    End_Procedure
96022>>>>>>>    
96022>>>>>>>    // This is only called in a successful close
96022>>>>>>>    Procedure ClosePromptList
96024>>>>>>>        Handle hoDataSource hoInvokingObject
96024>>>>>>>        Handle hmCallBack
96024>>>>>>>        Integer iRow eUpdateMode
96024>>>>>>>        Integer[] SelRowsIndexes
96025>>>>>>>        
96025>>>>>>>        Get phoDataSource to hoDataSource
96026>>>>>>>        Get phoInvokingObject to hoInvokingObject
96027>>>>>>>        
96027>>>>>>>        If (pbMultipleSelection(Self)) Begin
96029>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96030>>>>>>>        End
96030>>>>>>>>
96030>>>>>>>        Else Begin
96031>>>>>>>            Get SelectedRow of hoDataSource to iRow
96032>>>>>>>            If (iRow<>-1) Begin
96034>>>>>>>                Move iRow to SelRowsIndexes[0]
96035>>>>>>>            End
96035>>>>>>>>
96035>>>>>>>        End
96035>>>>>>>>
96035>>>>>>>        
96035>>>>>>>        Set pbCanceled to False
96036>>>>>>>        Set pSelectedRows to SelRowsIndexes
96037>>>>>>>        
96037>>>>>>>        Get peUpdateMode to eUpdateMode
96038>>>>>>>        // if non-invoking there is by definition, no move value out
96038>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96040>>>>>>>            
96040>>>>>>>            If (eUpdateMode=umPromptValue) Begin
96042>>>>>>>                Send OnMoveValueOutByValue
96043>>>>>>>            End
96043>>>>>>>>
96043>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96046>>>>>>>                Send OnMoveValueOutByCustom
96047>>>>>>>            End
96047>>>>>>>>
96047>>>>>>>                Get phmPromptUpdateCallback to hmCallBack
96048>>>>>>>                If hmCallBack Begin
96050>>>>>>>                    Send hmCallBack of hoInvokingObject Self
96051>>>>>>>                End
96051>>>>>>>>
96051>>>>>>>        End
96051>>>>>>>>
96051>>>>>>>
96051>>>>>>>        Send Close_Panel
96052>>>>>>>    End_Procedure
96053>>>>>>>
96053>>>>>>>    // augment to send OnRestoreDefaults.
96053>>>>>>>    Procedure Release_Focus
96055>>>>>>>        Integer eUpdateMode
96055>>>>>>>        Get peUpdateMode to eUpdateMode
96056>>>>>>>        Forward Send Release_Focus
96058>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96060>>>>>>>            Send OnRestoreDefaults
96061>>>>>>>        End
96061>>>>>>>>
96061>>>>>>>    End_Procedure
96062>>>>>>>    
96062>>>>>>>    Function SelectedRowIds Returns RowID[]
96064>>>>>>>        RowID[] SelectedRowids
96065>>>>>>>        Integer[] SelectedRows
96066>>>>>>>        Integer i iRows
96066>>>>>>>        Handle hoDataSource
96066>>>>>>>        Get phoDataSource to hoDataSource
96067>>>>>>>        Get pSelectedRows to SelectedRows
96068>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96069>>>>>>>        For i from 0 to (iRows-1)
96075>>>>>>>>
96075>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96076>>>>>>>        Loop
96077>>>>>>>>
96077>>>>>>>        Function_Return SelectedRowids
96078>>>>>>>    End_Function
96079>>>>>>>
96079>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96081>>>>>>>        String[] SelectedValues
96082>>>>>>>        Integer[] SelectedRows
96083>>>>>>>        Integer i iRows
96083>>>>>>>        Handle hoCol
96083>>>>>>>        Get ColumnObject iCol to hoCol
96084>>>>>>>        Get pSelectedRows to SelectedRows
96085>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96086>>>>>>>        For i from 0 to (iRows-1)
96092>>>>>>>>
96092>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96093>>>>>>>        Loop
96094>>>>>>>>
96094>>>>>>>        Function_Return SelectedValues
96095>>>>>>>    End_Function
96096>>>>>>>
96096>>>>>>>    Procedure Ok Returns Integer
96098>>>>>>>        Send ClosePromptList
96099>>>>>>>    End_Procedure
96100>>>>>>>
96100>>>>>>>    Procedure Cancel Returns Integer
96102>>>>>>>        Send Close_Panel
96103>>>>>>>    End_Procedure
96104>>>>>>>        
96104>>>>>>>    Procedure Search
96106>>>>>>>        Send Activate // give focus back to list so focus things are correct
96107>>>>>>>        Send Request_Search 0 0
96108>>>>>>>    End_Procedure
96109>>>>>>>    
96109>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96109>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96109>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96109>>>>>>>    Procedure Request_SearchEx
96111>>>>>>>        tGridKeyPair[] Keys
96111>>>>>>>        tGridKeyPair[] Keys
96112>>>>>>>        Integer iCol
96112>>>>>>>        Handle hoCol hoSearchDialog 
96112>>>>>>>        Boolean bOk
96112>>>>>>>        String sValue
96112>>>>>>>
96112>>>>>>>        Get piSortColumn to iCol
96113>>>>>>>        If (iCol<>-1) Begin
96115>>>>>>>            Get ColumnObject iCol to hoCol
96116>>>>>>>                Get pSearchKeys to Keys
96117>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96118>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96119>>>>>>>            If bOk Begin
96121>>>>>>>               Send RequestFindColumnValue iCol sValue True 0  
96122>>>>>>>            End
96122>>>>>>>>
96122>>>>>>>            Send Destroy of hoSearchDialog
96123>>>>>>>        End
96123>>>>>>>>
96123>>>>>>>        Send ClearSearchRequest // clear the search keys
96124>>>>>>>    End_Procedure
96125>>>>>>>    
96125>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96125>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96127>>>>>>>        tGridKeyPair[] Keys
96127>>>>>>>        tGridKeyPair[] Keys
96128>>>>>>>        tGridKeyPair KeyPair
96128>>>>>>>        tGridKeyPair KeyPair
96128>>>>>>>        Set pbRequestSearch to True
96129>>>>>>>        Move iKeyCode to KeyPair.KeyCode
96130>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
96131>>>>>>>        Get pSearchKeys to Keys                
96132>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96133>>>>>>>        Set pSearchKeys to Keys                
96134>>>>>>>    End_Procedure
96135>>>>>>>
96135>>>>>>>    Procedure ClearSearchRequest
96137>>>>>>>        tGridKeyPair[] SearchKeys
96137>>>>>>>        tGridKeyPair[] SearchKeys
96138>>>>>>>        Set pSearchKeys to SearchKeys
96139>>>>>>>        Set pbRequestSearch to False
96140>>>>>>>    End_Procedure
96141>>>>>>>    
96141>>>>>>>End_Class
96142>>>>>Use cDbUpdateFunctionLibrary.pkg
96142>>>>>Use MSSqldrv.pkg
96142>>>>>Use db2_drv.pkg
96142>>>>>Use odbc_drv.pkg
96142>>>>>
96142>>>>>Object oDatabaseSelection_sl is a ModalPanel
96144>>>>>    Set Label to "SQL Database Selection"
96145>>>>>    Set Size to 121 183
96146>>>>>    Set piMinSize to 89 170
96147>>>>>    Set Location to 2 2
96148>>>>>    Set Border_Style to Border_Thick
96149>>>>>
96149>>>>>    Property String[] psTheData
96151>>>>>
96151>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96153>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96155>>>>>        End_Object
96156>>>>>    End
96156>>>>>>
96156>>>>>
96156>>>>>    Object oSelList is a cCJGridPromptList
96158>>>>>        Set Size to 89 167
96159>>>>>        Set Location to 6 6
96160>>>>>        Set peAnchors to anAll
96161>>>>>        Set pbAllowColumnRemove to False
96162>>>>>        Set pbUseAlternateRowBackgroundColor to True
96163>>>>>        Set pbGrayIfDisable to False
96164>>>>>        Set pbHeaderReorders to False
96165>>>>>        Set pbHeaderSelectsColumn to False
96166>>>>>        Set pbHeaderTogglesDirection to False
96167>>>>>        Set pbShadeSortColumn to False
96168>>>>>        Set piFocusCellBackColor to clDkGray
96169>>>>>
96169>>>>>        Object oName is a cCJGridColumn
96171>>>>>            Set piWidth to 334
96172>>>>>            Set psCaption to "Database Name"
96173>>>>>        End_Object
96174>>>>>
96174>>>>>        Procedure Activating
96177>>>>>            tDataSourceRow[] MyData
96177>>>>>            tDataSourceRow[] MyData
96178>>>>>            Handle hoDataSource
96178>>>>>            String[] sTheData
96179>>>>>            Integer iCount iSize
96179>>>>>
96179>>>>>            Send Cursor_Wait of Cursor_Control
96180>>>>>            Forward Send Activating
96182>>>>>
96182>>>>>            Get psTheData to sTheData
96183>>>>>            Move (SizeOfArray(sTheData)) to iSize
96184>>>>>            Decrement iSize
96185>>>>>            For iCount from 0 to iSize
96191>>>>>>
96191>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96192>>>>>            Loop
96193>>>>>>
96193>>>>>
96193>>>>>            Get phoDataSource to hoDataSource
96194>>>>>            Send InitializeData of hoDataSource MyData
96195>>>>>            Send Cursor_Ready of Cursor_Control
96196>>>>>        End_Procedure
96197>>>>>
96197>>>>>    End_Object
96198>>>>>
96198>>>>>    Object oOK_Btn is a Button
96200>>>>>        Set Label    to "&OK"
96201>>>>>        Set Location to 100 68
96202>>>>>        Set peAnchors To anBottomRight
96203>>>>>
96203>>>>>        Procedure OnClick
96206>>>>>            Send Ok of oSelList
96207>>>>>        End_Procedure
96208>>>>>
96208>>>>>    End_Object
96209>>>>>
96209>>>>>    Object oCancel_Btn is a Button
96211>>>>>        Set Label    to "&Cancel"
96212>>>>>        Set Location to 100 123
96213>>>>>        Set peAnchors to anBottomRight
96214>>>>>
96214>>>>>        Procedure OnClick
96217>>>>>            Send Close_Panel
96218>>>>>        End_Procedure
96219>>>>>
96219>>>>>    End_Object
96220>>>>>
96220>>>>>    Procedure Page Integer iPageObject
96223>>>>>        Set Icon to "DatabaseLookup.ico"
96224>>>>>        Forward Send Page iPageObject
96226>>>>>    End_Procedure
96227>>>>>
96227>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96228>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96229>>>>>End_Object
96230>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ServerSelection.dg)
96230>>>>>Use Windows.pkg
96230>>>>>Use cCJGridPromptList.pkg
96230>>>>>Use cDbUpdateFunctionLibrary.pkg
96230>>>>>Use MSSqldrv.pkg
96230>>>>>Use db2_drv.pkg
96230>>>>>Use odbc_drv.pkg
96230>>>>>
96230>>>>>Object oServerSelection_sl is a ModalPanel
96232>>>>>    Set Size to 148 274
96233>>>>>    Set Label to "Database Server/DSN Selection"
96234>>>>>    Set piMinSize to 89 211
96235>>>>>    Set Location to 2 2
96236>>>>>    Set Border_Style to Border_Thick
96237>>>>>
96237>>>>>    Property String[] psTheData
96239>>>>>
96239>>>>>    Object oSelList is a cCJGridPromptList
96241>>>>>        Set Size to 115 264
96242>>>>>        Set Location to 6 6
96243>>>>>        Set peAnchors to anAll
96244>>>>>        Set pbAllowColumnRemove to False
96245>>>>>        Set pbUseAlternateRowBackgroundColor to True
96246>>>>>        Set pbGrayIfDisable to False
96247>>>>>        Set pbHeaderReorders to False
96248>>>>>        Set pbHeaderSelectsColumn to False
96249>>>>>        Set pbHeaderTogglesDirection to False
96250>>>>>        Set pbShadeSortColumn to False
96251>>>>>        Set piFocusCellBackColor to clDkGray
96252>>>>>
96252>>>>>        Object oName is a cCJGridColumn
96254>>>>>            Set piWidth to 528
96255>>>>>            Set psCaption to "Name"
96256>>>>>        End_Object
96257>>>>>
96257>>>>>        Procedure Activating
96260>>>>>            tDataSourceRow[] MyData
96260>>>>>            tDataSourceRow[] MyData
96261>>>>>            Handle hoDataSource
96261>>>>>            String[] sTheData
96262>>>>>            Integer iCount iSize
96262>>>>>
96262>>>>>            Send Cursor_Wait of Cursor_Control
96263>>>>>            Get psTheData to sTheData
96264>>>>>            Move (SizeOfArray(sTheData)) to iSize
96265>>>>>            Decrement iSize
96266>>>>>            For iCount from 0 to iSize
96272>>>>>>
96272>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96273>>>>>            Loop
96274>>>>>>
96274>>>>>
96274>>>>>            Forward Send Activating
96276>>>>>
96276>>>>>            Get phoDataSource to hoDataSource
96277>>>>>            Send InitializeData of hoDataSource MyData
96278>>>>>            Send Cursor_Ready of Cursor_Control
96279>>>>>        End_Procedure
96280>>>>>
96280>>>>>    End_Object
96281>>>>>
96281>>>>>    Object oOK_Btn is a Button
96283>>>>>        Set Label    to "&OK"
96284>>>>>        Set Location to 130 165
96285>>>>>        Set peAnchors To anBottomRight
96286>>>>>
96286>>>>>        Procedure OnClick
96289>>>>>            Send Ok of oSelList
96290>>>>>        End_Procedure
96291>>>>>
96291>>>>>    End_Object
96292>>>>>
96292>>>>>    Object oCancel_Btn is a Button
96294>>>>>        Set Label    to "&Cancel"
96295>>>>>        Set Location to 130 220
96296>>>>>        Set peAnchors to anBottomRight
96297>>>>>
96297>>>>>        Procedure OnClick
96300>>>>>            Send Close_Panel
96301>>>>>        End_Procedure
96302>>>>>
96302>>>>>    End_Object
96303>>>>>
96303>>>>>    Procedure Page Integer iPageObject
96306>>>>>        Set Icon to "ServerLookup.ico"
96307>>>>>        Forward Send Page iPageObject
96309>>>>>    End_Procedure
96310>>>>>
96310>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96311>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96312>>>>>End_Object
96313>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
96313>>>>>Use Windows.pkg
96313>>>>>Use cCJGridPromptList.pkg
96313>>>>>Use cDbUpdateFunctionLibrary.pkg
96313>>>>>
96313>>>>>Object oTableSpaceSelection_sl is a ModalPanel
96315>>>>>    Set Size to 118 177
96316>>>>>    Set Label to "SQL Tablespace Selection"
96317>>>>>    Set piMinSize to 89 177
96318>>>>>    Set Location to 2 2
96319>>>>>    Set Border_Style to Border_Thick
96320>>>>>
96320>>>>>    Property String[] psTheData
96322>>>>>
96322>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96324>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96326>>>>>        End_Object
96327>>>>>    End
96327>>>>>>
96327>>>>>
96327>>>>>    Object oSelList is a cCJGridPromptList
96329>>>>>        Set Size to 89 167
96330>>>>>        Set Location to 6 6
96331>>>>>        Set peAnchors to anAll
96332>>>>>        Set pbAllowColumnRemove to False
96333>>>>>        Set pbUseAlternateRowBackgroundColor to True
96334>>>>>        Set pbGrayIfDisable to False
96335>>>>>        Set pbHeaderReorders to False
96336>>>>>        Set pbHeaderSelectsColumn to False
96337>>>>>        Set pbHeaderTogglesDirection to False
96338>>>>>        Set pbShadeSortColumn to False
96339>>>>>        Set piFocusCellBackColor to clDkGray
96340>>>>>
96340>>>>>        Object oName is a cCJGridColumn
96342>>>>>            Set piWidth to 334
96343>>>>>            Set psCaption to "Table Space Name"
96344>>>>>        End_Object
96345>>>>>
96345>>>>>        Procedure Activating
96348>>>>>            tDataSourceRow[] MyData
96348>>>>>            tDataSourceRow[] MyData
96349>>>>>            Handle hoDataSource
96349>>>>>            String[] sTheData
96350>>>>>            Integer iCount iSize
96350>>>>>
96350>>>>>            Send Cursor_Wait of Cursor_Control
96351>>>>>            Forward Send Activating
96353>>>>>
96353>>>>>            Get psTheData to sTheData
96354>>>>>            Move (SizeOfArray(sTheData)) to iSize
96355>>>>>            Decrement iSize
96356>>>>>            For iCount from 0 to iSize
96362>>>>>>
96362>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96363>>>>>            Loop
96364>>>>>>
96364>>>>>
96364>>>>>            Get phoDataSource to hoDataSource
96365>>>>>            Send InitializeData of hoDataSource MyData
96366>>>>>            Send Cursor_Ready of Cursor_Control
96367>>>>>        End_Procedure
96368>>>>>
96368>>>>>    End_Object
96369>>>>>
96369>>>>>    Object oOK_Btn is a Button
96371>>>>>        Set Label    to "&OK"
96372>>>>>        Set Location to 100 68
96373>>>>>        Set peAnchors To anBottomRight
96374>>>>>
96374>>>>>        Procedure OnClick
96377>>>>>            Send Ok of oSelList
96378>>>>>        End_Procedure
96379>>>>>
96379>>>>>    End_Object
96380>>>>>
96380>>>>>    Object oCancel_Btn is a Button
96382>>>>>        Set Label    to "&Cancel"
96383>>>>>        Set Location to 100 123
96384>>>>>        Set peAnchors to anBottomRight
96385>>>>>
96385>>>>>        Procedure OnClick
96388>>>>>            Send Close_Panel
96389>>>>>        End_Procedure
96390>>>>>
96390>>>>>    End_Object
96391>>>>>
96391>>>>>    Procedure Page Integer iPageObject
96394>>>>>        Set Icon to "DatabaseLookup.ico"
96395>>>>>        Forward Send Page iPageObject
96397>>>>>    End_Procedure
96398>>>>>
96398>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96399>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96400>>>>>End_Object
96401>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SchemasSelection.dg)
96401>>>>>Use Windows.pkg
96401>>>>>Use cCJGridPromptList.pkg
96401>>>>>Use cDbUpdateFunctionLibrary.pkg
96401>>>>>
96401>>>>>Object oSchemasSelection_sl is a ModalPanel
96403>>>>>    Set Size to 118 177
96404>>>>>    Set Label to "SQL Schemas Selection"
96405>>>>>    Set piMinSize to 89 177
96406>>>>>    Set Location to 2 2
96407>>>>>    Set Border_Style to Border_Thick
96408>>>>>
96408>>>>>    Property String[] psTheData
96410>>>>>
96410>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96412>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96414>>>>>        End_Object
96415>>>>>    End
96415>>>>>>
96415>>>>>
96415>>>>>    Object oSelList is a cCJGridPromptList
96417>>>>>        Set Size to 89 167
96418>>>>>        Set Location to 6 6
96419>>>>>        Set peAnchors to anAll
96420>>>>>        Set pbAllowColumnRemove to False
96421>>>>>        Set pbUseAlternateRowBackgroundColor to True
96422>>>>>        Set pbGrayIfDisable to False
96423>>>>>        Set pbHeaderReorders to False
96424>>>>>        Set pbHeaderSelectsColumn to False
96425>>>>>        Set pbHeaderTogglesDirection to False
96426>>>>>        Set pbShadeSortColumn to False
96427>>>>>        Set piFocusCellBackColor to clDkGray
96428>>>>>
96428>>>>>        Object oName is a cCJGridColumn
96430>>>>>            Set piWidth to 334
96431>>>>>            Set psCaption to "Schema Name"
96432>>>>>        End_Object
96433>>>>>
96433>>>>>        Procedure Activating
96436>>>>>            tDataSourceRow[] MyData
96436>>>>>            tDataSourceRow[] MyData
96437>>>>>            Handle hoDataSource
96437>>>>>            String[] sTheData
96438>>>>>//            String sDriverID sConnectionString
96438>>>>>            Integer iCount iSize iDbType
96438>>>>>
96438>>>>>            Send Cursor_Wait of Cursor_Control
96439>>>>>            Forward Send Activating
96441>>>>>
96441>>>>>//            Get psDriverID to sDriverID
96441>>>>>//            Get psConnectionString to sConnectionString
96441>>>>>//            Get piDbType to iDbType
96441>>>>>            Get psTheData to sTheData
96442>>>>>
96442>>>>>            Move (SizeOfArray(sTheData)) to iSize
96443>>>>>            Decrement iSize
96444>>>>>            For iCount from 0 to iSize
96450>>>>>>
96450>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96451>>>>>            Loop
96452>>>>>>
96452>>>>>
96452>>>>>            Get phoDataSource to hoDataSource
96453>>>>>            Send InitializeData of hoDataSource MyData
96454>>>>>            Send Cursor_Ready of Cursor_Control
96455>>>>>        End_Procedure
96456>>>>>
96456>>>>>    End_Object
96457>>>>>
96457>>>>>    Object oOK_Btn is a Button
96459>>>>>        Set Label    to "&OK"
96460>>>>>        Set Location to 100 68
96461>>>>>        Set peAnchors To anBottomRight
96462>>>>>
96462>>>>>        Procedure OnClick
96465>>>>>            Send Ok of oSelList
96466>>>>>        End_Procedure
96467>>>>>
96467>>>>>    End_Object
96468>>>>>
96468>>>>>    Object oCancel_Btn is a Button
96470>>>>>        Set Label    to "&Cancel"
96471>>>>>        Set Location to 100 123
96472>>>>>        Set peAnchors to anBottomRight
96473>>>>>
96473>>>>>        Procedure OnClick
96476>>>>>            Send Close_Panel
96477>>>>>        End_Procedure
96478>>>>>
96478>>>>>    End_Object
96479>>>>>
96479>>>>>    Procedure Page Integer iPageObject
96482>>>>>        Set Icon to "DatabaseLookup.ico"
96483>>>>>        Forward Send Page iPageObject
96485>>>>>    End_Procedure
96486>>>>>
96486>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96487>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96488>>>>>End_Object
96489>>>
96489>>>Define CS_LoadingServers        for "Enumerating servers..."
96489>>>Define CS_LoadingDatabases      for "Enumerating databases..."
96489>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
96489>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
96489>>>Define CS_LoginAttempt          for "Connecting..."
96489>>>Define CS_LoginSuccessful       for "Login successful!"
96489>>>Define CS_LoginFailed           for "Login failed!"
96489>>>Define CS_DF_File_Schema        for "Schema"
96489>>>Define CS_DF_File_Owner         for "Owner"
96489>>>
96489>>>Object oSQLMaintainConnections_dg is a ModalPanel
96491>>>    Set Label to "Show SQL Connection"
96492>>>    Set Size to 261 410
96493>>>    Set Location to 4 6
96494>>>    Set Locate_Mode to Center_On_Parent
96495>>>    Set Border_Style to Border_Thick
96496>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
96497>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
96498>>>
96498>>>    Property Handle phoDialogCommandbar
96500>>>    Property tSQLConnection pSQLConnectionData
96502>>>    Property tDataSourceRow[] pTheData
96504>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
96506>>>    Property String psUncryptedPw     // Used if  pbDFConnId = True to temporary save the un-encrypted password.
96508>>>
96508>>>    Object oDbType_cf is a cSQLComboForm
96510>>>        Set Size to 11 120
96511>>>        Set Location to 11 86
96512>>>        Set Label_Col_Offset to 2
96513>>>        Set Label_Justification_Mode to JMode_Right
96514>>>        Set Label to "Database Type"
96515>>>        Set Entry_State to False
96516>>>        Set Combo_Sort_State to False
96517>>>        Set piItem to 3        
96518>>>        Set Enabled_State to False
96519>>>
96519>>>        Procedure Combo_Fill_List
96522>>>            Send Combo_Add_Item CS_dbTypeMSSQL
96523>>>            Send Combo_Add_Item CS_dbTypeMySQL
96524>>>            Send Combo_Add_Item CS_dbTypeOracle
96525>>>            Send Combo_Add_Item CS_dbTypeDB2
96526>>>            Send Combo_Add_Item CS_dbTypePostgre
96527>>>        End_Procedure
96528>>>
96528>>>        Function SelectedDbType Returns Integer
96531>>>            Integer iRetval
96531>>>            String sDbType
96531>>>
96531>>>            Get Value to sDbType
96532>>>            Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
96533>>>
96533>>>            Function_Return iRetval
96534>>>        End_Function
96535>>>
96535>>>    End_Object
96536>>>
96536>>>    Object oDriverID_cf is a cSQLComboForm
96538>>>        Set Size to 11 120
96539>>>        Set Location to 24 86
96540>>>        Set Label_Col_Offset to 2
96541>>>        Set Label_Justification_Mode to JMode_Right
96542>>>        Set Label to "Driver ID"
96543>>>        Set psToolTip to "Depending on the database type selected and if Mertech drivers have been installed, the comboform list will vary."
96544>>>        Set Entry_State to False
96545>>>        Set Combo_Sort_State to False
96546>>>        Set piItem to 4
96547>>>        Set Enabled_State to False
96548>>>
96548>>>        Procedure Refill_Comboform Integer iDbType
96551>>>            String sValue
96551>>>            Send Combo_Delete_Data
96552>>>            Case Begin
96552>>>                Case (iDbType = EN_dbTypeMSSQL)
96554>>>                    Send Combo_Add_Item MSSQLDRV_ID
96555>>>                    Send Combo_Add_Item SQLFLEX
96556>>>                    Move MSSQLDRV_ID to sValue
96557>>>                    Case Break
96558>>>                Case (iDbType = EN_dbTypeMySQL)
96561>>>                    Send Combo_Add_Item ODBC_DRV_ID
96562>>>                    Send Combo_Add_Item MDSMySQL
96563>>>                    Move MDSMySQL to sValue
96564>>>                    Case Break
96565>>>                Case (iDbType = EN_dbTypeOracle)
96568>>>                    Send Combo_Add_Item ODBC_DRV_ID
96569>>>                    Send Combo_Add_Item ORAFLEX
96570>>>                    Move ORAFLEX to sValue
96571>>>                    Case Break
96572>>>                Case (iDbType = EN_dbTypeDB2)
96575>>>                    Send Combo_Add_Item DB2_DRV_ID
96576>>>                    Move DB2_DRV_ID to sValue
96577>>>                    Case Break
96578>>>                Case (iDbType = EN_dbTypePostgre)
96581>>>                    Send Combo_Add_Item ODBC_DRV_ID
96582>>>                    Send Combo_Add_Item MDSPgSQL
96583>>>                    Move MDSPgSQL to sValue
96584>>>                    Case Break
96585>>>                Case Else
96585>>>                    Send Combo_Add_Item DATAFLEX_ID
96586>>>                    Move DATAFLEX_ID to sValue
96587>>>//                Case (iDbType = EN_dbTypeMSSQL)
96587>>>//                    Send Combo_Add_Item (MSSQLDRV_ID * "- (DAW)")
96587>>>//                    Send Combo_Add_Item (SQLFLEX * "- (Mertech)")
96587>>>//                    Move (MSSQLDRV_ID * "- (DAW)") to sValue
96587>>>//                    Case Break
96587>>>//                Case (iDbType = EN_dbTypeMySQL)
96587>>>//                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
96587>>>//                    Send Combo_Add_Item (MDSMySQL * "- (Mertech)")
96587>>>//                    Move (MDSMySQL * "- (Mertech)") to sValue
96587>>>//                    Case Break
96587>>>//                Case (iDbType = EN_dbTypeOracle)
96587>>>//                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
96587>>>//                    Send Combo_Add_Item (ORAFLEX * "- (Mertech)")
96587>>>//                    Move (ORAFLEX * "- (Mertech)") to sValue
96587>>>//                    Case Break
96587>>>//                Case (iDbType = EN_dbTypeDB2)
96587>>>//                    Send Combo_Add_Item (DB2_DRV_ID * "- (DAW)")
96587>>>//                    Move (DB2_DRV_ID * "- (DAW)") to sValue
96587>>>//                    Case Break
96587>>>//                Case (iDbType = EN_dbTypePostgre)
96587>>>//                    Send Combo_Add_Item (ODBC_DRV_ID * "- (DAW)")
96587>>>//                    Send Combo_Add_Item (MDSPgSQL * "- (Mertech)")
96587>>>//                    Move (MDSPgSQL * "- (Mertech)") to sValue
96587>>>//                    Case Break
96587>>>//                Case Else
96587>>>//                    Send Combo_Add_Item (DATAFLEX_ID * "- (DAW)")
96587>>>//                    Move (DATAFLEX_ID * "- (DAW)") to sValue
96587>>>            Case End
96587>>>            Set Value to sValue
96588>>>        End_Procedure
96589>>>
96589>>>//        Procedure OnChange
96589>>>//            String sDriverID
96589>>>//            Integer iDbType iPos
96589>>>//
96589>>>//            Get Value to sDriverID
96589>>>//            Move (Pos("-", sDriverID)) to iPos
96589>>>//            Move (Left(sDriverID, (iPos - 2))) to sDriverID
96589>>>//            If (sDriverID = "") Begin
96589>>>//                Move MSSQLDRV_ID to sDriverID
96589>>>//            End
96589>>>//            Get SelectedDbType of oDbType_cf to iDbType
96589>>>//            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
96589>>>//        End_Procedure
96589>>>//
96589>>>    End_Object
96590>>>
96590>>>    Object oConnectionID_fm is a cSQLForm
96592>>>        Set Size to 13 120
96593>>>        Set Location to 37 86
96594>>>        Set Label to "Connection ID"
96595>>>        Set Label_Col_Offset to 2
96596>>>        Set Label_Justification_Mode to JMode_Right
96597>>>        Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
96598>>>        Set piItem to 2
96599>>>        Set Enabled_State to False
96600>>>    End_Object
96601>>>
96601>>>    Object oEnabled_cb is a cSQLCheckBox
96603>>>        Set Auto_Size_State to False
96604>>>        Set Size to 9 38
96605>>>        Set Location to 39 216
96606>>>        Set Label to "Enabled"
96607>>>        Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
96608>>>        Set piItem to 1
96609>>>        Set Enabled_State to False
96610>>>    End_Object
96611>>>
96611>>>    Object oSettings_grp is a Group
96613>>>        Set Size to 166 389
96614>>>        Set Location to 59 11
96615>>>        Set Label to "Connection String Details"
96616>>>        Set peAnchors to anTopLeftRight
96617>>>
96617>>>        Object oServer_fm is a cSQLForm
96619>>>            Set Size to 13 120
96620>>>            Set Location to 14 74
96621>>>            Set Label to "Server"
96622>>>            Set Label_Col_Offset to 2
96623>>>            Set Label_Justification_Mode to JMode_Right
96624>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
96625>>>            Set peAnchors to anTopLeftRight
96626>>>            Set piItem to 5
96627>>>            Set Enabled_State to False
96628>>>        End_Object
96629>>>
96629>>>        Object oServersInfo_tb is a TextBox
96631>>>            Set Auto_Size_State to False
96632>>>            Set Size to 9 100
96633>>>            Set Location to 18 262
96634>>>            Set TextColor to clGreen
96635>>>            Set Justification_Mode to JMode_Right
96636>>>            Set peAnchors to anTopRight
96637>>>        End_Object
96638>>>
96638>>>        Object oSilentLogin_fm is a cSQLCheckBox
96640>>>            Set Auto_Size_State to False
96641>>>            Set Size to 9 51
96642>>>            Set Location to 17 205
96643>>>            Set Label to "Silent Login"
96644>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
96645>>>            Set peAnchors to anTopRight
96646>>>            Set piItem to 15
96647>>>            Set Enabled_State to False
96648>>>        End_Object
96649>>>
96649>>>        Object oODBC_rgp is a RadioGroup
96651>>>            Set Location to 31 75
96652>>>            Set Size to 25 298
96653>>>            Set Label to "Show ODBC Data Source"
96654>>>            Set Enabled_State to False
96655>>>
96655>>>            Object oRadio1 is a Radio
96657>>>                Set Label to "User data"
96658>>>                Set Size to 10 49
96659>>>                Set Location to 10 5
96660>>>            End_Object
96661>>>
96661>>>            Object oRadio2 is a Radio
96663>>>                Set Label to "System data"
96664>>>                Set Size to 10 55
96665>>>                Set Location to 10 64
96666>>>            End_Object
96667>>>
96667>>>            Object oRadio3 is a Radio
96669>>>                Set Label to "Both"
96670>>>                Set Size to 10 28
96671>>>                Set Location to 11 130
96672>>>            End_Object
96673>>>
96673>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
96676>>>                Forward Send Notify_Select_State iToItem iFromItem
96678>>>            End_Procedure
96679>>>
96679>>>            Object oFileDSN_btn is a cButtonDPI
96681>>>                Set Size to 13 62
96682>>>                Set Location to 8 168
96683>>>                Set Label to "Select File DSN..."
96684>>>
96684>>>                Procedure OnClick
96687>>>                    String sFileName
96687>>>                    Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
96688>>>                    If (sFileName <> "") Begin
96690>>>                        Set Value of oServer_fm to sFileName
96691>>>                    End
96691>>>>
96691>>>                End_Procedure
96692>>>
96692>>>                Set Current_Radio to 2
96693>>>            End_Object
96694>>>
96694>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
96697>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
96698>>>            End_Procedure
96699>>>
96699>>>            Object oODBCAdmin_btn is a cButtonDPI
96701>>>                Set Size to 13 55
96702>>>                Set Location to 8 234
96703>>>                Set Label to "ODBC Admin"
96704>>>                Procedure OnClick
96707>>>                    Handle hWnd
96707>>>                    Get Window_Handle to hWnd
96708>>>                    If (hWnd <> 0) Begin
96710>>>                        ODBCManager hWnd
96715>>>                    End
96715>>>>
96715>>>                    Else Begin
96716>>>                        Send Stop_Box "Could not get a Windows handle.."
96717>>>                    End
96717>>>>
96717>>>                End_Procedure
96718>>>            End_Object
96719>>>
96719>>>        End_Object
96720>>>
96720>>>        Object oTrusted_cb is a cSQLCheckBox
96722>>>            Set Size to 10 50
96723>>>            Set Location to 65 74
96724>>>            Set Label to "Use Trusted Connection"
96725>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
96726>>>            Set piItem to 8
96727>>>            Set Enabled_State to False
96728>>>
96728>>>        End_Object
96729>>>
96729>>>        Object oUserID_fm is a cSQLForm
96731>>>            Set Size to 13 120
96732>>>            Set Location to 76 74
96733>>>            Set Label to "User ID"
96734>>>            Set Label_Col_Offset to 2
96735>>>            Set Label_Justification_Mode to JMode_Right
96736>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
96737>>>            Set piItem to 9
96738>>>            Set Enabled_State to False
96739>>>        End_Object
96740>>>
96740>>>        Object oPassword_fm is a cSQLForm
96742>>>            Set Size to 13 91
96743>>>            Set Location to 76 270
96744>>>            Set Label to "Password"
96745>>>            Set Label_Col_Offset to 2
96746>>>            Set Label_Justification_Mode to JMode_Right
96747>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
96748>>>            Set piItem to 10
96749>>>            Set Password_State to True
96750>>>        End_Object
96751>>>
96751>>>        Object oViewPassword_btn is a cButtonDPI
96753>>>            Set Size to 13 19
96754>>>            Set Location to 76 365
96755>>>            Set psToolTip to "Toggle password"  
96756>>>            Set psImage to "PasswordView.ico"
96757>>>        
96757>>>            Procedure OnClick         
96760>>>                Handle ho       
96760>>>                Boolean bState   
96760>>>                Integer iRetval  
96760>>>                
96760>>>                Move (oPassword_fm(Self)) to ho
96761>>>                Get Password_State of ho item 0 to bState
96762>>>                Send Page_Object   of ho False
96763>>>                Set Password_State of ho item 0 to (not(bState)) 
96764>>>                Send Page_Object   of ho True  
96765>>>                // Finally we need to add the object to the focus tree again or else it will get invisible.
96765>>>                Get msg_Add_Focus  of ho (Parent(ho)) to iRetVal
96766>>>            End_Procedure
96767>>>        
96767>>>        End_Object
96768>>>
96768>>>        Object oLoginInfo_tb is a TextBox
96770>>>            Set Auto_Size_State to False
96771>>>            Set Size to 9 64
96772>>>            Set Location to 95 203
96773>>>            Set TextColor to clGreen
96774>>>            Set Justification_Mode to JMode_Right
96775>>>        End_Object
96776>>>
96776>>>        Object oCheckLogin_btn is a cButtonDPI
96778>>>            Set Size to 13 91
96779>>>            Set Location to 92 270
96780>>>            Set Label to "Check &Login"
96781>>>            Set psImage to "ActionLogin.ico"
96782>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
96783>>>
96783>>>            Procedure OnClick
96786>>>                String sConnectionString sServer sDatabase sUserId sPassword sDriverID sCheck
96786>>>                Boolean bTrusted bLoginSuccessful bMertechDriver
96786>>>                Integer iStart iDriverID
96786>>>                Handle hoErrorObj hoDriver
96786>>>
96786>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
96787>>>                Move Error_Object_Id to hoErrorObj
96788>>>                Move Self to Error_Object_Id
96789>>>                Move False to Err
96790>>>
96790>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
96791>>>                Send PumpMsgQueue
96792>>>
96792>>>                Get Checked_State of oTrusted_cb to bTrusted
96793>>>                Get Value of oDriverID_cf to sDriverID
96794>>>                Get Value of oServer_fm   to sServer
96795>>>                Get Value of oDatabase_fm to sDatabase
96796>>>                Get Value of oUserID_fm   to sUserId
96797>>>                Get Value of oPassword_fm to sPassword
96798>>>
96798>>>                If (sServer = "") Begin
96800>>>                    Send Info_Box "Please enter a server first, then try again."
96801>>>                    Procedure_Return
96802>>>                End
96802>>>>
96802>>>
96802>>>                Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID sServer sDatabase bTrusted sUserId sPassword to sConnectionString
96803>>>
96803>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
96804>>>                If (iDriverID = 0) Begin
96806>>>                    Set TextColor of oLoginInfo_tb to clRed
96807>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
96808>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
96809>>>                    Procedure_Return
96810>>>                End
96810>>>>
96810>>>
96810>>>                Get IsMertechDriver of ghoSQLConnectionHandler sDriverID to bMertechDriver
96811>>>                If (bMertechDriver = False) Begin
96813>>>                    Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
96816>>>                End
96816>>>>
96816>>>
96816>>>                Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
96817>>>                Set psDriverID of hoDriver to sDriverID
96818>>>                Get DbLogin    of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
96819>>>                Send Destroy   of hoDriver
96820>>>
96820>>>                If bLoginSuccessful Begin
96822>>>                    Set TextColor of oLoginInfo_tb to clGreen
96823>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful
96824>>>                End
96824>>>>
96824>>>                Else Begin
96825>>>                    Set TextColor of oLoginInfo_tb to clRed
96826>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
96827>>>                End
96827>>>>
96827>>>
96827>>>                Move hoErrorObj to Error_Object_Id
96828>>>                Send Cursor_Ready of Cursor_Control
96829>>>            End_Procedure
96830>>>
96830>>>            // This method is here simply to intercept any error that may occur while logging in
96830>>>            // it does not have to do anything with the error, but it suppresses the normal error display
96830>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
96833>>>            End_Procedure
96834>>>
96834>>>        End_Object
96835>>>
96835>>>        Object oTableSpaceInfo_tb is a TextBox
96837>>>            Set Auto_Size_State to False
96838>>>            Set Size to 9 118
96839>>>            Set Location to 102 75
96840>>>            Set TextColor to clGreen
96841>>>            Set Justification_Mode to JMode_Right
96842>>>            Set peAnchors to anNone
96843>>>        End_Object
96844>>>
96844>>>        Object oBaseTableSpace_fm is a cSQLForm
96846>>>            Set Size to 13 120
96847>>>            Set Location to 115 74
96848>>>            Set Label to "Table Space"
96849>>>            Set Label_Col_Offset to 2
96850>>>            Set Label_Justification_Mode to JMode_Right
96851>>>            Set piItem to 12
96852>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
96853>>>            Set Enabled_State to False
96854>>>        End_Object
96855>>>
96855>>>        Object oIndexTableSpace_fm is a cSQLForm
96857>>>            Set Size to 13 93
96858>>>            Set Location to 115 270
96859>>>            Set Label to "Index Table Space"
96860>>>            Set Label_Col_Offset to 2
96861>>>            Set Label_Justification_Mode to JMode_Right
96862>>>            Set piItem to 14
96863>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
96864>>>            Set Enabled_State to False
96865>>>        End_Object
96866>>>
96866>>>        Object oLongTableSpace_fm is a cSQLForm
96868>>>            Set Size to 13 120
96869>>>            Set Location to 130 74
96870>>>            Set Label to "Long Table Space"
96871>>>            Set Label_Col_Offset to 2
96872>>>            Set Label_Justification_Mode to JMode_Right
96873>>>            Set piItem to 13
96874>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
96875>>>            Set Enabled_State to False
96876>>>        End_Object
96877>>>
96877>>>        Object oSchema_fm is a cSQLForm
96879>>>            Set Size to 13 93
96880>>>            Set Location to 130 270
96881>>>            Set Label to "Schema"
96882>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
96883>>>            Set Label_Col_Offset to 2
96884>>>            Set Label_Justification_Mode to JMode_Right
96885>>>            Set piItem to 11
96886>>>            Set Enabled_State to False
96887>>>
96887>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
96889>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
96891>>>
96891>>>        End_Object
96892>>>
96892>>>        Object oDatabase_fm is a cSQLForm
96894>>>            Set Size to 13 120
96895>>>            Set Location to 146 74
96896>>>            Set Label to "Database"
96897>>>            Set Label_Col_Offset to 2
96898>>>            Set Label_Justification_Mode to JMode_Right
96899>>>            Set peAnchors to anTopLeftRight
96900>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
96901>>>            Set piItem to 6
96902>>>            Set Enabled_State to False
96903>>>        End_Object
96904>>>
96904>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
96907>>>            String sDbType
96907>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
96908>>>            Set Label to (sDbType * "Connection Details")
96909>>>        End_Procedure
96910>>>
96910>>>    End_Object
96911>>>
96911>>>    Object oCancel_Btn is a cButtonDPI
96913>>>        Set Label    to "Close"
96914>>>        Set Location to 232 343
96915>>>        Set peAnchors to anBottomRight
96916>>>
96916>>>        Procedure OnClick
96919>>>            Send Close_Panel
96920>>>        End_Procedure
96921>>>
96921>>>    End_Object
96922>>>
96922>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
96925>>>        String[] sConnectionData
96926>>>        String sValue
96926>>>        Integer iRetval
96926>>>
96926>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
96927>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
96928>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
96929>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
96930>>>        Move SQLConnection.sServer           to sConnectionData[5]
96931>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
96932>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
96933>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
96934>>>        Move SQLConnection.sUserID           to sConnectionData[9]
96935>>>
96935>>>        If (SQLConnection.sPassword <> "") Begin
96937>>>            Move MBR_Yes to iRetval
96938>>>            If (pbDFConnId(Self) = True) Begin
96940>>>                Set psUncryptedPw to SQLConnection.sPassword
96941>>>                Move "" to SQLConnection.sPassword
96942>>>            End
96942>>>>
96942>>>            Else Begin
96943>>>                Move SQLConnection.sPassword to sConnectionData[10]
96944>>>            End
96944>>>>
96944>>>        End
96944>>>>
96944>>>
96944>>>        Move SQLConnection.sSchema           to sConnectionData[11]
96945>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
96946>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
96947>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
96948>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
96949>>>
96949>>>        Function_Return sConnectionData
96950>>>    End_Function
96951>>>
96951>>>    Procedure Popup
96954>>>        tSQLConnection SQLIniFileConnection
96954>>>        tSQLConnection SQLIniFileConnection
96954>>>        String[] sConnectionData
96955>>>        String sDriverID
96955>>>        Integer iDbType
96955>>>
96955>>>        Get pSQLConnectionData to SQLIniFileConnection
96956>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
96957>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
96959>>>
96959>>>        Get SelectedDbType of oDbType_cf to iDbType
96960>>>        Get Value of oDriverID_cf to sDriverID
96961>>>        If (sDriverID = "") Begin
96963>>>            Move MSSQLDRV_ID to sDriverID
96964>>>        End      
96964>>>>
96964>>>        Send Refill_Comboform of oDriverID_cf iDbType
96965>>>        Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
96967>>>        
96967>>>        Set Password_State of oPassword_fm to True
96968>>>        Set Value of oLoginInfo_tb to ""
96969>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96970>>>        Forward Send Popup
96972>>>    End_Procedure
96973>>>
96973>>>    Procedure Page Integer iPageObject
96976>>>        String sText
96976>>>        Handle hWnd
96976>>>
96976>>>        Forward Send Page iPageObject
96978>>>
96978>>>        Set Icon to "SQLConnections.ico"
96979>>>
96979>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
96981>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96982>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96983>>>        End
96983>>>>
96983>>>    End_Procedure
96984>>>
96984>>>    // Put a status bar at the bottom of the panel, which makes
96984>>>    // status_help work and puts a gripper in the lower right corner.
96984>>>    Procedure End_Construct_Object
96987>>>        Integer iStyle iSize iOffset
96987>>>
96987>>>        Forward Send End_Construct_Object
96989>>>
96989>>>        Get Border_Style to iStyle
96990>>>        Move 8 to iOffset
96991>>>        If (iStyle = Border_Thick) Begin
96993>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96995>>>                Object oStatusBar is a cCJStatusBar
96997>>>                    Set phoDialogCommandbar to Self
96998>>>                    Object oStatusIdle is a cCJStatusBarPane
97000>>>                        Set piId to sbpIDIdlePane
97001>>>                        Set pbStyleStretch to True
97002>>>                    End_Object
97003>>>                End_Object
97004>>>            End_Object
97005>>>
97005>>>            Get Size to iSize
97006>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
97007>>>        End
97007>>>>
97007>>>    End_Procedure
97008>>>
97008>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
97009>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
97010>>>End_Object
97011>>>
97011>>>Procedure Activate_SQLMaintainConnections_dg tSQLConnection SQLConnectionData
97014>>>    Handle ho
97014>>>
97014>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
97015>>>    Set pSQLConnectionData      of ho to SQLConnectionData
97016>>>    Send Popup                  of ho
97017>>>End_Procedure
97018>        Use CompareDatabases.vw
Including file: CompareDatabases.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\CompareDatabases.vw)
97018>>>Use Dfclient.pkg
97018>>>Use Cursor.pkg
97018>>>Use Batchdd.pkg
97018>>>Use cButton.pkg
Including file: cButton.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButton.pkg)
97018>>>>>//****************************************************************************
97018>>>>>// $Module type: Package
97018>>>>>// $Module name: cButton.pkg
97018>>>>>//
97018>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
97018>>>>>// Copyright (c) 2012 RDC Tools International
97018>>>>>// E-mail      : support@rdctools.com
97018>>>>>// Web-site    : http://www.rdctools.com
97018>>>>>//
97018>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
97018>>>>>//
97018>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97018>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97018>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97018>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97018>>>>>// in the help folder for more details.
97018>>>>>//
97018>>>>>//****************************************************************************
97018>>>>>Use Windows.pkg
97018>>>>>Use Enclient.pkg
97018>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cTimer.pkg)
97018>>>>>>>// cTimer class
97018>>>>>>>//
97018>>>>>>>// This supercedes the DFTimer class. 
97018>>>>>>>// It is simpler and more flexible
97018>>>>>>>
97018>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dftimer.pkg)
97018>>>>>>>>>//************************************************************************
97018>>>>>>>>>//--- DFTimer   Timer package for DataFlex programs
97018>>>>>>>>>//
97018>>>>>>>>>// Copyright (c) 1983-2002 Data Access Corporation, Miami Florida,
97018>>>>>>>>>// All rights reserved.
97018>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
97018>>>>>>>>>//
97018>>>>>>>>>//************************************************************************
97018>>>>>>>>>//  Description:
97018>>>>>>>>>//      This package contains all components needed to implement timers
97018>>>>>>>>>//      in a DataFlex 4 program.
97018>>>>>>>>>//
97018>>>>>>>>>//
97018>>>>>>>>>//  Author: Eddy Kleinjan, Data Access Nederland
97018>>>>>>>>>//************************************************************************
97018>>>>>>>>>// 03/03/2001 EK  Fixed Timer_Active_State to check for valid windows
97018>>>>>>>>>//                handle before trying to set or kill a timer.
97018>>>>>>>>>//                Fixed Kill_All_Timers to check for valid windows
97018>>>>>>>>>//                handle before trying to kill a timer.
97018>>>>>>>>>//                The windows handle might not exist anymore when the
97018>>>>>>>>>//                program is being exited using Exit_Application.
97018>>>>>>>>>// 12/13/2001 JJT fixed Timer_Active_State to check for -1 (not 0). Fixed a
97018>>>>>>>>>//                a bug where set Timeout started inactive timers.
97018>>>>>>>>>//                Added code to force timer object to desktop
97018>>>>>>>>>//************************************************************************
97018>>>>>>>>>// CLASS DFTimer
97018>>>>>>>>>//
97018>>>>>>>>>// Usage:
97018>>>>>>>>>//    Object MyTimer is a DFTimer
97018>>>>>>>>>//
97018>>>>>>>>>//        Set Timeout to 2000                             // Default 1000
97018>>>>>>>>>//        Set Auto_Start_State to TRUE|FALSE              // Default TRUE
97018>>>>>>>>>//        Set Auto_Stop_State to TRUE|FALSE               // Default TRUE
97018>>>>>>>>>//        Set Timer_Message to MyMessage                  // Default 0
97018>>>>>>>>>//        Set Timer_Object to (MyObject(self))            // Default 0
97018>>>>>>>>>//        Set Timer_Active_State to TRUE|FALSE            // Default FALSE
97018>>>>>>>>>//
97018>>>>>>>>>//        // Augment when no Timer_Message
97018>>>>>>>>>//        Procedure OnTimer
97018>>>>>>>>>//            Send Info_Box "HEY, WAKE UP!"
97018>>>>>>>>>//        End_Procedure
97018>>>>>>>>>//
97018>>>>>>>>>//    End_Object
97018>>>>>>>>>//
97018>>>>>>>>>// DESCRIPTION
97018>>>>>>>>>//      Objects of this class can be used to trigger an event after a
97018>>>>>>>>>//      certain amount of time has passed. You can specify this time
97018>>>>>>>>>//      by setting the Timeout property of the object. This timeout
97018>>>>>>>>>//      is in miliseconds.
97018>>>>>>>>>//
97018>>>>>>>>>//      Whenever a timer event happens, it will notify the object by
97018>>>>>>>>>//      sending an OnTimer event. You can trap this event to do whatever
97018>>>>>>>>>//      you want the timer to do. By default this OnTimer event
97018>>>>>>>>>//      will send the Timer_Message to Timer_Object, when these have
97018>>>>>>>>>//      been specified.
97018>>>>>>>>>//
97018>>>>>>>>>//      By default, you have to activate a timer by setting its
97018>>>>>>>>>//      Timer_Active_State to TRUE. When the timer has been placed
97018>>>>>>>>>//      inside a user-interface object, it can also be activated
97018>>>>>>>>>//      automatically when this user-interface object is being
97018>>>>>>>>>//      activated. This only happes when it Auto_Start_State is TRUE,
97018>>>>>>>>>//      which is the default setting. In such a case, the timer will
97018>>>>>>>>>//      also automatically being stopped when the user-interface
97018>>>>>>>>>//      object is taken of the screen. This depends on the
97018>>>>>>>>>//      Auto_Stop_Timer state to happen.
97018>>>>>>>>>//
97018>>>>>>>>>//      When you need to set a new timeout value, you can do so
97018>>>>>>>>>//      even when the timer is active. It will adjust the timeout
97018>>>>>>>>>//      immediately.
97018>>>>>>>>>//
97018>>>>>>>>>//      Note that timer events depend on Windows for the delivery of
97018>>>>>>>>>//      the event. Since timer events get a low priority in Windows,
97018>>>>>>>>>//      it might put your program on hold when other programs are very
97018>>>>>>>>>//      busy. In such a case, you will only receive one timer event
97018>>>>>>>>>//      after the process stopped. There is no way, other than
97018>>>>>>>>>//      calculating it yourself, to determine how many time has passed
97018>>>>>>>>>//      or how many timer event should have happened since the last
97018>>>>>>>>>//      timer event or timer activation.
97018>>>>>>>>>//
97018>>>>>>>>>// PUBLIC INTERFACE
97018>>>>>>>>>//
97018>>>>>>>>>//    PROPERTIES
97018>>>>>>>>>//
97018>>>>>>>>>//    Auto_Start_State When TRUE (default) the timer will be activated
97018>>>>>>>>>//                     automatically when the object will be (virtually)
97018>>>>>>>>>//                     paged on the screen.
97018>>>>>>>>>//                     Example: When a timer object has been placed
97018>>>>>>>>>//                     inside a view, then the timer will be activated
97018>>>>>>>>>//                     when the view is activated.
97018>>>>>>>>>//
97018>>>>>>>>>//    Auto_Stop_State  When TRUE (default) the timer will be deactivated
97018>>>>>>>>>//                     automatically when the object will be (virtually)
97018>>>>>>>>>//                     taken off the screen.
97018>>>>>>>>>//
97018>>>>>>>>>//    Timeout          The timeout value for the timer to fire. The
97018>>>>>>>>>//                     timeout value must be set in miliseconds.
97018>>>>>>>>>//                     This property may be set even when the timer is
97018>>>>>>>>>//                     active. The new timeout value will be applied
97018>>>>>>>>>//                     immediately.
97018>>>>>>>>>//                     NOTE: The timeout set here is never precise. It
97018>>>>>>>>>//                     depends on Windows to deliver the message to our
97018>>>>>>>>>//                     application.
97018>>>>>>>>>//                     Default 1000.
97018>>>>>>>>>//
97018>>>>>>>>>//    Timer_Active_State
97018>>>>>>>>>//                     Set to TRUE to activate the timer, to FALSE to
97018>>>>>>>>>//                     deactivate the timer.
97018>>>>>>>>>//
97018>>>>>>>>>//
97018>>>>>>>>>//    Timer_Message    This property can be set to a messageID which has
97018>>>>>>>>>//                     to be sent whenever a timer event occurs. Default
97018>>>>>>>>>//                     this message will be send to the object itself
97018>>>>>>>>>//                     unless a Timer_Object as been specified.
97018>>>>>>>>>//
97018>>>>>>>>>//    Timer_Object     This property can be set to an objectID which has
97018>>>>>>>>>//                     to receive the Timer_Message whenever a timer
97018>>>>>>>>>//                     event occurs. This value has no meaning when
97018>>>>>>>>>//                     no Timer_Message has been set.
97018>>>>>>>>>//
97018>>>>>>>>>//    METHODS
97018>>>>>>>>>//
97018>>>>>>>>>//    OnTimer          This event will happen whenever the specified
97018>>>>>>>>>//                     amount of time has passed and the timer is
97018>>>>>>>>>//                     active. By default it sends the message in
97018>>>>>>>>>//                     the Timer_Message property to the object in
97018>>>>>>>>>//                     the Timer_Object when these have been specified.
97018>>>>>>>>>//                     When you don't need this, you can just override
97018>>>>>>>>>//                     the OnTimer event.
97018>>>>>>>>>//
97018>>>>>>>>>// PUBLIC INTERFACE
97018>>>>>>>>>//
97018>>>>>>>>>//    Page_Object      Has been augmented to auto_start the timer when
97018>>>>>>>>>//                     it becomes active as part or a user-interface
97018>>>>>>>>>//                     object.
97018>>>>>>>>>//
97018>>>>>>>>>//    Page_Delete      Has been augmented to auto_stop the timer when
97018>>>>>>>>>//                     it is deactivated as part or a user-interface
97018>>>>>>>>>//                     object.
97018>>>>>>>>>//
97018>>>>>>>>>//    Destroy_Object   Has been augmented to deactivate the timer.
97018>>>>>>>>>//
97018>>>>>>>>>Use LanguageText.pkg
97018>>>>>>>>>Use Windows.pkg
97018>>>>>>>>>Use WinUser.pkg
97018>>>>>>>>>
97018>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Integer
97019>>>>>>>>>
97019>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Integer hWnd ;    Integer idTimer ;    Returns Integer
97020>>>>>>>>>
97020>>>>>>>>>// This global integer holds the ID of the object
97020>>>>>>>>>// that manages all timers.
97020>>>>>>>>>Integer giTimerManager
97020>>>>>>>>>
97020>>>>>>>>>// This class is used to store the object IDs
97020>>>>>>>>>// of the active timer objects. It augments
97020>>>>>>>>>// the Destroy_Object procedure to notify
97020>>>>>>>>>// the DFTimerManager to kill all its active
97020>>>>>>>>>// timers.
97020>>>>>>>>>// NOTE: This class looks very much like the
97020>>>>>>>>>// Set class. I didn't want to use Set because
97020>>>>>>>>>// Remove_Element shifts items which I don't
97020>>>>>>>>>// want to happen because item numbers are used
97020>>>>>>>>>// as timerIDs.
97020>>>>>>>>>
97020>>>>>>>>>Class TimersArray is an Array
97021>>>>>>>>>
97021>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
97023>>>>>>>>>        Integer iMax
97023>>>>>>>>>        Integer iItem
97023>>>>>>>>>        Integer iValue
97023>>>>>>>>>        Get Item_count to iMax
97024>>>>>>>>>        Decrement iMax
97025>>>>>>>>>        For iItem from 1 to iMax
97031>>>>>>>>>>
97031>>>>>>>>>            Get Integer_Value item iItem to iValue
97032>>>>>>>>>            If iValue EQ iObj;                Function_Return iItem
97035>>>>>>>>>        Loop
97036>>>>>>>>>>
97036>>>>>>>>>        Function_Return -1
97037>>>>>>>>>    End_Function
97038>>>>>>>>>
97038>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
97040>>>>>>>>>        Integer iItem
97040>>>>>>>>>        Get Find_Object iObj to iItem
97041>>>>>>>>>        If iItem LT 0 Begin
97043>>>>>>>>>            Get Find_Object 0 to iItem
97044>>>>>>>>>            If iItem LT 0 ;                Get Item_Count to iItem
97047>>>>>>>>>        End
97047>>>>>>>>>>
97047>>>>>>>>>        Set Array_Value item iItem to iObj
97048>>>>>>>>>        Procedure_Return iItem
97049>>>>>>>>>    End_Procedure
97050>>>>>>>>>
97050>>>>>>>>>    Procedure Remove_Object Integer iObj
97052>>>>>>>>>        Integer iItem
97052>>>>>>>>>        Get Find_Object iObj to iItem
97053>>>>>>>>>        If iItem GT 0 ;            Set Array_Value item iItem to 0
97056>>>>>>>>>    End_Procedure
97057>>>>>>>>>
97057>>>>>>>>>    Procedure Destroy_Object
97059>>>>>>>>>        Delegate Send Kill_All_Timers
97061>>>>>>>>>        Forward Send Destroy_Object
97063>>>>>>>>>    End_Procedure
97064>>>>>>>>>
97064>>>>>>>>>End_Class // TimersArray
97065>>>>>>>>>
97065>>>>>>>>>// This class is the actual timer manager
97065>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
97065>>>>>>>>>// has been send. This message needs two arguments. The first
97065>>>>>>>>>// is the objectID of the object to receive the timer event,
97065>>>>>>>>>// and the second is state. The object which ID has been passed,
97065>>>>>>>>>// needs to have a Timeout property to return the timeout for the
97065>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
97065>>>>>>>>>// timer event occurs.
97065>>>>>>>>>// The objectID of the Object will be placed in an array which contains
97065>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
97065>>>>>>>>>// is the itemnumber of the object in the array.
97065>>>>>>>>>//
97065>>>>>>>>>Class DFTimerManager is a DfBaseControl
97066>>>>>>>>>
97066>>>>>>>>>    Procedure Construct_Object
97068>>>>>>>>>
97068>>>>>>>>>        Forward Send Construct_Object
97070>>>>>>>>>
97070>>>>>>>>>        Set Visible_State to FALSE
97071>>>>>>>>>
97071>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
97072>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
97073>>>>>>>>>
97073>>>>>>>>>        Object TimersArray is a TimersArray
97075>>>>>>>>>            Set Array_Value item 0 to -9999 // So we don't use item 0
97076>>>>>>>>>        End_Object
97077>>>>>>>>>
97077>>>>>>>>>        Move self to giTimerManager
97078>>>>>>>>>
97078>>>>>>>>>    End_Procedure
97079>>>>>>>>>
97079>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
97081>>>>>>>>>        Integer iTimerID
97081>>>>>>>>>        Integer iTimeout
97081>>>>>>>>>        Integer iResult
97081>>>>>>>>>        Integer iSet
97081>>>>>>>>>        Dword   nResult
97081>>>>>>>>>        Handle  hWnd
97081>>>>>>>>>
97081>>>>>>>>>        // Get the handle of this object
97081>>>>>>>>>        Get Window_Handle to hWnd
97082>>>>>>>>>        If (Not(hWnd)) Begin
97084>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
97085>>>>>>>>>>
97085>>>>>>>>>            Procedure_Return
97086>>>>>>>>>        End
97086>>>>>>>>>>
97086>>>>>>>>>
97086>>>>>>>>>        // Test if handle is valid. If not, we leave.
97086>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
97089>>>>>>>>>
97089>>>>>>>>>        Move (TimersArray(self)) to iSet
97090>>>>>>>>>
97090>>>>>>>>>        If (iSet) Begin
97092>>>>>>>>>
97092>>>>>>>>>            // Let's create or modify a timer
97092>>>>>>>>>            If iState Begin
97094>>>>>>>>>
97094>>>>>>>>>                // Get the exising to new TimerID
97094>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
97095>>>>>>>>>
97095>>>>>>>>>                // Set/Modify the timer
97095>>>>>>>>>                Get Timeout of iObj to iTimeout
97096>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
97097>>>>>>>>>                If Not iResult Begin
97099>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
97100>>>>>>>>>>
97100>>>>>>>>>                    Procedure_Return
97101>>>>>>>>>                End
97101>>>>>>>>>>
97101>>>>>>>>>
97101>>>>>>>>>            End
97101>>>>>>>>>>
97101>>>>>>>>>
97101>>>>>>>>>            // Let's kill an existing timer
97101>>>>>>>>>            Else Begin
97102>>>>>>>>>
97102>>>>>>>>>                // Look up the object in the set
97102>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
97103>>>>>>>>>
97103>>>>>>>>>                If iTimerID EQ -1 ;                    Procedure_Return
97106>>>>>>>>>
97106>>>>>>>>>                // Kill the timer
97106>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
97107>>>>>>>>>                If Not iResult Begin
97109>>>>>>>>>                    Move (GetLastError()) to nResult
97110>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * string(nResult) - "!")
97111>>>>>>>>>>
97111>>>>>>>>>                    Procedure_Return
97112>>>>>>>>>                End
97112>>>>>>>>>>
97112>>>>>>>>>
97112>>>>>>>>>                // Remove the objectID
97112>>>>>>>>>                Send Remove_Object to iSet iObj
97113>>>>>>>>>            End
97113>>>>>>>>>>
97113>>>>>>>>>        End
97113>>>>>>>>>>
97113>>>>>>>>>    End_Procedure
97114>>>>>>>>>
97114>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
97116>>>>>>>>>        Integer iResult
97116>>>>>>>>>        Get Find_Object of (TimersArray(self)) iObj to iResult
97117>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
97118>>>>>>>>>    End_Function
97119>>>>>>>>>
97119>>>>>>>>>    // Will be called by the Set when it is being destroyed.
97119>>>>>>>>>    Procedure Kill_All_Timers
97121>>>>>>>>>        Integer iMax
97121>>>>>>>>>        Integer iSet
97121>>>>>>>>>        Integer iItem
97121>>>>>>>>>        Integer iObj
97121>>>>>>>>>        Integer iResult
97121>>>>>>>>>        Handle  hWnd
97121>>>>>>>>>
97121>>>>>>>>>        // Get the handle of this object
97121>>>>>>>>>        Get Window_Handle to hWnd
97122>>>>>>>>>        If (Not(hWnd)) Begin
97124>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
97125>>>>>>>>>>
97125>>>>>>>>>            Procedure_Return
97126>>>>>>>>>        End
97126>>>>>>>>>>
97126>>>>>>>>>
97126>>>>>>>>>        // If the window handle is no longer valid, we
97126>>>>>>>>>        // leave this procedure. This can happen when the
97126>>>>>>>>>        // program is begin aborted using Exit_Application
97126>>>>>>>>>        If (Not(IsWindow(hWnd))) ;            Procedure_Return
97129>>>>>>>>>
97129>>>>>>>>>        // Scan the set and kill all known timers
97129>>>>>>>>>        Move (TimersArray(self)) to iSet
97130>>>>>>>>>        If (iSet) Begin
97132>>>>>>>>>            Get Item_Count of iSet to iMax
97133>>>>>>>>>            Decrement iMax
97134>>>>>>>>>            For iItem From 1 to iMax
97140>>>>>>>>>>
97140>>>>>>>>>                Get Integer_Value of iSet item iItem to iObj
97141>>>>>>>>>                If iObj Begin
97143>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
97144>>>>>>>>>                    Set Array_Value of iSet item iItem to 0
97145>>>>>>>>>                End
97145>>>>>>>>>>
97145>>>>>>>>>            Loop
97146>>>>>>>>>>
97146>>>>>>>>>        End
97146>>>>>>>>>>
97146>>>>>>>>>
97146>>>>>>>>>    End_Procedure
97147>>>>>>>>>
97147>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
97149>>>>>>>>>        Integer iObj
97149>>>>>>>>>        Get Integer_Value of (TimersArray(self)) item wParam to iObj
97150>>>>>>>>>        If Not iObj Begin
97152>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
97153>>>>>>>>>>
97153>>>>>>>>>            Procedure_Return
97154>>>>>>>>>        End
97154>>>>>>>>>>
97154>>>>>>>>>        Send OnTimer to iObj wParam lParam
97155>>>>>>>>>    End_Procedure
97156>>>>>>>>>
97156>>>>>>>>>    Procedure Destroy_Object
97158>>>>>>>>>        Send Kill_All_Timers
97159>>>>>>>>>        Forward Send Destroy_Object
97161>>>>>>>>>        Move 0 to giTimerManager
97162>>>>>>>>>    End_Procedure
97163>>>>>>>>>
97163>>>>>>>>>End_Class // DFTimerManger
97164>>>>>>>>>
97164>>>>>>>>>
97164>>>>>>>>>
97164>>>>>>>>>
97164>>>>>>>>>// This class acts as a container for the
97164>>>>>>>>>// timer manager object. This is needed because
97164>>>>>>>>>// A DFTimerManager object created directly at the
97164>>>>>>>>>// desktop doesn't have a Window_Handle which we
97164>>>>>>>>>// need to create a Windoows timer. By placing
97164>>>>>>>>>// this non-visual container around the timer
97164>>>>>>>>>// manager, it does get a Window_Handle.
97164>>>>>>>>>// The procedure End_Construct_Object has been
97164>>>>>>>>>// augmented to create a window and also
97164>>>>>>>>>// automatically page all children, which will
97164>>>>>>>>>// be the timer manager.
97164>>>>>>>>>//
97164>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
97165>>>>>>>>>
97165>>>>>>>>>    Procedure Construct_Object
97167>>>>>>>>>        Forward Send Construct_Object
97169>>>>>>>>>        Set Visible_State to FALSE
97170>>>>>>>>>        Object DFTimerManager is a DFTimerManager
97172>>>>>>>>>        End_Object
97173>>>>>>>>>    End_Procedure
97174>>>>>>>>>
97174>>>>>>>>>    Procedure End_Construct_Object
97176>>>>>>>>>        Forward Send End_Construct_Object
97178>>>>>>>>>        Send Page_Object TRUE
97179>>>>>>>>>        Broadcast Send Page_Object TRUE
97181>>>>>>>>>    End_Procedure
97182>>>>>>>>>
97182>>>>>>>>>End_Class
97183>>>>>>>>>
97183>>>>>>>>>// This is the class the user uses to create DFTimer objects
97183>>>>>>>>>
97183>>>>>>>>>
97183>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
97183>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
97183>>>>>>>>>Class DFTimer is a Textbox
97184>>>>>>>>>
97184>>>>>>>>>    Procedure Construct_Object
97186>>>>>>>>>        Forward Send Construct_Object
97188>>>>>>>>>
97188>>>>>>>>>        // Make sure this object never appears
97188>>>>>>>>>        Set Visible_State to FALSE
97189>>>>>>>>>
97189>>>>>>>>>        Property Integer Private.Timeout    1000
97190>>>>>>>>>
97190>>>>>>>>>        Property Integer Timer_Message      0
97191>>>>>>>>>        Property Integer Timer_Object       0
97192>>>>>>>>>        Property Integer Auto_Start_State   True
97193>>>>>>>>>        Property Integer Auto_Stop_State    True
97194>>>>>>>>>    End_Procedure
97195>>>>>>>>>
97195>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
97197>>>>>>>>>        Integer iObj
97197>>>>>>>>>        Move self to iObj
97198>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
97201>>>>>>>>>    End_Procedure
97202>>>>>>>>>
97202>>>>>>>>>    Function Timer_Active_State Returns Integer
97204>>>>>>>>>        Integer iState
97204>>>>>>>>>        Integer iObj
97204>>>>>>>>>        Move self to iObj
97205>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
97208>>>>>>>>>        Function_Return iState
97209>>>>>>>>>    End_Function
97210>>>>>>>>>
97210>>>>>>>>>    Procedure Set Timeout Integer iTimeout
97212>>>>>>>>>        Integer iActive
97212>>>>>>>>>        Set Private.Timeout to iTimeout
97213>>>>>>>>>        Get Timer_Active_State to iActive
97214>>>>>>>>>        If iActive ;            Set Timer_Active_State to TRUE
97217>>>>>>>>>    End_Procedure
97218>>>>>>>>>
97218>>>>>>>>>    Function Timeout Returns Integer
97220>>>>>>>>>        Integer iTimeout
97220>>>>>>>>>        Get Private.Timeout to iTimeout
97221>>>>>>>>>        Function_Return iTimeout
97222>>>>>>>>>    End_Function
97223>>>>>>>>>
97223>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
97225>>>>>>>>>        Integer iMsg
97225>>>>>>>>>        Integer iObj
97225>>>>>>>>>        Get Timer_Message to iMsg
97226>>>>>>>>>        If (iMsg) Begin
97228>>>>>>>>>            Get Timer_Object  to iObj
97229>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
97232>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
97234>>>>>>>>>        End
97234>>>>>>>>>>
97234>>>>>>>>>    End_Procedure
97235>>>>>>>>>
97235>>>>>>>>>    // Augmented to Auto_Start a timer
97235>>>>>>>>>    //
97235>>>>>>>>>    Procedure Page_Object Integer iState
97237>>>>>>>>>        Forward Send Page_Object iState
97239>>>>>>>>>        If (iState AND Auto_Start_State(self)) ;            Set Timer_Active_State to TRUE
97242>>>>>>>>>    End_Procedure
97243>>>>>>>>>
97243>>>>>>>>>    // Augmented to Auto_Stop a timer
97243>>>>>>>>>    //
97243>>>>>>>>>    Procedure Page_Delete
97245>>>>>>>>>        If (Auto_Stop_State(self)) ;            Set Timer_Active_State to FALSE
97248>>>>>>>>>        Forward Send Page_Delete
97250>>>>>>>>>    End_Procedure
97251>>>>>>>>>
97251>>>>>>>>>    // Augmented to stop the timer
97251>>>>>>>>>    //
97251>>>>>>>>>    Procedure Destroy_Object
97253>>>>>>>>>        Set Timer_Active_State to FALSE
97254>>>>>>>>>        Forward Send Destroy_Object
97256>>>>>>>>>    End_Procedure
97257>>>>>>>>>
97257>>>>>>>>>End_Class // DFTimer
97258>>>>>>>>>
97258>>>>>>>>>//
97258>>>>>>>>>// This was moved into a method so it can be reliable created
97258>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
97258>>>>>>>>>//
97258>>>>>>>>>Procedure CreateDfTimerManagerPanel FOR cDesktop
97260>>>>>>>>>    // Create the Desktop Timer Manager Object.
97260>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
97262>>>>>>>>>    End_Object
97263>>>>>>>>>End_Procedure
97264>>>>>>>>>
97264>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
97265>>>>>>>>>
97265>>>>>>>
97265>>>>>>>Class cTimer is a cObject
97266>>>>>>>
97266>>>>>>>    Procedure Construct_Object
97268>>>>>>>        Forward Send Construct_Object
97270>>>>>>>        Property Integer piPrivate_Timeout 1000
97271>>>>>>>    End_Procedure
97272>>>>>>>
97272>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
97274>>>>>>>        If giTimerManager Begin
97276>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
97277>>>>>>>        End
97277>>>>>>>>
97277>>>>>>>    End_Procedure
97278>>>>>>>
97278>>>>>>>    Function pbEnabled Returns Boolean
97280>>>>>>>        Boolean bEnabled
97280>>>>>>>        If giTimerManager Begin
97282>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
97283>>>>>>>        End
97283>>>>>>>>
97283>>>>>>>        Function_Return bEnabled
97284>>>>>>>    End_Function
97285>>>>>>>
97285>>>>>>>    Procedure Set piTimeout Integer iTimeout
97287>>>>>>>        Boolean bEnabled
97287>>>>>>>        Set piPrivate_Timeout to iTimeout
97288>>>>>>>        Get pbEnabled to bEnabled
97289>>>>>>>        If bEnabled Begin
97291>>>>>>>            Set pbEnabled to True
97292>>>>>>>        End
97292>>>>>>>>
97292>>>>>>>    End_Procedure
97293>>>>>>>
97293>>>>>>>    Function piTimeout Returns Integer
97295>>>>>>>        Integer iTimeout
97295>>>>>>>        Get piPrivate_Timeout to iTimeout
97296>>>>>>>        Function_Return iTimeout
97297>>>>>>>    End_Function
97298>>>>>>>
97298>>>>>>>    Procedure OnTimer
97300>>>>>>>    End_Procedure
97301>>>>>>>    
97301>>>>>>>    // this is needed by the timer manager 
97301>>>>>>>    Function Timeout Returns Integer
97303>>>>>>>        Integer iTimeout
97303>>>>>>>        Get piPrivate_Timeout to iTimeout
97304>>>>>>>        Function_Return iTimeout
97305>>>>>>>    End_Function
97306>>>>>>>
97306>>>>>>>    Procedure Destroy_Object
97308>>>>>>>        Set pbEnabled to False
97309>>>>>>>        Forward Send Destroy_Object
97311>>>>>>>    End_Procedure
97312>>>>>>>
97312>>>>>>>End_Class
97313>>>>>Use errornum.inc
97313>>>>>
97313>>>>>Class cButtonIdleHandler is a cTimer
97314>>>>>    Procedure Construct_Object
97316>>>>>        Forward Send Construct_Object  
97318>>>>>        
97318>>>>>        Set piTimeout to 1000   // Wait 1000 milliseconds (1 second) 
97319>>>>>        Set pbEnabled to True
97320>>>>>    End_Procedure
97321>>>>>
97321>>>>>    Procedure OnTimer
97323>>>>>        Delegate Send DoEnable
97325>>>>>    End_Procedure
97326>>>>>
97326>>>>>End_Class
97327>>>>>
97327>>>>>Class cButton is a Button
97328>>>>>
97328>>>>>    Procedure Construct_Object
97330>>>>>        Forward Send Construct_Object
97332>>>>>
97332>>>>>//#IF (Required_FMAC_Version < 17)
97332>>>>>//        Set Typeface to "Segoe UI"
97332>>>>>//        Set FontSize to 18 0
97332>>>>>//#ENDIF
97332>>>>>
97332>>>>>        Property Boolean pbAutoEnable False
97333>>>>>
97333>>>>>        Object oButtonIdleHandler is a cButtonIdleHandler
97335>>>>>        End_Object
97336>>>>>    End_Procedure
97337>>>>>
97337>>>>>    Procedure End_Construct_Object
97339>>>>>        String sTooltip sStatus_Help
97339>>>>>
97339>>>>>        Forward Send End_Construct_Object
97341>>>>>
97341>>>>>        Get psToolTip   to sTooltip
97342>>>>>        Get Status_Help to sStatus_Help
97343>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97345>>>>>            Set psToolTip to sStatus_Help
97346>>>>>        End
97346>>>>>>
97346>>>>>        Set pbEnabled of oButtonIdleHandler to (pbAutoEnable(Self))
97347>>>>>    End_Procedure
97348>>>>>
97348>>>>>    Procedure DoEnable
97350>>>>>        Boolean bAutoEnable bHasRecord
97350>>>>>        Handle hoDD
97350>>>>>        Get pbAutoEnable to bAutoEnable
97351>>>>>        If (bAutoEnable = False) Begin
97353>>>>>            Procedure_Return
97354>>>>>        End      
97354>>>>>>
97354>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
97355>>>>>        Move (Main_DD(Self)) to hoDD
97356>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
97357>>>>>        If (hoDD <> 0) Begin
97359>>>>>            Get HasRecord of hoDD to bHasRecord
97360>>>>>        End
97360>>>>>>
97360>>>>>        Set Enabled_State to (bHasRecord = True)
97361>>>>>    End_Procedure
97362>>>>>
97362>>>>>    // Enable the idle handler timer when the button is activated
97362>>>>>    Procedure Activating
97364>>>>>       Forward Send Activating
97366>>>>>       Set pbEnabled of oButtonIdleHandler to True
97367>>>>>    End_Procedure
97368>>>>>
97368>>>>>    // Disable the idle handler when the button is deactivated
97368>>>>>    Procedure Deactivating
97370>>>>>       Set pbEnabled of oButtonIdleHandler to False
97371>>>>>       Forward Send Deactivating
97373>>>>>    End_Procedure
97374>>>>>
97374>>>>>End_Class
97375>>>Use cDbUpdateFunctionLibrary.pkg
97375>>>Use DUFStatusPanel.pkg
97375>>>Use seq_chnl.pkg
97375>>>Use vWin32fh.pkg
97375>>>
97375>>>Define CS_ReportFileName           for "DUFCompareReport"
97375>>>Define CS_ReportFileNameExtenstion for ".txt"
97375>>>Define CS_ReportDifferenceNote     for "(*)"
97375>>>Define CS_ReportFieldNotFound      for "Field doesn't exist!"
97375>>>Define CS_ReportHeaderUnderWrite   for "===================================================================================="
97375>>>
97375>>>Define CI_ReportColumn1            for 15
97375>>>Define CI_ReportColumn2            for 50
97375>>>Define CI_ReportColunn3            for 65
97375>>>Define CI_ReportColunn4            for 80
97375>>>
97375>>>Activate_View Activate_oCompareDatabases_vw for oCompareDatabases_vw
97385>>>>
97385>>>Object oCompareDatabases_vw is a dbView
97387>>>    Set Size to 216 521
97388>>>    Set Label to "Compare Databases"
97389>>>    Set piMinSize to 89 211
97390>>>    Set Location to 2 2
97391>>>    Set Border_Style To Border_Thick
97392>>>    Set pbAutoActivate to True
97393>>>    Set Icon to "DbCompare.ico"
97394>>>    
97394>>>    Property String psOrgOpenPath
97396>>>    
97396>>>    // Set psOrgOpenPath at startup
97396>>>    Procedure StartUp
97399>>>        String sOrgOpenPath sDataPath
97399>>>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
97402>>>        // First remove the current Data folder path
97402>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sOrgOpenPath 1 to sDataPath
97403>>>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
97404>>>        If (Left(sOrgOpenPath, 2) = "\;") Begin
97406>>>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
97407>>>        End
97407>>>>
97407>>>        Set psOrgOpenPath to sOrgOpenPath
97408>>>    End_Procedure                        
97409>>>
97409>>>    Object oInfo_tb is a TextBox
97411>>>        Set Auto_Size_State to False
97412>>>        Set Size to 25 424
97413>>>        Set Location to 12 19
97414>>>        Set Label to "This will compare two Filelist.cfg files and write the differences as a text report. It will try to find a DUF SQLConnections.ini in the Programs folder - or if not found a DAW DFConnId.ini file in the Data folder, to be able to open SQL tables. After the compare has been run, click the 'Tag Filelist Diff' button to tag all tables with differences on the 'Code Generator' view."
97415>>>        Set Justification_Mode to JMode_Left
97416>>>        Set peAnchors to anTopLeftRight
97417>>>    End_Object
97418>>>    Send StartUp
97419>>>    
97419>>>    Object oFilelistPathFrom_fm is a Form
97421>>>        Set Size to 13 486
97422>>>        Set Location to 55 19
97423>>>        Set Label to "Please select the FROM database Filelist.cfg (F4)"
97424>>>        Set Label_Col_Offset to 0
97425>>>        Set Label_Row_Offset to 1
97426>>>        Set Label_Justification_Mode to JMode_Top
97427>>>        Set Prompt_Button_Mode to PB_PromptOn
97428>>>        Set peAnchors to anTopLeftRight 
97429>>>        Set Prompt_Object to Self
97430>>>        
97430>>>        Procedure Prompt
97433>>>            String sFileName sPath sFileMask sRetval
97433>>>
97433>>>            Get Value to sFileName
97434>>>            Get ParseFolderName sFileName to sPath
97435>>>            Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
97436>>>            Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
97437>>>            If (sRetval <> "") Begin
97439>>>                Set Value to sRetval
97440>>>            End
97440>>>>
97440>>>        End_Procedure 
97441>>>        
97441>>>        Procedure OnChange
97444>>>            String sValue
97444>>>            Get Value to sValue
97445>>>            Set psFilelistFrom of ghoApplication to sValue
97446>>>        End_Procedure
97447>>>
97447>>>        On_Key Key_Ctrl+Key_W Send None
97448>>>        On_Key Key_Ctrl+Key_Q Send None
97449>>>    End_Object
97450>>>
97450>>>    Object oFilelistPathTo_fm is a Form
97452>>>        Set Size to 13 486
97453>>>        Set Location to 83 19
97454>>>        Set Label to "Please select the TO database Filelist.cfg (F4)"
97455>>>        Set Label_Col_Offset to 0
97456>>>        Set Label_Row_Offset to 1
97457>>>        Set Label_Justification_Mode to JMode_Top
97458>>>        Set Prompt_Button_Mode to PB_PromptOn
97459>>>        Set peAnchors to anTopLeftRight 
97460>>>        Set Prompt_Object to Self
97461>>>        
97461>>>        Procedure Prompt
97464>>>            String sFileName sPath sFileMask sRetval
97464>>>
97464>>>            Get Value to sFileName
97465>>>            Get ParseFolderName sFileName to sPath
97466>>>            Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
97467>>>            Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
97468>>>            If (sRetval <> "") Begin
97470>>>                Set Value to sRetval
97471>>>            End
97471>>>>
97471>>>        End_Procedure  
97472>>>        
97472>>>        Procedure OnChange
97475>>>            String sPath sReportName sToday
97475>>>            Date dToday
97475>>>            
97475>>>            Sysdate dToday
97476>>>            Move (Replaces("/", dToday, "-")) to sToday
97477>>>            Get Value to sPath
97478>>>            Get ParseFolderName sPath to sPath
97479>>>            Get vFolderFormat   sPath to sPath
97480>>>            Move (sPath + CS_ReportFileName + String(sToday) + CS_ReportFileNameExtenstion) to sReportName
97481>>>            Set Value of oReportFileName_fm to sReportName
97482>>>        End_Procedure
97483>>>
97483>>>        On_Key Key_Ctrl+Key_W Send None
97484>>>        On_Key Key_Ctrl+Key_Q Send None
97485>>>    End_Object
97486>>>
97486>>>//    Object oCompareType_rg is a RadioGroup
97486>>>//        Set Location to 75 19
97486>>>//        Set Size to 33 486
97486>>>//        Set Label to "Compare Type"
97486>>>//        Set peAnchors to anTopLeftRight
97486>>>//    
97486>>>//        Object oRadio1 is a Radio
97486>>>//            Set Auto_Size_State to False
97486>>>//            Set Label to "Write Comparison Report"
97486>>>//            Set Size to 10 100
97486>>>//            Set Location to 14 10
97486>>>//        End_Object
97486>>>//    
97486>>>//        Object oRadio2 is a Radio
97486>>>//            Set Auto_Size_State to False
97486>>>//            Set Label to "Tag Tables in Filelist.cfg containing differences (for Code Generation)"
97486>>>//            Set Size to 10 260
97486>>>//            Set Location to 14 136
97486>>>//        End_Object
97486>>>//    
97486>>>//        Procedure Notify_Select_State Integer iToItem Integer iFromItem
97486>>>//            Forward Send Notify_Select_State iToItem iFromItem
97486>>>//            Set Enabled_State of oReportFileName_fm     to (iToItem = 0) 
97486>>>//            Set Enabled_State of oCompareProperties_grp to (iToItem = 0) 
97486>>>//            Set pbTagFileNames of ghoApplication to (iToItem = 1) 
97486>>>//            Set Enabled_State of oOK_Btn to (iToItem = 0)
97486>>>//        End_Procedure
97486>>>//
97486>>>//    End_Object
97486>>>
97486>>>    Object oCompareProperties_grp is a Group
97488>>>        Set Size to 45 486
97489>>>        Set Location to 112 19
97490>>>        Set Label to "Compare Properties"
97491>>>
97491>>>        Object oCompareDate_DataTime_cb is a CheckBox
97493>>>            Set Auto_Size_State to False
97494>>>            Set Size to 9 123
97495>>>            Set Location to 14 10
97496>>>            Set Label to "Check Date/DataTime difference"
97497>>>            Set Checked_State to False
97498>>>            Set psToolTip to "Check Date to DateTime column differences"
97499>>>        End_Object
97500>>>
97500>>>        Object oCompareIndexAscending_cb is a CheckBox
97502>>>            Set Auto_Size_State to False
97503>>>            Set Size to 9 134
97504>>>            Set Location to 14 137
97505>>>            Set Label to "Check Index Ascending/Descending"
97506>>>            Set Checked_State to False
97507>>>            Set psToolTip to "Compare if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
97508>>>        End_Object
97509>>>
97509>>>        Object oCompareIndexUppercase_cb is a CheckBox
97511>>>            Set Auto_Size_State to False
97512>>>            Set Size to 9 117
97513>>>            Set Location to 14 276
97514>>>            Set Label to "Check Index Lower/Uppercase"
97515>>>            Set Checked_State to False
97516>>>            Set psToolTip to "Compare if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
97517>>>        End_Object
97518>>>
97518>>>        Object oIgnoreFilelistUppercase_cb is a CheckBox
97520>>>            Set Auto_Size_State to False
97521>>>            Set Size to 9 210
97522>>>            Set Location to 27 10
97523>>>            Set Label to "Ignore Filelist Entries Uppercase/Lowercase"
97524>>>            Set Checked_State to True
97525>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
97526>>>        End_Object
97527>>>
97527>>>    End_Object
97528>>>
97528>>>    Object oReportFileName_fm is a Form
97530>>>        Set Size to 13 486
97531>>>        Set Location to 176 19
97532>>>        Set Label to "Report File Name"
97533>>>        Set Label_Col_Offset to 0
97534>>>        Set Label_Row_Offset to 1
97535>>>        Set Label_Justification_Mode to JMode_Top
97536>>>        Set Prompt_Button_Mode to PB_PromptOn
97537>>>        Set peAnchors to anTopLeftRight 
97538>>>        Set Prompt_Object to Self
97539>>>        
97539>>>        Procedure Prompt
97542>>>            String sFileName sPath sFileMask sRetval
97542>>>
97542>>>            Get Value to sFileName
97543>>>            Get ParseFolderName sFileName to sPath
97544>>>            Move "Text files (*.txt)|*.txt" to sFileMask
97545>>>            Get vSelect_File sFileMask "Please select a text file for the report" sPath to sRetval
97546>>>            If (sRetval <> "") Begin
97548>>>                Set Value to sRetval
97549>>>            End
97549>>>>
97549>>>        End_Procedure
97550>>>
97550>>>        On_Key Key_Ctrl+Key_W Send None
97551>>>        On_Key Key_Ctrl+Key_Q Send None
97552>>>    End_Object
97553>>>
97553>>>    Function ChangeFilelistPathing String sFileList Returns Boolean
97556>>>        String sPath sSQLConnectionsIniName sDataPath sDriverID sServer sOrgOpenPath
97556>>>        Boolean bExists 
97556>>>        Handle hoDbUpdateHandler hoSQLConnectionHandler hoSQLConnectionIniFile hTable
97556>>>        tSQLConnection SQLConnection 
97556>>>        tSQLConnection SQLConnection 
97556>>>        Number nVersionNumber                
97556>>>        Integer iRetval
97556>>>        
97556>>>        Move False to Err
97557>>>        Get vFilePathExists sFileList to bExists
97558>>>        If (bExists = False) Begin
97560>>>            Function_Return False
97561>>>        End  
97561>>>>
97561>>>        
97561>>>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID      
97562>>>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer
97563>>>        Close DF_ALL
97564>>>        Logout sDriverID sServer
97565>>>        
97565>>>        Set psFileList of (phoWorkspace(ghoApplication))   to sFileList
97566>>>        Set_Attribute DF_FILELIST_NAME                     to sFileList 
97569>>>        Get ParseFolderName sFileList                      to sDataPath
97570>>>        If (Right(sDataPath, 1) = "\") Begin
97572>>>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
97573>>>        End
97573>>>>
97573>>>        Set psDataPath of (phoWorkspace(ghoApplication))   to sDataPath 
97574>>>        
97574>>>        // Temporarily "redirect" the Open path to the current Data folder
97574>>>        Get psOrgOpenPath to sOrgOpenPath
97575>>>        Set_Attribute DF_OPEN_PATH to (sDataPath + ";" + sOrgOpenPath)
97578>>>
97578>>>        Get vFolderFormat sDataPath to sPath            
97579>>>        // Note: We delete all cache files (*.cch) before
97579>>>        // attempting to open any tables as a precausion, in case the table has been changed at the SQL end:
97579>>>        Get vDeleteFile (sPath + "*.cch") to iRetval
97580>>>
97580>>>        Get vParentPath sDataPath to sPath  
97581>>>        Get vFolderFormat sPath   to sPath                           
97582>>>        Move (sPath + "Programs") to sPath
97583>>>        Get vFolderFormat sPath   to sPath                           
97584>>>        Move CS_SQLIniFileName to sSQLConnectionsIniName
97585>>>        Get vFilePathExists (sPath + sSQLConnectionsIniName) to bExists
97586>>>        If (bExists = False) Begin
97588>>>            Get YesNo_Box ("Couldn't find the Programs\SQLConnections.ini file. If this is an SQL database this program won't be able to open any table. Continue?") to iRetval
97589>>>            If (iRetval <> MBR_Yes) Begin
97591>>>                Function_Return False
97592>>>            End
97592>>>>
97592>>>        End
97592>>>>
97592>>>        Else Begin
97593>>>            Get phoDbUpdateHandler of ghoApplication to hoDbUpdateHandler
97594>>>            Get phoSQLConnectionHandler of hoDbUpdateHandler to hoSQLConnectionHandler
97595>>>            Get phoSQLConnectionIniFile of hoSQLConnectionHandler to hoSQLConnectionIniFile
97596>>>            Set psIniFilePath of hoSQLConnectionIniFile to sPath
97597>>>            Set psIniFileName of hoSQLConnectionIniFile to sSQLConnectionsIniName
97598>>>
97598>>>            Get SetupSQLConnection of hoSQLConnectionHandler True to SQLConnection
97599>>>            Set pSQLConnection     of hoSQLConnectionHandler to SQLConnection 
97600>>>        End                      
97600>>>>
97600>>>        Function_Return (Err = False)
97601>>>    End_Function  
97602>>>    
97602>>>    Procedure Reset_DF_OPEN_PATH
97605>>>        String sOrgOpenpath
97605>>>        Get psOrgOpenPath to sOrgOpenpath
97606>>>        Set_Attribute DF_OPEN_PATH to sOrgOpenPath
97609>>>    End_Procedure
97610>>>
97610>>>    Procedure StartComparing
97613>>>        String sFilelistFrom sFilelistTo 
97613>>>        Integer[] iaDifferences    
97614>>>        Integer iSize iRetval
97614>>>        Boolean bFromExists bToExists 
97614>>>        tAPITableBooleans CompareTableBooleans
97614>>>        tAPITableBooleans CompareTableBooleans
97614>>>        
97614>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
97615>>>        Get vFilePathExists sFilelistFrom to bFromExists
97616>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
97617>>>        Get vFilePathExists sFilelistTo   to bToExists  
97618>>>        
97618>>>        If (bFromExists = False or bToExists = False) Begin
97620>>>            Send Info_Box "You first need to select a 'From' and a 'To' Filelist.cfg."
97621>>>            Procedure_Return
97622>>>        End
97622>>>>
97622>>>
97622>>>//        Get pbTagFileNames of ghoApplication to bTagFileNames
97622>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareTableBooleans.bCompareDate_DateTime
97623>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareTableBooleans.bCompareIndexAscending
97624>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareTableBooleans.bCompareIndexUppercase
97625>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareTableBooleans.bCompareFilelistUppercase
97626>>>        
97626>>>        Get CompareDatabases sFilelistFrom sFilelistTo CompareTableBooleans to iaDifferences
97627>>>        Set piaDifferences of ghoApplication to iaDifferences
97628>>>
97628>>>//        If (bTagFileNames = False) Begin        
97628>>>        Send Stop_StatusPanel of ghoStatusPanel
97629>>>        Move (SizeOfArray(iaDifferences)) to iSize
97630>>>        If (iSize > 0) Begin
97632>>>            Get YesNo_Box ("Ready!" * String(iSize) * "Differences found. View the report now?") to iRetval
97633>>>            If (iRetval = MBR_Yes) Begin
97635>>>                Send KeyAction of oViewReport_Btn
97636>>>            End
97636>>>>
97636>>>        End 
97636>>>>
97636>>>        Else If (iaDifferences[0] <> -1) Begin
97639>>>            Send Info_Box "No differences found. The two databases are identical."
97640>>>        End
97640>>>>
97640>>>        Else If (iaDifferences[0] = -1) Begin
97643>>>            Send Info_Box "Process interrupted."
97644>>>        End
97644>>>>
97644>>>//        End
97644>>>//        Else Begin
97644>>>//            Send Close_Panel
97644>>>//        End
97644>>>    End_Procedure
97645>>>
97645>>>    Function CompareDatabases String sFilelistFrom String sFilelistTo tAPITableBooleans CompareTableBooleans Returns Integer[]
97648>>>        Integer iSize iSizeFrom iSizeTo iCount iItemFrom iItemTo iNoOfTables
97648>>>        Boolean bIsSame bFilelistError bIsAlias bUserCancel bOK
97648>>>        Handle hTable hTableFrom hTableTo
97648>>>        String sLogicalName 
97648>>>        tAPITable[] aFromStructure    aToStructure
97648>>>        tAPITable[] aFromStructure    aToStructure
97650>>>        Integer[] iaDifferences iaDifferencesEmpty
97652>>>        
97652>>>        Set Message_Text of ghoStatusPanel to ""
97653>>>        // Set up the pathing correctly for the 'FROM' Filelist.cfg so we can open tables:
97653>>>        Get ChangeFilelistPathing sFilelistFrom to bOK
97654>>>        If (bOK = False) Begin 
97656>>>            Move -1 to iaDifferences[0]
97657>>>            Function_Return iaDifferencesEmpty
97658>>>        End
97658>>>>
97658>>>        Set pbVisible of ghoProgressBar to True
97659>>>        Set pbVisible of ghoProgressBarOverall to True
97660>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTables
97661>>>        Set piMaximum of ghoProgressBarOverall to iNoOfTables
97662>>>        
97662>>>        // Fill the 'From' structure with data:
97662>>>        Get UtilTableStructFill of ghoDbUpdateFunctionLibrary True True to aFromStructure
97663>>>        
97663>>>        // Set up the pathing correctly for the 'To' Filelist.cfg so we can open tables:
97663>>>        Get ChangeFilelistPathing sFilelistTo to bOK
97664>>>        If (bOK = False) Begin
97666>>>            Move -1 to iaDifferences[0]
97667>>>            Function_Return iaDifferencesEmpty
97668>>>        End
97668>>>>
97668>>>        
97668>>>        // Fill the 'To' structure with data:
97668>>>        Get UtilTableStructFill of ghoDbUpdateFunctionLibrary True False to aToStructure
97669>>>
97669>>>        // Make the comparison:
97669>>>        Set Message_Text of ghoStatusPanel to "Comparing Tables:"
97670>>>        Move 0 to hTable
97671>>>        Move 0 to iCount
97672>>>        Move (SizeOfArray(aFromStructure)) to iSizeFrom  
97673>>>        Move (SizeOfArray(aToStructure))   to iSizeTo
97674>>>        Move (iSizeFrom max iSizeTo)       to iSize 
97675>>>        Set piMaximum of ghoProgressBarOverall to iSize  
97676>>>        Decrement iSize 
97677>>>        
97677>>>        For iCount from 0 to iSize                 
97683>>>>
97683>>>            Move True to bIsSame                   
97684>>>            Set piPosition of ghoProgressBarOverall to iCount
97685>>>            Get FindArrayItem aFromStructure aToStructure iCount (&hTable) (&iItemFrom) (&iItemTo) to sLogicalName
97686>>>            Set Action_Text of ghoStatusPanel to ("Name:" * sLogicalName * "Number:" * String(hTable))  
97687>>>            If (iItemFrom > -1 and iItemTo > -1) Begin
97689>>>                Get UtilTableCompare_Ex of ghoDbUpdateFunctionLibrary aFromStructure[iItemFrom] aToStructure[iItemTo] CompareTableBooleans False (&bFilelistError) to bIsSame
97690>>>            End 
97690>>>>
97690>>>            Else Begin
97691>>>                Move True to bFilelistError
97692>>>            End
97692>>>>
97692>>>            If (bFilelistError = True or bIsSame = False) Begin
97694>>>                Move hTable to iaDifferences[SizeOfArray(iaDifferences)]
97695>>>            End
97695>>>>
97695>>>                    
97695>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
97696>>>            If (bUserCancel = True) Begin
97698>>>                Send Stop_StatusPanel of ghoStatusPanel
97699>>>                Send Info_Box "Process interrupted..."
97700>>>                Function_Return iaDifferencesEmpty
97701>>>            End
97701>>>>
97701>>>        Until (hTable = 0)    
97703>>>        
97703>>>//        If (bTagFileNames = False) Begin        
97703>>>//            Move (SizeOfArray(iaDifferences)) to iSize
97703>>>//            If (iSize > 0) Begin
97703>>>        Send WriteDifferenceReport (&aFromStructure) (&aToStructure) (&iaDifferences) (&CompareTableBooleans)
97704>>>//            End 
97704>>>//        End
97704>>>
97704>>>        Function_Return iaDifferences
97705>>>    End_Function  
97706>>>    
97706>>>    Function FindArrayItem tAPITable[] aFromStructure tAPITable[] aToStructure Integer iCount Handle ByRef hTable Integer ByRef iItemFrom Integer ByRef iItemTo Returns String
97709>>>        Integer iSizeFrom iSizeTo   
97709>>>        Handle hTableFrom hTableTo
97709>>>        String sLogicalName
97709>>>        
97709>>>        Move (SizeOfArray(aFromStructure)) to iSizeFrom
97710>>>        Move (SizeOfArray(aToStructure))   to iSizeTo
97711>>>
97711>>>        Move -1 to hTableFrom
97712>>>        Move -1 to hTableTo
97713>>>        Move iCount to iItemFrom
97714>>>        Move iCount to iItemTo
97715>>>        
97715>>>        // The two struct arrays may be different in size (contain different number of items/tables). 
97715>>>        //
97715>>>        // To avoid "Referenced Array Index Out of Bounds" error.
97715>>>        If (iCount < iSizeFrom) Begin
97717>>>            Move aFromStructure[iCount].ApiTableInfo.iTableNumber to hTableFrom
97718>>>        End
97718>>>>
97718>>>        If (iCount < iSizeTo) Begin
97720>>>            Move aToStructure[iCount].ApiTableInfo.iTableNumber   to hTableTo
97721>>>        End
97721>>>>
97721>>>        If (hTableFrom <> -1 and hTableTo <> -1) Begin
97723>>>            Move (hTableFrom min hTableTo)                to hTable
97724>>>        End
97724>>>>
97724>>>        Else Begin
97725>>>            Move (hTableFrom max hTableTo)                to hTable
97726>>>        End
97726>>>>
97726>>>                
97726>>>        If (iCount < iSizeFrom and hTableFrom <= hTableTo) Begin
97728>>>            Move aFromStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName                                                       
97729>>>            Get FindTableNumber aToStructure hTable to iItemTo
97730>>>        End 
97730>>>>
97730>>>        
97730>>>        // If the 'To' table number is lower than 'From'
97730>>>        Else If (iCount < iSizeTo) Begin
97733>>>            Move aToStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName                                                       
97734>>>            Get FindTableNumber aFromStructure hTable to iItemFrom
97735>>>        End              
97735>>>>
97735>>>        Else If (iCount = iSizeTo) Begin
97738>>>            Get FindTableNumber aToStructure hTable to iItemTo
97739>>>        End              
97739>>>>
97739>>>        
97739>>>        Function_Return sLogicalName
97740>>>    End_Function
97741>>>    
97741>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
97744>>>        Integer iSize iCount iTable iItem
97744>>>        tAPITableNameInfo ApiTableNameInfo
97744>>>        tAPITableNameInfo ApiTableNameInfo
97744>>>        
97744>>>        Move -1 to iItem
97745>>>        Move (SizeOfArray(aTableStructure)) to iSize
97746>>>        Decrement iSize
97747>>>        For iCount from 0 to iSize
97753>>>>
97753>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
97754>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
97756>>>                Move iCount to iItem
97757>>>                Move iSize  to iCount // We're done.
97758>>>            End
97758>>>>
97758>>>        Loop
97759>>>>
97759>>>        
97759>>>        Function_Return iItem
97760>>>    End_Function
97761>>>    
97761>>>    Procedure WriteDifferenceReport tAPITable[] ByRef aFromStructure tAPITable[] ByRef aToStructure Integer[] ByRef iaDifferences tAPITableBooleans ByRef CompareTableBooleans
97764>>>        Integer iCh iSize iCount iItem iErrors iItemFrom iItemTo iItems
97764>>>        String sFilelistFrom sFilelistTo sReportName sDriverID sLogicalName sFrom sTo sRootName sTableName
97764>>>        Handle hTable
97764>>>        Boolean bCompareDate_DateTime bCompareIndexUppercase bCompareIndexAscending bCompareFilelistUppercase
97764>>>        Boolean bIsSame bExistsFrom bExistsTo bUserCancel bIsSQLFrom bIsSQLTo
97764>>>        DateTime dtCreationTime
97764>>>        tAPITableNameInfo APITableNameInfoFrom APITableNameInfoTo
97764>>>        tAPITableNameInfo APITableNameInfoFrom APITableNameInfoTo
97764>>>        tAPIColumn[]   APIColumnsFrom   APIColumnsTo
97764>>>        tAPIColumn[]   APIColumnsFrom   APIColumnsTo
97766>>>        tAPIIndex[]    APIIndexesFrom   APIIndexesTo
97766>>>        tAPIIndex[]    APIIndexesFrom   APIIndexesTo
97768>>>        tAPIRelation[] APIRelationsFrom APIRelationsTo
97768>>>        tAPIRelation[] APIRelationsFrom APIRelationsTo
97770>>>        
97770>>>        Get Value of oReportFileName_fm   to sReportName
97771>>>        Get Seq_Open_Output_Channel sReportName to iCh
97772>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
97774>>>            Send Stop_Box "Sorry, couldn't retrieve a free channel number."
97775>>>            Procedure_Return
97776>>>        End
97776>>>>
97776>>>        
97776>>>        Move 0 to iItems
97777>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
97778>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
97779>>>        Move CompareTableBooleans.bCompareDate_DateTime     to bCompareDate_DateTime
97780>>>        Move CompareTableBooleans.bCompareIndexAscending    to bCompareIndexAscending
97781>>>        Move CompareTableBooleans.bCompareIndexUppercase    to bCompareIndexUppercase
97782>>>        Move CompareTableBooleans.bCompareFilelistUppercase to bCompareFilelistUppercase
97783>>>        Move (CurrentDateTime()) to dtCreationTime
97784>>>        Set Action_Text of ghoStatusPanel to "Writing difference report..."
97785>>>               
97785>>>        Writeln channel iCh ("/" + "/ *** The Database Update Framework (DUF)    ***")
97788>>>        Writeln channel iCh ("/" + "/ *** Compare Report: Database Differences   ***")
97791>>>        Writeln channel iCh ("/" + "/ *** Created at:" * String(dtCreationTime) + "    ***")
97794>>>        Writeln channel iCh ("/" + "/")
97797>>>        Writeln channel iCh ("/" + "/ FROM: Database Filelist.cfg -" * String(sFilelistFrom))
97800>>>        Writeln channel iCh ("/" + "/ TO  : Database Filelist.cfg -" * String(sFilelistTo))
97803>>>        Writeln channel iCh ("/" + "/")  
97806>>>        Writeln channel iCh ("/" + "/ Note: An asterisk in paranthesis (*) denotes that there is a difference!")
97809>>>        Writeln channel iCh 
97811>>>        
97811>>>        Move 0 to iErrors
97812>>>        Move (SizeOfArray(iaDifferences)) to iSize
97813>>>        Set piMaximum of ghoProgressBarOverall to iSize  
97814>>>        Decrement iSize
97815>>>        
97815>>>        For iCount from 0 to iSize
97821>>>>
97821>>>            Set piPosition of ghoProgressBarOverall to iCount
97822>>>            Move iaDifferences[iCount] to hTable  
97823>>>            Get FindTableNumber aFromStructure hTable               to iItemFrom
97824>>>            Get FindTableNumber aToStructure hTable                 to iItemTo
97825>>>            Move aFromStructure[iItemFrom].ApiTableInfo.bIsSQL      to bIsSQLFrom
97826>>>            Move aFromStructure[iItemTo].ApiTableInfo.bIsSQL        to bIsSQLTo
97827>>>            Move aFromStructure[iItemFrom].ApiTableInfo.sDriverID   to sDriverID
97828>>>            
97828>>>            If (iItemFrom <> -1) Begin
97830>>>                Move aFromStructure[iItemFrom].ApiTableInfo to APITableNameInfoFrom
97831>>>                Move APITableNameInfoFrom.sLogicalName      to sLogicalName
97832>>>            End
97832>>>>
97832>>>            If (iItemTo <> -1) Begin
97834>>>                Move aToStructure[iItemTo].ApiTableInfo to APITableNameInfoTo
97835>>>                Move APITableNameInfoTo.sLogicalName    to sLogicalName
97836>>>            End
97836>>>>
97836>>>                    
97836>>>            Set Message_Text of ghoStatusPanel to "Writing difference(s) for table:"
97837>>>            Set Action_Text of ghoStatusPanel  to (String(hTable) * String(APITableNameInfoFrom.sLogicalName))
97838>>>                
97838>>>            // Table Names:
97838>>>            Get UtilTableInfoCompare of ghoDbUpdateFunctionLibrary bCompareFilelistUppercase APITableNameInfoFrom APITableNameInfoTo to bIsSame
97839>>>            If (bIsSame = False) Begin
97841>>>                Send WriteTableInfoDiff APITableNameInfoFrom APITableNameInfoTo iCh 
97842>>>                Increment iItems
97843>>>            End
97843>>>>
97843>>>            
97843>>>            // Check if both tables exists: (Else the header text will say so and there is no point in showing columns.)
97843>>>            Move (iItemFrom > 0) to bExistsFrom
97844>>>            Move (iItemTo > 0)   to bExistsTo
97845>>>                
97845>>>            // Column Check:
97845>>>            If (bExistsFrom = True and bExistsTo = True) Begin
97847>>>                Move aFromStructure[iItemFrom].aApiColumns         to APIColumnsFrom
97848>>>                Move aToStructure[iItemTo].aApiColumns             to APIColumnsTo  
97849>>>                Move aFromStructure[iItemFrom].ApiTableInfo.bIsSQL to bIsSQLFrom
97850>>>                Move aToStructure[iItemTo].ApiTableInfo.bIsSQL     to bIsSQLTo
97851>>>                Get UtilColumnsCompare of ghoDbUpdateFunctionLibrary sDriverID bIsSQLFrom bIsSQLTo APIColumnsFrom APIColumnsTo bCompareDate_DateTime to bIsSame
97852>>>                If (bIsSame = False) Begin  
97854>>>                    // If array size = 0 the table doesn't exist.
97854>>>                    If (SizeOfArray(APIColumnsFrom) <> 0 and SizeOfArray(APIColumnsTo) <> 0) Begin
97856>>>                        Send WriteColumnInfoDiff sDriverID hTable APITableNameInfoFrom.sLogicalName bIsSQLFrom bIsSQLTo APIColumnsFrom APIColumnsTo bCompareDate_DateTime iCh
97857>>>                        Increment iItems
97858>>>                    End
97858>>>>
97858>>>                End
97858>>>>
97858>>>                
97858>>>                // Index Check:
97858>>>                Move aFromStructure[iItemFrom].aApiIndexes to APIIndexesFrom
97859>>>                Move aToStructure[iItemTo].aApiIndexes     to APIIndexesTo
97860>>>                Get UtilIndexesCompare of ghoDbUpdateFunctionLibrary hTable APIIndexesFrom APIIndexesTo bCompareIndexUppercase bCompareIndexAscending to bIsSame
97861>>>                If (bIsSame = False) Begin
97863>>>                    Send WriteIndexInfoDiff hTable APITableNameInfoFrom.sLogicalName APIIndexesFrom APIIndexesTo bCompareIndexUppercase bCompareIndexAscending iCh
97864>>>                End
97864>>>>
97864>>>                
97864>>>                // Relations Check:
97864>>>                Move aFromStructure[iItemFrom].aApiRelations to APIRelationsFrom
97865>>>                Move aToStructure[iItemTo].aApiRelations     to APIRelationsTo
97866>>>                Get UtilRelationsCompare of ghoDbUpdateFunctionLibrary hTable APIRelationsFrom APIRelationsTo to bIsSame
97867>>>                If (bIsSame = False) Begin
97869>>>                    Send WriteRelationInfoDiff hTable APIRelationsFrom APIRelationsTo iCh
97870>>>                End
97870>>>>
97870>>>            End
97870>>>>
97870>>>
97870>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
97871>>>            If (bUserCancel = True) Begin
97873>>>                Move iSize to iCount
97874>>>            End
97874>>>>
97874>>>        Loop 
97875>>>>
97875>>>        
97875>>>        If (bUserCancel = False) Begin
97877>>>            Writeln channel iCh
97879>>>            Writeln channel iCh "SUMMARY:"                                                   
97882>>>            Writeln channel iCh CS_ReportHeaderUnderWrite
97885>>>            Writeln channel iCh "Number of Tables with differences: " (String(iSize + 1))
97889>>>        End
97889>>>>
97889>>>        
97889>>>        Send Seq_Close_Channel iCh  
97890>>>        Send Stop_StatusPanel of ghoStatusPanel
97891>>>    End_Procedure                                                                
97892>>>    
97892>>>    Function MakeStringLength String sValue Integer iReportColumnPos Returns String
97895>>>        Move (Pad(sValue, (Length(sValue) + (iReportColumnPos - Length(sValue))))) to sValue
97896>>>        
97896>>>        Function_Return sValue
97897>>>    End_Function
97898>>>    
97898>>>    // Note: The rootname will be first be stripped if it contains any driver id prefix.
97898>>>    Procedure WriteTableInfoDiff tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Integer iCh
97901>>>        String sRootNameFrom sRootNameTo  
97901>>>        Boolean bExistsFrom bExistsTo 
97901>>>        Handle hTableFrom hTableTo hTable
97901>>>        
97901>>>        Move APITableNameInfoFrom.iTableNumber to hTableFrom
97902>>>        Move (hTableFrom > 0)                  to bExistsFrom
97903>>>        Move APITableNameInfoFrom.sRootName    to sRootNameFrom
97904>>>        Move APITableNameInfoTo.iTableNumber   to hTableTo
97905>>>        Move (hTableTo > 0)                    to bExistsTo
97906>>>        Move APITableNameInfoTo.sRootName      to sRootNameTo 
97907>>>        Move (If(hTableFrom > 0, hTableFrom, hTableTo)) to hTable
97908>>>        
97908>>>        Writeln channel iCh
97910>>>        Writeln channel iCh "Table Name Difference(s) Table Number: " hTable
97914>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
97917>>>        If (bExistsFrom = False) Begin
97919>>>            Writeln channel iCh "*** This table does not exist in the 'FROM' database! ***"
97922>>>        End
97922>>>>
97922>>>        If (bExistsTo = False) Begin
97924>>>            Writeln channel iCh "*** This table does not exist in the 'TO' database! ***"
97927>>>        End
97927>>>>
97927>>>        Writeln channel iCh "Logical Name From/To: " APITableNameInfoFrom.sLogicalName "     " APITableNameInfoTo.sLogicalName
97933>>>        Writeln channel iCh "Root Name From/To:    " sRootNameFrom                 "     " sRootNameTo
97939>>>        Writeln channel iCh "Display Name From/To: " APITableNameInfoFrom.sDisplayName "     " APITableNameInfoTo.sDisplayName
97945>>>        Writeln channel iCh
97947>>>    End_Procedure
97948>>>
97948>>>    Procedure WriteColumnInfoDiff String sDriverID Handle hTable String sLogicalTableName Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn[] APIColumnsFrom tAPIColumn[] APIColumnsTo Boolean bCompareDate_DateTime Integer iCh 
97951>>>        Integer iSize iSizeFrom iSizeTo iCount iDbType iFromType iToType
97951>>>        Boolean bIsSame   
97951>>>        String sFrom sTo sTypeFrom sTypeTo 
97951>>>        
97951>>>        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
97952>>>        
97952>>>        Writeln channel iCh "Field Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
97958>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
97961>>>        // Logical Name:
97961>>>//                        Move ("Logical Name: " * String(APITableNameInfoFrom.sLogicalName))     to sFrom
97961>>>//                        Move (Pad(sFrom, (Length(sFrom) + (CI_ReportColumn2 - Length(sFrom))))) to sFrom
97961>>>//                        Move (String(APITableNameInfoTo.sLogicalName))                          to sTo
97961>>>//                        Writeln channel iCh sFrom sTo
97961>>>
97961>>>        // Root Name:
97961>>>//                        Move ("Root Name   : " * String(APITableNameInfoFrom.sRootName))            to sFrom
97961>>>//                        Move (String(APITableNameInfoTo.sRootName))                                 to sTo
97961>>>//                        Move (Pad(sFrom, (Length(sFrom) + (CI_ReportColumn2 - Length(sFrom))))) to sFrom
97961>>>//                        Writeln channel iCh sFrom sTo
97961>>>        
97961>>>//                        Move ("Display Name: " * String(APITableNameInfoFrom.sDisplayName))         to sFrom
97961>>>//                        Move (String(APITableNameInfoTo.sDisplayName))                              to sTo
97961>>>//                        Move (Pad(sFrom, (Length(sFrom) + (CI_ReportColumn2 - Length(sFrom))))) to sFrom
97961>>>//                        Writeln channel iCh sFrom sTo
97961>>>
97961>>>//        Writeln channel iCh
97961>>>        Move "FROM Database:" to sFrom 
97962>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
97963>>>        Move (sFrom + "TO Database:") to sFrom
97964>>>        Writeln channel iCh sFrom
97967>>>        Move (Repeat("-", Length(sFrom))) to sFrom
97968>>>        Writeln channel iCh sFrom
97971>>>
97971>>>        // Any of the 'From' or 'To' table may have more fields then the other...
97971>>>        Move (SizeOfArray(APIColumnsFrom)) to iSizeFrom
97972>>>        Move (SizeOfArray(APIColumnsTo))   to iSizeTo
97973>>>        Move (iSizeFrom max iSizeTo)       to iSize
97974>>>        Decrement iSize
97975>>>        For iCount from 0 to iSize                                                            
97981>>>>
97981>>>            // Field exists in 'From' but not in 'To'
97981>>>            If (iCount >= iSizeTo) Begin
97983>>>                // Field Number:
97983>>>                Get MakeStringLength "Number:" CI_ReportColumn1                 to sFrom
97984>>>                Move (sFrom + String(APIColumnsFrom[iCount].iFieldNumber))      to sFrom
97985>>>                Get MakeStringLength sFrom CI_ReportColumn2                     to sFrom
97986>>>                Writeln channel iCh sFrom
97989>>>                
97989>>>                // Field Name:
97989>>>                Get MakeStringLength "Name:" CI_ReportColumn1                   to sFrom
97990>>>                Move (sFrom + String(APIColumnsFrom[iCount].sFieldName))        to sFrom
97991>>>                Get MakeStringLength sFrom CI_ReportColumn2                     to sFrom
97992>>>                Move (String(CS_ReportFieldNotFound * CS_ReportDifferenceNote)) to sTo
97993>>>                Writeln channel iCh sFrom sTo
97997>>>                
97997>>>                Get MakeStringLength "Type:" CI_ReportColumn1                   to sFrom
97998>>>                Move (sFrom + String(APIColumnsFrom[iCount].sType))             to sFrom
97999>>>                Get MakeStringLength sFrom CI_ReportColumn2                     to sFrom
98000>>>                Writeln channel iCh sFrom 
98003>>>                
98003>>>                // Field Length:    
98003>>>                Get MakeStringLength "Length:" CI_ReportColumn1                 to sFrom
98004>>>                Move (sFrom + String(APIColumnsFrom[iCount].iLength))           to sFrom
98005>>>                Get MakeStringLength sFrom CI_ReportColumn2                     to sFrom
98006>>>                Writeln channel iCh sFrom 
98009>>>                
98009>>>                // Field Precision: 
98009>>>                Get MakeStringLength "Precision:" CI_ReportColumn1              to sFrom
98010>>>                Move (sFrom + String(APIColumnsFrom[iCount].iPrecision))        to sFrom
98011>>>                Get MakeStringLength sFrom CI_ReportColumn2                     to sFrom
98012>>>                Writeln channel iCh sFrom
98015>>>            End 
98015>>>>
98015>>>
98015>>>            // Field exists in 'To' but not in 'From'
98015>>>            Else If (iCount >= iSizeFrom) Begin
98018>>>                // Field Number:
98018>>>                Get MakeStringLength "Number:" CI_ReportColumn1                         to sFrom
98019>>>                Move (sFrom + String(APIColumnsTo[iCount].iFieldNumber))                to sTo
98020>>>                Writeln channel iCh sFrom sTo
98024>>>                
98024>>>                // Field Name:
98024>>>                Get MakeStringLength "Name:" CI_ReportColumn1                           to sFrom
98025>>>                Move (sFrom + String(CS_ReportFieldNotFound * CS_ReportDifferenceNote)) to sFrom
98026>>>                Get MakeStringLength sFrom CI_ReportColumn2                             to sFrom
98027>>>                Move (String(APIColumnsTo[iCount].sFieldName))                          to sTo
98028>>>                Writeln channel iCh sFrom sTo
98032>>>                
98032>>>                Get MakeStringLength "Type:"                                            to sFrom
98033>>>                Move (String(APIColumnsTo[iCount].sType))                               to sTo
98034>>>                Writeln channel iCh sFrom sTo
98038>>>                
98038>>>                // Field Length:    
98038>>>                Get MakeStringLength "Length:"                                          to sFrom
98039>>>                Move (String(APIColumnsTo[iCount].iLength))                             to sTo
98040>>>                Writeln channel iCh sFrom sTo
98044>>>                
98044>>>                // Field Precision: 
98044>>>                Get MakeStringLength "Precision:"                                       to sTo
98045>>>                Move (String(APIColumnsTo[iCount].iPrecision))                          to sTo
98046>>>                Writeln channel iCh sFrom sTo
98050>>>            End                                                                             
98050>>>>
98050>>>            
98050>>>            If (iCount < iSizeFrom and iCount < iSizeTo) Begin
98052>>>                Get UtilColumnCompare of ghoDbUpdateFunctionLibrary sDriverID bIsSQLFrom bIsSQLTo APIColumnsFrom[iCount] APIColumnsTo[iCount] bCompareDate_DateTime to bIsSame
98053>>>
98053>>>                If (bIsSame = False) Begin
98055>>>                    // Field Number:
98055>>>                    Get MakeStringLength "Number:" CI_ReportColumn1                     to sFrom
98056>>>                    Move (sFrom + String(APIColumnsFrom[iCount].iFieldNumber))          to sFrom
98057>>>                    Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
98058>>>                    Move (String(APIColumnsTo[iCount].iFieldNumber))                    to sTo
98059>>>                    If (APIColumnsFrom[iCount].iFieldNumber <> APIColumnsTo[iCount].iFieldNumber) Begin
98061>>>                        Move (sTo * String(CS_ReportDifferenceNote))                    to sTo
98062>>>                    End
98062>>>>
98062>>>                    Writeln channel iCh sFrom sTo
98066>>>                    
98066>>>                    // Field Name:
98066>>>                    Get MakeStringLength "Name:" CI_ReportColumn1                       to sFrom
98067>>>                    Move (sFrom + String(APIColumnsFrom[iCount].sFieldName))            to sFrom
98068>>>                    Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
98069>>>                    Move (String(APIColumnsTo[iCount].sFieldName))                      to sTo
98070>>>                    If (APIColumnsFrom[iCount].sFieldName <> APIColumnsTo[iCount].sFieldName) Begin
98072>>>                        Move (sTo * String(CS_ReportDifferenceNote))                    to sTo
98073>>>                    End
98073>>>>
98073>>>                    Writeln channel iCh sFrom sTo
98077>>>                    
98077>>>                    // Field Type:                         
98077>>>                    Move APIColumnsFrom[iCount].sType to sTypeFrom
98078>>>                    Move APIColumnsTo[iCount].sType   to sTypeTo
98079>>>                    Move APIColumnsFrom[iCount].iType to iFromType
98080>>>                    Move APIColumnsTo[iCount].iType   to iToType
98081>>>
98081>>>                    // If one of the two tables is SQL and the other Embedded we need to "translate"
98081>>>                    // data types between Embedded and SQL, to be able to check if they are different or not.
98081>>>                    If (bIsSQLFrom = True and bIsSQLTo = False) Begin
98083>>>                        Get UtilSqlColumnTypeToDataFlexType of ghoDbUpdateFunctionLibrary sDriverID iDbType iFromType APIColumnsFrom[iCount].iLength to iFromType
98084>>>                    End
98084>>>>
98084>>>                    Else If (bIsSQLFrom = False and bIsSQLTo = True) Begin
98087>>>                        Get UtilSqlColumnTypeToDataFlexType of ghoDbUpdateFunctionLibrary sDriverID iDbType iToType   APIColumnsTo[iCount].iLength   to iToType
98088>>>                    End
98088>>>>
98088>>>                    Move (iFromType = iToType) to bIsSame
98089>>>
98089>>>                    Get MakeStringLength "Type:" CI_ReportColumn1                           to sFrom
98090>>>                    Move (sFrom + sTypeFrom)                                                to sFrom
98091>>>                    Get MakeStringLength sFrom CI_ReportColumn2                             to sFrom
98092>>>                    Move (String(sTypeTo))                                                  to sTo
98093>>>                    If (bIsSame = False) Begin
98095>>>                        Move (sTo * String(CS_ReportDifferenceNote))                        to sTo
98096>>>                    End
98096>>>>
98096>>>                    Writeln channel iCh sFrom sTo
98100>>>                    
98100>>>                    // Field Length:    
98100>>>                    Get MakeStringLength "Length:" CI_ReportColumn1                         to sFrom
98101>>>                    Move (sFrom + String(APIColumnsFrom[iCount].iLength))                   to sFrom
98102>>>                    Get MakeStringLength sFrom CI_ReportColumn2                             to sFrom
98103>>>                    Move (String(APIColumnsTo[iCount].iLength))                             to sTo
98104>>>                    If (APIColumnsFrom[iCount].iLength <> APIColumnsTo[iCount].iLength) Begin
98106>>>                        Move (sTo * String(CS_ReportDifferenceNote))                        to sTo
98107>>>                    End
98107>>>>
98107>>>                    Writeln channel iCh sFrom sTo
98111>>>                    
98111>>>                    // Field Precision: 
98111>>>                    Get MakeStringLength "Precision:" CI_ReportColumn1                      to sFrom
98112>>>                    Move (sFrom + String(APIColumnsFrom[iCount].iPrecision))                to sFrom
98113>>>                    Get MakeStringLength sFrom CI_ReportColumn2                             to sFrom
98114>>>                    Move (String(APIColumnsTo[iCount].iPrecision))                          to sTo
98115>>>                    If (APIColumnsFrom[iCount].iPrecision <> APIColumnsTo[iCount].iPrecision) Begin
98117>>>                        Move (sTo * String(CS_ReportDifferenceNote))                        to sTo
98118>>>                    End
98118>>>>
98118>>>                    Writeln channel iCh sFrom sTo
98122>>>                End
98122>>>>
98122>>>            End
98122>>>>
98122>>>        Loop
98123>>>>
98123>>>    End_Procedure  
98124>>>    
98124>>>    Procedure WriteIndexInfoDiff Handle hTable String sLogicalTableName tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Integer iCh 
98127>>>        Integer iSize iCount iSegmentSizeFrom iSegmentSizeTo iCount2 iSize2
98127>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo
98127>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo
98129>>>        String sFrom sTo
98129>>>        
98129>>>        Writeln channel iCh "Index Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
98135>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
98138>>>        Move (SizeOfArray(APIIndexFrom)) to iSize
98139>>>        Decrement iSize
98140>>>        For iCount from 0 to iSize  
98146>>>>
98146>>>            Get MakeStringLength "Index Number:" CI_ReportColumn1 to sFrom
98147>>>            Writeln channel iCh (sFrom + String(APIIndexFrom[iCount].iIndexNumber))
98150>>>            If (APIIndexFrom[iCount].sSQLIndexName <> "") Begin
98152>>>                Get MakeStringLength "SQL FROM Index Name:" CI_ReportColumn1 to sFrom
98153>>>                Writeln channel iCh (sFrom + String(APIIndexFrom[iCount].sSQLIndexName) * "SQL TO Index Name:" * String(APIIndexTo[iCount].sSQLIndexName))
98156>>>                Get MakeStringLength "SQL FROM Index Type:" CI_ReportColumn1 to sFrom
98157>>>                Writeln channel iCh (sFrom + String(APIIndexFrom[iCount].iSQLIndexType) * "SQL TO Index Type:" * String(APIIndexTo[iCount].iSQLIndexType))
98160>>>            End                             
98160>>>>
98160>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aApiIndexSegmentsFrom
98161>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aApiIndexSegmentsTo
98162>>>            Move (SizeOfArray(aApiIndexSegmentsFrom))   to iSegmentSizeFrom
98163>>>            If (iSegmentSizeFrom <> 0) Begin
98165>>>                Move (SizeOfArray(aApiIndexSegmentsTo))     to iSegmentSizeTo  
98166>>>                Move (iSegmentSizeFrom max iSegmentSizeTo)  to iSize2
98167>>>                Decrement iSize2   
98168>>>
98168>>>                Get MakeStringLength "Field Number:" CI_ReportColumn1 to sFrom
98169>>>                Move (sFrom + "Field Name:") to sFrom
98170>>>                Get MakeStringLength sFrom           CI_ReportColumn2 to sFrom
98171>>>                Move (sFrom + "Uppercase:")                           to sFrom
98172>>>                Get MakeStringLength sFrom           CI_ReportColunn3 to sFrom
98173>>>                Move (sFrom + "Ascending:")                           to sFrom
98174>>>                Writeln channel iCh sFrom
98177>>>                Move (Repeat("-", Length(sFrom))) to sFrom
98178>>>                Writeln channel iCh sFrom
98181>>>                
98181>>>                For iCount2 from 0 to iSize2
98187>>>>
98187>>>                    Get MakeStringLength ("From: " + String(aApiIndexSegmentsFrom[iCount2].iFieldNumber)) CI_ReportColumn1 to sFrom // Field Number
98188>>>                    Move (sFrom + String(aApiIndexSegmentsFrom[iCount2].sFieldName)) to sFrom                      // Field Name
98189>>>                    Get MakeStringLength sFrom CI_ReportColumn2                      to sFrom   
98190>>>                    If (bCompareIndexUppercase = True) Begin
98192>>>                        Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bUppercase = 1, "Yes","No")))  to sFrom // Uppercase
98193>>>                    End 
98193>>>>
98193>>>                    Else Begin
98194>>>                        Move (sFrom + String("N/A")) to sFrom
98195>>>                    End
98195>>>>
98195>>>                        
98195>>>                    Get MakeStringLength sFrom CI_ReportColunn3     to sFrom
98196>>>                    If (bCompareIndexAscending = True) Begin
98198>>>                        Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bAscending = 1, "Yes", "No"))) to sFrom // Ascending
98199>>>                    End 
98199>>>>
98199>>>                    Else Begin
98200>>>                        Move (sFrom + String("N/A")) to sFrom
98201>>>                    End
98201>>>>
98201>>>                        
98201>>>                    Writeln channel iCh sFrom
98204>>>                    
98204>>>                    If (iCount2 < iSegmentSizeTo) Begin
98206>>>                        Get MakeStringLength ("To  : " + String(aApiIndexSegmentsTo[iCount2].iFieldNumber))   CI_ReportColumn1 to sTo // Field Number
98207>>>                        Move (sTo + String(aApiIndexSegmentsTo[iCount2].sFieldName))     to sTo                      // Field Name   
98208>>>                        If (aApiIndexSegmentsFrom[iCount2].sFieldName <> aApiIndexSegmentsTo[iCount2].sFieldName) Begin
98210>>>                            Move (sTo * String(CS_ReportDifferenceNote)) to sTo
98211>>>                        End
98211>>>>
98211>>>                        Get MakeStringLength sTo CI_ReportColumn2                        to sTo
98212>>>                        If (bCompareIndexUppercase = True) Begin
98214>>>                            Move (sTo + String(If(aApiIndexSegmentsTo[iCount2].bUppercase = 1, "Yes", "No"))) to sTo // Uppercase
98215>>>                        End
98215>>>>
98215>>>                        Else Begin
98216>>>                            Move (sTo + String("N/A")) to sTo
98217>>>                        End
98217>>>>
98217>>>                            
98217>>>                        Get MakeStringLength sTo CI_ReportColunn3     to sTo
98218>>>                        If (bCompareIndexAscending = True) Begin
98220>>>                            Move (sTo + String(If(aApiIndexSegmentsTo[iCount2].bAscending = 1, "Yes", "No"))) to sTo // Ascending
98221>>>                        End 
98221>>>>
98221>>>                        Else Begin
98222>>>                            Move (sTo + String("N/A")) to sTo
98223>>>                        End
98223>>>>
98223>>>                            
98223>>>                        Writeln channel iCh sTo                                                    
98226>>>                    End
98226>>>>
98226>>>                Loop
98227>>>>
98227>>>                Writeln channel iCh
98229>>>            End
98229>>>>
98229>>>        Loop
98230>>>>
98230>>>    End_Procedure                                                 
98231>>>    
98231>>>    Procedure WriteRelationInfoDiff Handle hTable tAPIRelation[] APIRelationFrom tAPIRelation[] APIRelationTo Integer iCh 
98234>>>        Integer iSizeFrom iSizeTo iCount
98234>>>        Boolean bExists bOK  
98234>>>        String sFrom sTo sFromFields sToFields
98234>>>        
98234>>>        Writeln channel iCh ""
98237>>>        Writeln channel iCh "Relation Difference(s) for Table Number: " (String(hTable)) " - " APIRelationFrom[0].sLogicalNameFrom
98243>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
98246>>>        Move "FROM Database:" to sFrom
98247>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
98248>>>        Move (sFrom + "TO Database:") to sFrom
98249>>>        Writeln channel iCh sFrom
98252>>>        Move (Repeat("-", Length(sFrom))) to sFrom
98253>>>        Writeln channel iCh sFrom
98256>>>
98256>>>        Move (SizeOfArray(APIRelationFrom)) to iSizeFrom
98257>>>        Move (SizeOfArray(APIRelationTo))   to iSizeTo
98258>>>        Decrement iSizeFrom
98259>>>        For iCount from 0 to iSizeFrom
98265>>>>
98265>>>            Move ("Relation: " + String(iCount + 1)) to sFrom
98266>>>            Get MakeStringLength sFrom CI_ReportColumn1 to sFrom
98267>>>            Move (sFrom + "Table.Field:" * String(APIRelationFrom[iCount].hTableFrom) + "." + String(APIRelationFrom[iCount].iColumnFrom) * "->") to sFrom
98268>>>            Move (sFrom * String(APIRelationFrom[iCount].hTableTo) + "." + String(APIRelationFrom[iCount].iColumnTo)) to sFrom
98269>>>            Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
98270>>>            Move (String(APIRelationFrom[iCount].sLogicalNameFrom) + "." + String(APIRelationFrom[iCount].sFieldNameFrom) * "->") to sFromFields
98271>>>            Move (sFromFields * String(APIRelationFrom[iCount].sLogicalNameTo)   + "." + String(APIRelationFrom[iCount].sFieldNameTo)) to sFromFields
98272>>>
98272>>>            Move (iCount < iSizeTo) to bExists  
98273>>>            If (bExists = True) Begin
98275>>>                Move ("Table.Field:" * String(APIRelationTo[iCount].hTableFrom) + "." + String(APIRelationTo[iCount].iColumnFrom) * "->") to sTo
98276>>>                Move (sTo * String(APIRelationTo[iCount].hTableTo) + "." + String(APIRelationTo[iCount].iColumnTo)) to sTo
98277>>>                Move (APIRelationFrom[iCount].hTableFrom = APIRelationTo[iCount].hTableFrom and APIRelationFrom[iCount].hTableTo = APIRelationTo[iCount].hTableTo) to bOK
98278>>>                If (bOK = True) Begin
98280>>>                    Move (APIRelationFrom[iCount].iColumnFrom = APIRelationTo[iCount].iColumnFrom and APIRelationFrom[iCount].iColumnTo = APIRelationTo[iCount].iColumnTo) to bOK
98281>>>                End
98281>>>>
98281>>>                If (bOK = False) Begin
98283>>>                    Move (sTo * String(CS_ReportDifferenceNote)) to sTo
98284>>>                End
98284>>>>
98284>>>                Move (" 'TO:'" * String(APIRelationTo[iCount].sLogicalNameFrom) + "." + String(APIRelationTo[iCount].sFieldNameFrom) * "->") to sToFields
98285>>>                Move (sToFields * String(APIRelationTo[iCount].sLogicalNameTo) + "." + String(APIRelationTo[iCount].sFieldNameTo)) to sToFields 
98286>>>                Get MakeStringLength sToFields CI_ReportColumn2 to sToFields
98287>>>//                Move (Pad(sToFields, (Length(sToFields) + (CI_ReportColumn2 - Length(sToFields))))) to sToFields
98287>>>            End
98287>>>>
98287>>>            If (bExists = False) Begin
98289>>>                Move ("Relationship doesn't exist!" * String(CS_ReportDifferenceNote)) to sTo  
98290>>>                Move "" to sToFields
98291>>>            End
98291>>>>
98291>>>            
98291>>>            Writeln channel iCh sFrom sTo 
98295>>>            Writeln channel iCh sFromFields sToFields  
98299>>>            If (iCount < iSizeFrom) Begin
98301>>>                Writeln channel iCh
98303>>>            End
98303>>>>
98303>>>        Loop
98304>>>>
98304>>>    
98304>>>    End_Procedure                                                 
98305>>>    
98305>>>    Object oBusinessProcess is a BusinessProcess  
98307>>>        Set Status_Panel_Id to ghoStatusPanel
98308>>>        Set Allow_Cancel_State to True
98309>>>        Set Process_Caption to "The Database Update Framework"
98310>>>        Set Process_Title to "Comparing Database Structures..."
98311>>>//        Set Process_Message to "...for table:"
98311>>>//        Set Display_Error_State to True // Temp!
98311>>>    
98311>>>        Procedure OnProcess
98314>>>            Send StartComparing
98315>>>        End_Procedure                           
98316>>>        
98316>>>        Procedure Ignore_Error Integer iError
98319>>>        End_Procedure                        
98320>>>        Procedure Trap_Error Integer iError
98323>>>        End_Procedure 
98324>>>        
98324>>>    End_Object
98325>>>
98325>>>    Object oOK_Btn is a Button
98327>>>        Set Size to 14 47
98328>>>        Set Label to "Compare!"
98329>>>        Set Location to 195 334
98330>>>        Set peAnchors to anBottomRight
98331>>>        Set FontWeight to fw_Bold
98332>>>        Set Default_State to True
98333>>>
98333>>>        Procedure OnClick
98336>>>            String sFilelistFrom sFilelistTo 
98336>>>            Integer[] iaDifferences                         
98337>>>            Boolean bFromExists bToExists 
98337>>>            
98337>>>            Get Value of oFilelistPathFrom_fm to sFilelistFrom
98338>>>            Get vFilePathExists sFilelistFrom to bFromExists
98339>>>            Get Value of oFilelistPathTo_fm   to sFilelistTo
98340>>>            Get vFilePathExists sFilelistTo   to bToExists
98341>>>            If (bFromExists = False or bToExists = False) Begin
98343>>>                Send Info_Box "You need to both select a FROM and a TO database Filelist.cfg. Please adjust and try again."
98344>>>                Procedure_Return
98345>>>            End
98345>>>>
98345>>>            
98345>>>            Send DoProcess of oBusinessProcess
98346>>>            Send Reset_DF_OPEN_PATH
98347>>>        End_Procedure   
98348>>>        
98348>>>    End_Object
98349>>>
98349>>>    Object oViewReport_Btn is a cButton
98351>>>        Set Label    to "View Report"
98352>>>        Set Location to 195 392
98353>>>        Set peAnchors to anBottomRight
98354>>>
98354>>>        Procedure OnClick
98357>>>            String sReportName                            
98357>>>            Get Value of oReportFileName_fm to sReportName
98358>>>            Send vShellExecute "open" sReportName "" "" 
98359>>>        End_Procedure
98360>>>
98360>>>        Procedure DoEnable
98363>>>            String sReportName
98363>>>            Boolean bExists
98363>>>
98363>>>            Get Value of oReportFileName_fm to sReportName
98364>>>            Get vFilePathExists sReportName to bExists
98365>>>            Set Enabled_State to (bExists = True)
98366>>>        End_Procedure
98367>>>
98367>>>    End_Object
98368>>>
98368>>>    Object oTagFilelist_Btn is a Button
98370>>>        Set Size to 14 58
98371>>>        Set Label     to "&Tag Filelist Diff"
98372>>>        Set psToolTip to "Tag Tables in Filelist.cfg containing differences (for Code Generation) on the 'Code Generator' view page."
98373>>>        Set Location to 195 448
98374>>>        Set peAnchors to anBottomRight
98375>>>
98375>>>        Procedure OnClick 
98378>>>            Send TagFileNamesForCodeGeneration
98379>>>        End_Procedure
98380>>>
98380>>>    End_Object  
98381>>>    
98381>>>    // TEMP!
98381>>>    Set Value of oFilelistPathFrom_fm to "C:\DataFlex 19.0 Examples\Order Entry - Embedded Test 1\Data\Filelist.cfg"
98382>>>    Set Value of oFilelistPathTo_fm   to "C:\DataFlex 19.0 Examples\Order Entry - Embedded Test 2\Data\Filelist.cfg"
98383>>>    
98383>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
98384>>>    On_Key Key_Alt+Key_T Send KeyAction of oCancel_Btn
98385>>>End_Object
98386>>>
98386>>>//Procedure Activate_CompareDatabases String sFileListFrom
98386>>>//    Handle ho hoFilelistFrom hoTableDUFCodeGenerator_vw
98386>>>//    Boolean bTagFileNames                                                  
98386>>>//    Integer[] iaDifferences    
98386>>>//    
98386>>>//    Move (oCompareDatabases_vw(Self)) to ho
98386>>>//    Move (oFilelistPathFrom_fm(ho)) to hoFilelistFrom
98386>>>//    If (sFileListFrom <> "") Begin
98386>>>//        Set Value of hoFilelistFrom to sFileListFrom
98386>>>//    End
98386>>>//    
98386>>>//    Send Popup of ho               
98386>>>//    Send Activate_oCompareDatabases_vw
98386>>>//    
98386>>>//    Get pbTagFileNames of ho to bTagFileNames
98386>>>//    If (bTagFileNames = False) Begin
98386>>>//        Procedure_Return
98386>>>//    End                 
98386>>>//    
98386>>>//    Get Value of hoFilelistFrom to sFileListFrom
98386>>>//    Get piaDifferences    of ho to iaDifferences
98386>>>//    Get phoTableDUFCodeGenerator_vw of ghoApplication to hoTableDUFCodeGenerator_vw
98386>>>//    Send TagChangedTables of hoTableDUFCodeGenerator_vw sFileListFrom iaDifferences
98386>>>//End_Procedure
98386>        Use TableDUFCodeGenerator.vw
Including file: TableDUFCodeGenerator.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\TableDUFCodeGenerator.vw)
98386>>>Use Windows.pkg
98386>>>Use DFClient.pkg
98386>>>Use cCJGrid.pkg
98386>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridColumnRowIndicator.pkg)
98386>>>>>Use cCJGridColumn.pkg
98386>>>>>
98386>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
98387>>>>>    
98387>>>>>    Procedure Construct_Object
98389>>>>>        Forward Send Construct_Object
98391>>>>>    
98391>>>>>        Property Integer piImage 0
98392>>>>>        
98392>>>>>        Set psCaption to ""
98393>>>>>        Set piWidth to 20
98394>>>>>        Set pbResizable to False
98395>>>>>        Set pbEditable to False
98396>>>>>        Set pbFocusable to False
98397>>>>>        Set pbAllowDrag to False
98398>>>>>        Set psToolTip to "Row Indicator"
98399>>>>>//        Set Color to (RGB(217,222,243))   //JVH
98399>>>>>    End_Procedure
98400>>>>>    
98400>>>>>    Procedure OnCreateColumn
98402>>>>>        Integer iImage
98402>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
98404>>>>>        Set piImage to iImage
98405>>>>>    End_Procedure
98406>>>>>            
98406>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
98408>>>>>        Integer iImage iFocusedRow
98408>>>>>        Handle hoDataSource
98408>>>>>        
98408>>>>>        Get phoDataSource to hoDataSource
98409>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
98410>>>>>        Move -1 to iImage
98411>>>>>        If (iRow = iFocusedRow) Begin
98413>>>>>            Get piImage to iImage
98414>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
98415>>>>>        End
98415>>>>>>
98415>>>>>    End_Procedure
98416>>>>>
98416>>>>>End_Class
98417>>>Use cCJGridColumn.pkg
98417>>>Use dfLine.pkg
98417>>>Use seq_chnl.pkg
98417>>>Use vWin32fh.pkg
98417>>>Use cDbUpdateFunctionLibrary.pkg
98417>>>Use Batchdd.pkg
98417>>>Use DUFStatusPanel.pkg
98417>>>Use cButton.pkg
98417>>>
98417>>>Enum_List
98417>>>    Define cx_Select_All
98417>>>    Define cx_Select_None
98417>>>    Define cx_Select_Invert
98417>>>End_Enum_List
98417>>>
98417>>>Struct tGeneratorRow
98417>>>    Handle hTable
98417>>>    String sLogicalName
98417>>>    String sRootName
98417>>>    String sDisplayName 
98417>>>    Boolean bIsAlias
98417>>>    Boolean bSelected 
98417>>>End_Struct
98417>>>
98417>>>Activate_View Activate_oTableDUFCodeGenerator for oTableDUFCodeGenerator
98427>>>>
98427>>>Object oTableDUFCodeGenerator is a dbView
98429>>>    Set Size to 299 523
98430>>>    Set Location to 0 0
98431>>>    Set Label to "Code Generator"  
98432>>>    Set Icon to "DUFUpdateCodeGenerator.ico"
98433>>>//    Set Maximize_Icon to True
98433>>>    Set Border_Style to Border_Thick
98434>>>//    Set View_Mode to Viewmode_Zoom
98434>>>    Set pbAcceptDropFiles to True    
98435>>>    Set pbAutoActivate to True
98436>>>    Set phoTableDUFCodeGenerator_vw of ghoApplication to Self
98437>>>    
98437>>>    Property String psOrgOpenPath
98439>>>    
98439>>>    // Set psOrgOpenPath at startup
98439>>>    Procedure StartUp
98442>>>        String sOrgOpenPath sDataPath
98442>>>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
98445>>>        // First remove the current Data folder path
98445>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sOrgOpenPath 1 to sDataPath
98446>>>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
98447>>>        If (Left(sOrgOpenPath, 2) = "\;") Begin
98449>>>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
98450>>>        End
98450>>>>
98450>>>        Set psOrgOpenPath to sOrgOpenPath
98451>>>    End_Procedure                        
98452>>>    Send StartUp
98453>>>    
98453>>>    Object oInfo_tb is a TextBox
98455>>>        Set Auto_Size_State to False
98456>>>        Set Size to 25 424
98457>>>        Set Location to 12 19
98458>>>        Set Label to "This will generate Database Update Framework update code for the selected table(s). Include the generated package in your program's cDbUpdateHandler object and compile. When run at customer site, tables will either be updated (if table layout has changed) or created (if table doesn't exist on customer site)."
98459>>>        Set Justification_Mode to JMode_Left
98460>>>        Set peAnchors to anTopLeftRight
98461>>>    End_Object
98462>>>
98462>>>    Object oFilelistPath_fm is a Form
98464>>>        Set Size to 13 424
98465>>>        Set Location to 55 19
98466>>>        Set Label to "Please select a Filelist.cfg (F4) -or drag and drop one onto the form"
98467>>>        Set Label_Col_Offset to 0
98468>>>        Set Label_Row_Offset to 1
98469>>>        Set Label_Justification_Mode to JMode_Top
98470>>>        Set Prompt_Button_Mode to PB_PromptOn
98471>>>        Set peAnchors to anTopLeftRight 
98472>>>        Set Prompt_Object to Self
98473>>>        Set phoTableDUFCodeGeneratorFilelist of ghoApplication to Self
98474>>>        
98474>>>        Procedure Prompt
98477>>>            String sFileName sPath sFileMask sRetval
98477>>>
98477>>>            Get Value to sFileName
98478>>>            Get ParseFolderName sFileName to sPath
98479>>>            Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
98480>>>            Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
98481>>>            If (sRetval <> "") Begin     
98483>>>                Send Cursor_Wait of Cursor_Control
98484>>>                Set Value to sRetval
98485>>>            End
98485>>>>
98485>>>        End_Procedure
98486>>>
98486>>>        Procedure OnChange
98489>>>            String sFileList
98489>>>            Boolean bOK bExists bCfgFile
98489>>>            
98489>>>            Get Value to sFileList
98490>>>            Get vFilePathExists sFileList to bExists
98491>>>            Move (Lowercase(sFileList) contains ".cfg") to bCfgFile
98492>>>            If (bExists = True and bCfgFile) Begin 
98494>>>                // A little trick to show the filelist.cfg in the form before we start filling the grid.
98494>>>//                Send PumpMsgQueue of Desktop
98494>>>                Get ChangeFilelistPathing sFileList to bOK
98495>>>            End
98495>>>>
98495>>>        End_Procedure
98496>>>        
98496>>>        On_Key Key_Ctrl+Key_W Send None
98497>>>        On_Key Key_Ctrl+Key_Q Send None
98498>>>    End_Object
98499>>>
98499>>>    Object oFilelist_grd is a cCJGrid
98501>>>        Set Size to 91 424
98502>>>        Set Location to 79 19
98503>>>        Set pbUseAlternateRowBackgroundColor to True
98504>>>        Set psNoItemsText to "No Filelist.cfg selected yet..."
98505>>>        Set pbRestoreLayout to True
98506>>>        Set psLayoutSection to (Name(Self) + "_grid")
98507>>>        Set pbHeaderReorders to True
98508>>>        Set pbHeaderPrompts to False
98509>>>        Set pbHeaderTogglesDirection to True
98510>>>        Set pbSelectionEnable to True  
98511>>>        Set pbAllowInsertRow to False
98512>>>        Set pbAllowAppendRow to False
98513>>>        Set pbShowRowFocus to True
98514>>>        Set pbShowFooter to True
98515>>>        Set pbAllowDeleteRow to False
98516>>>        Set pbMultipleSelection to True
98517>>>        Set peAnchors to anAll
98518>>>        Set peVisualTheme to xtpReportThemeOffice2003
98519>>>        Set piLayoutBuild to 3
98520>>>        
98520>>>        Property Handle phDbVersion
98522>>>        Property Integer piCurrentRow -1
98524>>>
98524>>>        Set pbHotTracking to True
98525>>>        Set pbEditOnClick to True
98526>>>
98526>>>        Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
98528>>>            Set piWidth to 50
98529>>>        End_Object
98530>>>
98530>>>        Object oFilelistNumber_col is a cCJGridColumn
98532>>>            Set piWidth to 139
98533>>>            Set psCaption to "Filelist No"
98534>>>//            Set pbResizable to False
98534>>>            Set peDataType to Mask_Numeric_Window
98535>>>            Set pbEditable to False
98536>>>        End_Object
98537>>>
98537>>>        Object oLogicalName_col is a cCJGridColumn
98539>>>            Set piWidth to 296
98540>>>            Set psCaption to "Logical Name"
98541>>>            Set pbEditable to False
98542>>>        End_Object
98543>>>
98543>>>        Object oRootName_col is a cCJGridColumn
98545>>>            Set piWidth to 304
98546>>>            Set psCaption to "Table Name (Rootname)"
98547>>>            Set pbEditable to False
98548>>>        End_Object
98549>>>
98549>>>        Object oDisplayName_col is a cCJGridColumn
98551>>>            Set piWidth to 325
98552>>>            Set psCaption to "Display Name"
98553>>>            Set psFooterText to "No of Tables:"
98554>>>            Set pbEditable to False
98555>>>        End_Object 
98556>>>        
98556>>>        Object oIsAlias_Col is a cCJGridColumn
98558>>>            Set piWidth to 131
98559>>>            Set psCaption to "Is Alias"
98560>>>            Set pbCheckbox to True
98561>>>            Set peHeaderAlignment to xtpAlignmentCenter
98562>>>            Set peFooterAlignment to xtpAlignmentCenter
98563>>>            Set psFooterText to "Count:"
98564>>>//            Set pbEditable to False
98564>>>        End_Object
98565>>>
98565>>>        Object oCheckbox_Col is a cCJGridColumn
98567>>>            Set piWidth to 133
98568>>>            Set psCaption to "Select"
98569>>>            Set psToolTip to "Select table (easiest is to use the spacebar)"
98570>>>            Set pbCheckbox to True
98571>>>            Set peHeaderAlignment to xtpAlignmentCenter
98572>>>            Set peFooterAlignment to xtpAlignmentCenter
98573>>>            Set psFooterText to "Selected:"
98574>>>            Set peDataType to Mask_Numeric_Window
98575>>>        End_Object
98576>>>
98576>>>        Procedure LoadData
98579>>>            String sFileList sLogicalName
98579>>>            Handle hoDataSource hTable
98579>>>            tDataSourceRow[] TheData TheDataEmpty
98579>>>            tDataSourceRow[] TheData TheDataEmpty
98581>>>            Integer iRow iSize iTableNo iRoot iLogical iDisplay iIsAlias iChecked iAliasCount iNoOfTables iCount
98581>>>            Boolean bExists bIsAlias
98581>>>            
98581>>>            Get_Attribute DF_FILELIST_NAME to sFilelist
98584>>>            Get vFilePathExists sFileList to bExists
98585>>>            If (bExists = False) Begin
98587>>>                Procedure_Return
98588>>>            End                 
98588>>>>
98588>>>            
98588>>>            Send Cursor_Ready of Cursor_Control
98589>>>            Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Loading Filelist.cfg data" "...and checking for Alias tables"
98590>>>            Send Start_StatusPanel of ghoStatusPanel
98591>>>            Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTables
98592>>>            Set pbVisible of ghoProgressBar to True
98593>>>            Set pbVisible of ghoProgressBarOverall to False
98594>>>            Set piMaximum of ghoProgressBar to iNoOfTables
98595>>>            Move 0 to iCount
98596>>>            Get phoDataSource to hoDataSource 
98597>>>            Get DataSource of hoDataSource to TheData 
98598>>>            Move TheDataEmpty to TheData
98599>>>            Get piColumnId of oFilelistNumber_col to iTableNo
98600>>>            Get piColumnId of oRootName_col       to iRoot
98601>>>            Get piColumnid of oLogicalName_col    to iLogical
98602>>>            Get piColumnId of oDisplayName_col    to iDisplay
98603>>>            Get piColumnId of oIsAlias_Col        to iIsAlias
98604>>>            Get piColumnId of oCheckbox_Col       to iChecked
98605>>>            
98605>>>            Move 0 to hTable
98606>>>            Move 0 to iRow
98607>>>            Repeat
98607>>>>
98607>>>                Get_Attribute DF_FILE_NEXT_USED of hTable to hTable  
98610>>>                Set piPosition of ghoProgressBar to iCount
98611>>>                
98611>>>                If (hTable > 0 and hTable <> 50) Begin             
98613>>>                    Move hTable                                   to TheData[iRow].sValue[iTableNo]
98614>>>                    Get_Attribute DF_FILE_ROOT_NAME     of hTable to TheData[iRow].sValue[iRoot]
98617>>>                    Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
98620>>>                    Move sLogicalName                             to TheData[iRow].sValue[iLogical]
98621>>>                    If (Uppercase(sLogicalName) = "DBVERSION") Begin
98623>>>                        Set phDbVersion to hTable
98624>>>                    End
98624>>>>
98624>>>                    Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to TheData[iRow].sValue[iDisplay]
98627>>>                    Get UtilTableIsAlias of ghoDbUpdateFunctionLibrary hTable to bIsAlias
98628>>>                    Move bIsAlias                                 to TheData[iRow].sValue[iIsAlias] 
98629>>>                    If (bIsAlias = True) Begin
98631>>>                        Increment iAliasCount
98632>>>                    End
98632>>>>
98632>>>                    Move False to TheData[iRow].sValue[iChecked]
98633>>>                    Increment iRow
98634>>>                End    
98634>>>>
98634>>>                Increment iCount
98635>>>            Until (hTable = 0)
98637>>>            
98637>>>            Send ReInitializeData TheData False
98638>>>            Send MoveToFirstRow  
98639>>>            Set psFooterText of oDisplayName_col to ("No of Tables:" * String(iRow))
98640>>>            Set psFooterText of oIsAlias_Col     to ("Count:" * String(iAliasCount))
98641>>>            Send Stop_StatusPanel of ghoStatusPanel
98642>>>        End_Procedure  
98643>>>        
98643>>>        Function SelectedTableNumber Returns Handle
98646>>>            Integer hTable iTableNo iRowNo
98646>>>            Handle hoDataSource
98646>>>            tDataSourceRow[] TheData
98646>>>            tDataSourceRow[] TheData
98647>>>            
98647>>>            Get phoDataSource to hoDataSource  
98648>>>            Get piColumnId of oFilelistNumber_col to iTableNo
98649>>>            Get DataSource of hoDataSource to TheData
98650>>>            Get SelectedRow of hoDataSource to iRowNo
98651>>>            Move TheData[iRowNo].sValue[iTableNo] to hTable
98652>>>            
98652>>>            Function_Return hTable
98653>>>        End_Function
98654>>>        
98654>>>        Function GenerateSourceFileName Returns String
98657>>>            String sRetval sPath sFileListName sTableName sVersionNumber          
98657>>>            Boolean bExists
98657>>>            Integer iLogical iRowNo iSelected iPos
98657>>>            tDataSourceRow[] TheData
98657>>>            tDataSourceRow[] TheData
98658>>>            Handle hoDataSource
98658>>>            Number nVersionNumber
98658>>>            
98658>>>            Get Value of oFilelistPath_fm to sFileListName
98659>>>            Get vFilePathExists sFileListName to bExists
98660>>>            If (bExists = False) Begin
98662>>>                Function_Return ""
98663>>>            End
98663>>>>
98663>>>            
98663>>>            Get Value of oPnVersionNumber_fm to nVersionNumber
98664>>>            Move nVersionNumber to sVersionNumber 
98665>>>            Move (Pos(".", sVersionNumber)) to iPos
98666>>>            If (iPos = 0) Begin
98668>>>                Move (sVersionNumber + String(".0")) to sVersionNumber
98669>>>            End
98669>>>>
98669>>>            Move (Replaces(".", sVersionNumber, "_")) to sVersionNumber
98670>>>            
98670>>>            Get ParseFolderName sFileListName to sPath
98671>>>            Get vParentPath sPath   to sPath 
98672>>>            Get vFolderFormat sPath to sPath 
98673>>>            Move (sPath + "AppSrc") to sPath
98674>>>            Get vFolderFormat sPath to sPath    
98675>>>            
98675>>>            Get phoDataSource to hoDataSource  
98676>>>            Get piColumnid of oLogicalName_col to iLogical
98677>>>            Get DataSource of hoDataSource to TheData
98678>>>            Get CheckedItems to iSelected
98679>>>            If (iSelected > 1) Begin
98681>>>                Move "MultipleTables" to sTableName    
98682>>>            End 
98682>>>>
98682>>>            Else Begin
98683>>>                If (SizeOfArray(TheData) <> 0) Begin
98685>>>                    Get SelectedRow of hoDataSource to iRowNo
98686>>>                    Move TheData[iRowNo].sValue[iLogical] to sTableName 
98687>>>                End
98687>>>>
98687>>>            End
98687>>>>
98687>>>            Move ("DUF_" + sTableName + String(sVersionNumber) + ".pkg") to sTableName
98688>>>            
98688>>>            Move (sPath + sTableName) to sRetval
98689>>>            
98689>>>            Function_Return sRetval
98690>>>        End_Function
98691>>>
98691>>>        Function piCheckboxCol Returns Integer
98694>>>            Integer iIndex
98694>>>            Get piColumnId of oCheckbox_Col to iIndex
98695>>>            Function_Return iIndex
98696>>>        End_Function
98697>>>
98697>>>        // Returns the checked state for the checkbox column
98697>>>        // and the passed row number.
98697>>>        Function FindCheckedState Integer iRow Returns Boolean
98700>>>            Integer iCol
98700>>>            Handle hoDataSource
98700>>>            tDataSourceRow[] TheData
98700>>>            tDataSourceRow[] TheData
98701>>>            Boolean bChecked
98701>>>    
98701>>>            Get piCheckboxCol to iCol
98702>>>//            If (iCol < 0) Begin
98702>>>//                Send UserError "No piCheckboxCol has been set. Cannot return value"
98702>>>//                Procedure_Return
98702>>>//            End
98702>>>            Get phoDataSource               to hoDataSource
98703>>>            Get DataSource of hoDataSource  to TheData
98704>>>            Move TheData[iRow].sValue[iCol] to bChecked
98705>>>    
98705>>>            Function_Return bChecked
98706>>>        End_Function
98707>>>
98707>>>        Procedure DoSetCheckboxFooterText
98710>>>            Integer iCol iSelected
98710>>>            Handle hoCol
98710>>>            Get piCheckboxCol to iCol
98711>>>            Get ColumnObject iCol to hoCol
98712>>>            Get CheckedItems to iSelected
98713>>>            Set psFooterText of hoCol to ("Selected:" * String(iSelected))
98714>>>        End_Procedure
98715>>>
98715>>>        // Set checkboxes of the first column as selected.
98715>>>        // iState can be one of the following:
98715>>>        // cx_Select_All, cx_Select_None or cx_Select_Invert
98715>>>        Procedure Set SelectItems Integer iState
98718>>>            Integer i iItems
98718>>>            Integer iCheckbox_Col
98718>>>            Boolean bChecked
98718>>>            Handle hoDataSource
98718>>>            tDataSourceRow[] TheData
98718>>>            tDataSourceRow[] TheData
98719>>>            String[] sFilesArray   
98720>>>            String sSourceFile
98720>>>    
98720>>>            Get piColumnId of oCheckbox_Col to iCheckbox_Col
98721>>>            Get phoDataSource                to hoDataSource
98722>>>            Get DataSource of hoDataSource   to TheData
98723>>>            Move (SizeOfArray(TheData))      to iItems
98724>>>            Decrement iItems
98725>>>            For i from 0 to iItems
98731>>>>
98731>>>                Case Begin
98731>>>                    Case (iState = cx_Select_All)
98733>>>                        Move True to TheData[i].sValue[iCheckbox_Col]
98734>>>                        Break
98735>>>                    Case (iState = cx_Select_None)
98738>>>                        Move False to TheData[i].sValue[iCheckbox_Col]
98739>>>                        Break
98740>>>                    Case (iState = cx_Select_Invert)
98743>>>                        Move TheData[i].sValue[iCheckbox_Col] to bChecked
98744>>>                        Move (not(bChecked)) to  TheData[i].sValue[iCheckbox_Col]
98745>>>                        Break
98746>>>                Case End
98746>>>            Loop
98747>>>>
98747>>>
98747>>>            Send ReInitializeData TheData False
98748>>>            Send DoSetCheckboxFooterText
98749>>>            Get GenerateSourceFileName  to sSourceFile
98750>>>            Set Value of oSourceName_fm to sSourceFile
98751>>>        End_Procedure         
98752>>>        
98752>>>        // Selects all items
98752>>>        Procedure SelectAll
98755>>>            Set SelectItems to cx_Select_All
98756>>>        End_Procedure
98757>>>    
98757>>>        // Deselects all items
98757>>>        Procedure SelectNone
98760>>>            Set SelectItems to cx_Select_None
98761>>>        End_Procedure
98762>>>    
98762>>>        // Inverts the current selections
98762>>>        Procedure SelectInvert
98765>>>            Set SelectItems to cx_Select_Invert
98766>>>        End_Procedure
98767>>>    
98767>>>        // Returns a string array with the selected items.
98767>>>        Function SelectedItems Returns tGeneratorRow[]
98770>>>            Integer[] SelRows
98771>>>            Integer i iItems iSize iCheckbox_Col iFilelistNo_Col iLogical_Col iRoot_Col iDisplay_Col iIsAlias_Col
98771>>>            String sFileName
98771>>>            String[] sFilesArray
98772>>>            Handle hoDataSource
98772>>>            tDataSourceRow[] TheData
98772>>>            tDataSourceRow[] TheData
98773>>>            Boolean bChecked bIsAlias
98773>>>            tGeneratorRow[] GeneratorRowArray
98773>>>            tGeneratorRow[] GeneratorRowArray
98774>>>    
98774>>>            Get piColumnId of oFilelistNumber_col to iFilelistNo_Col 
98775>>>            Get piColumnId of oLogicalName_col    to iLogical_Col
98776>>>            Get piColumnId of oRootName_col       to iRoot_Col
98777>>>            Get piColumnId of oDisplayName_col    to iDisplay_Col
98778>>>            Get piColumnId of oIsAlias_Col        to iIsAlias_Col
98779>>>            Get piColumnId of oCheckbox_Col       to iCheckbox_Col
98780>>>
98780>>>            Get phoDataSource to hoDataSource
98781>>>            Get DataSource of hoDataSource to TheData
98782>>>            Move (SizeOfArray(TheData)) to iItems
98783>>>            Decrement iItems
98784>>>    
98784>>>            For i from 0 to iItems
98790>>>>
98790>>>                Move TheData[i].sValue[iCheckbox_Col] to bChecked
98791>>>                If (bChecked = True) Begin
98793>>>                    Move (SizeOfArray(GeneratorRowArray)) to iSize
98794>>>                    Move TheData[i].sValue[iFilelistNo_Col] to GeneratorRowArray[iSize].hTable
98795>>>                    Move TheData[i].sValue[iLogical_Col]    to GeneratorRowArray[iSize].sLogicalName
98796>>>                    Move TheData[i].sValue[iRoot_Col]       to GeneratorRowArray[iSize].sRootName
98797>>>                    Move TheData[i].sValue[iDisplay_Col]    to GeneratorRowArray[iSize].sDisplayName 
98798>>>                    Move TheData[i].sValue[iIsAlias_Col]    to GeneratorRowArray[iSize].bIsAlias
98799>>>                    Move TheData[i].sValue[iCheckbox_Col]   to GeneratorRowArray[iSize].bSelected
98800>>>                    Move sFileName to sFilesArray[iSize]
98801>>>                End
98801>>>>
98801>>>            Loop
98802>>>>
98802>>>    
98802>>>            Function_Return GeneratorRowArray
98803>>>        End_Function
98804>>>    
98804>>>        // Returns the number of items that has been selected.
98804>>>        // It is a bit confusing with the SelectedItems function above,
98804>>>        // but it is how it was designed from the beginning. The
98804>>>        // SelectedItems function returns an array of all selected files,
98804>>>        // while this function returns the number of selected items only.
98804>>>        // The purpose is to use it in e.g. a checkbox grid column object
98804>>>        // to show the current no of selected items.
98804>>>        Function CheckedItems Returns Integer
98807>>>            Integer iCount iItems iCheckbox_Col iRetval
98807>>>            Handle hoDataSource
98807>>>            tDataSourceRow[] TheData
98807>>>            tDataSourceRow[] TheData
98808>>>            Boolean bChecked
98808>>>    
98808>>>            Get piCheckboxCol to iCheckbox_Col
98809>>>            Get phoDataSource to hoDataSource
98810>>>            Get DataSource of hoDataSource to TheData
98811>>>            Move (SizeOfArray(TheData)) to iItems
98812>>>            Decrement iItems
98813>>>    
98813>>>            For iCount from 0 to iItems
98819>>>>
98819>>>                Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
98820>>>                If (bChecked = True) Begin
98822>>>                    Increment iRetval
98823>>>                End
98823>>>>
98823>>>            Loop
98824>>>>
98824>>>    
98824>>>            Function_Return iRetval
98825>>>        End_Function
98826>>>        
98826>>>        // Toggles the current row on/off (the checkbox)
98826>>>        Procedure ToggleCurrentItem
98829>>>            Boolean bChecked
98829>>>            Integer iCol
98829>>>            Handle hoCol
98829>>>            String sSourceFile
98829>>>    
98829>>>            Get piCheckboxCol       to iCol
98830>>>            Get ColumnObject iCol   to hoCol
98831>>>            Get SelectedRowValue    of hoCol to bChecked
98832>>>            Send UpdateCurrentValue of hoCol (not(bChecked))
98833>>>            Send Request_Save
98834>>>            Get GenerateSourceFileName  to sSourceFile
98835>>>            Set Value of oSourceName_fm to sSourceFile
98836>>>            Send DoSetCheckboxFooterText
98837>>>        End_Procedure
98838>>>    
98838>>>        Procedure Request_Clear
98841>>>            Delegate Send Request_Clear
98843>>>        End_Procedure
98844>>>
98844>>>        Procedure OnComMouseUp Short llButton Short llShift Integer llx Integer lly
98847>>>            Forward Send OnComMouseUp llButton llShift llx lly
98849>>>            Send Request_Save
98850>>>            Send DoSetCheckboxFooterText
98851>>>        End_Procedure
98852>>>    
98852>>>        Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
98855>>>            String sSourceFile
98855>>>            Handle hTable
98855>>>            
98855>>>            Forward Send OnRowChanged iOldRow iNewSelectedRow
98857>>>
98857>>>            Get SelectedTableNumber to hTable
98858>>>            Get GenerateSourceFileName  to sSourceFile
98859>>>            Set Value of oSourceName_fm to sSourceFile
98860>>>            Set piCurrentRow to iNewSelectedRow
98861>>>        End_Procedure
98862>>>        
98862>>>    End_Object
98863>>>
98863>>>    Object oSelectAll_btn is a Button
98865>>>        Set Size to 14 61
98866>>>        Set Location to 89 449
98867>>>        Set Label to "Select &All"
98868>>>        Set MultiLineState to True
98869>>>        Set peAnchors to anTopRight
98870>>>        Procedure OnClick
98873>>>            Set SelectItems of oFilelist_grd to cx_Select_All
98874>>>        End_Procedure
98875>>>
98875>>>    End_Object
98876>>>
98876>>>    Object oDeSelectAll_btn is a Button
98878>>>        Set Size to 14 61
98879>>>        Set Location to 105 449
98880>>>        Set Label to "Select &None"
98881>>>        Set peAnchors to anTopRight
98882>>>        Procedure OnClick
98885>>>            Set SelectItems of oFilelist_grd to cx_Select_None
98886>>>        End_Procedure
98887>>>
98887>>>    End_Object
98888>>>
98888>>>    Object oInvertSelection_btn is a Button
98890>>>        Set Size to 14 61
98891>>>        Set Location to 121 449
98892>>>        Set Label to "&Invert Selection"
98893>>>        Set peAnchors to anTopRight
98894>>>        Procedure OnClick
98897>>>            Set SelectItems of oFilelist_grd to cx_Select_Invert
98898>>>        End_Procedure
98899>>>    End_Object
98900>>>
98900>>>//    Object oSelectedTableNo_fm is a Form
98900>>>//        Set Size to 13 24
98900>>>//        Set Location to 200 19
98900>>>//        Set peAnchors to anBottomLeft
98900>>>//        Set Label to "Selected Table Number"
98900>>>//        Set Label_Col_Offset to 0
98900>>>//        Set Label_Row_Offset to 1
98900>>>//        Set Label_Justification_Mode to JMode_Top
98900>>>//        Set Enabled_State to False
98900>>>//    End_Object
98900>>>
98900>>>    Object oOptions_grp is a Group
98902>>>        Set Size to 47 424
98903>>>        Set Location to 185 19
98904>>>        Set Label to "Properties to be set for the cDbUpdateVersion Object"
98905>>>        Set peAnchors to anBottomLeftRight
98906>>>
98906>>>        Object oUseConnectionID_cb is a CheckBox
98908>>>            Set Auto_Size_State to False
98909>>>            Set Size to 9 78
98910>>>            Set Location to 14 5
98911>>>            Set Label to "pbUseConnectionID"
98912>>>            Set Checked_State to True
98913>>>            Set psToolTip to "If True (the default); uses the Connection ID of the connection string as defined by the SQLConnection.ini setting"
98914>>>        End_Object
98915>>>
98915>>>        Object oANSI_cb is a CheckBox
98917>>>            Set Auto_Size_State to False
98918>>>            Set Size to 9 37
98919>>>            Set Location to 14 110
98920>>>            Set Label to "pbANSI"
98921>>>            Set Checked_State to True
98922>>>            Set psToolTip to "DataFlex data is stored in OEM format. Non-DataFlex back ends may expect the data to be stored in ANSI format. When defining the conversion options you can define the table character format to be used in the converted table."
98923>>>        End_Object
98924>>>
98924>>>        Object oRecnum_cb is a CheckBox
98926>>>            Set Auto_Size_State to False
98927>>>            Set Size to 9 46
98928>>>            Set Location to 14 217
98929>>>            Set Label to "pbRecnum"
98930>>>            Set Checked_State to True
98931>>>            Set psToolTip to "If the program that is using the source database uses the recnum programming style, the tables should be converted to recnum tables. If the program uses the RowId programming style, converting to standard tables is recommended."
98932>>>        End_Object
98933>>>        
98933>>>        // ToDo: The pbApiTableUpdateAuto flag has not been implemented yet!
98933>>>        Object oApiTableUpdateAuto_cb is a CheckBox
98935>>>            Set Auto_Size_State to False
98936>>>            Set Size to 9 93
98937>>>            Set Location to 14 327
98938>>>            Set Label to "pbApiTableUpdateAuto"
98939>>>            Set psToolTip to "When set to True, 'To' tables will get converted to the same database format as the 'From' tables. So if a 'From' table is an SQL table and the 'To' table is in the embedded format (DataFlex table), it will be converted to SQL."
98940>>>        End_Object
98941>>>
98941>>>        Object oCompareDate_DataTime_cb is a CheckBox
98943>>>            Set Auto_Size_State to False
98944>>>            Set Size to 9 101
98945>>>            Set Location to 27 5
98946>>>            Set Label to "pbCompareDate_DataTime"
98947>>>            Set Checked_State to False
98948>>>            Set psToolTip to "Check Date to DateTime column differences"
98949>>>        End_Object
98950>>>
98950>>>        Object oCompareIndexAscending_cb is a CheckBox
98952>>>            Set Auto_Size_State to False
98953>>>            Set Size to 9 103
98954>>>            Set Location to 27 110
98955>>>            Set Label to "pbCompareIndexAscending"
98956>>>            Set Checked_State to False
98957>>>            Set psToolTip to "Compare if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
98958>>>        End_Object
98959>>>
98959>>>        Object oCompareIndexUppercase_cb is a CheckBox
98961>>>            Set Auto_Size_State to False
98962>>>            Set Size to 9 104
98963>>>            Set Location to 27 217
98964>>>            Set Label to "pbCompareIndexUppercase"
98965>>>            Set Checked_State to False
98966>>>            Set psToolTip to "Compare if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
98967>>>        End_Object
98968>>>
98968>>>        Object oIgnoreFilelistUppercase_cb is a CheckBox
98970>>>            Set Auto_Size_State to False
98971>>>            Set Size to 9 158
98972>>>            Set Location to 27 327
98973>>>            Set Label to "Ignore Filelist Entries Uppercase/Lowercase"
98974>>>            Set Checked_State to True
98975>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
98976>>>        End_Object
98977>>>
98977>>>    End_Object
98978>>>
98978>>>    Object oPnVersionNumber_fm is a Form
98980>>>        Set Size to 13 24
98981>>>        Set Location to 243 100
98982>>>        Set Label to "Next pnVersionNumber" 
98983>>>        Set psToolTip to "This value is the current DbVersion.DatabaseVersion value, with a value of 0.1 added to it."
98984>>>        Set Value to 0
98985>>>        Set peAnchors to anBottomLeft
98986>>>        Set Label_Justification_Mode to JMode_Right
98987>>>        Set Label_Col_Offset to 2
98988>>>        Set Form_Datatype to Mask_Numeric_Window
98989>>>        Set Numeric_Mask 0 to 4 1  
98990>>>        
98990>>>        Procedure OnChange
98993>>>            String sSourceFile
98993>>>            Get GenerateSourceFileName of oFilelist_grd  to sSourceFile
98994>>>            Set Value of oSourceName_fm to sSourceFile
98995>>>        End_Procedure   
98996>>>        
98996>>>    End_Object
98997>>>
98997>>>    Object oSourceName_fm is a Form
98999>>>        Set Size to 13 424
99000>>>        Set Location to 270 19
99001>>>        Set peAnchors to anBottomLeftRight
99002>>>        Set Label_Col_Offset to 0
99003>>>        Set Label_Justification_Mode to JMode_Top
99004>>>        Set Label_Row_Offset to 1
99005>>>        Set Label to "Source File Name:  (cDbVersion Object Code Package)"
99006>>>    End_Object
99007>>>
99007>>>    Object oGenerateCode_btn is a Button
99009>>>        Set Size to 14 54
99010>>>        Set Location to 261 449
99011>>>        Set Label to "Generate Code!"
99012>>>        Set FontWeight to fw_Bold
99013>>>        Set peAnchors to anBottomRight
99014>>>        Set psToolTip to "Start generating Database Update Framework code for the selected table(s)."
99015>>>        Set Default_State to True
99016>>>    
99016>>>        Procedure OnClick
99019>>>            Boolean bExists
99019>>>            String sSourceFile
99019>>>            Integer iSelected
99019>>>            
99019>>>            Get Value of oSourceName_fm to sSourceFile
99020>>>            Get vFilePathExists sSourceFile to bExists
99021>>>            If (bExists = True) Begin
99023>>>                Send Info_Box ("Oops, the source file" * sSourceFile * "already exists!\n\nPlease; either change the source file name to be generated or use the 'Open Location' button and delete the existing file, then try again.")
99024>>>                Procedure_Return
99025>>>            End 
99025>>>>
99025>>>            
99025>>>            Get CheckedItems  of oFilelist_grd to iSelected
99026>>>            If (iSelected = 0) Begin
99028>>>                Send Info_Box "No tables selected. Please adjust and try again."
99029>>>                Procedure_Return
99030>>>            End   
99030>>>>
99030>>>            
99030>>>            Send DoProcess of oBusinessProcess
99031>>>            Send Reset_DF_OPEN_PATH
99032>>>        End_Procedure
99033>>>        
99033>>>    End_Object
99034>>>
99034>>>    Object oOpenAppSrcFolder_fm is a cButton
99036>>>        Set Size to 14 61
99037>>>        Set Location to 277 449
99038>>>        Set Label to "Open Location"
99039>>>        Set peAnchors to anBottomRight
99040>>>        Set psToolTip to "Open the source location in Windows Explorer"
99041>>>    
99041>>>        Procedure OnClick
99044>>>            String sPath sSourceName
99044>>>            Get Value of oSourceName_fm to sSourceName
99045>>>            Get ParseFolderName sSourceName to sPath
99046>>>            Send vShellExecute "open" "Explorer.exe" sPath ""
99047>>>        End_Procedure
99048>>>    
99048>>>        Procedure DoEnable
99051>>>            String sSourceName
99051>>>            Boolean bExists
99051>>>
99051>>>            Get Value of oSourceName_fm to sSourceName
99052>>>            Get vFilePathExists sSourceName to bExists
99053>>>            Set Enabled_State to (bExists = True)
99054>>>        End_Procedure
99055>>>
99055>>>    End_Object
99056>>>
99056>>>    Procedure StartGenerateCode
99059>>>        String sSourceFile
99059>>>        Boolean bUseConnectionID bANSI bRecnum bCompare_DateTime bCompareIndexUppercase bCompareIndexAscending                        
99059>>>        Handle hTable
99059>>>        Number nVersionNumber
99059>>>        tGeneratorRow[] TheData
99059>>>        tGeneratorRow[] TheData
99060>>>        tAPITableBooleans CompareTableBooleans
99060>>>        tAPITableBooleans CompareTableBooleans
99060>>>        
99060>>>        Get Value of oSourceName_fm                     to sSourceFile
99061>>>        Get Checked_State of oUseConnectionID_cb        to bUseConnectionID
99062>>>        Get Checked_State of oANSI_cb                   to bANSI
99063>>>        Get Checked_State of oRecnum_cb                 to bRecnum
99064>>>
99064>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareTableBooleans.bCompareDate_DateTime
99065>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareTableBooleans.bCompareIndexAscending
99066>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareTableBooleans.bCompareIndexUppercase
99067>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareTableBooleans.bCompareFilelistUppercase
99068>>>        
99068>>>        Get SelectedItems of oFilelist_grd to TheData
99069>>>        Get Value of oPnVersionNumber_fm to nVersionNumber
99070>>>        Send GenerateDUFSourceCode sSourceFile TheData nVersionNumber bUseConnectionID bANSI bRecnum CompareTableBooleans
99071>>>    End_Procedure                                                       
99072>>>    
99072>>>    Procedure GenerateDUFSourceCode String sSourceFile tGeneratorRow[] TheData Number nVersionNumber Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPITableBooleans CompareTableBooleans
99075>>>        Boolean bCompare_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase
99075>>>        Integer iCh iNumColumns iColumn iLength iPrecision iOptions iCount iSize iTable iTables
99075>>>        Integer iIndex iIndexes iSegment iNumSegments iToColumn iType iErrors iStatus
99075>>>        Boolean bOpened bOK bDawSqlDriver bPrimaryKey bIsAlias bSqlDriver bSkipTable
99075>>>        String sRootName sLogicalName sDisplayName sTableName sFieldName sIndexSegments sDataType sDriverID
99075>>>        Handle hParent hTable 
99075>>>        tAPITableNameInfo  APITableNameInfo
99075>>>        tAPITableNameInfo  APITableNameInfo
99075>>>        tAPIColumn[]   APIColumns
99075>>>        tAPIColumn[]   APIColumns
99076>>>        tAPIRelation[] APIRelations
99076>>>        tAPIRelation[] APIRelations
99077>>>        tAPIIndex[]    APIIndexes  
99077>>>        tAPIIndex[]    APIIndexes  
99078>>>        DateTime dtCreationTime
99078>>>        
99078>>>        Move (CurrentDateTime()) to dtCreationTime
99079>>>        Move 0 to iErrors
99080>>>        Move (SizeOfArray(TheData)) to iTables
99081>>>        Decrement iTables
99082>>>        Move 0 to iTable
99083>>>        Move TheData[iTable].hTable to hTable
99084>>>
99084>>>        Get Seq_Open_Output_Channel sSourceFile to iCh
99085>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
99087>>>            Send Stop_Box "Sorry, couldn't retrieve a free channel number."
99088>>>            Procedure_Return
99089>>>        End
99089>>>>
99089>>>        
99089>>>        If (hTable < 1 or nVersionNumber <= 0) Begin
99091>>>            Send Stop_Box "Table number and pnVersionNumber both needs to be > 0"
99092>>>            Procedure_Return
99093>>>        End
99093>>>>
99093>>>        
99093>>>        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Generating Update Code" ""
99094>>>        Send Start_StatusPanel of ghoStatusPanel
99095>>>        Set pbVisible of ghoProgressBar to True
99096>>>        Set pbVisible of ghoProgressBarOverall to True
99097>>>        Set piMaximum of ghoProgressBarOverall to iTables
99098>>>
99098>>>        Move CompareTableBooleans.bCompareDate_DateTime     to bCompare_DateTime
99099>>>        Move CompareTableBooleans.bCompareFilelistUppercase to bCompareFilelistUppercase
99100>>>        Move CompareTableBooleans.bCompareIndexAscending    to bCompareIndexAscending
99101>>>        Move CompareTableBooleans.bCompareIndexUppercase    to bCompareIndexUppercase
99102>>>        
99102>>>        Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
99103>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
99106>>>        If (bOpened = False) Begin
99108>>>            Send Seq_Close_Channel iCh
99109>>>            Send Stop_Box ("Sorry, couldn't open the table! (Table No:" * String(hTable) * ")")
99110>>>            Procedure_Return
99111>>>        End                 
99111>>>>
99111>>>        
99111>>>        Writeln channel iCh ("/" + "/ Created by: 'DUF Update Code Generator'. Created:" * String(dtCreationTime))
99114>>>        Writeln channel iCh ("Use cDbUpdateVersion.pkg")
99117>>>        Writeln channel iCh
99119>>>        Writeln channel iCh ("Object oDbUdpateVersion" + String(nVersionNumber) * "is a cDbUpdateVersion")
99122>>>        Writeln channel iCh ("    Set pnVersionNumber to" * String(nVersionNumber))
99125>>>        Writeln channel iCh ("    Procedure OnUpdate")
99128>>>        Writeln channel iCh ("        Boolean bOK") 
99131>>>        Writeln channel iCh ("        tAPITableNameInfo APITableNameInfo")
99134>>>        Writeln channel iCh ("        tAPIColumn[]   APIColumns APIColumnEmpty")
99137>>>        Writeln channel iCh ("        tAPIIndex[]    APIIndexes APIIndexEmpty")
99140>>>        Writeln channel iCh ("        tAPIRelation[] APIRelations APIRelationEmpty")
99143>>>        Writeln channel iCh ("        Integer iCount iSegment")
99146>>>        Writeln channel iCh
99148>>>        Writeln channel iCh ("        Set pbUseConnectionID       to" * If(bUseConnectionID, "True", "False"))
99151>>>        Writeln channel iCh ("        Set pbToAnsi                to" * If(bANSI, "True", "False")) 
99154>>>        Writeln channel iCh ("        Set pbRecnum                to" * If(bRecnum, "True", "False"))
99157>>>        Writeln channel iCh ("        Set pbCompareDate_DateTime  to" * If(bCompare_DateTime, "True", "False"))
99160>>>        Writeln channel iCh ("        Set pbCompareIndexAscending to" * If(bCompareIndexAscending, "True", "False"))
99163>>>        Writeln channel iCh ("        Set pbCompareIndexUppercase to" * If(bCompareIndexUppercase, "True", "False"))
99166>>>        Writeln channel iCh ("        Move 0 to iCount")
99169>>>        Writeln channel iCh
99171>>>
99171>>>        // Create Definitions:
99171>>>        Move 0 to iTable
99172>>>        For iTable from 0 to iTables
99178>>>>
99178>>>            Set piPosition of ghoProgressBarOverall to iTable
99179>>>            Move TheData[iTable].hTable to hTable
99180>>>            Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
99181>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
99184>>>            If (bOpened = False) Begin
99186>>>                Send Stop_StatusPanel of ghoStatusPanel
99187>>>                Send Seq_Close_Channel iCh
99188>>>                Send Stop_Box ("Sorry, couldn't open the table! (Table No:" * String(hTable) * TheData[iTable].sLogicalName + ")")
99189>>>                Procedure_Return
99190>>>            End                 
99190>>>>
99190>>>
99190>>>            Move (Uppercase(TheData[iTable].sLogicalName) = "DBVERSION" or Uppercase(TheData[iTable].sLogicalName) = "CODETYPE" or Uppercase(TheData[iTable].sLogicalName) = "CODEMAST") to bSkipTable
99191>>>
99191>>>            If (bSkipTable = False) Begin                                           
99193>>>                Move TheData[iTable].sLogicalName to APITableNameInfo.sLogicalName
99194>>>                Set Action_Text of ghoStatusPanel to (sLogicalName * "No:" * String(APITableNameInfo.iTableNumber))
99195>>>                
99195>>>                Move hTable                       to APITableNameInfo.iTableNumber
99196>>>                Move TheData[iTable].sRootName    to sRootName
99197>>>                Get _TableNameOnly of ghoDbUpdateFunctionLibrary sRootName to sTableName
99198>>>                Move sRootName                    to APITableNameInfo.sRootName
99199>>>
99199>>>                Move TheData[iTable].sDisplayName to APITableNameInfo.sDisplayName
99200>>>                Move TheData[iTable].bIsAlias     to APITableNameInfo.bIsAlias
99201>>>                Get UtilTableIsSQL of ghoDbUpdateFunctionLibrary hTable to APITableNameInfo.bIsSQL
99202>>>                
99202>>>                // Get the Driver ID 
99202>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
99205>>>                Get IsDAWSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bDawSqlDriver
99206>>>                Get IsSQLDriver    of ghoDbUpdateFunctionLibrary sDriverID to bSqlDriver
99207>>>                
99207>>>                If (bIsAlias = False) Begin                                
99209>>>                    Set Action_Text of ghoStatusPanel to (String(APITableNameInfo.sLogicalName) * "No:" * String(APITableNameInfo.iTableNumber))
99210>>>                    Get UtilColumnsStructFill of ghoDbUpdateFunctionLibrary hTable to APIColumns
99211>>>                    Move (SizeOfArray(APIColumns)) to iSize
99212>>>                    Decrement iSize
99213>>>                    If (iSize >= 0) Begin
99215>>>                        Writeln channel iCh ("        // Logical Table Name:" * '"' + APITableNameInfo.sLogicalName + '"' * "Filelist.cfg Number:" * String(APITableNameInfo.iTableNumber))
99218>>>                        Writeln channel iCh ("        Move" * String(APITableNameInfo.iTableNumber)                  * "to APITableNameInfo.iTableNumber")
99221>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sRootName)    + '"'      * "to APITableNameInfo.sRootName")
99224>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sLogicalName) + '"'      * "to APITableNameInfo.sLogicalName")
99227>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sDisplayName) + '"'      * "to APITableNameInfo.sDisplayName")
99230>>>                        Writeln channel iCh ("        Move" * '"' + String(sDriverID)                     + '"'      * "to APITableNameInfo.sDriverID")
99233>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsAlias, "True", "False")) * "to APITableNameInfo.bIsAlias")
99236>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSQL,   "True", "False")) * "to APITableNameInfo.bIsSQL") 
99239>>>                        Writeln channel iCh
99241>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column: 1")
99244>>>                    End
99244>>>>
99244>>>    
99244>>>                    For iCount from 0 to iSize
99250>>>>
99250>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iFieldNumber)       * "to APIColumns[iCount].iFieldNumber")
99253>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sFieldName)   + '"' * "to APIColumns[iCount].sFieldName")
99256>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iType)              * "to APIColumns[iCount].iType")
99259>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bIsSQLType, "True", "False")) * "to APIColumns[iCount].bIsSQLType") 
99262>>>                        If (APIColumns[iCount].iFieldNumber = 0 and APIColumns[iCount].iLength = 0) Begin
99264>>>                            Writeln channel iCh ("        ERROR! This field has a length = 0! It must be corrected before running this code")
99267>>>                            Increment iErrors
99268>>>                        End                  
99268>>>>
99268>>>                        Move APIColumns[iCount].sType to sDataType
99269>>>                        If (Lowercase(sDataType) contains "identity") Begin
99271>>>                            Move (Replace("identity",sDataType, "")) to sDataType
99272>>>                            Move (Trim(sDataType)) to sDataType
99273>>>                        End
99273>>>>
99273>>>                        Writeln channel iCh ("        Move" * '"' + sDataType                               + '"' * "to APIColumns[iCount].sType")
99276>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iLength)            * "to APIColumns[iCount].iLength")
99279>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iPrecision)         * "to APIColumns[iCount].iPrecision")
99282>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iOptions)           * "to APIColumns[iCount].iOptions")
99285>>>    
99285>>>                        If (iCount < iSize) Begin
99287>>>                            Writeln channel iCh ("        Increment iCount")
99290>>>                            Writeln channel iCh                                
99292>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column:" * String(iCount + 2))
99295>>>                        End
99295>>>>
99295>>>                    Loop
99296>>>>
99296>>>                                      
99296>>>                    // Create Relation Definitions:  
99296>>>// ToDo: There seems to be something wrong with the relation ship logic. Comment out for now.
99296>>>                    Get UtilRelationStructFill of ghoDbUpdateFunctionLibrary hTable to APIRelations
99297>>>                    Move (SizeOfArray(APIRelations)) to iSize
99298>>>                    Decrement iSize
99299>>>                    If (iSize >= 0) Begin
99301>>>                        Writeln channel iCh
99303>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation: 1")
99306>>>                        Writeln channel iCh ("        Move 0 to iCount")
99309>>>                    End
99309>>>>
99309>>>                    For iCount from 0 to iSize
99315>>>>
99315>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableFrom)  * "to APIRelations[iCount].hTableFrom")
99318>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnFrom) * "to APIRelations[iCount].iColumnFrom")
99321>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableTo)    * "to APIRelations[iCount].hTableTo")
99324>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnTo)   * "to APIRelations[iCount].iColumnTo")
99327>>>                        If (iCount < iSize) Begin
99329>>>                            Writeln channel iCh ("        Increment iCount")
99332>>>                            Writeln channel iCh                                
99334>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation:" * String(iCount + 2))
99337>>>                        End
99337>>>>
99337>>>                    Loop                                                    
99338>>>>
99338>>>    
99338>>>                    // Create Index Definitions:
99338>>>                    Get UtilIndexesStructFill of ghoDbUpdateFunctionLibrary hTable to APIIndexes
99339>>>                    Move (SizeOfArray(APIIndexes)) to iIndexes
99340>>>                    Decrement iIndexes
99341>>>                    If (iIndexes >= 0) Begin
99343>>>                        Writeln channel iCh
99345>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index: 1")
99348>>>                        Writeln channel iCh ("        Move 0 to iCount")
99351>>>                        Writeln channel iCh ("        Move 0 to iSegment")
99354>>>                    End
99354>>>>
99354>>>                    For iIndex from 0 to iIndexes
99360>>>>
99360>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iIndexNumber)        * "to APIIndexes[iCount].iIndexNumber")
99363>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iSQLIndexType)       * "to APIIndexes[iCount].iSQLIndexType")
99366>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsPrimaryKey), "True", "False") * "to APIIndexes[iCount].bIsPrimaryKey")
99369>>>                        If (APIIndexes[iIndex].sSQLIndexName <> "") Begin
99371>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].sSQLIndexName) + '"' * "to APIIndexes[iCount].sSQLIndexName")
99374>>>                        End
99374>>>>
99374>>>                        
99374>>>                        Move (SizeOfArray(APIIndexes[iIndex].IndexSegmentArray)) to iNumSegments
99375>>>                        Decrement iNumSegments
99376>>>                        For iSegment from 0 to iNumSegments     
99382>>>>
99382>>>                            Writeln channel iCh ("        Move" *       String(APIIndexes[iIndex].IndexSegmentArray[iSegment].iFieldNumber)              * "to APIIndexes[iCount].IndexSegmentArray[iSegment].iFieldNumber")
99385>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].IndexSegmentArray[iSegment].sFieldName)          + '"' * "to APIIndexes[iCount].IndexSegmentArray[iSegment].sFieldName")
99388>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bUppercase), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bUppercase")
99391>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bAscending), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bAscending")
99394>>>                            If (iSegment < iNumSegments) Begin
99396>>>                                Writeln channel iCh ("        Increment iSegment")
99399>>>                            End
99399>>>>
99399>>>                        Loop
99400>>>>
99400>>>                            
99400>>>                        If (iIndex < iIndexes) Begin
99402>>>//                            Writeln channel iCh ("        Increment iSegment")
99402>>>                            Writeln channel iCh ("        Increment iCount")
99405>>>                            Writeln channel iCh                                
99407>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index:" * String(iIndex + 2))
99410>>>                            Writeln channel iCh ("        Move 0 to iSegment")
99413>>>                        End
99413>>>>
99413>>>                    Loop                              
99414>>>>
99414>>>                    
99414>>>                    // Create Table Update Definition:
99414>>>                    Writeln channel iCh                                
99416>>>                    Writeln channel iCh ("        Get ApiTableUpdate APITableNameInfo APIColumns APIIndexes APIRelations to bOK")
99419>>>                    Writeln channel iCh                                
99421>>>                    
99421>>>                    Writeln channel iCh ("        Move APIColumnEmpty   to APIColumns")
99424>>>                    Writeln channel iCh ("        Move APIRelationEmpty to APIRelations")
99427>>>                    Writeln channel iCh ("        Move APIIndexEmpty    to APIIndexes")
99430>>>                    Writeln channel iCh ("        Move 0 to iCount")
99433>>>                    Writeln channel iCh                                
99435>>>                End
99435>>>>
99435>>>                
99435>>>                If (bIsAlias = True) Begin
99437>>>                    // Create Alias Table Definition:
99437>>>                    Writeln channel iCh ("        // Create Alias Table Definition:")
99440>>>                    Writeln channel iCh ("        Move" * String(hTable) * "to hTable")
99443>>>                    If (bSqlDriver = True) Begin
99445>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + sDriverID + ":" + APITableNameInfo.sRootName    + '"')
99448>>>                    End 
99448>>>>
99448>>>                    Else Begin
99449>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + APITableNameInfo.sRootName    + '"')
99452>>>                    End
99452>>>>
99452>>>                        
99452>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to" * '"' + APITableNameInfo.sLogicalName + '"')
99455>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to" * '"' + APITableNameInfo.sDisplayName + '"')
99458>>>                    Writeln channel iCh                                
99460>>>                End
99460>>>>
99460>>>            End   
99460>>>>
99460>>>            Get Check_StatusPanel of ghoStatusPanel to iStatus
99461>>>            If (iStatus <> 0) Begin
99463>>>                Send Seq_Close_Channel iCh  
99464>>>                Send Stop_StatusPanel
99465>>>                Procedure_Return
99466>>>            End
99466>>>>
99466>>>        Loop // Main TheData loop
99467>>>>
99467>>>            
99467>>>        Writeln channel iCh ("    End_Procedure")
99470>>>        Writeln channel iCh ("End_Object")
99473>>>        
99473>>>        Send Seq_Close_Channel iCh   
99474>>>        Send Stop_StatusPanel of ghoStatusPanel
99475>>>        If (iErrors <> 0) Begin
99477>>>            Send Info_Box ("Ready! But the code contains ERRORS because there were fields with length = 0! Search the generated code for the word 'ERROR!' to see which fields they were.")
99478>>>        End                        
99478>>>>
99478>>>        Else Begin
99479>>>            Send Info_Box "Ready!"
99480>>>        End
99480>>>>
99480>>>    End_Procedure  
99481>>>    
99481>>>    Function DFTypeToDUFType Integer iDataFlexDataType Returns String
99484>>>        String sRetval
99484>>>        Case Begin
99484>>>            Case (iDataFlexDataType = DF_ASCII)
99486>>>                Move DF_ASCII_DUF to sRetval
99487>>>                Case Break
99488>>>            Case (iDataFlexDataType = DF_BCD)
99491>>>                Move "DF_BCD_DUF" to sRetval
99492>>>                Case Break
99493>>>            Case (iDataFlexDataType = DF_BINARY)
99496>>>                Move "DF_BINARY_DUF" to sRetval
99497>>>                Case Break
99498>>>            Case (iDataFlexDataType = DF_DATE)
99501>>>                Move "DF_DATE_DUF" to sRetval
99502>>>                Case Break
99503>>>            Case (iDataFlexDataType = DF_DATETIME)
99506>>>                Move "DF_DATETIME_DUF" to sRetval
99507>>>                Case Break
99508>>>            Case (iDataFlexDataType = DF_TEXT)
99511>>>                Move "DF_TEXT_DUF" to sRetval
99512>>>                Case Break
99513>>>            Case Else
99513>>>                Move iDataFlexDataType to sRetval
99514>>>        Case End               
99514>>>        
99514>>>        Function_Return sRetval        
99515>>>    End_Function
99516>>>    
99516>>>    Object oBusinessProcess is a BusinessProcess
99518>>>        Set Allow_Cancel_State to True
99519>>>        Set Process_Caption to "The Database Update Framework"
99520>>>        Set Process_Title to "Generating Database Update Code..."
99521>>>        Set Process_Message to "For table:"
99522>>>        
99522>>>        Procedure OnProcess
99525>>>            Send StartGenerateCode
99526>>>        End_Procedure
99527>>>    End_Object
99528>>>
99528>>>    Procedure OnFileDropped String sFilename Boolean bLast
99531>>>        String sPath sTest
99531>>>        Forward Send OnFileDropped sFilename bLast
99533>>>        If (bLast = True) Begin
99535>>>            Get ParseFileName sFilename to sTest
99536>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
99538>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
99539>>>                Procedure_Return
99540>>>            End
99540>>>>
99540>>>            Set Value of oFilelistPath_fm to sFilename
99541>>>        End
99541>>>>
99541>>>    End_Procedure              
99542>>>    
99542>>>    Procedure Request_Clear
99545>>>        tDataSourceRow[] EmptyData
99545>>>        tDataSourceRow[] EmptyData
99546>>>        Handle hoGrid hoDataSource
99546>>>        
99546>>>        Move (oFilelist_grd(Self))  to hoGrid
99547>>>        Get phoDataSource of hoGrid to hoDataSource
99548>>>        Send InitializeData of hoGrid EmptyData
99549>>>        Set Value of oFilelistPath_fm    to ""  
99550>>>        Set Value of oSourceName_fm      to "" 
99551>>>        Set Value of oPnVersionNumber_fm to "" 
99552>>>        Send Activate of oFilelistPath_fm
99553>>>    End_Procedure
99554>>>    
99554>>>    Procedure TagChangedTables String sFromFilelist Integer[] iaDifferences
99557>>>        Integer iSize iCount iCount2 iItem iItems iTableNo iTableNo_Col iCheckbox_Col
99557>>>        Handle hTable hoGrid
99557>>>        Handle hoDataSource
99557>>>        tDataSourceRow[] TheData
99557>>>        tDataSourceRow[] TheData
99558>>>
99558>>>        Set Value of oFilelistPath_fm to sFromFilelist
99559>>>        Move (oFilelist_grd(Self)) to hoGrid
99560>>>        
99560>>>        Get piColumnId of (oFilelistNumber_col(hoGrid)) to iTableNo_Col
99561>>>        Get piColumnId of (oCheckbox_Col(hoGrid))       to iCheckbox_Col
99562>>>        Get phoDataSource of hoGrid to hoDataSource
99563>>>        Get DataSource of hoDataSource to TheData  
99564>>>        Move (SizeOfArray(TheData)) to iItems
99565>>>        Decrement iItems
99566>>>        
99566>>>        Move (SizeOfArray(iaDifferences)) to iSize
99567>>>        If (iSize = 0) Begin
99569>>>            Procedure_Return
99570>>>        End
99570>>>>
99570>>>        Decrement iSize
99571>>>        If (iSize > 0) Begin
99573>>>            Send KeyAction of oDeSelectAll_btn
99574>>>        End
99574>>>>
99574>>>
99574>>>        For iCount from 0 to iSize
99580>>>>
99580>>>            Move iaDifferences[iCount] to iTableNo
99581>>>            If (iTableNo > 0) Begin
99583>>>                For iItem from 0 to iItems
99589>>>>
99589>>>                    If (TheData[iItem].sValue[iTableNo_Col] = iTableNo) Begin
99591>>>                        Move True to TheData[iItem].sValue[iCheckbox_Col]
99592>>>                        Move iItems to iItem // We found it and we're out of this loop.
99593>>>                    End            
99593>>>>
99593>>>                Loop
99594>>>>
99594>>>            End
99594>>>>
99594>>>        Loop
99595>>>>
99595>>>        
99595>>>        Send ReInitializeData of hoGrid TheData False
99596>>>        Send DoSetCheckboxFooterText of hoGrid
99597>>>    End_Procedure
99598>>>
99598>>>    Object oViewConnectionProperties_fm is a Button
99600>>>        Set Size to 14 104
99601>>>        Set Location to 243 132
99602>>>        Set Label to "View Connection Properties"
99603>>>        Set peAnchors to anBottomLeft
99604>>>    
99604>>>        Procedure OnClick                              
99607>>>            tSQLConnection Connection
99607>>>            tSQLConnection Connection
99607>>>            Get pSQLConnection of ghoSQLConnectionHandler to Connection
99608>>>            Send Activate_SQLMaintainConnections_dg Connection
99609>>>        End_Procedure
99610>>>    
99610>>>    End_Object
99611>>>
99611>>>    Function ChangeFilelistPathing String sFileList Returns Boolean
99614>>>        String sPath sSQLConnectionsIniName sDataPath sDriverID sServer sOrgOpenPath
99614>>>        Boolean bExists bEmbedded
99614>>>        Handle hoDbUpdateHandler hoSQLConnectionHandler hoSQLConnectionIniFile hTable
99614>>>        tSQLConnection SQLConnection 
99614>>>        tSQLConnection SQLConnection 
99614>>>        Number nVersionNumber                
99614>>>        Integer iRetval iDecimalSep
99614>>>        
99614>>>        Move False to Err
99615>>>        Get vFilePathExists sFileList to bExists
99616>>>        If (bExists = False) Begin
99618>>>            Function_Return False
99619>>>        End  
99619>>>>
99619>>>        
99619>>>        Send Cursor_Wait of Cursor_Control   
99620>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iDecimalSep
99623>>>        If (Character(iDecimalSep) <> ".") Begin
99625>>>            Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii("."))
99628>>>        End
99628>>>>
99628>>>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID      
99629>>>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer
99630>>>        Close DF_ALL
99631>>>        Logout sDriverID sServer
99632>>>        
99632>>>        Set psFileList of (phoWorkspace(ghoApplication))   to sFileList
99633>>>        Set_Attribute DF_FILELIST_NAME                     to sFileList 
99636>>>        Get ParseFolderName sFileList                      to sDataPath
99637>>>        If (Right(sDataPath, 1) = "\") Begin
99639>>>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
99640>>>        End
99640>>>>
99640>>>        Set psDataPath of (phoWorkspace(ghoApplication))   to sDataPath 
99641>>>        
99641>>>        // Temporarily "redirect" the Open path to the current Data folder
99641>>>        Get psOrgOpenPath to sOrgOpenPath
99642>>>        Set_Attribute DF_OPEN_PATH to (sDataPath + ";" + sOrgOpenPath)
99645>>>
99645>>>        Get vFolderFormat sDataPath to sPath            
99646>>>        // Note: We delete all cache files (*.cch) before
99646>>>        // attempting to open any tables as a precausion, in case the table has been changed at the SQL end:
99646>>>        Get vDeleteFile (sPath + "*.cch") to iRetval
99647>>>
99647>>>        Get vParentPath sDataPath to sPath  
99648>>>        Get vFolderFormat sPath   to sPath                           
99649>>>        Move (sPath + "Programs") to sPath
99650>>>        Get vFolderFormat sPath   to sPath                           
99651>>>        Move CS_SQLIniFileName to sSQLConnectionsIniName
99652>>>        Get vFilePathExists (sPath + sSQLConnectionsIniName) to bExists
99653>>>        If (bExists = False) Begin
99655>>>            Send Cursor_Ready of Cursor_Control
99656>>>            Get YesNo_Box ("Couldn't find the DUF SQLConnections.ini file in the workspace Programs folder. Is there a DataFlex DFConnId.ini file in the Data folder that you want to open instead?") to iRetval
99657>>>            If (iRetval = MBR_Yes) Begin
99659>>>                Move "DFConnId.ini" to sSQLConnectionsIniName   
99660>>>                Get AddAllConnections of ghoConnection to bExists
99661>>>            End
99661>>>>
99661>>>            Else Begin
99662>>>                Get YesNo_Box ("Then all the tables in the Filelist.cfg are embedded DataFlex tables. Continue?") to iRetval
99663>>>                If (iRetval <> MBR_Yes) Begin
99665>>>                    Function_Return False
99666>>>                End                  
99666>>>>
99666>>>                Move True to bEmbedded  
99667>>>            End
99667>>>>
99667>>>        End
99667>>>>
99667>>>        If (bEmbedded = False) Begin
99669>>>            Get phoDbUpdateHandler of ghoApplication to hoDbUpdateHandler
99670>>>            Get phoSQLConnectionHandler of hoDbUpdateHandler to hoSQLConnectionHandler
99671>>>            Get phoSQLConnectionIniFile of hoSQLConnectionHandler to hoSQLConnectionIniFile
99672>>>            Set psIniFilePath of hoSQLConnectionIniFile to sPath
99673>>>            Set psIniFileName of hoSQLConnectionIniFile to sSQLConnectionsIniName
99674>>>
99674>>>            Get SetupSQLConnection of hoSQLConnectionHandler True to SQLConnection
99675>>>            Set pSQLConnection     of hoSQLConnectionHandler to SQLConnection 
99676>>>        End     
99676>>>>
99676>>>        
99676>>>        Send LoadData to oFilelist_grd   
99677>>>        // It just seem logical to activate the grid after populating it.
99677>>>        // At this point there is little use of still having the oFilelist_fm active.
99677>>>        Send Activate of oFilelist_grd
99678>>>
99678>>>        If (bExists = True) Begin
99680>>>            Get phDbVersion of oFilelist_grd to hTable
99681>>>            If (hTable = 0) Begin
99683>>>                Send Info_Box ("This workspace has not been setup to use the DUF DbVersion table and thus the current database version can't be retrieved.\nYou need to manually set the 'Next pnVersionNumber' entry window below to an apropriate number before pressing the 'Generate Code' button.")
99684>>>                Procedure_Return
99685>>>            End
99685>>>>
99685>>>            Open hTable
99687>>>            Get_Field_Value hTable 1 to nVersionNumber
99690>>>            Move (nVersionNumber + .1) to nVersionNumber
99691>>>            Set Value of oPnVersionNumber_fm to nVersionNumber
99692>>>            Close hTable
99693>>>        End
99693>>>>
99693>>>
99693>>>        Function_Return (Err = False)
99694>>>    End_Function  
99695>>>    
99695>>>    Procedure Reset_DF_OPEN_PATH
99698>>>        String sOrgOpenpath
99698>>>        Get psOrgOpenPath to sOrgOpenpath
99699>>>        Set_Attribute DF_OPEN_PATH to sOrgOpenPath
99702>>>    End_Procedure
99703>>>
99703>>>    On_Key Key_Ctrl+Key_A  Send KeyAction of oSelectAll_btn
99704>>>    On_Key Key_Ctrl+Key_N  Send KeyAction of oDeSelectAll_btn
99705>>>    On_Key Key_Ctrl+Key_I  Send KeyAction of oInvertSelection_btn
99706>>>    On_Key Key_Space       Send ToggleCurrentItem
99707>>>    On_Key kClear          Send Request_Clear
99708>>>    On_Key kClear_All      Send Request_Clear
99709>>>    On_Key Key_Ctrl+Key_G  Send KeyAction of oGenerateCode_btn
99710>>>    On_Key Key_Ctrl+Key_F4 Send None
99711>>>End_Object    
99712>>>
99712>>>// General purpose access message to auto-fill grid with tables with
99712>>>// differences (after "Compare Databases" has been run).
99712>>>Procedure TagFileNamesForCodeGeneration
99715>>>    Boolean bTagFileNames
99715>>>    String sFileListFrom sCurrentFilelist
99715>>>    Integer[] iaDifferences
99716>>>    Handle ho
99716>>>    
99716>>>    Send Activate_oTableDUFCodeGenerator
99717>>>    Move (oTableDUFCodeGenerator(Self)) to ho
99718>>>    Get Value of (oFilelistPath_fm(ho)) to sCurrentFilelist
99719>>>    If (sCurrentFilelist <> "") Begin
99721>>>        Send Request_Clear of ho
99722>>>    End
99722>>>>
99722>>>
99722>>>    Get psFilelistFrom of ghoApplication to sFileListFrom
99723>>>    Get piaDifferences of ghoApplication to iaDifferences  
99724>>>    Send TagChangedTables of ho sFileListFrom iaDifferences
99725>>>End_Procedure
99726>
99726>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StdAbout.pkg)
99726>>>//************************************************************************
99726>>>// Confidential Trade Secret.
99726>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
99726>>>// as an unpublished work.  All rights reserved.
99726>>>// DataFlex is a registered trademark of Data Access Corporation.
99726>>>//
99726>>>//************************************************************************
99726>>>//************************************************************************
99726>>>//
99726>>>// $File name  : StdAbout.pkg
99726>>>// $File title : Standard about object package for VDF
99726>>>// Notice      :
99726>>>// $Author(s)  : John Tuohy
99726>>>//
99726>>>// $Rev History
99726>>>//
99726>>>// JT 06/27/97   File created
99726>>>//************************************************************************
99726>>>
99726>>>// This provides a quick and simple way to create an about package for a program.
99726>>>// You need to create a message inside you client area called Activate_About.
99726>>>// Within this message you should send the message DoAbout passing needed
99726>>>// string information.
99726>>>//
99726>>>//       Procedure Activate_About
99726>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
99726>>>//       End_Procedure
99726>>>//    where: sTitle =     Name of application. If none provided, uses caption
99726>>>//                        bar title
99726>>>//           sVersion   = Version Line. If none provided, will be blank
99726>>>//           sCopyRight = Copyright Line. If none provided, will be blank
99726>>>//           sAuthor    = Author name, blank if none provided
99726>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
99726>>>//                        is used.
99726>>>// It is expected that you will place this in your own object package. For
99726>>>// example an order about package may look like this:
99726>>>//
99726>>>//   // OrderAbout.pkg
99726>>>//   Use StdAbout.pkg
99726>>>//   Procedure Activate_About
99726>>>//      String sTitle sCopyright sVersion sAuthor
99726>>>//      Move "My Order Entry System" to sTitle
99726>>>//      Move "Version 2.1" to sVersion
99726>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
99726>>>//      Move "John Smith"  to sAuthor
99726>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
99726>>>//   end_procedure
99726>>>//   // end of file.
99726>>>
99726>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DfAbout.pkg)
99726>>>>>//************************************************************************
99726>>>>>// Confidential Trade Secret.
99726>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
99726>>>>>// as an unpublished work.  All rights reserved.
99726>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
99726>>>>>//
99726>>>>>//************************************************************************
99726>>>>>//************************************************************************
99726>>>>>//
99726>>>>>// $File name  : DfAbout.pkg
99726>>>>>// $File title : About class support
99726>>>>>// Notice      :
99726>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
99726>>>>>//
99726>>>>>// $Rev History
99726>>>>>//
99726>>>>>// NGS 08/16/2013 Improved by using a cRichEdit object were the params gets added to.
99726>>>>>//                The objects that previously were popupated with values from the params,
99726>>>>>//                and their corresponding "Procedure Set..." messages, were removed as
99726>>>>>//                the edit object is used instead.
99726>>>>>//                The number of params to the DoAbout procedure was increased to ten, so
99726>>>>>//                it is easier to add whatever extra text strings needed/wanted.
99726>>>>>//                The StdAbout.pkg was also changed for this to work. It allows for an extra
99726>>>>>//                five new params to be passed, but these new params are all optional.
99726>>>>>//                So the interface will work exactly as before - if no extra parameters are passed.
99726>>>>>//                Also added an extra bitmap object to show the "Powered By Visual DataFlex" logo, in
99726>>>>>//                the lower left corner of the About object, beneath the "main" About bitmap.
99726>>>>>//                Note: It is assumed that the bitmap "PoweredByVisualDataFlex.bmp" exists.
99726>>>>>//                The background was changed to clWhite for easier usage of bitmaps. Just set the background
99726>>>>>//                color of your bitmap to white and the bitmap will not look jagged.
99726>>>>>//                If an Internet address is passed as one of the params, it will be underlined and clickable.
99726>>>>>//                An e-mail address can also be passed; e.g. "E-mail: mailto:mail@myemailaccount.com" and will
99726>>>>>//                also be clickable.
99726>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
99726>>>>>//                Windows for the size first.
99726>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
99726>>>>>//                with anchor technique. Removed unnessary property in the
99726>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
99726>>>>>//                object To better look in Windows XP. Repositioned the close
99726>>>>>//                button in the sysinfo dialog To line up with the display area
99726>>>>>//                Replaced obsolete code and techniques. Removed dead code.
99726>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
99726>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
99726>>>>>//                the global Workspace object, if it is present
99726>>>>>// JJT 11/05/98   Added version information
99726>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
99726>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
99726>>>>>//                workspace package.
99726>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
99726>>>>>//                class can create this object.
99726>>>>>//                Cleaned up the interface (used correct classes and messages)
99726>>>>>//                Added workspace reporting support To sys-info.
99726>>>>>//                Turned off wrapping in the sys-info editor.
99726>>>>>// KR  ??/??/96   File created
99726>>>>>//************************************************************************
99726>>>>>Use LanguageText.pkg
99726>>>>>Use Windows.pkg
99726>>>>>Use DFbitmap.pkg
99726>>>>>Use GlobalFunctionsProcedures.pkg
99726>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cRichEdit.pkg)
99726>>>>>>>use Windows.pkg
99726>>>>>>>Use cEdit_Mixin.pkg
99726>>>>>>>
99726>>>>>>>// DFO: cRichEdit.Dfo
99726>>>>>>>// DFC: cRichEdit.Dfc
99726>>>>>>>
99726>>>>>>>// constants used for RichEdit Properties
99726>>>>>>>// peAlignment 
99726>>>>>>>Enum_List 
99726>>>>>>>    Define alLeft   for 1 
99726>>>>>>>    Define alRight  for 2 
99726>>>>>>>    Define alCenter for 3 
99726>>>>>>>End_Enum_List 
99726>>>>>>>
99726>>>>>>>// peBullets 
99726>>>>>>>Enum_List 
99726>>>>>>>    Define buNone 
99726>>>>>>>    Define buBullets 
99726>>>>>>>    Define buArabicNumbers 
99726>>>>>>>    Define buLowerLetters 
99726>>>>>>>    Define buUpperLetters 
99726>>>>>>>    Define buLowerRomans 
99726>>>>>>>    Define buUpperRomans 
99726>>>>>>>End_Enum_List 
99726>>>>>>>
99726>>>>>>>// peBulletStyle 
99726>>>>>>>Enum_List 
99726>>>>>>>    Define busRightParen   for 0 
99726>>>>>>>    Define busEncloseParen for 256 
99726>>>>>>>    Define busPeriod       for 512 
99726>>>>>>>    Define busNumberOnly   for 768 
99726>>>>>>>    Define busNoDisplay    for 1024 
99726>>>>>>>End_Enum_List
99726>>>>>>>    
99726>>>>>>>// peLineSpacingType
99726>>>>>>>Enum_List 
99726>>>>>>>    Define lstSingle
99726>>>>>>>    Define lstSingleAndOneHalf
99726>>>>>>>    Define lstDouble
99726>>>>>>>End_Enum_List
99726>>>>>>>
99726>>>>>>>Class cRichEdit Is A DFBaseRichEdit
99727>>>>>>>
99727>>>>>>>    Procedure Construct_Object
99729>>>>>>>        Forward Send Construct_Object
99731>>>>>>>        Send Define_cEdit_Mixin
99732>>>>>>>
99732>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
99733>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
99734>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
99735>>>>>>>
99735>>>>>>>    End_Procedure // Construct_Object
99736>>>>>>>
99736>>>>>>>    Import_Class_Protocol cEdit_Mixin
99737>>>>>>>    
99737>>>>>>>    Procedure ToggleBold
99739>>>>>>>        Set pbBold to (not(pbBold(self))) 
99740>>>>>>>    end_procedure
99741>>>>>>>    
99741>>>>>>>    Procedure ToggleItalics
99743>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
99744>>>>>>>    end_procedure
99745>>>>>>>    
99745>>>>>>>    Procedure ToggleUnderline
99747>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
99748>>>>>>>    end_procedure
99749>>>>>>>
99749>>>>>>>End_Class
99750>>>>>>>
99750>>>>>Use cTextEdit.pkg
99750>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\gFormatNumbers.pkg)
99750>>>>>>>//****************************************************************************//
99750>>>>>>>//                                                                            //
99750>>>>>>>// $File name  : gFormatNumbers.pkg                                           //
99750>>>>>>>// $File title : Globals for formating numbers and currency                   //
99750>>>>>>>// Notice      :                                                              //
99750>>>>>>>// $Author(s)  : John Tuohy                                                   //
99750>>>>>>>//                                                                            //
99750>>>>>>>// Confidential Trade Secret.                                                 //
99750>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
99750>>>>>>>// All Rights reserved                                                        //
99750>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
99750>>>>>>>// $Rev History                                                               //
99750>>>>>>>//                                                                            //
99750>>>>>>>// 25.08.99 Created                                                           //
99750>>>>>>>//****************************************************************************//
99750>>>>>>>
99750>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cFormatter.pkg)
99750>>>>>>>>>//****************************************************************************//
99750>>>>>>>>>//                                                                            //
99750>>>>>>>>>// $File name  : cFormatter.pkg                                               //
99750>>>>>>>>>// $File title : cFormatter class (private class)                             //
99750>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
99750>>>>>>>>>//                                                                            //
99750>>>>>>>>>// Confidential Trade Secret.                                                 //
99750>>>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
99750>>>>>>>>>// All Rights reserved                                                        //
99750>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
99750>>>>>>>>>//                                                                            //
99750>>>>>>>>>// $Rev History                                                               //
99750>>>>>>>>>//                                                                            //
99750>>>>>>>>>// 25.08.99 Created                                                           //
99750>>>>>>>>>//****************************************************************************//
99750>>>>>>>>>use VDFBase.pkg
99750>>>>>>>>>
99750>>>>>>>>>Class cFormatter is an cObject
99751>>>>>>>>>
99751>>>>>>>>>    Procedure Construct_object
99753>>>>>>>>>        Integer iCh
99753>>>>>>>>>        forward send construct_object
99755>>>>>>>>>        Property String  psCurrencySymbol
99756>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
99757>>>>>>>>>
99757>>>>>>>>>        Property string  psLeft
99758>>>>>>>>>        Property string  psright
99759>>>>>>>>>        Property integer pbThousandsSep
99760>>>>>>>>>        Property integer piPoints
99761>>>>>>>>>
99761>>>>>>>>>        Property string  psCurPosLeft
99762>>>>>>>>>        Property string  psCurPosright
99763>>>>>>>>>        Property integer pbCurPosThousandsSep
99764>>>>>>>>>        Property integer piCurPosPoints
99765>>>>>>>>>
99765>>>>>>>>>        Property string  psCurNegLeft
99766>>>>>>>>>        Property string  psCurNegright
99767>>>>>>>>>        Property integer pbCurNegThousandsSep
99768>>>>>>>>>        Property integer piCurNegPoints
99769>>>>>>>>>
99769>>>>>>>>>        Property string  psNumPosLeft
99770>>>>>>>>>        Property string  psNumPosright
99771>>>>>>>>>        Property integer pbNumPosThousandsSep
99772>>>>>>>>>        Property integer piNumPosPoints
99773>>>>>>>>>
99773>>>>>>>>>        Property string  psNumNegLeft
99774>>>>>>>>>        Property string  psNumNegright
99775>>>>>>>>>        Property integer pbNumNegThousandsSep
99776>>>>>>>>>        Property integer piNumNegPoints
99777>>>>>>>>>
99777>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" true  // currency
99778>>>>>>>>>        Send SetFormat  ",#.*"           false // numeric
99779>>>>>>>>>
99779>>>>>>>>>    end_procedure
99780>>>>>>>>>
99780>>>>>>>>>    // internal
99780>>>>>>>>>    // parse passed format string and set temporary properties with result
99780>>>>>>>>>    //
99780>>>>>>>>>    Procedure ParseFormat string sFmt
99782>>>>>>>>>
99782>>>>>>>>>        string sLeft sRight sDigit
99782>>>>>>>>>        integer bSep iPos i iDigits
99782>>>>>>>>>
99782>>>>>>>>>        // replace any literals. A "/" followed by anything.
99782>>>>>>>>>        // some literals are special. $ . , / #
99782>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
99783>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
99784>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
99785>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
99786>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
99787>>>>>>>>>        Move (Character(9)) to sDigit
99788>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
99789>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
99790>>>>>>>>>
99790>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
99791>>>>>>>>>        If bSep Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
99794>>>>>>>>>
99794>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(self))) to sFmt // replace any $ with currency symbol
99795>>>>>>>>>
99795>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
99796>>>>>>>>>
99796>>>>>>>>>        // Move all the special literals back into place before parsing
99796>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
99797>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
99798>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
99799>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
99800>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
99801>>>>>>>>>
99801>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
99803>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
99804>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
99806>>>>>>>>>               Move -2 to iDigits
99807>>>>>>>>>               increment i
99808>>>>>>>>>            end
99808>>>>>>>>>>
99808>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
99812>>>>>>>>>                 Increment i
99813>>>>>>>>>            end
99814>>>>>>>>>>
99814>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
99815>>>>>>>>>            If (iDigits=0) Move (i-1) to iDigits
99818>>>>>>>>>            //
99818>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
99819>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
99823>>>>>>>>>                 increment i
99824>>>>>>>>>            end
99825>>>>>>>>>>
99825>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
99826>>>>>>>>>        end
99826>>>>>>>>>>
99826>>>>>>>>>        else begin                             // we have no decinal
99827>>>>>>>>>            Move 0 to iDigits                  // so points is none
99828>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
99829>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
99831>>>>>>>>>                Move sFmt to sLeft
99832>>>>>>>>>                Move ""   to sRight
99833>>>>>>>>>            end
99833>>>>>>>>>>
99833>>>>>>>>>            else begin
99834>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
99835>>>>>>>>>                Move 1 to i
99836>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
99840>>>>>>>>>                    Increment i
99841>>>>>>>>>                end
99842>>>>>>>>>>
99842>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
99843>>>>>>>>>            end
99843>>>>>>>>>>
99843>>>>>>>>>        end
99843>>>>>>>>>>
99843>>>>>>>>>        // set temporary format properties and exit
99843>>>>>>>>>        Set pbThousandsSep to bSep
99844>>>>>>>>>        set psLeft         to sLeft
99845>>>>>>>>>        set psRight        to sRight
99846>>>>>>>>>        Set piPoints       to iDigits
99847>>>>>>>>>     End_procedure
99848>>>>>>>>>
99848>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
99848>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
99848>>>>>>>>>    //
99848>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
99848>>>>>>>>>    //
99848>>>>>>>>>    Procedure SetFormat string sFmt integer bCurrency
99850>>>>>>>>>        string sPos sNeg
99850>>>>>>>>>        integer iPos
99850>>>>>>>>>
99850>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
99851>>>>>>>>>        If iPos begin
99853>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
99854>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
99855>>>>>>>>>        end
99855>>>>>>>>>>
99855>>>>>>>>>        else Begin
99856>>>>>>>>>            Move sFmt         to sPos
99857>>>>>>>>>            Move ("-" + sFmt) to sNeg
99858>>>>>>>>>        end
99858>>>>>>>>>>
99858>>>>>>>>>        Send ParseFormat sPos
99859>>>>>>>>>        If bCurrency begin
99861>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(self))
99862>>>>>>>>>            set psCurPosLeft         to (psLeft(self))
99863>>>>>>>>>            set psCurPosRight        to (psRight(self))
99864>>>>>>>>>            Set piCurPosPoints       to (piPoints(self))
99865>>>>>>>>>        End
99865>>>>>>>>>>
99865>>>>>>>>>        else Begin
99866>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(self))
99867>>>>>>>>>            set psNumPosLeft         to (psLeft(self))
99868>>>>>>>>>            set psNumPosRight        to (psRight(self))
99869>>>>>>>>>            Set piNumPosPoints       to (piPoints(self))
99870>>>>>>>>>        end
99870>>>>>>>>>>
99870>>>>>>>>>
99870>>>>>>>>>        Send ParseFormat sNeg
99871>>>>>>>>>        If bCurrency begin
99873>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(self))
99874>>>>>>>>>            set psCurNegLeft         to (psLeft(self))
99875>>>>>>>>>            set psCurNegRight        to (psRight(self))
99876>>>>>>>>>            Set piCurNegPoints       to (piPoints(self))
99877>>>>>>>>>        End
99877>>>>>>>>>>
99877>>>>>>>>>        else Begin
99878>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(self))
99879>>>>>>>>>            set psNumNegLeft         to (psLeft(self))
99880>>>>>>>>>            set psNumNegRight        to (psRight(self))
99881>>>>>>>>>            Set piNumNegPoints       to (piPoints(self))
99882>>>>>>>>>        end
99882>>>>>>>>>>
99882>>>>>>>>>    End_procedure
99883>>>>>>>>>
99883>>>>>>>>>    // low level formatting. Pass parameters
99883>>>>>>>>>    Function Format_Num number nNumber integer iPoints integer bSep ;                       string sPrefix string sSuffix returns string
99885>>>>>>>>>        string  sLeft sRight sNumber sSep sDec
99885>>>>>>>>>        integer bIsNegative iDec iLen iCh
99885>>>>>>>>>
99885>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
99888>>>>>>>>>        Move (Character(iCh)) to sDec
99889>>>>>>>>>
99889>>>>>>>>>        Move (abs(nNumber)) to sNumber
99890>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
99891>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
99892>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
99893>>>>>>>>>        // format for decimal separator
99893>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+repeat("0",iPoints),iPoints)) to sRight
99896>>>>>>>>>
99896>>>>>>>>>        // format for thousand sep.
99896>>>>>>>>>        If bSep Begin
99898>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
99901>>>>>>>>>            Move (Character(iCh)) to sSep
99902>>>>>>>>>            Move (Length(sLeft)) to iLen
99903>>>>>>>>>            While (iLen>3)
99907>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
99908>>>>>>>>>                Move (iLen-3) to iLen
99909>>>>>>>>>            End
99910>>>>>>>>>>
99910>>>>>>>>>        End
99910>>>>>>>>>>
99910>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
99910>>>>>>>>>        If (iPoints>0 OR (iPoints=-2 AND sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
99913>>>>>>>>>        Function_return (sPrefix + sLeft+ sSuffix)
99914>>>>>>>>>    End_Function
99915>>>>>>>>>
99915>>>>>>>>>    // Public: Format for currency
99915>>>>>>>>>    //
99915>>>>>>>>>    Function FormatCur number nNumber integer iPoints returns string
99917>>>>>>>>>        string  sLeft sRight
99917>>>>>>>>>        integer bSep
99917>>>>>>>>>        If (nNumber<0) Begin
99919>>>>>>>>>            get pbCurNegThousandsSep to bSep
99920>>>>>>>>>            get psCurNegLeft         to sLeft
99921>>>>>>>>>            get psCurNegRight        to sRight
99922>>>>>>>>>            If (iPoints=-1) get piCurNegPoints       to iPoints
99925>>>>>>>>>        end
99925>>>>>>>>>>
99925>>>>>>>>>        Else Begin
99926>>>>>>>>>            get pbCurPosThousandsSep to bSep
99927>>>>>>>>>            get psCurPosLeft         to sLeft
99928>>>>>>>>>            get psCurPosRight        to sRight
99929>>>>>>>>>            If (iPoints=-1) get piCurPosPoints       to iPoints
99932>>>>>>>>>        end
99932>>>>>>>>>>
99932>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
99933>>>>>>>>>    End_function
99934>>>>>>>>>
99934>>>>>>>>>    // Public: Format for numeric
99934>>>>>>>>>    //
99934>>>>>>>>>    Function FormatNum number nNumber integer iPoints returns string
99936>>>>>>>>>        string  sLeft sRight
99936>>>>>>>>>        integer bSep
99936>>>>>>>>>        If (nNumber<0) Begin
99938>>>>>>>>>            get pbNumNegThousandsSep to bSep
99939>>>>>>>>>            get psNumNegLeft         to sLeft
99940>>>>>>>>>            get psNumNegRight        to sRight
99941>>>>>>>>>            If (iPoints=-1) get piNumNegPoints       to iPoints
99944>>>>>>>>>        end
99944>>>>>>>>>>
99944>>>>>>>>>        Else Begin
99945>>>>>>>>>            get pbNumPosThousandsSep to bSep
99946>>>>>>>>>            get psNumPosLeft         to sLeft
99947>>>>>>>>>            get psNumPosRight        to sRight
99948>>>>>>>>>            If (iPoints=-1) get piNumPosPoints       to iPoints
99951>>>>>>>>>        end
99951>>>>>>>>>>
99951>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
99952>>>>>>>>>    End_function
99953>>>>>>>>>
99953>>>>>>>>>
99953>>>>>>>>>    // Public: Format passing format string
99953>>>>>>>>>    //
99953>>>>>>>>>    Function FormatVal number nNumber string sFmt returns string
99955>>>>>>>>>        integer iPos bIsNeg
99955>>>>>>>>>        string  sLeft sRight
99955>>>>>>>>>        integer iPoints bSep
99955>>>>>>>>>        Move (nNumber<0) to bIsNeg
99956>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
99957>>>>>>>>>        Case Begin
99957>>>>>>>>>            Case (iPos and Not(bIsNeg))      Move (left(sFmt,iPos-1))    to sFmt
99960>>>>>>>>>            Case (iPos and bIsNeg)           Move (mid(sFmt,255,iPos+1)) to sFmt
99964>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) Move sFmt                   to sFmt
99968>>>>>>>>>            Case else                        Move ("-" + sFmt)           to sFmt
99970>>>>>>>>>        case end
99970>>>>>>>>>        Send ParseFormat sFmt
99971>>>>>>>>>        get pbThousandsSep to bSep
99972>>>>>>>>>        get psLeft         to sLeft
99973>>>>>>>>>        get psRight        to sRight
99974>>>>>>>>>        get piPoints       to iPoints
99975>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
99976>>>>>>>>>    end_function
99977>>>>>>>>>
99977>>>>>>>>>End_Class
99978>>>>>>>
99978>>>>>>>// for now, this object is private. All access is through the following
99978>>>>>>>// global functions
99978>>>>>>>
99978>>>>>>>//Object oFmt is a cFormatter
99978>>>>>>>//end_object
99978>>>>>>>
99978>>>>>>>Global_variable handle ghoFormatter
99978>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
99979>>>>>>>
99979>>>>>>>Function FormatNumber Global number nNum integer iPoints returns string
99981>>>>>>>    Function_return (FormatNum(ghoFormatter, nNum,iPoints))
99982>>>>>>>end_function
99983>>>>>>>
99983>>>>>>>Function FormatCurrency Global number nNum integer iPoints returns string
99985>>>>>>>    Function_return (FormatCur(ghoFormatter, nNum,iPoints))
99986>>>>>>>end_function
99987>>>>>>>
99987>>>>>>>Function FormatValue Global number nNum string sFmt returns string
99989>>>>>>>    Function_return (FormatVal(ghoFormatter, nNum,sFmt))
99990>>>>>>>end_function
99991>>>>>>>
99991>>>>>>>Procedure SetCurrencyFormat Global string sFmt
99993>>>>>>>    Send SetFormat of ghoFormatter sFmt True
99994>>>>>>>end_function
99995>>>>>>>
99995>>>>>>>Procedure SetNumberFormat Global string sFmt
99997>>>>>>>    Send SetFormat of ghoFormatter sFmt False
99998>>>>>>>end_function
99999>>>>>>>
99999>>>>>Use MapiDllCalls.Pkg
Including file: MapiDllCalls.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiDllCalls.Pkg)
99999>>>>>>>Use MapiConstants.Pkg
Including file: MapiConstants.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiConstants.Pkg)
99999>>>>>>>>>Type MapiSession
99999>>>>>>>>>   Field MapiSession.SessionID As Integer
99999>>>>>>>>>End_type // MapiSession
99999>>>>>>>>>
99999>>>>>>>>>Type MapiMessagePointer
99999>>>>>>>>>   Field MapiMessagePointer.lppMessage As Pointer
99999>>>>>>>>>End_Type // MapiMessagePointer
99999>>>>>>>>>
99999>>>>>>>>>Type MapiRecipPointer
99999>>>>>>>>>   Field MapiRecipPointer.lppRecip As Pointer
99999>>>>>>>>>End_Type // MapiRecipPointer
99999>>>>>>>>>
99999>>>>>>>>>Type MapiNewRecipsPointer
99999>>>>>>>>>   Field MapiNewRecipsPointer.lppNewRecips As Pointer
99999>>>>>>>>>End_Type // MapiNewRecipsPointer
99999>>>>>>>>>
99999>>>>>>>>>Type MapiNewRecipsCounter
99999>>>>>>>>>   Field MapiNewRecipsCounter.lpnNewRecips As Integer
99999>>>>>>>>>End_Type // MapiNewRecipsCounter
99999>>>>>>>>>
99999>>>>>>>>>Type MapiFileDesc
99999>>>>>>>>>   Field MapiFileDesc.ulReserved As Integer      // Reserved for future use (must be 0)
99999>>>>>>>>>   Field MapiFileDesc.flFlags As Integer         // Flags
99999>>>>>>>>>   Field MapiFileDesc.nPosition As Integer       // character in text to be replaced by attachment
99999>>>>>>>>>   Field MapiFileDesc.lpszPathName As Pointer    // Full path name of attachment file
99999>>>>>>>>>   Field MapiFileDesc.lpszFileName As Pointer    // Original file name (optional)
99999>>>>>>>>>   Field MapiFileDesc.lpFileType As Pointer     // Attachment file type (can be lpMapiFileTagExt)
99999>>>>>>>>>End_Type // MapiFileDesc
99999>>>>>>>>>
99999>>>>>>>>>Define MAPI_OLE        For |CI$00000001
99999>>>>>>>>>Define MAPI_OLE_STATIC For |CI$00000002
99999>>>>>>>>>
99999>>>>>>>>>Define MAPI_NOATTACHMENT_POSITION For |CI$FFFFFFFF
99999>>>>>>>>>
99999>>>>>>>>>Type MapiFileTagExt
99999>>>>>>>>>   Field MapiFileTagExt.ulReserved As Integer  // Reserved, must be zero.
99999>>>>>>>>>   Field MapiFileTagExt.cbTag As Integer       // Size (in bytes) of
99999>>>>>>>>>   Field MapiFileTagExt.lpTag As Pointer       // X.400 OID for this attachment type
99999>>>>>>>>>   Field MapiFileTagExt.cbEncoding As Integer  // Size (in bytes) of
99999>>>>>>>>>   Field MapiFileTagExt.lpEncoding As Pointer  // X.400 OID for this attachment's encoding
99999>>>>>>>>>End_Type // MapiFileTagExt
99999>>>>>>>>>
99999>>>>>>>>>Type MapiRecipDesc
99999>>>>>>>>>   Field MapiRecipDesc.ulReserved As Integer   // Reserved for future use
99999>>>>>>>>>   Field MapiRecipDesc.ulRecipClass As Integer // Recipient class
99999>>>>>>>>>                                               // MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG
99999>>>>>>>>>   Field MapiRecipDesc.lpszName As Pointer     // Recipient name
99999>>>>>>>>>   Field MapiRecipDesc.lpszAddress As Pointer  // Recipient address (optional)
99999>>>>>>>>>   Field MapiRecipDesc.ulEIDSize As Pointer    // Count in bytes of size of pEntryID
99999>>>>>>>>>   Field MapiRecipDesc.lpEntryID As Pointer    // System-specific recipient reference
99999>>>>>>>>>End_Type // MapiRecipDesc
99999>>>>>>>>>
99999>>>>>>>>>Define MAPI_ORIG   For 0 // Recipient is message originator
99999>>>>>>>>>Define MAPI_TO     For 1 // Recipient is a primary recipient
99999>>>>>>>>>Define MAPI_CC     For 2 // Recipient is a copy recipient
99999>>>>>>>>>Define MAPI_BCC    For 3 // Recipient is blind copy recipient
99999>>>>>>>>>
99999>>>>>>>>>Type MapiMessage
99999>>>>>>>>>   Field MapiMessage.ulReserved As Integer                   // Reserved for future use (M.B. 0)
99999>>>>>>>>>   Field MapiMessage.lpszSubject As Pointer                  // Message Subject
99999>>>>>>>>>   Field MapiMessage.lpszNoteText As Pointer                 // Message Text
99999>>>>>>>>>   Field MapiMessage.lpszMessageType As Pointer              // Message Class
99999>>>>>>>>>   Field MapiMessage.lpszDateReceived As Pointer             // in YYYY/MM/DD HH:MM format
99999>>>>>>>>>   Field MapiMessage.lpszConversationID As Pointer           // conversation thread ID
99999>>>>>>>>>   Field MapiMessage.flFlags As Integer                      // unread,return receipt
99999>>>>>>>>>   Field MapiMessage.lpOriginator As Pointer                 // Originator descriptor
99999>>>>>>>>>   Field MapiMessage.nRecipCount As Integer                  // Number of recipients
99999>>>>>>>>>   Field MapiMessage.lpRecips As Pointer                     // Recipient descriptors
99999>>>>>>>>>   Field MapiMessage.nFileCount As Integer                   // # of file attachments
99999>>>>>>>>>   Field MapiMessage.lpFiles As Pointer                      // Attachment descriptors
99999>>>>>>>>>End_Type // MapiMessage
99999>>>>>>>>>
99999>>>>>>>>>Define MAPI_UNREAD            For |CI$00000001
99999>>>>>>>>>Define MAPI_RECEIPT_REQUESTED For |CI$00000002
99999>>>>>>>>>Define MAPI_SENT              For |CI$00000004
99999>>>>>>>>>
99999>>>>>>>>>// MAPILogon() flags.
99999>>>>>>>>>Define MAPI_LOGON_UI         For |CI$00000001 // Display logon UI
99999>>>>>>>>>Define MAPI_PASSWORD_UI      For |CI$00020000 // prompt for password only
99999>>>>>>>>>Define MAPI_NEW_SESSION      For |CI$00000002 // Don't use shared session
99999>>>>>>>>>Define MAPI_FORCE_DOWNLOAD   For |CI$00001000 // Get new mail before return
99999>>>>>>>>>Define MAPI_ALLOW_OTHERS     For |CI$00000008 // Make this a shared session
99999>>>>>>>>>Define MAPI_EXPLICIT_PROFILE For |CI$00000010 // Don't use default profile
99999>>>>>>>>>Define MAPI_EXTENDED         For |CI$00000020 // Extended MAPI Logon
99999>>>>>>>>>Define MAPI_USE_DEFAULT      For |CI$00000040 // Use default profile in logon
99999>>>>>>>>>
99999>>>>>>>>>Define MAPI_SIMPLE_DEFAULT  For (MAPI_LOGON_UI + MAPI_FORCE_DOWNLOAD + MAPI_ALLOW_OTHERS)
99999>>>>>>>>>Define MAPI_SIMPLE_EXPLICIT For (MAPI_NEW_SESSION + MAPI_FORCE_DOWNLOAD + MAPI_EXPLICIT_PROFILE)
99999>>>>>>>>>
99999>>>>>>>>>// MAPILogoff() flags.
99999>>>>>>>>>Define MAPI_LOGOFF_SHARED For |CI$00000001 // Close all shared sessions
99999>>>>>>>>>Define MAPI_LOGOFF_UI     For |CI$00000002 // It's OK to present UI
99999>>>>>>>>>
99999>>>>>>>>>// MAPISendMail() flags.
99999>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
99999>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
99999>>>>>>>>>
99999>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Display a send note UI
99999>>>>>>>>>Define MAPI_USE_DEFAULT For |CI$00000040 // Use default profile in logon
99999>>>>>>>>>
99999>>>>>>>>>// MAPIFindNext() flags.
99999>>>>>>>>>Define MAPI_UNREAD_ONLY    For |CI$00000020 // Only unread messages
99999>>>>>>>>>Define MAPI_GUARANTEE_FIFO For |CI$00000100 // use date order
99999>>>>>>>>>Define MAPI_LONG_MSGID     For |CI$00004000 // allow 512 char returned ID
99999>>>>>>>>>
99999>>>>>>>>>// MAPIReadMail() flags.
99999>>>>>>>>>Define MAPI_PEEK            For |CI$00000080 // Do not mark as read.
99999>>>>>>>>>Define MAPI_SUPPRESS_ATTACH For |CI$00000800 // header + body, no files
99999>>>>>>>>>Define MAPI_ENVELOPE_ONLY   For |CI$00000040 // Only header information
99999>>>>>>>>>Define MAPI_BODY_AS_FILE    For |CI$00000200
99999>>>>>>>>>
99999>>>>>>>>>// MAPISaveMail() flags.
99999>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
99999>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
99999>>>>>>>>>Define MAPI_LONG_MSGID  For |CI$00004000 // allow 512 char returned ID
99999>>>>>>>>>
99999>>>>>>>>>// MAPIAddress() flags.
99999>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
99999>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
99999>>>>>>>>>
99999>>>>>>>>>// MAPIDetails() flags.
99999>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
99999>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
99999>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
99999>>>>>>>>>
99999>>>>>>>>>// MAPIResolveName() flags.
99999>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
99999>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
99999>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Prompt for choices if ambiguous
99999>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
99999>>>>>>>>>
99999>>>>>>>>>Define SUCCESS_SUCCESS                 For 0
99999>>>>>>>>>Define MAPI_USER_ABORT                 For 1
99999>>>>>>>>>Define MAPI_E_USER_ABORT               For MAPI_USER_ABORT
99999>>>>>>>>>Define MAPI_E_FAILURE                  For 2
99999>>>>>>>>>Define MAPI_E_LOGON_FAILURE            For 3
99999>>>>>>>>>Define MAPI_E_LOGIN_FAILURE            For MAPI_E_LOGON_FAILURE
99999>>>>>>>>>Define MAPI_E_DISK_FULL                For 4
99999>>>>>>>>>Define MAPI_E_INSUFFICIENT_MEMORY      For 5
99999>>>>>>>>>Define MAPI_E_ACCESS_DENIED            For 6
99999>>>>>>>>>Define MAPI_E_TOO_MANY_SESSIONS        For 8
99999>>>>>>>>>Define MAPI_E_TOO_MANY_FILES           For 9
99999>>>>>>>>>Define MAPI_E_TOO_MANY_RECIPIENTS      For 10
99999>>>>>>>>>Define MAPI_E_ATTACHMENT_NOT_FOUND     For 11
99999>>>>>>>>>Define MAPI_E_ATTACHMENT_OPEN_FAILURE  For 12
99999>>>>>>>>>Define MAPI_E_ATTACHMENT_WRITE_FAILURE For 13
99999>>>>>>>>>Define MAPI_E_UNKNOWN_RECIPIENT        For 14
99999>>>>>>>>>Define MAPI_E_BAD_RECIPTYPE            For 15
99999>>>>>>>>>Define MAPI_E_NO_MESSAGES              For 16
99999>>>>>>>>>Define MAPI_E_INVALID_MESSAGE          For 17
99999>>>>>>>>>Define MAPI_E_TEXT_TOO_LARGE           For 18
99999>>>>>>>>>Define MAPI_E_INVALID_SESSION          For 19
99999>>>>>>>>>Define MAPI_E_TYPE_NOT_SUPPORTED       For 20
99999>>>>>>>>>Define MAPI_E_AMBIGUOUS_RECIPIENT      For 21
99999>>>>>>>>>Define MAPI_E_AMBIG_RECIP              For MAPI_E_AMBIGUOUS_RECIPIENT
99999>>>>>>>>>Define MAPI_E_MESSAGE_IN_USE           For 22
99999>>>>>>>>>Define MAPI_E_NETWORK_FAILURE          For 23
99999>>>>>>>>>Define MAPI_E_INVALID_EDITFIELDS       For 24
99999>>>>>>>>>Define MAPI_E_INVALID_RECIPS           For 25
99999>>>>>>>>>Define MAPI_E_NOT_SUPPORTED            For 26
99999>>>>>>>Use WinKern.pkg
99999>>>>>>>
99999>>>>>>>External_Function MAPILogon "MAPILogon" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszProfileName ;   Pointer lpszPassword ;   Integer flFlags ;   Integer ulReserved ;   Pointer lplhSession ;   Returns Integer
100000>>>>>>>External_Function MAPILogoff "MAPILogoff" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
100001>>>>>>>External_Function MAPIFindNext "MAPIFindNext" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageType ;   Pointer lpszSeedMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
100002>>>>>>>External_Function MAPIFreeBuffer "MAPIFreeBuffer" Mapi32.Dll ;   Pointer pv ;   Returns Integer
100003>>>>>>>External_Function MAPIReadMail "MAPIReadMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppMessage ;   Returns Integer
100004>>>>>>>External_Function MAPIAddress "MAPIAddress" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszCaption ;   Integer nEditFields ;   Pointer lpszLabels ;   Integer nRecips ;   Pointer lpRecips ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpnNewRecips ;   Pointer lppNewRecips ;   Returns Integer
100005>>>>>>>External_Function MAPIResolveName "MAPIResolveName" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszName ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppRecip ;   Returns Integer
100006>>>>>>>External_Function MAPISendMail "MAPISendMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
100007>>>>>>>External_Function MAPISaveMail "MAPISaveMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
100008>>>>>>>External_Function MAPIDeleteMail "MAPIDeleteMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
100009>>>>>>>External_Function MAPISendDocuments "MAPISendDocuments" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszDelimChar ;   Pointer lpszFullPaths ;   Pointer lpszFileNames ;   Integer ulReserved ;   Returns Integer
100010>>>>>>>External_Function MAPIDetails "MAPIDetails" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpRecip ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
100011>>>>>>>
100011>>>>>>>External_Function ShellExecute "ShellExecuteA" Shell32.Dll ;   Handle hwnd ;   String sOperation ;   String sFile ;   String sParameters ;   String sDirectory ;   Integer nShowCmd ;   Returns VOID_TYPE
100012>>>>>Use DFBTRDRV.PKG
100012>>>>>Use MSSqldrv.pkg
100012>>>>>Use db2_drv.pkg
100012>>>>>Use odbc_drv.pkg
100012>>>>>Use seq_chnl.pkg
100012>>>>>Use Std_help.pkg
Including file: Std_help.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Std_help.pkg)
100012>>>>>>>// STD_HELP.PKG
100012>>>>>>>//
100012>>>>>>>// Global Help Object
100012>>>>>>>//
100012>>>>>>>//  Creates all Help Support required to access WINDOWs help system
100012>>>>>>>//  with DataFlex. Creates a global object named Help_Object.
100012>>>>>>>//
100012>>>>>>>//  9/19/97 JJT - Modified to define stadnard help Ids if they are undefined
100012>>>>>>>
100012>>>>>>>use DFHlpSys.pkg // Context Sensitive Help Support for Windows and HTML
Including file: Dfhlpsys.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfhlpsys.pkg)
100012>>>>>>>>>//************************************************************************
100012>>>>>>>>>//
100012>>>>>>>>>// Confidential Trade Secret.
100012>>>>>>>>>// Copyright (c) 1997-2002 Data Access Corporation, Miami Florida
100012>>>>>>>>>// as an unpublished work.  All rights reserved.
100012>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
100012>>>>>>>>>//
100012>>>>>>>>>//***********************************************************************/
100012>>>>>>>>>
100012>>>>>>>>>//************************************************************************
100012>>>>>>>>>// DFHlpSys.pkg
100012>>>>>>>>>//  12-07-1994 : Created
100012>>>>>>>>>//  8/29/2002  : major changes
100012>>>>>>>>>//
100012>>>>>>>>>// Author: John J. Tuohy
100012>>>>>>>>>//
100012>>>>>>>>>// This package loads support the windows help and html help. It used to define
100012>>>>>>>>>// a bunch of desktop help messages, but as of 8.3 those have been moved into
100012>>>>>>>>>// objects via a dfbase mixin. The only reason this package remains here is that
100012>>>>>>>>>// std_help.pkg calls it.
100012>>>>>>>>>//************************************************************************
100012>>>>>>>>>
100012>>>>>>>>>use DFHlpCl.pkg    // Define the Help_System Class for windows
Including file: Dfhlpcl.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfhlpcl.pkg)
100012>>>>>>>>>>>//************************************************************************
100012>>>>>>>>>>>//
100012>>>>>>>>>>>// Confidential Trade Secret.
100012>>>>>>>>>>>// Copyright 1997-2001 Data Access Corporation, Miami FL, USA
100012>>>>>>>>>>>// All Rights reserved
100012>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//************************************************************************
100012>>>>>>>>>>>//
100012>>>>>>>>>>>// $File name  : DFHlpCl.pkg
100012>>>>>>>>>>>// $File title : HelpSystem class support
100012>>>>>>>>>>>// Notice      :
100012>>>>>>>>>>>// $Author(s)  : John Tuohy
100012>>>>>>>>>>>//
100012>>>>>>>>>>>// $Rev History
100012>>>>>>>>>>>//
100012>>>>>>>>>>>// 07/19/01 SWB - added support for the Application object's psHelpFile
100012>>>>>>>>>>>//                to override any value in the global Workspace object
100012>>>>>>>>>>>// 11/17/97 JJT - added missing set help_filename method.
100012>>>>>>>>>>>// 10/15/97 JJT - changed define_symbol to define
100012>>>>>>>>>>>// 6/27/97  JJT - Modified low level help calls to work better in 95 help.
100012>>>>>>>>>>>// 07/23/96 JJT - New Class names
100012>>>>>>>>>>>// 01/27/96 JJT - Changed to from DAF to DF
100012>>>>>>>>>>>// 02/14/95 JJT - Added DFGSINI for 3.01/3.05 dual support of .ini name
100012>>>>>>>>>>>//                and section name.
100012>>>>>>>>>>>//************************************************************************
100012>>>>>>>>>>>// VDF8 changes
100012>>>>>>>>>>>// 10/23/2001 JJT - use ReadString instead of System_profile_string
100012>>>>>>>>>>>//************************************************************************
100012>>>>>>>>>>>
100012>>>>>>>>>>>// Help System Package
100012>>>>>>>>>>>//
100012>>>>>>>>>>>// Public Properties that should be set:
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//     Property String  Help_Filename   (Help_File_Default(self))
100012>>>>>>>>>>>//     Property Integer Help_Id_General 0
100012>>>>>>>>>>>//     Property Integer Help_Id_Index   0
100012>>>>>>>>>>>//     Property Integer Help_Id_Keys    0
100012>>>>>>>>>>>//     Property Integer Help_Id_Files   0
100012>>>>>>>>>>>//     Property Integer Help_Id_Errors  0
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//
100012>>>>>>>>>>>// Public messsages which are sent to this object:
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//    procedure View_Context_KeyWord_Help integer Obj
100012>>>>>>>>>>>//    procedure View_Context_ID_Help      integer Obj
100012>>>>>>>>>>>//    procedure View_Context_Help         integer Obj
100012>>>>>>>>>>>//    procedure View_Help_for_help        integer Obj
100012>>>>>>>>>>>//    procedure View_help_index           integer Obj
100012>>>>>>>>>>>//    procedure View_Keys_Help            integer Obj
100012>>>>>>>>>>>//    procedure View_File_Help            integer Obj
100012>>>>>>>>>>>//    procedure View_Error_Help           integer Obj
100012>>>>>>>>>>>//    procedure View_Help_on_Topic        integer Obj
100012>>>>>>>>>>>//
100012>>>>>>>>>>>// Protected Messages:
100012>>>>>>>>>>>//        These messages invoke the Window's help system and are not
100012>>>>>>>>>>>//        directly sent by outside objects. They are sent by public
100012>>>>>>>>>>>//        "view_xxx" messages and might be used if you are creating
100012>>>>>>>>>>>//        a sub-class of an object-class.
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//    Procedure Exec_System_Context_Help  integer Context_id
100012>>>>>>>>>>>//    Procedure Exec_System_Help          string  Keyword
100012>>>>>>>>>>>//    Procedure Exec_Context_Help         string  Context
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//    Functions for converting DF help IDs to windows Help Ids
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//        Any of these can return either a string or an integer.
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//    Function System_Help_Context_id Integer ID Returns String
100012>>>>>>>>>>>//           Convert a DF help context id into a windows id. By default,
100012>>>>>>>>>>>//           just return the same value (a one to one match). This is called
100012>>>>>>>>>>>//           by View_Context_id_help and View_Context_Help
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//    Function System_Help_File_Id Integer File# Integer Field# Returns String
100012>>>>>>>>>>>//           Convert file and field into a help id. By default it returns the
100012>>>>>>>>>>>//           file#. Called by View_File_Help.
100012>>>>>>>>>>>//
100012>>>>>>>>>>>//    Function System_Help_Error_id Integer Id Returns String
100012>>>>>>>>>>>//           Convert an error message into an ID. Right now it returns the
100012>>>>>>>>>>>//           the general error context id property, Help_id_errors. This
100012>>>>>>>>>>>//           will invoke general error help. If you want error support at the
100012>>>>>>>>>>>//           error# level you will have to determine the program to help
100012>>>>>>>>>>>//           interface yourself. Errors have a very large range and it is
100012>>>>>>>>>>>//           therefore hard to come up with an automatic numbering scheme.
100012>>>>>>>>>>>//           Called by View_Error_Help.
100012>>>>>>>>>>>
100012>>>>>>>>>>>
100012>>>>>>>>>>>Use Windows.pkg
100012>>>>>>>>>>>Use WinHlp.pkg // low level help call to windows API provides global message gDoWinHelp
100012>>>>>>>>>>>Use HelpSystemConstants.pkg // constants used by help system
100012>>>>>>>>>>>
100012>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
100012>>>>>>>>>>>Register_function peHelpType  returns integer
100012>>>>>>>>>>>
100012>>>>>>>>>>>class HelpSystem is an cObject
100013>>>>>>>>>>>
100013>>>>>>>>>>>    register_function Help_File_Default returns string
100013>>>>>>>>>>>
100013>>>>>>>>>>>    procedure Construct_Object
100015>>>>>>>>>>>       Forward send Construct_Object
100017>>>>>>>>>>>
100017>>>>>>>>>>>       // Help file name only. If set, this overrides all other settings.
100017>>>>>>>>>>>       Property String psHelpFile
100018>>>>>>>>>>>
100018>>>>>>>>>>>       // Help_FileName
100018>>>>>>>>>>>       //   full path name of Help file. The default value grabs its value
100018>>>>>>>>>>>       //   from .ini or environment settings. See functiob Help_file_Default
100018>>>>>>>>>>>       //
100018>>>>>>>>>>>       Property String  Private.Help_Filename (Help_File_Default(self))
100019>>>>>>>>>>>
100019>>>>>>>>>>>       // The following properties are the default values for the help files
100019>>>>>>>>>>>       // IDs for the various subjects. Setting these requires an agreement
100019>>>>>>>>>>>       // between the DF help system and the help file.
100019>>>>>>>>>>>       //
100019>>>>>>>>>>>       Property Integer Help_Id_General  0
100020>>>>>>>>>>>       Property Integer Help_Id_Index    0
100021>>>>>>>>>>>       Property Integer Help_Id_Keys     0
100022>>>>>>>>>>>       Property Integer Help_Id_Files    0
100023>>>>>>>>>>>       Property Integer Help_Id_Errors   0
100024>>>>>>>>>>>
100024>>>>>>>>>>>       // this is now the default help object
100024>>>>>>>>>>>       Move self to Help_Object_id
100025>>>>>>>>>>>    End_Procedure
100026>>>>>>>>>>>
100026>>>>>>>>>>>   // New rules for VDF8:
100026>>>>>>>>>>>   // 1. If psHelpFile exists, find the file in the file path and use it
100026>>>>>>>>>>>   // 2. If application object exists and help type is windows, use psHelpFile from there, find in file path and use it.
100026>>>>>>>>>>>   // 3. If no help file exists, use thge old private help name (which gets the full name from the registry -only if no app object)
100026>>>>>>>>>>>   //    Last method is deprecated and only used for old applications
100026>>>>>>>>>>>   //
100026>>>>>>>>>>>   Function Help_filename returns string
100028>>>>>>>>>>>        string sHelpName
100028>>>>>>>>>>>        // If ghoWorkSpace Get Help_FileName of ghoWorkSpace to sHelpName // removed for VDF8
100028>>>>>>>>>>>
100028>>>>>>>>>>>        // If an Application object is used, take the name from there.
100028>>>>>>>>>>>        Get psHelpFile to sHelpName
100029>>>>>>>>>>>        If (sHelpName="" AND ghoApplication AND peHelpType(ghoApplication)=htWinHelp) Begin
100031>>>>>>>>>>>            Get psHelpFile of ghoApplication To sHelpName
100032>>>>>>>>>>>            //Move (psHelpPath(phoWorkspace(ghoApplication)) -"\" -sHelpName) To sHelpName
100032>>>>>>>>>>>        End
100032>>>>>>>>>>>>
100032>>>>>>>>>>>        If (sHelpName<>"") begin
100034>>>>>>>>>>>            Get_File_Path sHelpName To sHelpName
100035>>>>>>>>>>>            Function_Return sHelpName
100036>>>>>>>>>>>        end
100036>>>>>>>>>>>>
100036>>>>>>>>>>>        // if not set anywhere (and ideally it is) we use this.
100036>>>>>>>>>>>        Get Private.Help_FileName to sHelpName
100037>>>>>>>>>>>        Function_Return sHelpName
100038>>>>>>>>>>>    End_Function
100039>>>>>>>>>>>
100039>>>>>>>>>>>    Procedure Set Help_FileName string sName
100041>>>>>>>>>>>        Set Private.Help_FileName to sName
100042>>>>>>>>>>>    End_Procedure
100043>>>>>>>>>>>
100043>>>>>>>>>>>
100043>>>>>>>>>>>
100043>>>>>>>>>>>    // Consider this message PRIVATE in that it should only be changed
100043>>>>>>>>>>>    // by a sub-class and not an object. It is called in construct_object
100043>>>>>>>>>>>    // before it knows about object augmentations!!!!
100043>>>>>>>>>>>    //
100043>>>>>>>>>>>    //  Sets the Help_file_name by looking at the .INI file for:
100043>>>>>>>>>>>    //        HELP_DIR    - help directory (will check environment variable
100043>>>>>>>>>>>    //                      windir if not found - avoid this usage). If not
100043>>>>>>>>>>>    //                      blank append "\" as required.
100043>>>>>>>>>>>    //
100043>>>>>>>>>>>    //        HELP_FILE   - help file name. If blank uses the default help
100043>>>>>>>>>>>    //                      file name
100043>>>>>>>>>>>    //
100043>>>>>>>>>>>    Function Help_File_Default Returns String
100045>>>>>>>>>>>       String HelpFileDir HelpFileName sSubKey
100045>>>>>>>>>>>       // if using the application object we expect the help name to be
100045>>>>>>>>>>>       // defined in the application object or directly in the help object. No Exceptions
100045>>>>>>>>>>>       If (ghoApplication) function_return ""
100048>>>>>>>>>>>
100048>>>>>>>>>>>       // else if no application (and hence no WS) use an old deprecated method of checking
100048>>>>>>>>>>>       // for the module name in local_machine.
100048>>>>>>>>>>>       Get Module_name of Desktop to sSubKey
100049>>>>>>>>>>>       Get_Profile_String sSubKey HELP_DIR to HelpFileDir
100052>>>>>>>>>>>       Get_Profile_String sSubKey HELP_FILE to HelpFileName
100055>>>>>>>>>>>       // if dir exists, sure it has a "\" at the end. If no directory the
100055>>>>>>>>>>>       // dir must be blank so current directory is searched
100055>>>>>>>>>>>       If ( (HelpFileDir<>'') AND (Right(HelpFileDir,1)<>"\") ) ;          Move (HelpFileDir - '\') to HelpFileDir
100058>>>>>>>>>>>       If HelpFileName eq '' Move DEFAULT_HELP_FILENAME to HelpFileName
100061>>>>>>>>>>>       Function_Return (HelpFileDir - HelpFileName)
100062>>>>>>>>>>>    End_Function
100063>>>>>>>>>>>
100063>>>>>>>>>>>    // The System_Help_xxxx messages convert a DF help integer ID into
100063>>>>>>>>>>>    // a context value that can be used by the windows help system. If
100063>>>>>>>>>>>    // you return a number or a string. Numbers will get used for context ID
100063>>>>>>>>>>>    // help, non-numbers get used for keyword context help
100063>>>>>>>>>>>
100063>>>>>>>>>>>    // By default return ID passed. This creates a direct mapping between
100063>>>>>>>>>>>    // context IDs in your object and the context IDs in windows help.
100063>>>>>>>>>>>    //
100063>>>>>>>>>>>    Function System_Help_Context_id Integer ID Returns String
100065>>>>>>>>>>>       Function_Return ID
100066>>>>>>>>>>>    End_Function // System_Help_Context_id
100067>>>>>>>>>>>
100067>>>>>>>>>>>    // Returns the file# which assumes that we have a direct mapping between
100067>>>>>>>>>>>    // the file number and a window's help context_id. We are ignoring field#
100067>>>>>>>>>>>    // in this case (although your augmentation would not have to). If the
100067>>>>>>>>>>>    // file# is 0, return a the HELP_ID context id.
100067>>>>>>>>>>>    //
100067>>>>>>>>>>>    Function System_Help_File_Id Integer File# Integer Field# Returns String
100069>>>>>>>>>>>       String rVal
100069>>>>>>>>>>>       if File# eq 0 Move (Help_id_files(self)) to rVal
100072>>>>>>>>>>>       Else Move File# to rVal
100074>>>>>>>>>>>       Function_Return Rval
100075>>>>>>>>>>>    End_Function // System_Help_File_id
100076>>>>>>>>>>>
100076>>>>>>>>>>>    // Convert an error id into a help context id. Return the general
100076>>>>>>>>>>>    // Help id property value. We do this because error number have
100076>>>>>>>>>>>    // a rather large range (1-9000) and just using the number would consume
100076>>>>>>>>>>>    // too much of the context id space.
100076>>>>>>>>>>>    //
100076>>>>>>>>>>>    Function System_Help_Error_id Integer Id Returns String
100078>>>>>>>>>>>       Function_Return (Help_Id_Errors(self))
100079>>>>>>>>>>>    End_Function // System_Help_Error_id
100080>>>>>>>>>>>
100080>>>>>>>>>>>    // Use this if you want your help context to be keyword based
100080>>>>>>>>>>>    //
100080>>>>>>>>>>>    procedure View_Context_KeyWord_Help integer Obj
100082>>>>>>>>>>>       String Context
100082>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of obj HELP_CONTEXT_KEYWORD to Context
100085>>>>>>>>>>>       Send Exec_System_Help Context
100086>>>>>>>>>>>    end_procedure
100087>>>>>>>>>>>
100087>>>>>>>>>>>    // Use this if you want your help context to be ID based
100087>>>>>>>>>>>    //
100087>>>>>>>>>>>    procedure View_Context_ID_Help integer Obj
100089>>>>>>>>>>>       Integer Context_ID
100089>>>>>>>>>>>       String Context
100089>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of Obj HELP_CONTEXT_ID to Context_ID
100092>>>>>>>>>>>       Get System_Help_Context_id Context_Id to Context
100093>>>>>>>>>>>       Send Exec_Context_Help Context
100094>>>>>>>>>>>    end_procedure
100095>>>>>>>>>>>
100095>>>>>>>>>>>    // Use this is you want the object requesting help to support either
100095>>>>>>>>>>>    // keyword or context ID help (it will use whatever it finds first).
100095>>>>>>>>>>>    //
100095>>>>>>>>>>>    procedure View_Context_Help integer Obj
100097>>>>>>>>>>>       String Context
100097>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of obj HELP_CONTEXT_ID_OR_KEY to Context
100100>>>>>>>>>>>       if (left(context,1)) in '0123456789' ;          Get System_Help_Context_id Context to Context
100103>>>>>>>>>>>       Send Exec_Context_Help Context
100104>>>>>>>>>>>    end_procedure
100105>>>>>>>>>>>
100105>>>>>>>>>>>    Procedure View_Help_for_Help Integer obj
100107>>>>>>>>>>>        Send Exec_System_Help HELP_FOR_HELP_STRING
100108>>>>>>>>>>>    end_procedure
100109>>>>>>>>>>>
100109>>>>>>>>>>>    Procedure View_Help_Index integer obj
100111>>>>>>>>>>>       Send Exec_Context_Help (Help_id_index(self))
100112>>>>>>>>>>>    End_Procedure // View_help_index
100113>>>>>>>>>>>
100113>>>>>>>>>>>    procedure View_Keys_Help Integer Obj
100115>>>>>>>>>>>        Send Exec_Context_Help (Help_id_keys(self))
100116>>>>>>>>>>>    end_procedure
100117>>>>>>>>>>>
100117>>>>>>>>>>>    Procedure View_File_Help Integer Obj
100119>>>>>>>>>>>       String Context FilFld
100119>>>>>>>>>>>       Integer File# Field# Dot
100119>>>>>>>>>>>       If Obj gt 0 Begin
100121>>>>>>>>>>>          // This should return the file and field as a string in
100121>>>>>>>>>>>          // FFF.fff format (F=File, f=format).
100121>>>>>>>>>>>          Get Help_Context of Obj HELP_CONTEXT_DATAFILE to FilFld
100122>>>>>>>>>>>          // Parse FilFld into File# and Field#.
100122>>>>>>>>>>>          Pos '.' in FilFld to Dot
100124>>>>>>>>>>>>
100124>>>>>>>>>>>          if Dot ne 0 begin
100126>>>>>>>>>>>             Left FilFld to File#  (dot-1)
100128>>>>>>>>>>>>
100128>>>>>>>>>>>             Mid  FilFld to Field# 255 (dot+1)
100131>>>>>>>>>>>>
100131>>>>>>>>>>>          End
100131>>>>>>>>>>>>
100131>>>>>>>>>>>       End
100131>>>>>>>>>>>>
100131>>>>>>>>>>>       Get System_Help_File_id File# Field# to Context
100132>>>>>>>>>>>       Send Exec_Context_Help Context
100133>>>>>>>>>>>    End_Procedure // View_File_Help
100134>>>>>>>>>>>
100134>>>>>>>>>>>    //  View help on an error. Current version uses context id help.
100134>>>>>>>>>>>    //  The error number should be in global integer last_err
100134>>>>>>>>>>>    //
100134>>>>>>>>>>>    procedure View_Error_Help Integer Obj
100136>>>>>>>>>>>        String Context
100136>>>>>>>>>>>        If Obj gt 0 ;           Get Help_Context of obj HELP_CONTEXT_ERROR to Context
100139>>>>>>>>>>>        if (left(context,1)) in '0123456789' ;           Get System_Help_Error_id Context to Context
100142>>>>>>>>>>>        Send Exec_Context_Help Context
100143>>>>>>>>>>>    end_procedure
100144>>>>>>>>>>>
100144>>>>>>>>>>>    // View list of help topics.
100144>>>>>>>>>>>    //
100144>>>>>>>>>>>    Procedure View_Help_on_Topic Integer obj
100146>>>>>>>>>>>        Send Exec_System_Help HELP_ON_TOPIC_STRING
100147>>>>>>>>>>>    end_procedure
100148>>>>>>>>>>>
100148>>>>>>>>>>>    // Request context help. If context is a number assume that it is
100148>>>>>>>>>>>    // context id help, else assume it is keyword help.
100148>>>>>>>>>>>    //
100148>>>>>>>>>>>    Procedure Exec_Context_Help string Context
100150>>>>>>>>>>>       if (left(context,1)) in '0123456789' ;    // if first character is a          Send Exec_System_Context_Help Context  // numeric we assume ID help
100153>>>>>>>>>>>       else ;                                    // otherwise we assume key-          Send Exec_System_Help Context          // word help.
100155>>>>>>>>>>>    End_Procedure // Exec_Context_Help
100156>>>>>>>>>>>
100156>>>>>>>>>>>    // NOTE: the following two messages are the only messages that directly make calls
100156>>>>>>>>>>>    //       to the windows API. This is important. These two messages could be changed
100156>>>>>>>>>>>    //       to call other help systems (e.g. HTML help) and the rest of the high level
100156>>>>>>>>>>>    //       program remains the same. These are the only two messages that are
100156>>>>>>>>>>>    //       expected to be windows help centric.
100156>>>>>>>>>>>
100156>>>>>>>>>>>    // Get Context Id help for passed ID. Use help file as defined
100156>>>>>>>>>>>    // in Help_filename. If id is 0 use general help id (which must be
100156>>>>>>>>>>>    // defined.
100156>>>>>>>>>>>    //
100156>>>>>>>>>>>    Procedure Exec_System_Context_Help integer Context_id
100158>>>>>>>>>>>        If Context_Id eq 0 ; // if zero, see if we have a contents page            Move (Help_Id_General(self)) to Context_id
100161>>>>>>>>>>>        If Context_Id eq 0 ; // if still zero, jump to the topics popup dialog            Send Exec_System_Help HELP_ON_TOPIC_STRING
100164>>>>>>>>>>>        Else ;            Send gDoWinHelp WH_INTCONTEXT (Help_Filename(self)) Context_Id
100166>>>>>>>>>>>    end_procedure
100167>>>>>>>>>>>
100167>>>>>>>>>>>    // Get keyword help for passed keyword. Use help file as defined
100167>>>>>>>>>>>    // in help_filename.
100167>>>>>>>>>>>    //
100167>>>>>>>>>>>    procedure Exec_System_Help string Keyword
100169>>>>>>>>>>>        If Keyword eq HELP_FOR_HELP_STRING ;            Send gDoWinHelp WH_HELPONHELP
100172>>>>>>>>>>>        else if (Keyword eq HELP_ON_TOPIC_STRING OR KeyWord="");            Send gDoWinHelp WH_FINDER (Help_Filename(self))
100176>>>>>>>>>>>        else ;            Send gDoWinHelp WH_STRINGCONTEXT (Help_Filename(self)) KeyWord
100178>>>>>>>>>>>    end_procedure
100179>>>>>>>>>>>
100179>>>>>>>>>>>end_class
100180>>>>>>>>>use cHtmlHelp.pkg //  Define the help class for Html
100180>>>>>>>
100180>>>>>>>
100180>>>>>>>// This file needs to be provided by the developer. It will contain
100180>>>>>>>// symbolic replacements for the ID integer values used to access the
100180>>>>>>>// the windows help file's topics.
100180>>>>>>>//
100180>>>>>>>use Help_ids.inc
Including file: Help_ids.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Help_ids.inc)
100180>>>>>>>>>// Help_ids.inc
100180>>>>>>>>>//
100180>>>>>>>>>// Context ids. This uses help file Developer5.chm.
100180>>>>>>>>>//
100180>>>>>>>>>// This is a sample version. YOU must supply
100180>>>>>>>>>// the ID values
100180>>>>>>>>>
100180>>>>>>>>>//  Generic Context Ids
100180>>>>>>>>>//
100180>>>>>>>>>Define SQLConnectionsProgram for 0
100180>>>>>>>>>
100180>>>>>>>>>// It is expected that file-names ids will be the same as their
100180>>>>>>>>>// filenumber.
100180>>>>>>>>>
100180>>>>>>>>>
100180>>>>>>>>>//  View and selection-list specific context ids
100180>>>>>>>>>//
100180>>>>>>>>>//..........add view, object, selection-list ids here....
100180>>>>>>>
100180>>>>>>>// If the following are not defined in help_ids.inc,
100180>>>>>>>//  create default 0 values for them
100180>>>>>>>Define GeneralHelpId    for    0
100180>>>>>>>Define KeysHelpId       for    0
100180>>>>>>>Define FileHelpId       for    0
100180>>>>>>>Define ErrorHelpId      for    0  // probably not used in VDF
100180>>>>>>>Define IndexHelpId      for    0  // probably not used in VDF
100180>>>>>>>
100180>>>>>>>object Help_Object is a HelpSystem // global windows HLP help object
100182>>>>>>>
100182>>>>>>>   Set Help_Id_General to GeneralHelpId    // these should all be defined
100183>>>>>>>   Set Help_Id_Index   to IndexHelpId      // in help_ids.inc.
100184>>>>>>>   Set Help_Id_Keys    to KeysHelpId       //
100185>>>>>>>   Set Help_Id_Files   to FileHelpId       //
100186>>>>>>>   Set Help_Id_Errors  to ErrorHelpId      //
100187>>>>>>>
100187>>>>>>>end_object
100188>>>>>>>
100188>>>>>>>Object oHtmlHelp is a cHtmlHelp // this also defines ghoHtmlHelp
100190>>>>>>>End_Object
100191>>>>>
100191>>>>>Register_Function phoWorkspace Returns Handle
100191>>>>>Register_Function Help_filename Returns String
100191>>>>>Register_Function GetHelpFile Returns String
100191>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
100191>>>>>
100191>>>>>// Use of Mertech drivers:
100191>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>// *** Constant Declarations: ***
100191>>>>>//
100191>>>>>
100191>>>>>// NOTE: These text constants should be added to the various "Language_xxx.inc" files:
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>
100191>>>>>// System icon menu constants. If the upper left hand
100191>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
100191>>>>>    Define SC_RESTORE  for |CI$F120
100191>>>>>    Define SC_MOVE     for |CI$F010
100191>>>>>    Define SC_SIZE     for |CI$F000
100191>>>>>    Define SC_MINIMIZE for |CI$F020
100191>>>>>    Define SC_MAXIMIZE for |CI$F030
100191>>>>>    Define SC_CLOSE    for |CI$F060
100191>>>>>    Define SC_KEYMENU  for |CI$F100
100191>>>>>    Define SC_NEXTWINDOW for |CI$F040
100191>>>>>    Define SC_PREVWINDOW for |CI$F050
100191>>>>>
100191>>>>>// *** Struct Declarations: ***
100191>>>>>Struct tWinMemoryStatusEx
100191>>>>>    UInteger dwLength
100191>>>>>    UInteger dwMemoryLoad
100191>>>>>    UBigInt ullTotalPhys
100191>>>>>    UBigInt ullAvailPhys
100191>>>>>    UBigInt ullTotalPageFile
100191>>>>>    UBigInt ullAvailPageFile
100191>>>>>    UBigInt ullTotalVirtual
100191>>>>>    UBigInt ullAvailVirtual
100191>>>>>    UBigInt ullAvailExtendedVirtual
100191>>>>>End_Struct
100191>>>>>
100191>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
100191>>>>>Type MEMORYSTATUS
100191>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
100191>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
100191>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
100191>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
100191>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
100191>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
100191>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
100191>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
100191>>>>>End_Type
100191>>>>>
100191>>>>>// *** External Function calls: ***
100191>>>>>//
100191>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
100192>>>>>
100192>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
100193>>>>>
100193>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
100194>>>>>
100194>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
100195>>>>>
100195>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
100196>>>>>
100196>>>>>// *** Global/Desktop Function Declarations: ***
100196>>>>>
100196>>>>>Function ComputerName for Desktop Returns String
100198>>>>>    String sName
100198>>>>>    Get_Environment "COMPUTERNAME" to sName
100199>>>>>>
100199>>>>>    Function_Return sName
100200>>>>>End_Function
100201>>>>>
100201>>>>>Function Network_User_Name for cDesktop Returns String
100203>>>>>    String sName
100203>>>>>    Get_Environment "USERNAME" to sName
100204>>>>>>
100204>>>>>    Function_Return sName
100205>>>>>End_Function
100206>>>>>
100206>>>>>// *** Class Declarations: ***
100206>>>>>//
100206>>>>>Class cBitmapContainerVDFLink is a BitmapContainer
100207>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
100209>>>>>        Send Mouse_Up iWindowNumber iPosition
100210>>>>>    End_Procedure
100211>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
100213>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
100215>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
100216>>>>>    End_Procedure
100217>>>>>End_Class
100218>>>>>
100218>>>>>Class cCopyEditorContentButton is a Button
100219>>>>>    Procedure Construct_Object
100221>>>>>        Forward Send Construct_Object
100223>>>>>        Property Handle phoEditorHandle
100224>>>>>        Set psToolTip to C_$DescCopy
100225>>>>>    End_Procedure
100226>>>>>
100226>>>>>    Procedure CopyToWindowsClipboard
100228>>>>>        String sValue
100228>>>>>        Handle hoEditor
100228>>>>>        Boolean bCanCopy
100228>>>>>        Address aEditorAddress
100228>>>>>
100228>>>>>        Get phoEditorHandle to hoEditor
100229>>>>>        Send Select_All of hoEditor
100230>>>>>        Get CanCopy of hoEditor to bCanCopy
100231>>>>>        If (bCanCopy = True) Begin
100233>>>>>            Get paValue of hoEditor to aEditorAddress
100234>>>>>            Move aEditorAddress to sValue
100235>>>>>            Send Copy   of hoEditor
100236>>>>>            // Remove the selection after text is copied to the clipboard.
100236>>>>>            Send Beginning_of_Data of hoEditor
100237>>>>>            Send Info_Box C_$CopyToClipboard_Text
100238>>>>>        End
100238>>>>>>
100238>>>>>    End_Procedure
100239>>>>>End_Class
100240>>>>>
100240>>>>>Class SysinfoDisplay is a cTextEdit
100241>>>>>    Procedure Construct_Object
100243>>>>>        Forward Send Construct_Object
100245>>>>>
100245>>>>>        Set Size to 104 247
100246>>>>>        Set Location to 4 6
100247>>>>>        Set Border_Style to Border_None
100248>>>>>        Set peAnchors to anAll
100249>>>>>        Set Read_Only_State to True
100250>>>>>        Set pbWrap to True
100251>>>>>    End_Procedure
100252>>>>>
100252>>>>>    // Augmented class message to adjust certain text strings that are wrong...
100252>>>>>
100252>>>>>    Procedure AppendTextLn String sText
100254>>>>>        String sWorkspaceWSFile
100254>>>>>
100254>>>>>        // Only works for English:
100254>>>>>        If (ghoApplication > 0) Begin
100256>>>>>            If (sText contains "Workspace Name") Begin
100258>>>>>                Move "Workspace Config Filename:" to sText
100259>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
100260>>>>>                Move (sText * sWorkspaceWSFile) to sText
100261>>>>>            End
100261>>>>>>
100261>>>>>        End
100261>>>>>>
100261>>>>>        Send AppendText sText
100262>>>>>        Send AppendText (character(10))
100263>>>>>    End_Procedure
100264>>>>>
100264>>>>>    //****************************************************************************
100264>>>>>    // $Module type: PROCEDURE
100264>>>>>    // $Module name: Show_Current_Directory
100264>>>>>    // $Author     : VOO
100264>>>>>    // Created     : 06-10-96 @ 15:24
100264>>>>>    //
100264>>>>>    // Description
100264>>>>>    //    This method will show the name Of the current directory in the system
100264>>>>>    //    information box
100264>>>>>    //
100264>>>>>    // $Rev History
100264>>>>>    //    06-10-96  Module header created
100264>>>>>    //****************************************************************************
100264>>>>>    Procedure Show_Current_Directory
100266>>>>>        String sDir
100266>>>>>
100266>>>>>        Get_Current_Directory To sDir
100267>>>>>
100267>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
100268>>>>>    End_Procedure
100269>>>>>
100269>>>>>    Procedure Show_Windows_Directory
100271>>>>>        String sWindir
100271>>>>>
100271>>>>>        Get_Windows_Directory To sWindir
100272>>>>>
100272>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
100273>>>>>    End_Procedure
100274>>>>>
100274>>>>>    Procedure Show_Current_User
100276>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
100277>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
100278>>>>>    End_Procedure
100279>>>>>
100279>>>>>    Procedure Show_Number_Format
100281>>>>>        Integer iFormat
100281>>>>>        String sFormatText
100281>>>>>
100281>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
100284>>>>>        Move (Character (iFormat)) To sFormatText
100285>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
100286>>>>>
100286>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
100289>>>>>        Move (Character (iFormat)) to sFormatText
100290>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
100291>>>>>    End_Procedure
100292>>>>>
100292>>>>>    Procedure Show_Filelist_Name
100294>>>>>        String sFilename
100294>>>>>
100294>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
100297>>>>>
100297>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
100298>>>>>    End_Procedure
100299>>>>>
100299>>>>>    Procedure Show_Lock_Delay
100301>>>>>        Integer iLockdelay
100301>>>>>
100301>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
100304>>>>>
100304>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
100305>>>>>    End_Procedure
100306>>>>>
100306>>>>>    Procedure Show_Lock_Timeout
100308>>>>>        Integer iLockTimeout
100308>>>>>
100308>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
100311>>>>>
100311>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
100312>>>>>    End_Procedure
100313>>>>>
100313>>>>>    Procedure Show_Screen_Size
100315>>>>>        Integer iYscreensize iXscreensize
100315>>>>>
100315>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
100316>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
100317>>>>>
100317>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
100318>>>>>    End_Procedure
100319>>>>>
100319>>>>>    Procedure Show_Page_Size
100321>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
100322>>>>>    End_procedure
100323>>>>>
100323>>>>>    Procedure Show_Date
100325>>>>>        Date dToday
100325>>>>>
100325>>>>>        Sysdate dToday
100326>>>>>
100326>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
100327>>>>>    End_procedure
100328>>>>>
100328>>>>>    Procedure Show_Date_Format
100330>>>>>        Integer iDateFormat
100330>>>>>        String sDateFormat
100330>>>>>
100330>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
100333>>>>>        Case Begin
100333>>>>>            Case (iDateFormat = DF_DATE_USA)
100335>>>>>                Move C_$USA To sDateFormat
100336>>>>>                Case Break
100337>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
100340>>>>>                Move C_$European To sDateFormat
100341>>>>>                Case Break
100342>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
100345>>>>>                Move C_$Military To sDateFormat
100346>>>>>                Case Break
100347>>>>>            Case Else
100347>>>>>                Move C_$UnknownDateType To sDateFormat
100348>>>>>                Case Break
100349>>>>>        Case End
100349>>>>>
100349>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
100350>>>>>    End_Procedure
100351>>>>>
100351>>>>>    // 2013-08-14 NGS
100351>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
100351>>>>>    Procedure Show_Systemresources
100353>>>>>        tWinMemoryStatusEx MemoryStatusInfo
100353>>>>>        tWinMemoryStatusEx MemoryStatusInfo
100353>>>>>        Integer iRetval
100353>>>>>        Number nValue
100353>>>>>        String sValue
100353>>>>>
100353>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
100354>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
100355>>>>>        If (iRetval = 0) Begin
100357>>>>>            Move (ShowLastError ()) to iRetval
100358>>>>>            Procedure_Return
100359>>>>>        End
100359>>>>>>
100359>>>>>
100359>>>>>        Send AppendTextLn ""
100360>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
100361>>>>>
100361>>>>>        // Show memory in Gigabytes:
100361>>>>>        Move (nValue/1024/1024/1024) to nValue
100362>>>>>        Move (Round(nValue)) to nValue
100363>>>>>        Get FormatNumber nValue 2 to sValue
100364>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
100365>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
100366>>>>>
100366>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
100366>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
100367>>>>>        Move (Round(nValue)) to nValue
100368>>>>>        Get FormatNumber nValue 0 to sValue
100369>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
100370>>>>>
100370>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
100370>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
100371>>>>>        Move (Round(nValue)) to nValue
100372>>>>>        Get FormatNumber nValue 0 to sValue
100373>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
100374>>>>>
100374>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
100374>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
100375>>>>>        Move (Round(nValue)) to nValue
100376>>>>>        Get FormatNumber nValue 0 to sValue
100377>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
100378>>>>>
100378>>>>>        // Add an empty row after the memory information:
100378>>>>>        Send AppendTextLn ""
100379>>>>>    End_Procedure
100380>>>>>
100380>>>>>    Procedure Show_Registration
100382>>>>>        String sRegName
100382>>>>>        Integer iSN iUsersMax iUserCount
100382>>>>>
100382>>>>>        Registration sRegName iSN
100383>>>>>>
100383>>>>>        Get_Licensed_Max_Users to iUsersMax
100384>>>>>        Get_Current_User_Count to iUserCount
100385>>>>>
100385>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
100386>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
100387>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
100388>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
100389>>>>>    End_Procedure
100390>>>>>
100390>>>>>    //****************************************************************************
100390>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
100390>>>>>    // To the workspace object passing the an object and message To send back
100390>>>>>    // To this object. It is expected that the workspace object will send this
100390>>>>>    // message for every line Of information it wants displayed (passing the
100390>>>>>    // information To be displayed
100390>>>>>    //****************************************************************************
100390>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
100390>>>>>
100390>>>>>    Procedure Show_ServicePack
100392>>>>>        String sKey sVersion sDataFlex
100392>>>>>        Handle hoRegistry
100392>>>>>        Boolean bExists bOpened
100392>>>>>
100392>>>>>        Move "DataFlex"        to sDataFlex
100393>>>>>
100393>>>>>        Get Create U_cRegistry to hoRegistry
100394>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
100395>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
100396>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
100397>>>>>
100397>>>>>        If (bExists) Begin
100399>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
100400>>>>>        End
100400>>>>>>
100400>>>>>        Else Begin
100401>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
100402>>>>>        End
100402>>>>>>
100402>>>>>        Get KeyExists of hoRegistry sKey to bExists
100403>>>>>        If (bExists) Begin
100405>>>>>            Get OpenKey of hoRegistry sKey to bOpened
100406>>>>>            If (bOpened) Begin
100408>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
100409>>>>>                If (bExists) Begin
100411>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
100412>>>>>                End
100412>>>>>>
100412>>>>>                Send CloseKey of hoRegistry
100413>>>>>            End
100413>>>>>>
100413>>>>>        End
100413>>>>>>
100413>>>>>        Send Destroy of hoRegistry
100414>>>>>
100414>>>>>        If (sVersion <> "") Begin
100416>>>>>           Send AppendTextLn sVersion
100417>>>>>           Send AppendTextLn ""
100418>>>>>        End
100418>>>>>>
100418>>>>>    End_Procedure
100419>>>>>
100419>>>>>    Procedure Show_WorkspaceInformation
100421>>>>>        Integer hoWorkspace
100421>>>>>
100421>>>>>        If (ghoApplication <> 0) Begin
100423>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
100424>>>>>            If (hoWorkspace <> 0) Begin
100426>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
100427>>>>>            End
100427>>>>>>
100427>>>>>        End
100427>>>>>>
100427>>>>>    End_Procedure
100428>>>>>
100428>>>>>    //****************************************************************************
100428>>>>>    // If connection ids are used, we will send the message EnumerateConnections
100428>>>>>    // to the connection manager object passing the an object and message to send
100428>>>>>    // back to this object. It is expected that the connection manager object will
100428>>>>>    // send this message for every line Of information it wants displayed (passing
100428>>>>>    // the information To be displayed
100428>>>>>    //****************************************************************************
100428>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
100428>>>>>
100428>>>>>    Procedure Show_ConnectionIdInformation
100430>>>>>        If (ghoConnection > 0) Begin
100432>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
100433>>>>>            Send AppendTextLn ""
100434>>>>>        End
100434>>>>>>
100434>>>>>    End_Procedure
100435>>>>>
100435>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
100437>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
100438>>>>>    End_Function
100439>>>>>
100439>>>>>    Procedure Show_Versions
100441>>>>>        Integer iVersion iRevision iBuild
100441>>>>>
100441>>>>>        Version_information iVersion iRevision iBuild
100443>>>>>
100443>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
100444>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
100445>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
100446>>>>>    End_Procedure
100447>>>>>
100447>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
100449>>>>>        Boolean bOK
100449>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
100450>>>>>        Function_Return bOK
100451>>>>>    End_Function
100452>>>>>
100452>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
100454>>>>>        Boolean bOK
100454>>>>>        Function_Return bOK
100455>>>>>    End_Function
100456>>>>>
100456>>>>>    //***
100456>>>>>    //*** BW
100456>>>>>    //*** Procedure: Show_Drivers
100456>>>>>    //*** Purpose  : Show loaded database drivers
100456>>>>>    //***
100456>>>>>
100456>>>>>    Procedure Show_Drivers
100458>>>>>        String sDriverID sVersion sClient sMertechSQLFlexVersion sValue
100458>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
100458>>>>>        Handle hoCLIHandler hoBtrvHandler
100458>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
100458>>>>>
100458>>>>>        Move False to bStudioLicense
100459>>>>>
100459>>>>>        Get Create U_cCLIHandler      to hoCLIHandler
100460>>>>>        Get Create U_cDFBtrDrvHandler to hoBtrvHandler
100461>>>>>
100461>>>>>        // For testing purposes:
100461>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
100461>>>>>//        Load_Driver MSSQLDRV_ID
100461>>>>>//        Load_Driver ODBC_DRV_ID
100461>>>>>//        Load_Driver DB2_DRV_ID
100461>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
100461>>>>>//
100461>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
100461>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
100461>>>>>//            Load_Driver SQLFLEX
100461>>>>>//            Load_Driver MDSPgSQL
100461>>>>>//            Load_Driver MDSMySQL
100461>>>>>//            Load_Driver ORAFLEX
100461>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
100461>>>>>//        #ENDIF
100461>>>>>        Move False to Err
100462>>>>>
100462>>>>>        // Loop through all loaded drivers.
100462>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
100465>>>>>        If (iNumberOfDrivers > 1) Begin
100467>>>>>            Send AppendTextLn ""
100468>>>>>        End
100468>>>>>>
100468>>>>>        For iDriver from 1 to iNumberOfDrivers
100474>>>>>>
100474>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
100474>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
100474>>>>>            // would be thrown, so we safeguard from that here.
100474>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
100475>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
100478>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
100479>>>>>            Get IsDAWSQLDriver sDriverID to bIsDAWDriver
100480>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
100481>>>>>
100481>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
100483>>>>>
100483>>>>>                // Pervasive/Btrieve database
100483>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
100485>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
100486>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
100487>>>>>                    If (sClient <> "0.0.0") Begin
100489>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
100490>>>>>                    End
100490>>>>>>
100490>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
100491>>>>>                    If (sClient <> "0.0.0") Begin
100493>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
100494>>>>>                    End
100494>>>>>>
100494>>>>>                End
100494>>>>>>
100494>>>>>
100494>>>>>                Else Begin
100495>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
100496>>>>>                    Move 0 to iNumServers
100497>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
100499>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
100502>>>>>                    End
100502>>>>>>
100502>>>>>
100502>>>>>                    If (bIsDAWDriver = True) Begin
100504>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
100506>>>>>                            // This info is only available for the MS SQL driver:
100506>>>>>                            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient
100509>>>>>                            If (iClient = 13) Move C_$SQLSERVER2016DRVRSTR              to sClient
100512>>>>>                            If (iClient = 12) Move C_$SQLSERVER2014DRVRSTR              to sClient
100515>>>>>                            If (iClient = 11) Move C_$SQL_Server_Native_Client_11_0     to sClient
100518>>>>>                            If (iClient = 10) Move C_$SQL_Server_Native_Client_10_0     to sClient
100521>>>>>                            If (iClient = 9)  Move C_$SQL_Native_Client                 to sClient
100524>>>>>                            If (iClient = 8)  Move C_$SQL_Server_SQL_Server_2000_client to sClient
100527>>>>>                            If (sClient <> "") Begin
100529>>>>>                                Move ("    " + sClient) to sClient
100530>>>>>                            End
100530>>>>>>
100530>>>>>                        End
100530>>>>>>
100530>>>>>
100530>>>>>                        Get CKRevision of hoCLIHandler to sVersion
100531>>>>>                    End
100531>>>>>>
100531>>>>>
100531>>>>>                    If (bIsMertechDriver = True) Begin
100533>>>>>                    End
100533>>>>>>
100533>>>>>
100533>>>>>                    // If the serialnumber is = 0, it means that the
100533>>>>>                    // Studio licens is in use and there is no
100533>>>>>                    // number of max users defined because the driver is
100533>>>>>                    // relying on the info from the VDF license.
100533>>>>>                    If (bStudioLicense = False) Begin
100535>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
100536>>>>>                        Move (iSerialNo = 0) to bStudioLicense
100537>>>>>                    End
100537>>>>>>
100537>>>>>                End
100537>>>>>>
100537>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
100538>>>>>                If (iNumServers <> 0) Begin
100540>>>>>                    For iCount from 1 to iNumServers
100546>>>>>>
100546>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
100549>>>>>                        Send AppendTextLn ("    " + "Server/DSN:" * sValue)
100550>>>>>                    Loop
100551>>>>>>
100551>>>>>                End
100551>>>>>>
100551>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
100553>>>>>                    Send AppendTextLn sClient
100554>>>>>                End
100554>>>>>>
100554>>>>>            End
100554>>>>>>
100554>>>>>        Loop
100555>>>>>>
100555>>>>>
100555>>>>>        Send AppendTextLn ""
100556>>>>>        If (bStudioLicense = False) Begin
100558>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
100559>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
100560>>>>>        End
100560>>>>>>
100560>>>>>        Else Begin
100561>>>>>            Send AppendTextLn C_$VDF_Studio_License_Text
100562>>>>>        End
100562>>>>>>
100562>>>>>        Send Destroy of hoCLIHandler
100563>>>>>        Send Destroy of hoBtrvHandler
100564>>>>>    End_Procedure
100565>>>>>
100565>>>>>    Procedure Show_HelpFile
100567>>>>>        String sHelpFile
100567>>>>>        Integer eHelpType
100567>>>>>
100567>>>>>        If (ghoApplication <> 0) Begin
100569>>>>>            Get peHelpType Of ghoApplication To eHelpType
100570>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
100572>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
100573>>>>>            End
100573>>>>>>
100573>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
100576>>>>>                Get Help_filename Of Help_object_id To sHelpFile
100577>>>>>            End
100577>>>>>>
100577>>>>>            Else Begin
100578>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
100579>>>>>            End
100579>>>>>>
100579>>>>>
100579>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
100580>>>>>        End
100580>>>>>>
100580>>>>>    End_Procedure
100581>>>>>
100581>>>>>    Procedure Show_EnterAsTab
100583>>>>>        Boolean bEnterKeyAsTabKey
100583>>>>>        String sText
100583>>>>>
100583>>>>>        If (ghoApplication <> 0) Begin
100585>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
100586>>>>>            If (bEnterKeyAsTabKey) Begin
100588>>>>>                Move "True" To sText
100589>>>>>            End
100589>>>>>>
100589>>>>>            Else Begin
100590>>>>>                Move "False" To sText
100591>>>>>            End
100591>>>>>>
100591>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
100592>>>>>        End
100592>>>>>>
100592>>>>>    End_Procedure
100593>>>>>
100593>>>>>    //****************************************************************************
100593>>>>>    // $Module type: PROCEDURE
100593>>>>>    // $Module name: Add_Focus
100593>>>>>    // $Author     : VOO
100593>>>>>    // Created     : 24-09-96 @ 19:43
100593>>>>>    //
100593>>>>>    // Description
100593>>>>>    //    During activation we will remove the old information and add the newly
100593>>>>>    //    found systeminformation
100593>>>>>    //
100593>>>>>    // $Rev History
100593>>>>>    //    24-09-96  Module header created
100593>>>>>    //****************************************************************************
100593>>>>>    Procedure Add_Focus Integer hoRoot
100595>>>>>        Forward Send Add_Focus hoRoot
100597>>>>>
100597>>>>>        Send Delete_Data
100598>>>>>
100598>>>>>        Set Changed_State To False
100599>>>>>        Set Read_Only_State To True
100600>>>>>
100600>>>>>        Send Show_Registration
100601>>>>>        Send Show_Drivers
100602>>>>>        Send AppendTextLn ""
100603>>>>>
100603>>>>>        Send Show_ServicePack
100604>>>>>        If (ghoApplication <> 0) Begin
100606>>>>>            Send Show_WorkSpaceInformation
100607>>>>>            Send Show_HelpFile
100608>>>>>            Send AppendTextLn ""
100609>>>>>        End
100609>>>>>>
100609>>>>>        Else Begin
100610>>>>>            Send AppendTextLn ""
100611>>>>>        End
100611>>>>>>
100611>>>>>
100611>>>>>        If (ghoConnection <> 0) Begin
100613>>>>>            Send Show_ConnectionIdInformation
100614>>>>>        End
100614>>>>>>
100614>>>>>
100614>>>>>        Send Show_Current_User
100615>>>>>        Send Show_Windows_Directory
100616>>>>>        Send Show_Current_Directory
100617>>>>>
100617>>>>>        // This is already shown in the workspace details,
100617>>>>>        // unless no workspace object is present:
100617>>>>>        If (ghoApplication = 0) Begin
100619>>>>>            Send Show_Filelist_Name
100620>>>>>        End
100620>>>>>>
100620>>>>>
100620>>>>>        If (ghoApplication <> 0) Begin
100622>>>>>            Send AppendTextLn ""
100623>>>>>            Send Show_EnterAsTab
100624>>>>>        End
100624>>>>>>
100624>>>>>
100624>>>>>        Send Show_Versions
100625>>>>>        Send Show_Screen_Size
100626>>>>>        Send Show_Page_Size
100627>>>>>        Send Show_Number_Format
100628>>>>>        Send Show_Date_Format
100629>>>>>        Send Show_Lock_Delay
100630>>>>>        Send Show_Lock_Timeout
100631>>>>>        Send Show_Date
100632>>>>>        Send Show_Systemresources
100633>>>>>        Send Beginning_of_Data
100634>>>>>
100634>>>>>        Set Icon to 'default.ico'
100635>>>>>    End_Procedure
100636>>>>>End_Class
100637>>>>>
100637>>>>>//****************************************************************************
100637>>>>>// $Module type: OBJECT
100637>>>>>// $Module name: Sysinfo_Dialog
100637>>>>>// $Author     : VOO
100637>>>>>// Created     : 24-09-96 @ 18:47
100637>>>>>//
100637>>>>>// Description
100637>>>>>//    This object shows the systeminformation on the screen
100637>>>>>//
100637>>>>>// $Rev History
100637>>>>>//    24-09-96  Module header created
100637>>>>>//****************************************************************************
100637>>>>>Class SysInfoDialog is a ModalPanel
100638>>>>>    Procedure Construct_Object
100640>>>>>        Forward Send Construct_Object
100642>>>>>
100642>>>>>        Set Label to C_$SystemInformation
100643>>>>>        Set Size to 140 267
100644>>>>>        Set Locate_Mode to CENTER_ON_PARENT
100645>>>>>        Set Border_Style to Border_Thick
100646>>>>>        Set Sysmenu_Icon to False
100647>>>>>
100647>>>>>        // "+1" will make the panel to paint correctly.
100647>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
100648>>>>>
100648>>>>>        // 2014-09-14 NGS
100648>>>>>        // Added a container object around the cTexteditor
100648>>>>>        // object to get a border around the text.
100648>>>>>        Object oSysinfoDisplayContainer is a Container3d
100650>>>>>            Set Location to 2 4
100651>>>>>            Set Size to 110 255
100652>>>>>            Set Border_Style to Border_ClientEdge
100653>>>>>            Set Color to clWhite
100654>>>>>            Set peAnchors to anAll
100655>>>>>
100655>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
100657>>>>>            End_Object
100658>>>>>
100658>>>>>        End_Object
100659>>>>>
100659>>>>>        Object oCloseButton is a Button
100661>>>>>            Set Label to C_$Close
100662>>>>>            Set Location to 120 210
100663>>>>>            Set Message item 0 to msg_Close_Panel
100664>>>>>            Set Default_State To True
100665>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
100665>>>>>            // and changes its peAnchors, we might as well prepare this object
100665>>>>>            // for that situation.
100665>>>>>            Set peAnchors to anBottomRight
100666>>>>>        End_Object
100667>>>>>
100667>>>>>        Object oCopyButton is a cCopyEditorContentButton
100669>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
100670>>>>>            Set Size to 14 50
100671>>>>>            Set Location to 120 158
100672>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100672>>>>>            // we might as well prepare the object for it.
100672>>>>>            Set peAnchors to anBottomRight
100673>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
100674>>>>>        End_Object
100675>>>>>
100675>>>>>        On_Key kCancel Send Close_Panel
100676>>>>>    End_Procedure
100677>>>>>
100677>>>>>    Procedure Page Integer iPageObject
100679>>>>>        Handle hMenu
100679>>>>>        Integer iPrevState
100679>>>>>
100679>>>>>        Forward Send Page iPageObject
100681>>>>>
100681>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
100681>>>>>        //
100681>>>>>    End_Procedure
100682>>>>>
100682>>>>>End_Class
100683>>>>>
100683>>>>>Class cAboutEdit is an cRichEdit
100684>>>>>    Procedure Construct_Object
100686>>>>>        Forward Send Construct_Object
100688>>>>>
100688>>>>>        Set Size to 57 153
100689>>>>>        Set Location to 8 60
100690>>>>>
100690>>>>>        Set Read_Only_State to True
100691>>>>>        Set Skip_State to True
100692>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
100692>>>>>        // or 1/20 of a printer's point.
100692>>>>>//        Set piFontSize    to (9 * 20)
100692>>>>>        Set piRightMargin to (0.1 * 1440)
100693>>>>>        Set Border_Style  to Border_None
100694>>>>>    End_Procedure
100695>>>>>
100695>>>>>    // Adds a line of text to the edit object
100695>>>>>    Procedure Add_Line String sVal
100697>>>>>        String sText
100697>>>>>        Address aAddress
100697>>>>>        Get paValue to aAddress
100698>>>>>        Move aAddress to sText
100699>>>>>        Move (sText + String(sVal)) to sVal
100700>>>>>        GetAddress of sVal to aAddress
100701>>>>>        Set paValue to aAddress
100702>>>>>    End_Procedure
100703>>>>>
100703>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
100703>>>>>    // Note that we use the paValue interface,
100703>>>>>    // because the object isn't paged yet when we add the
100703>>>>>    // values and the COM edit object needs to be paged
100703>>>>>    // for the "Set Value" interface to be used.
100703>>>>>    Procedure Add_LineLn String sVal
100705>>>>>        String sText
100705>>>>>        Address aAddress
100705>>>>>        Get paValue to aAddress
100706>>>>>        Move aAddress to sText
100707>>>>>        Move (sText + String(sVal) + Character(10) + Character(13)) to sVal
100708>>>>>        GetAddress of sVal to aAddress
100709>>>>>        Set paValue to aAddress
100710>>>>>    End_Procedure
100711>>>>>
100711>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
100713>>>>>        String sLinkText
100713>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
100714>>>>>        Send Show_HomePage sLinkText
100715>>>>>    End_Procedure
100716>>>>>
100716>>>>>End_Class
100717>>>>>
100717>>>>>// Purpose:
100717>>>>>//
100717>>>>>// Ken Ross 12/17/96 5:16PM
100717>>>>>//
100717>>>>>Class AboutDialog is a ModalPanel
100718>>>>>    Procedure Construct_Object
100720>>>>>
100720>>>>>        Forward Send Construct_Object
100722>>>>>
100722>>>>>        Set Label to C_$About
100723>>>>>        Set Size to 96 230
100724>>>>>        Set Locate_Mode To CENTER_ON_PARENT
100725>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
100726>>>>>//        Set Sysmenu_Icon to True
100726>>>>>
100726>>>>>        Object oSysInfoDialog is a SysInfoDialog
100728>>>>>        End_Object
100729>>>>>
100729>>>>>        Object oBox is a Container3d
100731>>>>>            Set Border_Style to Border_Normal
100732>>>>>            Set Size to 70 220
100733>>>>>            Set Location to 4 5
100734>>>>>            Set Color to clWhite
100735>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100735>>>>>            // we might as well prepare the object for it.
100735>>>>>            Set peAnchors to anAll
100736>>>>>
100736>>>>>            Object oAboutGraphic is a BitmapContainer
100738>>>>>                Set Border_Style To Border_None
100739>>>>>                Set Bitmap_Style to Bitmap_Center
100740>>>>>                Set Color to clWhite
100741>>>>>                Set Size to 45 50
100742>>>>>                Set Location to 0 3
100743>>>>>            End_Object
100744>>>>>
100744>>>>>            Object oPoweredByVDFGraphic is a cBitmapContainerVDFLink
100746>>>>>                Set Border_Style to Border_None
100747>>>>>                Set Bitmap_Style to Bitmap_Center
100748>>>>>                Set Color to clWhite
100749>>>>>                Set Size to 30 55 //28 50
100750>>>>>                Set Location to 44 3
100751>>>>>            End_Object
100752>>>>>
100752>>>>>            Object oInfoList_Editor is an cAboutEdit
100754>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
100754>>>>>                // we might as well prepare the object for it.
100754>>>>>                Set peAnchors to anAll
100755>>>>>            End_Object
100756>>>>>
100756>>>>>            // These objects are here for backwards compatability only.
100756>>>>>            // They are not used.
100756>>>>>            Object oProductName is a TextBox
100758>>>>>                Set Label To C_$ProductName
100759>>>>>                Set Size To 10 45
100760>>>>>                Set Location To 8 53
100761>>>>>                Set Visible_State to False
100762>>>>>                Set Focus_Mode to NonFocusable
100763>>>>>            End_Object
100764>>>>>
100764>>>>>            Object oVersion is a TextBox
100766>>>>>                Set Label To C_$Version
100767>>>>>                Set Size To 10 25
100768>>>>>                Set Location To 21 53
100769>>>>>                Set Visible_State to False
100770>>>>>                Set Focus_Mode to NonFocusable
100771>>>>>            End_Object
100772>>>>>
100772>>>>>            Object oCopyright is a TextBox
100774>>>>>                Set Label To C_$Copyright
100775>>>>>                Set Size To 10 31
100776>>>>>                Set Location To 34 53
100777>>>>>                Set Visible_State to False
100778>>>>>                Set Focus_Mode to NonFocusable
100779>>>>>            End_Object
100780>>>>>
100780>>>>>            Object oAuthor is a TextBox
100782>>>>>                Set Label To C_$Author
100783>>>>>                Set Size To 10 22
100784>>>>>                Set Location To 46 53
100785>>>>>                Set Visible_State to False
100786>>>>>                Set Focus_Mode to NonFocusable
100787>>>>>            End_Object
100788>>>>>
100788>>>>>        End_Object
100789>>>>>
100789>>>>>        Object oOKButton Is A Button
100791>>>>>            On_Item C_$Close Send Close_Panel
100792>>>>>            Set Location to 78 176
100793>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100793>>>>>            // we might as well prepare the object for it.
100793>>>>>            Set peAnchors to anBottomRight
100794>>>>>        End_Object
100795>>>>>
100795>>>>>        Object oSysInfoButton Is A Button
100797>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
100798>>>>>            Set Location to 78 123
100799>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100799>>>>>            // we might as well prepare the object for it.
100799>>>>>            Set peAnchors to anBottomRight
100800>>>>>        End_Object
100801>>>>>
100801>>>>>        Object oCopyButton is a cCopyEditorContentButton
100803>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
100804>>>>>            Set Size to 14 50
100805>>>>>            Set Location to 78 70
100806>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
100806>>>>>            // we might as well prepare the object for it.
100806>>>>>            Set peAnchors to anBottomRight
100807>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
100808>>>>>        End_Object
100809>>>>>
100809>>>>>        On_Key Kcancel Send KeyAction of oOKButton
100810>>>>>        Set Logo    to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
100811>>>>>//        Set LogoVDF to "PoweredByDataFlex.bmp"
100811>>>>>        Set LogoVDF to "PoweredByOrange.bmp"
100812>>>>>    End_Procedure
100813>>>>>
100813>>>>>    Procedure Page Integer iPageObject
100815>>>>>        Handle hMenu
100815>>>>>        Integer iPrevState
100815>>>>>
100815>>>>>        Forward Send Page iPageObject
100817>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
100817>>>>>//        Set Icon to "ActionAbout.ico"
100817>>>>>
100817>>>>>        // Shadow upper left corner menu items: (icon menu items)
100817>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
100818>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100819>>>>>        // The "Move" menu command may come in handy to have.
100819>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100819>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100820>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100821>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100822>>>>>        // The "Close" menu command may be good to have.
100822>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
100822>>>>>    End_Procedure
100823>>>>>
100823>>>>>    Procedure Set ProductName String sText
100825>>>>>        Set Value of oProductName to sText
100826>>>>>    End_Procedure
100827>>>>>
100827>>>>>    Procedure Set Copyright String sText
100829>>>>>        Set Value of oCopyright to sText
100830>>>>>    End_Procedure
100831>>>>>
100831>>>>>    Procedure Set Author String sText
100833>>>>>        Set Value of oAuthor to sText
100834>>>>>    End_Procedure
100835>>>>>
100835>>>>>    Procedure Set Version String sVersion
100837>>>>>        Handle hoVersionInfo
100837>>>>>        Boolean bIncluded
100837>>>>>        Integer iMajor iMinor iRelease iBuild
100837>>>>>        Date dCompileDate
100837>>>>>
100837>>>>>        If (sVersion = "") Begin
100839>>>>>            // This automatically shows the program version of the program, if available.
100839>>>>>            // It will be displayed as the second item in the edit object.
100839>>>>>            If (ghoApplication <> 0) Begin
100841>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
100842>>>>>                If (hoVersionInfo <> 0) Begin
100844>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
100845>>>>>                    If (bIncluded) Begin
100847>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
100848>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
100849>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
100850>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
100851>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
100852>>>>>                    End
100852>>>>>>
100852>>>>>                End
100852>>>>>>
100852>>>>>            End
100852>>>>>>
100852>>>>>        End
100852>>>>>>
100852>>>>>
100852>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
100852>>>>>        Get GetCompileDate to dCompileDate
100853>>>>>        If (sVersion <> "") Begin
100855>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
100856>>>>>        End
100856>>>>>>
100856>>>>>    End_Procedure
100857>>>>>
100857>>>>>    Function GetCompileDate Returns Date
100859>>>>>        Date dCompileDate
100859>>>>>        String sAppFilename sData sCompileDate
100859>>>>>        Integer iChannel iPos iDateFormat
100859>>>>>
100859>>>>>        // Get full path to the current running executable
100859>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
100860>>>>>
100860>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
100860>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
100861>>>>>        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
100863>>>>>        Read_Block channel iChannel sData 75            // The compile information we're interested in
100865>>>>>        Send Seq_Close_Channel iChannel
100866>>>>>
100866>>>>>        // The data is padded with Character(0)s. Strip them out
100866>>>>>        Move (CString(sData)) to sData
100867>>>>>
100867>>>>>        // The compile date is after the first ", ", so string parsing is required
100867>>>>>        Move (Pos(", ", sData)) to iPos
100868>>>>>        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
100869>>>>>        // If the current date format is non US, we need to temporary
100869>>>>>        // change the format and then move the string to the date variable.
100869>>>>>        Get_Attribute DF_DATE_FORMAT        to iDateFormat
100872>>>>>        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
100875>>>>>        Move (Date(sCompileDate))           to dCompileDate
100876>>>>>        Set_Attribute DF_DATE_FORMAT        to iDateFormat // Reset date format
100879>>>>>
100879>>>>>        Function_Return dCompileDate
100880>>>>>    End_Function
100881>>>>>
100881>>>>>    Procedure Add_LineLn String sValue
100883>>>>>        Send Add_LineLn of oInfoList_Editor sValue
100884>>>>>    End_Procedure
100885>>>>>
100885>>>>>    Procedure Add_Line String sValue
100887>>>>>        Send Add_Line of oInfoList_Editor sValue
100888>>>>>    End_Procedure
100889>>>>>
100889>>>>>    Procedure Set Logo string sLogo
100891>>>>>        // Square bitmaps of 80x80 work best
100891>>>>>        Set Bitmap of oAboutGraphic to sLogo
100892>>>>>    End_Procedure
100893>>>>>
100893>>>>>    Procedure Set LogoVDF String sLogo
100895>>>>>        Set Bitmap of oPoweredByVDFGraphic to sLogo
100896>>>>>    End_Procedure
100897>>>>>
100897>>>>>    Procedure Show_Sysinfo
100899>>>>>        Send Popup_Modal of oSysinfoDialog
100900>>>>>    End_Procedure
100901>>>>>
100901>>>>>    Procedure Show_HomePage String sWebpage
100903>>>>>        Handle hWnd hInstance
100903>>>>>        Get Window_Handle to hWnd
100904>>>>>        Move (ShellExecute(hWnd, "open", (Trim(sWebpage)), "", "", 1)) to hInstance
100905>>>>>    End_Procedure
100906>>>>>
100906>>>>>//    Procedure End_Construct_Object
100906>>>>>//        Handle hoVersionInfo
100906>>>>>//        Boolean bIncluded
100906>>>>>//        Integer iMajor iMinor iRelease iBuild
100906>>>>>//        String sLabel sVersion
100906>>>>>//
100906>>>>>//        If (sVersion = "") Begin
100906>>>>>//            // This automatically shows the program version of the program, if available.
100906>>>>>//            // It will be displayed as the last item in the edit object.
100906>>>>>//            If (ghoApplication <> 0) Begin
100906>>>>>//                Get phoVersionInfo of ghoApplication to hoVersionInfo
100906>>>>>//                If (hoVersionInfo <> 0) Begin
100906>>>>>//                    Get pbIncluded of hoVersionInfo to bIncluded
100906>>>>>//                    If (bIncluded) Begin
100906>>>>>//                        Get piVersionMajor of hoVersionInfo to iMajor
100906>>>>>//                        Get piVersionMinor of hoVersionInfo to iMinor
100906>>>>>//                        Get piVersionRelease of hoVersionInfo to iRelease
100906>>>>>//                        Get piVersionBuild of hoVersionInfo to iBuild
100906>>>>>//                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
100906>>>>>//                        Set Version to sLabel
100906>>>>>//                    End
100906>>>>>//                End
100906>>>>>//            End
100906>>>>>//        End
100906>>>>>//
100906>>>>>//        Forward Send End_Construct_Object
100906>>>>>//    End_Procedure
100906>>>>>
100906>>>>>End_Class
100907>>>
100907>>>// *************************************************************************
100907>>>//  Public message. This is the default message. It is expected that you will
100907>>>//   create your own message to override this
100907>>>// *************************************************************************
100907>>>
100907>>>Procedure Activate_About
100910>>>   Send DoAbout "" "" "" "" ""
100911>>>End_Procedure
100912>>>
100912>>>// *************************************************************************
100912>>>//  Public message. It is expected that you will send this message (most
100912>>>//  likely from Activate_About. This creates an about object, activates it
100912>>>//  and destroys it when done. It is not exepected that you will augment this.
100912>>>// *************************************************************************
100912>>>// Sample usage:
100912>>>//   The first two params will automatically be filled from the application settings if not provided.
100912>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
100912>>>
100912>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;                  String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
100915>>>        Integer hoObj hoMain iArgs
100915>>>        String sValue
100915>>>
100915>>>        // Create object
100915>>>        Object About is an AboutDialog
100917>>>            // Uncomment these two lines if you would like to have a resizable About object.
100917>>>//            Set Border_Style to Border_Thick
100917>>>//            Set peAnchors to anAll
100917>>>
100917>>>            // Add checking for the number of arguments passed to avoid runtime errors
100917>>>            // if one of them is not passed. This makes the interface
100917>>>            // more flexible.
100917>>>            Move num_arguments to iArgs
100918>>>
100918>>>            // If no title is passed use the label of the main panel (if a main panel exists).
100918>>>            If (iArgs > 0 and sTitle = "") Begin
100920>>>                Get Main_Window of Desktop to hoMain
100921>>>                If hoMain Get Label of hoMain to sValue
100924>>>            End
100924>>>>
100924>>>            Else If (iArgs > 0 and sTitle <> "") Begin
100927>>>                Move sTitle to sValue
100928>>>            End
100928>>>>
100928>>>            Else If (iArgs = 0) Begin
100931>>>                Get Main_Window of Desktop to hoMain
100932>>>                If hoMain Get Label of hoMain to sValue
100935>>>            End
100935>>>>
100935>>>
100935>>>            If (sValue <> "") Send Add_LineLn sValue
100938>>>            Move "" to sValue
100939>>>
100939>>>            // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
100939>>>            // For this to work the Project Properties Version must have been set in the Studio.
100939>>>            If (iArgs < 2) Begin
100941>>>                Move "" to sValue
100942>>>            End
100942>>>>
100942>>>            Else Begin
100943>>>                Move sVersion to sValue
100944>>>            End
100944>>>>
100944>>>            Set Version to sValue
100945>>>
100945>>>            If (iArgs > 2 and sCopyRight <> "") Send Add_LineLn sCopyRight
100948>>>
100948>>>            // If only the five "standard" params were passed we don't add an extra linefeed;
100948>>>            // else we do.
100948>>>            If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
100950>>>                Send Add_Line sAuthor
100951>>>            End
100951>>>>
100951>>>            Else If (iArgs > 5 and sAuthor <> "") Begin
100954>>>                Send Add_LineLn sAuthor
100955>>>            End
100955>>>>
100955>>>
100955>>>            // Square bitmaps of 80x80 works best
100955>>>            If (iArgs > 4 and sBitmap <> "") Begin
100957>>>               Set Logo to sBitMap
100958>>>            End
100958>>>>
100958>>>
100958>>>            // Here starts handling of the five optional params:
100958>>>            If (iArgs = 6 and sParam6  <> "") Begin
100960>>>                Send Add_Line sParam6
100961>>>            End
100961>>>>
100961>>>            Else If (iArgs > 6 and sParam6  <> "") Begin
100964>>>                Send Add_LineLn sParam6
100965>>>            End
100965>>>>
100965>>>
100965>>>            If (iArgs = 7 and sParam7  <> "") Begin
100967>>>                Send Add_Line sParam7
100968>>>            End
100968>>>>
100968>>>            Else If (iArgs > 7 and sParam7  <> "") Begin
100971>>>                Send Add_LineLn sParam7
100972>>>            End
100972>>>>
100972>>>
100972>>>            If (iArgs = 8 and sParam8  <> "") Begin
100974>>>                Send Add_Line sParam8
100975>>>            End
100975>>>>
100975>>>            Else If (iArgs > 8 and sParam8  <> "") Begin
100978>>>                Send Add_LineLn sParam8
100979>>>            End
100979>>>>
100979>>>
100979>>>            If (iArgs = 9 and sParam9  <> "") Begin
100981>>>                Send Add_Line sParam9
100982>>>            End
100982>>>>
100982>>>            Else If (iArgs > 9 and sParam9  <> "") Begin
100985>>>                Send Add_LineLn sParam9
100986>>>            End
100986>>>>
100986>>>
100986>>>            If (iArgs = 10 and sParam10 <> "") Begin
100988>>>                Send Add_Line sParam10
100989>>>            End
100989>>>>
100989>>>
100989>>>            Move Self to hoObj
100990>>>        End_Object
100991>>>
100991>>>        Send Popup   of hoObj // Popup the about object
100992>>>        Send Destroy of hoObj // When done, it will be destroyed
100993>>>End_Procedure
100994>        Procedure Activate_About
100997>            Send DoAbout "" "" ("Copyright 2016-2018" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DUFUpdateCodeGenerator.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com"
100998>        End_Procedure
100999>
100999>        On_Key Key_Ctrl+Key_Tab           Send Switch_Next_View
101000>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Prior_View
101001>    End_Object
101002>
101002>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
101002>    // in the oHtmlHelp object, so we need to explitetly send the message
101002>    // to that object.
101002>    Procedure ShowProgramHelp
101005>        Send DoDisplayKeyword of oHtmlHelp "The Database Update Framework"
101006>    End_Procedure
101007>
101007>End_Object
101008>
101008>// Because we want to display the compare databases view first.
101008>Send Activate_oCompareDatabases_vw of (Client_Id(phoMainPanel(ghoApplication)))
101009>Start_UI
101010>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 54231
Total Resources: 3
Total Commands : 101009
Total Windows  : 1
Total Pages    : 1
Static Data    : 747677
Message area   : 651402
Total Blocks   : 36053
