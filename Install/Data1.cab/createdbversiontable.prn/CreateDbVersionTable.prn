Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\CreateDbVersionTable.src
Memory Available: 2147483646
1>Use DfAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dfallent.pkd)
79216>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardCommandBarSystem.pkg)
79216>>>// these are all the packages used in a standard MDI menubar/toolbar system
79216>>>
79216>>>Use cCJCommandBarSystem.pkg
79216>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardMenuItemClasses.pkg)
79216>>>>>Use Dfpanel.pkg
79216>>>>>Use cCJCommandBarSystem.pkg
79216>>>>>Use LanguageText.pkg
79216>>>>>
79216>>>>>
79216>>>>>Class cCJUndoMenuItem is a cCJMenuItem
79217>>>>>    
79217>>>>>    Procedure Construct_Object
79219>>>>>        Forward Send Construct_Object
79221>>>>>        Set psCaption   to C_$CaptionUndo
79222>>>>>        Set psToolTip to C_$ToolTipUndo
79223>>>>>        Set psDescription to C_$DescUndo
79224>>>>>        Set psImage to "ActionUndo.ico"
79225>>>>>        Set pbActiveUpdate to True
79226>>>>>        Set psCategory to C_$CategoryEdit
79227>>>>>        Set psShortcut to C_$Key_Ctrl_Z
79228>>>>>    End_Procedure
79229>>>>>
79229>>>>>    Procedure OnExecute Variant vCommandBarControl
79231>>>>>        Send Undo of (focus(Self))
79232>>>>>    End_Procedure
79233>>>>>    
79233>>>>>    Function IsEnabled Returns Boolean
79235>>>>>        Boolean bEnabled
79235>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
79236>>>>>        Function_Return bEnabled
79237>>>>>    End_Function
79238>>>>>         
79238>>>>>End_Class
79239>>>>>
79239>>>>>
79239>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
79240>>>>>    
79240>>>>>    Procedure Construct_Object
79242>>>>>        Forward Send Construct_Object
79244>>>>>        Set psCaption   to C_$CaptionDelete
79245>>>>>        Set psToolTip to C_$ToolTipDelete
79246>>>>>        Set psDescription to C_$DescDelete
79247>>>>>        Set psImage to "actionDelete.ico"
79248>>>>>        Set psShortcut to C_$Key_Delete
79249>>>>>        Set pbActiveUpdate to True
79250>>>>>        Set psCategory to C_$CategoryEdit
79251>>>>>    End_Procedure
79252>>>>>
79252>>>>>
79252>>>>>    Procedure OnExecute Variant vCommandBarControl
79254>>>>>        Send Delete of (focus(Self))
79255>>>>>    End_Procedure
79256>>>>>    
79256>>>>>    Function IsEnabled Returns Boolean
79258>>>>>        Boolean bEnabled
79258>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
79259>>>>>        Function_Return bEnabled
79260>>>>>    End_Function
79261>>>>>         
79261>>>>>End_Class
79262>>>>>
79262>>>>>
79262>>>>>Class cCJCutMenuItem is a cCJMenuItem
79263>>>>>    
79263>>>>>    Procedure Construct_Object
79265>>>>>        Forward Send Construct_Object
79267>>>>>        Set psCaption   to C_$CaptionCut
79268>>>>>        Set psToolTip to C_$TooltipCut
79269>>>>>        Set psDescription to C_$DescCut
79270>>>>>        Set psImage to "actionCut.ico"
79271>>>>>        Set psShortcut to C_$Key_Ctrl_X
79272>>>>>        Set pbActiveUpdate to True
79273>>>>>        Set psCategory to C_$CategoryEdit
79274>>>>>    End_Procedure
79275>>>>>
79275>>>>>
79275>>>>>    Procedure OnExecute Variant vCommandBarControl
79277>>>>>        Send Cut of (focus(Self))
79278>>>>>    End_Procedure
79279>>>>>    
79279>>>>>    Function IsEnabled Returns Boolean
79281>>>>>        Boolean bEnabled
79281>>>>>        Get CanCut of (Focus(Self)) to bEnabled
79282>>>>>        Function_Return bEnabled
79283>>>>>    End_Function
79284>>>>>         
79284>>>>>End_Class
79285>>>>>
79285>>>>>
79285>>>>>Class cCJCopyMenuItem is a cCJMenuItem
79286>>>>>    
79286>>>>>    Procedure Construct_Object
79288>>>>>        Forward Send Construct_Object
79290>>>>>        Set psCaption   to C_$CaptionCopy
79291>>>>>        Set psToolTip to C_$ToolTipCopy
79292>>>>>        Set psDescription to C_$DescCopy
79293>>>>>        Set psImage to "actionCopy.ico"
79294>>>>>        Set psShortcut to C_$Key_Ctrl_C
79295>>>>>        Set pbActiveUpdate to True
79296>>>>>        Set psCategory to C_$CategoryEdit
79297>>>>>    End_Procedure
79298>>>>>
79298>>>>>
79298>>>>>    Procedure OnExecute Variant vCommandBarControl
79300>>>>>        Send Copy of (focus(Self))
79301>>>>>    End_Procedure
79302>>>>>    
79302>>>>>    Function IsEnabled Returns Boolean
79304>>>>>        Boolean bEnabled
79304>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
79305>>>>>        Function_Return bEnabled
79306>>>>>    End_Function
79307>>>>>         
79307>>>>>End_Class
79308>>>>>
79308>>>>>
79308>>>>>Class cCJPasteMenuItem is a cCJMenuItem
79309>>>>>    
79309>>>>>    Procedure Construct_Object
79311>>>>>        Forward Send Construct_Object
79313>>>>>        Set psCaption   to C_$CaptionPaste
79314>>>>>        Set psToolTip to C_$ToolTipPaste
79315>>>>>        Set psDescription to C_$DescPaste
79316>>>>>        Set psImage to "actionPaste.ico"
79317>>>>>        Set pbActiveUpdate to True
79318>>>>>        Set psShortcut to C_$Key_Ctrl_V
79319>>>>>        Set psCategory to C_$CategoryEdit
79320>>>>>    End_Procedure
79321>>>>>
79321>>>>>
79321>>>>>    Procedure OnExecute Variant vCommandBarControl
79323>>>>>        Send Paste of (focus(Self))
79324>>>>>    End_Procedure
79325>>>>>    
79325>>>>>    Function IsEnabled Returns Boolean
79327>>>>>        Boolean bEnabled
79327>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
79328>>>>>        Function_Return bEnabled
79329>>>>>    End_Function
79330>>>>>         
79330>>>>>End_Class
79331>>>>>
79331>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
79332>>>>>    
79332>>>>>    Procedure Construct_Object
79334>>>>>        Forward Send Construct_Object
79336>>>>>        Set psCaption   to C_$CaptionSelectAll
79337>>>>>        Set psToolTip to C_$ToolTipSelectAll
79338>>>>>        Set psDescription to C_$DescSelectAll
79339>>>>>        Set pbActiveUpdate to True
79340>>>>>        Set psShortcut to C_$Key_Ctrl_A
79341>>>>>        Set psCategory to C_$CategoryEdit
79342>>>>>    End_Procedure
79343>>>>>
79343>>>>>
79343>>>>>    Procedure OnExecute Variant vCommandBarControl
79345>>>>>        Send Select_All of (focus(Self))
79346>>>>>    End_Procedure
79347>>>>>    
79347>>>>>    Function IsEnabled Returns Boolean
79349>>>>>        Boolean bEnabled
79349>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
79350>>>>>        Function_Return bEnabled
79351>>>>>    End_Function
79352>>>>>         
79352>>>>>End_Class
79353>>>>>
79353>>>>> 
79353>>>>>Class cCJExitMenuItem is a cCJMenuItem
79354>>>>>
79354>>>>>    Procedure Construct_Object
79356>>>>>        Forward Send Construct_Object
79358>>>>>        Set psCaption to C_$CaptionExit
79359>>>>>        Set psToolTip to C_$ToolTipExit
79360>>>>>        Set psDescription to C_$ToolTipExit
79361>>>>>        Set psShortcut to C_$Key_Alt_F4
79362>>>>>        Set psCategory to C_$CategoryFile
79363>>>>>    End_Procedure
79364>>>>>
79364>>>>>    Procedure OnExecute Variant vCommandBarControl
79366>>>>>        Send Exit_Application of Desktop
79367>>>>>    End_Procedure
79368>>>>>
79368>>>>>End_Class           
79369>>>>>
79369>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
79370>>>>>
79370>>>>>    Procedure Construct_Object
79372>>>>>        Forward Send Construct_Object
79374>>>>>        Set psCaption to C_$CaptionHelp
79375>>>>>        Set psDescription to C_$ToolTipHelp
79376>>>>>        Set psToolTip to C_$DescHelp
79377>>>>>        Set psImage to "ActionHelp.ico"
79378>>>>>        Set psShortcut to "F1"
79379>>>>>        Set psCategory to C_$CategoryHelp
79380>>>>>    End_Procedure
79381>>>>>    
79381>>>>>    Procedure OnExecute Variant vCommandBarControl
79383>>>>>        Send Help of (Focus(Self))
79384>>>>>    End_Procedure
79385>>>>>
79385>>>>>End_Class
79386>>>>>
79386>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
79387>>>>>
79387>>>>>    Procedure Construct_Object
79389>>>>>        Forward Send Construct_Object
79391>>>>>        Set psCaption to C_$CaptionAddStatusbar
79392>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
79393>>>>>        Set psDescription to  C_$DescAddStatusbar
79394>>>>>        Set psCategory to C_$CategoryWindow
79395>>>>>    End_Procedure
79396>>>>>
79396>>>>>    Procedure OnExecute Variant vCommandBarControl
79398>>>>>        Handle hoCommandBars hoClientArea
79398>>>>>        Get CommandBarSystemObject to hoCommandBars
79399>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79400>>>>>        If hoClientArea Begin
79402>>>>>            // the clientarea's parent panel has message
79402>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
79403>>>>>        End
79403>>>>>>
79403>>>>>    End_Procedure
79404>>>>>
79404>>>>>     Function IsChecked Returns Boolean
79406>>>>>        Boolean bOn
79406>>>>>        Handle hoCommandBars hoClientArea
79406>>>>>        Get CommandBarSystemObject to hoCommandBars
79407>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79408>>>>>        If hoClientArea Begin
79410>>>>>            // the clientarea's parent panel has message
79410>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
79411>>>>>        End
79411>>>>>>
79411>>>>>        Function_Return bOn
79412>>>>>     End_Function
79413>>>>>End_Class
79414>>>>>
79414>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
79415>>>>>
79415>>>>>    Procedure Construct_Object
79417>>>>>        Forward Send Construct_Object
79419>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
79420>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
79421>>>>>        Set psDescription to C_$DescAutoArrangeIcons
79422>>>>>        Set psCategory to C_$CategoryWindow
79423>>>>>    End_Procedure
79424>>>>>
79424>>>>>    Procedure OnExecute Variant vCommandBarControl
79426>>>>>        Handle hoCommandBars hoClientArea
79426>>>>>        Get CommandBarSystemObject to hoCommandBars
79427>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79428>>>>>        If hoClientArea Begin
79430>>>>>            // the clientarea's parent panel has message
79430>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
79431>>>>>        End
79431>>>>>>
79431>>>>>    End_Procedure
79432>>>>>    
79432>>>>>     Function IsChecked Returns Boolean
79434>>>>>        Boolean bOn
79434>>>>>        Handle hoCommandBars hoClientArea
79434>>>>>        Get CommandBarSystemObject to hoCommandBars
79435>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79436>>>>>        If hoClientArea Begin
79438>>>>>            // the clientarea's parent panel has message
79438>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
79439>>>>>        End
79439>>>>>>
79439>>>>>        Function_Return bOn
79440>>>>>     End_Function
79441>>>>>End_Class
79442>>>>>
79442>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
79443>>>>>
79443>>>>>    Procedure Construct_Object
79445>>>>>        Forward Send Construct_Object
79447>>>>>        Set psCaption to C_$CaptionRestoreMenus
79448>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
79449>>>>>        Set psDescription to C_$DescRestoreMenus
79450>>>>>        Set psCategory to C_$CategoryWindow
79451>>>>>    End_Procedure
79452>>>>>
79452>>>>>    Procedure OnExecute Variant vCommandBarControl
79454>>>>>        Handle hoCommandBars
79454>>>>>        Get CommandBarSystemObject to hoCommandBars
79455>>>>>        Send RestoreLayout of hoCommandBars
79456>>>>>    End_Procedure
79457>>>>>    
79457>>>>>End_Class
79458>>>>>
79458>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
79459>>>>>
79459>>>>>    Procedure Construct_Object
79461>>>>>        Forward Send Construct_Object
79463>>>>>        Set psCaption to C_$CaptionCascade
79464>>>>>        Set psToolTip to C_$ToolTipCascade
79465>>>>>        Set psDescription to  C_$DescCascade
79466>>>>>        Set psImage to "ActionCascade.ico"
79467>>>>>        Set psCategory to C_$CategoryWindow
79468>>>>>    End_Procedure
79469>>>>>    
79469>>>>>    Procedure OnExecute Variant vCommandBarControl
79471>>>>>        Handle hoCommandBars hoClientArea
79471>>>>>        Get CommandBarSystemObject to hoCommandBars
79472>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79473>>>>>        If hoClientArea Begin
79475>>>>>            Send Cascade_Windows of hoClientArea
79476>>>>>        End
79476>>>>>>
79476>>>>>    End_Procedure
79477>>>>>End_Class
79478>>>>>
79478>>>>>Class cCJTileHorizontally is a cCJMenuItem
79479>>>>>
79479>>>>>    Procedure Construct_Object
79481>>>>>        Forward Send Construct_Object
79483>>>>>        Set psCaption to C_$CaptionTileHorizontally 
79484>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
79485>>>>>        Set psDescription to  C_$DescTileHorizontally
79486>>>>>        Set psImage to "ActionTileHorizontally.ico"
79487>>>>>        Set psCategory to C_$CategoryWindow
79488>>>>>    End_Procedure
79489>>>>>
79489>>>>>    Procedure OnExecute Variant vCommandBarControl
79491>>>>>        Handle hoCommandBars hoClientArea
79491>>>>>        Get CommandBarSystemObject to hoCommandBars
79492>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79493>>>>>        If hoClientArea Begin
79495>>>>>            Send Tile_Windows_Horizontal of hoClientArea
79496>>>>>        End
79496>>>>>>
79496>>>>>    End_Procedure
79497>>>>>End_Class
79498>>>>>
79498>>>>>Class cCJTileVertically is a cCJMenuItem
79499>>>>>
79499>>>>>    Procedure Construct_Object
79501>>>>>        Forward Send Construct_Object
79503>>>>>        Set psCaption to C_$CaptionTileVertically  
79504>>>>>        Set psToolTip to C_$ToolTipTileVertically
79505>>>>>        Set psDescription to  C_$DescTileVertically
79506>>>>>        Set psImage to "ActionTileVertically.ico"
79507>>>>>        Set psCategory to C_$CategoryWindow
79508>>>>>    End_Procedure
79509>>>>>
79509>>>>>    Procedure OnExecute Variant vCommandBarControl
79511>>>>>        Handle hoCommandBars hoClientArea
79511>>>>>        Get CommandBarSystemObject to hoCommandBars
79512>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79513>>>>>        If hoClientArea Begin
79515>>>>>            Send Tile_Windows_Vertical of hoClientArea
79516>>>>>        End
79516>>>>>>
79516>>>>>    End_Procedure
79517>>>>>End_Class
79518>>>>>
79518>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
79519>>>>>
79519>>>>>    Procedure Construct_Object
79521>>>>>        Forward Send Construct_Object
79523>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
79524>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
79525>>>>>        Set psDescription to  C_$DescMinimizeWindows
79526>>>>>        Set psCategory to C_$CategoryWindow
79527>>>>>    End_Procedure
79528>>>>>
79528>>>>>    Procedure OnExecute Variant vCommandBarControl
79530>>>>>        Handle hoCommandBars hoClientArea
79530>>>>>        Get CommandBarSystemObject to hoCommandBars
79531>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79532>>>>>        If hoClientArea Begin
79534>>>>>            // the clientarea's parent panel has message
79534>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
79535>>>>>        End
79535>>>>>>
79535>>>>>    End_Procedure
79536>>>>>End_Class
79537>>>>>
79537>>>>>
79537>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
79538>>>>>
79538>>>>>    Procedure Construct_Object
79540>>>>>        Forward Send Construct_Object
79542>>>>>        Set psCaption to C_$CaptionRestoreWindows
79543>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
79544>>>>>        Set psDescription to  C_$DescRestoreWindows
79545>>>>>        Set psCategory to C_$CategoryWindow
79546>>>>>    End_Procedure
79547>>>>>
79547>>>>>    Procedure OnExecute Variant vCommandBarControl
79549>>>>>        Handle hoCommandBars hoClientArea
79549>>>>>        Get CommandBarSystemObject to hoCommandBars
79550>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79551>>>>>        If hoClientArea Begin
79553>>>>>            // the clientarea's parent panel has message
79553>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
79554>>>>>        End
79554>>>>>>
79554>>>>>    End_Procedure
79555>>>>>End_Class
79556>>>>>
79556>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
79557>>>>>
79557>>>>>    Procedure Construct_Object
79559>>>>>        Forward Send Construct_Object
79561>>>>>        Set psCaption to C_$CaptionArrangeIcons  
79562>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
79563>>>>>        Set psDescription to  C_$DescArrangeIcons
79564>>>>>        Set psCategory to C_$CategoryWindow
79565>>>>>    End_Procedure
79566>>>>>
79566>>>>>    Procedure OnExecute Variant vCommandBarControl
79568>>>>>        Handle hoCommandBars hoClientArea
79568>>>>>        Get CommandBarSystemObject to hoCommandBars
79569>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79570>>>>>        If hoClientArea Begin
79572>>>>>            Send Arrange_Icons of hoClientArea
79573>>>>>        End
79573>>>>>>
79573>>>>>    End_Procedure
79574>>>>>
79574>>>>>End_Class
79575>>>>>    
79575>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJAboutMenuItem.pkg)
79575>>>>>Use cCJCommandBarSystem.pkg
79575>>>>>Use LanguageText.pkg
79575>>>>>
79575>>>>>// It is expected that if you use this class that you provide an about object that is
79575>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
79575>>>>>// because you may wish to create your own custom about package.
79575>>>>>
79575>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
79576>>>>>
79576>>>>>    Procedure Construct_Object
79578>>>>>        Forward Send Construct_Object
79580>>>>>        Set psCaption to C_$CaptionAbout
79581>>>>>        Set psDescription to C_$ToolTipAbout
79582>>>>>        Set psToolTip to C_$DescAbout
79583>>>>>        Set psImage to "ActionAbout.ico"
79584>>>>>        Set psCategory to C_$CategoryHelp
79585>>>>>    End_Procedure
79586>>>>>    
79586>>>>>    Procedure OnExecute Variant vCommandBarControl
79588>>>>>        Handle hoCommandBars hoClientArea
79588>>>>>        Get CommandBarSystemObject to hoCommandBars
79589>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79590>>>>>        If hoClientArea Begin
79592>>>>>            Send Activate_About of hoClientArea
79593>>>>>        End
79593>>>>>>
79593>>>>>    End_Procedure
79594>>>>>
79594>>>>>End_Class
79595>>>>>
79595>>>>>
79595>>>Use cCJDeoMenuItemClasses.pkg
79595>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJMDIWindowsMenuItem.pkg)
79595>>>>>Use cCJCommandBarSystem.pkg
79595>>>>>
79595>>>>>Register_Function Client_ID Returns Integer
79595>>>>>
79595>>>>>// only used by cCJMDIWIndowsMenuItem
79595>>>>>Class cCJMDIWindowItem is a cCJMenuItem
79596>>>>>
79596>>>>>    Procedure Construct_Object
79598>>>>>        Forward Send Construct_Object
79600>>>>>        Property Handle phWindow 0 // object id of view
79601>>>>>        Set pbControlFlagNoMovable to True
79602>>>>>        Set pbActiveUpdate to True
79603>>>>>    End_Procedure
79604>>>>>    
79604>>>>>    Procedure OnExecute Variant vCommandBarControl
79606>>>>>        Handle hWindow
79606>>>>>        Get phWindow to hWindow
79607>>>>>        Send Activate_View of hWindow
79608>>>>>    End_Procedure
79609>>>>>    
79609>>>>>End_Class                
79610>>>>>
79610>>>>>
79610>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
79611>>>>>    
79611>>>>>    Procedure Construct_Object
79613>>>>>        Forward Send Construct_Object
79615>>>>>        Property Handle[] phArrayOfWindows
79616>>>>>        Set peControlType to xtpControlPopup
79617>>>>>        Set psCategory to C_$CategoryWindow
79618>>>>>    End_Procedure
79619>>>>>    
79619>>>>>     // This adds MDI windows to the existing menu items.
79619>>>>>     // This removes any existing windows menus and always adds a new set to the end
79619>>>>>
79619>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
79621>>>>>        Handle  hClientArea hView
79621>>>>>        String  sLabel
79621>>>>>        Integer i iWindows
79621>>>>>        Handle[] hArrayOfWindows
79622>>>>>        Variant vItem
79622>>>>>        
79622>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
79622>>>>>        // also assume that destroying an action removes all menu instances of that action
79622>>>>>        Get phArrayOfWindows to hArrayOfWindows
79623>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
79624>>>>>        For i from 0 to (iWindows-1)
79630>>>>>>
79630>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
79631>>>>>        Loop
79632>>>>>>
79632>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
79633>>>>>
79633>>>>>        // Add all views to this menu. Create the action and add the item
79633>>>>>        Move 0 to i
79634>>>>>        Get Client_Id to hClientArea // object id of client area
79635>>>>>        If (hClientArea > 0) Begin
79637>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
79638>>>>>            While (hView <> 0)
79642>>>>>                If (Active_State(hView)) Begin
79644>>>>>                    // create the action
79644>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
79645>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
79646>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
79647>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
79648>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
79650>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
79651>>>>>                    End
79651>>>>>>
79651>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
79652>>>>>                    If (i=0) Begin
79654>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
79655>>>>>                    End
79655>>>>>>
79655>>>>>                    // Create a menu item for this action
79655>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
79656>>>>>                    Increment i
79657>>>>>                End
79657>>>>>>
79657>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
79658>>>>>            Loop
79659>>>>>>
79659>>>>>        End
79659>>>>>>
79659>>>>>
79659>>>>>        Set phArrayOfWindows to hArrayOfWindows
79660>>>>>
79660>>>>>     End_Procedure
79661>>>>>     
79661>>>>>End_Class
79662>>>>>
79662>Use Dfspnfrm.pkg
79662>Use Dfcursor.pkg
79662>Use Dfline.pkg
79662>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vWin32fh.pkg)
79662>>>// This code is part of VDF GUIdance
79662>>>// Visit us @ http://www.vdf-guidance.com
79662>>>// e-Mail us @ info@vdf-guidance.com
79662>>>// VDF GUIdance is a mutual project of
79662>>>// Frank Vandervelpen - Vandervelpen Systems and
79662>>>// Wil van Antwerpen  - Antwise Solutions
79662>>>// All software source code should be used <<AS IS>> without any warranty.
79662>>>//
79662>>>//
79662>>>// *** Windows 32bit file handling wrapper class ***
79662>>>//
79662>>>
79662>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
79662>>>//                   This may be painfull for some of you, but it was really needed as it was
79662>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
79662>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
79662>>>//
79662>>>// The used naming-convention is:
79662>>>//     - a prefix of "vWin32_" for every external function declaration
79662>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
79662>>>//
79662>>>// By using this we are guarding ourselves for conflicts with variable declarations
79662>>>// of DataAccess in the future.
79662>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
79662>>>//
79662>>>// mm-dd-yyyy Author Description
79662>>>//
79662>>>//                   vSHGetFolderPath added to retrieve the new shell folders
79662>>>//                   vGetWindowsDirectory
79662>>>//
79662>>>//                   vGetTempFileName
79662>>>//                   vGetTempPath
79662>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
79662>>>//                   This is an absolute need for WebApp. We expect you to handle the
79662>>>//                   error in your application anyways. Changed this for:
79662>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
79662>>>// 03-02-2002 **WvA: vRemoveDirectory added
79662>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
79662>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
79662>>>//                   It is renamed too avoid this.
79662>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
79662>>>//                   function vSelectedFileName is now just SelectedFileName
79662>>>//                   Removed the local keyword in the variable declarations
79662>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
79662>>>//                   created file-open dialog
79662>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
79662>>>//                   in that it didn't exactly return the correct filename of the file created.
79662>>>//                   This has now been taken care of.
79662>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
79662>>>//                   These declarations are now included from the vWin32fh header file.
79662>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
79662>>>//                   Before today one could always undo the operation, as of now you cannot as
79662>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
79662>>>//                   Since i don't really expect someone to use that feature it has been removed.
79662>>>//                   One can however restore to the old way of handling by simply calling the
79662>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
79662>>>//                   filehandling operations
79662>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
79662>>>//                   as well as the StringFromRightOfChar function.
79662>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
79662>>>//                   DISABLED now as testing shows that it does not work as advertised...
79662>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
79662>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
79662>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
79662>>>//                   extended characters are treated ok too.
79662>>>//                   Reported by Flemming from
79662>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
79662>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
79662>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
79662>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
79662>>>//                   Added vSelectSavefile function to create a file save dialog
79662>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
79662>>>//                   Added vParentPath function to retrieve the parent "node" of a path
79662>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
79662>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
79662>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
79662>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
79662>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
79662>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
79662>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
79662>>>
79662>>>Use Case.mac
79662>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
79662>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cvFileDialogs.pkg)
79662>>>>>//***************************************************************************
79662>>>>>//*
79662>>>>>//* Class:        cvSaveAsDialog
79662>>>>>//* Package Name: cvFileDialogs.pkg
79662>>>>>//*
79662>>>>>//***************************************************************************
79662>>>>>
79662>>>>>Use File_dlg.pkg
79662>>>>>
79662>>>>>// *WvA: 13-01-1999 Created
79662>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
79662>>>>>// This function opens the Windows standard file open dialog and returns the selected
79662>>>>>// file_name.
79662>>>>>Class cvSelectFile_Dialog Is An OpenDialog
79663>>>>>
79663>>>>>  Procedure Construct_Object Integer iImage_Id
79665>>>>>    Forward Send Construct_Object iImage_Id
79667>>>>>    Set HideReadOnly_State To True
79668>>>>>  End_Procedure // Construct_Object
79669>>>>>
79669>>>>>  Function SelectedFileName Returns String
79671>>>>>    String sFileName
79671>>>>>    Move "" To sFileName
79672>>>>>    If (Show_Dialog(Self)) Begin
79674>>>>>      Move (RTrim(File_Name(Self))) To sFileName
79675>>>>>    End
79675>>>>>>
79675>>>>>    Function_Return sFileName
79676>>>>>  End_Function // SelectedFileName
79677>>>>>End_Class // cvSelectFile_Dialog
79678>>>>>
79678>>>>>
79678>>>>>// *WvA: 13-01-1999 Created
79678>>>>>// This function opens the Windows standard file open dialog and returns the selected
79678>>>>>// file_name. Returns '' if the user didn't make a selection.
79678>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
79678>>>>>//                   file-open dialog
79678>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
79680>>>>>  String sSelectedFile
79680>>>>>  Integer hoOpenFileDialog
79680>>>>>
79680>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
79682>>>>>
79682>>>>>    Set Dialog_Caption    To sCaptionText
79683>>>>>    Set Filter_String     To sSupportedFileTypes
79684>>>>>    Set Initial_Folder    To sInitialFolder
79685>>>>>
79685>>>>>    Move Self       To hoOpenFileDialog
79686>>>>>  End_Object // oOpenFileDialog
79687>>>>>
79687>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
79688>>>>>  Send Destroy_Object To hoOpenFileDialog
79689>>>>>  Function_Return sSelectedFile
79690>>>>>End_Function // vSelect_File
79691>>>>>
79691>>>>>
79691>>>>>Class cvSaveAsDialog is a SaveAsDialog
79692>>>>>
79692>>>>>  Procedure Construct_Object
79694>>>>>    Forward Send Construct_Object
79696>>>>>    Set HideReadOnly_State To True
79697>>>>>  End_Procedure // Construct_Object
79698>>>>>
79698>>>>>  Function SelectedFileName Returns String
79700>>>>>    String sFileName
79700>>>>>    Move "" To sFileName
79701>>>>>    If (Show_Dialog(Self)) Begin
79703>>>>>      Move (RTrim(File_Name(Self))) To sFileName
79704>>>>>    End
79704>>>>>>
79704>>>>>    Function_Return sFileName
79705>>>>>  End_Function // SelectedFileName
79706>>>>>
79706>>>>>End_Class // cvSaveAsDialog
79707>>>>>
79707>>>>>// Added optional default filename as suggested by Nils
79707>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
79709>>>>>  String sSelectedFile
79709>>>>>  Integer hoDialog
79709>>>>>
79709>>>>>  Move "" To sSelectedFile
79710>>>>>  Get Create U_cvSaveAsDialog To hoDialog
79711>>>>>  If (hoDialog) Begin
79713>>>>>    //Set NoChangeDir_State Of hoDialog To True
79713>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
79714>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
79715>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
79716>>>>>    If (Num_Arguments = 4) Begin
79718>>>>>      Set File_Title        of hoDialog to sDefaultFileName
79719>>>>>    End
79719>>>>>>
79719>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
79720>>>>>    Send Destroy Of hoDialog
79721>>>>>  End
79721>>>>>>
79721>>>>>  Function_Return sSelectedFile
79722>>>>>End_Function // vSelectSaveFile
79723>>>Use Seq_chnl.pkg
79723>>>
79723>>>Use windows
79723>>>//Use Dferror
79723>>>Use Dll
79723>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vwin32fh.h)
79723>>>>>//TH-Header
79723>>>>>//*****************************************************************************************
79723>>>>>// Copyright (c)  2004 KURANT Project
79723>>>>>// All rights reserved.
79723>>>>>//
79723>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
79723>>>>>// $ProjectName : Windows 32 bits file handling
79723>>>>>// $Authors     : Wil van Antwerpen
79723>>>>>// $Created     : 19.02.2004  19:25
79723>>>>>// $Type        : BSD (as in do with it whatever you like)
79723>>>>>//
79723>>>>>// Contents:
79723>>>>>//  This file contains the Windows API external function call definitions and
79723>>>>>//  constants as they are used in the vWin32fh package.
79723>>>>>//*****************************************************************************************
79723>>>>>//TH-RevisionStart
79723>>>>>//TH-RevisionEnd
79723>>>>>
79723>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
79723>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
79723>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
79723>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
79723>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
79723>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
79723>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
79723>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
79723>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
79723>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
79723>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
79723>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
79723>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
79723>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
79723>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
79723>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
79723>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
79723>>>>>
79723>>>>>
79723>>>>>Define vMax_Path     For |CI260
79723>>>>>Define vMinChar      For |CI$80
79723>>>>>Define vMaxChar      For |CI$7F
79723>>>>>Define vMinShort     For |CI$8000
79723>>>>>Define vMaxShort     For |CI$7FFF
79723>>>>>Define vMinLong      For |CI$80000000
79723>>>>>Define vMaxLong      For |CI$7FFFFFFF
79723>>>>>Define vMaxByte      For |CI$FF
79723>>>>>Define vMaxWord      For |CI$FFFF
79723>>>>>Define vMaxDword     For |CI$FFFFFFFF
79723>>>>>
79723>>>>>
79723>>>>>
79723>>>>>// For FindFirstFile
79723>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
79723>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
79723>>>>>Define vERROR_NO_MORE_FILES    For |CI18
79723>>>>>
79723>>>>>// The defines below can be used to find out what kind of error has occurred if
79723>>>>>// the API-call ShellExecute is used.
79723>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
79723>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
79723>>>>>Define vERROR_BAD_FORMAT       For |CI0011
79723>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
79723>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
79723>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
79723>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
79723>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
79723>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
79723>>>>>Define vSE_ERR_FNF             For |CI0002
79723>>>>>Define vSE_ERR_NOASSOC         For |CI0031
79723>>>>>Define vSE_ERR_OOM             For |CI0008
79723>>>>>Define vSE_ERR_PNF             For |CI0003
79723>>>>>Define vSE_ERR_SHARE           For |CI0026
79723>>>>>
79723>>>>>
79723>>>>>// C-Structure
79723>>>>>//typedef struct _browseinfo {
79723>>>>>//    HWND hwndOwner;
79723>>>>>//    LPCITEMIDLIST pidlRoot;
79723>>>>>//    LPSTR pszDisplayName;
79723>>>>>//    LPCSTR lpszTitle;
79723>>>>>//    UINT ulFlags;
79723>>>>>//    BFFCALLBACK lpfn;
79723>>>>>//    LPARAM lParam;
79723>>>>>//    int iImage;
79723>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
79723>>>>>
79723>>>>>//declare C structure struct_browseinfo
79723>>>>>//as documented in MSDN under Windows Shell API
79723>>>>>Type vtBrowseInfo
79723>>>>>  Field vtBrowseInfo.hWndOwner      as Handle
79723>>>>>  Field vtBrowseInfo.pIDLRoot       as Pointer
79723>>>>>  Field vtBrowseInfo.pszDisplayName as Pointer
79723>>>>>  Field vtBrowseInfo.lpszTitle      as Pointer
79723>>>>>  Field vtBrowseInfo.ulFlags        as dWord
79723>>>>>  Field vtBrowseInfo.lpfnCallback   as Pointer
79723>>>>>  Field vtBrowseInfo.lParam         as dWord
79723>>>>>  Field vtBrowseInfo.iImage         as dWord
79723>>>>>End_Type // tBrowseInfo
79723>>>>>
79723>>>>>// Browsing for directory.
79723>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
79723>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
79723>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
79723>>>>>                                            // The callback function can set the status text by
79723>>>>>                                            // sending messages to the dialog box.
79723>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
79723>>>>>
79723>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
79723>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
79723>>>>>
79723>>>>>// message from browser
79723>>>>>//Define BFFM_INITIALIZED        1
79723>>>>>//Define BFFM_SELCHANGED         2
79723>>>>>
79723>>>>>// messages to browser
79723>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
79723>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
79723>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
79723>>>>>
79723>>>>>
79723>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
79724>>>>>
79724>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
79725>>>>>
79725>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
79726>>>>>
79726>>>>>
79726>>>>>
79726>>>>>
79726>>>>>Type vtSecurity_attributes
79726>>>>>  Field vtSecurity_attributes.nLength        as dWord
79726>>>>>  Field vtSecurity_attributes.lpDescriptor   as Pointer
79726>>>>>  Field vtSecurity_attributes.bInheritHandle as Integer
79726>>>>>End_Type // vtSecurity_attributes
79726>>>>>
79726>>>>>//nLength:
79726>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
79726>>>>>// SECURITY_ATTRIBUTES structure.
79726>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
79726>>>>>// value of the nLength member. However, an application should still set it properly.
79726>>>>>// That ensures current, future, and cross-platform compatibility.
79726>>>>>//
79726>>>>>//lpSecurityDescriptor:
79726>>>>>// Points to a security descriptor for the object that controls the sharing of it.
79726>>>>>// If NULL is specified for this member, the object may be assigned the default security
79726>>>>>// descriptor of the calling process.
79726>>>>>//
79726>>>>>//bInheritHandle:
79726>>>>>// Specifies whether the returned handle is inherited when a new process is created.
79726>>>>>// If this member is TRUE, the new process inherits the handle.
79726>>>>>
79726>>>>>
79726>>>>>// BOOL CreateDirectory(
79726>>>>>//    LPCTSTR lpPathName,
79726>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
79726>>>>>//   );
79726>>>>>//
79726>>>>>// lpPathName
79726>>>>>//  Points to a null-terminated string that specifies the path of the directory
79726>>>>>//  to be created.
79726>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
79726>>>>>//  This limit is related to how the CreateDirectory function parses paths.
79726>>>>>// lpSecurityAttributes
79726>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
79726>>>>>//  determines whether the returned handle can be inherited by child processes.
79726>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
79726>>>>>// Returns:
79726>>>>>//  If the function succeeds, the return value is nonzero.
79726>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
79726>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
79727>>>>>
79727>>>>>
79727>>>>>// lpPathName
79727>>>>>//  Points to a null-terminated string that specifies the path of the directory
79727>>>>>//  to be removed.
79727>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
79727>>>>>// Returns:
79727>>>>>//  If the function succeeds, the return value is nonzero.
79727>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
79727>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
79728>>>>>
79728>>>>>
79728>>>>>
79728>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
79728>>>>>// executable file or a document file.
79728>>>>>//
79728>>>>>// Operation can be one of the following:
79728>>>>>//    "OPEN"  The function opens the file specified by lpFile.
79728>>>>>//            The file can be an executable file or a document file.
79728>>>>>//            The file can be a folder to open.
79728>>>>>//    "PRINT" The function prints the file specified by lpFile.
79728>>>>>//            The file should be a document file. If the file is an executable file,
79728>>>>>//            the function opens the file, as if "open" had been specified.
79728>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
79728>>>>>//
79728>>>>>// Return Values:
79728>>>>>//
79728>>>>>// If the function succeeds, the return value is the instance handle of the application that
79728>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
79728>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
79728>>>>>//
79728>>>>>// The following table lists these error values:
79728>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
79728>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
79728>>>>>// Public Const ERROR_BAD_FORMAT = 11&
79728>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
79728>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
79728>>>>>// Public Const SE_ERR_DDEBUSY = 30
79728>>>>>// Public Const SE_ERR_DDEFAIL = 29
79728>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
79728>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
79728>>>>>// Public Const SE_ERR_FNF = 2
79728>>>>>// Public Const SE_ERR_NOASSOC = 31
79728>>>>>// Public Const SE_ERR_OOM = 8
79728>>>>>// Public Const SE_ERR_PNF = 3
79728>>>>>// Public Const SE_ERR_SHARE = 26
79728>>>>>
79728>>>>>
79728>>>>>
79728>>>>>// Code to open the program that is associated with the selected file.
79728>>>>>//
79728>>>>>// External function call used in Procedure DoStartDocument
79728>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
79729>>>>>
79729>>>>>
79729>>>>>
79729>>>>>
79729>>>>>
79729>>>>>                                          // Must be freed using SHFreeNameMappings
79729>>>>>
79729>>>>>Type vtShFileOpStruct
79729>>>>>  Field vtShFileOpStruct.hWnd                   as Handle
79729>>>>>  Field vtShFileOpStruct.wFunc                  as Integer
79729>>>>>  Field vtShFileOpStruct.pFrom                  as Pointer
79729>>>>>  Field vtShFileOpStruct.pTo                    as Pointer
79729>>>>>  Field vtShFileOpStruct.fFlags                 as Short
79729>>>>>  Field vtShFileOpStruct.fAnyOperationsAborted  as Short
79729>>>>>  Field vtShFileOpStruct.hNameMappings          as Pointer
79729>>>>>  Field vtShFileOpStruct.lpszProgressTitle      as Pointer // only used if FOF_SIMPLEPROGRESS
79729>>>>>End_Type // tShFileOpStruct
79729>>>>>
79729>>>>>// hwnd
79729>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
79729>>>>>
79729>>>>>// wFunc
79729>>>>>//   Operation to perform. This member can be one of the following values:
79729>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
79729>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
79729>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
79729>>>>>//     FO_RENAME   Renames the files specified by pFrom.
79729>>>>>
79729>>>>>// pFrom
79729>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
79729>>>>>//   be null-separated. The list of names must be double null-terminated.
79729>>>>>
79729>>>>>// pTo
79729>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
79729>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
79729>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
79729>>>>>//   double null-terminated.
79729>>>>>
79729>>>>>// fAnyOperationsAborted
79729>>>>>//   Value that receives TRUE if the user aborted any file operations before they
79729>>>>>//   were completed or FALSE otherwise.
79729>>>>>
79729>>>>>
79729>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
79729>>>>>// This can be a file or a folder.
79729>>>>>// With thanks to Andrew S Kaplan
79729>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
79730>>>>>
79730>>>>>
79730>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
79730>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
79731>>>>>
79731>>>>>
79731>>>>>
79731>>>>>// Courtesy Of Vincent Oorsprong
79731>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
79731>>>>>//   Pointer lpPathName ;
79731>>>>>//   Pointer lpPrefixString ;
79731>>>>>//   Integer uUnique ;
79731>>>>>//   Pointer lpTempFileName ;
79731>>>>>//   Returns Integer
79731>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
79731>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
79732>>>>>
79732>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
79733>>>>>
79733>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
79734>>>>>                  
79734>>>>>// from:
79734>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
79734>>>>>//
79734>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
79734>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
79734>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
79734>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
79734>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
79734>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
79734>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
79734>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
79734>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
79734>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
79734>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
79734>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
79734>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
79734>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
79734>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
79734>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
79734>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
79734>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
79734>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
79734>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
79734>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
79734>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
79734>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
79734>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
79734>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
79734>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
79734>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
79734>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
79734>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
79734>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
79734>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
79734>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
79734>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
79734>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
79734>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
79734>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
79734>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
79734>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
79734>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
79734>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
79734>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
79734>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
79734>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
79734>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
79734>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
79734>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
79734>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
79734>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
79734>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
79734>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
79734>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
79734>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
79734>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
79734>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
79734>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
79734>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
79734>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
79734>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
79734>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
79734>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
79734>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
79734>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
79734>>>>>
79734>>>>>
79734>>>>>//HRESULT SHGetFolderPath(
79734>>>>>//    HWND hwndOwner,
79734>>>>>//    int nFolder,
79734>>>>>//    HANDLE hToken,
79734>>>>>//    DWORD dwFlags,
79734>>>>>//    LPTSTR pszPath
79734>>>>>//);
79734>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
79734>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
79734>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
79734>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
79734>>>>>// If that fails, it will try to simulate the appropriate behavior.
79734>>>>>//
79734>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
79735>>>>>
79735>>>>>
79735>>>>>
79735>>>>>Type vWin32_Find_Data
79735>>>>>  Field vWin32_Find_Data.dwFileAttributes As Dword
79735>>>>>  Field vWin32_Find_Data.ftCreationLowDateTime As Dword
79735>>>>>  Field vWin32_Find_Data.ftCreationHighDateTime As Dword
79735>>>>>  Field vWin32_Find_Data.ftLastAccessLowDateTime As dword
79735>>>>>  Field vWin32_Find_Data.ftLastAccessHighDateTime As Dword
79735>>>>>  Field vWin32_Find_Data.ftLastWriteLowDateTime As Dword
79735>>>>>  Field vWin32_Find_Data.ftLastWriteHighDateTime As Dword
79735>>>>>  Field vWin32_Find_Data.nFileSizeHigh As Dword
79735>>>>>  Field vWin32_Find_Data.nFileSizeLow As Dword
79735>>>>>  Field vWin32_Find_Data.dwReserved0 As Dword
79735>>>>>  Field vWin32_Find_Data.dwReserved1 As Dword
79735>>>>>  Field vWin32_Find_Data.cFileName As Char vMax_Path
79735>>>>>  Field vWin32_Find_Data.cAlternateFileName As Char 14
79735>>>>>End_Type // vWin32_Find_Data
79735>>>>>
79735>>>>>// Courtesy Of Vincent Oorsprong
79735>>>>>// lpFileName      : address of name of file to search for
79735>>>>>// lpFindFileData  : address of returned information
79735>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
79736>>>>>
79736>>>>>// Courtesy Of Vincent Oorsprong
79736>>>>>// hFindFile       : handle of search
79736>>>>>// lpFindFileData  : address of structure for data on found file
79736>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
79737>>>>>
79737>>>>>// Courtesy Of Vincent Oorsprong
79737>>>>>//  hFindFile      : file search handle
79737>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
79738>>>>>
79738>>>>>
79738>>>>>
79738>>>>>Type vFileTime
79738>>>>>  Field vFileTime.dwLowDateTime As Dword
79738>>>>>  Field vFileTime.dwHighDateTime As Dword
79738>>>>>End_Type // vFileTime
79738>>>>>
79738>>>>>
79738>>>>>Type vSystemTime
79738>>>>>  Field vSystemTime.wYear As Word
79738>>>>>  Field vSystemTime.wMonth As Word
79738>>>>>  Field vSystemTime.wDayOfWeek As Word
79738>>>>>  Field vSystemTime.wDay As Word
79738>>>>>  Field vSystemTime.wHour As Word
79738>>>>>  Field vSystemTime.wMinute As Word
79738>>>>>  Field vSystemTime.wSecond As Word
79738>>>>>  Field vSystemTime.wMilliSeconds As Word
79738>>>>>End_Type // vSystemTime
79738>>>>>
79738>>>>>
79738>>>>>// Courtesy Of Vincent Oorsprong
79738>>>>>//  lpFileTime     : pointer to file time to convert
79738>>>>>//  lpSystemTime   : pointer to structure to receive system time
79738>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
79739>>>>>
79739>>>>>// Courtesy Of Vincent Oorsprong
79739>>>>>// This function formats the time in a picture-string passed
79739>>>>>//
79739>>>>>// Picture      Meaning
79739>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
79739>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
79739>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
79739>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
79739>>>>>//    m         Minutes with no leading zero for single-digit minutes
79739>>>>>//    mm        Minutes with leading zero for single-digit minutes
79739>>>>>//    s         Seconds with no leading zero for single-digit seconds
79739>>>>>//    ss        Seconds with leading zero for single-digit seconds
79739>>>>>//    t         One character time marker string, such as A or P
79739>>>>>//    tt        Multicharacter time marker string, such as AM or PM
79739>>>>>//
79739>>>>>// For example, to get the time string  "11:29:40 PM"
79739>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
79739>>>>>
79739>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
79740>>>>>
79740>>>>>
79740>>>>>// Courtesy Of Vincent Oorsprong
79740>>>>>// This function formats the date in a picture-string passed
79740>>>>>//
79740>>>>>// Picture      Meaning
79740>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
79740>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
79740>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
79740>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
79740>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
79740>>>>>//              value associated with the specified locale.
79740>>>>>//    M         Month as digits with no leading zero for single-digit months.
79740>>>>>//    MM        Month as digits with leading zero for single-digit months.
79740>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
79740>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
79740>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
79740>>>>>//              associated with the specified locale.
79740>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
79740>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
79740>>>>>//    yyyy      Year represented hy full four digits.
79740>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
79740>>>>>//              with the specified locale. This element is ignored if the date to be formatted
79740>>>>>//              does not have an associated era or period string.
79740>>>>>// For example, to get the date string  "Wed, Aug 31 94"
79740>>>>>// use the following picture string:    "ddd","MMM dd yy"
79740>>>>>
79740>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
79741>>>>>
79741>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
79741>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$0000000l  //  do not use minutes or seconds
79741>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
79741>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
79741>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
79741>>>>>
79741>>>>>//  Date Flags for GetDateFormatW.
79741>>>>>//
79741>>>>>Define DATE_SHORTDATE           For |CI$0000000l  //  use short date picture
79741>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
79741>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
79741>>>>>
79741>>>>>
79741>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
79742>>>>>
79742>>>>>
79742>>>>>// **WvA: 20-02-2004
79742>>>>>// While i was testing the format capabilities i stumbled over a very
79742>>>>>// weird problem where it looks like that the integer value gets somehow translated
79742>>>>>// incorrectly into an unsigned integer.
79742>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
79742>>>>>// It does smell a bit fishy though
79742>>>>>// Tested it with the same results on both VDF7 and VDF9.1
79742>>>>>
79742>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
79742>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
79742>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
79742>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
79742>>>>>
79742>>>>>// Possible errors that can be returned by the shellformat function
79742>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
79742>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
79742>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
79742>>>>>                                                
79742>>>>>
79742>>>>> // Courtesy Of Steve Walter,
79742>>>>> // USA Software, Inc
79742>>>>> // Format a disk
79742>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
79742>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
79743>>>>>
79743>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
79743>>>>>
79743>>>>>// SHCreateDirectoryEx
79743>>>>>
79743>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
79743>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
79743>>>>>//
79743>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
79743>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
79743>>>>>//    the files are visible. If they are not visible, expect one of the following:
79743>>>>>//
79743>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
79743>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
79743>>>>>//        ERROR_CANCELLED.
79743>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
79743>>>>>
79743>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
79743>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
79743>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
79743>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
79743>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
79743>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
79743>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
79743>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
79743>>>>>
79743>>>>>//        int SHCreateDirectoryEx(
79743>>>>>//            HWND hwnd,
79743>>>>>//            LPCTSTR pszPath,
79743>>>>>//            const SECURITY_ATTRIBUTES *psa
79743>>>>>//        );
79743>>>>>
79743>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
79744>>>
79744>>>
79744>>>
79744>>>
79744>>>
79744>>>//
79744>>>// Gets the string from the right of the last sStopChar in sFrom
79744>>>// If sStopChar has no occurences in the string an empty string is
79744>>>// returned.
79744>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
79746>>>  String  sRetVal
79746>>>  String  sChar
79746>>>  Integer iLength
79746>>>  Integer iPos
79746>>>  Boolean bStopChar
79746>>>  Move "" To sRetval
79747>>>  Move (Length(sFrom)) To iLength
79748>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
79750>>>    Move iLength   To iPos
79751>>>    Move (False)   To bStopChar
79752>>>    While Not bStopChar
79756>>>      Move (Mid(sFrom,1,iPos)) To sChar
79757>>>      Decrement iPos
79758>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
79760>>>        Move (True) To bStopChar
79761>>>      End
79761>>>>
79761>>>      Else Begin
79762>>>        Move (sChar+sRetVal) To sRetVal
79763>>>      End
79763>>>>
79763>>>    Loop
79764>>>>
79764>>>  End
79764>>>>
79764>>>  Function_Return sRetVal
79765>>>End_Function // StringFromRightOfChar
79766>>>
79766>>>
79766>>>// Pre:  sFileName contains the complete path of the file.
79766>>>// Post: returns the complete path of the file.
79766>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
79766>>>Function ParseFolderName Global String sFileName Returns String
79768>>>  String sFile
79768>>>  String sFolderName
79768>>>  String sDirSep // this is "\" for windows, or "/" for unix
79768>>>  MOve "" To sFolderName
79769>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
79770>>>  If sDirSep In sFileName Begin
79772>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
79773>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
79774>>>  End
79774>>>>
79774>>>  Else If ":" In sFileName Begin
79777>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
79778>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
79779>>>  End
79779>>>>
79779>>>  Function_Return sFolderName
79780>>>End_Function // ParseFolderName
79781>>>
79781>>>
79781>>>// Pre:  sFileName contains the complete path of the file.
79781>>>// post: The returned filename has it's path removed, but will have a extension
79781>>>Function ParseFileName Global String sFileName Returns String
79783>>>  String sFolderName
79783>>>  String sDirSep // this is "\" for windows, or "/" for unix
79783>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
79784>>>  Get ParseFolderName sFileName To sFolderName
79785>>>  If (sFolderName <> "") Move (Replace(sFolderName,sFileName,"")) To sFileName
79788>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
79789>>>  Function_Return sFilename
79790>>>End_Function // ParseFileName
79791>>>
79791>>>
79791>>>// Pre:  sFileName may contain the complete path of the file.
79791>>>//       or contain multiple dots in the filename, so temp.gif.bak will
79791>>>//       return "bak" as the extension and not "gif"
79791>>>// Post: returns the extension only, this extension can be a valid unixlike extension
79791>>>//       such as "html" or "java"
79791>>>Function ParseFileExtension Global String sFileName Returns String
79793>>>  String  sFileExtension
79793>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
79794>>>  Function_Return sFileExtension
79795>>>End_Function // ParseFileExtension
79796>>>
79796>>>
79796>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
79796>>>
79796>>>
79796>>>Function DDE_Error_To_String Integer iErrorID Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
79798>>>  String sMessage
79798>>>  Case Begin
79798>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
79800>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
79801>>>      Case Break
79802>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
79805>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
79806>>>      Case Break
79807>>>    Case (iErrorID = vERROR_BAD_FORMAT)
79810>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
79811>>>      Case Break
79812>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
79815>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
79816>>>      Case Break
79817>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
79820>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
79821>>>      Case Break
79822>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
79825>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
79826>>>      Case Break
79827>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
79830>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
79831>>>      Case Break
79832>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
79835>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
79836>>>      Case Break
79837>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
79840>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
79841>>>      Case Break
79842>>>    Case (iErrorID = vSE_ERR_NOASSOC)
79845>>>      Move CS_DDE_ERR_NOASSOC To sMessage
79846>>>      Case Break
79847>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
79850>>>      Move CS_DDE_ERR_OOM To sMessage
79851>>>      Case Break
79852>>>    Case (iErrorID = vSE_ERR_PNF)
79855>>>      Move CS_DDE_ERR_PNF To sMessage
79856>>>      Case Break
79857>>>    Case (iErrorID = vSE_ERR_SHARE)
79860>>>      Move CS_DDE_ERR_SHARE To sMessage
79861>>>      Case Break
79862>>>    Case Else
79862>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
79863>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
79864>>>      Case Break
79865>>>  Case End
79865>>>  Function_Return sMessage
79866>>>End_Function // DDE_Error_To_String
79867>>>
79867>>>
79867>>>Procedure vDDE_Error_Handler Integer iErrorID
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
79869>>>  String sMessage
79869>>>  Get DDE_Error_To_String iErrorID To sMessage
79870>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
79871>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
79872>>>End_Procedure // vDDE_Error_Handler hInstance
79873>>>
79873>>>
79873>>>// Does the directory exist? - No = 0, Yes = 1
79873>>>// This also works with UNC path encoding and wildcards
79873>>>Function vFolderExists Global String sFolderName Returns Integer
79875>>>  String  sFolder sTmp
79875>>>  Integer bFolderExists iCh
79875>>>
79875>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
79875>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
79876>>>  If (sFolderName = "") Begin
79878>>>    Function_Return False
79879>>>  End
79879>>>>
79879>>>
79879>>>  Move dfTrue To bFolderExists
79880>>>  Move "dir:" To sFolder
79881>>>  Append sFolder sFolderName
79882>>>  Get Seq_New_Channel To iCh  // get free channel for input
79883>>>  Direct_Input Channel iCh sFolder
79885>>>    Repeat
79885>>>>
79885>>>      Readln Channel iCh sTmp
79887>>>      If (Trim(sTmp)="") Move dfFalse To bFolderExists
79890>>>      Else Begin
79891>>>        Move dfTrue To bFolderExists
79892>>>        Indicate seqeof True  // end loop
79893>>>        End
79893>>>>
79893>>>    Until (seqeof)
79895>>>  Close_Input Channel iCh
79897>>>  Send Seq_Release_Channel iCh
79898>>>  Function_Return bFolderExists
79899>>>End_Function  // vFolderExists
79900>>>
79900>>>
79900>>>// returns folder name if a folder was selected, otherwise returns ""
79900>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
79902>>>  String sFolder sBrowseInfo sTitle
79902>>>  Pointer lpItemIdList lpsFolder lpsBrowseInfo lpsTitle
79902>>>  Integer iFolderSelected iRetval
79902>>>
79902>>>  // fill string variable with null characters
79902>>>  ZeroType vtBrowseInfo To sBrowseInfo
79903>>>
79903>>>  If (sDialogTitle<>"") Begin
79905>>>    Move sDialogTitle To sTitle
79906>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
79906>>>    // disables showing some commonly used ascii characters like ascii 137 ()
79906>>>    // These chars are correctly shown if no toansi is used.
79906>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
79906>>>    // selected it will always be valid.
79906>>>    GetAddress Of sTitle To lpsTitle
79907>>>    Put lpsTitle To sBrowseInfo At vtBrowseInfo.lpszTitle
79908>>>  End
79908>>>>
79908>>>
79908>>>  Put vBIF_RETURNONLYFSDIRS To sBrowseInfo At vtBrowseInfo.ulFlags
79909>>>
79909>>>  // Torben Lund added line below. Move handle of focus object to structure before
79909>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
79909>>>  Put (window_handle(focus(desktop))) To sBrowseInfo At vtBrowseInfo.hWndOwner
79910>>>
79910>>>  GetAddress Of sBrowseInfo To lpsBrowseInfo
79911>>>
79911>>>  // null 128 chars into var (make space)
79911>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
79912>>>  GetAddress Of sFolder To lpsFolder
79913>>>
79913>>>  // select folder
79913>>>  Move (vWin32_SHBrowseForFolder(lpsBrowseInfo)) To lpItemIdList
79914>>>  // get selected folder name
79914>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, lpsFolder)) To iFolderSelected
79915>>>
79915>>>  // release memory resources that are used by the ItemIdList
79915>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
79916>>>
79916>>>  If (iFolderSelected<>0) Function_Return (CString(sFolder))
79919>>>  Else Function_Return ""
79921>>>End_Function // vSHBrowseForFolder
79922>>>
79922>>>
79922>>>// returns 0 if the folder is created.
79922>>>//         1 if the API-call returned an error.
79922>>>Function vCreateDirectory Global String sNewFolder Returns Integer
79924>>>  String  sFolder sSA
79924>>>  Pointer lpsFolder lpsSecurity_Attributes lpDescriptor
79924>>>  Integer iRetval bFolderCreated bInheritHandle
79924>>>
79924>>>  Move (False) To bFolderCreated
79925>>>  // fill string variable with null characters
79925>>>  ZeroType vtSecurity_attributes To sSA
79926>>>
79926>>>  // null MAX_PATH chars into var (make space)
79926>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
79927>>>
79927>>>  If (sNewFolder <> "") Begin
79929>>>
79929>>>    Move dfTrue To  bInheritHandle
79930>>>    // Setting this to NULL is already done by the zerotype command
79930>>>    // Move NULL   To  lpDescriptor
79930>>>    Put (length(sSA))   To sSA At vtSecurity_attributes.nLength
79931>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
79931>>>    Put bInheritHandle To sSA At vtSecurity_attributes.bInheritHandle
79932>>>
79932>>>    GetAddress Of sSA To lpsSecurity_Attributes
79933>>>
79933>>>    //
79933>>>    Move sNewFolder To sFolder
79934>>>    GetAddress Of sFolder To lpsFolder
79935>>>    Move (vWin32_CreateDirectory(lpsFolder, lpsSecurity_Attributes)) To bFolderCreated
79936>>>  End
79936>>>>
79936>>>
79936>>>  Ifnot bFolderCreated Move 1 To iRetVal
79939>>>  Function_Return iRetVal
79940>>>End_Function // vCreateDirectory
79941>>>
79941>>>
79941>>>// **WvA: 03-02-2002 Function created.
79941>>>// With this function one can remove a directory.
79941>>>// returns 0 if the folder is removed.
79941>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
79941>>>//         2 if the folder did not exist
79941>>>//         3 if the sFolder parameter passed is equal to ""
79941>>>Function vRemoveDirectory Global String sFolder Returns Integer
79943>>>  String  sPath
79943>>>  Pointer lpsPath
79943>>>  Integer iRetval bRemoved bExists
79943>>>
79943>>>  Move (False) To bRemoved
79944>>>  Move 0 To iRetVal
79945>>>  Move (Trim(sFolder)) To sFolder
79946>>>  If (sFolder="") Begin
79948>>>    Move 3 To iRetVal
79949>>>  End
79949>>>>
79949>>>  If (vFolderExists(sFolder)=False) Begin
79951>>>    Move 2 To iRetVal
79952>>>  End
79952>>>>
79952>>>  If (iRetVal=0) Begin
79954>>>    // null MAX_PATH chars into var (make space)
79954>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
79955>>>    //
79955>>>    Move (Insert(sFolder,sPath,1)) To sPath
79956>>>    GetAddress Of sPath To lpsPath
79957>>>    Move (vWin32_RemoveDirectory(lpsPath)) To bRemoved
79958>>>  End
79958>>>>
79958>>>
79958>>>  If ((iRetVal=0) And (bRemoved=False)) Begin
79960>>>    Move 1 To iRetVal
79961>>>  End
79961>>>>
79961>>>  Function_Return iRetVal
79962>>>End_Function // vRemoveDirectory
79963>>>
79963>>>
79963>>>
79963>>>// This function informs the user that he entered a yet unknown folder and
79963>>>// asks if he/she wants to create the folder (Yes/No)
79963>>>// Choice: "Yes" - this creates the folder
79963>>>//                 if successful, the function returns false
79963>>>//                 else it will be true.
79963>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
79963>>>//                 For example: to stop a save
79963>>>// Precondition: A foldername must be entered. We do not check for empty paths
79963>>>// This function returns a non-zero value if the folder isn't created afterwards
79963>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
79965>>>  Integer bIsNotValid
79965>>>  Integer iUsers_Choice
79965>>>  String  sMessage
79965>>>
79965>>>  If (vFolderExists(sFolderName) Eq 0) Begin
79967>>>    Move "The folder '" To sMessage
79968>>>    Append sMessage sFolderName
79969>>>    Append sMessage "' does not yet exist,\n"
79970>>>    Append sMessage "Do you want to create it now?"
79971>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
79972>>>    Case Begin
79972>>>      Case (iUsers_Choice = MBR_Yes)
79974>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
79975>>>        If bIsNotValid Begin
79977>>>          Move "An error occurred while trying to create folder '" To sMessage
79978>>>          Append sMessage sFolderName "'.\n\n"
79980>>>          Send Info_Box sMessage "Info"
79981>>>          End
79981>>>>
79981>>>        Case Break
79982>>>      Case (iUsers_Choice = MBR_No)
79985>>>        Move dfTrue To bIsNotValid // Cancel the save
79986>>>        Case Break
79987>>>    Case End
79987>>>  End
79987>>>>
79987>>>  Function_Return bIsNotValid
79988>>>End_Function // vVerifyNewFolder
79989>>>
79989>>>
79989>>>// This will perform an operation on a file (e.g. open) with the application
79989>>>// registered in the Windows Registry to open that type of file (via its extension)
79989>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
79989>>>Procedure vShellExecute global String sOperation String sDocument String sParameters String sPath
79991>>>  Handle  hInstance hWnd
79991>>>  Pointer lpsOperation
79991>>>  Pointer lpsDocument
79991>>>  Pointer lpsParameters
79991>>>  Pointer lpsPath
79991>>>  // remove any leading/trailing spaces in the string
79991>>>  Move (Trim(sDocument)) To sDocument
79992>>>  Move (Trim(sPath))     To sPath
79993>>>  // Make the strings readable for windows API, by converting them to null-terminated
79993>>>  Append sOperation   (Character(0))
79994>>>  Append sDocument    (Character(0))
79995>>>  Append sParameters  (Character(0))
79996>>>  Append sPath        (Character(0))
79997>>>  // Connect the corresponding pointers to the strings
79997>>>  GetAddress Of sOperation  To lpsOperation
79998>>>  GetAddress Of sDocument   To lpsDocument
79999>>>  GetAddress Of sParameters To lpsParameters
80000>>>  GetAddress Of sPath       To lpsPath
80001>>>
80001>>>  Get Window_Handle To hWnd
80002>>>  Move (vWin32_ShellExecute (hWnd, lpsOperation, lpsDocument, lpsParameters, lpsPath, 1)) To hInstance
80003>>>  If (hInstance <= 32) Begin
80005>>>    Send vDDE_Error_Handler hInstance
80006>>>  End
80006>>>>
80006>>>End_Procedure // vShellExecute
80007>>>
80007>>>
80007>>>Class cShellFileOperations Is a Array
80008>>>
80008>>>  Procedure Construct_Object
80010>>>    Forward Send Construct_Object
80012>>>    Property Integer piDeleteFlags        Public 0
80013>>>    Property Integer piCopyFlags          Public 0
80014>>>    Property Integer piMoveFlags          Public 0
80015>>>    Property Integer piRenameFlags        Public 0
80016>>>
80016>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80017>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
80018>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
80019>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
80020>>>  End_Procedure // Construct_Object
80021>>>
80021>>>
80021>>>  // This function uses the shell API to perform a file operation on the
80021>>>  // files supplied.
80021>>>  //
80021>>>  Function FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
80023>>>    String   sShFileOp
80023>>>    Pointer  lpShFileOp
80023>>>    Pointer  lpsSource
80023>>>    Pointer  lpsDestination
80023>>>    Integer  iRetVal
80023>>>    Integer  bUserAbort
80023>>>
80023>>>    ZeroType vtShFileOpStruct To sShFileOp
80024>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
80025>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
80026>>>    GetAddress Of sSource    To lpsSource
80027>>>    If iOperation Ne vFO_DELETE Begin
80029>>>      GetAddress Of sDestination      To lpsDestination
80030>>>      Put lpsDestination To sShFileOp At vtShFileOpStruct.pTo
80031>>>    End
80031>>>>
80031>>>
80031>>>    Put iOperation     To sShFileOp At vtShFileOpStruct.wFunc
80032>>>    Put lpsSource      To sShFileOp At vtShFileOpStruct.pFrom
80033>>>    Put iFlags         To sShFileOp At vtShFileOpStruct.fFlags
80034>>>
80034>>>    GetAddress Of sShFileOp To lpShFileOp
80035>>>
80035>>>    Move (vWin32_SHFileOperation(lpShFileOp)) To iRetVal
80036>>>    GetBuff From sShFileOp At vtShFileOpStruct.fAnyOperationsAborted To bUserAbort
80037>>>    If (bUserAbort <> 0) Begin
80039>>>      Move 80 To iRetVal  // file Operation Aborted by USER
80040>>>    End
80040>>>>
80040>>>    Function_Return (iRetVal)
80041>>>  End_Function // FileOperation
80042>>>
80042>>>
80042>>>  Function sfoDeleteFile String sFileName Returns Integer
80044>>>    Integer  iRetVal
80044>>>    Integer  iFlags
80044>>>
80044>>>    Get piDeleteFlags To iFlags
80045>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
80046>>>    Function_Return iRetVal
80047>>>  End_Function // sfoDeleteFile
80048>>>
80048>>>
80048>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
80050>>>    Integer  iRetVal
80050>>>    Integer  iFlags
80050>>>
80050>>>    Get piCopyFlags To iFlags
80051>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
80052>>>    Function_Return iRetVal
80053>>>  End_Function // sfoCopyFile
80054>>>
80054>>>
80054>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
80056>>>    Integer  iRetVal
80056>>>    Integer  iFlags
80056>>>
80056>>>    Get piMoveFlags To iFlags
80057>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
80058>>>    Function_Return iRetVal
80059>>>  End_Function // sfoMoveFile
80060>>>
80060>>>
80060>>>  // Rename a file or folder
80060>>>  // Returns a nonzero value if the operation failed.
80060>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
80062>>>    Integer  iRetVal
80062>>>    Integer  iFlags
80062>>>
80062>>>    Get piRenameFlags To iFlags
80063>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
80064>>>    Function_Return iRetVal
80065>>>  End_Function // sfoRenameFile
80066>>>
80066>>>  // Courtesy Of Steve Walter
80066>>>  // Requires Windows 2000 and up according to msdn but it was
80066>>>  //  in fact available before that as an unpublished API call
80066>>>  //  a little google search shows that this was already available
80066>>>  //  in windows 95 and NT
80066>>>  //
80066>>>  // The format is controlled by the dialog interface.
80066>>>  // That is, the user must click the OK button To actually Begin the format
80066>>>  // the format cannot be started programmatically.
80066>>>  // An alternative to this functionality would be to use a controlpanel
80066>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
80066>>>  //
80066>>>  // hWnd = The windows handle of the object from which the format Function
80066>>>  //        is called.
80066>>>  // To Get this,
80066>>>  //          use:  Get Window_Handle Of <object>
80066>>>  //          For instance, in this app, we're going to use the Report_Panel:
80066>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
80066>>>  //
80066>>>  // sDrive = The drive letter. At this moment only A and B are valid
80066>>>  //
80066>>>  // iOptions = Format options.
80066>>>  //  SHFMT_OPT_DEFAULT = Quick format
80066>>>  //  SHFMT_OPT_FULL    = Full Format
80066>>>  //  SHFMT_OPT_SYSONLY = System only
80066>>>  //  3                 = Full format with system. (unsupported)
80066>>>  //
80066>>>  // Return Values:
80066>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
80066>>>  //  SHFMT_CANCEL   = Format cancelled by user.
80066>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
80066>>>  //
80066>>>  //
80066>>>  // *** ATTENTION: This function has been disabled as it doesn't
80066>>>  //                seem to work, i must have made a silly mistake
80066>>>  //                somewhere.
80066>>>  //
80066>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
80068>>>    Handle   hWnd
80068>>>    Integer  iObj
80068>>>    DWORD    dwReturnVal
80068>>>    Integer iDrive
80068>>>
80068>>>    Function_Return (1) // STOP HERE
80069>>>
80069>>>    Move (Trim(sDrive)) To sDrive
80070>>>    If ( sDrive <> '' ) Begin
80072>>>      If ( sDrive Contains ':' ) Move (Replace(':',sDrive,'')) To sDrive
80075>>>      If (Not( 'AB' Contains sDrive )) Function_Return (SHFMT_NOFORMAT)
80078>>>      If ( sDrive = 'A' ) Move 0 To iDrive
80081>>>      Else If ( sDrive = 'B' ) Move 1 To iDrive
80085>>>      // Window_Handle Of Desktop equals to 0
80085>>>
80085>>>      Get focus Of desktop To iObj
80086>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
80089>>>      While (hWnd=0 And iObj<>Desktop)
80093>>>          Get Parent Of iObj To iObj
80094>>>          Get Container_Handle Of iObj To hWnd
80095>>>      End
80096>>>>
80096>>>
80096>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
80096>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
80097>>>    End
80097>>>>
80097>>>    Else Begin
80098>>>      Move (SHFMT_ERROR) To dwReturnVal
80099>>>    End
80099>>>>
80099>>>    Function_Return dwReturnVal
80100>>>  End_Function // sfoFormatDisk
80101>>>
80101>>>  //Example:
80101>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
80101>>>  //                                          mode.
80101>>>
80101>>>End_Class // cShellFileOperations
80102>>>
80102>>>
80102>>>Object oShellFileOperations Is a cShellFileOperations
80104>>>End_Object // oShellFileOperations
80105>>>
80105>>>
80105>>>// Restore to the old way of working with the shell file operations.
80105>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
80105>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
80105>>>Procedure vWin32fhCompatibilityMode
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80107>>>  Integer hoSFO
80107>>>  Integer iFlags
80107>>>
80107>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
80108>>>  Move (oShellFileOperations(Self)) To hoSFO
80109>>>
80109>>>  Set piDeleteFlags Of hoSFO To iFlags
80110>>>  Set piCopyFlags   Of hoSFO To iFlags
80111>>>  Set piMoveFlags   Of hoSFO To iFlags
80112>>>  Set piRenameFlags Of hoSFO To iFlags
80113>>>End_Procedure // vWin32fhCompatibilityMode
80114>>>
80114>>>
80114>>>Function vDeleteFile Global String sFileName Returns Integer
80116>>>  Integer  iRetVal
80116>>>
80116>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
80117>>>  Function_Return iRetVal
80118>>>End_Function // vDeleteFile
80119>>>
80119>>>
80119>>>Function vCopyFile Global String sSource String sDestination Returns Integer
80121>>>  Integer  iRetVal
80121>>>
80121>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80122>>>  Function_Return iRetVal
80123>>>End_Function // vCopyFile
80124>>>
80124>>>
80124>>>Function vMoveFile Global String sSource String sDestination Returns Integer
80126>>>  Integer  iRetVal
80126>>>
80126>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80127>>>  Function_Return iRetVal
80128>>>End_Function // vMoveFile
80129>>>
80129>>>
80129>>>// Rename a file or folder
80129>>>// Returns a nonzero value if the operation failed.
80129>>>Function vRenameFile Global String sSource String sDestination Returns Integer
80131>>>  Integer  iRetVal
80131>>>
80131>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
80132>>>  Function_Return iRetVal
80133>>>End_Function // vRenameFile
80134>>>
80134>>>
80134>>>
80134>>>Function vGetWindowsDirectory Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80136>>>  String  sDirectory
80136>>>  Pointer lpDirectory
80136>>>  Integer iVoid
80136>>>
80136>>>  ZeroString vMAX_PATH To sDirectory
80137>>>  GetAddress Of sDirectory To lpDirectory
80138>>>
80138>>>  Move (vWin32_GetWindowsDirectory(lpDirectory, vMAX_PATH)) To iVoid
80139>>>  Function_Return (CString(sDirectory))  // **WvA: Changed to CString()
80140>>>End_Function // vGetWindowsDirectory
80141>>>
80141>>>
80141>>>
80141>>>
80141>>>// Courtesy of Marco Kuipers
80141>>>Function vMakeTempFile Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80143>>>    Integer iRetval
80143>>>    String  sTempPath sTempFileName sPrefixString
80143>>>    Pointer lpTempPath lpTempFileName lpPrefixString
80143>>>
80143>>>    Move (Repeat (Character (0), 255)) To sTempPath
80144>>>    GetAddress Of sTempPath To lpTempPath
80145>>>    Move (vWin32_GetTempPath (255, lpTempPath)) To iRetVal
80146>>>
80146>>>    If (sTempPath = "") Begin
80148>>>       Get_Current_Directory To sTempPath
80149>>>    End
80149>>>>
80149>>>    Move (pad(sTempPath,vMax_Path-14)) To sTempPath // *WvA: 28-04-2005 Quote from msdn: The string cannot be longer than MAX_PATH-14 characters.
80150>>>    Move (Repeat (Character (0), 255)) To sTempFileName
80151>>>    GetAddress Of sTempFileName To lpTempFileName
80152>>>    Move ("tmp"+character(0)) To sPrefixString // **WvA: 28-04-2005 Added a null
80153>>>    GetAddress Of sPrefixString To lpPrefixString
80154>>>    GetAddress Of sTempPath To lpTempPath
80155>>>    Move (vWin32_GetTempFileName (lpTempPath, lpPrefixString, 0, lpTempFileName)) To iRetval
80156>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
80158>>>        Move "" To sTempFileName
80159>>>    End
80159>>>>
80159>>>
80159>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
80160>>>End_Function // vMakeTempFile
80161>>>
80161>>>
80161>>>// This function creates a uniquely named temporary file in folder sPath
80161>>>// The file created will have a prefix based on the first 3 characters in sPrefix
80161>>>// Note that you will have to cleanup the tempfile yourself as the function
80161>>>// does not take care of that.
80161>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80163>>>    String sTempFileName
80163>>>    Integer iCnt iRetVal
80163>>>    Pointer lpTempFileName
80163>>>    Pointer lpPath
80163>>>    Pointer lpPrefix
80163>>>
80163>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
80164>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
80165>>>    Move (pad("", vMAX_PATH)) To sTempFileName
80166>>>    GetAddress Of sTempFileName To lpTempFileName
80167>>>    GetAddress Of sPath         To lpPath
80168>>>    GetAddress Of sPrefix       To lpPrefix
80169>>>
80169>>>    Move (vWin32_GetTempFileName(lpPath, lpPrefix, 0, lpTempFileName)) To iRetVal
80170>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
80171>>>    Function_Return sTempFileName
80172>>>End_Function // vCreateTempFileInPath
80173>>>
80173>>>//
80173>>>// Get a specific shell folder for example to get the desktop folder
80173>>>// simply call this function and pass it vCSIDL_DESKTOP
80173>>>//
80173>>>Function vSHGetFolderPath Integer eFolder Returns String
#REM AMBIGUOUS METHODS ON .DESKTOP. ARE .NOT. RECOMMENDED (OBSOLETE TECHNIQUE)
80175>>>  String  sFolder
80175>>>  Integer iVoid
80175>>>  Pointer lpsFolder
80175>>>  Handle  hWnd
80175>>>  Move (Window_Handle(focus(desktop))) To hWnd
80176>>>
80176>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
80177>>>  GetAddress Of sFolder To lpsFolder
80178>>>
80178>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,lpsFolder)) To iVoid
80179>>>  Function_Return (CString(sFolder))
80180>>>End_Function // vSHGetFolderPath
80181>>>
80181>>>
80181>>>
80181>>>// Courtesy Of Vincent Oorsprong
80181>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
80183>>>  String  sftTime sSystemTime sFormattedTime sFormattedDate
80183>>>  Pointer lpsftTime lpsSystemTime lpsFormattedTime lpsFormattedDate
80183>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
80183>>>
80183>>>  ZeroType vFileTime  To sftTime
80184>>>  Put dwLowDateTime  To sftTime At vFileTime.dwLowDateTime
80185>>>  Put dwHighDateTime To sftTime At vFileTime.dwHighDateTime
80186>>>  GetAddress Of sftTime To lpsftTime
80187>>>
80187>>>  ZeroType vSystemTime To sSystemTime
80188>>>  GetAddress Of sSystemTime To lpsSystemTime
80189>>>
80189>>>  Moveint (vWin32_FileTimeToSystemTime (lpsftTime, lpsSystemTime)) To iSuccess
80190>>>>
80190>>>  If iSuccess Eq DfTrue Begin
80192>>>    ZeroString 255 To sFormattedTime
80193>>>    GetAddress Of sFormattedTime To lpsFormattedTime
80194>>>    Length sFormattedTime To iLenCcTime
80195>>>>
80195>>>    Moveint (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedTime, iLenCcTime)) To iDataLength
80196>>>>
80196>>>    ZeroString 255 To sFormattedDate
80197>>>    GetAddress Of sFormattedDate To lpsFormattedDate
80198>>>    Length sFormattedDate To iLenCcDate
80199>>>>
80199>>>    Moveint (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedDate, iLenCcDate)) To iDataLength
80200>>>>
80200>>>    Function_Return (Cstring (sFormattedDate)  * Cstring (sFormattedTime))
80201>>>  End // iSuccess
80201>>>>
80201>>>End_Function // vConvertFileDateTime
80202>>>
80202>>>
80202>>>// **WvA Removed, See the cFileSet class for an alternative
80202>>>//Procedure DoBrowseDir String sFilePath
80202>>>//End_Procedure // DoBrowseDir
80202>>>
80202>>>// **WvA:
80202>>>// A windows replacement for the standard function FileExists.
80202>>>// This version will also return (true) for a file when it is open by an application.
80202>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
80202>>>// Example: Get vFilePathExists "C:\config.sy?"
80202>>>// This will return true if you have a file matching these conditions. (aka config.sys)
80202>>>Function vFilePathExists Global String sFilePathMask Returns Integer
80204>>>  String  sWin32FindData
80204>>>  String  sDirSep
80204>>>  Pointer lpsFilePathMask lpsWin32FindData
80204>>>  Handle  hFindFile
80204>>>  Integer iVoid
80204>>>
80204>>>  Move vINVALID_HANDLE_VALUE To hFindFile
80205>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
80206>>>
80206>>>  If (length(sFilePathMask)>0) Begin
80208>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
80208>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80209>>>    While (Right(sFilePathMask, 1) = sDirSep)
80213>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
80214>>>    Loop
80215>>>>
80215>>>
80215>>>    GetAddress Of sFilePathMask To lpsFilePathMask
80216>>>    ZeroType vWin32_Find_Data To sWin32FindData
80217>>>    GetAddress Of sWin32FindData To lpswin32FindData
80218>>>    Move (vWin32_FindFirstFile (lpsFilePathMask, lpsWin32FindData)) To hFindFile
80219>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
80220>>>  End
80220>>>>
80220>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
80221>>>End_Function // vFilePathExists
80222>>>
80222>>>
80222>>>// **WvA
80222>>>// Formats a foldername by first trimming it and after that by sticking a
80222>>>// directory separator (/\) to the end if it doesn't have one there already.
80222>>>// The folder may contain a drive letter or UNC encoding.
80222>>>Function vFolderFormat Global String sFolderName Returns String
80224>>>  String sDirSep
80224>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
80225>>>  Move (Trim(sFolderName)) To sFolderName
80226>>>  If (Right(sFolderName,1)<>sDirSep) Begin
80228>>>    Move (sFolderName+sDirSep) To sFolderName
80229>>>  End
80229>>>>
80229>>>  Function_Return sFolderName
80230>>>End_Function // vFolderFormat
80231>>>//
80231>>>// Returns the amount of files in the folder (if it exists)
80231>>>// Returns -1 if folder doesn't exist.
80231>>>// The files "." and ".." are not counted.
80231>>>//
80231>>>Function vFolderFileCount Global String sFolderName Returns Integer
80233>>>  Boolean bFound
80233>>>  Handle  hFindFile
80233>>>  Integer iCount  iVoid
80233>>>  Integer iSuccess
80233>>>  Pointer lpsFolderName lpsWin32FindData
80233>>>  String  sWin32FindData
80233>>>  String  sFileName
80233>>>
80233>>>  Move -1 To iCount
80234>>>  Get vFolderFormat sFolderName To sFolderName
80235>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
80236>>>  GetAddress Of sFolderName To lpsFolderName
80237>>>  ZeroType vWin32_Find_Data To sWin32FindData
80238>>>  GetAddress Of sWin32FindData To lpswin32FindData
80239>>>  Move (vWin32_FindFirstFile (lpsFolderName, lpsWin32FindData)) To hFindFile
80240>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
80241>>>  If (bFound) Move 0 To iCount
80244>>>  While (bFound)
80248>>>    Increment iCount
80249>>>    GetBuff_String From sWin32FindData At vWin32_Find_Data.cFileName To sFileName
80250>>>    If (sFileName="." or sFileName="..") Decrement iCount
80253>>>    Move (vWin32_FindNextFile(hFindFile, lpsWin32FindData)) To iSuccess
80254>>>    Move (iSuccess<>0) To bFound
80255>>>  Loop
80256>>>>
80256>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
80257>>>  Function_Return iCount
80258>>>End_Function // vFolderFileCount
80259>>>
80259>>>
80259>>>//
80259>>>// Gets the parent path of the currently supplied path
80259>>>// Returns "" when we are at the root folder.
80259>>>//
80259>>>Function vParentPath Global String sPath Returns String
80261>>>  String sStrip
80261>>>  Integer iLength
80261>>>  
80261>>>  If (Right(sPath,1)="\") Begin
80263>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
80264>>>  End
80264>>>>
80264>>>  If (Pos("\",sPath)) Begin
80266>>>    Move (StringFromRightOfChar(sPath,"\")) to sStrip
80267>>>    Move (Length(sStrip)) to iLength
80268>>>    Move (Left(sPath, (Length(sPath) - iLength -1))) to sPath
80269>>>//    Move (Replace(sStrip,sPath,"")) To sPath
80269>>>  End
80269>>>>
80269>>>  Else Begin
80270>>>    Move "" To sPath
80271>>>  End
80271>>>>
80271>>>  Function_Return sPath
80272>>>End_Function // vParentPath
80273>>>
80273>>>// Create the folder, including intermediate directories.
80273>>>// Don't panic if the folder already exists.
80273>>>// Michael Mullan June 2009.
80273>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
80275>>>  String  sFolder sSA
80275>>>  Pointer lpsFolder lpsSecurity_Attributes
80275>>>  Integer iRetval bFolderCreated bInheritHandle
80275>>>  Move (False) to bFolderCreated
80276>>>  // fill string variable with null characters
80276>>>  ZeroType vtSecurity_attributes to sSA
80277>>>  // null MAX_PATH chars into var (make space)
80277>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
80278>>>  If (sNewFolder <> "") Begin
80280>>>    Move dfTrue to  bInheritHandle
80281>>>    // Setting this to NULL is already done by the zerotype command
80281>>>    // Move NULL   To  lpDescriptor
80281>>>    Put (length(sSA))   to sSA At vtSecurity_attributes.nLength
80282>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
80282>>>    Put bInheritHandle to sSA At vtSecurity_attributes.bInheritHandle
80283>>>    GetAddress of sSA to lpsSecurity_Attributes
80284>>>    //
80284>>>    Move sNewFolder to sFolder
80285>>>    GetAddress of sFolder to lpsFolder
80286>>>    Move (vWin32_SHCreateDirectoryEx(0,lpsFolder, lpsSecurity_Attributes)) to bFolderCreated
80287>>>  End
80287>>>>
80287>>>
80287>>>  If (bFolderCreated <> 0) Begin
80289>>>    Move 1 to iRetVal
80290>>>
80290>>>    If (bFolderCreated = 161 ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
80293>>>    Else If (bFolderCreated = 206 ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
80297>>>    Else If (bFolderCreated = 3   ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
80301>>>    Else If (bFolderCreated = 80  ) Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
80305>>>    Else If (bFolderCreated = 183 ) Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
80309>>>    Else If (bFolderCreated = 1223) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
80313>>>    Else Error DFERR_OPERATOR ("Folder Creation Error # " + String(bfoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
80315>>>  End
80315>>>>
80315>>>  Function_Return iRetVal
80316>>>End_Function // vshCreateDirectoryEX
80317>>>
80317>>>
80317>>>Function vWin32_APIFileSize Global string sFileName returns integer
80319>>>     dWord dwFileSizeHigh dwFileSizeLow
80319>>>     integer iFileSize iVoid
80319>>>     handle hFindFile
80319>>>     pointer lpsFilePath lpsWin32FindData
80319>>>     string sWin32FindData
80319>>>
80319>>>     GetAddress of sFileName to lpsFilePath
80320>>>
80320>>>     ZeroType vWin32_Find_Data to sWin32FindData
80321>>>     GetAddress of sWin32FindData to lpsWin32FindData
80322>>>
80322>>>     move (vWin32_FindFirstFile (lpsFilePath, lpsWin32FindData)) to hFindFile
80323>>>     if (hFindFile<>vINVALID_HANDLE_VALUE) begin
80325>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeHigh To dwFileSizeHigh
80326>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeLow To dwFileSizeLow
80327>>>     end
80327>>>>
80327>>>     move (vWin32_FindClose (hFindFile)) to iVoid
80328>>>
80328>>>     moveInt ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
80329>>>>
80329>>>
80329>>>     function_return iFileSize
80330>>>End_Function  // vWin32_APIFileSize
80331>>>
80331>>>
80331>
80331>Object oHtmlHelp is a cHtmlHelp
80333>End_Object
80334>
80334>Object oApplication is a cApplication
80336>    Set peHelpType to htHtmlHelp
80337>    Set psCompany to "RDC Tools International"
80338>    Set psProduct to "Create DbVersion Table"
80339>    Set psHelpFile to "DataFlex.chm"
80340>    Set psAutoOpenWorkspace to ""
80341>
80341>    Property String psFilelistName
80343>    Property String psOpenPath
80345>
80345>    Procedure OnCreate
80348>        Handle ho hoIni
80348>        String sSWSFile sWSFile sOpenPath sPath sHomeFolder sDdSrcPath sDataPath sFilelistname
80348>        Integer eOpened iPos
80348>        Boolean bExists
80348>
80348>        Get phoCommandLine to ho
80349>        Get Argument of ho 1 to sSWSFile
80350>
80350>        // Was the program started with a parameter on the command line from e.g. the Studio?
80350>        If (sSWSFile <> "") Begin
80352>            Get Create (RefClass(cIniFile)) to hoIni
80353>            Set psFileName of hoIni to sSWSFile
80354>            Get ParseFolderName sSWSFile to sPath
80355>
80355>            // Read .ws file path from the .sws file:
80355>            Get ReadString of hoIni "WorkspacePaths" "ConfigFile" "" to sWSFile
80356>            Move (Pos(".\", sWSFile)) to iPos
80357>            If (iPos <> 0) Begin
80359>                Move (Replace(".\", sWSFile, "")) to sWSFile
80360>            End
80360>            Send Destroy of hoIni
80361>            Move (sPath + sWSFile) to sWSFile
80362>            Get vFilePathExists sWSFile to bExists
80363>            If (bExists = True) Begin
80365>                Get OpenWorkspaceFile of (phoWorkspace(Self)) sWSFile to eOpened
80366>                If (eOpened = wsWorkspaceOpened) Begin
80368>                    Set psFilelistName to (psFileList(phoWorkspace(Self)))
80369>                    Procedure_Return // Workspace opened; We're done!
80370>                End
80370>            End
80370>        End
80370>
80370>        Get_Attribute DF_OPEN_PATH to sOpenPath
80373>        Set psOpenPath to sOpenPath
80374>
80374>        // Check if there is a config.ws file in the Programs folder:
80374>        Get OpenWorkspaceFile of (phoWorkspace(Self)) "config.ws" to eOpened
80375>        If (eOpened = wsWorkspaceOpened) Begin
80377>            Get psFileList of (phoWorkspace(Self)) to sFileListName
80378>            Set psFilelistName to sFileListName
80379>            Procedure_Return         // Workspace opened; We're done!
80380>        End
80380>
80380>        // If no config.ws was not found; let user select a .ws file
80380>        Get GetApplicationPath to sPath
80381>        Get vSelect_File "Workspace Files (*.ws)|*.ws|All Files (*.*)|*.*" "Please select a Workspace file (*.ws)" sPath to sWsFile
80382>        Get vFilePathExists sWsFile to bExists
80383>        If (bExists = False) Begin
80385>            Send Stop_Box "No Workspace file selected. Cannot continue!"
80386>            Send Exit_Application
80387>        End
80387>        Get OpenWorkspaceFile of (phoWorkspace(Self)) sWsFile to eOpened
80388>        If (eOpened = wsWorkspaceOpened) Begin
80390>            Get psFileList of (phoWorkspace(Self)) to sFileListName
80391>            Set psFilelistName to sFileListName
80392>            Procedure_Return
80393>        End
80393>        Else Begin
80394>            Send Stop_Box "Could not open the Workspace. Cannot continue!"
80395>            Send Exit_Application
80396>        End
80396>
80396>    End_Procedure
80397>
80397>End_Object
80398>
80398>//Use cCJSkinFramework.pkg
80398>//Object oCJSkinFramework is a cCJSkinFramework
80398>//    Set psSkinFile to "Mac_OSX_Leopard.cjstyles"
80398>//    Set psSkinIni to "NormalLeopard.ini"
80398>//End_Object
80398>
80398>Use cToolTipController.pkg
80398>Object oToolTipController is a cToolTipController
80400>    Move Self to ghoToolTipController
80401>    Set pbBalloonStyle to False
80402>    Set piIcon to TTI_INFO
80403>    Set psTitle to "Information"
80404>    Set piMaxWidth to 400
80405>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
80406>End_Object
80407>
80407>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
80407>>>//****************************************************************************
80407>>>// $Module type: Class
80407>>>// $Module name: cDbUpdateFunctionLibrary
80407>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
80407>>>// Web-site    : http://www.rdctools.com
80407>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
80407>>>//
80407>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
80407>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
80407>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
80407>>>//               with the help of Sql-scripts.
80407>>>//
80407>>>// $Rev History:
80407>>>//    2014-09-05  Module header created
80407>>>//
80407>>>//****************************************************************************
80407>>>Use cApplication.pkg
80407>>>Use seq_chnl.pkg
80407>>>Use GlobalFunctionsProcedures.pkg
80407>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
80407>>>Use StatusPanel.pkg
Including file: StatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StatusPanel.pkg)
80407>>>>>// StatPnl.pkg - creates the standard status_panel object.
80407>>>>>//
80407>>>>>//
80407>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
80407>>>>>// invoke the standard status panel. The standard has always been that the package name
80407>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
80407>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
80407>>>>>// prior revisions has been replace with status panel that is part of the application.
80407>>>>>// This should work much better and faster than the old sentinel based solution.
80407>>>>>// While the way this operates has changed, the interface has not and therefore this should work
80407>>>>>// with most applications.
80407>>>>>//
80407>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
80407>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
80407>>>>>// a cleaner more robust interface.
80407>>>>>//
80407>>>>>//
80407>>>>>// Compatibility Note:
80407>>>>>//
80407>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
80407>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
80407>>>>>//
80407>>>>>// If for some reason you application will not work using this as a replacement for the old status
80407>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
80407>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
80407>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
80407>>>>>//
80407>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
80407>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
80407>>>>>//
80407>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
80407>>>>>// can still access the new object via the ghoStatusPanel handle.
80407>>>>>//
80407>>>>>//
80407>>>>>// Creating your own Status Panel objects
80407>>>>>//
80407>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
80407>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
80407>>>>>// with a different file and object name and direct your status panel request to the new object.
80407>>>>>//
80407>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
80407>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
80407>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
80407>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
80407>>>>>// e.g.
80407>>>>>//       Procedure UpdateStatusBar
80407>>>>>//           Send DoAdvance of oProgressBar
80407>>>>>//           Send ProcessEvents
80407>>>>>//       End_Procedure
80407>>>>>//
80407>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
80407>>>>>// messages this will be done for you.
80407>>>>>//
80407>>>>>// the standard Interface for status panels are:
80407>>>>>//
80407>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
80407>>>>>// Send Start_StatusPanel      - start the status panel
80407>>>>>// Send Stop_StatusPanel       - stop the status panel
80407>>>>>// Send Update_StatusPanel     - update the status panel's action area
80407>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
80407>>>>>//
80407>>>>>// Get/Set Caption_Text - updates the caption bar
80407>>>>>// Get/Set Title_Text   - updates the title area
80407>>>>>// Get/Set Message_Text - updates the Message area
80407>>>>>// Get/Set Action_Text  - updates the action area
80407>>>>>// Get/Set Button_Text  - updates the button area
80407>>>>>//
80407>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
80407>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
80407>>>>>//
80407>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
80407>>>>>Use cProcessStatusPanel.pkg
80407>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJSkinFramework.pkg)
80407>>>>>>>Use windows.pkg
80407>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJComSkinFramework.pkg)
80407>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v17.3.0\Bin\Codejock.SkinFramework.v17.3.0.ocx
80407>>>>>>>>>Use FlexCom20.pkg
80407>>>>>>>>>
80407>>>>>>>>>// Changes to Imported package
80407>>>>>>>>>//     OLEXTPxx to XTPxx
80407>>>>>>>>>//     OLExtpxx to xtpxx
80407>>>>>>>>>//     OLESkinFramework to SkinFramework
80407>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
80407>>>>>>>>>//     cCom classes to cCJ
80407>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
80407>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
80407>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
80407>>>>>>>>>//     Use statements as noted below (classes moved to these files)
80407>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
80407>>>>>>>>>
80407>>>>>>>>>// These have been extracted from this class and moved into seperate packages
80407>>>>>>>>>// because other Codejock classes use these.
80407>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
80407>>>>>>>>>
80407>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
80407>>>>>>>>>    Define xtpSkinApplyMetrics for 1
80407>>>>>>>>>    Define xtpSkinApplyFrame for 2
80407>>>>>>>>>    Define xtpSkinApplyColors for 4
80407>>>>>>>>>    Define xtpSkinApplyMenus for 8
80407>>>>>>>>>
80407>>>>>>>>>// CLSID: {AFA0E6A1-28D7-4F2C-87A7-7266367B4655}
80407>>>>>>>>>// Dispatch interface for SkinFramework Control
80407>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
80408>>>>>>>>>
80408>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
80410>>>>>>>>>        SkinFrameworkApplyOptions retVal
80410>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
80411>>>>>>>>>        Function_Return retVal
80412>>>>>>>>>    End_Function
80413>>>>>>>>>
80413>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
80415>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
80416>>>>>>>>>    End_Procedure
80417>>>>>>>>>
80417>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
80419>>>>>>>>>        Boolean retVal
80419>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
80420>>>>>>>>>        Function_Return retVal
80421>>>>>>>>>    End_Function
80422>>>>>>>>>
80422>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
80424>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
80425>>>>>>>>>    End_Procedure
80426>>>>>>>>>
80426>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
80428>>>>>>>>>        Boolean retVal
80428>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
80429>>>>>>>>>        Function_Return retVal
80430>>>>>>>>>    End_Function
80431>>>>>>>>>
80431>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
80433>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
80434>>>>>>>>>    End_Procedure
80435>>>>>>>>>
80435>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
80437>>>>>>>>>        Handle hDispatchDriver
80437>>>>>>>>>        Boolean retVal
80437>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80438>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80439>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
80440>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
80441>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
80442>>>>>>>>>        Function_Return retVal
80443>>>>>>>>>    End_Function
80444>>>>>>>>>
80444>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
80446>>>>>>>>>        Handle hDispatchDriver
80446>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80447>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80448>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80449>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
80450>>>>>>>>>    End_Procedure
80451>>>>>>>>>
80451>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
80453>>>>>>>>>        Handle hDispatchDriver
80453>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80454>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80455>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80456>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
80457>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
80458>>>>>>>>>    End_Procedure
80459>>>>>>>>>
80459>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
80461>>>>>>>>>        Handle hDispatchDriver
80461>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80462>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80463>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80464>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
80465>>>>>>>>>    End_Procedure
80466>>>>>>>>>
80466>>>>>>>>>    Procedure ComRemoveAllWindows
80468>>>>>>>>>        Handle hDispatchDriver
80468>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80469>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
80470>>>>>>>>>    End_Procedure
80471>>>>>>>>>
80471>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
80473>>>>>>>>>        Handle hDispatchDriver
80473>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80474>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80475>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
80476>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
80477>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
80478>>>>>>>>>    End_Procedure
80479>>>>>>>>>
80479>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
80481>>>>>>>>>        Handle hDispatchDriver
80481>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80482>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80483>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
80484>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
80485>>>>>>>>>    End_Procedure
80486>>>>>>>>>
80486>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
80488>>>>>>>>>        Handle hDispatchDriver
80488>>>>>>>>>        Variant retVal
80488>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80489>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80490>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
80491>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
80492>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
80493>>>>>>>>>        Function_Return retVal
80494>>>>>>>>>    End_Function
80495>>>>>>>>>
80495>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
80497>>>>>>>>>        Handle hDispatchDriver
80497>>>>>>>>>        Variant retVal
80497>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80498>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80499>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
80500>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
80501>>>>>>>>>        Function_Return retVal
80502>>>>>>>>>    End_Function
80503>>>>>>>>>
80503>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
80505>>>>>>>>>        Handle hDispatchDriver
80505>>>>>>>>>        OLE_COLOR retVal
80505>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80506>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80507>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80508>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
80509>>>>>>>>>        Function_Return retVal
80510>>>>>>>>>    End_Function
80511>>>>>>>>>
80511>>>>>>>>>    Procedure ComExcludeModule String llModuleName
80513>>>>>>>>>        Handle hDispatchDriver
80513>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80514>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80515>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
80516>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
80517>>>>>>>>>    End_Procedure
80518>>>>>>>>>
80518>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
80520>>>>>>>>>        Handle hDispatchDriver
80520>>>>>>>>>        Variant retVal
80520>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80521>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80522>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
80523>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
80524>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
80525>>>>>>>>>        Function_Return retVal
80526>>>>>>>>>    End_Function
80527>>>>>>>>>
80527>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
80529>>>>>>>>>        Handle hDispatchDriver
80529>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80530>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
80531>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
80532>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
80533>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
80534>>>>>>>>>    End_Procedure
80535>>>>>>>>>
80535>>>>>>>>>    Procedure ComAboutBox
80537>>>>>>>>>        Handle hDispatchDriver
80537>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80538>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
80539>>>>>>>>>    End_Procedure
80540>>>>>>>>>End_Class
80541>>>>>>>>>
80541>>>>>>>>>// CLSID: {40217CB8-4463-4030-B324-AC6A8075FEC8}
80541>>>>>>>>>// Event interface for SkinFramework Control
80541>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
80542>>>>>>>>>
80542>>>>>>>>>    Procedure RegisterComEvents
80544>>>>>>>>>    End_Procedure
80545>>>>>>>>>End_Class
80546>>>>>>>>>
80546>>>>>>>>>// CoClass
80546>>>>>>>>>// ProgID: Codejock.SkinFramework.17.3.0
80546>>>>>>>>>// CLSID: {DE67160B-9A3E-4EA6-846E-8C9A72F9F203}
80546>>>>>>>>>// SkinFramework Control
80546>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
80547>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
80548>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
80549>>>>>>>>>
80549>>>>>>>>>    Procedure Construct_Object
80551>>>>>>>>>        Forward Send Construct_Object
80553>>>>>>>>>        Set psProgID to "{DE67160B-9A3E-4EA6-846E-8C9A72F9F203}"
80554>>>>>>>>>        Set psEventId to "{40217CB8-4463-4030-B324-AC6A8075FEC8}"
80555>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2016 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v17.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
80556>>>>>>>>>        Set peAutoCreate to acAutoCreate
80557>>>>>>>>>    End_Procedure
80558>>>>>>>>>End_Class
80559>>>>>>>>>
80559>>>>>>>>>// CLSID: {06E8A85B-70E4-4F71-A0FC-D1D5658C7E17}
80559>>>>>>>>>// SkinFramework Global Settings
80559>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
80560>>>>>>>>>
80560>>>>>>>>>    Function ComLicense Returns String
80562>>>>>>>>>        String retVal
80562>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
80563>>>>>>>>>        Function_Return retVal
80564>>>>>>>>>    End_Function
80565>>>>>>>>>
80565>>>>>>>>>    Procedure Set ComLicense String value
80567>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
80568>>>>>>>>>    End_Procedure
80569>>>>>>>>>
80569>>>>>>>>>    Function ComTitle Returns String
80571>>>>>>>>>        String retVal
80571>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
80572>>>>>>>>>        Function_Return retVal
80573>>>>>>>>>    End_Function
80574>>>>>>>>>
80574>>>>>>>>>    Procedure Set ComTitle String value
80576>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
80577>>>>>>>>>    End_Procedure
80578>>>>>>>>>
80578>>>>>>>>>    Function ComVersion Returns String
80580>>>>>>>>>        Handle hDispatchDriver
80580>>>>>>>>>        String retVal
80580>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80581>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
80582>>>>>>>>>        Function_Return retVal
80583>>>>>>>>>    End_Function
80584>>>>>>>>>
80584>>>>>>>>>    Function ComUnicode Returns Boolean
80586>>>>>>>>>        Handle hDispatchDriver
80586>>>>>>>>>        Boolean retVal
80586>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80587>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
80588>>>>>>>>>        Function_Return retVal
80589>>>>>>>>>    End_Function
80590>>>>>>>>>
80590>>>>>>>>>    Function ComOcxPath Returns String
80592>>>>>>>>>        Handle hDispatchDriver
80592>>>>>>>>>        String retVal
80592>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80593>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
80594>>>>>>>>>        Function_Return retVal
80595>>>>>>>>>    End_Function
80596>>>>>>>>>End_Class
80597>>>>>>>>>
80597>>>>>>>>>// CoClass
80597>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.17.3.0
80597>>>>>>>>>// CLSID: {C4136A4A-67FD-4FC1-BA62-A715B4D60808}
80597>>>>>>>>>// SkinFramework Global Settings
80597>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
80598>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
80599>>>>>>>>>
80599>>>>>>>>>    Procedure Construct_Object
80601>>>>>>>>>        Forward Send Construct_Object
80603>>>>>>>>>        Set psProgID to "{C4136A4A-67FD-4FC1-BA62-A715B4D60808}"
80604>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
80605>>>>>>>>>    End_Procedure
80606>>>>>>>>>End_Class
80607>>>>>>>>>
80607>>>>>>>>>// CLSID: {27E4AC9B-4A2D-4FBB-A782-BD76BEFA4345}
80607>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
80608>>>>>>>>>
80608>>>>>>>>>    Function ComColorScheme Returns String
80610>>>>>>>>>        String retVal
80610>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80611>>>>>>>>>        Function_Return retVal
80612>>>>>>>>>    End_Function
80613>>>>>>>>>
80613>>>>>>>>>    Procedure Set ComColorScheme String value
80615>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80616>>>>>>>>>    End_Procedure
80617>>>>>>>>>
80617>>>>>>>>>    Function ComFontSize Returns String
80619>>>>>>>>>        String retVal
80619>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80620>>>>>>>>>        Function_Return retVal
80621>>>>>>>>>    End_Function
80622>>>>>>>>>
80622>>>>>>>>>    Procedure Set ComFontSize String value
80624>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80625>>>>>>>>>    End_Procedure
80626>>>>>>>>>
80626>>>>>>>>>    Function ComIniFileName Returns String
80628>>>>>>>>>        String retVal
80628>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
80629>>>>>>>>>        Function_Return retVal
80630>>>>>>>>>    End_Function
80631>>>>>>>>>
80631>>>>>>>>>    Procedure Set ComIniFileName String value
80633>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
80634>>>>>>>>>    End_Procedure
80635>>>>>>>>>End_Class
80636>>>>>>>>>
80636>>>>>>>>>// CLSID: {5005F22B-A30E-4B12-B142-E97F62A927A6}
80636>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
80637>>>>>>>>>
80637>>>>>>>>>    Function ComName Returns String
80639>>>>>>>>>        String retVal
80639>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
80640>>>>>>>>>        Function_Return retVal
80641>>>>>>>>>    End_Function
80642>>>>>>>>>
80642>>>>>>>>>    Procedure Set ComName String value
80644>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
80645>>>>>>>>>    End_Procedure
80646>>>>>>>>>
80646>>>>>>>>>    Function ComPath Returns String
80648>>>>>>>>>        String retVal
80648>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
80649>>>>>>>>>        Function_Return retVal
80650>>>>>>>>>    End_Function
80651>>>>>>>>>
80651>>>>>>>>>    Procedure Set ComPath String value
80653>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
80654>>>>>>>>>    End_Procedure
80655>>>>>>>>>
80655>>>>>>>>>    Function ComCount Returns Integer
80657>>>>>>>>>        Handle hDispatchDriver
80657>>>>>>>>>        Integer retVal
80657>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80658>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80659>>>>>>>>>        Function_Return retVal
80660>>>>>>>>>    End_Function
80661>>>>>>>>>
80661>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
80663>>>>>>>>>        Handle hDispatchDriver
80663>>>>>>>>>        Variant retVal
80663>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80664>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80665>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80666>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80667>>>>>>>>>        Function_Return retVal
80668>>>>>>>>>    End_Function
80669>>>>>>>>>
80669>>>>>>>>>    Function Com_NewEnum Returns Variant
80671>>>>>>>>>        Handle hDispatchDriver
80671>>>>>>>>>        Variant retVal
80671>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80672>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80673>>>>>>>>>        Function_Return retVal
80674>>>>>>>>>    End_Function
80675>>>>>>>>>End_Class
80676>>>>>>>>>
80676>>>>>>>>>// CLSID: {C4367A33-2A7C-4CC6-BF0C-C50383B34B51}
80676>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
80677>>>>>>>>>
80677>>>>>>>>>    Function ComCount Returns Integer
80679>>>>>>>>>        Handle hDispatchDriver
80679>>>>>>>>>        Integer retVal
80679>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80680>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
80681>>>>>>>>>        Function_Return retVal
80682>>>>>>>>>    End_Function
80683>>>>>>>>>
80683>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
80685>>>>>>>>>        Handle hDispatchDriver
80685>>>>>>>>>        Variant retVal
80685>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80686>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
80687>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
80688>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
80689>>>>>>>>>        Function_Return retVal
80690>>>>>>>>>    End_Function
80691>>>>>>>>>
80691>>>>>>>>>    Function Com_NewEnum Returns Variant
80693>>>>>>>>>        Handle hDispatchDriver
80693>>>>>>>>>        Variant retVal
80693>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
80694>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
80695>>>>>>>>>        Function_Return retVal
80696>>>>>>>>>    End_Function
80697>>>>>>>>>End_Class
80698>>>>>>>>>
80698>>>>>>>>>// CLSID: {128507E0-C56F-43C0-BCF1-8193B35FE4C4}
80698>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
80699>>>>>>>>>End_Class
80700>>>>>>>Use cApplication.pkg
80700>>>>>>>
80700>>>>>>>Struct tSkinInformation
80700>>>>>>>    String sName     // description of the skin
80700>>>>>>>    String sSkinfile // file path. Can be relative or full
80700>>>>>>>    String sSkinIni  // section name
80700>>>>>>>End_Struct
80700>>>>>>>
80700>>>>>>>
80700>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
80701>>>>>>>    
80701>>>>>>>    Procedure Construct_Object
80703>>>>>>>        Forward Send Construct_Object
80705>>>>>>>        
80705>>>>>>>        Property String psSkinFile ""
80706>>>>>>>        Property String psSkinIni ""
80707>>>>>>>        Property Boolean pbLoadPreference False
80708>>>>>>>        
80708>>>>>>>        Set peAutoCreate to acAutoCreate
80709>>>>>>>        
80709>>>>>>>        Move Self to ghoSkinFramework
80710>>>>>>>    End_Procedure
80711>>>>>>>    
80711>>>>>>>    // return the default skin path, which is the programs directory.
80711>>>>>>>    // This requires an application object.
80711>>>>>>>    // If you want to different skin path, override this.
80711>>>>>>>    Function SkinPath Returns String
80713>>>>>>>        String sPath sPaths
80713>>>>>>>        Handle hoWorkspace
80713>>>>>>>        If ghoApplication Begin
80715>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
80716>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
80717>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
80718>>>>>>>        End
80718>>>>>>>>
80718>>>>>>>        Else Begin
80719>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80720>>>>>>>>
80720>>>>>>>        End
80720>>>>>>>>
80720>>>>>>>        Function_Return sPath
80721>>>>>>>    End_Function
80722>>>>>>>    
80722>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
80722>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
80722>>>>>>>    Function SkinQFile Returns String
80724>>>>>>>        String sFile sPath sSep
80724>>>>>>>        Boolean bQualified
80724>>>>>>>        Get psSkinFile to sFile
80725>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
80727>>>>>>>            Get SkinPath to sPath
80728>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80729>>>>>>>            Move (sPath - sSep - sFile) to sFile
80730>>>>>>>        End
80730>>>>>>>>
80730>>>>>>>        Function_Return sFile
80731>>>>>>>    End_Function
80732>>>>>>>        
80732>>>>>>>    // defines the default VDF window class mapping.    
80732>>>>>>>    Procedure OnAddVDFWindowClasses
80734>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
80735>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
80736>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
80737>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
80738>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
80739>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
80740>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
80741>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
80742>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
80743>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
80744>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
80745>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient" 
80746>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
80747>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
80748>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
80749>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
80750>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
80751>>>>>>>        // External class
80751>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
80752>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
80753>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
80754>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
80755>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
80756>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
80757>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
80758>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
80759>>>>>>>    End_Procedure
80760>>>>>>>    
80760>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
80760>>>>>>>    Procedure OnAddCustomWindowClasses
80762>>>>>>>    End_Procedure
80763>>>>>>>
80763>>>>>>>    // called when object is created during end_construct_object.
80763>>>>>>>    Procedure OnCreate
80765>>>>>>>        Integer iOpts
80765>>>>>>>        Boolean bUseWindowsFont
80765>>>>>>>        Forward Send OnCreate
80767>>>>>>>        
80767>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
80767>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
80767>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
80768>>>>>>>        If bUseWindowsFont Begin
80770>>>>>>>            Get ComApplyOptions to iOpts
80771>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
80772>>>>>>>        End
80772>>>>>>>>
80772>>>>>>>
80772>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down. 
80772>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
80772>>>>>>>        // and this was the suggested workaround.
80772>>>>>>>        Set ComAutoApplyNewThreads to False
80773>>>>>>>
80773>>>>>>>        Send OnAddVDFWindowClasses
80774>>>>>>>        Send OnAddCustomWindowClasses
80775>>>>>>>        
80775>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
80775>>>>>>>        If (pbLoadPreference(Self)) Begin
80777>>>>>>>            Send LoadSkinPreference
80778>>>>>>>        End
80778>>>>>>>>
80778>>>>>>>        // if a skin file name exists, we apply the skin.    
80778>>>>>>>        If (psSkinFile(Self)<>"") Begin
80780>>>>>>>            Send ApplySkin
80781>>>>>>>        End        
80781>>>>>>>>
80781>>>>>>>    End_Procedure
80782>>>>>>>    
80782>>>>>>>    // called by framework as part of application exit.
80782>>>>>>>    Procedure Broadcast_Notify_Exit_Application
80784>>>>>>>        Send Notify_Exit_Application
80785>>>>>>>    End_Procedure // Notify_Exit_Application
80786>>>>>>>
80786>>>>>>>    Procedure Notify_Exit_Application
80788>>>>>>>        If (pbLoadPreference(Self)) Begin
80790>>>>>>>            Send SaveSkinPreference
80791>>>>>>>        End
80791>>>>>>>>
80791>>>>>>>    End_Procedure
80792>>>>>>>
80792>>>>>>>    Procedure NotifyPreApplySkin
80794>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True       
80796>>>>>>>    End_Procedure
80797>>>>>>>
80797>>>>>>>    Procedure NotifyPostApplySkin
80799>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True       
80801>>>>>>>    End_Procedure
80802>>>>>>>    
80802>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
80802>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
80802>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
80804>>>>>>>        tSkinInformation[] Skins
80804>>>>>>>        tSkinInformation[] Skins
80805>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
80805>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
80805>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
80805>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
80805>>>>>>>        Integer iPos iDfltLen
80805>>>>>>>        Boolean bUseRelativePath
80805>>>>>>>        
80805>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80806>>>>>>>        
80806>>>>>>>        Get SkinPath to sDefaultPath
80807>>>>>>>        If (sPath="") Begin
80809>>>>>>>            Move sDefaultPath to sPath
80810>>>>>>>        End
80810>>>>>>>>
80810>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
80811>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
80812>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
80813>>>>>>>
80813>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
80814>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
80816>>>>>>>
80816>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
80817>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
80818>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
80819>>>>>>>            
80819>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
80820>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
80821>>>>>>>            
80821>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
80827>>>>>>>>
80827>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
80828>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
80829>>>>>>>
80829>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
80830>>>>>>>                    
80830>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
80836>>>>>>>>
80836>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
80837>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
80838>>>>>>>
80838>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
80839>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
80840>>>>>>>                    If bUseRelativePath Begin
80842>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
80843>>>>>>>                        If iPos Begin
80845>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile   
80846>>>>>>>                            While (Left(sSkinFile,1)=sSep)
80850>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile   
80851>>>>>>>                            Loop                         
80852>>>>>>>>
80852>>>>>>>                        End
80852>>>>>>>>
80852>>>>>>>                    End
80852>>>>>>>>
80852>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
80853>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
80854>>>>>>>
80854>>>>>>>                    Increment iArrayItem
80855>>>>>>>                Loop
80856>>>>>>>>
80856>>>>>>>            Loop
80857>>>>>>>>
80857>>>>>>>                            
80857>>>>>>>            Send Destroy of hSkinDescriptions
80858>>>>>>>            Send Destroy of hSkinDescription
80859>>>>>>>            Send Destroy of hSkinIniFile
80860>>>>>>>                
80860>>>>>>>        End
80860>>>>>>>>
80860>>>>>>>        Function_Return Skins
80861>>>>>>>    End_Function 
80862>>>>>>>    
80862>>>>>>>    // Save the skin preference. This requires an application object.
80862>>>>>>>    // Only do this if the application object allows it. 
80862>>>>>>>    // This is called during startup if pbLoadPreference is True
80862>>>>>>>    // Suitable for override
80862>>>>>>>    Procedure SaveSkinPreference 
80864>>>>>>>        String sSkin sIni
80864>>>>>>>        If ghoApplication Begin
80866>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80868>>>>>>>                Get psSkinFile to sSkin
80869>>>>>>>                Get psSkinIni to sIni
80870>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
80871>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
80872>>>>>>>            End
80872>>>>>>>>
80872>>>>>>>        End
80872>>>>>>>>
80872>>>>>>>        Else Begin
80873>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80874>>>>>>>>
80874>>>>>>>        End
80874>>>>>>>>
80874>>>>>>>    End_Procedure
80875>>>>>>>
80875>>>>>>>    // Load the skin preference. This requires an application object.
80875>>>>>>>    // Only do this if the application object allows it. 
80875>>>>>>>    // This is called during startup if pbLoadPreference is True
80875>>>>>>>    // Suitable for override
80875>>>>>>>    Procedure LoadSkinPreference 
80877>>>>>>>        String sSkin sIni
80877>>>>>>>        Boolean bExists
80877>>>>>>>        If ghoApplication Begin
80879>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80881>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
80882>>>>>>>                If bExists Begin
80884>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
80885>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
80886>>>>>>>                    Set psSkinFile to sSkin
80887>>>>>>>                    Set psSkinIni to sIni
80888>>>>>>>                End
80888>>>>>>>>
80888>>>>>>>            End
80888>>>>>>>>
80888>>>>>>>        End
80888>>>>>>>>
80888>>>>>>>        Else Begin
80889>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80890>>>>>>>>
80890>>>>>>>        End
80890>>>>>>>>
80890>>>>>>>    End_Procedure
80891>>>>>>>
80891>>>>>>>    // Can be called to apply the current skin.
80891>>>>>>>    Procedure ApplySkin
80893>>>>>>>        Boolean bOk
80893>>>>>>>        String sSkin sIni
80893>>>>>>>        If (IsComObjectCreated(Self)) Begin
80895>>>>>>>            Get SkinQFile to sSkin
80896>>>>>>>            Get psSkinIni to sIni
80897>>>>>>>            
80897>>>>>>>            Send NotifyPreApplySkin
80898>>>>>>>            // when skins are used we don't want to use built in Visual Styles
80898>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
80899>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
80900>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
80902>>>>>>>                // if not ok, no skin was appied. Enable visual styles
80902>>>>>>>                Send EnableVisualStyles of Desktop True
80903>>>>>>>            End
80903>>>>>>>>
80903>>>>>>>            Send NotifyPostApplySkin
80904>>>>>>>        End
80904>>>>>>>>
80904>>>>>>>    End_Procedure
80905>>>>>>>
80905>>>>>>>
80905>>>>>>>End_Class
80906>>>>>//Use cAnimation.pkg
80906>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cProgressBar.pkg)
80906>>>>>>>Use Windows.pkg
80906>>>>>>>Use cWinControl.pkg
80906>>>>>>>Use CommCtrl.pkg
80906>>>>>>>
80906>>>>>>>Type tPbRange
80906>>>>>>>    Field tPbRange.iLow  as DWord
80906>>>>>>>    Field tPbRange.iHigh as DWord
80906>>>>>>>End_Type
80906>>>>>>>
80906>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
80906>>>>>>>Class cProgressBar is a cWinControl
80907>>>>>>>
80907>>>>>>>    Procedure Construct_Object
80909>>>>>>>        Forward Send Construct_Object
80911>>>>>>>        Property Integer private_piMinimum
80912>>>>>>>        Property Integer private_piMaximum   100
80913>>>>>>>        Property Integer private_piAdvanceBy 10
80914>>>>>>>        Property Integer private_piPosition
80915>>>>>>>        Property Integer private_pbVertical  False
80916>>>>>>>        Property Integer private_pbSmooth    False
80917>>>>>>>        Property Integer private_piBackColor clDefault
80918>>>>>>>        Property Integer private_piBarColor  clDefault
80919>>>>>>>
80919>>>>>>>        Send Define_ToolTip_Support_Mixin
80920>>>>>>>
80920>>>>>>>        Set External_Class_Name 'cVdfProgressBar' To 'msctls_progress32'
80921>>>>>>>        Set Focus_Mode to NonFocusable
80922>>>>>>>        Set Skip_State to True
80923>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
80924>>>>>>>    End_Procedure
80925>>>>>>>
80925>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
80926>>>>>>>
80926>>>>>>>    Procedure Set piMinimum Integer iMin
80928>>>>>>>        Integer iMax
80928>>>>>>>
80928>>>>>>>        Set private_piMinimum to iMin
80929>>>>>>>        Get private_piMaximum To iMax
80930>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80931>>>>>>>    End_Procedure
80932>>>>>>>    Function piMinimum Returns Integer
80934>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
80937>>>>>>>        Else Function_Return (private_piMinimum(self))
80939>>>>>>>    End_Function
80940>>>>>>>
80940>>>>>>>    Procedure Set piMaximum Integer iMax
80942>>>>>>>        Integer iMin
80942>>>>>>>
80942>>>>>>>        Set private_piMaximum to iMax
80943>>>>>>>        Get private_piMinimum To iMin
80944>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
80945>>>>>>>    End_Procedure
80946>>>>>>>    Function piMaximum Returns Integer
80948>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
80951>>>>>>>        Else Function_Return (private_piMaximum(self))
80953>>>>>>>    End_Function
80954>>>>>>>
80954>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
80956>>>>>>>        Set private_piAdvanceBy To iAdvanceBy
80957>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
80958>>>>>>>    End_Procedure
80959>>>>>>>    Function piAdvanceBy Returns Integer
80961>>>>>>>        Function_Return (private_piAdvanceBy(self))
80962>>>>>>>    End_Function
80963>>>>>>>
80963>>>>>>>    Procedure Set piPosition Integer iPos
80965>>>>>>>        Set private_piPosition To iPos
80966>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
80967>>>>>>>    End_Procedure
80968>>>>>>>
80968>>>>>>>    Function piPosition Returns Integer
80970>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
80973>>>>>>>        Else Function_Return (private_piPosition(self))
80975>>>>>>>    End_Function
80976>>>>>>>
80976>>>>>>>    Procedure Set pbVertical Boolean bVertical
80978>>>>>>>        If (private_pbVertical(self) <> bVertical) Begin
80980>>>>>>>            Set private_pbVertical To bVertical
80981>>>>>>>           Send DoRecreateWindow
80982>>>>>>>        End
80982>>>>>>>>
80982>>>>>>>    End_Procedure
80983>>>>>>>
80983>>>>>>>    Function pbVertical Returns Boolean
80985>>>>>>>        Function_Return (private_pbVertical(self))
80986>>>>>>>    End_Function
80987>>>>>>>
80987>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
80989>>>>>>>        If (private_pbSmooth(self) <> bSmooth) Begin
80991>>>>>>>           Set private_pbSmooth To bSmooth
80992>>>>>>>           Send DoRecreateWindow
80993>>>>>>>        End
80993>>>>>>>>
80993>>>>>>>    End_Procedure
80994>>>>>>>    Function pbSmooth Returns Boolean
80996>>>>>>>        Function_Return (private_pbSmooth(self))
80997>>>>>>>    End_Function
80998>>>>>>>
80998>>>>>>>    Procedure Set piBackColor Integer rgbColor
81000>>>>>>>        Set private_piBackColor To rgbColor
81001>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
81002>>>>>>>    End_Procedure
81003>>>>>>>    Function piBackColor Returns Integer
81005>>>>>>>        Function_Return (private_piBackColor(self))
81006>>>>>>>    End_Function
81007>>>>>>>
81007>>>>>>>    Procedure Set piBarColor Integer rgbColor
81009>>>>>>>        Set private_piBarColor To rgbColor
81010>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
81011>>>>>>>    End_Procedure
81012>>>>>>>    Function piBarColor Returns Integer
81014>>>>>>>        Function_Return (private_piBarColor(self))
81015>>>>>>>    End_Function
81016>>>>>>>
81016>>>>>>>    Procedure DoAdvance
81018>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
81019>>>>>>>    End_procedure
81020>>>>>>>
81020>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
81022>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
81023>>>>>>>    End_procedure
81024>>>>>>>
81024>>>>>>>    Procedure private_DoInitWindow
81026>>>>>>>        Set piBarColor  To (private_piBarColor(self))
81027>>>>>>>        Set piBackColor To (private_piBackColor(self))
81028>>>>>>>        Set piAdvanceBy To (private_piAdvanceBy(self))
81029>>>>>>>        Set piMinimum   To (private_piMinimum(self))
81030>>>>>>>        Set piMaximum   To (private_piMaximum(self))
81031>>>>>>>        Set piPosition  To (private_piPosition(self))
81032>>>>>>>    End_Procedure
81033>>>>>>>
81033>>>>>>>    Procedure Page_Object Integer iState
81035>>>>>>>        Handle hWnd
81035>>>>>>>
81035>>>>>>>        Get Window_Handle To hWnd
81036>>>>>>>        If (hWnd=0 and iState) Begin
81038>>>>>>>            Set Window_Style To PBS_VERTICAL (private_pbVertical(self))
81039>>>>>>>            Set Window_Style To PBS_SMOOTH   (private_pbSmooth(self))
81040>>>>>>>            Forward Send Page_Object True
81042>>>>>>>        End
81042>>>>>>>>
81042>>>>>>>        Else Forward Send Page_Object iState
81045>>>>>>>     
81045>>>>>>>        // Handle tooltip support....
81045>>>>>>>        If (iState = 0) Begin
81047>>>>>>>            Send RequestDeleteToolTip
81048>>>>>>>        End 
81048>>>>>>>>
81048>>>>>>>        Else Begin
81049>>>>>>>            Send RequestAddToolTip
81050>>>>>>>        End
81050>>>>>>>>
81050>>>>>>>    End_Procedure
81051>>>>>>>
81051>>>>>>>    Procedure Page Integer iState
81053>>>>>>>        Forward Send Page iState
81055>>>>>>>        If (iState =1) Send private_DoInitWindow
81058>>>>>>>    End_Procedure
81059>>>>>>>
81059>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
81059>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
81059>>>>>>>    // is implemented in a mixin class.
81059>>>>>>>    Procedure RequestAddToolTip
81061>>>>>>>        Send AddToolTip
81062>>>>>>>    End_Procedure  // RequestAddToolTip
81063>>>>>>>
81063>>>>>>>
81063>>>>>>>    // Called by Page_Object. Handles tooltip removal. 
81063>>>>>>>    Procedure RequestDeleteToolTip
81065>>>>>>>        Send DeleteToolTip
81066>>>>>>>    End_Procedure // RequestDeleteToolTip
81067>>>>>>>End_Class
81068>>>>>
81068>>>>>
81068>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
81068>>>>>
81068>>>>>Object Status_Panel is a cProcessStatusPanel
81070>>>>>    Set Size to 140 222
81071>>>>>    Set Border_Style to Border_Dialog
81072>>>>>//    Set Sysmenu_Icon to False  
81072>>>>>    Set Icon to "DbUpdateFrameworkdf19.ico"
81073>>>>>
81073>>>>>    Property Boolean Cancel_Button_Visible_State True
81075>>>>>
81075>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
81076>>>>>
81076>>>>>//    Object oAnimation is a cAnimation
81076>>>>>//      Set Size to 16 130
81076>>>>>//      Set Location to 5 65
81076>>>>>//      Set pbTransparent       to True
81076>>>>>
81076>>>>>    Procedure Activate
81079>>>>>        Integer iSizeBefore iSizeAfter
81079>>>>>        Get GuiSize to iSizeBefore
81080>>>>>        Forward Send Activate
81082>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))  
81083>>>>>        Set Label of oTitleTxt      to ""
81084>>>>>        Set Label of oTableNameTxt  to ""
81085>>>>>        Set Label of oMessageTxt    to ""
81086>>>>>        Set Label of oActionTxt     to ""
81087>>>>>    End_Procedure
81088>>>>>
81088>>>>>    Object oTitleTxt is a TextBox
81090>>>>>        Set Location to 8 21
81091>>>>>        Set Size to 8 173
81092>>>>>        Set Auto_Size_State to False
81093>>>>>        Set Justification_Mode  to jMode_Center
81094>>>>>        Set Label to "This is the Title Text"
81095>>>>>    End_Object
81096>>>>>
81096>>>>>    Object oTableNameTxt is a TextBox
81098>>>>>        Set Size to 19 173
81099>>>>>        Set Location to 24 21
81100>>>>>        Set Auto_Size_State to False
81101>>>>>        Set Justification_Mode to JMode_Left
81102>>>>>        Set Label to "This is the TableName Text"
81103>>>>>    End_Object
81104>>>>>
81104>>>>>    Object oMessageTxt is a TextBox
81106>>>>>        Set Location to 45 21
81107>>>>>        Set Size to 23 173
81108>>>>>        Set Auto_Size_State to False
81109>>>>>        Set Justification_Mode to JMode_Left
81110>>>>>        Set Label to "This is the Message text"
81111>>>>>    End_Object
81112>>>>>
81112>>>>>    Object oActionTxt is a TextBox
81114>>>>>        Set Size to 13 173
81115>>>>>        Set Location to 71 21
81116>>>>>        Set Auto_Size_State to False
81117>>>>>        Set Justification_Mode to JMode_Left
81118>>>>>        Set Label to "This is the Action Text"
81119>>>>>    End_Object
81120>>>>>
81120>>>>>    Object oPercentage_tb is a TextBox
81122>>>>>        Set Location to 74 196
81123>>>>>        Set Size to 10 25
81124>>>>>//        Set Label to "% Done"
81124>>>>>    End_Object
81125>>>>>
81125>>>>>    Object oProgressBar is a cProgressBar
81127>>>>>        Move Self to ghoProgressBar
81128>>>>>        Set Location to 87 21
81129>>>>>        Set Size to 14 173
81130>>>>>        Set piMinimum        to 0
81131>>>>>        Set piMaximum        to 2000
81132>>>>>        Set piAdvanceBy      to 100
81133>>>>>        Set pbSmooth to True
81134>>>>>
81134>>>>>        // For some weird reason the application skin makes the coloring of the progressbar
81134>>>>>        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
81134>>>>>        // color will show correctly.
81134>>>>>        Procedure Page Integer iPageObject
81137>>>>>            Handle hWin
81137>>>>>            Forward Send Page iPageObject
81139>>>>>            If (ghoSkinFramework <> 0) Begin
81141>>>>>                Get Window_Handle to hWin
81142>>>>>                Send ComRemoveWindow of ghoSkinFramework hWin
81143>>>>>            End
81143>>>>>>
81143>>>>>        End_Procedure
81144>>>>>    End_Object
81145>>>>>
81145>>>>>//    Object oLicense_txt is a TextBox
81145>>>>>//        Set Label to "oLicense_txt"
81145>>>>>//        Set Location to 129 4
81145>>>>>//        Set Size to 10 289
81145>>>>>//        Set FontPointHeight to 8
81145>>>>>//        Set Auto_Size_State    to False
81145>>>>>//        Set Justification_Mode to jMode_Center
81145>>>>>//    End_Object
81145>>>>>
81145>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
81148>>>>>        Set pbVisible of ghoProgressBar to bVisible
81149>>>>>    End_Procedure
81150>>>>>
81150>>>>>    Function Progress_Bar_Visible_State Returns Boolean
81153>>>>>        Boolean bVisible
81153>>>>>        Get pbVisible of ghoProgressBar to bVisible
81154>>>>>        Function_Return (bVisible)
81155>>>>>    End_Function
81156>>>>>
81156>>>>>    Object oCopyRight is a TextBox
81158>>>>>        Set Location to 129 21
81159>>>>>        Set Size to 9 197
81160>>>>>        Set FontPointHeight to 8
81161>>>>>        Set Auto_Size_State to False
81162>>>>>        Set Justification_Mode  to jMode_Center
81163>>>>>        Set Label to "Copyright 2001-2017 RDC Tools International"
81164>>>>>    End_Object
81165>>>>>
81165>>>>>    Object oStopButton is a Button
81167>>>>>        Set Location to 110 82
81168>>>>>        Set Label to C_$Cancel
81169>>>>>
81169>>>>>        Procedure OnClick
81172>>>>>            Send Close_panel
81173>>>>>        End_Procedure
81174>>>>>
81174>>>>>    End_Object
81175>>>>>
81175>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
81175>>>>>    // objects defined within this instance of the status panel.
81175>>>>>
81175>>>>>    // note: all of the messages that change text should be forwarded
81175>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
81175>>>>>
81175>>>>>    Procedure Set Message_Text String sText
81178>>>>>        Set Label of oMessageTxt to sText
81179>>>>>        Forward Set Message_Text to sText
81181>>>>>    End_Procedure
81182>>>>>
81182>>>>>    Function Message_Text Returns String
81185>>>>>        Function_Return (Label(oMessageTxt))
81186>>>>>    End_Function
81187>>>>>
81187>>>>>    Procedure Set Action_Text String sText
81190>>>>>        Set Label of oActionTxt to sText
81191>>>>>        Forward Set Action_Text to sText
81193>>>>>    End_Procedure
81194>>>>>
81194>>>>>    Function Action_Text Returns String
81197>>>>>        Function_Return (Label(oActionTxt))
81198>>>>>    End_Function
81199>>>>>
81199>>>>>    Procedure Set Button_Text String sText
81202>>>>>        Set Label of oStopButton to sText
81203>>>>>        Forward Set Button_Text to sText
81205>>>>>    End_Procedure
81206>>>>>
81206>>>>>    Function Button_Text Returns String
81209>>>>>        Function_Return (Label(oStopButton))
81210>>>>>    End_Function
81211>>>>>
81211>>>>>    Procedure Set Title_Text String sText
81214>>>>>        Set Label of oTitleTxt to sText
81215>>>>>        Forward Set Title_Text to sText
81217>>>>>    End_Procedure
81218>>>>>
81218>>>>>    Function Title_Text Returns String
81221>>>>>        Function_Return (Label(oTitleTxt))
81222>>>>>    End_Function
81223>>>>>
81223>>>>>    Procedure Set TableName_Text String sText
81226>>>>>        Set Label of oTableNameTxt to sText
81227>>>>>    End_Procedure
81228>>>>>
81228>>>>>    Function TableName_Text Returns String
81231>>>>>        Function_Return (Label(oTableNameTxt))
81232>>>>>    End_Function
81233>>>>>
81233>>>>>    Procedure Set License_Text String sText
81236>>>>>//        Set Label of oLicense_txt to sText
81236>>>>>    End_Procedure
81237>>>>>
81237>>>>>    // gets called when status panel is activated passing whether a button
81237>>>>>    // should appear
81237>>>>>    Procedure EnableCancelButton Boolean bEnable
81240>>>>>        Boolean bVisible
81240>>>>>        Get Cancel_Button_Visible_State to bVisible
81241>>>>>        If (bEnable = False) Begin
81243>>>>>            Set Visible_State of oStopButton to bVisible
81244>>>>>        End
81244>>>>>>
81244>>>>>        Set Enabled_State of oStopButton to bEnable
81245>>>>>    End_Procedure
81246>>>>>
81246>>>>>    Procedure Reset_StatusPanel
81249>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
81250>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
81251>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to False
81252>>>>>    End_Procedure
81253>>>>>
81253>>>>>End_Object
81254>>>>>
81254>>>Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
81254>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
81254>>>>>>>//
81254>>>>>>>// *** The Database Update Framework Include file ***
81254>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
81254>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
81254>>>>>>>//
81254>>>>>>>//
81254>>>>>>>Use LanguageText.Pkg
81254>>>>>>>
81254>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
81254>>>>>>>//
81254>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
81254>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
81254>>>>>>>//
81254>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
81254>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
81254>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
81254>>>>>>>//
81254>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
81254>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
81254>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
81254>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
81254>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
81254>>>>>>>//
81254>>>>>>>    Define CS_UpdateVersion     for "Updating database"
81254>>>>>>>    Define CS_UpdateFromVersion for "from version"
81254>>>>>>>    Define CS_UpdateToVersion   for "to version:"
81254>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
81254>>>>>>>//
81254>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
81254>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
81254>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
81254>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
81254>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
81254>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
81254>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
81254>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
81254>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>>>
81254>>>>>
81254>>>>>Register_Function paSQLQueryMessages Returns String[]
81254>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
81254>>>>>
81254>>>>>// Global handle to a cDatabaseUpdateHandler object
81254>>>>>    Global_Variable Handle ghoDbUpdateHandler
81254>>>>>
81254>>>>>    Define DATAFLEX_ID for "DATAFLEX"
81254>>>>>
81254>>>>>    Define CS_OEM_Txt for "OEM"
81254>>>>>
81254>>>>>    Define CS_ANSI_Txt for "ANSI"
81254>>>>>
81254>>>>>    Define CS_DFCONNID for "DFCONNID"
81254>>>>>
81254>>>>>    Define CS_SERVER for "SERVER"
81254>>>>>
81254>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
81254>>>>>
81254>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
81254>>>>>
81254>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
81254>>>>>
81254>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
81254>>>>>
81254>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
81254>>>>>
81254>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
81254>>>>>
81254>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
81254>>>>>
81254>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
81254>>>>>
81254>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
81254>>>>>
81254>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
81254>>>>>
81254>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
81254>>>>>
81254>>>>>
81254>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
81254>>>>>
81254>>>>>Struct tSQLScriptArray
81254>>>>>    Boolean bError
81254>>>>>    Boolean bArgumentSizeChanged
81254>>>>>    Integer iOrgArgumentSize
81254>>>>>    String[] sSQLScriptArray
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tSqlErrorArray
81254>>>>>    String[]  sSqlErrorArray
81254>>>>>    String[]  sSqlStatementArray
81254>>>>>    Integer[] iSqlErrorArray
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tSqlColumnNew
81254>>>>>    String  sBaseColumnName
81254>>>>>    String  sBaseTableName
81254>>>>>    String  sLabel
81254>>>>>    Integer iSqlType
81254>>>>>    Integer iSize
81254>>>>>    Integer iPrecision
81254>>>>>    Integer iDFType
81254>>>>>    Integer iDFNativeType
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tColumnType
81254>>>>>    String  sType
81254>>>>>    Integer iType
81254>>>>>    String  sDataFlexType
81254>>>>>    Integer iDataFlexType
81254>>>>>    String  sPrecision
81254>>>>>    Boolean bFixedSize
81254>>>>>End_Struct
81254>>>>>
81254>>>>>// Used to store/retreive SQL keywords in a struct array.
81254>>>>>// Various SQL back-ends can have slightly different
81254>>>>>// keywords.
81254>>>>>Struct tSQLKeyWords
81254>>>>>    Integer iSQLWord
81254>>>>>    Integer iSQLDbType
81254>>>>>    String  sSQLPhrase // Can be more than one word.
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tSQLRelation
81254>>>>>    Integer iFileNumber
81254>>>>>    Integer iFieldNumber
81254>>>>>    String  sFileName
81254>>>>>    String  sFieldName
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tSQLLoggedInUser
81254>>>>>    String sUser
81254>>>>>    String sProgram
81254>>>>>End_Struct
81254>>>>>
81254>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
81254>>>>>Enumeration_List
81254>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
81254>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
81254>>>>>End_Enumeration_List
81254>>>>>
81254>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
81254>>>>>// They can have slightly different SQL keywords.
81254>>>>>// Note: If a new type is added to the list,
81254>>>>>//       the struct array xxx must be adjusted
81254>>>>>//       so that it is filled with all SQL
81254>>>>>//       keywords for that new type.
81254>>>>>Enum_List
81254>>>>>    Define EN_DbTypeMSSQL
81254>>>>>    Define EN_DbTypeMySQL
81254>>>>>    Define EN_DbTypeOracle
81254>>>>>    Define EN_DbTypeDB2
81254>>>>>    Define EN_DbTypePostgre
81254>>>>>    Define EN_DbTypeDataFlex // Embedded database.
81254>>>>>End_Enum_List
81254>>>>>
81254>>>>>// We need to have our "own" constants for the standard DataFlex data types.
81254>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
81254>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
81254>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
81254>>>>>Define CS_DbTypeMySQL       for "MySQL"
81254>>>>>Define CS_DbTypeOracle      for "Oracle"
81254>>>>>Define CS_DbTypeDB2         for "IBM DB2"
81254>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
81254>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
81254>>>>>
81254>>>>>// We need to re-define the standard constants because several driver constants
81254>>>>>// have the same value and we need to be able to distinguish which data type to use when
81254>>>>>// e.g. creating a column with embedded SQL (ESQL).
81254>>>>>Enum_List
81254>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
81254>>>>>    Define DF_BCD_DUF       for -1499
81254>>>>>    Define DF_DATE_DUF      for -1498
81254>>>>>    Define DF_TEXT_DUF      for -1495
81254>>>>>    Define DF_BINARY_DUF    for -1494
81254>>>>>    Define DF_DATETIME_DUF  for -1493
81254>>>>>End_Enum_List
81254>>>>>
81254>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
81254>>>>>
81254>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
81254>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
81254>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
81254>>>>>
81254>>>>>// These are not defined pre DF 18:
81254>>>>>    Define SQL_VARCHARMAX for (-201)
81254>>>>>    Define SQL_TYPE_MONEY for (-204)
81254>>>>>    Define SQL_TYPE_SMALLMONEY for (-205)
81254>>>>>    Define SQL_TYPE_SMALLDATETIME for (-206)
81254>>>>>
81254>>>>>Struct tSQLIntTableInfo
81254>>>>>    String sDriverName
81254>>>>>    String sServerName
81254>>>>>    String sDatabaseName
81254>>>>>    String sSchemaName
81254>>>>>    Boolean bRecnumTable
81254>>>>>    Integer iPrimaryIndex
81254>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
81254>>>>>    String sTableCharacterFormat
81254>>>>>    Boolean bUseDummyZeroDate
81254>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
81254>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
81254>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
81254>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
81254>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
81254>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
81254>>>>>    String sSystemFile             // Yes or No (how to handle?)
81254>>>>>    String sFileIndexTablespace
81254>>>>>    String sFileLongTablespace
81254>>>>>    String sTableTablespace
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tSQLIntColumnInfo
81254>>>>>    Integer iFieldNumber
81254>>>>>    Integer iFieldIndex
81254>>>>>    Integer iFieldRelatedFile
81254>>>>>    Integer iFieldRelatedField
81254>>>>>    Integer iIndexNumber
81254>>>>>    Integer iIndexNumberSegments      
81254>>>>>    Integer iIndexSegmentField1
81254>>>>>    Integer iIndexSegmentField2
81254>>>>>    Integer iIndexSegmentFieldn
81254>>>>>    String sIndexName
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tAPIColumn 
81254>>>>>    String sFieldName 
81254>>>>>    Integer iFieldNumber
81254>>>>>    Integer iType  
81254>>>>>    String  sType
81254>>>>>    Integer iLength 
81254>>>>>    Integer iPrecision 
81254>>>>>    Integer iOptions  
81254>>>>>    Boolean bShouldChange
81254>>>>>End_Struct  
81254>>>>>
81254>>>>>Struct tAPIRelation
81254>>>>>    Handle hTableFrom
81254>>>>>    Handle hTableTo 
81254>>>>>    Integer iColumnFrom
81254>>>>>    Integer iColumnTo 
81254>>>>>    Boolean bShouldChange
81254>>>>>End_Struct 
81254>>>>>
81254>>>>>Struct tAPIIndexSegment
81254>>>>>    Integer iFieldNumber
81254>>>>>    String  sFieldName 
81254>>>>>    Boolean bUppercase
81254>>>>>    Boolean bAscending
81254>>>>>    Boolean bShouldChange
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tAPIIndex
81254>>>>>    Integer iIndexNumber
81254>>>>>    String  sSQLIndexName
81254>>>>>    Integer iSQLIndexType
81254>>>>>    tAPIIndexSegment[] IndexSegmentArray
81254>>>>>    tAPIIndexSegment[] IndexSegmentArray
81254>>>>>    Boolean bShouldChange
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Struct tAPITableNameInfo
81254>>>>>    Integer iTableNumber 
81254>>>>>    String  sRootName
81254>>>>>    String  sLogicalName
81254>>>>>    String  sDisplayName  
81254>>>>>    String  sDriverID
81254>>>>>    Boolean bIsAlias
81254>>>>>    Boolean bIsSQL
81254>>>>>    Boolean bShouldChange
81254>>>>>End_Struct
81254>>>>>    
81254>>>>>Struct tAPITable
81254>>>>>    tAPITableNameInfo ApiTableInfo
81254>>>>>    tAPITableNameInfo ApiTableInfo
81254>>>>>    tAPIColumn[]   aApiColumns
81254>>>>>    tAPIColumn[]   aApiColumns
81254>>>>>    tAPIIndex[]    aApiIndexes
81254>>>>>    tAPIIndex[]    aApiIndexes
81254>>>>>    tAPIRelation[] aApiRelations
81254>>>>>    tAPIRelation[] aApiRelations
81254>>>>>    Boolean bShouldChange
81254>>>>>End_Struct 
81254>>>>>
81254>>>>>Struct tAPITableBooleans
81254>>>>>    Boolean bCompareDate_DateTime
81254>>>>>    Boolean bCompareIndexAscending
81254>>>>>    Boolean bCompareIndexUppercase
81254>>>>>    Boolean bCompareFilelistUppercase
81254>>>>>End_Struct
81254>>>>>
81254>>>>>Define C_tAPIColumn_None for 0
81254>>>>>Define C_tAPIColumn_Identity for 1 
81254>>>>>
81254>>>>>// SQL Key-Word Constants:
81254>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
81254>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
81254>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
81254>>>>>// different wording content depending on the EN_xxx value also passed to the function.
81254>>>>>Enum_List
81254>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
81254>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
81254>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
81254>>>>>    Define CI_SQLColumn                //for "COLUMN"
81254>>>>>    Define CI_SQLSelect                //for "SELECT"
81254>>>>>    Define CI_SQLWhere                 //for "WHERE"
81254>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
81254>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
81254>>>>>    Define CI_SQLTable                 //for "TABLE"
81254>>>>>    Define CI_SQLSys                   //for "SYS"
81254>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
81254>>>>>    Define CI_SQLFrom                  //for "FROM"
81254>>>>>    Define CI_SQLAdd                   //for "ADD"
81254>>>>>    Define CI_SQLDropColumn            //for "DROP"
81254>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
81254>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
81254>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
81254>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
81254>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
81254>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
81254>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
81254>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
81254>>>>>    Define CI_SQLTo                    //for "TO"
81254>>>>>    Define CI_SQLGO                    //for "GO"
81254>>>>>    Define CI_SQLUse                   //for "USE"
81254>>>>>    Define CI_SQLDBO                   //for "DBO"
81254>>>>>
81254>>>>>    Define CI_SQLName                  //for "NAME"
81254>>>>>    Define CI_SQLMaster                //for "MASTER"
81254>>>>>    Define CI_SQLDatabases             //for "DATABASES"
81254>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
81254>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
81254>>>>>    Define CI_SQLID                    //for "ID"
81254>>>>>    Define CI_SQLAND                   //for "AND"
81254>>>>>    Define CI_SQLUpdate                //for "UPDATE"
81254>>>>>    Define CI_SQLSet                   //for "SET"
81254>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
81254>>>>>End_Enum_List
81254>>>>>
81254>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
81254>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
81254>>>>>//
81254>>>>>// We need to create a mixin class for the library.
81254>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
81254>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
81254>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
81254>>>>>// Note: This class should _not_ have a construct_object defined.
81254>>>>>//
81254>>>>>Use VdfBase.pkg
81254>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinUuid.pkg)
81254>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
81255>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
81256>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
81257>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
81258>>>>>>>
81258>>>>>>>// RandomHexUUID:
81258>>>>>>>
81258>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
81258>>>>>>>Function RandomHexUUID Global Returns String
81260>>>>>>>    Address pUUID pUUIDStr
81260>>>>>>>    Integer iRetval iOffset iChar
81260>>>>>>>    String sUUID sKey
81260>>>>>>>    
81260>>>>>>>    Move (Alloc(16)) to pUUID
81261>>>>>>>    
81261>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
81262>>>>>>>    
81262>>>>>>>    If (iRetval = 0) Begin
81264>>>>>>>        Move 0 to pUUIDStr
81265>>>>>>>        
81265>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
81266>>>>>>>        If (iRetval = 0) Begin
81268>>>>>>>            Move pUUIDStr to sUUID
81269>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
81270>>>>>>> 
81270>>>>>>>            Move (Uppercase (sUUID)) to sUUID
81271>>>>>>>        End
81271>>>>>>>>
81271>>>>>>>    End
81271>>>>>>>>
81271>>>>>>>    
81271>>>>>>>    Move (Free(pUUID)) to iRetval 
81272>>>>>>>    
81272>>>>>>>    Function_Return sUUID
81273>>>>>>>End_Function
81274>>>>>>>
81274>>>>>>>
81274>>>>>>>// SeqHexUUID:
81274>>>>>>>
81274>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
81274>>>>>>>Function SeqHexUUID Global Returns String    
81276>>>>>>>    Address pUUID pUUIDStr
81276>>>>>>>    Integer iRetval iOffset iChar
81276>>>>>>>    String sUUID sKey
81276>>>>>>>    
81276>>>>>>>    Move (Alloc(16)) to pUUID
81277>>>>>>>    
81277>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
81278>>>>>>>    
81278>>>>>>>    If (iRetval = 0) Begin
81280>>>>>>>        Move 0 to pUUIDStr
81281>>>>>>>        
81281>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
81282>>>>>>>        If (iRetval = 0) Begin
81284>>>>>>>            Move pUUIDStr to sUUID
81285>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
81286>>>>>>> 
81286>>>>>>>            Move (Uppercase (sUUID)) to sUUID
81287>>>>>>>        End
81287>>>>>>>>
81287>>>>>>>    End
81287>>>>>>>>
81287>>>>>>>    
81287>>>>>>>    Move (Free(pUUID)) to iRetval 
81288>>>>>>>    
81288>>>>>>>    Function_Return sUUID
81289>>>>>>>End_Function
81290>>>>>Use cli.pkg
81290>>>>>Use sql.pkg
81290>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MSSqldrv.pkg)
81290>>>>>>>//*****************************************************************************
81290>>>>>>>//*** MSSQLDRV.PKG                                                          ***
81290>>>>>>>//***                                                                       ***
81290>>>>>>>//*** Author: Ben Weijers                                                   ***
81290>>>>>>>//***         Data Access Nederland                                         ***
81290>>>>>>>//***         29 June 1998                                                  ***
81290>>>>>>>//***                                                                       ***
81290>>>>>>>//***                                                                       ***
81290>>>>>>>//*** Purpose:                                                              ***
81290>>>>>>>//***   Package that declares MS SQL driver constants and functions.        ***
81290>>>>>>>//****                                                                      ***
81290>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
81290>>>>>>>//***   MS SQL Client specific code to a DataFlex application.              ***
81290>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
81290>>>>>>>//***             Changed EnumerateServers function to use the highest      ***
81290>>>>>>>//***             available SQL Server client driver.                       ***
81290>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
81290>>>>>>>//***             mssqldrv.pkg                                              ***
81290>>>>>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
81290>>>>>>>//***             Added constants for SQL Server specific native types      ***
81290>>>>>>>//***             ( var...(max) types, money types, datetime types)         ***
81290>>>>>>>//*****************************************************************************
81290>>>>>>>
81290>>>>>>>Use Cli.pkg
81290>>>>>>>Use SQL.pkg
81290>>>>>>>
81290>>>>>>>//*** Driver Indentification
81290>>>>>>>
81290>>>>>>>//*** Error number constants
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>// SQL Server spcific types. 
81290>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
81290>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
81290>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
81290>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
81290>>>>>>>
81290>>>>>>>// SQL Server spcific types. 
81290>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
81290>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
81290>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
81290>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
81290>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
81290>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
81290>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>//*****************************************************************************
81290>>>>>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
81290>>>>>>>//***                                                                       ***
81290>>>>>>>//***   Setup a constraint for a file.                                      ***
81290>>>>>>>//*****************************************************************************
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>
81290>>>>>>>Class cMSSQLHandler Is A cCLIHandler
81291>>>>>>>
81291>>>>>>>    Procedure Construct_Object
81293>>>>>>>        Forward Send Construct_Object
81295>>>>>>>
81295>>>>>>>        Set psDriverID To MSSQLDRV_ID
81296>>>>>>>    End_Procedure // Construct_Object
81297>>>>>>>
81297>>>>>>>
81297>>>>>>>
81297>>>>>>>    //***
81297>>>>>>>    //*** Function: ExtractList
81297>>>>>>>    //*** Purpose : Extract the list from the out connect string.
81297>>>>>>>    //***
81297>>>>>>>
81297>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
81299>>>>>>>        Local String  sItem
81299>>>>>>>        Local Integer iStart
81299>>>>>>>        Local Integer iEnd
81299>>>>>>>
81299>>>>>>>        If (hoStore = 0) ;            Move Current_object To hoStore
81302>>>>>>>
81302>>>>>>>        Send Delete_Data To hoStore
81303>>>>>>>        Move (Pos("{", sOutConnStr)) To iStart
81304>>>>>>>        While (iStart > 0)
81308>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
81309>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
81312>>>>>>>            Else Begin
81313>>>>>>>                Move (Pos(",", sOutConnStr)) To iStart
81314>>>>>>>                Move (Pos("}", sOutConnStr)) To iEnd
81315>>>>>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
81318>>>>>>>
81318>>>>>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
81321>>>>>>>
81321>>>>>>>                If (iStart = iEnd) ;                    Move 0 To iStart
81324>>>>>>>            End
81324>>>>>>>>
81324>>>>>>>        Loop
81325>>>>>>>>
81325>>>>>>>
81325>>>>>>>        Function_Return (Item_Count(hoStore))
81326>>>>>>>    End_Procedure // ExtractList
81327>>>>>>>
81327>>>>>>>
81327>>>>>>>
81327>>>>>>>    //***
81327>>>>>>>    //*** Function: BrowseConnect
81327>>>>>>>    //*** Purpose : Call the driver's browse connect function
81327>>>>>>>    //***
81327>>>>>>>
81327>>>>>>>    Function BrowseConnect String sInConnStr Returns String
81329>>>>>>>        Local String  sDriver
81329>>>>>>>        Local String  sOutConnStr
81329>>>>>>>        Local Integer iArg
81329>>>>>>>        Local Integer iRetval
81329>>>>>>>
81329>>>>>>>        Get psDriverID To sDriver
81330>>>>>>>        If (sDriver <> "") Begin
81332>>>>>>>            Move (Repeat(" ", 8192)) To sOutConnStr
81333>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
81338>>>>>>>        End
81338>>>>>>>>
81338>>>>>>>
81338>>>>>>>        Function_Return sOutConnStr
81339>>>>>>>    End_Function// BrowseConnect
81340>>>>>>>
81340>>>>>>>
81340>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
81342>>>>>>>        Local String  sDriver
81342>>>>>>>        Local String  sOutConnStr
81342>>>>>>>        Local Integer iArg
81342>>>>>>>        Local Integer iRetval
81342>>>>>>>        
81342>>>>>>>        Move 1 to iArg // Browses only local
81343>>>>>>>
81343>>>>>>>        Get psDriverID to sDriver
81344>>>>>>>        If (sDriver <> "") Begin
81346>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
81347>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
81352>>>>>>>        End
81352>>>>>>>>
81352>>>>>>>
81352>>>>>>>        Function_Return sOutConnStr
81353>>>>>>>    End_Function// BrowseConnect
81354>>>>>>>
81354>>>>>>>
81354>>>>>>>    Function DriverIndex String sDriver Returns Integer
81356>>>>>>>    
81356>>>>>>>        Local String  sCurrentDriver
81356>>>>>>>        Local Integer iNumberOfDrivers iDriver iCount
81356>>>>>>>    
81356>>>>>>>        Move 0 to iDriver
81357>>>>>>>    
81357>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
81360>>>>>>>        For iCount from 1 to iNumberOfDrivers
81366>>>>>>>>
81366>>>>>>>    
81366>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
81369>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
81371>>>>>>>                Move iCount to iDriver
81372>>>>>>>            End
81372>>>>>>>>
81372>>>>>>>        Loop
81373>>>>>>>>
81373>>>>>>>    
81373>>>>>>>        Function_Return iDriver
81374>>>>>>>    
81374>>>>>>>    End_Function 
81375>>>>>>>
81375>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
81377>>>>>>>        
81377>>>>>>>        Local String  sServerList
81377>>>>>>>        Local Integer iNumServers
81377>>>>>>>        Local Integer iDriver
81377>>>>>>>        Local Integer iClientVersion
81377>>>>>>>        Local String  sDriver
81377>>>>>>>        
81377>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
81378>>>>>>>
81378>>>>>>>        If (iDriver) Begin
81380>>>>>>>                
81380>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
81383>>>>>>>            
81383>>>>>>>            Case Begin
81383>>>>>>>    
81383>>>>>>>                Case (iClientVersion = SQLSERVER2016CLIENT)
81385>>>>>>>                    Move SQLSERVER2016DRVRSTR to sDriver
81386>>>>>>>                    Case Break
81387>>>>>>>    
81387>>>>>>>                Case (iClientVersion = SQLSERVER2014CLIENT)
81390>>>>>>>                    Move SQLSERVER2014DRVRSTR to sDriver
81391>>>>>>>                    Case Break
81392>>>>>>>            
81392>>>>>>>                Case (iClientVersion = SQLSERVER2012CLIENT)
81395>>>>>>>                    Move SQLSERVER2012DRVRSTR to sDriver
81396>>>>>>>                    Case Break
81397>>>>>>>    
81397>>>>>>>                Case (iClientVersion = SQLSERVER2008CLIENT)
81400>>>>>>>                    Move SQLSERVER2008DRVRSTR to sDriver
81401>>>>>>>                    Case Break
81402>>>>>>>    
81402>>>>>>>                Case (iClientVersion = SQLSERVER2005CLIENT)
81405>>>>>>>                    Move SQLSERVER2005DRVRSTR to sDriver
81406>>>>>>>                    Case Break
81407>>>>>>>            
81407>>>>>>>                Case (iClientVersion = SQLSERVER2000CLIENT)
81410>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81411>>>>>>>                    Case Break
81412>>>>>>>            
81412>>>>>>>                Case Else
81412>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
81413>>>>>>>            
81413>>>>>>>            Case End
81413>>>>>>>    
81413>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
81414>>>>>>>            If (iNetworkLocal = 0) Begin
81416>>>>>>>                Get BrowseConnect sDriver to sServerList
81417>>>>>>>            End
81417>>>>>>>>
81417>>>>>>>            Else Begin
81418>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
81419>>>>>>>            End
81419>>>>>>>>
81419>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
81420>>>>>>>        End
81420>>>>>>>>
81420>>>>>>>        
81420>>>>>>>        Function_Return iNumServers
81421>>>>>>>        
81421>>>>>>>    End_Function
81422>>>>>>>
81422>>>>>>>    //***
81422>>>>>>>    //*** Procedure: EnumerateServers
81422>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81422>>>>>>>    //***            This function will return all SQL Server instances on the network. 
81422>>>>>>>    //***            This may take a long time. 
81422>>>>>>>    //***            To enumerate only local SQL Server instances use EnumerateServersLocal 
81422>>>>>>>    Function EnumerateServers Returns Integer
81424>>>>>>>
81424>>>>>>>        Local Integer iNumServers
81424>>>>>>>        Local Integer iNetworkLocal
81424>>>>>>>        
81424>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
81425>>>>>>>        
81425>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81426>>>>>>>        
81426>>>>>>>        Function_Return iNumServers
81427>>>>>>>        
81427>>>>>>>    End_Function
81428>>>>>>>
81428>>>>>>>
81428>>>>>>>    //***
81428>>>>>>>    //*** Procedure: EnumerateServersLocal
81428>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
81428>>>>>>>    //***            This function will return only return SQL Server instance on the local machine
81428>>>>>>>    //***            To enumerate all SQL Server instances in a network use EnumerateServers
81428>>>>>>>    Function EnumerateServersLocal Returns Integer
81430>>>>>>>
81430>>>>>>>        Local Integer iNumServers
81430>>>>>>>        Local Integer iNetworkLocal
81430>>>>>>>        
81430>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
81431>>>>>>>        
81431>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
81432>>>>>>>        
81432>>>>>>>        Function_Return iNumServers
81433>>>>>>>        
81433>>>>>>>    End_Function
81434>>>>>>>
81434>>>>>>>    
81434>>>>>>>
81434>>>>>>>    //***
81434>>>>>>>    //*** Function: EnumerateDatabases
81434>>>>>>>    //*** Purpose : Enumerate database in a given server.
81434>>>>>>>    //***
81434>>>>>>>
81434>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
81436>>>>>>>        Local Integer hoSQL
81436>>>>>>>        Local String  sConnect
81436>>>>>>>        Local String  sDatabase
81436>>>>>>>        Local Integer hdbc
81436>>>>>>>        Local Integer hstmt
81436>>>>>>>        Local Integer iFetchResult
81436>>>>>>>
81436>>>>>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
81439>>>>>>>        If (Num_Arguments < 2) ;            Move "" To sUser
81442>>>>>>>
81442>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
81445>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
81447>>>>>>>
81447>>>>>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
81449>>>>>>>            Move Current_Object To hoSQL
81450>>>>>>>        End_Object // oEnumDBSQLManager
81451>>>>>>>
81451>>>>>>>        If (hoSQL <> 0) Begin
81453>>>>>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
81454>>>>>>>            If (hdbc <> 0) Begin
81456>>>>>>>                Get SQLOpen Of hdbc To hstmt
81457>>>>>>>                If (hstmt <> 0) Begin
81459>>>>>>>                    //*** We could do a direct select on the sysdatabases table but we use
81459>>>>>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
81459>>>>>>>                    //*** approach in case meta data might change, the stored procedure will
81459>>>>>>>                    //*** stay the same.
81459>>>>>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
81460>>>>>>>                    Send SQLCall To hstmt
81461>>>>>>>                    Repeat
81461>>>>>>>>
81461>>>>>>>                        Get SQLFetch Of hstmt To iFetchResult
81462>>>>>>>                        If (iFetchResult <> 0) Begin
81464>>>>>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
81465>>>>>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
81466>>>>>>>                        End
81466>>>>>>>>
81466>>>>>>>                    Until (iFetchResult = 0)
81468>>>>>>>
81468>>>>>>>                    Send SQLClose To hstmt
81469>>>>>>>                End
81469>>>>>>>>
81469>>>>>>>                Send SQLDisconnect To hdbc
81470>>>>>>>            End
81470>>>>>>>>
81470>>>>>>>        End
81470>>>>>>>>
81470>>>>>>>        Send Destroy_Object To hoSQL
81471>>>>>>>
81471>>>>>>>        Function_return (Item_Count(Current_Object))
81472>>>>>>>    End_Function // EnumerateDatabases
81473>>>>>>>
81473>>>>>>>
81473>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
81475>>>>>>>        
81475>>>>>>>        Local String  sSqlServerClientVersionName
81475>>>>>>>        
81475>>>>>>>            
81475>>>>>>>        Case Begin
81475>>>>>>>
81475>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
81477>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
81478>>>>>>>                Case Break
81479>>>>>>>
81479>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
81482>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
81483>>>>>>>                Case Break
81484>>>>>>>        
81484>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
81487>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
81488>>>>>>>                Case Break
81489>>>>>>>
81489>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
81492>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
81493>>>>>>>                Case Break
81494>>>>>>>
81494>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
81497>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
81498>>>>>>>                Case Break
81499>>>>>>>        
81499>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
81502>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
81503>>>>>>>                Case Break
81504>>>>>>>        
81504>>>>>>>            Case Else
81504>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
81505>>>>>>>        
81505>>>>>>>        Case End
81505>>>>>>>    
81505>>>>>>>        
81505>>>>>>>        Function_Return sSqlServerClientVersionName
81506>>>>>>>        
81506>>>>>>>    End_Function
81507>>>>>>>
81507>>>>>>>
81507>>>>>>>End_Class // cMSSQLHandler
81508>>>>>>>
81508>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\db2_drv.pkg)
81508>>>>>>>//*****************************************************************************
81508>>>>>>>//*** DB2_DRV.PKG                                                           ***
81508>>>>>>>//***                                                                       ***
81508>>>>>>>//*** Author: Ben Weijers                                                   ***
81508>>>>>>>//***         Data Access Nederland                                         ***
81508>>>>>>>//***         30 July 1998                                                  ***
81508>>>>>>>//***                                                                       ***
81508>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
81508>>>>>>>//***                                                                       ***
81508>>>>>>>//*** Purpose:                                                              ***
81508>>>>>>>//***   Package that declares DB2 driver constants and functions.           ***
81508>>>>>>>//****                                                                      ***
81508>>>>>>>//***   This package can be used by developers who want to add DB2 driver   ***
81508>>>>>>>//***   specific code to a DataFlex application.                            ***
81508>>>>>>>//*****************************************************************************
81508>>>>>>>
81508>>>>>>>Use Cli.pkg
81508>>>>>>>
81508>>>>>>>//*** Driver attributes
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>//*** Driver Indentification
81508>>>>>>>
81508>>>>>>>//*** Error number constants
81508>>>>>>>
81508>>>>>>>//*** Call driver function identifiers
81508>>>>>>>
81508>>>>>>>// DB2 specific data types
81508>>>>>>>Define SQL_CLOB           for   (-99)  
81508>>>>>>>Define SQL_BLOB           for   (-98)  
81508>>>>>>>Define SQL_XML            for   (-370) 
81508>>>>>>>// DB2 Graphic types are Unicode types
81508>>>>>>>Define SQL_GRAPHIC        for   (-95)  
81508>>>>>>>Define SQL_VARGRAPHIC     for   (-96)  
81508>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)  
81508>>>>>>>Define SQL_DBCLOB         for   (-350) 
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>//*** Extra DB2 commands
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>//*****************************************************************************
81508>>>>>>>//*** DB2_CheckTrigger <NewState>                                           ***
81508>>>>>>>//***                                                                       ***
81508>>>>>>>//*** This command will set the trigger check at open on or off.            ***
81508>>>>>>>//*****************************************************************************
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>//*****************************************************************************
81508>>>>>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
81508>>>>>>>//***                                                                       ***
81508>>>>>>>//***   Setup a constraint for a file.                                      ***
81508>>>>>>>//*****************************************************************************
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>
81508>>>>>>>Class cDB2Handler Is A cCLIHandler
81509>>>>>>>
81509>>>>>>>    Procedure Construct_Object
81511>>>>>>>        Forward Send Construct_Object
81513>>>>>>>
81513>>>>>>>        Set psDriverID To DB2_DRV_ID
81514>>>>>>>    End_Procedure // Construct_Object
81515>>>>>>>
81515>>>>>>>
81515>>>>>>>
81515>>>>>>>    //***
81515>>>>>>>    //*** Procedure: SeedDataSources
81515>>>>>>>    //*** Purpose  : Reset the datasource list to the beginning
81515>>>>>>>    //***
81515>>>>>>>
81515>>>>>>>    Procedure SeedDataSources
81517>>>>>>>        Local String  sDriver
81517>>>>>>>        Local String  sVoid
81517>>>>>>>        Local Integer iRetval
81517>>>>>>>
81517>>>>>>>        Get psDriverID To sDriver
81518>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
81525>>>>>>>    End_Procedure // SeedDataSources
81526>>>>>>>
81526>>>>>>>
81526>>>>>>>
81526>>>>>>>    //***
81526>>>>>>>    //*** Function: DataSources
81526>>>>>>>    //*** Purpose : Call the driver's data sources function
81526>>>>>>>    //***
81526>>>>>>>
81526>>>>>>>    Function DataSources Returns String
81528>>>>>>>        Local String  sDriver
81528>>>>>>>        Local String  sDataSource
81528>>>>>>>        Local String  sDescription
81528>>>>>>>        Local Integer iLength
81528>>>>>>>        Local Integer iRetval
81528>>>>>>>
81528>>>>>>>        Get psDriverID To sDriver
81529>>>>>>>        If (sDriver <> "") Begin
81531>>>>>>>            Move 8192 To iLength
81532>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81533>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
81534>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81539>>>>>>>        End
81539>>>>>>>>
81539>>>>>>>
81539>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81542>>>>>>>        Else ;            Function_Return ""
81544>>>>>>>    End_Function// DataSources
81545>>>>>>>
81545>>>>>>>End_Class // cODBCHandler
81546>>>>>>>
81546>>>>>>>
81546>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\odbc_drv.pkg)
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBC_DRV.PKG                                                          ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Author: Ben Weijers                                                   ***
81546>>>>>>>//***         Data Access Nederland                                         ***
81546>>>>>>>//***         3 February 1998                                               ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Purpose:                                                              ***
81546>>>>>>>//***   Package that declares ODBC driver constants and functions.          ***
81546>>>>>>>//****                                                                      ***
81546>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
81546>>>>>>>//***   ODBC Client specific code to a DataFlex application.                ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>Use Cli.pkg
81546>>>>>>>
81546>>>>>>>//*** Driver Indentification
81546>>>>>>>
81546>>>>>>>//*** Error number constants
81546>>>>>>>
81546>>>>>>>//*** Call driver function identifiers
81546>>>>>>>
81546>>>>>>>//*** Extra ODBC commands
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBCManage                                                            ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Start the ODBC manager.                                               ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBCNumberOfDataSources To <NumDSN>                                   ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Returns the number of data sources.                                   ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBCDSNName <DSNNumber> To <DSNName>                                  ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Returns the name of the data source.                                  ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBCEnumerateTables <DSNName> To <TableNum>                           ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Builds internal table array and returns the number of tables in the   ***
81546>>>>>>>//*** DSN.                                                                  ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBCTableName <TableNum> To <TableName>                               ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Returns the name of the table.                                        ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBCSchemaName <TableNum> To <SchemaName>                             ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Returns the schema name of the table.                                 ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBCNumberOfFields <DSNName> <TableName> To <NumDSN>                  ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Returns the number of fields.                                         ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBCFieldName <FieldNumber> To <FieldName>                            ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//*** Returns the name of the field.                                  ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>//*****************************************************************************
81546>>>>>>>//*** ODBC_SetConstraint <FileNum> <ConstraintText>                         ***
81546>>>>>>>//***                                                                       ***
81546>>>>>>>//***   Setup a constraint for a file.                                      ***
81546>>>>>>>//*****************************************************************************
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>
81546>>>>>>>Class cODBCHandler Is A cCLIHandler
81547>>>>>>>
81547>>>>>>>    Procedure Construct_Object
81549>>>>>>>        Forward Send Construct_Object
81551>>>>>>>
81551>>>>>>>        Set psDriverID To ODBC_DRV_ID
81552>>>>>>>    End_Procedure // Construct_Object
81553>>>>>>>
81553>>>>>>>
81553>>>>>>>
81553>>>>>>>    //***
81553>>>>>>>    //*** Procedure Set: DataSourceType
81553>>>>>>>    //*** Purpose      : Setup the type of data sources returned by the datasources function
81553>>>>>>>    //***
81553>>>>>>>
81553>>>>>>>    Procedure Set DataSourceType Integer iNewType
81555>>>>>>>        Local String  sDriver
81555>>>>>>>        Local String  sVoid
81555>>>>>>>        Local Integer iRetval
81555>>>>>>>
81555>>>>>>>        Get psDriverID To sDriver
81556>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
81563>>>>>>>    End_Procedure // Set DataSourceType
81564>>>>>>>
81564>>>>>>>
81564>>>>>>>
81564>>>>>>>    //***
81564>>>>>>>    //*** Function: DataSources
81564>>>>>>>    //*** Purpose : Call the driver's data sources function
81564>>>>>>>    //***
81564>>>>>>>
81564>>>>>>>    Function DataSources Returns String
81566>>>>>>>        Local String  sDriver
81566>>>>>>>        Local String  sDataSource
81566>>>>>>>        Local String  sDescription
81566>>>>>>>        Local Integer iLength
81566>>>>>>>        Local Integer iRetval
81566>>>>>>>
81566>>>>>>>        Get psDriverID To sDriver
81567>>>>>>>        If (sDriver <> "") Begin
81569>>>>>>>            Move 8192 To iLength
81570>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
81571>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
81572>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
81577>>>>>>>        End
81577>>>>>>>>
81577>>>>>>>
81577>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
81580>>>>>>>        Else ;            Function_Return ""
81582>>>>>>>    End_Function// DataSources
81583>>>>>>>
81583>>>>>>>End_Class // cODBCHandler
81584>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DFBTRDRV.PKG)
81584>>>>>>>//****************************************************************************
81584>>>>>>>//
81584>>>>>>>// $File name  : DFBTRDRV.PKG
81584>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
81584>>>>>>>// Notice      : This package contains constants and commands, used to call
81584>>>>>>>//               specific functions in the DFBTRDRV.
81584>>>>>>>// $Author(s)  : Eddy Kleinjan
81584>>>>>>>//
81584>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
81584>>>>>>>// Created     : 01-07-97 @ 12:00:00
81584>>>>>>>//
81584>>>>>>>// Changed     : 04-04-2001.
81584>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
81584>>>>>>>//
81584>>>>>>>// Changed     : June 6, 2001
81584>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
81584>>>>>>>//
81584>>>>>>>//               Added DFBTR_DDF_OWNER command.
81584>>>>>>>//
81584>>>>>>>// Changed     : June 12, 2001
81584>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
81584>>>>>>>//
81584>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
81584>>>>>>>//
81584>>>>>>>// Changed     : August 4, 2004
81584>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
81584>>>>>>>//
81584>>>>>>>//               Added cDfbtrdrvHandler class.
81584>>>>>>>//               New functions in this class:
81584>>>>>>>//                  Function CKRevision Returns String
81584>>>>>>>//                  Function CkUsesUri Returns Integer
81584>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81584>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81584>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81584>>>>>>>//
81584>>>>>>>// Changed     : September 30, 2005
81584>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
81584>>>>>>>//
81584>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
81584>>>>>>>//****************************************************************************
81584>>>>>>>Use Ui
81584>>>>>>>//
81584>>>>>>>// Driver Indentification
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//*** Driver attributes
81584>>>>>>>//
81584>>>>>>>// Call_Driver functions ID's
81584>>>>>>>//
81584>>>>>>>//
81584>>>>>>>// DFBTRFN_CONVERT_FILE options
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// DFBTRFN_SET_OWNER options
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to create all vars which may be needed
81584>>>>>>>// in other commands.
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to set the owner of a Btrieve file.
81584>>>>>>>// File must have been opened.
81584>>>>>>>// Filenumber needs to be passed.
81584>>>>>>>// To clear set the owner to "".
81584>>>>>>>// Examples:
81584>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
81584>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
81584>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
81584>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
81584>>>>>>>// To clear:
81584>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to parse DFBTR_SET_OWNVER
81584>>>>>>>// options.
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to parse for Callback
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to clear the owner of a Btrieve file.
81584>>>>>>>// File must have been opened.
81584>>>>>>>// Filenumber needs to be passed.
81584>>>>>>>// Examples:
81584>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to add a owner name to the internal list of ownernames
81584>>>>>>>// which will be tries when opening files.
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to remove all owners from the internal list of ownernames
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to set the owner name to be used when opening the DDF files.
81584>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
81584>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
81584>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to change the transaction type.
81584>>>>>>>// Valid types are:
81584>>>>>>>//     DFBTRTT_NONE
81584>>>>>>>//     DFBTRTT_EXCLUSIVE
81584>>>>>>>//     DFBTRTT_CONCURRENT
81584>>>>>>>//
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to get the current transaction type.
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to set explicit_locking
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to get explicit locking
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//
81584>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
81584>>>>>>>//
81584>>>>>>>
81584>>>>>>>//*****************************************************************************
81584>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
81584>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
81584>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
81584>>>>>>>//*****************************************************************************
81584>>>>>>>
81584>>>>>>>Class cDFBtrDrvHandler Is An Array
81585>>>>>>>
81585>>>>>>>    Procedure Construct_Object Integer iImage
81587>>>>>>>        Forward Send Construct_object iImage
81589>>>>>>>
81589>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
81590>>>>>>>    End_Procedure // Construct_Object
81591>>>>>>>
81591>>>>>>>
81591>>>>>>>
81591>>>>>>>    //***
81591>>>>>>>    //*** Function: CKRevsion
81591>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
81591>>>>>>>    //***
81591>>>>>>>
81591>>>>>>>    Function CKRevision Returns String
81593>>>>>>>        Local String  sDriverID
81593>>>>>>>        Local String  sRevision
81593>>>>>>>        Local String  sVoid
81593>>>>>>>        Local Integer iRetval
81593>>>>>>>
81593>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81593>>>>>>>        // This error would otherwise be raised when we have an older
81593>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81593>>>>>>>        Send Ignore_error To Error_object_Id 20491
81594>>>>>>>        Get psDriverID To sDriverID
81595>>>>>>>        Move (Repeat(" ", 255)) To sRevision
81596>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
81601>>>>>>>        Send Trap_Error To Error_object_Id 20491
81602>>>>>>>        If (Trim(sRevision) = "") Begin
81604>>>>>>>            // Unable to get the revision. return all zeroes.
81604>>>>>>>            Move "0.0.0.0" To sRevision
81605>>>>>>>        End
81605>>>>>>>>
81605>>>>>>>        Function_Return sRevision
81606>>>>>>>    End_Function // CKRevision
81607>>>>>>>
81607>>>>>>>    Function CkUsesUri Returns Integer
81609>>>>>>>        Local String  sDriverID
81609>>>>>>>        Local String  sVoid1
81609>>>>>>>        Local String  sVoid2
81609>>>>>>>        Local Integer iRetval
81609>>>>>>>
81609>>>>>>>        Get psDriverID To sDriverID
81610>>>>>>>
81610>>>>>>>        Move 0 To iRetval
81611>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81611>>>>>>>        // This error would otherwise be raised when we have an older
81611>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
81611>>>>>>>        Send Ignore_error To Error_object_Id 20491
81612>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
81617>>>>>>>        Send Trap_Error To Error_object_Id 20491
81618>>>>>>>
81618>>>>>>>        Function_Return iRetval
81619>>>>>>>    End_Function // CKUsesUri
81620>>>>>>>
81620>>>>>>>
81620>>>>>>>
81620>>>>>>>    //***
81620>>>>>>>    //*** Function: ExtractPartFromRevsion
81620>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
81620>>>>>>>    //***
81620>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
81620>>>>>>>    //***
81620>>>>>>>
81620>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
81622>>>>>>>        Local Integer iPartRev
81622>>>>>>>        Local Integer iCurrentPart
81622>>>>>>>        Local Integer iSeparatorPos
81622>>>>>>>
81622>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
81625>>>>>>>
81625>>>>>>>        Move 0 To iCurrentPart
81626>>>>>>>        Repeat
81626>>>>>>>>
81626>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
81627>>>>>>>            If (iSeparatorPos > 0) Begin
81629>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
81630>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
81631>>>>>>>                Increment iCurrentPart
81632>>>>>>>            End
81632>>>>>>>>
81632>>>>>>>            Else If (sRevision <> "") Begin
81635>>>>>>>                Move sRevision To iPartRev
81636>>>>>>>                Move "" To sRevision
81637>>>>>>>                Increment iCurrentPart
81638>>>>>>>            End
81638>>>>>>>>
81638>>>>>>>            Else ;                Move -1 To iPartRev
81640>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
81642>>>>>>>
81642>>>>>>>        Function_Return iPartRev
81643>>>>>>>    End_Function // EcxtractPartFromRevision
81644>>>>>>>
81644>>>>>>>
81644>>>>>>>
81644>>>>>>>    //***
81644>>>>>>>    //*** Function: CKMajorRevision
81644>>>>>>>    //*** Purpose : Returns the major revision of the CK
81644>>>>>>>    //***
81644>>>>>>>
81644>>>>>>>    Function CKMajorRevision Returns Integer
81646>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
81647>>>>>>>    End_Function // CKMajorRevision
81648>>>>>>>
81648>>>>>>>
81648>>>>>>>
81648>>>>>>>    //***
81648>>>>>>>    //*** Function: CKMinorRevision
81648>>>>>>>    //*** Purpose : Returns the minor revision of the CK
81648>>>>>>>    //***
81648>>>>>>>
81648>>>>>>>    Function CKMinorRevision Returns Integer
81650>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
81651>>>>>>>    End_Function // CKMinorRevision
81652>>>>>>>
81652>>>>>>>
81652>>>>>>>
81652>>>>>>>    //***
81652>>>>>>>    //*** Function: CKReleaseRevision
81652>>>>>>>    //*** Purpose : Returns the release revision of the CK
81652>>>>>>>    //***
81652>>>>>>>
81652>>>>>>>    Function CKReleaseRevision Returns Integer
81654>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
81655>>>>>>>    End_Function // CKReleaseRevision
81656>>>>>>>
81656>>>>>>>
81656>>>>>>>
81656>>>>>>>    //***
81656>>>>>>>    //*** Function: CKBuildRevision
81656>>>>>>>    //*** Purpose : Returns the major revision of the CK
81656>>>>>>>    //***
81656>>>>>>>
81656>>>>>>>    Function CKBuildRevision Returns Integer
81658>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
81659>>>>>>>    End_Function // CKBuildRevision
81660>>>>>>>
81660>>>>>>>
81660>>>>>>>
81660>>>>>>>    //***
81660>>>>>>>    //*** Function: IsMinimalRevision
81660>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
81660>>>>>>>    //***
81660>>>>>>>
81660>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
81662>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
81665>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
81668>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
81671>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
81674>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
81677>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
81681>>>>>>>            End
81681>>>>>>>>
81681>>>>>>>        End
81681>>>>>>>>
81681>>>>>>>
81681>>>>>>>        Function_Return (FALSE)
81682>>>>>>>    End_Function // IsMinimalRevision
81683>>>>>>>
81683>>>>>>>    //   Functions to query the Pervasive.SQL version:
81683>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
81683>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
81683>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
81683>>>>>>>    //
81683>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
81683>>>>>>>    //   in the following format:
81683>>>>>>>    //       <version>.<revision>.<type>
81683>>>>>>>    //   possible values for <type>:
81683>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
81683>>>>>>>    //         server using Workgroup authentication mode
81683>>>>>>>    //       C for client cache engine
81683>>>>>>>    //       D for DOS workstation
81683>>>>>>>    //       N for client Requester
81683>>>>>>>    //       S for NetWare server
81683>>>>>>>    //       T for 32-bit Windows server engine
81683>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
81683>>>>>>>    //
81683>>>>>>>    //   example:
81683>>>>>>>    //       8.50.T
81683>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
81683>>>>>>>    //   32-bits Windows server.
81683>>>>>>>    //
81683>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
81683>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
81683>>>>>>>    //
81683>>>>>>>    //   If the version information is not available or can not be obtained
81683>>>>>>>    //   the functions will return "0.0.0"
81683>>>>>>>
81683>>>>>>>
81683>>>>>>>    //***
81683>>>>>>>    //*** Function: PSQLRequesterVersionInfo
81683>>>>>>>    //*** Purpose : Returns the version information of the
81683>>>>>>>    //***           Pervasive.SQL Client requester.
81683>>>>>>>
81683>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
81685>>>>>>>
81685>>>>>>>        Local String  sDriverID
81685>>>>>>>        Local String  sVersion
81685>>>>>>>        Local String  sVoid
81685>>>>>>>        Local Integer iRetval
81685>>>>>>>
81685>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81685>>>>>>>        // This error would otherwise be raised when we have an older
81685>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81685>>>>>>>        Send Ignore_error To Error_object_Id 20491
81686>>>>>>>        Get psDriverID To sDriverID
81687>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81688>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81693>>>>>>>        Send Trap_Error To Error_object_Id 20491
81694>>>>>>>        If (Trim(sVersion) = "") Begin
81696>>>>>>>            // Unable to get the revision. return all zeroes.
81696>>>>>>>            Move "0.0.0" To sVersion
81697>>>>>>>        End
81697>>>>>>>>
81697>>>>>>>        Function_Return sVersion
81698>>>>>>>    End_Function //  PSQLRequesterVersion
81699>>>>>>>
81699>>>>>>>    //***
81699>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
81699>>>>>>>    //*** Purpose : Returns the version information of the
81699>>>>>>>    //***           Pervasive.SQL Local Engine
81699>>>>>>>
81699>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
81701>>>>>>>
81701>>>>>>>        Local String  sDriverID
81701>>>>>>>        Local String  sVersion
81701>>>>>>>        Local String  sVoid
81701>>>>>>>        Local Integer iRetval
81701>>>>>>>
81701>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81701>>>>>>>        // This error would otherwise be raised when we have an older
81701>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81701>>>>>>>        Send Ignore_error To Error_object_Id 20491
81702>>>>>>>        Get psDriverID To sDriverID
81703>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81704>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81709>>>>>>>        Send Trap_Error To Error_object_Id 20491
81710>>>>>>>        If (Trim(sVersion) = "") Begin
81712>>>>>>>            // Unable to get the revision. return all zeroes.
81712>>>>>>>            Move "0.0.0" To sVersion
81713>>>>>>>        End
81713>>>>>>>>
81713>>>>>>>        Function_Return sVersion
81714>>>>>>>    End_Function //  PSQLLocalEngineVersion
81715>>>>>>>
81715>>>>>>>    //***
81715>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
81715>>>>>>>    //*** Purpose : Returns the version information of the
81715>>>>>>>    //***           Pervasive.SQL Server Engine
81715>>>>>>>
81715>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
81717>>>>>>>
81717>>>>>>>        Local String  sDriverID
81717>>>>>>>        Local String  sVersion
81717>>>>>>>        Local String  sVoid
81717>>>>>>>        Local Integer iRetval
81717>>>>>>>
81717>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
81717>>>>>>>        // This error would otherwise be raised when we have an older
81717>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
81717>>>>>>>        Send Ignore_error To Error_object_Id 20491
81718>>>>>>>        Get psDriverID To sDriverID
81719>>>>>>>        Move (Repeat(" ", 255)) To sVersion
81720>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
81725>>>>>>>        Send Trap_Error To Error_object_Id 20491
81726>>>>>>>        If (Trim(sVersion) = "") Begin
81728>>>>>>>            // Unable to get the revision. return all zeroes.
81728>>>>>>>            Move "0.0.0" To sVersion
81729>>>>>>>        End
81729>>>>>>>>
81729>>>>>>>        Function_Return sVersion
81730>>>>>>>    End_Function //  PSQLServerEngineVersion
81731>>>>>>>
81731>>>>>>>End_Class // cDfbtrdrvHandler
81732>>>>>>>
81732>>>>>Use cDbUpdateFunctionLibrary.inc
81732>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
81732>>>>>>>//****************************************************************************
81732>>>>>>>// $Module type: Include file
81732>>>>>>>// $Module name: cSQLConnectionIniFile.inc
81732>>>>>>>//
81732>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
81732>>>>>>>// Copyright (c) 2012 RDC Tools International
81732>>>>>>>// E-mail      : support@rdctools.com
81732>>>>>>>// Web-site    : http://www.rdctools.com
81732>>>>>>>//
81732>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
81732>>>>>>>//
81732>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
81732>>>>>>>//
81732>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
81732>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
81732>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
81732>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
81732>>>>>>>// in the help folder for more details.
81732>>>>>>>//
81732>>>>>>>Use Winkern.pkg
81732>>>>>>>Use cIniFile.pkg
81732>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCryptographer.pkg)
81732>>>>>>>>>Use VdfBase.pkg
81732>>>>>>>>>
81732>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\CryptographerConstants.pkg)
81732>>>>>>>>>>>//                                      
81732>>>>>>>>>>>// File    : CryptographerConstants.pkg
81732>>>>>>>>>>>//
81732>>>>>>>>>>>//   Author  : Ulbe Stellema
81732>>>>>>>>>>>//             Data Access Worldwide
81732>>>>>>>>>>>//
81732>>>>>>>>>>>//   Date    : October 4, 2009
81732>>>>>>>>>>>//
81732>>>>>>>>>>>
81732>>>>>>>>>>>
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Algorithm classes
81732>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
81732>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
81732>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
81732>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
81732>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
81732>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
81732>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Algorithm types
81732>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
81732>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
81732>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
81732>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
81732>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
81732>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
81732>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Generic sub-ids
81732>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
81732>>>>>>>>>>>
81732>>>>>>>>>>>// RSA sub-ids
81732>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
81732>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
81732>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
81732>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
81732>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
81732>>>>>>>>>>>
81732>>>>>>>>>>>// DSS sub-ids
81732>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
81732>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
81732>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
81732>>>>>>>>>>>
81732>>>>>>>>>>>// DES sub_ids
81732>>>>>>>>>>>Define ALG_SID_DES                      for 1
81732>>>>>>>>>>>Define ALG_SID_3DES                     for 3
81732>>>>>>>>>>>Define ALG_SID_DESX                     for 4
81732>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
81732>>>>>>>>>>>Define ALG_SID_CAST                     for 6
81732>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
81732>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
81732>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
81732>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
81732>>>>>>>>>>>Define ALG_SID_RC5                      for 13
81732>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
81732>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
81732>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
81732>>>>>>>>>>>Define ALG_SID_AES                      for 17
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Fortezza sub-ids
81732>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
81732>>>>>>>>>>>Define ALG_SID_TEK                      for 11
81732>>>>>>>>>>>
81732>>>>>>>>>>>// RC2 sub-ids
81732>>>>>>>>>>>Define ALG_SID_RC2                      for 2
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Stream cipher sub-ids
81732>>>>>>>>>>>Define ALG_SID_RC4                      for 1
81732>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Diffie-Hellman sub-ids
81732>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
81732>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
81732>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
81732>>>>>>>>>>>Define ALG_SID_KEA                      for 4
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Hash sub ids
81732>>>>>>>>>>>Define ALG_SID_MD2                      for 1
81732>>>>>>>>>>>Define ALG_SID_MD4                      for 2
81732>>>>>>>>>>>Define ALG_SID_MD5                      for 3
81732>>>>>>>>>>>Define ALG_SID_SHA                      for 4
81732>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
81732>>>>>>>>>>>Define ALG_SID_MAC                      for 5
81732>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
81732>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
81732>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
81732>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
81732>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
81732>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
81732>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
81732>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
81732>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
81732>>>>>>>>>>>
81732>>>>>>>>>>>// secure channel sub ids
81732>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
81732>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
81732>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
81732>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
81732>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
81732>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
81732>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
81732>>>>>>>>>>>
81732>>>>>>>>>>>// algorithm identifier definitions
81732>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
81732>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
81732>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
81732>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
81732>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
81732>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
81732>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81732>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
81732>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
81732>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
81732>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
81732>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
81732>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
81732>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
81732>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
81732>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
81732>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
81732>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
81732>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
81732>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
81732>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
81732>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
81732>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
81732>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
81732>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
81732>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
81732>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
81732>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
81732>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
81732>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
81732>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
81732>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
81732>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
81732>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
81732>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
81732>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
81732>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
81732>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
81732>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
81732>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
81732>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
81732>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
81732>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
81732>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Providers
81732>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
81732>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
81732>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
81732>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
81732>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
81732>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
81732>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
81732>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
81732>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
81732>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
81732>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
81732>>>>>>>>>>>
81732>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
81732>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
81732>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
81732>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
81732>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
81732>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
81732>>>>>>>>>>>
81732>>>>>>>>>>>// dwFlag definitions for CryptGenKey
81732>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
81732>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
81732>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
81732>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
81732>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
81732>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
81732>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
81732>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
81732>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
81732>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
81732>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
81732>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
81732>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
81732>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
81732>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
81732>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
81732>>>>>>>>>>>
81732>>>>>>>>>>>// Provider types
81732>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
81732>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
81732>>>>>>>>>>>Define PROV_DSS                         for 3
81732>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
81732>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
81732>>>>>>>>>>>Define PROV_SSL                         for 6
81732>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
81732>>>>>>>>>>>Define PROV_DSS_DH                      for 13
81732>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
81732>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
81732>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
81732>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
81732>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
81732>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
81732>>>>>>>>>>>Define PROV_RNG                         for 21
81732>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
81732>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
81732>>>>>>>>>>>Define PROV_RSA_AES                     for 24
81732>>>>>>>>>>>
81732>>>>>>>>>>>// KP_MODE
81732>>>>>>>>>>>// KP_MODE
81732>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
81732>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
81732>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
81732>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
81732>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
81732>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
81732>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
81732>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
81732>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
81732>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
81732>>>>>>>>>>>
81732>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
81732>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
81732>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
81732>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
81732>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
81732>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
81732>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
81732>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
81732>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
81732>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
81732>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
81732>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
81732>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
81732>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
81732>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
81732>>>>>>>>>>>Define KP_Y                             for 15      // Y value
81732>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
81732>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
81732>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
81732>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
81732>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
81732>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
81732>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
81732>>>>>>>>>>>Define KP_RP                            for 23
81732>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
81732>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
81732>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
81732>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
81732>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
81732>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
81732>>>>>>>>>>>Define KP_KEYVAL                        for 30
81732>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
81732>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
81732>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
81732>>>>>>>>>>>Define KP_PREHASH                       for 34
81732>>>>>>>>>>>Define KP_ROUNDS                        for 35
81732>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
81732>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
81732>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
81732>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
81732>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
81732>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
81732>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
81732>>>>>>>>>>>
81732>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
81732>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
81732>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
81732>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
81732>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
81732>>>>>>>>>>>
81732>>>>>>>>>>>// key BLOB types
81732>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
81732>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
81732>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
81732>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
81732>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
81732>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
81732>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
81732>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
81732>>>>>>>>>>>
81732>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
81732>>>>>>>>>>>
81732>>>>>>>>>>>//  Structure cryptimportkey
81732>>>>>>>>>>>Struct PUBLICKEYSTRUC
81732>>>>>>>>>>>    UChar    bType
81732>>>>>>>>>>>    UChar    bVersion
81732>>>>>>>>>>>    UShort   reserved
81732>>>>>>>>>>>    UInteger aiKeyAlg
81732>>>>>>>>>>>End_Struct
81732>>>>>>>>>>>
81732>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
81732>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81732>>>>>>>>>>>    PUBLICKEYSTRUC hdr
81732>>>>>>>>>>>    UInteger       dwKeySize
81732>>>>>>>>>>>//    UChar[]        rgbKeyData
81732>>>>>>>>>>>End_Struct
81732>>>>>>>>>>>
81732>>>>>>>>>>>
81732>>>>>>>>>>>
81732>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
81732>>>>>>>>>>>Struct HMAC_INFO
81732>>>>>>>>>>>    UInteger HashAlgid
81732>>>>>>>>>>>    Pointer pbInnerString
81732>>>>>>>>>>>    DWord cbInnerString
81732>>>>>>>>>>>    Pointer pbOuterString
81732>>>>>>>>>>>    DWord cbOuterString
81732>>>>>>>>>>>End_Struct
81732>>>>>>>>>>>
81732>>>>>>>>>>>
81732>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
81733>>>>>>>>>>>
81733>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
81734>>>>>>>>>>>
81734>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
81735>>>>>>>>>>>
81735>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
81736>>>>>>>>>>>
81736>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
81737>>>>>>>>>>>
81737>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81738>>>>>>>>>>>
81738>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
81739>>>>>>>>>>>
81739>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
81740>>>>>>>>>>>
81740>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
81741>>>>>>>>>>>
81741>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
81742>>>>>>>>>>>    
81742>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
81743>>>>>>>>>>>
81743>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
81744>>>>>>>>>>>
81744>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
81745>>>>>>>>>>>
81745>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
81746>>>>>>>>>>>    
81746>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
81747>>>>>>>>>>>    
81747>>>>>>>>>
81747>>>>>>>>>Class cCryptographer is a cObject
81748>>>>>>>>>    
81748>>>>>>>>>    // Procedure : Construct_Object
81748>>>>>>>>>    // Purpose   : Object constructor
81748>>>>>>>>>    Procedure Construct_Object
81750>>>>>>>>>        Forward Send Construct_Object
81752>>>>>>>>>
81752>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
81753>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
81754>>>>>>>>>        Property Integer    piCipher    CALG_RC4
81755>>>>>>>>>        Property Integer    piHash      CALG_MD5
81756>>>>>>>>>        
81756>>>>>>>>>        // Private properties
81756>>>>>>>>>        Property Handle     Private_phProv
81757>>>>>>>>>    End_Procedure
81758>>>>>>>>>    
81758>>>>>>>>>    
81758>>>>>>>>>    // Function : AcquireContext
81758>>>>>>>>>    // Purpose  : Acquire key container handle
81758>>>>>>>>>    Function AcquireContext Returns Handle
81760>>>>>>>>>        Integer iProvider
81760>>>>>>>>>        String sProvider
81760>>>>>>>>>        Handle hProv
81760>>>>>>>>>        Boolean bOk
81760>>>>>>>>>        Address addrProv
81760>>>>>>>>>        
81760>>>>>>>>>        Move 0 to hProv
81761>>>>>>>>>        Get piProvider to iProvider
81762>>>>>>>>>        Get psProvider to sProvider
81763>>>>>>>>>        
81763>>>>>>>>>        //  Determine address to be passed as provider
81763>>>>>>>>>        If (Trim(sProvider) <> "") Begin
81765>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
81766>>>>>>>>>        End
81766>>>>>>>>>>
81766>>>>>>>>>        Else Begin
81767>>>>>>>>>            Move 0 to addrProv
81768>>>>>>>>>        End
81768>>>>>>>>>>
81768>>>>>>>>>        
81768>>>>>>>>>        //  Acquire Crypto Context
81768>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
81769>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81771>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
81772>>>>>>>>>        End
81772>>>>>>>>>>
81772>>>>>>>>>        
81772>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
81774>>>>>>>>>            // Fallback to original
81774>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
81775>>>>>>>>>            
81775>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
81777>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
81778>>>>>>>>>            End
81778>>>>>>>>>>
81778>>>>>>>>>        End
81778>>>>>>>>>>
81778>>>>>>>>>        Set Private_phProv to hProv
81779>>>>>>>>>        
81779>>>>>>>>>        Function_Return hProv
81780>>>>>>>>>    End_Function
81781>>>>>>>>>    
81781>>>>>>>>>    // Function : ReleaseContext
81781>>>>>>>>>    // Purpose  : Releases key container handle
81781>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
81783>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
81784>>>>>>>>>    End_Function
81785>>>>>>>>>    
81785>>>>>>>>>    // Function : CreateHash
81785>>>>>>>>>    // Purpose  : Creates hash object
81785>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
81787>>>>>>>>>        Integer iAlgorithm
81787>>>>>>>>>        Handle hHash
81787>>>>>>>>>        Boolean bOk
81787>>>>>>>>>        
81787>>>>>>>>>        Move 0 to hHash
81788>>>>>>>>>        Get piHash to iAlgorithm
81789>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
81790>>>>>>>>>        
81790>>>>>>>>>        Function_Return hHash
81791>>>>>>>>>    End_Function
81792>>>>>>>>>    
81792>>>>>>>>>    // Function : DestroyHash
81792>>>>>>>>>    // Purpose  : Destroys the hash object
81792>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
81794>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
81795>>>>>>>>>    End_Function
81796>>>>>>>>>    
81796>>>>>>>>>    // Function : HashData
81796>>>>>>>>>    // Purpose  : Adds data to hash object
81796>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
81798>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
81799>>>>>>>>>    End_Function
81800>>>>>>>>>    
81800>>>>>>>>>    // Function : DeriveKey
81800>>>>>>>>>    // Purpose  : Generates session key
81800>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
81802>>>>>>>>>        Integer iAlgorithm
81802>>>>>>>>>        Handle hKey
81802>>>>>>>>>        Boolean bOk
81802>>>>>>>>>        
81802>>>>>>>>>        Move 0 to hKey
81803>>>>>>>>>        Get piCipher to iAlgorithm
81804>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
81805>>>>>>>>>        
81805>>>>>>>>>        Function_Return hKey
81806>>>>>>>>>    End_Function
81807>>>>>>>>>    
81807>>>>>>>>>    // Function : ImportPlainTextKey
81807>>>>>>>>>    // Purpose  : Imports a plain text key
81807>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
81809>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81809>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
81809>>>>>>>>>        Boolean   bSuccess
81809>>>>>>>>>        Handle    hKey
81809>>>>>>>>>        Integer   iHeadSize iKeySize
81809>>>>>>>>>        UChar[]   ucaKeyblob
81810>>>>>>>>>        Integer iVoid
81810>>>>>>>>>    
81810>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
81811>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
81812>>>>>>>>>    
81812>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
81813>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
81814>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
81815>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
81816>>>>>>>>>    
81816>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
81817>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
81818>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
81819>>>>>>>>>    
81819>>>>>>>>>        Move 0 to hKey
81820>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
81821>>>>>>>>>        If (not(bSuccess)) Begin 
81823>>>>>>>>>            Move (ShowLastError()) to iVoid
81824>>>>>>>>>        End
81824>>>>>>>>>>
81824>>>>>>>>>    
81824>>>>>>>>>        Function_Return hKey
81825>>>>>>>>>    End_Function
81826>>>>>>>>>
81826>>>>>>>>>    // Function : DestroyKey
81826>>>>>>>>>    // Purpose  : Destroys the key
81826>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
81828>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
81829>>>>>>>>>    End_Function
81830>>>>>>>>>    
81830>>>>>>>>>    // Function : KeyParameter
81830>>>>>>>>>    // Purpose  : Retrieves key data
81830>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
81832>>>>>>>>>        Integer iBuffer iLen
81832>>>>>>>>>        Boolean bOk
81832>>>>>>>>>        
81832>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
81833>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
81834>>>>>>>>>        Function_Return iBuffer
81835>>>>>>>>>    End_Function
81836>>>>>>>>>    
81836>>>>>>>>>    // Function : HashValue
81836>>>>>>>>>    // Purpose  : Retrieves a hash value
81836>>>>>>>>>    Function HashValue Handle lhHash Returns String
81838>>>>>>>>>        Pointer lpSize
81838>>>>>>>>>        Pointer lpHash
81838>>>>>>>>>        String  lsSize
81838>>>>>>>>>        String  lsHash
81838>>>>>>>>>        Integer liResult
81838>>>>>>>>>
81838>>>>>>>>>        Move (Repeat(Character(0),4)) to lsSize
81839>>>>>>>>>        GetAddress of lsSize to lpSize
81840>>>>>>>>>
81840>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,lpSize,0)) to liResult
81841>>>>>>>>>        If (liResult = 0) Function_Return ""
81844>>>>>>>>>
81844>>>>>>>>>        Move (Repeat(Character(0),BytesTodWord(lsSize,1))) to lsHash
81845>>>>>>>>>        GetAddress of lsHash to lpHash
81846>>>>>>>>>
81846>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,lpHash,lpSize,0)) to liResult
81847>>>>>>>>>        If (liResult = 0) Function_Return ""
81850>>>>>>>>>
81850>>>>>>>>>        Function_Return lsHash
81851>>>>>>>>>    End_Function  // HashValue
81852>>>>>>>>>    
81852>>>>>>>>>            
81852>>>>>>>>>    // Function : Encrypt
81852>>>>>>>>>    // Purpose  : Encrypts data
81852>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
81854>>>>>>>>>        Handle hProv hHash hKey
81854>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
81854>>>>>>>>>        Boolean bOk
81854>>>>>>>>>        
81854>>>>>>>>>        Get AcquireContext to hProv
81855>>>>>>>>>        If (hProv) Begin
81857>>>>>>>>>            Get CreateHash hProv to hHash
81858>>>>>>>>>            If (hHash) Begin
81860>>>>>>>>>                Get HashData hHash sPassword to bOk
81861>>>>>>>>>                If (bOk) Begin
81863>>>>>>>>>                    Get piCipher to iAlgorithm
81864>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
81865>>>>>>>>>                End // If (bOk) Begin            
81865>>>>>>>>>>
81865>>>>>>>>>                Get DestroyHash hHash to bOk
81866>>>>>>>>>            End // If (hHash) Begin
81866>>>>>>>>>>
81866>>>>>>>>>            
81866>>>>>>>>>            If (hKey) Begin
81868>>>>>>>>>                //  First call to determine resulting data size
81868>>>>>>>>>                Move (Length(sData)) to iDataLen
81869>>>>>>>>>                Move (Length(sData)) to iCipherLen
81870>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
81871>>>>>>>>>                
81871>>>>>>>>>                //  Reserve space in string
81871>>>>>>>>>                If (iDataLen < iCipherLen) Begin
81873>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
81874>>>>>>>>>                End
81874>>>>>>>>>>
81874>>>>>>>>>                
81874>>>>>>>>>                //  Call to really decrypt
81874>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
81875>>>>>>>>>                //If (not(bOk)) Begin
81875>>>>>>>>>                    //Move "" to sData
81875>>>>>>>>>                    //Move (GetLastError()) to iErr
81875>>>>>>>>>                //End
81875>>>>>>>>>                
81875>>>>>>>>>                Get DestroyKey hKey to bOk
81876>>>>>>>>>            End // If (hKey) Begin
81876>>>>>>>>>>
81876>>>>>>>>>            Get ReleaseContext hProv to bOk
81877>>>>>>>>>        End // If (hProv) Begin
81877>>>>>>>>>>
81877>>>>>>>>>        Function_Return sData
81878>>>>>>>>>    End_Function
81879>>>>>>>>>    
81879>>>>>>>>>    // Function : Decrypt
81879>>>>>>>>>    // Purpose  : Decrypts data
81879>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
81881>>>>>>>>>        Handle hProv hHash hKey
81881>>>>>>>>>        Integer iAlgorithm iDataLen
81881>>>>>>>>>        Boolean bOk
81881>>>>>>>>>        
81881>>>>>>>>>        Get AcquireContext to hProv
81882>>>>>>>>>        If (hProv) Begin
81884>>>>>>>>>            Get CreateHash hProv to hHash
81885>>>>>>>>>            If (hHash) Begin
81887>>>>>>>>>                Get HashData hHash sPassword to bOk
81888>>>>>>>>>                If (bOk) Begin
81890>>>>>>>>>                    Get piCipher to iAlgorithm
81891>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
81892>>>>>>>>>                End // If (bOk) Begin            
81892>>>>>>>>>>
81892>>>>>>>>>                Get DestroyHash hHash to bOk
81893>>>>>>>>>            End // If (hHash) Begin
81893>>>>>>>>>>
81893>>>>>>>>>            
81893>>>>>>>>>            If (hKey) Begin
81895>>>>>>>>>                Move (Length(sData)) to iDataLen
81896>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
81897>>>>>>>>>                //If (bOk = False) Move "" to sData
81897>>>>>>>>>                
81897>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
81897>>>>>>>>>                If (Length(sData) > iDataLen) Begin
81899>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
81900>>>>>>>>>                End
81900>>>>>>>>>>
81900>>>>>>>>>                
81900>>>>>>>>>                Get DestroyKey hKey to bOk
81901>>>>>>>>>            End // If (hKey) Begin
81901>>>>>>>>>>
81901>>>>>>>>>            Get ReleaseContext hProv to bOk
81902>>>>>>>>>        End // If (hProv) Begin
81902>>>>>>>>>>
81902>>>>>>>>>        Function_Return sData
81903>>>>>>>>>    End_Function
81904>>>>>>>>>    
81904>>>>>>>>>    //  Function : GenerateRandom
81904>>>>>>>>>    //  Purpose  : Generates random data.
81904>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
81906>>>>>>>>>        Handle hProv
81906>>>>>>>>>        UChar[] uaResult
81907>>>>>>>>>        Boolean bRes
81907>>>>>>>>>        
81907>>>>>>>>>        Get AcquireContext to hProv
81908>>>>>>>>>        
81908>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
81909>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
81910>>>>>>>>>        
81910>>>>>>>>>        Get ReleaseContext hProv to bRes
81911>>>>>>>>>        
81911>>>>>>>>>        Function_Return uaResult
81912>>>>>>>>>    End_Function
81913>>>>>>>>>    
81913>>>>>>>>>    //  Function : GenerateRandomString
81913>>>>>>>>>    //  Purpose  : Generates random data and does a base64 encoding to properly present it as a string.
81913>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
81915>>>>>>>>>        String sResult
81915>>>>>>>>>        UChar[] aData
81916>>>>>>>>>        Address pBase64
81916>>>>>>>>>        Integer iVoid
81916>>>>>>>>>
81916>>>>>>>>>        Get GenerateRandom iLenght to aData
81917>>>>>>>>>        
81917>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
81918>>>>>>>>>        Move pBase64 to sResult
81919>>>>>>>>>        Move (Free(pBase64)) to iVoid    
81920>>>>>>>>>        
81920>>>>>>>>>        Function_Return (Left(sResult, iLenght))
81921>>>>>>>>>    End_Function
81922>>>>>>>>>
81922>>>>>>>>>End_Class
81923>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Base64Functions.pkg)
81923>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
81923>>>>>>>>>//>
81923>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
81923>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
81923>>>>>>>>>//>
81923>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
81923>>>>>>>>>//> strings.
81923>>>>>>>>>//>
81923>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
81923>>>>>>>>>//> Base64Decode) that are built into the runtime.
81923>>>>>>>>>//>
81923>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
81923>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
81923>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
81923>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
81923>>>>>>>>>
81923>>>>>>>>>Use VdfBase.pkg
81923>>>>>>>>>
81923>>>>>>>>>// Functions in vdfBase64.dll
81923>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
81924>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
81925>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
81926>>>>>>>>>
81926>>>>>>>>>// Structure
81926>>>>>>>>>Struct txxfBase64Buffer
81926>>>>>>>>>    Pointer pData
81926>>>>>>>>>    Integer iLength
81926>>>>>>>>>End_Struct
81926>>>>>>>>>
81926>>>>>>>>>Global_Variable Integer oBase64Functions
81926>>>>>>>>>
81926>>>>>>>>>Object _oBase64Functions is a cObject
81928>>>>>>>>>    Move Self to oBase64Functions
81929>>>>>>>>>
81929>>>>>>>>>
81929>>>>>>>>>    Function EncodeString String sValue Returns String
81932>>>>>>>>>        Address pBase64
81932>>>>>>>>>        String sResult
81932>>>>>>>>>        Integer iVoid
81932>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
81933>>>>>>>>>        Move pBase64 to sResult
81934>>>>>>>>>        Move (Free(pBase64)) to iVoid
81935>>>>>>>>>        Function_Return sResult
81936>>>>>>>>>    End_Function
81937>>>>>>>>>
81937>>>>>>>>>    Function DecodeString String sValue Returns String
81940>>>>>>>>>        Address pBinary
81940>>>>>>>>>        String sBinary
81940>>>>>>>>>        Integer iVoid iLen
81940>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
81941>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
81942>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
81943>>>>>>>>>        Move (Free(pBinary)) to iVoid
81944>>>>>>>>>        Function_Return sBinary
81945>>>>>>>>>    End_Function
81946>>>>>>>>>
81946>>>>>>>>>End_Object
81947>>>>>>>Use MSSqldrv.pkg
81947>>>>>>>Use db2_drv.pkg
81947>>>>>>>Use odbc_drv.pkg
81947>>>>>>>Use vWin32fh.pkg
81947>>>>>>>
81947>>>>>>>Use DUFLanguageConstants.inc
81947>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MertechDUF.pkg)
81947>>>>>>>>>//
81947>>>>>>>>>// Use of Mertech drivers:
81947>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
81947>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
81947>>>>>>>>>//Define DUF_Use_Mertech_Drivers
81947>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
81947>>>>>>>>>// MySQL Data Types
81947>>>>>>>>>Define eMySQL_DECIMAL                               for 0
81947>>>>>>>>>Define eMySQL_TINY                                  for 1
81947>>>>>>>>>Define eMySQL_SHORT                                 for 2
81947>>>>>>>>>Define eMySQL_LONG                                  for 3
81947>>>>>>>>>Define eMySQL_FLOAT                                 for 4
81947>>>>>>>>>Define eMySQL_DOUBLE                                for 5
81947>>>>>>>>>Define eMySQL_NULL                                  for 6
81947>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
81947>>>>>>>>>Define eMySQL_LONGLONG                              for 8
81947>>>>>>>>>Define eMySQL_INT24                                 for 9
81947>>>>>>>>>Define eMySQL_DATE                                  for 10
81947>>>>>>>>>Define eMySQL_TIME                                  for 11
81947>>>>>>>>>Define eMySQL_DATETIME                              for 12
81947>>>>>>>>>Define eMySQL_YEAR                                  for 13
81947>>>>>>>>>Define eMySQL_NEWDATE                               for 14
81947>>>>>>>>>Define eMySQL_BIT                                   for 16
81947>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
81947>>>>>>>>>Define eMySQL_ENUM                                  for 247
81947>>>>>>>>>Define eMySQL_SET                                   for 248
81947>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
81947>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
81947>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
81947>>>>>>>>>Define eMySQL_BLOB                                  for 252
81947>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
81947>>>>>>>>>Define eMySQL_STRING                                for 254
81947>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
81947>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
81947>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
81947>>>>>>>>>Define eMySQL_TEXT                                  for -252
81947>>>>>>>>>
81947>>>>>>>>>// Oracle Data Types
81947>>>>>>>>>Define eOracle_VARCHAR2                             for   1
81947>>>>>>>>>Define eOracle_NUMBER                               for   2
81947>>>>>>>>>Define eOracle_INT                                  for   3
81947>>>>>>>>>Define eOracle_FLOAT                                for   4
81947>>>>>>>>>Define eOracle_STRING                               for   5
81947>>>>>>>>>Define eOracle_LONG                                 for   8
81947>>>>>>>>>Define eOracle_ROWID                                for  11
81947>>>>>>>>>Define eOracle_DATE                                 for  12
81947>>>>>>>>>Define eOracle_RAW                                  for  23
81947>>>>>>>>>Define eOracle_LONGRAW                              for  24
81947>>>>>>>>>Define eOracle_CHAR                                 for  96
81947>>>>>>>>>Define eOracle_MSLABEL                              for 106
81947>>>>>>>>>Define eOracle_CLOB                                 for 112
81947>>>>>>>>>Define eOracle_BLOB                                 for 113
81947>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
81947>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
81947>>>>>>>>>Define eOracle_INTERVALYM                           for 189
81947>>>>>>>>>Define eOracle_INTERVALDS                           for 190
81947>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
81947>>>>>>>>>Define eOracle_NCHAR                                for 286
81947>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
81947>>>>>>>>>Define eOracle_NCLOB                                for 288
81947>>>>>>>>>
81947>>>>>>>>>// PostgreSQL Data Types
81947>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
81947>>>>>>>>>Define ePgSQL_MONEY                                 for  790
81947>>>>>>>>>Define ePgSQL_BOOL                                  for   16
81947>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
81947>>>>>>>>>Define ePgSQL_CHAR                                  for   18
81947>>>>>>>>>Define ePgSQL_INT2                                  for   21
81947>>>>>>>>>Define ePgSQL_INT4                                  for   23
81947>>>>>>>>>Define ePgSQL_REGPROC                               for   24
81947>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
81947>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
81947>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
81947>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
81947>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
81947>>>>>>>>>Define ePgSQL_TEXT                                  for   25
81947>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
81947>>>>>>>>>Define ePgSQL_OID                                   for   26
81947>>>>>>>>>Define ePgSQL_TID                                   for   27
81947>>>>>>>>>Define ePgSQL_XID                                   for   28
81947>>>>>>>>>Define ePgSQL_CID                                   for   29
81947>>>>>>>>>Define ePgSQL_XML                                   for  142
81947>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
81947>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
81947>>>>>>>>>Define ePgSQL_INT8                                  for   20
81947>>>>>>>>>Define ePgSQL_PATH                                  for  602
81947>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
81947>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
81947>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
81947>>>>>>>>>Define ePgSQL_RELTIME                               for  703
81947>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
81947>>>>>>>>>Define ePgSQL_POINT                                 for  600
81947>>>>>>>>>Define ePgSQL_LINE                                  for  628
81947>>>>>>>>>Define ePgSQL_LSEG                                  for  601
81947>>>>>>>>>Define ePgSQL_BOX                                   for  603
81947>>>>>>>>>Define ePgSQL_POLYGON                               for  604
81947>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
81947>>>>>>>>>Define ePgSQL_MACADDR                               for  829
81947>>>>>>>>>Define ePgSQL_INET                                  for  869
81947>>>>>>>>>Define ePgSQL_CIDR                                  for  650
81947>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
81947>>>>>>>>>Define ePgSQL_DATE                                  for 1082
81947>>>>>>>>>Define ePgSQL_TIME                                  for 1083
81947>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
81947>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
81947>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
81947>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
81947>>>>>>>>>Define ePgSQL_BIT                                   for 1560
81947>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
81947>>>>>>>>>Define ePgSQL_UUID                                  for 2950
81947>>>>>>>>>
81947>>>>>>>>>// SQL Server Data Types
81947>>>>>>>>>Define eSQLServer_NA                                for    0
81947>>>>>>>>>Define eSQLServer_CHAR                              for    1
81947>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
81947>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
81947>>>>>>>>>Define eSQLServer_INT                               for    4
81947>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
81947>>>>>>>>>Define eSQLServer_FLOAT                             for    6
81947>>>>>>>>>Define eSQLServer_REAL                              for    7
81947>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
81947>>>>>>>>>Define eSQLServer_DATETIME                          for   11
81947>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
81947>>>>>>>>>Define eSQLServer_DATE                              for   40
81947>>>>>>>>>Define eSQLServer_TIME                              for   41
81947>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
81947>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
81947>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
81947>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
81947>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
81947>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
81947>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
81947>>>>>>>>>Define eSQLServer_TEXT                              for   -1
81947>>>>>>>>>Define eSQLServer_BINARY                            for   -2
81947>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
81947>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
81947>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
81947>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
81947>>>>>>>>>Define eSQLServer_BIT                               for   -7
81947>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
81947>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
81947>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
81947>>>>>>>>>Define eSQLServer_GUID                              for  -11
81947>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
81947>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
81947>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
81947>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
81947>>>>>>>>>Define eSQLServer_XML                               for -370
81947>>>>>>>>>
81947>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
81947>>>>>>>
81947>>>>>>>// This needs to be after Mertech drivers are defined.
81947>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
81947>>>>>>>
81947>>>>>>>
81947>>>>>>>    Define SQLFLEX   for "SQL_DRV"
81947>>>>>>>
81947>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
81947>>>>>>>
81947>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
81947>>>>>>>
81947>>>>>>>    Define ORAFLEX   for "ORA_DRV"
81947>>>>>>>
81947>>>>>>>
81947>>>>>>>// SQLConnection.ini constants:
81947>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
81947>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
81947>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
81947>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
81947>>>>>>>Define CS_SQLIniSectionName             for "Connection"
81947>>>>>>>
81947>>>>>>>// DF 19 ini-file settings:
81947>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
81947>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
81947>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
81947>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
81947>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
81947>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
81947>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
81947>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
81947>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
81947>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection"
81947>>>>>>>
81947>>>>>>>// Database Update Framework extended settings:
81947>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
81947>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
81947>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
81947>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
81947>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
81947>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
81947>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
81947>>>>>>>
81947>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
81947>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
81947>>>>>>>Define CS_SQLIniConnectionNo            for "No"
81947>>>>>>>
81947>>>>>>>Struct tSQLConnection
81947>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
81947>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
81947>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
81947>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
81947>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
81947>>>>>>>    String sDatabase                // 6. SQL Database
81947>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
81947>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
81947>>>>>>>    String sUserID                  // 9. User ID
81947>>>>>>>    String sPassword                // 10. Password
81947>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
81947>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
81947>>>>>>>    String sLongTableSpace          // 13. DB2 specific
81947>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
81947>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
81947>>>>>>>    Boolean bError                  // 16. Set to true on error.
81947>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
81947>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
81947>>>>>>>End_Struct
81947>>>>>
81947>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
81948>>>>>    Procedure CreateDbUpdateLibraryProperties
81950>>>>>        Handle hoSQLManagerMT
81950>>>>>
81950>>>>>        // Error Reporting Related
81950>>>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
81950>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
81951>>>>>
81951>>>>>        Property String Private.psUseDatabase ""
81952>>>>>
81952>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
81953>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
81954>>>>>
81954>>>>>        Property Handle phoSQLManagerMT
81955>>>>>
81955>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
81956>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
81957>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
81958>>>>>        Property Handle phoSQLConnectionHandler 0
81959>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
81960>>>>>
81960>>>>>        Property Boolean pbHandleQueryErrors True
81961>>>>>
81961>>>>>        Property tSqlColumnNew[] paQueryColumns
81962>>>>>        Property String[] paSQLFetchResults
81963>>>>>
81963>>>>>        // Error handling
81963>>>>>        Property Boolean pbSqlError False
81964>>>>>        Property tSqlErrorArray paSqlErrorArray
81965>>>>>        Property Boolean pbProcessingError False
81966>>>>>
81966>>>>>        // Statistics on query
81966>>>>>        Property TimeSpan ptsTotalQueryTime
81967>>>>>        Property TimeSpan ptsQueryExec
81968>>>>>        Property TimeSpan ptsFetchResults
81969>>>>>        Property Integer piColumns 0
81970>>>>>        Property Integer piRows 0
81971>>>>>        Property Integer piRowType 0
81972>>>>>        Property String[] paQueryMessages
81973>>>>>        Property String psSQLStatementString
81974>>>>>
81974>>>>>        Property Integer[] piTableConvertExceptions
81975>>>>>
81975>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
81975>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
81975>>>>>        // the statements in smaller chunks than to execute them all at the same time.
81975>>>>>        Property Integer piChunkMax 500
81976>>>>>        
81976>>>>>        // Fill the paSQLKeywordArray array with values;
81976>>>>>        Send SetupSQLKeywordArray
81977>>>>>    End_Procedure
81978>>>>>
81978>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
81978>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
81980>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
81982>>>>>            Function_Return (EQ)
81983>>>>>        End
81983>>>>>>
81983>>>>>        Function_Return (NE)
81984>>>>>    End_Function
81985>>>>>
81985>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
81985>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
81987>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) Begin
81989>>>>>            Function_Return (LT)
81990>>>>>        End
81990>>>>>>
81990>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) Begin
81992>>>>>            Function_Return (GT)
81993>>>>>        End
81993>>>>>>
81993>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) Begin
81995>>>>>            Function_Return (LT)
81996>>>>>        End
81996>>>>>>
81996>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) Begin
81998>>>>>            Function_Return (GT)
81999>>>>>        End
81999>>>>>>
81999>>>>>
81999>>>>>        Function_Return (EQ)
82000>>>>>    End_Function
82001>>>>>
82001>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
82003>>>>>        tSQLKeyWords[] SQLKeywordArray
82003>>>>>        tSQLKeyWords[] SQLKeywordArray
82004>>>>>        Integer iSize
82004>>>>>
82004>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82005>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
82006>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
82007>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
82008>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
82009>>>>>
82009>>>>>        Set paSQLKeywordArray to SQLKeywordArray
82010>>>>>    End_Procedure
82011>>>>>
82011>>>>>    // Creates a struct array with all SQL keywords
82011>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
82011>>>>>    // have slightly different wording.
82011>>>>>    // If a new EN_dbTypexxx type is added; additions
82011>>>>>    // needs to be done for every keyword group below.
82011>>>>>    Procedure SetupSQLKeywordArray
82013>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
82013>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
82015>>>>>
82015>>>>>        // This should only be called once; but in case it is
82015>>>>>        // we delete the array first.
82015>>>>>        Set paSQLKeywordArray to SQLKeywordArray
82016>>>>>
82016>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
82016>>>>>        //
82016>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
82017>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
82018>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
82019>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
82020>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
82021>>>>>
82021>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
82022>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
82023>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
82024>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
82025>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
82026>>>>>
82026>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
82027>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
82028>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
82029>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
82030>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
82031>>>>>
82031>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
82032>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
82033>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
82034>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
82035>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
82036>>>>>
82036>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
82037>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
82038>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
82039>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
82040>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
82041>>>>>
82041>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
82042>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
82043>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
82044>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
82045>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
82046>>>>>
82046>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
82047>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
82048>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
82049>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
82050>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
82051>>>>>
82051>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
82052>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
82053>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
82054>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
82055>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
82056>>>>>
82056>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
82057>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
82058>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
82059>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
82060>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
82061>>>>>
82061>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
82062>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
82063>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
82064>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
82065>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
82066>>>>>
82066>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_RENAME"
82067>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
82068>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
82069>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
82070>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
82071>>>>>
82071>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
82072>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
82073>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
82074>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
82075>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
82076>>>>>
82076>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
82077>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
82078>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
82079>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
82080>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
82081>>>>>
82081>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
82082>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
82083>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
82084>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
82085>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
82086>>>>>
82086>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
82087>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
82088>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
82089>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
82090>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
82091>>>>>
82091>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
82092>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
82093>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
82094>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
82095>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
82096>>>>>
82096>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
82097>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
82098>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
82099>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
82100>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
82101>>>>>
82101>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
82102>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
82103>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
82104>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
82105>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
82106>>>>>
82106>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
82107>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
82108>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
82109>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
82110>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
82111>>>>>
82111>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
82112>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
82113>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
82114>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
82115>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
82116>>>>>
82116>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
82117>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
82118>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
82119>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
82120>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
82121>>>>>
82121>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
82122>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
82123>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
82124>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
82125>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
82126>>>>>
82126>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
82127>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
82128>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
82129>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
82130>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
82131>>>>>
82131>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
82132>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
82133>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
82134>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
82135>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
82136>>>>>
82136>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
82137>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
82138>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
82139>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
82140>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
82141>>>>>
82141>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
82142>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
82143>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
82144>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
82145>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
82146>>>>>
82146>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
82147>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
82148>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
82149>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
82150>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
82151>>>>>
82151>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
82152>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
82153>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
82154>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
82155>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
82156>>>>>
82156>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
82157>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
82158>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
82159>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
82160>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
82161>>>>>
82161>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
82162>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
82163>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
82164>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
82165>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
82166>>>>>
82166>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
82167>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
82168>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
82169>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
82170>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
82171>>>>>
82171>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
82172>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
82173>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
82174>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
82175>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
82176>>>>>
82176>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
82177>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
82178>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
82179>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
82180>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
82181>>>>>
82181>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
82182>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
82183>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
82184>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
82185>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
82186>>>>>
82186>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
82187>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
82188>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
82189>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
82190>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
82191>>>>>
82191>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
82191>>>>>        Get paSQLKeywordArray to SQLKeywordArray
82192>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
82193>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
82194>>>>>
82194>>>>>    End_Procedure
82195>>>>>
82195>>>>>End_Class
82196>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
82196>>>>>//****************************************************************************
82196>>>>>// $Module type: Class
82196>>>>>// $Module name: cSQLConnectionHandler.pkg
82196>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
82196>>>>>// Web-site    : http://www.rdctools.com
82196>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
82196>>>>>//
82196>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
82196>>>>>//
82196>>>>>// $Rev History:
82196>>>>>//    2015-08-11  Module header created
82196>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
82196>>>>>//                Added a new structure for passing connection data back & forth.
82196>>>>>//                Added better error handling.
82196>>>>>//                Added a decompose message for the connection string.
82196>>>>>//    2017-01-09  Added support for Mertech drivers
82196>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
82196>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
82196>>>>>//    2017-02-12  Reworked the whole connection property interface.
82196>>>>>//                Now there is one struct property that is the at cencter of a connection.
82196>>>>>//****************************************************************************
82196>>>>>Use cli.pkg
82196>>>>>Use MSSqldrv.pkg
82196>>>>>Use db2_drv.pkg
82196>>>>>Use odbc_drv.pkg
82196>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
82196>>>>>>>//****************************************************************************
82196>>>>>>>// $Module type: Class
82196>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
82196>>>>>>>//
82196>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
82196>>>>>>>// Copyright (c) 2012 RDC Tools International
82196>>>>>>>// E-mail      : support@rdctools.com
82196>>>>>>>// Web-site    : http://www.rdctools.com
82196>>>>>>>//
82196>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
82196>>>>>>>//
82196>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
82196>>>>>>>//               properties of that object.
82196>>>>>>>//
82196>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
82196>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
82196>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
82196>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
82196>>>>>>>// in the help folder for more details.
82196>>>>>>>//
82196>>>>>>>Use cSQLConnectionIniFile.inc
82196>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
82196>>>>>>>>>Use cSQLConnectionIniFile.inc
82196>>>>>>>>>
82196>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
82197>>>>>>>>>    Procedure Construct_Object
82199>>>>>>>>>        Forward Send Construct_Object
82201>>>>>>>>>        Property String psDriverID DATAFLEX_ID
82202>>>>>>>>>    End_Procedure
82203>>>>>>>>>
82203>>>>>>>>>    Function ServerKeyword Returns String
82205>>>>>>>>>        Function_Return CS_SQLIniDSNKeyword
82206>>>>>>>>>    End_Function
82207>>>>>>>>>
82207>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82209>>>>>>>>>        String sConnect
82209>>>>>>>>>
82209>>>>>>>>>        Move (sConnect * ServerKeyword(Self) + "=" + sServer) to sConnect
82210>>>>>>>>>        If (sDatabase <> "") Begin
82212>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82213>>>>>>>>>        End
82213>>>>>>>>>>
82213>>>>>>>>>        If (bTrusted = True) Begin
82215>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82216>>>>>>>>>        End
82216>>>>>>>>>>
82216>>>>>>>>>        Else Begin
82217>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82218>>>>>>>>>        End
82218>>>>>>>>>>
82218>>>>>>>>>        Function_Return sConnect
82219>>>>>>>>>    End_Function
82220>>>>>>>>>
82220>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82222>>>>>>>>>        Boolean bLoginSuccessful
82222>>>>>>>>>        String sDriverID
82222>>>>>>>>>
82222>>>>>>>>>        Get psDriverID to sDriverID
82223>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
82225>>>>>>>>>            Function_Return True
82226>>>>>>>>>        End
82226>>>>>>>>>>
82226>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
82227>>>>>>>>>        If (bTrusted = False) Begin
82229>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82231>>>>>>>>>        End
82231>>>>>>>>>>
82231>>>>>>>>>        Else Begin
82232>>>>>>>>>            Login sConnectionString "" "" sDriverID
82234>>>>>>>>>        End
82234>>>>>>>>>>
82234>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
82235>>>>>>>>>        Function_Return bLoginSuccessful
82236>>>>>>>>>    End_Function
82237>>>>>>>>>End_Class
82238>>>>>>>>>
82238>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
82239>>>>>>>>>    Function ServerKeyword Returns String
82241>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
82242>>>>>>>>>    End_Function
82243>>>>>>>>>End_Class
82244>>>>>>>>>
82244>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
82245>>>>>>>>>End_Class
82246>>>>>>>>>
82246>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
82247>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82249>>>>>>>>>        Boolean bLoginSuccessful
82249>>>>>>>>>        String sDriverID
82249>>>>>>>>>
82249>>>>>>>>>        Move False to Err
82250>>>>>>>>>        Get psDriverID to sDriverID
82251>>>>>>>>>        If (not(Uppercase(sServer) contains "DSN")) Begin
82253>>>>>>>>>            Move ("DSN=" + sServer) to sServer
82254>>>>>>>>>        End
82254>>>>>>>>>>
82254>>>>>>>>>        Login sServer sUserId sPassword sDriverID
82256>>>>>>>>>
82256>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82257>>>>>>>>>        Function_Return bLoginSuccessful
82258>>>>>>>>>    End_Function
82259>>>>>>>>>End_Class
82260>>>>>>>>>
82260>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
82261>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82263>>>>>>>>>        Function_Return ""
82264>>>>>>>>>    End_Function
82265>>>>>>>>>End_Class
82266>>>>>>>>>
82266>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
82267>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82269>>>>>>>>>        Boolean bLoginSuccessful
82269>>>>>>>>>        String sDriverID
82269>>>>>>>>>
82269>>>>>>>>>        Get psDriverID to sDriverID
82270>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
82270>>>>>>>>>        Move False to Err
82271>>>>>>>>>        If (bTrusted = False) Begin
82273>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82275>>>>>>>>>        End
82275>>>>>>>>>>
82275>>>>>>>>>        Else Begin
82276>>>>>>>>>            Login sServer "" "" sDriverID
82278>>>>>>>>>        End
82278>>>>>>>>>>
82278>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82279>>>>>>>>>
82279>>>>>>>>>        Function_Return bLoginSuccessful
82280>>>>>>>>>    End_Function
82281>>>>>>>>>End_Class
82282>>>>>>>>>
82282>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
82283>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82285>>>>>>>>>        Boolean bLoginSuccessful
82285>>>>>>>>>        String sDriverID sErrorMsg
82285>>>>>>>>>        String sVal
82285>>>>>>>>>        Integer iPos
82285>>>>>>>>>
82285>>>>>>>>>        Get psDriverID to sDriverID
82286>>>>>>>>>        Move (Pos("/", sServer)) to iPos
82287>>>>>>>>>        If (iPos = 0) Begin
82289>>>>>>>>>            If (sDatabase <> "") Begin
82291>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
82292>>>>>>>>>            End
82292>>>>>>>>>>
82292>>>>>>>>>        End
82292>>>>>>>>>>
82292>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82292>>>>>>>>>        Move False to Err
82293>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
82293>>>>>>>>>        Login sServer sUserId sPassword sDriverID
82295>>>>>>>>>
82295>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82296>>>>>>>>>        Function_Return bLoginSuccessful
82297>>>>>>>>>    End_Function
82298>>>>>>>>>End_Class
82299>>>>>>>>>
82299>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
82300>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82302>>>>>>>>>        Boolean bLoginSuccessful
82302>>>>>>>>>        String sDriverID
82302>>>>>>>>>
82302>>>>>>>>>        Get psDriverID to sDriverID
82303>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82303>>>>>>>>>        Move False to Err
82304>>>>>>>>>        If (bTrusted = False) Begin
82306>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82308>>>>>>>>>        End
82308>>>>>>>>>>
82308>>>>>>>>>        Else Begin
82309>>>>>>>>>            Login sServer "" "" sDriverID
82311>>>>>>>>>        End
82311>>>>>>>>>>
82311>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82312>>>>>>>>>        Function_Return bLoginSuccessful
82313>>>>>>>>>    End_Function
82314>>>>>>>>>End_Class
82315>>>>>>>>>
82315>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
82316>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82318>>>>>>>>>        Boolean bLoginSuccessful
82318>>>>>>>>>        String sDriverID
82318>>>>>>>>>
82318>>>>>>>>>        Get psDriverID to sDriverID
82319>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
82319>>>>>>>>>        Move False to Err
82320>>>>>>>>>        If (bTrusted = False) Begin
82322>>>>>>>>>            Login sServer sUserId sPassword sDriverID
82324>>>>>>>>>        End
82324>>>>>>>>>>
82324>>>>>>>>>        Else Begin
82325>>>>>>>>>            Login sServer "" "" sDriverID
82327>>>>>>>>>        End
82327>>>>>>>>>>
82327>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
82328>>>>>>>>>        Function_Return bLoginSuccessful
82329>>>>>>>>>    End_Function
82330>>>>>>>>>End_Class
82331>>>>>>>>>
82331>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
82332>>>>>>>>>    Procedure Construct_Object
82334>>>>>>>>>        Forward Send Construct_Object
82336>>>>>>>>>        Property String psDriverID DATAFLEX_ID
82337>>>>>>>>>        Property Handle phoDriverSpecificObject
82338>>>>>>>>>    End_Procedure
82339>>>>>>>>>
82339>>>>>>>>>    Function CreateDriver Returns Handle
82341>>>>>>>>>        String sDriverID
82341>>>>>>>>>        Handle hoDriver hcDriverClass
82341>>>>>>>>>
82341>>>>>>>>>        Get psDriverID to sDriverID
82342>>>>>>>>>        Case Begin
82342>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82344>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
82345>>>>>>>>>                Case Break
82346>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
82349>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
82350>>>>>>>>>                Case Break
82351>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82354>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
82355>>>>>>>>>                Case Break
82356>>>>>>>>>            Case (sDriverID = SQLFLEX)
82359>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
82360>>>>>>>>>                Case Break
82361>>>>>>>>>            Case (sDriverID = ORAFLEX)
82364>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
82365>>>>>>>>>                Case Break
82366>>>>>>>>>            Case (sDriverID = MDSPgSQL)
82369>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
82370>>>>>>>>>                Case Break
82371>>>>>>>>>            Case (sDriverID = MDSMySQL)
82374>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
82375>>>>>>>>>                Case Break
82376>>>>>>>>>            // DATAFLEX_ID = Default driver
82376>>>>>>>>>            Case Else  
82376>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
82377>>>>>>>>>                Move DATAFLEX_ID to sDriverID
82378>>>>>>>>>        Case End
82378>>>>>>>>>
82378>>>>>>>>>        Get Create hcDriverClass to hoDriver
82379>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
82380>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
82381>>>>>>>>>
82381>>>>>>>>>        Function_Return hoDriver
82382>>>>>>>>>    End_Procedure
82383>>>>>>>>>
82383>>>>>>>>>    Procedure DestroyDriver
82385>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
82387>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
82388>>>>>>>>>        End
82388>>>>>>>>>>
82388>>>>>>>>>    End_Procedure
82389>>>>>>>>>
82389>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82391>>>>>>>>>        String sConnect
82391>>>>>>>>>        Handle hoDriver
82391>>>>>>>>>
82391>>>>>>>>>        Get CreateDriver to hoDriver
82392>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
82393>>>>>>>>>        Send DestroyDriver
82394>>>>>>>>>        Function_Return sConnect
82395>>>>>>>>>    End_Function
82396>>>>>>>>>
82396>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
82398>>>>>>>>>        Boolean bLoginSuccessful
82398>>>>>>>>>        Handle hoDriver
82398>>>>>>>>>
82398>>>>>>>>>        Get CreateDriver to hoDriver
82399>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
82400>>>>>>>>>        Send DestroyDriver
82401>>>>>>>>>        Function_Return bLoginSuccessful
82402>>>>>>>>>    End_Function
82403>>>>>>>>>
82403>>>>>>>>>End_Class
82404>>>>>>>
82404>>>>>>>Class cSQLConnectionIniFile is a cIniFile
82405>>>>>>>    Procedure Construct_Object
82407>>>>>>>        Forward Send Construct_Object
82409>>>>>>>
82409>>>>>>>        Property String Private_psIniFilePath
82410>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
82411>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
82412>>>>>>>
82412>>>>>>>//        { Visibility=Private }
82412>>>>>>>        Property Boolean pbDFConnId False
82413>>>>>>>
82413>>>>>>>        // We use Base64 coding instead of the cCryptographer class because the
82413>>>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
82413>>>>>>>//        { Visibility=Public }
82413>>>>>>>//        // *** You really want to change this value! ***
82413>>>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
82413>>>>>>>
82413>>>>>>>    End_Procedure
82414>>>>>>>
82414>>>>>>>    Procedure End_Construct_Object
82416>>>>>>>        Forward Send End_Construct_Object
82418>>>>>>>    End_Procedure
82419>>>>>>>
82419>>>>>>>    Procedure Set psIniFilePath String sPath
82421>>>>>>>        String sIniFile
82421>>>>>>>        Get vFolderFormat sPath to sPath
82422>>>>>>>        Set private_psIniFilePath to sPath
82423>>>>>>>        Get psIniFileName to sIniFile
82424>>>>>>>        Set psFileName to (sPath + sIniFile)
82425>>>>>>>    End_Procedure
82426>>>>>>>
82426>>>>>>>    Function psIniFilePath Returns String
82428>>>>>>>        Function_Return (private_psIniFilePath(Self))
82429>>>>>>>    End_Function
82430>>>>>>>
82430>>>>>>>    Procedure Set psIniFileName String sFileName
82432>>>>>>>        String sPath
82432>>>>>>>        Get psIniFilePath to sPath
82433>>>>>>>        Set psFileName to (sPath + sFileName)
82434>>>>>>>        Set private_psIniFileName to sFileName
82435>>>>>>>    End_Procedure
82436>>>>>>>
82436>>>>>>>    Function psIniFileName Returns String
82438>>>>>>>        Function_Return (private_psIniFileName(Self))
82439>>>>>>>    End_Function
82440>>>>>>>
82440>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
82440>>>>>>>    // Sets a value in the program's ini file (write)
82440>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
82440>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
82442>>>>>>>        String sIniFile sPath
82442>>>>>>>
82442>>>>>>>        Get psIniFilePath to sPath
82443>>>>>>>        Get psIniFileName to sIniFile
82444>>>>>>>        Move (sPath + sIniFile) to sIniFile
82445>>>>>>>        Set psFileName to sIniFile
82446>>>>>>>        Send WriteString sSection sValueName sValue
82447>>>>>>>    End_Procedure
82448>>>>>>>
82448>>>>>>>    // Get a value from program's ini-file (read)
82448>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
82448>>>>>>>    // Returns the value
82448>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
82450>>>>>>>        String sValue sIniFile sPath
82450>>>>>>>
82450>>>>>>>        Get psIniFilePath to sPath
82451>>>>>>>        Get psIniFileName to sIniFile
82452>>>>>>>        Move (sPath + sIniFile) to sIniFile
82453>>>>>>>        Set psFileName to sIniFile
82454>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
82455>>>>>>>
82455>>>>>>>        Function_Return sValue
82456>>>>>>>    End_Function
82457>>>>>>>
82457>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
82457>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
82459>>>>>>>        Integer iCheckboxCol
82459>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) Begin
82461>>>>>>>            Function_Return (LT)
82462>>>>>>>        End
82462>>>>>>>>
82462>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) Begin
82464>>>>>>>            Function_Return (GT)
82465>>>>>>>        End
82465>>>>>>>>
82465>>>>>>>
82465>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) Begin
82467>>>>>>>            Function_Return (LT)
82468>>>>>>>        End
82468>>>>>>>>
82468>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) Begin
82470>>>>>>>            Function_Return (GT)
82471>>>>>>>        End
82471>>>>>>>>
82471>>>>>>>
82471>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) Begin
82473>>>>>>>            Function_Return (LT)
82474>>>>>>>        End
82474>>>>>>>>
82474>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) Begin
82476>>>>>>>            Function_Return (GT)
82477>>>>>>>        End
82477>>>>>>>>
82477>>>>>>>
82477>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) Begin
82479>>>>>>>            Function_Return (LT)
82480>>>>>>>        End
82480>>>>>>>>
82480>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) Begin
82482>>>>>>>            Function_Return (GT)
82483>>>>>>>        End
82483>>>>>>>>
82483>>>>>>>
82483>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) Begin
82485>>>>>>>            Function_Return (LT)
82486>>>>>>>        End
82486>>>>>>>>
82486>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) Begin
82488>>>>>>>            Function_Return (GT)
82489>>>>>>>        End
82489>>>>>>>>
82489>>>>>>>
82489>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) Begin
82491>>>>>>>            Function_Return (LT)
82492>>>>>>>        End
82492>>>>>>>>
82492>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) Begin
82494>>>>>>>            Function_Return (GT)
82495>>>>>>>        End
82495>>>>>>>>
82495>>>>>>>
82495>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) Begin
82497>>>>>>>            Function_Return (LT)
82498>>>>>>>        End
82498>>>>>>>>
82498>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) Begin
82500>>>>>>>            Function_Return (GT)
82501>>>>>>>        End
82501>>>>>>>>
82501>>>>>>>
82501>>>>>>>        Function_Return (EQ)
82502>>>>>>>    End_Function
82503>>>>>>>
82503>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
82505>>>>>>>        Handle hoSections
82505>>>>>>>        Integer iItems
82505>>>>>>>
82505>>>>>>>        Send ReadSections hoSections
82506>>>>>>>        Move (Item_Count(hoSections)) to iItems
82507>>>>>>>        Function_Return iItems
82508>>>>>>>    End_Function
82509>>>>>>>
82509>>>>>>>    // The normal connection string looks something like this;
82509>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
82509>>>>>>>    // ...but the full connection string looks like this;
82509>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
82509>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
82509>>>>>>>//        String sSection
82509>>>>>>>//        Integer iCount
82509>>>>>>>//
82509>>>>>>>//        Move False to Err
82509>>>>>>>//        Get psIniSectionName to sSection
82509>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
82509>>>>>>>//        Increment iCount
82509>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
82509>>>>>>>//
82509>>>>>>>//        Function_Return (Err = False)
82509>>>>>>>//    End_Function
82509>>>>>>>
82509>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
82511>>>>>>>        Integer iCount
82511>>>>>>>        Boolean bExists
82511>>>>>>>        String sSection
82511>>>>>>>
82511>>>>>>>        Move False to Err
82512>>>>>>>        Move 1 to iCount
82513>>>>>>>        Get psIniSectionName to sSection
82514>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82515>>>>>>>        While (bExists = True)
82519>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
82520>>>>>>>            Increment iCount
82521>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82522>>>>>>>        Loop
82523>>>>>>>>
82523>>>>>>>        Function_Return (Err = False)
82524>>>>>>>    End_Function
82525>>>>>>>
82525>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
82527>>>>>>>        Integer iCount
82527>>>>>>>        String sSection
82527>>>>>>>        Boolean bExists
82527>>>>>>>
82527>>>>>>>        Move False to Err
82528>>>>>>>        Move 1 to iCount
82529>>>>>>>        Get psIniSectionName to sSection
82530>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
82531>>>>>>>        While (bExists = True)
82535>>>>>>>            If (iCount = iItem) Begin
82537>>>>>>>                Send DeleteSection sSection
82538>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
82538>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
82539>>>>>>>            End
82539>>>>>>>>
82539>>>>>>>            Increment iCount
82540>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
82541>>>>>>>        Loop
82542>>>>>>>>
82542>>>>>>>
82542>>>>>>>        Function_Return (Err = False)
82543>>>>>>>    End_Function
82544>>>>>>>
82544>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
82544>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
82544>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
82546>>>>>>>        tSQLConnection[] SQLConnectionsArray
82546>>>>>>>        tSQLConnection[] SQLConnectionsArray
82547>>>>>>>        tSQLConnection   SQLConnection
82547>>>>>>>        tSQLConnection   SQLConnection
82547>>>>>>>        Integer iIndex
82547>>>>>>>
82547>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
82548>>>>>>>        If (iIndex = -1) Begin
82550>>>>>>>            Move True to SQLConnection.bError
82551>>>>>>>            Function_Return SQLConnection
82552>>>>>>>        End
82552>>>>>>>>
82552>>>>>>>
82552>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82553>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
82554>>>>>>>
82554>>>>>>>        Function_Return SQLConnection
82555>>>>>>>    End_Function
82556>>>>>>>
82556>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
82556>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
82558>>>>>>>        tSQLConnection[] SQLConnectionsArray
82558>>>>>>>        tSQLConnection[] SQLConnectionsArray
82559>>>>>>>        Integer iRetval iCount iSize
82559>>>>>>>        String sValue
82559>>>>>>>        Boolean bExists
82559>>>>>>>
82559>>>>>>>        Move -1 to iRetval
82560>>>>>>>
82560>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82561>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82562>>>>>>>        Decrement iSize
82563>>>>>>>        For iCount from 0 to iSize
82569>>>>>>>>
82569>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
82570>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
82571>>>>>>>            If (bExists) Begin
82573>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
82574>>>>>>>                Move iSize to iCount         // We're done!
82575>>>>>>>            End
82575>>>>>>>>
82575>>>>>>>        Loop
82576>>>>>>>>
82576>>>>>>>
82576>>>>>>>        Function_Return iRetval
82577>>>>>>>    End_Function
82578>>>>>>>
82578>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
82578>>>>>>>    // Used to check that ConnectionID's are unique.
82578>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
82580>>>>>>>        Integer iCount iSize iItems
82580>>>>>>>        String sValue
82580>>>>>>>        Boolean bExists
82580>>>>>>>        tSQLConnection[] SQLConnectionsArray
82580>>>>>>>        tSQLConnection[] SQLConnectionsArray
82581>>>>>>>
82581>>>>>>>        Move 0 to iItems
82582>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82583>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82584>>>>>>>        Decrement iSize
82585>>>>>>>        For iCount from 0 to iSize
82591>>>>>>>>
82591>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
82592>>>>>>>            Move (sValue = sConnectionID) to bExists
82593>>>>>>>            If (bExists) Begin
82595>>>>>>>                Increment iItems
82596>>>>>>>            End
82596>>>>>>>>
82596>>>>>>>        Loop
82597>>>>>>>>
82597>>>>>>>
82597>>>>>>>        Function_Return (iItems > 1)
82598>>>>>>>    End_Function
82599>>>>>>>
82599>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
82599>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
82601>>>>>>>        Boolean bRetval bOK
82601>>>>>>>        Integer iItem iSize iCount
82601>>>>>>>        tSQLConnection[] SQLConnectionsArray
82601>>>>>>>        tSQLConnection[] SQLConnectionsArray
82602>>>>>>>        tSQLConnection SQLConnection
82602>>>>>>>        tSQLConnection SQLConnection
82602>>>>>>>        String sConnectionString
82602>>>>>>>
82602>>>>>>>        Move False to Err
82603>>>>>>>        Get psConnectionString to sConnectionString
82604>>>>>>>
82604>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82605>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82606>>>>>>>        Decrement iSize
82607>>>>>>>        // Set all current connection to inactive.
82607>>>>>>>        For iCount from 0 to iSize
82613>>>>>>>>
82613>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
82614>>>>>>>        Loop
82615>>>>>>>>
82615>>>>>>>
82615>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
82616>>>>>>>        Move True              to SQLConnection.bEnabled
82617>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
82618>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
82619>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
82620>>>>>>>
82620>>>>>>>        Function_Return (bOK = True)
82621>>>>>>>    End_Function
82622>>>>>>>
82622>>>>>>>    // Used for updating an existing connection with new data.
82622>>>>>>>    // Returns True if successful.
82622>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
82624>>>>>>>        Boolean bRetval bOK
82624>>>>>>>        Integer iItem iSize iCount
82624>>>>>>>        tSQLConnection[] SQLConnectionsArray
82624>>>>>>>        tSQLConnection[] SQLConnectionsArray
82625>>>>>>>
82625>>>>>>>        Move False to Err
82626>>>>>>>        Move -1 to iItem
82627>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
82628>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82629>>>>>>>        Decrement iSize
82630>>>>>>>        // Set all current connection to inactive.
82630>>>>>>>        For iCount from 0 to iSize
82636>>>>>>>>
82636>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
82637>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
82639>>>>>>>                Move iCount to iItem
82640>>>>>>>            End
82640>>>>>>>>
82640>>>>>>>        Loop
82641>>>>>>>>
82641>>>>>>>
82641>>>>>>>        If (iItem <> -1) Begin
82643>>>>>>>            Move True to SQLConnection.bEnabled
82644>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
82645>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
82646>>>>>>>        End
82646>>>>>>>>
82646>>>>>>>
82646>>>>>>>        Function_Return (bOK = True)
82647>>>>>>>    End_Function
82648>>>>>>>
82648>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
82650>>>>>>>        tSQLConnection[] SQLConnectionsArray
82650>>>>>>>        tSQLConnection[] SQLConnectionsArray
82651>>>>>>>        String sSection sValue
82651>>>>>>>        Integer iCount
82651>>>>>>>        Boolean bExists bEnabled
82651>>>>>>>
82651>>>>>>>        Get psIniSectionName to sSection
82652>>>>>>>        Get SectionExists sSection to bExists
82653>>>>>>>        If (bExists = False) Begin
82655>>>>>>>            Function_Return SQLConnectionsArray
82656>>>>>>>        End
82656>>>>>>>>
82656>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
82657>>>>>>>        If (bExists = True) Begin
82659>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
82660>>>>>>>>
82660>>>>>>>        End
82660>>>>>>>>
82660>>>>>>>
82660>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
82661>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82662>>>>>>>
82662>>>>>>>        While (bExists = True)
82666>>>>>>>            // We always put the enabled/active connection at the top
82666>>>>>>>            Move (iCount = 1) to bEnabled
82667>>>>>>>            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
82668>>>>>>>
82668>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
82669>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
82670>>>>>>>
82670>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
82670>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
82671>>>>>>>            If (sValue = "99") Begin
82673>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
82674>>>>>>>            End
82674>>>>>>>>
82674>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
82675>>>>>>>
82675>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
82676>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
82677>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
82679>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
82680>>>>>>>            End
82680>>>>>>>>
82680>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
82681>>>>>>>
82681>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
82682>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
82683>>>>>>>
82683>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
82684>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
82685>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
82687>>>>>>>                Get DecryptPassword sValue to sValue
82688>>>>>>>            End
82688>>>>>>>>
82688>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
82689>>>>>>>
82689>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
82689>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
82690>>>>>>>
82690>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
82691>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
82692>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
82693>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
82694>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to SQLConnectionsArray[iCount].bSilentLogin
82695>>>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
82695>>>>>>>
82695>>>>>>>            Increment iCount
82696>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
82697>>>>>>>        Loop
82698>>>>>>>>
82698>>>>>>>
82698>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
82698>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
82700>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
82701>>>>>>>        End
82701>>>>>>>>
82701>>>>>>>
82701>>>>>>>        Function_Return SQLConnectionsArray
82702>>>>>>>    End_Function
82703>>>>>>>
82703>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
82705>>>>>>>        Integer iCount iSize iItem
82705>>>>>>>        Boolean bIsOneActive bEnabled bExists bOK
82705>>>>>>>        String sConnectionString sSection sValue
82705>>>>>>>
82705>>>>>>>        // First we need to _remove_ all current connections in the ini-file, we
82705>>>>>>>        // do that by setting their values to "".
82705>>>>>>>        Move 0 to iCount
82706>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
82707>>>>>>>        If (bOK = False) Begin
82709>>>>>>>            Function_Return False
82710>>>>>>>        End
82710>>>>>>>>
82710>>>>>>>
82710>>>>>>>        Move False to Err
82711>>>>>>>        Get psIniSectionName to sSection
82712>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
82712>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
82713>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
82714>>>>>>>        Decrement iSize
82715>>>>>>>
82715>>>>>>>        For iCount from 0 to iSize
82721>>>>>>>>
82721>>>>>>>            // DF 19 compatible settings:
82721>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
82722>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
82723>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
82724>>>>>>>
82724>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
82725>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
82727>>>>>>>                Get EncryptPassword sValue to sValue
82728>>>>>>>            End
82728>>>>>>>>
82728>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
82729>>>>>>>
82729>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
82731>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
82732>>>>>>>            End
82732>>>>>>>>
82732>>>>>>>
82732>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
82733>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
82734>>>>>>>
82734>>>>>>>            // The Database Update Framework extended settings:
82734>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
82735>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
82736>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
82737>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
82738>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
82739>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to SQLConnectionsArray[iCount].bSilentLogin
82740>>>>>>>        Loop
82741>>>>>>>>
82741>>>>>>>
82741>>>>>>>        Function_Return (bOK and Err = False)
82742>>>>>>>    End_Function
82743>>>>>>>
82743>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
82743>>>>>>>    //
82743>>>>>>>    // SQL utility function that returns a database type (string) constant
82743>>>>>>>    // corresponding to the passed iDbType.
82743>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
82745>>>>>>>        String sRetval
82745>>>>>>>        If (iDbType = EN_dbTypeMSSQL)       Move CS_dbTypeMSSQL     to sRetval
82748>>>>>>>        If (iDbType = EN_dbTypeMySQL)       Move CS_dbTypeMySQL     to sRetval
82751>>>>>>>        If (iDbType = EN_dbTypeOracle)      Move CS_dbTypeOracle    to sRetval
82754>>>>>>>        If (iDbType = EN_dbTypeDB2)         Move CS_dbTypeDB2       to sRetval
82757>>>>>>>        If (iDbType = EN_dbTypePostgre)     Move CS_dbTypePostgre   to sRetval
82760>>>>>>>        Function_Return sRetval
82761>>>>>>>    End_Function
82762>>>>>>>
82762>>>>>>>    // SQL utility function that returns a database type constant (integer)
82762>>>>>>>    // corresponding to the passed sDbType string constant.
82762>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
82764>>>>>>>        Integer iRetval
82764>>>>>>>        If (sDbType = CS_dbTypeMSSQL)       Move EN_dbTypeMSSQL     to iRetval
82767>>>>>>>        If (sDbType = CS_dbTypeMySQL)       Move EN_dbTypeMySQL     to iRetval
82770>>>>>>>        If (sDbType = CS_dbTypeOracle)      Move EN_dbTypeOracle    to iRetval
82773>>>>>>>        If (sDbType = CS_dbTypeDB2)         Move EN_dbTypeDB2       to iRetval
82776>>>>>>>        If (sDbType = CS_dbTypePostgre)     Move EN_dbTypePostgre   to iRetval
82779>>>>>>>        Function_Return iRetval
82780>>>>>>>    End_Function
82781>>>>>>>
82781>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
82781>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
82781>>>>>>>    // the SQL Connection program's grid.
82781>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
82783>>>>>>>        String sRetval
82783>>>>>>>        If (iDbType = EN_dbTypeMSSQL)       Move "EN_dbTypeMSSQL"   to sRetval
82786>>>>>>>        If (iDbType = EN_dbTypeMySQL)       Move "EN_dbTypeMySQL"   to sRetval
82789>>>>>>>        If (iDbType = EN_dbTypeOracle)      Move "EN_dbTypeOracle"  to sRetval
82792>>>>>>>        If (iDbType = EN_dbTypeDB2)         Move "EN_dbTypeDB2"     to sRetval
82795>>>>>>>        If (iDbType = EN_dbTypePostgre)     Move "EN_dbTypePostgre" to sRetval
82798>>>>>>>        Function_Return sRetval
82799>>>>>>>    End_Function
82800>>>>>>>
82800>>>>>>>    // Pass a driver id and the function will return
82800>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
82800>>>>>>>    // quite work and always returns "MS SQL Server"
82800>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
82802>>>>>>>        Integer iRetval
82802>>>>>>>        If (sDriverID = MSSQLDRV_ID)  Move EN_dbTypeMSSQL     to iRetval
82805>>>>>>>        If (sDriverID = SQLFLEX)      Move EN_dbTypeMSSQL     to iRetval
82808>>>>>>>        If (sDriverID = ODBC_DRV_ID)  Move EN_dbTypeMSSQL     to iRetval
82811>>>>>>>        If (sDriverID = MDSMySQL)     Move EN_dbTypeMySQL     to iRetval
82814>>>>>>>        If (sDriverID = ORAFLEX)      Move EN_dbTypeOracle    to iRetval
82817>>>>>>>        If (sDriverID = DB2_DRV_ID)   Move EN_dbTypeDB2       to iRetval
82820>>>>>>>        If (sDriverID = MDSPgSQL)     Move EN_dbTypePostgre   to iRetval
82823>>>>>>>        Function_Return iRetval
82824>>>>>>>    End_Function
82825>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
82825>>>>>>>>
82825>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
82827>>>>>>>>    Integer iStart iEnd
82827>>>>>>>>    String sRetval
82827>>>>>>>>
82827>>>>>>>>    Move (Trim(sConnect)) to sConnect
82828>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
82829>>>>>>>>    If (iStart = 0) Begin
82831>>>>>>>>        Function_Return ""
82832>>>>>>>>    End
82832>>>>>>>>>
82832>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
82833>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
82834>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
82836>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
82837>>>>>>>>    End
82837>>>>>>>>>
82837>>>>>>>>    Else Begin
82838>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
82839>>>>>>>>    End
82839>>>>>>>>>
82839>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
82841>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
82842>>>>>>>>        Decrement iEnd
82843>>>>>>>>    End
82843>>>>>>>>>
82843>>>>>>>>    If (iEnd <> 0) Begin
82845>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
82846>>>>>>>>    End
82846>>>>>>>>>
82846>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
82847>>>>>>>>
82847>>>>>>>>    Function_Return (Trim(sRetval))
82848>>>>>>>>End_Function
82849>>>>>>>>
82849>>>>>>>>
82849>>>>>>>
82849>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
82851>>>>>>>        String sConnect
82851>>>>>>>        Handle hoDriver
82851>>>>>>>
82851>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
82852>>>>>>>        Set psDriverID of hoDriver to sDriverID
82853>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
82854>>>>>>>        Send Destroy   of hoDriver
82855>>>>>>>
82855>>>>>>>//        Case Begin
82855>>>>>>>//            Case (sDriverID = MSSQLDRV_ID)
82855>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
82855>>>>>>>//                If (sDatabase <> "") Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                If (bTrusted = True) Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                Else Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                Case Break
82855>>>>>>>//
82855>>>>>>>//            Case (sDriverID = ODBC_DRV_ID)
82855>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82855>>>>>>>//                If (sDatabase <> "") Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                If (bTrusted = True) Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                Else Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                Case Break
82855>>>>>>>//
82855>>>>>>>//            Case (sDriverID = DB2_DRV_ID)
82855>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82855>>>>>>>////                If (sDatabase <> "") Begin
82855>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82855>>>>>>>////                End
82855>>>>>>>////                If (bTrusted = True) Begin
82855>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82855>>>>>>>////                End
82855>>>>>>>////                Else Begin
82855>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82855>>>>>>>////                End
82855>>>>>>>//                Case Break
82855>>>>>>>//
82855>>>>>>>//            Case (sDriverID = SQLFLEX)
82855>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
82855>>>>>>>//                If (sDatabase <> "") Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                If (bTrusted = True) Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                Else Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                Case Break
82855>>>>>>>//
82855>>>>>>>//            Case (sDriverID = ORAFLEX)
82855>>>>>>>//                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
82855>>>>>>>//                    Move (sServer + "/" + sDatabase)                  to sServer
82855>>>>>>>//                End
82855>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82855>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82855>>>>>>>//                Case Break
82855>>>>>>>//
82855>>>>>>>//            Case (sDriverID = MDSPgSQL)
82855>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82855>>>>>>>//                If (sDatabase <> "") Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82855>>>>>>>//                Case Break
82855>>>>>>>//
82855>>>>>>>//            Case (sDriverID = MDSMySQL)
82855>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82855>>>>>>>//                If (sDatabase <> "") Begin
82855>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82855>>>>>>>//                End
82855>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
82855>>>>>>>//                Case Break
82855>>>>>>>//
82855>>>>>>>//            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
82855>>>>>>>//                Break
82855>>>>>>>//
82855>>>>>>>//            Case Else
82855>>>>>>>//                Move "" to sConnect
82855>>>>>>>//        Case End
82855>>>>>>>
82855>>>>>>>        Function_Return sConnect
82856>>>>>>>    End_Function
82857>>>>>>>
82857>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
82857>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
82859>>>>>>>        String sConnect
82859>>>>>>>
82859>>>>>>>        Case Begin
82859>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
82861>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
82862>>>>>>>                If (sDatabase <> "") Begin
82864>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82865>>>>>>>                End
82865>>>>>>>>
82865>>>>>>>                Case Break
82866>>>>>>>
82866>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
82869>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82870>>>>>>>                If (sDatabase <> "") Begin
82872>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82873>>>>>>>                End
82873>>>>>>>>
82873>>>>>>>                Case Break
82874>>>>>>>
82874>>>>>>>            Case (sDriverID = DB2_DRV_ID)
82877>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82878>>>>>>>                If (sDatabase <> "") Begin
82880>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82881>>>>>>>                End
82881>>>>>>>>
82881>>>>>>>                Case Break
82882>>>>>>>
82882>>>>>>>            Case (sDriverID = ORAFLEX)
82885>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82886>>>>>>>                If (sDatabase <> "") Begin
82888>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82889>>>>>>>                End
82889>>>>>>>>
82889>>>>>>>                Case Break
82890>>>>>>>
82890>>>>>>>            Case (sDriverID = MDSPgSQL)
82893>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82894>>>>>>>                If (sDatabase <> "") Begin
82896>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82897>>>>>>>                End
82897>>>>>>>>
82897>>>>>>>                Case Break
82898>>>>>>>
82898>>>>>>>            Case (sDriverID = MDSMySQL)
82901>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
82902>>>>>>>                If (sDatabase <> "") Begin
82904>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
82905>>>>>>>                End
82905>>>>>>>>
82905>>>>>>>                Case Break
82906>>>>>>>
82906>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
82909>>>>>>>                Break
82910>>>>>>>
82910>>>>>>>            Case Else
82910>>>>>>>                Move "" to sConnect
82911>>>>>>>        Case End
82911>>>>>>>
82911>>>>>>>        Function_Return sConnect
82912>>>>>>>    End_Function
82913>>>>>>>
82913>>>>>>>    // Use Base64
82913>>>>>>>    Function EncryptPassword String sPassword Returns String
82915>>>>>>>        String sRetval sHashString
82915>>>>>>>//        Handle hoCryptographer
82915>>>>>>>//
82915>>>>>>>//        Get psHashString to sHashString
82915>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
82915>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
82915>>>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
82915>>>>>>>//
82915>>>>>>>//        Send Destroy of hoCryptographer
82915>>>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
82916>>>>>>>        Function_Return sRetval
82917>>>>>>>    End_Function
82918>>>>>>>
82918>>>>>>>    Function DecryptPassword String sPassword Returns String
82920>>>>>>>        String sRetval sHashString
82920>>>>>>>//        Handle hoCryptographer
82920>>>>>>>//
82920>>>>>>>//        Get psHashString to sHashString
82920>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
82920>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
82920>>>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
82920>>>>>>>//
82920>>>>>>>//        Send Destroy of hoCryptographer
82920>>>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
82921>>>>>>>
82921>>>>>>>        Function_Return sRetval
82922>>>>>>>    End_Function
82923>>>>>>>
82923>>>>>>>    // Returns the full path of the Application (no trailing "\")
82923>>>>>>>    Function ApplicationPath Returns String
82925>>>>>>>        String sApplicationFileName sPath
82925>>>>>>>        Integer iNumChars iRetval
82925>>>>>>>
82925>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
82926>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
82927>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
82928>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
82929>>>>>>>        Move (CString(sApplicationFileName)) to sPath
82930>>>>>>>
82930>>>>>>>        Function_Return sPath
82931>>>>>>>    End_Function
82932>>>>>>>
82932>>>>>>>End_Class
82933>>>>>Use cDbUpdateDatabaseDriver.pkg
82933>>>>>
82933>>>>>// The cConnection class is the new SQL connections class for DF 19.
82933>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
82933>>>>>
82933>>>>>// We're making references to this object handle so we need it defined
82933>>>>>// here as well as for the cDbUpdateHandler class
82933>>>>>
82933>>>>>    Global_Variable Handle ghoSQLConnectionHandler
82933>>>>>
82933>>>>>Class cSQLConnectionHandler is a cObject
82934>>>>>
82934>>>>>    Procedure Construct_Object
82936>>>>>        Forward Send Construct_Object
82938>>>>>        Move Self to ghoSQLConnectionHandler
82939>>>>>
82939>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
82940>>>>>
82940>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
82940>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
82940>>>>>        // methods to this class.
82940>>>>>        Property Boolean pbUseConnectionID True
82941>>>>>        Property Boolean pbToANSI          True
82942>>>>>        Property Boolean pbRecnum          True
82943>>>>>        Property Boolean pbCopyData        True
82944>>>>>        Property Boolean pbCompareDate_DateTime  False
82945>>>>>        Property Boolean pbCompareIndexAscending False
82946>>>>>        Property Boolean pbCompareIndexUppercase False
82947>>>>>
82947>>>>>        // Driver default value settings:
82947>>>>>        // Note: When the object is created the corresponding values
82947>>>>>        // from the driver .int files are read.
82947>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
82947>>>>>        Property String psDriverDefaultValueASCII    ""
82948>>>>>        Property String psDriverDefaultValueBinary   ""
82949>>>>>        Property String psDriverDefaultValueDate     ""
82950>>>>>        Property String psDriverDefaultValueDateTime ""
82951>>>>>        Property String psDriverDefaultValueNumeric  ""
82952>>>>>        Property String psDriverDefaultValueText     ""
82953>>>>>
82953>>>>>        // Driver "nullability" settings:
82953>>>>>        // Note: When the object is created the corresponding values
82953>>>>>        // from the driver .int files are read.
82953>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
82953>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
82954>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
82955>>>>>        Property Boolean pbDriverDefaultNullableDate     False
82956>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
82957>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
82958>>>>>        Property Boolean pbDriverDefaultNullableText     False
82959>>>>>
82959>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
82959>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
82959>>>>>        //     driver interfaces.
82959>>>>>        //     There are also procedure/function pairs to set/get individual data members
82959>>>>>        //     of the struct they are all routed throu this struct property.
82959>>>>>        Property tSQLConnection Private.pSQLConnection
82960>>>>>
82960>>>>>    End_Procedure
82961>>>>>
82961>>>>>    Procedure End_Construct_Object
82963>>>>>        Boolean bReadSettings
82963>>>>>        tSQLConnection SQLConnection
82963>>>>>        tSQLConnection SQLConnection
82963>>>>>
82963>>>>>        Forward Send End_Construct_Object
82965>>>>>
82965>>>>>        // Now is the time to read and apply SQL connection settings.
82965>>>>>        Get SetupSQLConnection True to SQLConnection
82966>>>>>        Set Private.pSQLConnection to SQLConnection
82967>>>>>    End_Procedure
82968>>>>>
82968>>>>>    // *** Properties ***
82968>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
82968>>>>>    // private.pSQLConnection struct connection property. These "properties" are
82968>>>>>    // merely here for conveniance.
82968>>>>>    //
82968>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
82968>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
82968>>>>>    // This struct property contains all the connection data.
82968>>>>>    //
82968>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
82970>>>>>        Boolean bIsDaw bIsMertech bOK
82970>>>>>
82970>>>>>        Set Private.pSQLConnection to SQLConnection
82971>>>>>
82971>>>>>        // When starting a program we might not have a connection id yet:
82971>>>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
82973>>>>>            Procedure_Return
82974>>>>>        End
82974>>>>>>
82974>>>>>
82974>>>>>        // After we have set the class property we need to tell the DAW/Mertech
82974>>>>>        // driver interfaces about the change & make a new login.
82974>>>>>        Get SQLLogin SQLConnection to bOK
82975>>>>>        If (bOK = False) Begin
82977>>>>>            Error DFERR_PROGRAM "Login error."
82978>>>>>>
82978>>>>>        End
82978>>>>>>
82978>>>>>
82978>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
82978>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
82979>>>>>
82979>>>>>    End_Procedure
82980>>>>>
82980>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
82980>>>>>    // attempt to load the driver.
82980>>>>>    // Returns true if the passed driver is SQL based.
82980>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
82982>>>>>        Boolean bOK
82982>>>>>        Integer iDriver
82982>>>>>
82982>>>>>        Get IsDAWSQLDriver sDriverID to bOK
82983>>>>>
82983>>>>>        If (bOK = False) Begin
82985>>>>>            Get IsMertechDriver sDriverID to bOK
82986>>>>>        End
82986>>>>>>
82986>>>>>
82986>>>>>        Function_Return bOK
82987>>>>>    End_Function
82988>>>>>
82988>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
82988>>>>>    Procedure SetupDriverDefaults String sDriverID
82990>>>>>        String sAttributeValue
82990>>>>>        Integer iDriverID
82990>>>>>        Boolean bNULL bSQLDriver
82990>>>>>
82990>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
82991>>>>>        If (bSQLDriver = False) Begin
82993>>>>>            Procedure_Return
82994>>>>>        End
82994>>>>>>
82994>>>>>
82994>>>>>        Get DriverIndex sDriverID to iDriverID
82995>>>>>
82995>>>>>        // Driver default values for various data types:
82995>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
82998>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
82999>>>>>
82999>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
83002>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
83003>>>>>
83003>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
83006>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
83007>>>>>
83007>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
83010>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
83011>>>>>
83011>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
83014>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
83015>>>>>
83015>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
83018>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
83019>>>>>
83019>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
83019>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
83022>>>>>        Set pbDriverDefaultNullableASCII to bNULL
83023>>>>>
83023>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
83026>>>>>        Set pbDriverDefaultNullableBinary to bNULL
83027>>>>>
83027>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
83030>>>>>        Set pbDriverDefaultNullableDate to bNULL
83031>>>>>
83031>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
83034>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
83035>>>>>
83035>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
83038>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
83039>>>>>
83039>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
83042>>>>>        Set pbDriverDefaultNullableText to bNULL
83043>>>>>
83043>>>>>    End_Procedure
83044>>>>>
83044>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
83046>>>>>        Boolean bOK bIsDaw bIsMertech bTrusted
83046>>>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID sCheck
83046>>>>>        Handle hoErrorObj hoDriver hoIniFile
83046>>>>>        Integer iDriverID
83046>>>>>
83046>>>>>        Move False to bOK
83047>>>>>
83047>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
83048>>>>>        If (bIsDaw = False) Begin
83050>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
83051>>>>>            If (bIsMertech = False) Begin
83053>>>>>                Function_Return False
83054>>>>>            End
83054>>>>>>
83054>>>>>        End
83054>>>>>>
83054>>>>>
83054>>>>>        Move Error_Object_Id to hoErrorObj
83055>>>>>        Move Self to Error_Object_Id
83056>>>>>
83056>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83057>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
83058>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
83059>>>>>        If (iDriverID = 0) Begin
83061>>>>>            Move hoErrorObj to Error_Object_Id
83062>>>>>            Function_Return False
83063>>>>>        End
83063>>>>>>
83063>>>>>
83063>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
83063>>>>>        If (bIsMertech = False) Begin
83065>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
83068>>>>>        End
83068>>>>>>
83068>>>>>
83068>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83069>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
83070>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
83071>>>>>        Send Destroy   of hoDriver
83072>>>>>        Move hoErrorObj to Error_Object_Id
83073>>>>>
83073>>>>>        Function_Return bOK
83074>>>>>    End_Function
83075>>>>>
83075>>>>>    Function pSQLConnection Returns tSQLConnection
83077>>>>>        tSQLConnection SQLConnection
83077>>>>>        tSQLConnection SQLConnection
83077>>>>>        Get Private.pSQLConnection to SQLConnection
83078>>>>>        Function_Return SQLConnection
83079>>>>>    End_Function
83080>>>>>
83080>>>>>    Procedure Set psConnectionID String sValue
83082>>>>>        tSQLConnection SQLConnection
83082>>>>>        tSQLConnection SQLConnection
83082>>>>>        Integer iIndex
83082>>>>>
83082>>>>>        Get Private.pSQLConnection to SQLConnection
83083>>>>>        If (SQLConnection.sConnectionID = "") Begin
83085>>>>>            Move sValue to SQLConnection.sConnectionID
83086>>>>>        End
83086>>>>>>
83086>>>>>
83086>>>>>        // Else we might want to change the current connection ID
83086>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
83089>>>>>            Move False to Err
83090>>>>>            Logout SQLConnection.sDriverID
83091>>>>>            // This will also make a login to the new server.
83091>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
83092>>>>>        End
83092>>>>>>
83092>>>>>        Set pSQLConnection to SQLConnection
83093>>>>>    End_Procedure
83094>>>>>
83094>>>>>    Function psConnectionID Returns String
83096>>>>>        tSQLConnection SQLConnection
83096>>>>>        tSQLConnection SQLConnection
83096>>>>>        Get Private.pSQLConnection to SQLConnection
83097>>>>>        Function_Return SQLConnection.sConnectionID
83098>>>>>    End_Procedure
83099>>>>>
83099>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
83099>>>>>    //       the psDriverID *must* be the first property that is changed!
83099>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
83099>>>>>    //       for a connection string has the wrong format for that driver.
83099>>>>>    Procedure Set psDriverID String sValue
83101>>>>>        tSQLConnection SQLConnection
83101>>>>>        tSQLConnection SQLConnection
83101>>>>>        Get pSQLConnection to SQLConnection
83102>>>>>        Move sValue        to SQLConnection.sDriverID
83103>>>>>        Set pSQLConnection to SQLConnection
83104>>>>>        If (sValue <> DATAFLEX_ID) Begin
83106>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83107>>>>>        End
83107>>>>>>
83107>>>>>    End_Procedure
83108>>>>>
83108>>>>>    Function psDriverID Returns String
83110>>>>>        tSQLConnection SQLConnection
83110>>>>>        tSQLConnection SQLConnection
83110>>>>>        Get Private.pSQLConnection to SQLConnection
83111>>>>>        If (SQLConnection.sDriverID = "") Begin
83113>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
83114>>>>>        End
83114>>>>>>
83114>>>>>        Function_Return SQLConnection.sDriverID
83115>>>>>    End_Function
83116>>>>>
83116>>>>>    Procedure Set psConnectionString String sValue
83118>>>>>        tSQLConnection SQLConnection
83118>>>>>        tSQLConnection SQLConnection
83118>>>>>        Get Private.pSQLConnection to SQLConnection
83119>>>>>        Move sValue        to SQLConnection.sConnectionString
83120>>>>>        Set pSQLConnection to SQLConnection
83121>>>>>    End_Procedure
83122>>>>>
83122>>>>>    Function psConnectionString Returns String
83124>>>>>        tSQLConnection SQLConnection
83124>>>>>        tSQLConnection SQLConnection
83124>>>>>        Get Private.pSQLConnection to SQLConnection
83125>>>>>        Function_Return SQLConnection.sConnectionString
83126>>>>>    End_Function
83127>>>>>
83127>>>>>    Procedure Set psServer String sValue
83129>>>>>        tSQLConnection SQLConnection
83129>>>>>        tSQLConnection SQLConnection
83129>>>>>        Get Private.pSQLConnection to SQLConnection
83130>>>>>        Move sValue        to SQLConnection.sServer
83131>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83132>>>>>        Set pSQLConnection to SQLConnection
83133>>>>>    End_Procedure
83134>>>>>
83134>>>>>    Function psServer Returns String
83136>>>>>        tSQLConnection SQLConnection
83136>>>>>        tSQLConnection SQLConnection
83136>>>>>        Get Private.pSQLConnection to SQLConnection
83137>>>>>        Function_Return SQLConnection.sServer
83138>>>>>    End_Function
83139>>>>>
83139>>>>>    Procedure Set psDatabase String sValue
83141>>>>>        tSQLConnection SQLConnection
83141>>>>>        tSQLConnection SQLConnection
83141>>>>>        Get Private.pSQLConnection to SQLConnection
83142>>>>>        Move sValue        to SQLConnection.sDatabase
83143>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83144>>>>>        Set pSQLConnection to SQLConnection
83145>>>>>    End_Procedure
83146>>>>>
83146>>>>>    Function psDatabase Returns String
83148>>>>>        tSQLConnection SQLConnection
83148>>>>>        tSQLConnection SQLConnection
83148>>>>>        Get Private.pSQLConnection to SQLConnection
83149>>>>>        Function_Return SQLConnection.sDatabase
83150>>>>>    End_Function
83151>>>>>
83151>>>>>    Procedure Set psUserID String sValue
83153>>>>>        tSQLConnection SQLConnection
83153>>>>>        tSQLConnection SQLConnection
83153>>>>>        Get Private.pSQLConnection to SQLConnection
83154>>>>>        Move sValue        to SQLConnection.sUserID
83155>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83156>>>>>        Set pSQLConnection to SQLConnection
83157>>>>>    End_Procedure
83158>>>>>
83158>>>>>    Function psUserID Returns String
83160>>>>>        tSQLConnection SQLConnection
83160>>>>>        tSQLConnection SQLConnection
83160>>>>>        Get Private.pSQLConnection to SQLConnection
83161>>>>>        Function_Return SQLConnection.sUserID
83162>>>>>    End_Function
83163>>>>>
83163>>>>>    // This is the uncrypted password
83163>>>>>    Procedure Set psPassword String sValue
83165>>>>>        tSQLConnection SQLConnection
83165>>>>>        tSQLConnection SQLConnection
83165>>>>>        Get Private.pSQLConnection to SQLConnection
83166>>>>>        Move sValue        to SQLConnection.sPassword
83167>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83168>>>>>        Set pSQLConnection to SQLConnection
83169>>>>>    End_Procedure
83170>>>>>
83170>>>>>    Function psPassword Returns String
83172>>>>>        tSQLConnection SQLConnection
83172>>>>>        tSQLConnection SQLConnection
83172>>>>>        Get Private.pSQLConnection to SQLConnection
83173>>>>>        Function_Return SQLConnection.sPassword
83174>>>>>    End_Function
83175>>>>>
83175>>>>>    Procedure Set pbTrusted Boolean bValue
83177>>>>>        tSQLConnection SQLConnection
83177>>>>>        tSQLConnection SQLConnection
83177>>>>>        Get Private.pSQLConnection to SQLConnection
83178>>>>>        Move bValue        to SQLConnection.bTrusted
83179>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
83180>>>>>        Set pSQLConnection to SQLConnection
83181>>>>>    End_Procedure
83182>>>>>
83182>>>>>    Function pbTrusted Returns Boolean
83184>>>>>        tSQLConnection SQLConnection
83184>>>>>        tSQLConnection SQLConnection
83184>>>>>        Get Private.pSQLConnection to SQLConnection
83185>>>>>        Function_Return SQLConnection.bTrusted
83186>>>>>    End_Function
83187>>>>>
83187>>>>>    // *** All of these properties are special to the Database Update Framework ***
83187>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
83187>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
83187>>>>>    //     the central pSQLConnection "hub".
83187>>>>>    Procedure Set pbSilentLogin Boolean bValue
83189>>>>>        tSQLConnection SQLConnection
83189>>>>>        tSQLConnection SQLConnection
83189>>>>>        Get Private.pSQLConnection to SQLConnection
83190>>>>>        Move bValue to SQLConnection.bTrusted
83191>>>>>        Set Private.pSQLConnection to SQLConnection
83192>>>>>    End_Procedure
83193>>>>>
83193>>>>>    Function pbSilentLogin Returns Boolean
83195>>>>>        tSQLConnection SQLConnection
83195>>>>>        tSQLConnection SQLConnection
83195>>>>>        Get Private.pSQLConnection to SQLConnection
83196>>>>>        Function_Return SQLConnection.bSilentLogin
83197>>>>>    End_Function
83198>>>>>
83198>>>>>    Procedure Set piDbType Integer iValue
83200>>>>>        tSQLConnection SQLConnection
83200>>>>>        tSQLConnection SQLConnection
83200>>>>>        Get Private.pSQLConnection to SQLConnection
83201>>>>>        Move iValue to SQLConnection.iDbType
83202>>>>>        Set Private.pSQLConnection to SQLConnection
83203>>>>>    End_Procedure
83204>>>>>
83204>>>>>    Function piDbType Returns Integer
83206>>>>>        tSQLConnection SQLConnection
83206>>>>>        tSQLConnection SQLConnection
83206>>>>>        Get Private.pSQLConnection to SQLConnection
83207>>>>>        Function_Return SQLConnection.iDbType
83208>>>>>    End_Function
83209>>>>>
83209>>>>>    Procedure Set psBaseTableSpace String sValue
83211>>>>>        tSQLConnection SQLConnection
83211>>>>>        tSQLConnection SQLConnection
83211>>>>>        Get Private.pSQLConnection to SQLConnection
83212>>>>>        Move sValue to SQLConnection.sBaseTableSpace
83213>>>>>        Set Private.pSQLConnection to SQLConnection
83214>>>>>    End_Procedure
83215>>>>>
83215>>>>>    Function psBaseTableSpace Returns String
83217>>>>>        tSQLConnection SQLConnection
83217>>>>>        tSQLConnection SQLConnection
83217>>>>>        Get Private.pSQLConnection to SQLConnection
83218>>>>>        Function_Return SQLConnection.sBaseTableSpace
83219>>>>>    End_Function
83220>>>>>
83220>>>>>    Procedure Set psIndexTableSpace String sValue
83222>>>>>        tSQLConnection SQLConnection
83222>>>>>        tSQLConnection SQLConnection
83222>>>>>        Get Private.pSQLConnection to SQLConnection
83223>>>>>        Move sValue to SQLConnection.sIndexTableSpace
83224>>>>>        Set Private.pSQLConnection to SQLConnection
83225>>>>>    End_Procedure
83226>>>>>
83226>>>>>    Function psIndexTableSpace Returns String
83228>>>>>        tSQLConnection SQLConnection
83228>>>>>        tSQLConnection SQLConnection
83228>>>>>        Get Private.pSQLConnection to SQLConnection
83229>>>>>        Function_Return SQLConnection.sIndexTableSpace
83230>>>>>    End_Function
83231>>>>>
83231>>>>>    Procedure Set psLongTableSpace String sValue
83233>>>>>        tSQLConnection SQLConnection
83233>>>>>        tSQLConnection SQLConnection
83233>>>>>        Get Private.pSQLConnection to SQLConnection
83234>>>>>        Move sValue to SQLConnection.sLongTableSpace
83235>>>>>        Set Private.pSQLConnection to SQLConnection
83236>>>>>    End_Procedure
83237>>>>>
83237>>>>>    Function psLongTableSpace Returns String
83239>>>>>        tSQLConnection SQLConnection
83239>>>>>        tSQLConnection SQLConnection
83239>>>>>        Get Private.pSQLConnection to SQLConnection
83240>>>>>        Function_Return SQLConnection.sLongTableSpace
83241>>>>>    End_Function
83242>>>>>
83242>>>>>    Procedure Set psSchema String sValue
83244>>>>>        tSQLConnection SQLConnection
83244>>>>>        tSQLConnection SQLConnection
83244>>>>>        Get Private.pSQLConnection to SQLConnection
83245>>>>>        Move sValue to SQLConnection.sSchema
83246>>>>>        Set Private.pSQLConnection to SQLConnection
83247>>>>>    End_Procedure
83248>>>>>
83248>>>>>    Function psSchema Returns String
83250>>>>>        tSQLConnection SQLConnection
83250>>>>>        tSQLConnection SQLConnection
83250>>>>>        Get Private.pSQLConnection to SQLConnection
83251>>>>>        Function_Return SQLConnection.sSchema
83252>>>>>    End_Function
83253>>>>>
83253>>>>>    Procedure Set pbEnabled Boolean bValue
83255>>>>>        tSQLConnection SQLConnection
83255>>>>>        tSQLConnection SQLConnection
83255>>>>>        Get Private.pSQLConnection to SQLConnection
83256>>>>>        Move bValue to SQLConnection.bEnabled
83257>>>>>        Set Private.pSQLConnection to SQLConnection
83258>>>>>    End_Procedure
83259>>>>>
83259>>>>>    Function pbEnabled Returns Boolean
83261>>>>>        tSQLConnection SQLConnection
83261>>>>>        tSQLConnection SQLConnection
83261>>>>>        Get Private.pSQLConnection to SQLConnection
83262>>>>>        Function_Return SQLConnection.bEnabled
83263>>>>>    End_Function
83264>>>>>
83264>>>>>
83264>>>>>    // ************************************
83264>>>>>    Function SetupSQLConnection Boolean bReadSettings Returns tSQLConnection
83266>>>>>        tSQLConnection SQLConnection
83266>>>>>        tSQLConnection SQLConnection
83266>>>>>
83266>>>>>        // If this object was created by the cDbUpdateHandler class we will
83266>>>>>        // deferr reading SQL connection values until later.
83266>>>>>        If (bReadSettings = True) Begin
83268>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
83268>>>>>            If (ghoConnection > 0) Begin
83270>>>>>                Get ReadcConnections to SQLConnection
83271>>>>>            End
83271>>>>>>
83271>>>>>
83271>>>>>            // In addition to the above; there might be other values set even if a cConnection
83271>>>>>            // object is used.
83271>>>>>            Get ReadSQLConnectionsIniSettings to SQLConnection
83272>>>>>        End
83272>>>>>>
83272>>>>>
83272>>>>>        Function_Return SQLConnection
83273>>>>>    End_Function
83274>>>>>
83274>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
83274>>>>>    Function ReadcConnections Returns tSQLConnection
83276>>>>>        tConnection Connection
83276>>>>>        tConnection Connection
83276>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83276>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83276>>>>>        Integer iCount iSize iRetval iDbType
83276>>>>>        Boolean bOK bEnabled bConnected bVal
83276>>>>>        String sConnectionID sSchema
83276>>>>>
83276>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
83276>>>>>            // - and there are multiple connection id's defined for the same driver. This is
83276>>>>>            //   because otherwise we can't possibly know which connection id to use... So
83276>>>>>            //   we then generate an error and abort the program...
83276>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
83277>>>>>            If (bOK = False) Begin
83279>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
83280>>>>>>
83280>>>>>                Abort
83281>>>>>>
83281>>>>>            End
83281>>>>>>
83281>>>>>
83281>>>>>            Move 0 to iRetval
83282>>>>>            // DAW DF19 connection info:
83282>>>>>            // We first check that the connection is OK:
83282>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
83283>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
83283>>>>>            If (iRetval = -1) Begin
83285>>>>>                Function_Return SQLConnectionEmpty
83286>>>>>            End
83286>>>>>>
83286>>>>>
83286>>>>>            If (sConnectionID <> "") Begin
83288>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
83289>>>>>            End
83289>>>>>>
83289>>>>>            If (Connection.sId = "") Begin
83291>>>>>                Move True to SQLConnectionEmpty.bError
83292>>>>>                Function_Return SQLConnectionEmpty
83293>>>>>            End
83293>>>>>>
83293>>>>>
83293>>>>>            Move Connection.sId to sConnectionID
83294>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
83295>>>>>
83295>>>>>            If (bConnected = False) Begin
83297>>>>>                Get LoginConnectionId of ghoConnection to iRetval
83298>>>>>                If (iRetval <> 0) Begin
83300>>>>>                    Send UserError CS_DUF_CannotLoginToServer
83301>>>>>                    Send Exit_Application
83302>>>>>                End
83302>>>>>>
83302>>>>>            End
83302>>>>>>
83302>>>>>
83302>>>>>            // DUF connection info struct property:
83302>>>>>            Get Private.pSQLConnection                       to SQLConnection
83303>>>>>            Move True                                        to SQLConnection.bEnabled
83304>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
83305>>>>>
83305>>>>>            // Not used in DUF:
83305>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
83305>>>>>
83305>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
83306>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
83307>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
83308>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
83309>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
83310>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
83311>>>>>
83311>>>>>            // Not used in DUF:
83311>>>>>            // Move Connection.sSection to SQLConnection.xxx
83311>>>>>
83311>>>>>            // The rest of the properties of the SQLConnection struct should have been
83311>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
83311>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
83313>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniServerKeyword to SQLConnection.sServer
83314>>>>>            End
83314>>>>>>
83314>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
83316>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniDSNKeyword    to SQLConnection.sServer
83317>>>>>            End
83317>>>>>>
83317>>>>>            Get ParseKeyWord Connection.sString CS_SQLIniDatabaseKeyword   to SQLConnection.sDatabase
83318>>>>>
83318>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
83318>>>>>            // the value from the driver id:
83318>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
83319>>>>>            // ...but in case it has been explicitly set in the object we use that value.
83319>>>>>            Get piDbType                                     to iDbType
83320>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
83322>>>>>                Move iDbType to SQLConnection.iDbType
83323>>>>>            End
83323>>>>>>
83323>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
83324>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
83325>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
83326>>>>>            Get psSchema                                     to SQLConnection.sSchema
83327>>>>>
83327>>>>>            // We finally set the struct property to the newly fetched values.
83327>>>>>            Set pSQLConnection to SQLConnection
83328>>>>>
83328>>>>>        Function_Return SQLConnection
83329>>>>>    End_Function
83330>>>>>
83330>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
83330>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
83330>>>>>    // connection id for a particular driver.
83330>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
83330>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
83330>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
83330>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
83330>>>>>    // connections of the DAW cConnect class.
83330>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
83332>>>>>        tConnection[] ConnIdArray
83332>>>>>        tConnection[] ConnIdArray
83333>>>>>        Integer iCount iSize iConnectionIDCounter
83333>>>>>        Boolean bOK bEnabled bFound
83333>>>>>        String sConnectionID2 sDriverID sDriverConn
83333>>>>>
83333>>>>>        Move False to bFound
83334>>>>>        If (ghoConnection > 0) Begin
83336>>>>>
83336>>>>>            // The property of the cDbUpdateHandler container object
83336>>>>>            Get psDriverID to sDriverID
83337>>>>>
83337>>>>>            Move 0 to iConnectionIDCounter
83338>>>>>            // This is the the DAW cConnect array with all registered connection id's.
83338>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
83339>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
83340>>>>>            Decrement iSize
83341>>>>>            For iCount from 0 to iSize
83347>>>>>>
83347>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
83348>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
83349>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
83350>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
83350>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
83350>>>>>                If (sConnectionID = "") Begin
83352>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
83353>>>>>                End
83353>>>>>>
83353>>>>>                Else Begin
83354>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
83356>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
83357>>>>>                    End
83357>>>>>>
83357>>>>>                End
83357>>>>>>
83357>>>>>
83357>>>>>                If (bFound = True) Begin
83359>>>>>                    Increment iConnectionIDCounter
83360>>>>>                End
83360>>>>>>
83360>>>>>            Loop
83361>>>>>>
83361>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
83362>>>>>            If (bFound = True) Begin
83364>>>>>                Move sConnectionID2 to sConnectionID
83365>>>>>            End
83365>>>>>>
83365>>>>>        End
83365>>>>>>
83365>>>>>
83365>>>>>        // Special case; a cConnection object has been setup in the cApplication,
83365>>>>>        // but no DFConn.ini record has been created.
83365>>>>>        If (iSize = -1) Begin
83367>>>>>            Move True to bFound
83368>>>>>        End
83368>>>>>>
83368>>>>>
83368>>>>>        Function_Return bFound
83369>>>>>    End_Function
83370>>>>>
83370>>>>>    // Send on object creation to read the default connection string settings, and
83370>>>>>    // create a connection to the server.
83370>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
83372>>>>>        String sPath sFileName sSection sConnectionString sPassword
83372>>>>>        Boolean bExists
83372>>>>>        tSQLConnection[] SQLConnectionArray
83372>>>>>        tSQLConnection[] SQLConnectionArray
83373>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83373>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
83373>>>>>        Handle hoIniFile
83373>>>>>        Integer iSize iCount
83373>>>>>
83373>>>>>        Get psIniFilePath to sPath
83374>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83375>>>>>        If (sPath = "") Begin
83377>>>>>            Get ApplicationPath of hoIniFile to sPath
83378>>>>>            Set psIniFilePath   of hoIniFile to sPath
83379>>>>>        End
83379>>>>>>
83379>>>>>        Get vFolderFormat sPath to sPath
83380>>>>>        Get psIniFileName to sFileName
83381>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
83382>>>>>
83382>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
83383>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
83384>>>>>        If (iSize = 0) Begin
83386>>>>>            // This may have been set by the "ReadcConnections" function,
83386>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
83386>>>>>            // in the cApplication object.
83386>>>>>            Get pSQLConnection to SQLConnection
83387>>>>>            If (SQLConnection.sConnectionID = "") Begin
83389>>>>>                Function_Return SQLConnectionEmpty
83390>>>>>            End
83390>>>>>>
83390>>>>>            Move SQLConnection to SQLConnectionArray[0]
83391>>>>>        End
83391>>>>>>
83391>>>>>
83391>>>>>        // The first connection should be the one that is active, but just in case...
83391>>>>>        Decrement iSize
83392>>>>>        For iCount from 0 to iSize
83398>>>>>>
83398>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
83399>>>>>            If (SQLConnection.bEnabled = True) Begin
83401>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
83402>>>>>            End
83402>>>>>>
83402>>>>>        Loop
83403>>>>>>
83403>>>>>
83403>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
83404>>>>>
83404>>>>>        Set pSQLConnection to SQLConnection
83405>>>>>        Send AutoSetConnectionID
83406>>>>>
83406>>>>>        Function_Return SQLConnection
83407>>>>>    End_Function
83408>>>>>
83408>>>>>    Procedure Set psIniFilePath String sPath
83410>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
83411>>>>>    End_Procedure
83412>>>>>
83412>>>>>    Function psIniFilePath Returns String
83414>>>>>        String sRetval
83414>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
83415>>>>>        Function_Return sRetval
83416>>>>>    End_Function
83417>>>>>
83417>>>>>    Procedure Set psIniFileName String sFileName
83419>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
83420>>>>>    End_Procedure
83421>>>>>
83421>>>>>    Function psIniFileName Returns String
83423>>>>>        String sRetval
83423>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
83424>>>>>        Function_Return sRetval
83425>>>>>    End_Function
83426>>>>>
83426>>>>>    // We use Base64 coding instead of the cCryptographer class because the
83426>>>>>    // password will get scrambled while writing/reading to/from the ini-file.
83426>>>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
83426>>>>>//    Procedure Set psHashString String sHashString
83426>>>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
83426>>>>>//    End_Procedure
83426>>>>>//
83426>>>>>//    Function psHashString Returns String
83426>>>>>//        String sRetval
83426>>>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
83426>>>>>//        Function_Return sRetval
83426>>>>>//    End_Function
83426>>>>>
83426>>>>>    Procedure Set psIniSectionName String sSection
83428>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
83429>>>>>    End_Procedure
83430>>>>>
83430>>>>>    Function psIniSectionName Returns String
83432>>>>>        String sRetval
83432>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
83433>>>>>        Function_Return sRetval
83434>>>>>    End_Function
83435>>>>>
83435>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
83437>>>>>        Handle ho
83437>>>>>        Get phoSQLConnectionIniFile to ho
83438>>>>>        Set IniFileValue of ho to sSection sValueName sValue
83439>>>>>    End_Procedure
83440>>>>>
83440>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
83442>>>>>        Handle ho
83442>>>>>        String sRetval
83442>>>>>        Get phoSQLConnectionIniFile to ho
83443>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
83444>>>>>        Function_Return sRetval
83445>>>>>    End_Function
83446>>>>>
83446>>>>>    Function SectionExists String sSection Returns Boolean
83448>>>>>        Handle ho
83448>>>>>        Boolean bRetval
83448>>>>>        Get phoSQLConnectionIniFile to ho
83449>>>>>        Get SectionExists of ho sSection to bRetval
83450>>>>>        Function_Return bRetval
83451>>>>>    End_Function
83452>>>>>
83452>>>>>    Function KeyExists String sSection String sKey Returns Boolean
83454>>>>>        Handle ho
83454>>>>>        Boolean bRetval
83454>>>>>        Get phoSQLConnectionIniFile to ho
83455>>>>>        Get KeyExists of ho sSection sKey to bRetval
83456>>>>>        Function_Return bRetval
83457>>>>>    End_Function
83458>>>>>
83458>>>>>    Function EncryptPassword String sPassword Returns String
83460>>>>>        Handle ho
83460>>>>>        String sRetval
83460>>>>>        Get phoSQLConnectionIniFile to ho
83461>>>>>        Get EncryptPassword of ho sPassword to sRetval
83462>>>>>        Function_Return sRetval
83463>>>>>    End_Function
83464>>>>>
83464>>>>>    Function DecryptPassword String sPassword Returns String
83466>>>>>        Handle ho
83466>>>>>        String sRetval
83466>>>>>        Get phoSQLConnectionIniFile to ho
83467>>>>>        Get DecryptPassword of ho sPassword to sRetval
83468>>>>>        Function_Return sRetval
83469>>>>>    End_Function
83470>>>>>
83470>>>>>    // *** Main Connection Message ***
83470>>>>>    // It will create a Connection ID for the passed driver.
83470>>>>>    // It will also set the psDriverID & psConnectionID of this class.
83470>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
83472>>>>>        Integer iResult
83472>>>>>        Handle hoCLI hoDriver
83472>>>>>        String sConnectionString sError
83472>>>>>        Boolean bMertech bLoginSuccessful
83472>>>>>
83472>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
83473>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
83474>>>>>        Set psDriverID of hoDriver to sDriverID
83475>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
83476>>>>>        If (bLoginSuccessful = False) Begin
83478>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
83479>>>>>>
83479>>>>>        End
83479>>>>>>
83479>>>>>        Send Destroy of hoDriver
83480>>>>>
83480>>>>>    End_Procedure
83481>>>>>
83481>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
83483>>>>>        Integer iRetval
83483>>>>>        Handle hoCLI
83483>>>>>        String sDriverID
83483>>>>>
83483>>>>>        Get psDriverID to sDriverID
83484>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
83485>>>>>        If (hoCLI <> 0) Begin
83487>>>>>            Set psDriverID of hoCLI to sDriverID
83488>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
83489>>>>>            Send Destroy of hoCLI
83490>>>>>        End
83490>>>>>>
83490>>>>>
83490>>>>>        Function_Return iRetval
83491>>>>>    End_Function
83492>>>>>
83492>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
83494>>>>>        Integer iResult
83494>>>>>        Handle hoCLI
83494>>>>>        String sServer sDatabase sUserID sPassword
83494>>>>>        tSQLConnection SQLConnection
83494>>>>>        tSQLConnection SQLConnection
83494>>>>>
83494>>>>>        Set psDriverID to sDriverID
83495>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
83496>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
83497>>>>>    End_Procedure
83498>>>>>
83498>>>>>    // This is needed when e.g. the connection id we have specified in the program code
83498>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
83498>>>>>    // or the one in the DataFlex Bin folder.)
83498>>>>>    // We then need to delete the current one before creating a new one.
83498>>>>>    // This is because the parameters may differ between the program code and the
83498>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
83498>>>>>    // when one tries to create a Connection ID that already exists.
83498>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
83500>>>>>        Integer iResult iDriver iNumConn iConn
83500>>>>>        Handle hoCLI
83500>>>>>        String sID
83500>>>>>
83500>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
83502>>>>>            Procedure_Return
83503>>>>>        End
83503>>>>>>
83503>>>>>
83503>>>>>        Move 0 to iResult
83504>>>>>        Get Create U_cCLIHandler to hoCLI
83505>>>>>        If (hoCLI <> 0) Begin
83507>>>>>            Set psDriverID of hoCLI to sDriverID
83508>>>>>            Get DriverIndex sDriverID to iDriver
83509>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83512>>>>>            Decrement iNumConn
83513>>>>>            For iConn from 0 to iNumConn
83519>>>>>>
83519>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
83522>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
83524>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
83525>>>>>                End
83525>>>>>>
83525>>>>>            Loop
83526>>>>>>
83526>>>>>            Send Destroy of hoCLI
83527>>>>>        End
83527>>>>>>
83527>>>>>
83527>>>>>    End_Procedure
83528>>>>>
83528>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
83530>>>>>        Integer iResult iDriver iNumConn iConn
83530>>>>>        Handle hoCLI
83530>>>>>        String sID sConnectionString sVal sDatabase
83530>>>>>        tSQLConnection SQLConnection
83530>>>>>        tSQLConnection SQLConnection
83530>>>>>        Boolean bTrusted
83530>>>>>
83530>>>>>        Move 0 to iResult
83531>>>>>        Get Create U_cCLIHandler to hoCLI
83532>>>>>        If (hoCLI <> 0) Begin
83534>>>>>            Set psDriverID of hoCLI to sDriverID
83535>>>>>            Get DriverIndex sDriverID to iDriver
83536>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
83539>>>>>            Decrement iNumConn
83540>>>>>            For iConn from 0 to iNumConn
83546>>>>>>
83546>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
83549>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
83551>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
83552>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
83555>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
83558>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
83559>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
83562>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
83563>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
83564>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
83565>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
83566>>>>>
83566>>>>>                    Case Begin
83566>>>>>                        Case (sDriverID = MSSQLDRV_ID)
83568>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
83569>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
83570>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
83571>>>>>                            Case Break
83572>>>>>                        Case (sDriverID = DB2_DRV_ID)
83575>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83576>>>>>                            Case Break
83577>>>>>                        Case (sDriverID = ODBC_DRV_ID)
83580>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83581>>>>>                            Case Break
83582>>>>>                        Case (sDriverID = SQLFLEX)
83585>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83586>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83587>>>>>                            If (SQLConnection.bTrusted = True) Begin
83589>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83590>>>>>                            End
83590>>>>>>
83590>>>>>                            Else Begin
83591>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83592>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83593>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83594>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83595>>>>>                            End
83595>>>>>>
83595>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83596>>>>>                            Case Break
83597>>>>>                        Case (sDriverID = MDSMySQL)
83600>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83601>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83602>>>>>                            If (SQLConnection.bTrusted = True) Begin
83604>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83605>>>>>                            End
83605>>>>>>
83605>>>>>                            Else Begin
83606>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83607>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83608>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83609>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83610>>>>>                            End
83610>>>>>>
83610>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83611>>>>>                            Case Break
83612>>>>>                        Case (sDriverID = MDSPgSQL)
83615>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
83616>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
83617>>>>>                            If (SQLConnection.bTrusted = True) Begin
83619>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83620>>>>>                            End
83620>>>>>>
83620>>>>>                            Else Begin
83621>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83622>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83623>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83624>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83625>>>>>                            End
83625>>>>>>
83625>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
83626>>>>>                            Case Break
83627>>>>>
83627>>>>>                        Case (sDriverID = ORAFLEX)
83630>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
83631>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
83632>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83633>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
83635>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
83636>>>>>                            End
83636>>>>>>
83636>>>>>                            If (SQLConnection.bTrusted = True) Begin
83638>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
83639>>>>>                            End
83639>>>>>>
83639>>>>>                            Else Begin
83640>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
83641>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
83642>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
83643>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
83644>>>>>                            End
83644>>>>>>
83644>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
83645>>>>>                            Case Break
83646>>>>>                        Case Else
83646>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
83647>>>>>>
83647>>>>>                            Case Break
83648>>>>>                    Case End
83648>>>>>                End
83648>>>>>>
83648>>>>>            Loop
83649>>>>>>
83649>>>>>            Send Destroy of hoCLI
83650>>>>>        End
83650>>>>>>
83650>>>>>
83650>>>>>        Function_Return SQLConnection
83651>>>>>    End_Function
83652>>>>>
83652>>>>>    Function DriverIndex String sDriverID Returns Integer
83654>>>>>        String  sCurrentDriver
83654>>>>>        Integer iNumberOfDrivers iDriver iCount iRetval
83654>>>>>
83654>>>>>        Move 0 to iDriver
83655>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
83658>>>>>        For iCount from 1 to iNumberOfDrivers
83664>>>>>>
83664>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
83667>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
83669>>>>>                Function_Return iCount
83670>>>>>            End
83670>>>>>>
83670>>>>>        Loop
83671>>>>>>
83671>>>>>
83671>>>>>        // If driver not previously loaded; attempt to do so now.
83671>>>>>        If (iDriver = 0) Begin
83673>>>>>            Move 0 to LastErr
83674>>>>>            Load_Driver sDriverID
83675>>>>>            // If driver could not be loaded.
83675>>>>>            If (LastErr = 4255) Begin
83677>>>>>                Move 0 to iCount
83678>>>>>            End
83678>>>>>>
83678>>>>>            Function_Return iCount
83679>>>>>        End
83679>>>>>>
83679>>>>>        Function_Return 0
83680>>>>>    End_Function
83681>>>>>
83681>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
83681>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
83683>>>>>        String sRetval sDriverID sConnectionID sConnectionString sServer sDatabase sUserID sPassword
83683>>>>>        Boolean bTrusted bSilent
83683>>>>>        Integer iConnOptions
83683>>>>>
83683>>>>>        Move SQLConnection.sDriverID     to sDriverID
83684>>>>>        Move SQLConnection.sConnectionID to sConnectionID
83685>>>>>        Move SQLConnection.sServer       to sServer
83686>>>>>        Move SQLConnection.sDatabase     to sDatabase
83687>>>>>        Move SQLConnection.bTrusted      to bTrusted
83688>>>>>        Move SQLConnection.sUserID       to sUserID
83689>>>>>        Move SQLConnection.sPassword     to sPassword
83690>>>>>        Move SQLConnection.bSilentLogin  to bSilent
83691>>>>>
83691>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
83692>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
83692>>>>>        Send AutoSetConnectionID
83693>>>>>    End_Procedure
83694>>>>>
83694>>>>>    // Called when the object is constructed.
83694>>>>>    // It will check the psDriverID for a ConnectionID and save it
83694>>>>>    // as psConnectionID property. It is later used whenever a login to
83694>>>>>    // the database is needed.
83694>>>>>    Procedure AutoSetConnectionID
83696>>>>>        String sConnectionID sValue sDriverID sConnectionString
83696>>>>>        Integer iDriver iNumConn iConn iConnOptions iRetval
83696>>>>>        Handle hoCLI
83696>>>>>        Boolean bOK bSilent bMertechDriver
83696>>>>>
83696>>>>>        Get pbSilentLogin      to bSilent
83697>>>>>        Get psConnectionID     to sConnectionID
83698>>>>>        Get psConnectionString to sConnectionString
83699>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
83699>>>>>        Get psDriverID to sDriverID
83700>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83701>>>>>        If (bOK = False) Begin
83703>>>>>            Procedure_Return
83704>>>>>        End
83704>>>>>>
83704>>>>>
83704>>>>>        // Mertech drivers can't use connection ID's.
83704>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83705>>>>>        If (bMertechDriver = True) Begin
83707>>>>>            // This ensures that the correct Server & Database attributes are set both for
83707>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
83707>>>>>            Get _MertechSQLManagerHandle to hoCLI
83708>>>>>            Procedure_Return
83709>>>>>        End
83709>>>>>>
83709>>>>>
83709>>>>>        Get DriverIndex sDriverID          to iDriver
83710>>>>>        // If driver not loaded; load it.
83710>>>>>        If (iDriver = 0) Begin
83712>>>>>            Load_Driver sDriverID
83713>>>>>            Get DriverIndex sDriverID      to iDriver
83714>>>>>        End
83714>>>>>>
83714>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
83714>>>>>        If (iDriver = 0) Begin
83716>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
83717>>>>>>
83717>>>>>            Procedure_Return
83718>>>>>        End
83718>>>>>>
83718>>>>>
83718>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
83719>>>>>        Set psDriverID of hoCLI            to sDriverID
83720>>>>>        // Delete the connection first; in case it exists
83720>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
83721>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval
83722>>>>>
83722>>>>>        Send Destroy of hoCLI
83723>>>>>    End_Procedure
83724>>>>>
83724>>>>>    // Returns the handle of the Mertech SQL handler.
83724>>>>>    // It also ensures that the correct Server & Database attributes are set both for
83724>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
83724>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
83724>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
83724>>>>>    Function _MertechSQLManagerHandle Returns Handle
83726>>>>>        Handle hoSQLHandler
83726>>>>>        String sDriverID sServer sDatabase
83726>>>>>
83726>>>>>        Move 0 to hoSQLHandler
83727>>>>>        Get psDriverID to sDriverID
83728>>>>>        Get psServer   to sServer
83729>>>>>        Get psDatabase to sDatabase
83730>>>>>
83730>>>>>        Function_Return hoSQLHandler
83731>>>>>    End_Function
83732>>>>>
83732>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
83734>>>>>        Boolean bOK bMertechDriver
83734>>>>>
83734>>>>>        Get IsDAWSQLDriver sDriverID to bOK
83735>>>>>
83735>>>>>        If (bOK = False) Begin
83737>>>>>            Get IsMertechDriver sDriverID to bOK
83738>>>>>        End
83738>>>>>>
83738>>>>>
83738>>>>>        If (bOK = False) Begin
83740>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
83741>>>>>            If (bMertechDriver = True) Begin
83743>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
83744>>>>>>
83744>>>>>            End
83744>>>>>>
83744>>>>>            Else Begin
83745>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
83746>>>>>>
83746>>>>>            End
83746>>>>>>
83746>>>>>            Function_Return False
83747>>>>>        End
83747>>>>>>
83747>>>>>
83747>>>>>        Function_Return True
83748>>>>>    End_Function
83749>>>>>
83749>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
83751>>>>>        Boolean bOK
83751>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
83752>>>>>        Function_Return bOK
83753>>>>>    End_Function
83754>>>>>
83754>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
83756>>>>>        Boolean bOK
83756>>>>>        Move False to bOK
83757>>>>>        Function_Return bOK
83758>>>>>    End_Function
83759>>>>>
83759>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
83761>>>>>        Handle hoIniFile
83761>>>>>        String sConnect
83761>>>>>
83761>>>>>        Get phoSQLConnectionIniFile to hoIniFile
83762>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
83763>>>>>
83763>>>>>        Function_Return sConnect
83764>>>>>    End_Function
83765>>>>>
83765>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
83765>>>>>    // Pass a complete driver connection string
83765>>>>>    // Returns the following as a struct:
83765>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
83765>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
83765>>>>>    //
83765>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
83767>>>>>        tSQLConnection SQLConnection
83767>>>>>        tSQLConnection SQLConnection
83767>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
83767>>>>>        Boolean bTrusted bSilent bOK
83767>>>>>        Integer iPos
83767>>>>>
83767>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83768>>>>>        If (bOK = False) Begin
83770>>>>>            Function_Return SQLConnection
83771>>>>>        End
83771>>>>>>
83771>>>>>
83771>>>>>        Move False to bTrusted
83772>>>>>        Move False to bSilent
83773>>>>>
83773>>>>>        Case Begin
83773>>>>>            Case (sDriverID = MSSQLDRV_ID)
83775>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
83776>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83777>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83778>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83779>>>>>                If (bTrusted = False) Begin
83781>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83782>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83783>>>>>                End
83783>>>>>>
83783>>>>>                Case Break
83784>>>>>
83784>>>>>            Case (sDriverID = ODBC_DRV_ID)
83787>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83788>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83789>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83790>>>>>                If (bTrusted = False) Begin
83792>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83793>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83794>>>>>                End
83794>>>>>>
83794>>>>>                Case Break
83795>>>>>
83795>>>>>            Case (sDriverID = DB2_DRV_ID)
83798>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83799>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83800>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83801>>>>>                Case Break
83802>>>>>
83802>>>>>            Case (sDriverID = SQLFLEX)
83805>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
83806>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
83807>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
83808>>>>>                If (bTrusted = False) Begin
83810>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
83811>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
83812>>>>>                End
83812>>>>>>
83812>>>>>                Case Break
83813>>>>>
83813>>>>>            Case (sDriverID = ORAFLEX)
83816>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83817>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83818>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
83820>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
83821>>>>>                End
83821>>>>>>
83821>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83822>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83823>>>>>                Case Break
83824>>>>>
83824>>>>>            Case (sDriverID = MDSPgSQL)
83827>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83828>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83829>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83830>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83831>>>>>                Case Break
83832>>>>>
83832>>>>>            Case (sDriverID = MDSMySQL)
83835>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
83836>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
83837>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
83838>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
83839>>>>>                Case Break
83840>>>>>
83840>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
83843>>>>>                Break
83844>>>>>        Case End
83844>>>>>
83844>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
83845>>>>>
83845>>>>>        // bSilent?
83845>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
83846>>>>>        If (iPos = 0) Begin
83848>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
83849>>>>>        End
83849>>>>>>
83849>>>>>        If (iPos = 0) Move "0"                                                  to sValue
83852>>>>>        Else Move (Mid(sConnectionString, 1, (iPos +1)))                        to sValue
83854>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
83855>>>>>
83855>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
83856>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
83857>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
83858>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
83859>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
83860>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
83861>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
83862>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
83863>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
83864>>>>>
83864>>>>>        Function_Return SQLConnection
83865>>>>>    End_Function
83866>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
83866>>>>>>
83866>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
83868>>>>>>    Integer iStart iEnd
83868>>>>>>    String sRetval
83868>>>>>>
83868>>>>>>    Move (Trim(sConnect)) to sConnect
83869>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
83870>>>>>>    If (iStart = 0) Begin
83872>>>>>>        Function_Return ""
83873>>>>>>    End
83873>>>>>>>
83873>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
83874>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
83875>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
83877>>>>>>        Move (Pos(",", sRetval))          to iEnd
83878>>>>>>    End
83878>>>>>>>
83878>>>>>>    Else Begin
83879>>>>>>        Move (Pos(";", sRetval))          to iEnd
83880>>>>>>    End
83880>>>>>>>
83880>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
83882>>>>>>        Move (Pos(",", sRetval))          to iEnd
83883>>>>>>        Decrement iEnd
83884>>>>>>    End
83884>>>>>>>
83884>>>>>>    If (iEnd <> 0) Begin
83886>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
83887>>>>>>    End
83887>>>>>>>
83887>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
83888>>>>>>
83888>>>>>>    Function_Return (Trim(sRetval))
83889>>>>>>End_Function
83890>>>>>>
83890>>>>>>
83890>>>>>
83890>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
83890>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
83892>>>>>        Handle ho
83892>>>>>        Integer iRetval iIndex
83892>>>>>        Boolean bRetval bOK
83892>>>>>        tSQLConnection SQLConnection
83892>>>>>        tSQLConnection SQLConnection
83892>>>>>
83892>>>>>        Get pSQLConnection to SQLConnection
83893>>>>>        Get phoSQLConnectionIniFile to ho
83894>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
83895>>>>>        If (iIndex = -1) Begin
83897>>>>>            Function_Return False
83898>>>>>        End
83898>>>>>>
83898>>>>>
83898>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
83899>>>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
83900>>>>>        If (ghoConnection > 0) Begin
83902>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
83903>>>>>            If (iIndex <> -1) Begin
83905>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
83906>>>>>            End
83906>>>>>>
83906>>>>>        End
83906>>>>>>
83906>>>>>
83906>>>>>        Function_Return bRetval
83907>>>>>    End_Function
83908>>>>>
83908>>>>>End_Class
83909>>>Use vWin32fh.pkg
83909>>>
83909>>>//
83909>>>Class cDbUpdateFunctionLibrary is a cObject
83910>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
83911>>>>
83911>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
83913>>>>    Integer iStart iEnd
83913>>>>    String sRetval
83913>>>>
83913>>>>    Move (Trim(sConnect)) to sConnect
83914>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
83915>>>>    If (iStart = 0) Begin
83917>>>>        Function_Return ""
83918>>>>    End
83918>>>>>
83918>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
83919>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
83920>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
83922>>>>        Move (Pos(",", sRetval))          to iEnd
83923>>>>    End
83923>>>>>
83923>>>>    Else Begin
83924>>>>        Move (Pos(";", sRetval))          to iEnd
83925>>>>    End
83925>>>>>
83925>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
83927>>>>        Move (Pos(",", sRetval))          to iEnd
83928>>>>        Decrement iEnd
83929>>>>    End
83929>>>>>
83929>>>>    If (iEnd <> 0) Begin
83931>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
83932>>>>    End
83932>>>>>
83932>>>>    Move (Replace("=", sRetval, ""))      to sRetval
83933>>>>
83933>>>>    Function_Return (Trim(sRetval))
83934>>>>End_Function
83935>>>>
83935>>>>
83935>>>
83935>>>    Procedure Construct_Object
83937>>>        Handle ho
83937>>>        Forward Send Construct_Object
83939>>>
83939>>>        Move Self to ghoDbUpdateFunctionLibrary
83940>>>
83940>>>        Send CreateDbUpdateLibraryProperties
83941>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
83941>>>        // we will create one as it is used for all ConnectionID, ConnectionString
83941>>>        // etc settings.
83941>>>        If (ghoSQLConnectionHandler = 0) Begin
83943>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
83944>>>            Set phoSQLConnectionHandler to ho
83945>>>        End
83945>>>>
83945>>>
83945>>>    End_Procedure
83946>>>
83946>>>    Procedure End_Construct_Object
83948>>>        Forward Send End_Construct_Object
83950>>>    End_Procedure
83951>>>
83951>>>    // *** SQL Messages for making changes to the SQL back-end ***
83951>>>    //
83951>>>
83951>>>    // Function for creating a new *Database*.
83951>>>    // Note: This is for creating SQL DATABASES - not tables!
83951>>>    // Returns True if successful.
83951>>>    // ToDo: Only works for MS-SQL...
83951>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
83953>>>        String sSQL sSQL1 sConnectionID sConnectionString sCreateDatabaseKeyWord sSelectFromWhereName
83953>>>        Handle hConnection hStmt hoSQLManager
83953>>>        Integer iFetchResult iDbType
83953>>>        Boolean bOK bMertechDriver
83953>>>
83953>>>        Get piDbType to iDbType
83954>>>        If (iDbType <> EN_DbTypeMSSQL) Begin
83956>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
83957>>>>
83957>>>            Function_Return False
83958>>>        End
83958>>>>
83958>>>
83958>>>        Get IsMertechDriver sDriverID to bMertechDriver
83959>>>        If (bMertechDriver = False) Begin
83961>>>            Get phoSQLManager to hoSQLManager
83962>>>        End
83962>>>>
83962>>>        Else Begin
83963>>>            Get _MertechSQLManagerHandle to hoSQLManager
83964>>>        End
83964>>>>
83964>>>
83964>>>        Get psConnectionID     to sConnectionID
83965>>>        Get psConnectionString to sConnectionString
83966>>>        Move 0 to LastErr
83967>>>
83967>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
83968>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
83969>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
83970>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
83972>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
83973>>>>
83973>>>            Function_Return False
83974>>>        End
83974>>>>
83974>>>
83974>>>        Get SqlOpen of hConnection to hStmt
83975>>>
83975>>>        If (hStmt = 0) Begin
83977>>>            Send SqlDisconnect of hoSQLManager
83978>>>            Error DFERR_PROGRAM CS_SQLConnectError
83979>>>>
83979>>>            Function_Return False
83980>>>        End
83980>>>>
83980>>>
83980>>>        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
83981>>>        Get _SqlSelectFromWhereName to sSelectFromWhereName
83982>>>        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
83983>>>
83983>>>        // Check if database exists
83983>>>        Send SqlExecDirect of hStmt sSQL
83984>>>        Get SqlFetch of hStmt to iFetchResult
83985>>>        Send SqlClose of hStmt
83986>>>        Send SqlDisconnect of hConnection
83987>>>
83987>>>        // If database already exists we're out of here!
83987>>>        // Note that we return True as this is not an error.
83987>>>        If (iFetchResult > 0) Begin
83989>>>            Function_Return True
83990>>>        End
83990>>>>
83990>>>
83990>>>        // Database doesn't exist, create it.
83990>>>        If (iFetchResult = 0) Begin
83992>>>            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
83993>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
83994>>>
83994>>>            Send SqlUtilExecuteQuery sSQL1 sDriverID
83995>>>
83995>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
83996>>>            If (LastErr = CLIERR_GENERAL_ERROR) Begin
83998>>>               Function_Return False
83999>>>            End
83999>>>>
83999>>>
83999>>>            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
83999>>>            Sleep 1
84000>>>            Send SqlUtilExecuteQuery sSQL sDriverID
84001>>>        End
84001>>>>
84001>>>
84001>>>        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
84001>>>        // the one we just created.
84001>>>        If (bUpdateConnectionString = True) Begin
84003>>>            Set psDatabase to sDatabase
84004>>>            //...and perhaps also the SQLConnections.ini file setting.
84004>>>            If (bPermanantly = True) Begin
84006>>>                If (ghoSQLConnectionHandler <> 0) Begin
84008>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84009>>>                End
84009>>>>
84009>>>            End
84009>>>>
84009>>>        End
84009>>>>
84009>>>
84009>>>        Function_Return (Err = False)
84010>>>    End_Function
84011>>>
84011>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84011>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84011>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84011>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84011>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84011>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84013>>>        Handle hToTable
84013>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bCopyData
84013>>>        String sDriverID sPhysicalName sRootName sDisplayName sEmpty sConnectionID sConnectionString
84013>>>        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase
84013>>>        tSQLConnection SQLConnection
84013>>>        tSQLConnection SQLConnection
84013>>>        Integer iPos iMaxRecords
84013>>>
84013>>>        Get psDriverID to sDriverID
84014>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84015>>>        If (bExists = False) Begin
84017>>>            Function_Return False
84018>>>        End
84018>>>>
84018>>>
84018>>>        If (num_arguments > 1) Begin
84020>>>            Move bCpyDat to bCopyData
84021>>>        End
84021>>>>
84021>>>        Else Begin
84022>>>            Move False to bCopyData
84023>>>        End
84023>>>>
84023>>>
84023>>>        Open hTable
84025>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84028>>>        If (bOpened = False) Begin
84030>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84031>>>>
84031>>>            Function_Return False
84032>>>        End
84032>>>>
84032>>>        Move 0 to hToTable
84033>>>
84033>>>        Move 16711679 to iMaxRecords
84034>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84037>>>        Move (Pos(".", sDisplayName)) to iPos
84038>>>        If (iPos > 0) Begin
84040>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84041>>>        End
84041>>>>
84041>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84044>>>        Get _TableNameOnly sRootName                 to sRootName
84045>>>        Move (sRootName + ".dat")                    to sPhysicalName
84046>>>
84046>>>        If (ghoProgressBar <> 0) Begin
84048>>>            Send DoAdvance of ghoProgressBar
84049>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84050>>>        End
84050>>>>
84050>>>
84050>>>        Move False to Err
84051>>>
84051>>>        Structure_Start hToTable DATAFLEX_ID
84052>>>            Structure_Copy hTable to hToTable
84053>>>
84053>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84056>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84059>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84062>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84065>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84068>>>
84068>>>        Structure_End hToTable
84070>>>
84070>>>        Move (not(Err)) to bOK
84071>>>        If (bOK = True and bCopyData = True) Begin
84073>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84074>>>        End
84074>>>>
84074>>>
84074>>>        Get IsMertechDriver sDriverID to bMertechDriver
84075>>>        If (bMertechDriver = True) Begin
84077>>>            Open hTable
84079>>>        End
84079>>>>
84079>>>
84079>>>        // This must be after copying data...
84079>>>        If (Err = False) Begin
84081>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84084>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84087>>>        End
84087>>>>
84087>>>        Move (not(Err)) to bOK
84088>>>
84088>>>        Function_Return (bOK = True)
84089>>>    End_Function
84090>>>
84090>>>    // Creates an SQL Table at the SQL end by its filelist number;
84090>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84090>>>    Function SqlTableCreate Integer hTable Returns Boolean
84092>>>        String sTableName sSQLString sPath sVal sCreateTable sDriverID
84092>>>        Integer iRetval iDbType
84092>>>        Boolean bExists bOK
84092>>>
84092>>>        Get psDriverID to sDriverID
84093>>>        Get UtilTableHandleToString hTable to sTableName
84094>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84095>>>        If (bExists = True) Begin
84097>>>            Function_Return False
84098>>>        End
84098>>>>
84098>>>
84098>>>        Get psDataPathFirstPart to sPath
84099>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84100>>>
84100>>>        Get piDbType to iDbType
84101>>>        Get _SqlProperTableName sTableName to sTableName
84102>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84103>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84104>>>
84104>>>        Move False to Err
84105>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84106>>>
84106>>>        Function_Return (Err = False)
84107>>>    End_Function
84108>>>
84108>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84108>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84108>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84110>>>        String sSQLString sPath sVal sCreateTable sDriverID
84110>>>        Integer iRetval iDbType
84110>>>        Boolean bExists bOK
84110>>>
84110>>>        Get psDriverID to sDriverID
84111>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84112>>>        If (bExists = True) Begin
84114>>>            Function_Return False
84115>>>        End
84115>>>>
84115>>>
84115>>>        Get psDataPathFirstPart to sPath
84116>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84117>>>        If (bExists = True) Begin
84119>>>            // ToDo: What should we do if an .int file already exists?
84119>>>        End
84119>>>>
84119>>>
84119>>>        Get piDbType to iDbType
84120>>>        Get _SqlProperTableName sTableName to sTableName
84121>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84122>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84123>>>
84123>>>        Move False to Err
84124>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84125>>>
84125>>>        Function_Return (Err = False)
84126>>>    End_Function
84127>>>
84127>>>    // First deletes the data cache file and then drops the passed SQL table.
84127>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84127>>>    //       else try using the SqlTableRemoveByTableName message.
84127>>>    Function SqlTableRemove Integer hTable Returns Boolean
84129>>>        String sSQLString sPath sDropTable sTableName sDriverID
84129>>>        Integer iRetval iDbType
84129>>>        Boolean bExists bMertechDriver bOK
84129>>>
84129>>>        Get psDriverID to sDriverID
84130>>>        Get IsMertechDriver sDriverID to bMertechDriver
84131>>>        Get UtilTableHandleToString hTable to sTableName
84132>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84133>>>        If (bExists = False) Begin
84135>>>            Function_Return False
84136>>>        End
84136>>>>
84136>>>
84136>>>        Get psDataPathFirstPart to sPath
84137>>>        Get UtilDeleteCacheFile sTableName to iRetval
84138>>>
84138>>>        Get piDbType to iDbType
84139>>>        Get _SqlProperTableName sTableName to sTableName
84140>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84141>>>        Move (sDropTable * String(sTableName)) to sSQLString
84142>>>
84142>>>        Move False to Err
84143>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84144>>>
84144>>>        // We also need to remove the cache-file since the table has been changed
84144>>>        Get UtilDeleteCacheFile sTableName to bOK
84145>>>
84145>>>        Function_Return (Err = False)
84146>>>    End_Function
84147>>>
84147>>>    // First deletes the data cache file and then drops the passed data table.
84147>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84149>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84149>>>        Integer iRetval iDbType
84149>>>        Boolean bMertechDriver bOK
84149>>>
84149>>>        Get psDriverID to sDriverID
84150>>>        Get IsMertechDriver sDriverID to bMertechDriver
84151>>>        Get psDataPathFirstPart to sPath
84152>>>        Get UtilDeleteCacheFile sTableName to iRetval
84153>>>
84153>>>        Get piDbType to iDbType
84154>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84155>>>        Get psSchema to sSchema
84156>>>        If (sSchema = "") Begin
84158>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84159>>>        End
84159>>>>
84159>>>        Move (Uppercase(sTableName)) to sVal
84160>>>        If (not(sVal contains (sSchema + "."))) Begin
84162>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84163>>>        End
84163>>>>
84163>>>        Move (sDropTable * String(sTableName)) to sSQLString
84164>>>
84164>>>        Move False to Err
84165>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84166>>>
84166>>>        // We also need to remove the cache-file since the table has been changed
84166>>>        Get UtilDeleteCacheFile sTableName to bOK
84167>>>
84167>>>        Function_Return (Err = False)
84168>>>    End_Function
84169>>>
84169>>>    // *** Sql View Messages ***
84169>>>
84169>>>    // First deletes the data cache file and then drops the passed Sql data view.
84169>>>    Function SqlViewRemove String sDataView Returns Boolean
84171>>>        String sDriverID sSQLString sPath sDropViewKeyWord
84171>>>        Integer iRetval
84171>>>        Boolean bMertechDriver bOK
84171>>>
84171>>>        Get psDriverID to sDriverID
84172>>>        Get IsMertechDriver sDriverID to bMertechDriver
84173>>>        Get UtilDeleteCacheFile sDataView to iRetval
84174>>>
84174>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
84175>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
84176>>>        Set psSQLStatementString to sSQLString
84177>>>
84177>>>        // As we don't check if the view exist or not, it might happen
84177>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
84177>>>        Move False to Err
84178>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84179>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84180>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84181>>>        Move 0 to LastErr
84182>>>
84182>>>        // We also need to remove the cache-file since the table has been changed
84182>>>        Get UtilDeleteCacheFile sDataView to bOK
84183>>>
84183>>>        Function_Return (Err = False)
84184>>>    End_Function
84185>>>
84185>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84187>>>        Boolean bOK
84187>>>        Integer iDbType 
84187>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84187>>>        
84187>>>        Get psDriverID to sDriverID
84188>>>        Get piDbType   to iDbType
84189>>>        
84189>>>        Case Begin
84189>>>            Case (iDbType = EN_DbTypeDB2)
84191>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84192>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84193>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84194>>>            Break
84195>>>
84195>>>            Case (iDbType = EN_DbTypeMSSQL)
84198>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84199>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84200>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
84201>>>            Break
84202>>>
84202>>>            Case (iDbType = EN_DbTypeOracle)
84205>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84206>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84207>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84208>>>            Break
84209>>>
84209>>>            Case (iDbType = EN_DbTypePostgre)
84212>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84213>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84214>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84215>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
84216>>>            Break
84217>>>
84217>>>            Case (iDbType = EN_DbTypeMySQL)
84220>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84221>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84222>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
84223>>>            Break
84224>>>        Case End   
84224>>>        
84224>>>        Move False to Err
84225>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84226>>>        Move (Err = False) to bOK
84227>>>        
84227>>>        Function_Return bOK
84228>>>    End_Function
84229>>>    
84229>>>     // *** Sql Column Messages ***
84229>>>    //
84229>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84229>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84231>>>        Integer iColumn iDbType iLength iDecimals
84231>>>        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
84231>>>        String sTableName sDriverID sUpdate sSet sNoCountOn
84231>>>        Boolean bExists bOK bInitializeValue
84231>>>
84231>>>        Get psDriverID to sDriverID
84232>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84233>>>        If (bOK = False) Begin
84235>>>            Function_Return False
84236>>>        End
84236>>>>
84236>>>
84236>>>        Get UtilTableHandleToString hTable to sTableName
84237>>>        If (sTableName = "") Begin
84239>>>            Function_Return False
84240>>>        End
84240>>>>
84240>>>
84240>>>        If (num_arguments > 3) Begin
84242>>>            Move iLen     to iLength
84243>>>            Move iDec     to iDecimals
84244>>>            Move bInitVal to bInitializeValue
84245>>>            Move sColVal  to sColumnValue
84246>>>        End
84246>>>>
84246>>>
84246>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84247>>>
84247>>>        Function_Return (bOK = True)
84248>>>    End_Function
84249>>>
84249>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84249>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84251>>>        Integer iColumn iDbType iLength iDecimals iDriver
84251>>>        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
84251>>>        String sDriverID sUpdate sSet sNoCountOn sNotNull
84251>>>        Boolean bExists bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84251>>>        Handle hTable
84251>>>
84251>>>        Get psDriverID to sDriverID
84252>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84253>>>        If (bOK = False) Begin
84255>>>            Function_Return False
84256>>>        End
84256>>>>
84256>>>
84256>>>        Get UtilTableNameToHandle sTableName to hTable
84257>>>        If (hTable = 0) Begin
84259>>>            Get NextFreeFilelistSlot to hTable
84260>>>        End 
84260>>>>
84260>>>
84260>>>        Get piDbType to iDbType
84261>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84261>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84262>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84264>>>            Function_Return False
84265>>>        End
84265>>>>
84265>>>
84265>>>        Get DriverIndex sDriverID to iDriver
84266>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84269>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84272>>>
84272>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84273>>>        If (num_arguments > 3) Begin
84275>>>            Move iLen     to iLength
84276>>>            Move iDec     to iDecimals
84277>>>            Move bInitVal to bInitializeValue
84278>>>            Move sColVal  to sColumnValue
84279>>>        End
84279>>>>
84279>>>
84279>>>        Get _SqlProperTableName sTableName   to sTableName
84280>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84281>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84282>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84283>>>
84283>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84284>>>        If (bFixed = False) Begin
84286>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84287>>>        End
84287>>>>
84287>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84288>>>
84288>>>        Move False to Err
84289>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84290>>>
84290>>>        If (bInitializeValue = True and Err = False) Begin
84292>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84293>>>        End
84293>>>>
84293>>>
84293>>>        If (Err = False) Begin
84295>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84296>>>        End
84296>>>>
84296>>>
84296>>>        Move (not(Err)) to bRetval
84297>>>
84297>>>        // We also need to remove the cache-file since the table has been changed
84297>>>        Get UtilDeleteCacheFile sTableName to bOK
84298>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84301>>>
84301>>>        Function_Return bRetval
84302>>>    End_Function
84303>>>    
84303>>>    // To update all current rows for a table column with a common value.
84303>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84305>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
84305>>>        Boolean bRetval bSQLDriver 
84305>>>        Integer iCurrErr
84305>>>        
84305>>>        Move False to bRetval
84306>>>        Get psDriverID to sDriverID
84307>>>        Get IsSQLDriver sDriverID to bSQLDriver
84308>>>        If (bSQLDriver = False) Begin
84310>>>            Function_Return bRetval
84311>>>        End
84311>>>>
84311>>>        Get UtilTableHandleToString hTable to sTableName
84312>>>        
84312>>>        Move Err to iCurrErr
84313>>>        Move False to Err
84314>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84315>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84316>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84317>>>        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84318>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84319>>>        Move (Err = False) to bRetval
84320>>>        Move iCurrErr to Err
84321>>>        
84321>>>        Function_Return bRetval
84322>>>    End_Function
84323>>>
84323>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84323>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84323>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84325>>>        Integer iColumn iDbType iLength iDecimals
84325>>>        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sTableName sNotNull
84325>>>        Boolean bExists bOK bFixed
84325>>>
84325>>>        Get psDriverID to sDriverID
84326>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84327>>>        If (bOK = False) Begin
84329>>>            Function_Return False
84330>>>        End
84330>>>>
84330>>>
84330>>>        Get UtilTableHandleToString hTable to sTableName
84331>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84332>>>
84332>>>        Function_Return (Err = False)
84333>>>    End_Function
84334>>>
84334>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84334>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84334>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84334>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84336>>>        Integer iColumn iDbType iLength iDecimals
84336>>>        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sNotNull
84336>>>        Boolean bExists bOK bFixed
84336>>>        Handle hTable
84336>>>
84336>>>        Get psDriverID to sDriverID
84337>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84338>>>        If (bOK = False) Begin
84340>>>            Function_Return False
84341>>>        End
84341>>>>
84341>>>
84341>>>        Get UtilTableNameToHandle sTableName to hTable
84342>>>        If (hTable = 0) Begin
84344>>>            Get NextFreeFilelistSlot to hTable
84345>>>        End
84345>>>>
84345>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84346>>>        If (bExists = True) Begin
84348>>>            Function_Return False
84349>>>        End
84349>>>>
84349>>>
84349>>>        If (num_arguments > 3) Begin
84351>>>            Move iLen to iLength
84352>>>        End
84352>>>>
84352>>>        If (num_arguments > 4) Begin
84354>>>            Move iDec to iDecimals
84355>>>        End
84355>>>>
84355>>>
84355>>>        Get piDbType to iDbType
84356>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84357>>>
84357>>>        Move False to Err
84358>>>        Get _SqlProperTableName sTableName    to sTableName
84359>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84360>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
84361>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84362>>>
84362>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84363>>>        If (bFixed = False) Begin
84365>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84366>>>        End
84366>>>>
84366>>>
84366>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84367>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84368>>>
84368>>>        // We also need to remove the cache-file since the table has been changed
84368>>>        Get UtilDeleteCacheFile sTableName to bOK
84369>>>
84369>>>        Function_Return (Err = False)
84370>>>    End_Function
84371>>>
84371>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
84373>>>        Boolean bOK bErr bIsSQLDriver
84373>>>        String sDriverID
84373>>>
84373>>>        Get psDriverID to sDriverID
84374>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84375>>>        If (bIsSQLDriver = False) Begin
84377>>>            Function_Return False
84378>>>        End
84378>>>>
84378>>>
84378>>>        Move Err to bErr
84379>>>        Move False to bErr
84380>>>
84380>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
84380>>>        // inserts randomly character(10) and spaces, so we correct from that here:
84380>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
84381>>>
84381>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
84384>>>        Move (not(Err)) to bOK
84385>>>        Move bErr to Err
84386>>>
84386>>>        Function_Return bOK
84387>>>    End_Function
84388>>>
84388>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
84390>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
84390>>>        String sDriverID
84390>>>
84390>>>        Get psDriverID to sDriverID
84391>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
84392>>>        If (bIsSQLDriver = False) Begin
84394>>>            Function_Return False
84395>>>        End
84395>>>>
84395>>>
84395>>>        Move Err to bErr
84396>>>        Move False to bErr
84397>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
84400>>>        If (bNullable = bCurrentState) Begin
84402>>>            Function_Return True
84403>>>        End
84403>>>>
84403>>>
84403>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84406>>>        If (bOpen = False) Begin
84408>>>            Get AutoConnectionIDLogin to bOK
84409>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84410>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84411>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84412>>>            Open hTable
84414>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
84415>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
84416>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84417>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
84420>>>        End
84420>>>>
84420>>>        If (bOpen = True) Begin
84422>>>            Structure_Start hTable sDriverID
84423>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
84426>>>            Structure_End hTable
84428>>>        End
84428>>>>
84428>>>
84428>>>        Move (not(Err)) to bOK
84429>>>        Move bErr to Err
84430>>>
84430>>>        Function_Return bOK
84431>>>    End_Function
84432>>>
84432>>>    // Drop column by its table handle
84432>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
84434>>>        Integer iColumn idbType
84434>>>        String sDriverID sStmt sAlterTable sDropColumn sVal sTableName
84434>>>        Boolean bExists bOK
84434>>>
84434>>>        Get psDriverID to sDriverID
84435>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84436>>>        If (bOK = False) Begin
84438>>>            Function_Return False
84439>>>        End
84439>>>>
84439>>>
84439>>>        Get UtilTableHandleToString hTable to sTableName
84440>>>        If (sTableName = "") Begin
84442>>>            Function_Return False
84443>>>        End
84443>>>>
84443>>>
84443>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
84444>>>
84444>>>        Function_Return (bOK = True)
84445>>>    End_Function
84446>>>
84446>>>    // Drop column by its table name as a string.
84446>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
84448>>>        Integer iColumn iDbType iDriver
84448>>>        String sDriverID sStmt sAlterTable sDropColumn sVal
84448>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
84448>>>        Handle hTable
84448>>>
84448>>>        Get psDriverID to sDriverID
84449>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84450>>>        If (bOK = False) Begin
84452>>>            Function_Return False
84453>>>        End
84453>>>>
84453>>>
84453>>>        Get DriverIndex sDriverID to iDriver
84454>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84457>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84460>>>
84460>>>        Get UtilTableNameToHandle sTableName to hTable
84461>>>        If (hTable <> 0) Begin
84463>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
84464>>>            If (bExists = False) Begin
84466>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84469>>>                Function_Return False
84470>>>            End
84470>>>>
84470>>>        End
84470>>>>
84470>>>
84470>>>        Get piDbType to iDbType
84471>>>        If (iDbType = EN_DbTypeMSSQL) Begin
84473>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
84474>>>            Get UtilDeleteCacheFile sTableName to bOK
84475>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84478>>>            Function_Return bOK
84479>>>        End
84479>>>>
84479>>>
84479>>>        Move False to Err
84480>>>        Get _SqlProperTableName sTableName    to sTableName
84481>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84482>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
84483>>>
84483>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
84484>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84485>>>        Move (not(Err)) to bRetval
84486>>>
84486>>>        // We also need to remove the cache-file since the table has been changed
84486>>>        Get UtilDeleteCacheFile sTableName to bOK
84487>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84490>>>
84490>>>        Function_Return bRetval
84491>>>    End_Function
84492>>>
84492>>>    // Rename a field/column by table handle (filelist number)
84492>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
84494>>>        Integer iColumn idbType
84494>>>        String sDriverID sTableName sStmt sAlterTable sRenameColumn sVal sColumnKeyWord
84494>>>        Boolean bExists bOK
84494>>>
84494>>>        Get psDriverID to sDriverID
84495>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84496>>>        If (bOK = False) Begin
84498>>>            Function_Return False
84499>>>        End
84499>>>>
84499>>>
84499>>>        Get UtilTableHandleToString hTable to sTableName
84500>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
84501>>>
84501>>>        Function_Return (Err = False)
84502>>>    End_Function
84503>>>
84503>>>    // Rename a field/column by table name.
84503>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
84505>>>        Integer iColumn iDbType iDataType
84505>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
84505>>>        Boolean bExists bOK bRetval
84505>>>        Handle hTable
84505>>>
84505>>>        Move sTableName to sOrgTableName
84506>>>        Get psDriverID to sDriverID
84507>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84508>>>        If (bOK = False) Begin
84510>>>            Function_Return False
84511>>>        End
84511>>>>
84511>>>
84511>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84512>>>        If (sVal = "") Begin
84514>>>            Function_Return False
84515>>>        End
84515>>>>
84515>>>
84515>>>        Get piDbType to iDbType
84516>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
84517>>>        Get _SqlProperTableName sTableName     to sTableName
84518>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
84519>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
84520>>>
84520>>>        Case Begin
84520>>>            Case (iDbType = EN_dbTypeMSSQL)
84522>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
84523>>>                Case Break
84524>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
84524>>>            Case (iDbType = EN_dbTypeOracle)
84527>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84528>>>                Case Break
84529>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
84529>>>            Case (iDbType = EN_dbTypeDB2)
84532>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84533>>>                Case Break
84534>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
84534>>>            Case (iDbType = EN_dbTypePostgre)
84537>>>                Move sOrgTableName to sTableName
84538>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
84539>>>                Case Break
84540>>>            Case (iDbType = EN_dbTypeMySQL)
84543>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
84543>>>                Move sOrgTableName to sTableName
84544>>>                Get psDatabase to sDatabase
84545>>>                Get UtilTableNameToHandle sTableName to hTable
84546>>>                If (hTable = 0) Begin
84548>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84549>>>                    If (bOK = False) Begin
84551>>>                        Function_Return False
84552>>>                    End
84552>>>>
84552>>>                    Get NextFreeFilelistSlot to hTable
84553>>>                End
84553>>>>
84553>>>                Else Begin
84554>>>                    Open hTable
84556>>>                End
84556>>>>
84556>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
84557>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
84558>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
84559>>>                Case Break
84560>>>            Case Else
84560>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
84561>>>        Case End
84561>>>
84561>>>        Move False to Err
84562>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84563>>>        Move (Err = False) to bRetval
84564>>>        // We also need to remove the cache-file since the table has been changed
84564>>>        Get UtilDeleteCacheFile sTableName to bOK
84565>>>
84565>>>        Function_Return bRetval
84566>>>    End_Function
84567>>>
84567>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
84569>>>        Handle hoSQLHandler hSQLConnect hStmt
84569>>>        Boolean bMertechDriver
84569>>>        Integer iNumCols iCount iSQLType iDataType
84569>>>        String sValue
84569>>>
84569>>>        Get IsMertechDriver sDriverID to bMertechDriver
84570>>>        If (bMertechDriver = False) Begin
84572>>>            Get phoSQLManager to hoSQLHandler
84573>>>        End
84573>>>>
84573>>>        Else Begin
84574>>>            Get _MertechSQLManagerHandle to hoSQLHandler
84575>>>        End
84575>>>>
84575>>>
84575>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
84576>>>        If (hSQLConnect <> 0) Begin
84578>>>            Get SQLOpen of hSQLConnect to hStmt
84579>>>            If (hStmt <> 0) Begin
84581>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
84582>>>
84582>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
84583>>>                For iCount from 1 to iNumCols
84589>>>>
84589>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
84590>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
84592>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
84593>>>                        Move iNumCols to iCount // We're out of here
84594>>>                    End
84594>>>>
84594>>>                Loop
84595>>>>
84595>>>
84595>>>                Send SQLClose of hStmt
84596>>>            End
84596>>>>
84596>>>            Send SQLDisconnect of hSQLConnect
84597>>>        End
84597>>>>
84597>>>
84597>>>        Function_Return iDataType
84598>>>    End_Function
84599>>>
84599>>>
84599>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
84599>>>    // the DbUpdateVersion database revision in.
84599>>>    // Also pass the file number of the current (embedded?) table number used in development.
84599>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
84599>>>    Function SqlCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
84601>>>        Boolean bOK bOpened
84601>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt sDropColumn
84601>>>
84601>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84604>>>        Get _TableNameOnly sTableName to sTableName
84605>>>        If (sTableName = "") Begin
84607>>>            Function_Return False
84608>>>        End
84608>>>>
84608>>>
84608>>>        // This just creates the table and a "dummy" column.
84608>>>        Get SqlTableCreate hTable sDriverID to bOK
84609>>>        If (bOK = False) Begin
84611>>>            Function_Return False
84612>>>        End
84612>>>>
84612>>>
84612>>>        Close hTable
84613>>>        Move False to Err
84614>>>
84614>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84615>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84616>>>        Move "Decimal" to sDataType
84617>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
84618>>>
84618>>>        // Adds the "sColumnName" passed to the function
84618>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
84619>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84620>>>
84620>>>        // Now we can delete the dummy column:
84620>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
84621>>>
84621>>>        // Finally, we attach to the newly created table.
84621>>>        If (Err = False) Begin
84623>>>            Get ApiTableAttachToSQL hTable True to bOK
84624>>>        End
84624>>>>
84624>>>        Open hTable
84626>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84629>>>
84629>>>        Function_Return (Err = False and bOK = True and bOpened = True)
84630>>>    End_Function
84631>>>
84631>>>    // Checks if a column/field name exists in a SQL table definition
84631>>>    // Returns True if it does
84631>>>    // Sample:
84631>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
84631>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
84633>>>        Integer iNumColumns iColumn
84633>>>        String sColumn sDriverID
84633>>>        String[] sColumnsArray
84634>>>        Boolean bExists bOK
84634>>>
84634>>>        Move False to bExists
84635>>>        Get AutoConnectionIDLogin to bOK
84636>>>        Get psDriverID to sDriverID
84637>>>
84637>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
84638>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
84639>>>        Decrement iNumColumns
84640>>>        For iColumn from 0 to iNumColumns
84646>>>>
84646>>>            Move sColumnsArray[iColumn] to sColumn
84647>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
84649>>>                Move True to bExists
84650>>>                Move iNumColumns to iColumn // We're out of here
84651>>>            End
84651>>>>
84651>>>        Loop
84652>>>>
84652>>>
84652>>>        Function_Return bExists
84653>>>    End_Function
84654>>>
84654>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
84656>>>        Integer iNumColumns iColumn iDFType iNativeType
84656>>>        Boolean bOpened bOK
84656>>>        String sColumnName sNativeTypeName
84656>>>
84656>>>        Get AutoConnectionIDLogin to bOK
84657>>>        Get OpenTableExclusive hTable to bOK
84658>>>        If (bOK = False) Begin
84660>>>            Function_Return False
84661>>>        End
84661>>>>
84661>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84664>>>        If (bOpened = False) Begin
84666>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
84667>>>>
84667>>>            Function_Return False
84668>>>        End
84668>>>>
84668>>>
84668>>>        Move False to Err
84669>>>
84669>>>        Structure_Start hTable
84670>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
84673>>>
84673>>>            For iColumn from 1 to iNumColumns
84679>>>>
84679>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
84682>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
84685>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
84688>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
84691>>>
84691>>>                Case Begin
84691>>>                    Case (iDFType = DF_DATE)
84693>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
84695>>>                            // Convert datetime to date
84695>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
84698>>>                        End
84698>>>>
84698>>>                        Case Break
84699>>>                    Case (iDFType = DF_DATETIME)
84702>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
84704>>>                            // Convert datetime to datetime2
84704>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
84707>>>                        End
84707>>>>
84707>>>                        Case Break
84708>>>                    Case (iDFType = DF_ASCII)
84711>>>                        If (iNativeType = SQL_CHAR) Begin
84713>>>                            // Convert char to varchar
84713>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
84716>>>                        End
84716>>>>
84716>>>                        Case Break
84717>>>                    Case (iDFType = DF_TEXT)
84720>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
84722>>>                            // Convert text to varchar(max)
84722>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
84725>>>                        End
84725>>>>
84725>>>                        Case Break
84726>>>                    Case (iDFType = DF_BINARY)
84729>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
84731>>>                            // Convert image to varbinary(max)
84731>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
84734>>>                        End
84734>>>>
84734>>>                        Case Break
84735>>>                Case End
84735>>>            Loop
84736>>>>
84736>>>        Structure_End hTable
84738>>>
84738>>>        Function_Return (Err = False)
84739>>>    End_Function
84740>>>
84740>>>    // Does three things with auxilirary files;
84740>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
84740>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
84740>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
84740>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
84742>>>        String sDataPath sDDSrcPath sVal sDriverID
84742>>>        Boolean bOK bExists bMertechDriver
84742>>>        Integer iCount iItems iCh iPos
84742>>>
84742>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
84742>>>        If (sTableName contains ".") Begin
84744>>>            Move (Pos(".", sTableName)) to iPos
84745>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
84746>>>        End
84746>>>>
84746>>>
84746>>>        Get psDriverID to sDriverID
84747>>>        Get psDataPathFirstPart to sDataPath
84748>>>        Get vFolderExists sDataPath to bOK
84749>>>        If (bOK = False) Begin
84751>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
84752>>>>
84752>>>            Function_Return False
84753>>>        End
84753>>>>
84753>>>
84753>>>        Get IsMertechDriver sDriverID to bMertechDriver
84754>>>        // First delete the cache file:
84754>>>        Get UtilDeleteCacheFile sTableName to bOK
84755>>>
84755>>>        Get Seq_New_Channel to iCh
84756>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84758>>>            Function_Return False
84759>>>        End
84759>>>>
84759>>>
84759>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
84760>>>        If (bExists = False) Begin
84762>>>            Function_Return False
84763>>>        End
84763>>>>
84763>>>
84763>>>        // Add the new column name to the .tag file:
84763>>>        Append_Output channel iCh (sDataPath + sTableName + ".tag")
84765>>>            Writeln channel iCh sColumnName
84768>>>        Close_Output
84769>>>
84769>>>        // If in development environment; output new .fd file:
84769>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
84770>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
84771>>>        If (iCount > 1) Begin
84773>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
84774>>>        End
84774>>>>
84774>>>        Get vFolderExists sDDSrcPath to bExists
84775>>>        If (bExists = True) Begin
84777>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
84778>>>            Move False to Err
84779>>>            Get AutoConnectionIDLogin to bOK
84780>>>            If (hTable <> 0) Begin
84782>>>                Open hTable
84784>>>            End
84784>>>>
84784>>>            Else Begin
84785>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
84786>>>            End
84786>>>>
84786>>>
84786>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
84789>>>            If (bOK = True) Begin
84791>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
84793>>>            End
84793>>>>
84793>>>            If (Err = True) Begin
84795>>>                Move False to bOK
84796>>>            End
84796>>>>
84796>>>        End
84796>>>>
84796>>>
84796>>>        Function_Return (bOK = True)
84797>>>    End_Function
84798>>>
84798>>>    // The table must already exist in the filelist for this function to work.
84798>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
84798>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
84800>>>        Boolean bOK bExists bUseConnectionID bMertech
84800>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
84800>>>        String[] sIndexArray
84801>>>        Integer iCount iCh iSize
84801>>>
84801>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
84802>>>        Get psConnectionString to sConnectionString
84803>>>
84803>>>        Move CS_ANSI_Txt to sANSI_OEM
84804>>>        If (bANSI = False) Begin
84806>>>            Move CS_OEM_Txt to sANSI_OEM
84807>>>        End
84807>>>>
84807>>>
84807>>>        Get psDataPathFirstPart to sDataPath
84808>>>        Get vFolderExists sDataPath to bOK
84809>>>        If (bOK = False) Begin
84811>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
84812>>>>
84812>>>            Function_Return False
84813>>>        End
84813>>>>
84813>>>        Get vFolderFormat sDataPath to sDataPath
84814>>>
84814>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84817>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84820>>>        Get _TableNameOnly sRootName to sDatabaseName
84821>>>//        Move sDatabaseName to sPhysicalFileName                     
84821>>>        Move sLogicalName  to sPhysicalFileName
84822>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
84823>>>
84823>>>        Get IsMertechDriver sDriverID to bMertech
84824>>>        If (bMertech = True) Begin
84826>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
84826>>>            // Else it will create an error in the error log (although it won't do anything...)
84826>>>            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
84826>>>            Function_Return (bOK = True)
84827>>>        End
84827>>>>
84827>>>
84827>>>        Get psSchema hTable to sSchemaName
84828>>>        If (sSchemaName = "") Begin
84830>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
84831>>>        End
84831>>>>
84831>>>
84831>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
84831>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
84832>>>        If (bExists = True) Begin
84834>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
84835>>>        End
84835>>>>
84835>>>
84835>>>        Get UtilDeleteCacheFile sRootName to bOK
84836>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
84837>>>
84837>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
84838>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
84843>>>            If (bUseConnectionID = True) Begin
84845>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
84852>>>            End
84852>>>>
84852>>>            Else Begin
84853>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
84860>>>            End
84860>>>>
84860>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
84865>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
84870>>>            // There seems to be a new order how these are set from DF19.
84870>>>            If (bSysFile = True) Begin
84872>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
84877>>>            End
84877>>>>
84877>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
84882>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
84887>>>            If (bSysFile = True) Begin
84889>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
84894>>>            End
84894>>>>
84894>>>
84894>>>            If (bSysFile = False) Begin
84896>>>                Move (SizeOfArray(sIndexArray)) to iSize
84897>>>                Move (SortArray(sIndexArray)) to sIndexArray
84898>>>                If (iSize > 0) Begin
84900>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
84903>>>                    Writeln channel iCh // Just an empty line
84905>>>                End
84905>>>>
84905>>>                Decrement iSize
84906>>>                For iCount from 0 to iSize
84912>>>>
84912>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
84915>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
84918>>>                    Writeln channel iCh
84920>>>                Loop
84921>>>>
84921>>>            End
84921>>>>
84921>>>        Send Seq_Close_Channel iCh
84922>>>
84922>>>        // Wait a sec for Windows to finish writing the file:
84922>>>        Sleep 1
84923>>>
84923>>>        Function_Return (bOK = True)
84924>>>    End_Function
84925>>>
84925>>>    // Message for changing .int files to use connection ID's
84925>>>    //
84925>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
84925>>>    // OR changes an existing connection id to a new id.
84925>>>    // Pass the full path to the data folder and the name of the connection id (string value).
84925>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
84925>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
84927>>>        String sFileName sDriverID sDriverFile sConnectionString
84927>>>        String[] sFilesData
84928>>>        Boolean bExists bOK
84928>>>        Integer iSize iCount
84928>>>
84928>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
84929>>>        Move (SizeOfArray(sFilesData))    to iSize
84930>>>        If (iSize = 0) Begin
84932>>>            Send Info_Box "No .int files found! Nothing was changed."
84933>>>            Procedure_Return
84934>>>        End
84934>>>>
84934>>>
84934>>>        Move (Trim(sConnectionID)) to sConnectionID
84935>>>        Get vFolderFormat sDataPath to sDataPath
84936>>>        Decrement iSize
84937>>>        For iCount from 0 to iSize
84943>>>>
84943>>>            Move sFilesData[iCount] to sFileName
84944>>>            // This makes sure that we also can change an existing connection id to something new:
84944>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
84945>>>        Loop
84946>>>>
84946>>>
84946>>>        Get psDriverID to sDriverID
84947>>>
84947>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
84947>>>        Move "" to sFileName
84948>>>        If (sDriverID = MSSQLDRV_ID) Begin
84950>>>            Move "MSSQLDrv.int" to sFileName
84951>>>        End
84951>>>>
84951>>>        If (sDriverID = DB2_DRV_ID) Begin
84953>>>            Move "DB2_Drv.int" to sFileName
84954>>>        End
84954>>>>
84954>>>        If (sDriverID = ODBC_DRV_ID) Begin
84956>>>            Move "ODBC_Drv.int" to sFileName
84957>>>        End
84957>>>>
84957>>>        If (sFileName <> "") Begin
84959>>>            Move "" to sDriverFile
84960>>>            Get_File_Path sFileName to sDriverFile
84961>>>            If (sDriverFile <> "") Begin
84963>>>                Get psConnectionString to sConnectionString
84964>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
84965>>>            End
84965>>>>
84965>>>        End
84965>>>>
84965>>>    End_Procedure
84966>>>
84966>>>    // Checks if the database exists in SQL. Returns = True if it does.
84966>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
84968>>>        String[] sDatabaseArray
84969>>>        String sVal sServer sDriverID
84969>>>        Integer iCount iSize iPos
84969>>>        Boolean bExists
84969>>>        tSQLConnection SQLConnection
84969>>>        tSQLConnection SQLConnection
84969>>>
84969>>>        Move False to bExists
84970>>>        Get psDriverID to sDriverID
84971>>>        // DB2 doesn't need to have a "Database" name, so we always return True.
84971>>>        If (sDriverID = DB2_DRV_ID) Begin
84973>>>            Function_Return bExists
84974>>>        End
84974>>>>
84974>>>
84974>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
84975>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
84977>>>            Function_Return False
84978>>>        End
84978>>>>
84978>>>
84978>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84979>>>        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
84980>>>        If (sServer contains "/") Begin
84982>>>            Move (Pos("/", sServer)) to iPos
84983>>>            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
84984>>>        End
84984>>>>
84984>>>
84984>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
84985>>>        Decrement iSize
84986>>>        For iCount from 0 to iSize
84992>>>>
84992>>>            Move sDatabaseArray[iCount] to sVal
84993>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
84995>>>                Move True to bExists
84996>>>            End
84996>>>>
84996>>>        Loop
84997>>>>
84997>>>
84997>>>        Function_Return bExists
84998>>>    End_Function
84999>>>
84999>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84999>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85001>>>        String sTableName sVal
85001>>>        Boolean bExists
85001>>>        String[] sTablesArray
85002>>>        Integer iSize iCount
85002>>>
85002>>>        Move False to bExists
85003>>>        Get UtilTableHandleToString hTable to sTableName
85004>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
85005>>>        Move (SizeOfArray(sTablesArray)) to iSize
85006>>>        Decrement iSize
85007>>>        For iCount from 0 to iSize
85013>>>>
85013>>>            Move sTablesArray[iCount] to sVal
85014>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85016>>>                Move True to bExists
85017>>>                Move iSize to iCount // We're done!
85018>>>            End
85018>>>>
85018>>>        Loop
85019>>>>
85019>>>
85019>>>        Function_Return bExists
85020>>>    End_Function
85021>>>
85021>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85021>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
85023>>>        String sVal
85023>>>        Boolean bExists
85023>>>        String[] sTablesArray
85024>>>        Integer iSize iCount
85024>>>
85024>>>        Move False to bExists
85025>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
85026>>>        Move (SizeOfArray(sTablesArray)) to iSize
85027>>>        Decrement iSize
85028>>>        For iCount from 0 to iSize
85034>>>>
85034>>>            Move sTablesArray[iCount] to sVal
85035>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85037>>>                Move True to bExists
85038>>>                Move iSize to iCount // We're done!
85039>>>            End
85039>>>>
85039>>>        Loop
85040>>>>
85040>>>
85040>>>        Function_Return bExists
85041>>>    End_Function
85042>>>
85042>>>    // ToDo: This index name function needs to be finished...
85042>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85044>>>        String sStmt sSchema sTableName sDriverID
85044>>>        Boolean bExists
85044>>>
85044>>>        Get psDriverID to sDriverID
85045>>>        Get psSchema to sSchema
85046>>>        Get UtilTableHandleToString hTable to sTableName
85047>>>
85047>>>        Function_Return bExists
85048>>>    End_Function
85049>>>
85049>>>    // Function creates the passed Sql script as a ".sql" file in the workspace's
85049>>>    // Home folder, if no path was specified for the filename.
85049>>>    // Mostly for debugging purposes. E.g. to recreate a Sql script that has been
85049>>>    // compiled into the program, when the program is run at other location.
85049>>>//    Function SqlUtilCreateScriptAsFile String sSQLScript String sFileName Returns String
85049>>>//        String sRetval sPath
85049>>>//        Integer iCh
85049>>>//
85049>>>//        Get ParseFolderName sFileName to sPath
85049>>>//        If (Trim(sPath) = "") Begin
85049>>>//            Get psHome of (phoWorkspace(ghoApplication)) to sPath
85049>>>//        End
85049>>>//        Get vFolderFormat sPath to sPath
85049>>>//        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
85049>>>//            Write channel iCh sSQLScript
85049>>>//        Send Seq_Close_Channel iCh
85049>>>//
85049>>>//        Function_Return (sPath + sFileName)
85049>>>//    End_Function
85049>>>
85049>>>    // Enumerate SQL Servers.
85049>>>    // Pass a driver id. Returns a string array.
85049>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
85049>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
85049>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
85051>>>        String[] sReturnArray
85052>>>        Handle hoSQLHandler
85052>>>        String sServer
85052>>>        Integer iCount iNumItems iDataSourceType
85052>>>        Boolean bOK
85052>>>
85052>>>        If (num_arguments > 1) Begin
85054>>>            Move iDatSrcType to iDataSourceType
85055>>>        End
85055>>>>
85055>>>
85055>>>        Case Begin
85055>>>            Case (sDriverID = MSSQLDRV_ID)
85057>>>                Get phoMSSQLHandler to hoSQLHandler
85058>>>                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
85059>>>                    If (iNumItems = 0) Begin
85061>>>                        Get EnumerateServers of hoSQLHandler to iNumItems
85062>>>                    End
85062>>>>
85062>>>                For iCount from 0 to (iNumItems - 1)
85068>>>>
85068>>>                    Get String_Value of hoSQLHandler item iCount to sServer
85069>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
85070>>>                Loop
85071>>>>
85071>>>                Case Break
85072>>>
85072>>>            Case (sDriverID = DB2_DRV_ID)
85075>>>                Get phoDB2SQLHandler to hoSQLHandler
85076>>>                Send SeedDataSources of hoSQLHandler
85077>>>                Move 0 to iCount
85078>>>                Repeat
85078>>>>
85078>>>                    Get DataSources of hoSQLHandler to sServer
85079>>>                    If (sServer <> "") Begin
85081>>>                        Move (Replace(",", sServer, "")) to sServer
85082>>>                        Move sServer to sReturnArray[iCount]
85083>>>                    End
85083>>>>
85083>>>                    Increment iCount
85084>>>                Until (sServer = "")
85086>>>                Case Break
85087>>>
85087>>>            Case (sDriverID = ODBC_DRV_ID)
85090>>>                Get phoODBCSQLHandler to hoSQLHandler
85091>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
85092>>>                Move 0 to iCount
85093>>>                Repeat
85093>>>>
85093>>>                    Get DataSources of hoSQLHandler to sServer
85094>>>                    If (sServer <> "") Begin
85096>>>                        Move (Replace(",", sServer, ", ")) to sServer
85097>>>                        Move sServer to sReturnArray[iCount]
85098>>>                    End
85098>>>>
85098>>>                    Increment iCount
85099>>>                Until (sServer = "")
85101>>>                Case Break
85102>>>
85102>>>            Case (sDriverID = SQLFLEX)
85105>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
85106>>>                Case Break
85107>>>
85107>>>            Case (sDriverID = ORAFLEX)
85110>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
85111>>>                Case Break
85112>>>
85112>>>            // There appearantly is no way to enumerate servers for this backend.
85112>>>            Case (sDriverID = MDSPgSQL)
85115>>>                Move "localhost" to sReturnArray[0]
85116>>>                Case Break
85117>>>
85117>>>            // There appearantly is no way to enumerate servers for this backend.
85117>>>            Case (sDriverID = MDSMySQL)
85120>>>                Move "localhost" to sReturnArray[0]
85121>>>                Case Break
85122>>>
85122>>>            Case Else
85122>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
85123>>>>
85123>>>        Case End
85123>>>
85123>>>        Function_Return sReturnArray
85124>>>    End_Function
85125>>>
85125>>>    // Returns all databases as a string array for the passed driver id.
85125>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
85127>>>        String[] sReturnArray
85128>>>        String sUserID sPassword
85128>>>        Boolean bOK
85128>>>
85128>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85129>>>        If (bOK = False) Begin
85131>>>            Function_Return sReturnArray
85132>>>        End
85132>>>>
85132>>>
85132>>>        Case Begin
85132>>>            Case (sDriverID = MSSQLDRV_ID)
85134>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
85135>>>                Case Break
85136>>>            Case (sDriverID = DB2_DRV_ID)
85139>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
85140>>>                Case Break
85141>>>
85141>>>            // Enumeration of ODBC databases should be irrelevant as the database
85141>>>            // should have been specified when the ODBC source was setup with the ODBC manager.
85141>>>            Case (sDriverID = ODBC_DRV_ID)
85144>>>                Case Break
85145>>>
85145>>>            Case (sDriverID = SQLFLEX)
85148>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
85149>>>                Case Break
85150>>>
85150>>>            Case (sDriverID = MDSPgSQL)
85153>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
85154>>>                Case Break
85155>>>
85155>>>            Case (sDriverID = MDSMySQL)
85158>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
85159>>>                Case Break
85160>>>
85160>>>            Case (sDriverID = ORAFLEX)
85163>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
85164>>>                Case Break
85165>>>
85165>>>            Case Else
85165>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
85166>>>>
85166>>>        Case End
85166>>>
85166>>>        Function_Return sReturnArray
85167>>>    End_Function
85168>>>
85168>>>    // Returns all table spaces as a string array for the passed driver id.
85168>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
85170>>>        String[] sReturnArray
85171>>>        String sServer sUserID sPassword
85171>>>        Boolean bOK
85171>>>
85171>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85172>>>        If (bOK = False) Begin
85174>>>            Function_Return sReturnArray
85175>>>        End
85175>>>>
85175>>>
85175>>>        Case Begin
85175>>>            Case (sDriverID = DB2_DRV_ID)
85177>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
85178>>>                Case Break
85179>>>
85179>>>            Case (sDriverID = MDSPgSQL)
85182>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
85183>>>                Case Break
85184>>>
85184>>>            Case (sDriverID = ORAFLEX)
85187>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
85188>>>                Case Break
85189>>>
85189>>>            Case Else
85189>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
85190>>>>
85190>>>                Case Break
85191>>>        Case End
85191>>>
85191>>>        Function_Return sReturnArray
85192>>>    End_Function
85193>>>
85193>>>    // Returns all schemas as a string array for the passed driver id.
85193>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
85195>>>        String[] sReturnArray
85196>>>        Boolean bOK
85196>>>
85196>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85197>>>        If (bOK = False) Begin
85199>>>            Function_Return sReturnArray
85200>>>        End
85200>>>>
85200>>>
85200>>>        Case Begin
85200>>>            Case (sDriverID = DB2_DRV_ID)
85202>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
85203>>>                Case Break
85204>>>
85204>>>            Case (sDriverID = MDSPgSQL)
85207>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
85208>>>                Case Break
85209>>>
85209>>>            Case (sDriverID = ORAFLEX)
85212>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
85213>>>                Case Break
85214>>>
85214>>>            Case Else
85214>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
85215>>>>
85215>>>                Case Break
85216>>>        Case End
85216>>>
85216>>>        Function_Return sReturnArray
85217>>>    End_Function
85218>>>
85218>>>    // Returns a string array with all tables for the current database.
85218>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
85220>>>        String[] sReturnArray sArray
85222>>>        String sServer sDatabase sConnectionString sSelect sSchema
85222>>>        Integer iSize iCount
85222>>>        Boolean bOK
85222>>>
85222>>>        If (sDriverID = DATAFLEX_ID) Begin
85224>>>            Function_Return sArray
85225>>>        End
85225>>>>
85225>>>
85225>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85226>>>        If (bOK = False) Begin
85228>>>            Function_Return sReturnArray
85229>>>        End
85229>>>>
85229>>>
85229>>>        Get psConnectionString to sConnectionString
85230>>>        Get psDatabase to sDatabase
85231>>>        Get psSchema   to sSchema
85232>>>
85232>>>        Case Begin
85232>>>            Case (sDriverID = MSSQLDRV_ID)
85234>>>                Get _SqlTableArrayDAW to sReturnArray
85235>>>                Case Break
85236>>>
85236>>>            Case (sDriverID = DB2_DRV_ID)
85239>>>                Get _SqlTableArrayDAW to sReturnArray
85240>>>                Case Break
85241>>>
85241>>>            Case (sDriverID = ODBC_DRV_ID)
85244>>>                Get _SqlTableArrayDAW to sReturnArray
85245>>>                Case Break
85246>>>
85246>>>            Case (sDriverID = SQLFLEX)
85249>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
85250>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85251>>>                Case Break
85252>>>
85252>>>            Case (sDriverID = MDSMySQL)
85255>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
85256>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85257>>>                Case Break
85258>>>
85258>>>            Case (sDriverID = MDSPgSQL)
85261>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
85262>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
85263>>>                Case Break
85264>>>
85264>>>            Case (sDriverID = ORAFLEX)
85267>>>                Move "SELECT table_name from user_tables" to sSelect
85268>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
85269>>>                Move (SizeOfArray(sArray)) to iSize
85270>>>                Decrement iSize
85271>>>                For iCount from 0 to iSize
85277>>>>
85277>>>                    If (not(sArray[iCount] contains "$")) Begin
85279>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
85280>>>                    End
85280>>>>
85280>>>                Loop
85281>>>>
85281>>>                Case Break
85282>>>
85282>>>            Case Else
85282>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
85283>>>>
85283>>>                Case Break
85284>>>        Case End
85284>>>
85284>>>        Function_Return sReturnArray
85285>>>    End_Function
85286>>>
85286>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
85286>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
85288>>>        String[] sReturnArray
85289>>>        String sServer sConnectionString sSelect sSchema
85289>>>        Boolean bOK
85289>>>
85289>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85290>>>        If (bOK = False) Begin
85292>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
85293>>>>
85293>>>            Function_Return sReturnArray
85294>>>        End
85294>>>>
85294>>>
85294>>>        Get psConnectionString to sConnectionString
85295>>>        Get psSchema to sSchema
85296>>>
85296>>>        Case Begin
85296>>>            Case (sDriverID = MSSQLDRV_ID)
85298>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
85299>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
85300>>>                Case Break
85301>>>
85301>>>            Case (sDriverID = DB2_DRV_ID)
85304>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
85305>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
85306>>>                Case Break
85307>>>
85307>>>            Case (sDriverID = SQLFLEX)
85310>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
85311>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
85312>>>                Case Break
85313>>>
85313>>>            Case (sDriverID = MDSMySQL)
85316>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
85317>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
85318>>>                Case Break
85319>>>
85319>>>            Case (sDriverID = MDSPgSQL)
85322>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
85323>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
85324>>>                Case Break
85325>>>
85325>>>            Case (sDriverID = ORAFLEX)
85328>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
85329>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
85330>>>                Case Break
85331>>>
85331>>>            Case Else
85331>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
85332>>>>
85332>>>                Case Break
85333>>>        Case End
85333>>>
85333>>>        Function_Return sReturnArray
85334>>>    End_Function
85335>>>
85335>>>
85335>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
85335>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
85337>>>        String[] sReturnArray sReturnArray2
85339>>>        String sServer sConnectionString sSelect sSchema
85339>>>        Boolean bOK
85339>>>        Integer iCount iSize
85339>>>
85339>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85340>>>        If (bOK = False) Begin
85342>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
85343>>>>
85343>>>            Function_Return sReturnArray
85344>>>        End
85344>>>>
85344>>>
85344>>>        Get psConnectionString to sConnectionString
85345>>>        Get psSchema to sSchema
85346>>>
85346>>>        Case Begin
85346>>>            Case (sDriverID = MSSQLDRV_ID)
85348>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
85349>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
85350>>>                Case Break
85351>>>
85351>>>            Case (sDriverID = DB2_DRV_ID)
85354>>>                Error "Not implemented yet! The select statement has not been finalized."
85355>>>>
85355>>>//                Move () to sSelect
85355>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
85355>>>                Case Break
85356>>>
85356>>>            Case (sDriverID = SQLFLEX)
85359>>>                Error "Not implemented yet! The select statement has not been finalized."
85360>>>>
85360>>>//                Move () to sSelect
85360>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85360>>>                Case Break
85361>>>
85361>>>            Case (sDriverID = MDSMySQL)
85364>>>                Error "Not implemented yet! The select statement has not been finalized."
85365>>>>
85365>>>//                Move () to sSelect
85365>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85365>>>                Case Break
85366>>>
85366>>>            Case (sDriverID = MDSPgSQL)
85369>>>                Error "Not implemented yet! The select statement has not been finalized."
85370>>>>
85370>>>//                Move () to sSelect
85370>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85370>>>                Case Break
85371>>>
85371>>>            Case (sDriverID = ORAFLEX)
85374>>>                Error "Not implemented yet! The select statement has not been finalized."
85375>>>>
85375>>>//                Move () to sSelect
85375>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85375>>>                Case Break
85376>>>
85376>>>            Case Else
85376>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
85377>>>>
85377>>>                Case Break
85378>>>        Case End
85378>>>
85378>>>        Move (SizeOfArray(sReturnArray)) to iSize
85379>>>        Decrement iSize
85380>>>        For iCount from 0 to iSize
85386>>>>
85386>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
85388>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
85389>>>            End
85389>>>>
85389>>>        Loop
85390>>>>
85390>>>
85390>>>        Function_Return sReturnArray2
85391>>>    End_Function
85392>>>
85392>>>    // Returns a string array with all table names the passed table handle has relation ships with.
85392>>>    // The format of the array is "TableName.FieldName"
85392>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
85394>>>        String[] sFileNameArray sFieldNameArray
85396>>>        tSQLRelation[] sRelationsArray
85396>>>        tSQLRelation[] sRelationsArray
85397>>>        String sServer sConnectionString sSelect sSchema sFileName sFieldName sVal
85397>>>        Boolean bOK
85397>>>        Integer iCount iSize iLength iPos
85397>>>        Integer iFileNumber iFieldNumber
85397>>>
85397>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85398>>>        If (bOK = False) Begin
85400>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
85401>>>>
85401>>>            Function_Return sRelationsArray
85402>>>        End
85402>>>>
85402>>>
85402>>>        Get psConnectionString to sConnectionString
85403>>>        Get psSchema to sSchema
85404>>>
85404>>>        Case Begin
85404>>>            Case (sDriverID = MSSQLDRV_ID)
85406>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
85407>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
85408>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85409>>>                Case Break
85410>>>
85410>>>            Case (sDriverID = DB2_DRV_ID)
85413>>>                Error "Not implemented yet! The select statement has not been finalized."
85414>>>>
85414>>>//                Move () to sSelect
85414>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
85414>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85414>>>                Case Break
85415>>>
85415>>>            Case (sDriverID = SQLFLEX)
85418>>>                Error "Not implemented yet! The select statement has not been finalized."
85419>>>>
85419>>>//                Move () to sSelect
85419>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85419>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85419>>>                Case Break
85420>>>
85420>>>            Case (sDriverID = MDSMySQL)
85423>>>                Error "Not implemented yet! The select statement has not been finalized."
85424>>>>
85424>>>//                Move () to sSelect
85424>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85424>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85424>>>                Case Break
85425>>>
85425>>>            Case (sDriverID = MDSPgSQL)
85428>>>                Error "Not implemented yet! The select statement has not been finalized."
85429>>>>
85429>>>//                Move () to sSelect
85429>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85429>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85429>>>                Case Break
85430>>>
85430>>>            Case (sDriverID = ORAFLEX)
85433>>>                Error "Not implemented yet! The select statement has not been finalized."
85434>>>>
85434>>>//                Move () to sSelect
85434>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85434>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85434>>>                Case Break
85435>>>
85435>>>            Case Else
85435>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
85436>>>>
85436>>>                Case Break
85437>>>        Case End
85437>>>
85437>>>        Move (Length(sTableName)) to iLength
85438>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
85439>>>        Move (SizeOfArray(sFileNameArray)) to iSize
85440>>>        Decrement iSize
85441>>>        For iCount from 0 to iSize
85447>>>>
85447>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
85449>>>                Move sFileNameArray[iCount]         to sFileName
85450>>>                Move sFieldNameArray[iCount]        to sFieldName
85451>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
85452>>>                Move sFileName  to sRelationsArray[iCount].sFileName
85453>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
85454>>>            End
85454>>>>
85454>>>        Loop
85455>>>>
85455>>>
85455>>>        Function_Return sRelationsArray
85456>>>    End_Function
85457>>>
85457>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
85459>>>        tSQLLoggedInUser[] SQLLoggedInUser
85459>>>        tSQLLoggedInUser[] SQLLoggedInUser
85460>>>        String[] sUsers sPrograms
85462>>>        String sSelect
85462>>>        Integer iSize iCount
85462>>>
85462>>>        Case Begin
85462>>>            Case (sDriverID = MSSQLDRV_ID)
85464>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
85465>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
85466>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
85467>>>                Case Break
85468>>>            Case (sDriverID = SQLFLEX)
85471>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
85472>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
85473>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
85474>>>                Case Break
85475>>>            Case Else
85475>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
85476>>>>
85476>>>        Case End
85476>>>
85476>>>        Move (SizeOfArray(sUsers)) to iSize
85477>>>        Decrement iSize
85478>>>        For iCount from 0 to iSize
85484>>>>
85484>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
85485>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
85486>>>        Loop
85487>>>>
85487>>>
85487>>>        Function_Return SQLLoggedInUser
85488>>>    End_Function
85489>>>
85489>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
85489>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
85489>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
85491>>>        String[] sFilesData
85492>>>        Boolean bExists
85492>>>        Integer iCh
85492>>>        String sFileName sExt
85492>>>
85492>>>        Get vFolderExists sDataPath to bExists
85493>>>        If (bExists = True) Begin
85495>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
85496>>>            Move ("dir:" + sDataPath)      to sDataPath
85497>>>            Get Seq_New_Channel to iCh  // get free channel for input
85498>>>            Direct_Input channel iCh sDataPath
85500>>>                Repeat
85500>>>>
85500>>>                    Readln channel iCh sFileName
85502>>>                    Get ParseFileExtension sFileName to sExt
85503>>>                    If (Uppercase(sExt) = "INT") Begin
85505>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
85507>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
85508>>>                        End
85508>>>>
85508>>>                    End
85508>>>>
85508>>>                Until (SeqEof = True)
85510>>>            Close_Input channel iCh
85512>>>        End
85512>>>>
85512>>>        Function_Return sFilesData
85513>>>    End_Function
85514>>>
85514>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85514>>>    // Pass e.g. the psServer property to determine the current connection server.
85514>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85514>>>    // This handle can be used to obtain attributes about the server, such as default
85514>>>    // column types.
85514>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85516>>>        Handle hDatabase
85516>>>        Integer iDriver iServers iCount
85516>>>        String sValue
85516>>>
85516>>>        If (sServer = "") Begin
85518>>>            Function_Return 0
85519>>>        End
85519>>>>
85519>>>
85519>>>        Get DriverIndex sDriverID to iDriver
85520>>>        If (iDriver = 0) Begin
85522>>>            Function_Return 0
85523>>>        End
85523>>>>
85523>>>
85523>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85526>>>        For iCount from 1 to iServers
85532>>>>
85532>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85535>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85537>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85540>>>            End
85540>>>>
85540>>>        Loop
85541>>>>
85541>>>
85541>>>        Function_Return hDatabase
85542>>>    End_Function
85543>>>
85543>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85545>>>        String sConnectionString sMessage
85545>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85545>>>        Integer i iMsgs iFetchResult iResultCount iRowType iRows iErr iMessage iLastErr
85545>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85548>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85548>>>        TimeSpan tsQuery tsFetch
85548>>>        tSqlErrorArray aSqlErrorArray
85548>>>        tSqlErrorArray aSqlErrorArray
85548>>>        Boolean bOK bMertechDriver bShowProgress
85548>>>        tSQLConnection SQLConnection
85548>>>        tSQLConnection SQLConnection
85548>>>
85548>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85549>>>        If (bOK = False) Begin
85551>>>            Procedure_Return
85552>>>        End
85552>>>>
85552>>>
85552>>>        If (num_arguments > 2) Begin
85554>>>            Move bShowProgr to bShowProgress
85555>>>        End
85555>>>>
85555>>>
85555>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85556>>>
85556>>>        Get IsMertechDriver sDriverID to bMertechDriver
85557>>>        If (bMertechDriver = True) Begin
85559>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
85560>>>        End
85560>>>>
85560>>>        If (bMertechDriver = False) Begin
85562>>>            Get phoSQLManager to hoSqlHandler
85563>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85564>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85565>>>        End
85565>>>>
85565>>>
85565>>>        If (hoSQLConnect <> 0) Begin
85567>>>            Get SqlOpen of hoSQLConnect to hoStmt
85568>>>            If (hoStmt <> 0) Begin
85570>>>                // record starting date/time stamp
85570>>>                Move (CurrentDateTime()) to dtQueryExecStart
85571>>>                // turn on error handling if enabled
85571>>>                If (pbHandleQueryErrors(Self)) Begin
85573>>>                    Set pbSqlError to False
85574>>>                    Set paSqlErrorArray to aSqlErrorArray
85575>>>                    Move Error_Object_Id to hoError
85576>>>                    Move Self to Error_Object_Id
85577>>>                End
85577>>>>
85577>>>
85577>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85577>>>                Set psSQLStatementString to sStmt
85578>>>                Send SqlExecDirect of hoStmt sStmt
85579>>>
85579>>>                If (pbHandleQueryErrors(Self)) Begin
85581>>>                    Move hoError to Error_Object_Id
85582>>>                End
85582>>>>
85582>>>
85582>>>                Move 0 to iMsgs
85583>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
85583>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
85583>>>                If (bMertechDriver = False) Begin
85585>>>                    Move Err to iErr
85586>>>                    Move LastErr to iLastErr
85587>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85588>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85589>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85590>>>                    Send _SqlColumnInfo hoStmt
85591>>>                    Send Ignore_Error of Error_Object_Id 12289
85592>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85593>>>                    Repeat
85593>>>>
85593>>>                        Get SqlFetch of hoStmt to iFetchResult
85594>>>                        If (iFetchResult <> 0) Begin
85596>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85597>>>                        End
85597>>>>
85597>>>                    Until (iFetchResult = 0)
85599>>>                    Send Trap_Error of Error_Object_Id 12289
85600>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
85601>>>                    Move iErr to Err
85602>>>                    Move iLastErr to LastErr
85603>>>                    Set paSQLFetchResults to aSQLFetchResults
85604>>>                End
85604>>>>
85604>>>
85604>>>                Set piRows    to iRows
85605>>>                Set piRowType to iRowType
85606>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85607>>>                Move (CurrentDateTime()) to dtFetchStart
85608>>>
85608>>>                If (iMsgs <> 0) Begin
85610>>>                    If (ghoDbUpdateHandler > 0) Begin
85612>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85613>>>                    End
85613>>>>
85613>>>                    For i from 1 to iMsgs
85619>>>>
85619>>>                        Get SqlGetMessage of hoStmt i to sMessage
85620>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85621>>>                        If (bShowProgress = True) Begin
85623>>>                            If (Active_State(ghoStatusPanel)) Begin
85625>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85626>>>                            End
85626>>>>
85626>>>                            Else Begin
85627>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85629>>>                            End
85629>>>>
85629>>>                        End
85629>>>>
85629>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85630>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85631>>>                    Loop
85632>>>>
85632>>>                    If (ghoDbUpdateHandler > 0) Begin
85634>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85635>>>                    End
85635>>>>
85635>>>                    Set paQueryMessages to sMsg
85636>>>                End
85636>>>>
85636>>>                Move (CurrentDateTime()) to dtFetchEnd
85637>>>            End
85637>>>>
85637>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85638>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85639>>>            Set ptsQueryExec to tsQuery
85640>>>            Set ptsFetchResults to tsFetch
85641>>>            Send SqlClose of hoStmt
85642>>>        End
85642>>>>
85642>>>
85642>>>        Send SqlDisconnect of hoSQLConnect
85643>>>    End_Procedure
85644>>>
85644>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85644>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85644>>>    // Returns False if no error occured.
85644>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85646>>>        Boolean bOK bShowProgress
85646>>>        tSQLScriptArray SQLScriptArray
85646>>>        tSQLScriptArray SQLScriptArray
85646>>>        Integer iOut iRows iCount
85646>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85646>>>        TimeSpan tsTotalTime
85646>>>        String sMessage
85646>>>
85646>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85647>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
85648>>>        If (SQLScriptArray.bError = True) Begin
85650>>>            Function_Return False
85651>>>        End
85651>>>>
85651>>>
85651>>>        If (num_arguments > 3) Begin
85653>>>            Move bShowProgr to bShowProgress
85654>>>        End
85654>>>>
85654>>>
85654>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85655>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85656>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85657>>>
85657>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
85659>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
85660>>>>
85660>>>        End
85660>>>>
85660>>>
85660>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85661>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85662>>>        Set ptsTotalQueryTime to tsTotalTime
85663>>>
85663>>>        Function_Return bOK
85664>>>    End_Procedure
85665>>>
85665>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85665>>>//        String sRootName
85665>>>//        Boolean bOK
85665>>>//
85665>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85665>>>//        Move (sRootName contains sDriverID) to bOK
85665>>>//
85665>>>//        Function_Return bOK
85665>>>//    End_Function
85665>>>
85665>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85665>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85665>>>//        Integer iDbType
85665>>>//        Boolean bOK
85665>>>//
85665>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85665>>>//        If (bOK = True) Begin
85665>>>//            Function_Return False
85665>>>//        End
85665>>>//
85665>>>//        Get psDriverID to sDriverID
85665>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85665>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85665>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85665>>>//
85665>>>//        Get psDriverID to sDriverID
85665>>>//        Get piDbType   to iDbType
85665>>>//        Get psSchema   to sSchema
85665>>>//        If (sSchema = "") Begin
85665>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85665>>>//        End
85665>>>//
85665>>>//        Move (Uppercase(sDisplayName)) to sVal
85665>>>//        If (not(sVal contains (sSchema + "."))) Begin
85665>>>//            If (iDbType = EN_dbTypeDB2) Begin
85665>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85665>>>//            End
85665>>>//            Else Begin
85665>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85665>>>//            End
85665>>>//        End
85665>>>//
85665>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85665>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85665>>>//
85665>>>//        Function_Return True
85665>>>//    End_Function
85665>>>
85665>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
85665>>>    // from the passed filelist.
85665>>>    // Returns the number of tables affected.
85665>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85667>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85667>>>        Integer iRetval
85667>>>        Handle hTable
85667>>>
85667>>>        // We first save the current filelist as the passed filelist name
85667>>>        // may come from another workspace, to restore it when we're ready.
85667>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85670>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85673>>>        Move 0 to hTable
85674>>>        Move 0 to iRetval
85675>>>
85675>>>        Repeat
85675>>>>
85675>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85678>>>            If (hTable <> 0) Begin
85680>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85683>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85686>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85689>>>                Move (Uppercase(sRootName)) to sVal
85690>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85692>>>                    // Prefixes:
85692>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85693>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85694>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85695>>>                    // Suffixes:
85695>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85696>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85697>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85698>>>
85698>>>                    // Change Filelist entry:
85698>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85701>>>
85701>>>                    Move (Lowercase(sDisplayName)) to sVal
85702>>>                    If (sVal contains "dbo.") Begin
85704>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85705>>>
85705>>>                        // Change Filelist entry:
85705>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85708>>>                    End
85708>>>>
85708>>>                    Increment iRetval
85709>>>                End
85709>>>>
85709>>>            End
85709>>>>
85709>>>        Until (hTable = 0)
85711>>>
85711>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85714>>>
85714>>>        Function_Return iRetval
85715>>>    End_Function
85716>>>
85716>>>    // To open all Sql based tables in Filelist.cfg
85716>>>    Procedure SqlUtilOpenAllTables
85718>>>        Handle hTable
85718>>>        String sRoot sDriverID
85718>>>        Boolean bOK
85718>>>
85718>>>        Move 0 to hTable
85719>>>        Move "" to sDriverID
85720>>>        Get AutoConnectionIDLogin to bOK
85721>>>
85721>>>        Repeat
85721>>>>
85721>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85724>>>            If (hTable > 0) Begin
85726>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85729>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85731>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85734>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85736>>>                        Open hTable
85738>>>                    End
85738>>>>
85738>>>                End
85738>>>>
85738>>>            End
85738>>>>
85738>>>
85738>>>        Until (hTable = 0)
85740>>>    End_Procedure
85741>>>
85741>>>    // This function allows you to put an Sql script in a CM Image. It makes it easier to
85741>>>    // copy and paste between a DataFlex program and an Sql Editor.
85741>>>    Function SqlUtilLoadImageFile String sFileName Returns String
85743>>>        Integer iChannel iPos
85743>>>        String sTextValue sLine sPath
85743>>>        Boolean bSeqEof
85743>>>
85743>>>        Move "" to sTextValue
85744>>>        Get ParseFolderName sFileName to sPath
85745>>>        If (Trim(sPath) = "") Begin
85747>>>            Get psDataPathFirstPart to sPath
85748>>>            Move (sPath + sFileName) to sFileName
85749>>>        End
85749>>>>
85749>>>
85749>>>        Get Seq_New_Channel to iChannel
85750>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85752>>>            Error DFERR_PROGRAM "No channel available..."
85753>>>>
85753>>>        End
85753>>>>
85753>>>        Else Begin
85754>>>            Direct_Input channel iChannel sFileName
85756>>>            Move (SeqEof) to bSeqEof
85757>>>            If (bSeqEof = True) Begin
85759>>>                Send Seq_Release_Channel iChannel
85760>>>                Set psSQLStatementString to ""
85761>>>                Error DFERR_PROGRAM ("The Sql script file:\n" + sFileName + "\nCould not be found.")
85762>>>>
85762>>>                Function_Return ""
85763>>>            End
85763>>>>
85763>>>
85763>>>            While (not(bSeqEof))
85767>>>                Readln channel iChannel sLine
85769>>>                Move (Pos("/", sLine)) to iPos
85770>>>                Move (SeqEol) to bSeqEof
85771>>>                If (not(bSeqEof) and iPos <> 1) Begin
85773>>>                    Move (sTextValue + sLine + Character(13)) to sTextValue
85774>>>                End
85774>>>>
85774>>>            Loop
85775>>>>
85775>>>            Send Seq_Release_Channel iChannel
85776>>>        End
85776>>>>
85776>>>
85776>>>        Set psSQLStatementString to sTextValue
85777>>>        Function_Return sTextValue
85778>>>    End_Function
85779>>>
85779>>>    // Reads an Sql script that have been compiled into the program as an "image" (/MyImageName) and returns the full script as a string.
85779>>>    // Usage: Get SqlUtilReadScriptFromCMImage of ghoDbUpdateFunctionLibrary CreatevwWorkflowInbox.n
85779>>>    //
85779>>>    // This is a trick to use an old DataFlex feature/syntax to include "image names" at the top
85779>>>    // of a file. Each such section must end with a "/*".
85779>>>    // Note: Sql script files remarks/comments cannot be handled by the DataFlex compiler. All Sql comment
85779>>>    //       sections in the "xxx.pkg.sql" file _must_ be removed.
85779>>>//    Function SqlUtilReadScriptFromCMImage Integer iImg Returns tSQLScriptResult
85779>>>//        Integer iChannel iPos
85779>>>//        String sTextValue sLine
85779>>>//        Boolean bSeqEof
85779>>>//        tSQLScriptResult SqlScriptResult
85779>>>//
85779>>>//        Move "" to sTextValue
85779>>>//
85779>>>//        Get Seq_New_Channel to iChannel
85779>>>//        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85779>>>//            Error DFERR_PROGRAM "No channel available..."
85779>>>//            Function_Return ""
85779>>>//        End
85779>>>//
85779>>>//        Get SqlUtilCheckScriptSize False "" iImg True to SqlScriptResult
85779>>>//
85779>>>//        Direct_Input channel iChannel ("image: " + String(iImg))
85779>>>//        Move (SeqEof) to bSeqEof
85779>>>//        While (not(bSeqEof))
85779>>>//            Readln channel iChannel sLine
85779>>>//            Move (SeqEol) to bSeqEof
85779>>>//            If (not(bSeqEof)) Begin
85779>>>//                Move (Trim(sLine)) to sLine
85779>>>//                If (Left(sLine, 2) <> (Character(47) + Character(47))) Begin // ASCII 47 = "/" (Comments)
85779>>>//                    Move (sTextValue + sLine + character(13)) to sTextValue
85779>>>//                End
85779>>>//            End
85779>>>//        Loop
85779>>>//        Send Seq_Release_Channel iChannel
85779>>>//
85779>>>//        Set psSQLStatementString to sTextValue
85779>>>//        Move sTextValue to SqlScriptResult.sSQLScript
85779>>>//        Function_Return SqlScriptResult
85779>>>//    End_Function
85779>>>
85779>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85779>>>//        String sRetval sDriverID
85779>>>//        String sTableName
85779>>>//        Integer iDbType iIndex
85779>>>//        Boolean bOK
85779>>>//
85779>>>//        Get psDriverID to sDriverID
85779>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85779>>>//        If (hTable = 0 or bOK = False) Begin
85779>>>//            Function_Return ""
85779>>>//        End
85779>>>//
85779>>>//        Move False to Err
85779>>>//        Get UtilTableHandleToString hTable to sTableName
85779>>>//        Get piDbType to iDbType
85779>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85779>>>//        If (iIndex = -1) Begin
85779>>>//            Function_Return ""
85779>>>//        End
85779>>>//
85779>>>//        Function_Return sRetval
85779>>>//    End_Function
85779>>>
85779>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
85781>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
85781>>>        Boolean bOpened bOK bMertech
85781>>>        
85781>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85784>>>        Get _TableNameOnly sRootName to sDatabaseName
85785>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
85785>>>        // which makes the program unable to run because they can't be opened.
85785>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
85785>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
85785>>>        // proper .int files for the two tables.
85785>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
85787>>>            Function_Return True
85788>>>        End                     
85788>>>>
85788>>>        
85788>>>        Move CS_OEM_Txt  to sOrgFormat
85789>>>        Move CS_ANSI_Txt to sNewFormat
85790>>>        Get AutoConnectionIDLogin to bOK
85791>>>        Send Ignore_Error of Error_Object_Id DFERR_MISSING_VALUE
85792>>>        Open hTable
85794>>>        Send Trap_Error of Error_Object_Id DFERR_MISSING_VALUE
85795>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85798>>>
85798>>>        // ToDo: What to do if we cannot open the table?!
85798>>>        If (bOpened = False) Begin
85800>>>            Function_Return False
85801>>>        End
85801>>>>
85801>>>
85801>>>        Get psDriverID to sDriverID
85802>>>        Get IsMertechDriver sDriverID to bMertech
85803>>>        If (bMertech = True) Begin
85805>>>            Get psDataPathFirstPart to sDataPath
85806>>>            Get vFolderExists sDataPath to bOK
85807>>>            If (bOK = False) Begin
85809>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
85810>>>>
85810>>>                Function_Return False
85811>>>            End
85811>>>>
85811>>>            Get vFolderFormat sDataPath to sDataPath
85812>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85815>>>            Get _TableNameOnly sRootName to sDatabaseName
85816>>>            Move sDatabaseName to sPhysicalFileName
85817>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
85818>>>            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
85819>>>            Function_Return (bOK = True)
85820>>>        End
85820>>>>
85820>>>
85820>>>        Move False to Err
85821>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
85824>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
85825>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
85825>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
85825>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
85826>>>
85826>>>        Structure_Start hTable
85827>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
85830>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
85833>>>        Structure_End hTable (DF_STRUCTEND_OPT_IN_PLACE ior DF_STRUCTEND_OPT_FORCE)
85835>>>
85835>>>        Function_Return (Err = False)
85836>>>    End_Function
85837>>>
85837>>>    // Checks if the passed Table;
85837>>>    // 1) Already has a Filelist entry that points to SQL and
85837>>>    // 2) It has an .int file.
85837>>>    // If both is True it should already be connected to SQL
85837>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85839>>>        Boolean bExists bRootName
85839>>>        String sRootName sDataPath
85839>>>        Integer iCount
85839>>>
85839>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85842>>>        Move (sRootName contains sDriverID) to bRootName
85843>>>
85843>>>        Get psDataPathFirstPart to sDataPath
85844>>>        Get vFolderExists sDataPath to bExists
85845>>>        If (bExists = False) Begin
85847>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85847>>>            Function_Return False
85848>>>        End
85848>>>>
85848>>>
85848>>>        Get vFolderFormat sDataPath to sDataPath
85849>>>        Get _TableNameOnly sRootName to sRootName
85850>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85851>>>
85851>>>        Function_Return (bRootName = True and bExists = True)
85852>>>    End_Function
85853>>>
85853>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85855>>>        Boolean bViewTableType bOpen bMertechDriver bOK
85855>>>        Integer hoSQLHandler
85855>>>        Integer iTableCount iNumTables iPos iTableIndex
85855>>>        String sTableName sOwner sTableType sLogin sEnumTableName sEnumSchemaName sCurrent_Login
85855>>>        Handle hoCliHandler
85855>>>        tSQLConnection SQLConnection
85855>>>        tSQLConnection SQLConnection
85855>>>
85855>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85858>>>        If (bOpen = False) Begin
85860>>>            Get AutoConnectionIDLogin to bOK
85861>>>            Open hTable
85863>>>        End
85863>>>>
85863>>>
85863>>>        Get pSQLConnection to SQLConnection
85864>>>        Get phoCLIHandler to hoCliHandler
85865>>>        Set psDriverID of hoCliHandler to sDriverID
85866>>>
85866>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85869>>>        Get _TableNameOnly sTableName to sTableName
85870>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85873>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85874>>>
85874>>>        For iTableCount from 1 to iNumTables
85880>>>>
85880>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85881>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85882>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85884>>>                Get TableType of hoCliHandler iTableCount to sTableType
85885>>>                Move iNumTables to iTableCount // We're done.
85886>>>            End
85886>>>>
85886>>>        Loop
85887>>>>
85887>>>
85887>>>        Move (sTableType = "VIEW") to bViewTableType
85888>>>        If (bOpen = False) Begin
85890>>>            Close hTable
85891>>>        End
85891>>>>
85891>>>
85891>>>        Function_Return bViewTableType
85892>>>    End_Function
85893>>>
85893>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85893>>>    //
85893>>>    // SQL utility function that returns a database type (string) constant
85893>>>    // corresponding to the passed iDbType.
85893>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85895>>>        String sRetval
85895>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85896>>>        Function_Return sRetval
85897>>>    End_Function
85898>>>
85898>>>    // SQL utility function that returns a database type constant (integer)
85898>>>    // corresponding to the passed sDbType string constant.
85898>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85900>>>        Integer iRetval
85900>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85901>>>        Function_Return iRetval
85902>>>    End_Function
85903>>>
85903>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85903>>>    // Used e.g. when reading a connection ini-file to display the database type in
85903>>>    // the SQL Connection program's grid.
85903>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85905>>>        String sRetval
85905>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85906>>>        Function_Return sRetval
85907>>>    End_Function
85908>>>
85908>>>    // Pass a driver name as a string and the function will return
85908>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85908>>>    // quite work and always returns "MS SQL Server"
85908>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85910>>>        Integer iRetval
85910>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85911>>>        Function_Return iRetval
85912>>>    End_Function
85913>>>
85913>>>    // *** Helper Functions ***
85913>>>    // They all start with an underscore: "_" in the function name.
85913>>>    //
85913>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
85913>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
85913>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
85913>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
85915>>>        Integer iChannel iArgumentSize iOut iChunk iPointer iCount iSize
85915>>>        Number nByteCount
85915>>>        String sCharacter sSQLScript
85915>>>        Boolean bSeqEof
85915>>>        tSQLScriptArray SqlScriptArray
85915>>>        tSQLScriptArray SqlScriptArray
85915>>>        UChar[] uCharData
85916>>>
85916>>>        Move False to Err
85917>>>        Get Seq_New_Channel to iChannel
85918>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85920>>>            Error DFERR_PROGRAM 'No channel available...'
85921>>>>
85921>>>            Move True to SqlScriptArray.bError
85922>>>            Function_Return SqlScriptArray
85923>>>        End
85923>>>>
85923>>>
85923>>>        // First decide the size of the script
85923>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
85925>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
85927>>>        Close_Input channel iChannel
85929>>>
85929>>>        Move (SizeOfArray(uCharData)) to nByteCount
85930>>>        If (nByteCount  < 1) Begin
85932>>>            Send Seq_Release_Channel iChannel
85933>>>            Move True to SqlScriptArray.bError
85934>>>            Function_Return SqlScriptArray
85935>>>        End
85935>>>>
85935>>>
85935>>>        // If necessary change the string argument_size
85935>>>        Get_Argument_Size to iArgumentSize
85936>>>        If (nByteCount >= iArgumentSize) Begin
85938>>>            Move (nByteCount + 2048) to nByteCount
85939>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
85940>>>>
85940>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
85941>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
85942>>>        End
85942>>>>
85942>>>        Else Begin
85943>>>            Move False to SqlScriptArray.bArgumentSizeChanged
85944>>>        End
85944>>>>
85944>>>
85944>>>        // Read the script file from memory line-by-line
85944>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
85946>>>            Move 0 to iCount
85947>>>            Repeat
85947>>>>
85947>>>                Readln channel iChannel sSQLScript
85949>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
85950>>>                Increment iCount
85951>>>            Until (SeqEof = True)
85953>>>        Close_Input channel iChannel
85955>>>        Send Seq_Release_Channel iChannel
85956>>>
85956>>>        // Finally "sanitize" the script by removing all comments.
85956>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
85957>>>
85957>>>        Function_Return SqlScriptArray
85958>>>    End_Function
85959>>>
85959>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
85961>>>        String sSQLVal sStmt sCR sDebugFileName sTmp sGOKeyWord sNoCountKeyWord sMessage sExportFile
85961>>>        Handle hoSql hoSQLConnect hoStmt hoError
85961>>>        Integer i iMsgs iFetchResult iResultCount iRows iRowType iCount iChunkCounter iChunkMax iPos iOut iNextSet iMessage
85961>>>        String[] sMsg aSQLQueryMessages
85963>>>        DateTime dtQueryExecStart dtQueryExecEnd
85963>>>        TimeSpan tsQuery
85963>>>        tSqlErrorArray aSqlErrorArray
85963>>>        tSqlErrorArray aSqlErrorArray
85963>>>        tSQLConnection SQLConnection
85963>>>        tSQLConnection SQLConnection
85963>>>        Boolean bOK bMertechDriver bShowProgress
85963>>>
85963>>>        If (num_arguments > 4) Begin
85965>>>            Move bShowProgr to bShowProgress
85966>>>        End
85966>>>>
85966>>>        Get IsMertechDriver sDriverID to bMertechDriver
85967>>>        If (bMertechDriver = False) Begin
85969>>>            Get phoSQLManager to hoSql
85970>>>        End
85970>>>>
85970>>>        Else Begin
85971>>>            Get _MertechSQLManagerHandle to hoSql
85972>>>        End
85972>>>>
85972>>>
85972>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
85973>>>        // There seems to be a problem to pass strings when their value gets really big, aka
85973>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
85973>>>        // or later SqlExecDirect stops working correctly with no error messages!
85973>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
85973>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
85973>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
85973>>>        Get piChunkMax to iChunkMax
85974>>>        Move 0 to iChunkCounter
85975>>>        Move "" to sStmt
85976>>>
85976>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
85977>>>        Move (Character(13) + Character(10)) to sCR
85978>>>
85978>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85979>>>
85979>>>        If (bMertechDriver = True) Begin
85981>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
85982>>>        End
85982>>>>
85982>>>        If (bMertechDriver = False) Begin
85984>>>            Get phoSQLManager  to hoSQL
85985>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
85986>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
85987>>>        End
85987>>>>
85987>>>
85987>>>        If (hoSQLConnect <> 0) Begin
85989>>>            Move False to Err
85990>>>            Get SqlOpen of hoSQLConnect to hoStmt
85991>>>            If (hoStmt <> 0) Begin
85993>>>
85993>>>                // If the embedded resource should be written as a script file to disk:
85993>>>                If (bCreateScriptFile = True) Begin
85995>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
85996>>>                    Get vFolderFormat sExportFile to sExportFile
85997>>>                    Move (sExportFile + sMemFileName) to sExportFile
85998>>>                    Get Seq_New_Channel to iOut
85999>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
86001>>>                        Direct_Output channel iOut sExportFile
86003>>>                    End
86003>>>>
86003>>>                End
86003>>>>
86003>>>
86003>>>                // Record starting date/time stamp
86003>>>                Move (CurrentDateTime()) to dtQueryExecStart
86004>>>                // Turn on error handling if enabled
86004>>>                If (pbHandleQueryErrors(Self)) Begin
86006>>>                    Set pbSqlError to False
86007>>>                    Set paSqlErrorArray to aSqlErrorArray
86008>>>                    Move Error_Object_Id to hoError
86009>>>                    Move Self to Error_Object_Id
86010>>>                End
86010>>>>
86010>>>
86010>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
86011>>>                Decrement iRows
86012>>>                Move (sNoCountKeyWord + sCR) to sStmt
86013>>>
86013>>>                For iCount from 0 to iRows
86019>>>>
86019>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
86020>>>
86020>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
86022>>>                        If (sSQLVal <> "") Begin
86024>>>                            Move (sSQLVal + sCR) to sSQLVal
86025>>>                        End
86025>>>>
86025>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
86026>>>                    End
86026>>>>
86026>>>
86026>>>                    // - Each time we encounter a "GO" statement we execute it,
86026>>>                    // or if at the very end of the script.
86026>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
86028>>>
86028>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
86028>>>                        // instead of all in one go.
86028>>>                        Send SqlExecDirect of hoStmt sStmt
86029>>>
86029>>>                        If (bCreateScriptFile = True) Begin
86031>>>                            Write channel iOut sStmt
86033>>>                        End
86033>>>>
86033>>>                        Move "" to sStmt
86034>>>                        Move 0 to iChunkCounter
86035>>>                    End
86035>>>>
86035>>>                    Increment iChunkCounter
86036>>>                Loop
86037>>>>
86037>>>
86037>>>                Repeat
86037>>>>
86037>>>                    If (pbHandleQueryErrors(Self)) Begin
86039>>>                        Move hoError to Error_Object_Id
86040>>>                    End
86040>>>>
86040>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
86041>>>
86041>>>                    Send _SqlColumnInfo hoStmt
86042>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
86043>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
86044>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
86045>>>                    Set piRows    to iRows
86046>>>                    Set piRowType to iRowType
86047>>>
86047>>>                    If (iMsgs <> 0) Begin
86049>>>                        If (ghoDbUpdateHandler > 0) Begin
86051>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
86052>>>                        End
86052>>>>
86052>>>                        For i from 1 to iMsgs
86058>>>>
86058>>>                            Get SqlGetMessage of hoStmt i to sMessage
86059>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
86060>>>                            If (bShowProgress = True) Begin
86062>>>                                If (Active_State(ghoStatusPanel)) Begin
86064>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
86065>>>                                End
86065>>>>
86065>>>                                Else Begin
86066>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
86068>>>                                End
86068>>>>
86068>>>                            End
86068>>>>
86068>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
86069>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
86070>>>                        Loop
86071>>>>
86071>>>
86071>>>
86071>>>                        If (ghoDbUpdateHandler > 0) Begin
86073>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
86074>>>                        End
86074>>>>
86074>>>                        Set paQueryMessages to sMsg
86075>>>                    End
86075>>>>
86075>>>
86075>>>                    Get SQLNextResultSet of hoStmt to iNextSet
86076>>>                Until (iNextSet = 0)
86078>>>
86078>>>                Move (CurrentDateTime()) to dtQueryExecEnd
86079>>>            End
86079>>>>
86079>>>
86079>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
86080>>>            Set ptsQueryExec to tsQuery
86081>>>            Send SqlClose of hoStmt
86082>>>
86082>>>            If (bCreateScriptFile = True) Begin
86084>>>                Close_Output channel iOut
86086>>>                Send Seq_Release_Channel iOut
86087>>>            End
86087>>>>
86087>>>        End
86087>>>>
86087>>>        Send SqlDisconnect of hoSQLConnect
86088>>>
86088>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
86089>>>    End_Function
86090>>>
86090>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
86090>>>    // for DAW drivers.
86090>>>    // Returns: A string array.
86090>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
86092>>>        String[] sReturnArray
86093>>>        String sValue sPrevious
86093>>>        Handle hoSQLHandler hoSQLConnect hstmt
86093>>>        Integer iFetchResult iRows
86093>>>        tSQLConnection SQLConnection
86093>>>        tSQLConnection SQLConnection
86093>>>
86093>>>        Get phoSQLManager to hoSQLHandler
86094>>>
86094>>>        If (hoSQLHandler <> 0) Begin
86096>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86097>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
86098>>>
86098>>>            If (hoSQLConnect <> 0) Begin
86100>>>                Get SQLOpen of hoSQLConnect to hstmt
86101>>>                If (hstmt <> 0) Begin
86103>>>                    Send SqlExecDirect of hstmt sStmt
86104>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
86105>>>                    Repeat
86105>>>>
86105>>>                        Get SQLFetch of hstmt to iFetchResult
86106>>>                        If (iFetchResult <> 0) Begin
86108>>>                            Get SQLColumnValue of hstmt iColumn to sValue
86109>>>                            If (sValue <> sPrevious) Begin
86111>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86112>>>                            End
86112>>>>
86112>>>                            Move sValue to sPrevious
86113>>>                        End
86113>>>>
86113>>>                    Until (iFetchResult = 0)
86115>>>                    Send SQLClose of hstmt
86116>>>                End
86116>>>>
86116>>>                Send SQLDisconnect of hoSQLConnect
86117>>>            End
86117>>>>
86117>>>        End
86117>>>>
86117>>>
86117>>>        Function_Return sReturnArray
86118>>>    End_Function
86119>>>
86119>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
86119>>>    // for Mertech drivers.
86119>>>    // Returns: A string array.
86119>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
86121>>>        String[] sReturnArray
86122>>>        String sValue sUserID sPassword
86122>>>        Handle hoSQLHandler hoSQLConnect hStmt
86122>>>        Integer iFetchResult iRows
86122>>>        tSQLConnection SQLConnection
86122>>>        tSQLConnection SQLConnection
86122>>>
86122>>>        Get _MertechSQLManagerHandle to hoSQLHandler
86123>>>
86123>>>        If (hoSQLHandler <> 0) Begin
86125>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86126>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
86127>>>
86127>>>            If (hoSQLConnect <> 0) Begin
86129>>>                Get SQLOpen of hoSQLConnect to hStmt
86130>>>                If (hStmt <> 0) Begin
86132>>>                    Send SqlExecDirect of hStmt sStmt
86133>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
86134>>>                    Repeat
86134>>>>
86134>>>                        Get SQLFetch of hStmt to iFetchResult
86135>>>                        If (iFetchResult <> 0) Begin
86137>>>                            Get SQLColumnValue of hStmt 1 to sValue
86138>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86139>>>                        End
86139>>>>
86139>>>                    Until (iFetchResult = 0)
86141>>>                    Send SQLClose of hStmt
86142>>>                End
86142>>>>
86142>>>                Send SQLDisconnect of hoSQLConnect
86143>>>            End
86143>>>>
86143>>>        End
86143>>>>
86143>>>
86143>>>        Function_Return sReturnArray
86144>>>    End_Function
86145>>>
86145>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
86145>>>    // will be used.
86145>>>    Function SqlUtilBackupDatabaseToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
86147>>>        Boolean bOK bExists bShowProgress
86147>>>        String sStatement sDriverID
86147>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
86147>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
86147>>>        Integer iDbType
86147>>>
86147>>>        If (sDatabase = "") Begin
86149>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
86150>>>>
86150>>>            Function_Return False
86151>>>        End
86151>>>>
86151>>>        If (sBackupName = "") Begin
86153>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
86154>>>>
86154>>>            Function_Return False
86155>>>        End
86155>>>>
86155>>>
86155>>>        // Create backup-folder if it doesn't exist
86155>>>        Get vFolderExists sPath to bExists
86156>>>        If (bExists = False) Begin
86158>>>            Get vCreateDirectory sPath to bOK
86159>>>            If (bOK = False) Begin
86161>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
86162>>>>
86162>>>                Function_Return False
86163>>>            End
86163>>>>
86163>>>        End
86163>>>>
86163>>>        // Make sure the path ends with a back-slash
86163>>>        If (sPath <> "") Begin
86165>>>            Get vFolderFormat sPath to sPath
86166>>>        End
86166>>>>
86166>>>
86166>>>        Get psDriverID to sDriverID
86167>>>        Get piDbType   to iDbType
86168>>>        If (num_arguments > 3) Begin
86170>>>            Move bShowProg to bShowProgress
86171>>>        End
86171>>>>
86171>>>
86171>>>        Case Begin
86171>>>            Case (iDbType = EN_DbTypeMSSQL)
86173>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
86173>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
86173>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
86174>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
86175>>>
86175>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
86176>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
86177>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
86178>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
86179>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
86180>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
86181>>>                Case Break
86182>>>            Case Else
86182>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
86183>>>        Case End
86183>>>
86183>>>        Function_Return bOK
86184>>>    End_Function
86185>>>
86185>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
86185>>>    // that "fits" in the max allowed length for table names.
86185>>>    // Max number of characters allowed for table names;
86185>>>    // IBM DB2      = 128
86185>>>    // MS-SQL       = 128
86185>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
86185>>>    // MySQL        = 64
86185>>>    // PostgreSQL   = 64
86185>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
86187>>>        String sGUIDName
86187>>>        Integer iDbType iLength
86187>>>        
86187>>>        Get piDbType to iDbType
86188>>>        Move (RandomHexUUID()) to sGUIDName
86189>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
86190>>>        Move (Length(sGUIDName)) to iLength
86191>>>        
86191>>>        Case Begin
86191>>>            Case (iDbType = EN_DbTypeDB2)
86193>>>            If (iLength > 128) Begin
86195>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86196>>>            End
86196>>>>
86196>>>            Case Break
86197>>>
86197>>>            Case (iDbType = EN_DbTypeMSSQL)
86200>>>            If (iLength > 128) Begin
86202>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86203>>>            End
86203>>>>
86203>>>            Case Break
86204>>>
86204>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
86207>>>            If (iLength > 128) Begin
86209>>>                Move (Left(sGUIDName, 128)) to sGUIDName
86210>>>            End
86210>>>>
86210>>>            Case Break
86211>>>
86211>>>            Case (iDbType = EN_DbTypeMySQL)
86214>>>            If (iLength > 64) Begin
86216>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86217>>>            End
86217>>>>
86217>>>            Case Break
86218>>>
86218>>>            Case (iDbType = EN_DbTypePostgre)
86221>>>            If (iLength > 64) Begin
86223>>>                Move (Left(sGUIDName, 64)) to sGUIDName
86224>>>            End
86224>>>>
86224>>>        Case End
86224>>>       
86224>>>        Function_Return sGUIDName   
86225>>>    End_Function
86226>>>       
86226>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
86226>>>    // Pass the memory resource file reference and the filename to be created,
86226>>>    // including full path.
86226>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
86228>>>        String sText
86228>>>        Integer iCh iSize iArgSize
86228>>>
86228>>>        Move ("Resource:" + sMemFileName) to sMemFileName
86229>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
86230>>>            Get_Channel_Size iCh to iSize
86231>>>            Get_Argument_Size to iArgSize
86232>>>            If (iSize > iArgSize) Begin
86234>>>                Set_Argument_Size iSize
86235>>>>
86235>>>            End
86235>>>>
86235>>>            Read_Block channel iCh sText iSize
86237>>>        Send Seq_Close_Channel iCh
86238>>>
86238>>>        Get Seq_Open_Output_Channel sFileName to iCh
86239>>>            Write channel iCh sText
86241>>>        Send Seq_Close_Channel iCh
86242>>>
86242>>>        If (iSize <> iArgSize) Begin
86244>>>            Set_Argument_Size iArgSize
86245>>>>
86245>>>        End
86245>>>>
86245>>>
86245>>>        // Wait for file to be written to disk.
86245>>>        Sleep 2
86246>>>    End_Procedure
86247>>>
86247>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
86249>>>        String sNotNull sRetval sDefaultValue
86249>>>        Boolean bOK
86249>>>
86249>>>        Get IsSQLDriver sDriverID to bOK
86250>>>        If (bOK = False) Begin
86252>>>            Function_Return ""
86253>>>        End
86253>>>>
86253>>>
86253>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
86254>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
86255>>>
86255>>>        Case Begin
86255>>>            Case (iDbType = EN_dbTypeMSSQL)
86257>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
86258>>>                Case Break
86259>>>            Case (iDbType = EN_dbTypeMySQL)
86262>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86263>>>                Case Break
86264>>>            Case (iDbType = EN_dbTypePostgre)
86267>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86268>>>                Case Break
86269>>>            Case (iDbType = EN_dbTypeDB2)
86272>>>                Move (String(sNotNull))                                     to sRetval
86273>>>                Case Break
86274>>>
86274>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86274>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86274>>>            Case (iDbType = EN_dbTypeOracle)
86277>>>                Move  ""                                                    to sRetval
86278>>>                Case Break
86279>>>
86279>>>            Case Else
86279>>>                Move  ""                                                    to sRetval
86280>>>        Case End
86280>>>
86280>>>        Function_Return sRetval
86281>>>    End_Function
86282>>>
86282>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
86284>>>        String[] sReturnArray
86285>>>        String sValue sUserID sPassword
86285>>>        Handle hoSQLHandler hoSQLConnect hStmt
86285>>>        Integer iFetchResult iRetval
86285>>>        tSQLConnection SQLConnection
86285>>>        tSQLConnection SQLConnection
86285>>>
86285>>>        Get _MertechSQLManagerHandle to hoSQLHandler
86286>>>        If (hoSQLHandler <> 0) Begin
86288>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86289>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
86290>>>            If (hoSQLConnect <> 0) Begin
86292>>>                Get SQLOpen of hoSQLConnect to hStmt
86293>>>                If (hStmt <> 0) Begin
86295>>>                    Send SQLSetProcedureName of hStmt sStmt
86296>>>                    If (sArgument <> "") Begin
86298>>>                        Send SqlSetArgument  of hStmt 1 sArgument
86299>>>                    End
86299>>>>
86299>>>                    Send SQLCall of hStmt
86300>>>
86300>>>                    Get SqlReturnValue       of hStmt to iRetval
86301>>>                    If (iRetval = 0) Begin
86303>>>                        Repeat
86303>>>>
86303>>>                            Get SQLFetch of hStmt to iFetchResult
86304>>>                            If (iFetchResult <> 0) Begin
86306>>>                                Get SQLColumnValue of hStmt 1 to sValue
86307>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
86308>>>                            End
86308>>>>
86308>>>                        Until (iFetchResult = 0)
86310>>>                        Send SQLClose of hStmt
86311>>>                    End
86311>>>>
86311>>>                End
86311>>>>
86311>>>                Send SQLDisconnect of hoSQLConnect
86312>>>            End
86312>>>>
86312>>>        End
86312>>>>
86312>>>
86312>>>        Function_Return sReturnArray
86313>>>    End_Function
86314>>>
86314>>>    // Returns the index for the passed sTableName
86314>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
86314>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
86316>>>        Integer iIndex iSize iCount
86316>>>        String[] sTablesArray
86317>>>        String sVal sConnectionString
86317>>>
86317>>>        Move -1 to iIndex
86318>>>        Get psConnectionString to sConnectionString
86319>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
86320>>>        Move (SizeOfArray(sTablesArray)) to iSize
86321>>>        Decrement iSize
86322>>>        For iCount from 0 to iSize
86328>>>>
86328>>>            Move sTablesArray[iCount] to sVal
86329>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
86331>>>                Move iCount to iIndex // We found it!
86332>>>                Move iSize to iCount  // End the loop
86333>>>            End
86333>>>>
86333>>>        Loop
86334>>>>
86334>>>
86334>>>        Function_Return iIndex
86335>>>    End_Function
86336>>>
86336>>>    // Helper function that builds a string like;
86336>>>    // "SELECT name from [Master].[sys].[databases] where name"
86336>>>    Function _SqlSelectFromWhereName Returns String
86338>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
86338>>>
86338>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
86339>>>        Get _SqlFindKeyWord CI_SQLName         to sName
86340>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
86341>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
86342>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
86343>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
86344>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
86345>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
86346>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
86347>>>        Function_Return sRetval
86348>>>    End_Function
86349>>>
86349>>>    // Helper function to create a SQL statement like;
86349>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
86349>>>    // Used for checking if an index exists.
86349>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
86351>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
86351>>>
86351>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
86352>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
86353>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
86354>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
86355>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
86356>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
86357>>>        Get _SqlFindKeyWord CI_SQLName to sName
86358>>>
86358>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
86359>>>
86359>>>        Function_Return sRetval
86360>>>    End_Function
86361>>>
86361>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
86361>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
86361>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
86363>>>        String sRetval
86363>>>        If (iLength <> 0) Begin
86365>>>            Move ("(" + String(iLength)) to sRetval
86366>>>            If (iDecimals <> 0) Begin
86368>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
86369>>>            End
86369>>>>
86369>>>            Move (sRetval + ")") to sRetval
86370>>>        End
86370>>>>
86370>>>        Function_Return sRetval
86371>>>    End_Function
86372>>>
86372>>>    Procedure _SqlColumnInfo Handle hoStmt
86374>>>        Integer i iCols iItem
86374>>>        tSqlColumnNew[] aQueryColumns
86374>>>        tSqlColumnNew[] aQueryColumns
86375>>>
86375>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
86376>>>        For i from 1 to iCols
86382>>>>
86382>>>            Move (SizeOfArray(aQueryColumns)) to iItem
86383>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
86384>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
86385>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
86386>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
86387>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
86388>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
86389>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
86390>>>        Loop
86391>>>>
86391>>>        Set piColumns to iCols
86392>>>        Set paQueryColumns to aQueryColumns
86393>>>    End_Procedure
86394>>>
86394>>>    // Checks that the passed sDriverID is defined.
86394>>>    // Also checks if the driver has been loaded; else it gets loaded.
86394>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
86396>>>        Boolean bOK
86396>>>        Integer iDriver
86396>>>
86396>>>        If (sDriverID = DATAFLEX_ID) Begin
86398>>>            Function_Return False
86399>>>        End
86399>>>>
86399>>>
86399>>>        Get IsDAWSQLDriver sDriverID to bOK
86400>>>
86400>>>        If (bOK = False) Begin
86402>>>            Get IsMertechDriver sDriverID to bOK
86403>>>        End
86403>>>>
86403>>>
86403>>>        If (bOK = False) Begin
86405>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
86406>>>>
86406>>>            Function_Return False
86407>>>        End
86407>>>>
86407>>>
86407>>>        Get DriverIndex sDriverID to iDriver
86408>>>        If (iDriver = 0) Begin
86410>>>            Load_Driver sDriverID
86411>>>        End
86411>>>>
86411>>>
86411>>>        Function_Return True
86412>>>    End_Function
86413>>>
86413>>>    // Checks that the length parameter has been passed correctly.
86413>>>    // This is only of concern for certain SQL data types.
86413>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
86415>>>        Integer iLength
86415>>>        Boolean bOK bCheckTypeLength
86415>>>
86415>>>        If (num_arguments > 1) Begin
86417>>>            Move iLen to iLength
86418>>>        End
86418>>>>
86418>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
86419>>>
86419>>>        If (bCheckTypeLength = True) Begin
86421>>>            Move (iLength > 0) to bOK
86422>>>        End
86422>>>>
86422>>>
86422>>>        Function_Return (bOK = True)
86423>>>    End_Function
86424>>>
86424>>>    Function _SqlProperTableName String sTableName Returns String
86426>>>        String sVal sSchema sDriverID sValue
86426>>>        Handle hTable
86426>>>        Integer iDbType
86426>>>
86426>>>        If (Trim(sTableName) = "") Begin
86428>>>            Function_Return ""
86429>>>        End
86429>>>>
86429>>>
86429>>>        Get psDriverID to sDriverID
86430>>>        Get piDbType   to iDbType
86431>>>        If (iDbType = EN_dbTypeOracle) Begin
86433>>>            Get psUserID to sSchema
86434>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
86434>>>            Move (Uppercase(sSchema)) to sSchema
86435>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
86436>>>            Function_Return sTableName
86437>>>        End
86437>>>>
86437>>>        If (iDbType = EN_DbTypeMySQL) Begin
86439>>>            Get psDatabase to sVal
86440>>>            Move (sVal + "." + sTableName) to sTableName
86441>>>            Function_Return sTableName
86442>>>        End
86442>>>>
86442>>>        If (iDbType = EN_DbTypePostgre) Begin
86444>>>            Move ('"' + sTableName + '"') to sTableName
86445>>>            Function_Return sTableName
86446>>>        End
86446>>>>
86446>>>
86446>>>        Get psSchema to sSchema
86447>>>        If (sSchema = "") Begin
86449>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86450>>>        End
86450>>>>
86450>>>
86450>>>        Move (Uppercase(sTableName)) to sVal
86451>>>        If (not(sVal contains (sSchema + "."))) Begin
86453>>>            If (iDbType = EN_dbTypeDB2) Begin
86455>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
86456>>>            End
86456>>>>
86456>>>            Else Begin
86457>>>                Move (sSchema + "." + sTableName) to sTableName
86458>>>            End
86458>>>>
86458>>>        End
86458>>>>
86458>>>
86458>>>        Function_Return sTableName
86459>>>    End_Function
86460>>>
86460>>>    // SQL column names can be case-sensitive. This function is used to check that
86460>>>    // the passed sFieldName has the correct spelling.
86460>>>    // Used with Embedded SQL statement calls.
86460>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
86460>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
86462>>>        String sRetval sValue sConnectionString sDriverID
86462>>>        String[] sColumnNamesArray
86463>>>        Integer iCount iColumns
86463>>>
86463>>>        Move "" to sRetval
86464>>>        Get psDriverID to sDriverID
86465>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
86466>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
86467>>>        Decrement iColumns
86468>>>
86468>>>        For iCount from 0 to iColumns
86474>>>>
86474>>>            Move sColumnNamesArray[iCount] to sValue
86475>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
86477>>>                Move sValue to sRetval
86478>>>                Move iColumns to iCount // We're done.
86479>>>            End
86479>>>>
86479>>>        Loop
86480>>>>
86480>>>
86480>>>        Function_Return sRetval
86481>>>    End_Function
86482>>>
86482>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
86484>>>        String[] sReturnArray
86485>>>        Handle hoSQLHandler
86485>>>        Integer iCount iSize iItem
86485>>>        String sServer sUser sPassword
86485>>>        tSQLConnection SQLConnection
86485>>>        tSQLConnection SQLConnection
86485>>>
86485>>>        Get phoMSSQLHandler to hoSQLHandler
86486>>>        Send Delete_Data    of hoSQLHandler
86487>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
86488>>>
86488>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86489>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
86490>>>        Decrement iSize
86491>>>
86491>>>        For iCount from 0 to iSize
86497>>>>
86497>>>            Get String_Value of hoSQLHandler item iCount to sServer
86498>>>            Move (Trim(sServer)) to sReturnArray[iItem]
86499>>>            Increment iItem
86500>>>        Loop
86501>>>>
86501>>>
86501>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86502>>>
86502>>>        Function_Return sReturnArray
86503>>>    End_Function
86504>>>
86504>>>    Function _SqlTableArrayDAW Returns String[]
86506>>>        String[] sReturnArray
86507>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
86507>>>        Handle hoSQLHandler
86507>>>        Integer iCount iSize iItem
86507>>>        Boolean bOK
86507>>>        tSQLConnection SQLConnection
86507>>>        tSQLConnection SQLConnection
86507>>>
86507>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86508>>>        If (SQLConnection.sConnectionString = "") Begin
86510>>>            Function_Return sReturnArray
86511>>>        End
86511>>>>
86511>>>
86511>>>        Move SQLConnection.sSchema      to sDefSchema
86512>>>        Move (Uppercase(sDefSchema))    to sDefSchema
86513>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
86514>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
86515>>>
86515>>>        Get phoCLIHandler to hoSQLHandler
86516>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
86517>>>        Send Delete_Data  of hoSQLHandler
86518>>>
86518>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86519>>>        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
86520>>>        Move False to Err
86521>>>        Decrement iSize
86522>>>
86522>>>        For iCount from 0 to iSize
86528>>>>
86528>>>            Get TableName    of hoSQLHandler iCount to sTable
86529>>>            Get TableType    of hoSQLHandler iCount to sTableType
86530>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
86531>>>            Get TableComment of hoSQLHandler iCount to sComment
86532>>>            Move (Trim(sTable)) to sTable
86533>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
86535>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
86536>>>            End
86536>>>>
86536>>>            Else Begin
86537>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
86538>>>            End
86538>>>>
86538>>>            If (bOK = True) Begin
86540>>>                Move sTable to sReturnArray[iItem]
86541>>>                Increment iItem
86542>>>            End
86542>>>>
86542>>>        Loop
86543>>>>
86543>>>
86543>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86544>>>
86544>>>        Function_Return sReturnArray
86545>>>    End_Function
86546>>>
86546>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
86548>>>        String[] sReturnArray
86549>>>        String sValue
86549>>>        Handle hoSQLHandler hoSQLConnect hStmt
86549>>>        Integer iRetval iCols iFetchResult
86549>>>        tSQLConnection SQLConnection
86549>>>        tSQLConnection SQLConnection
86549>>>
86549>>>        Get phoSQLManager to hoSQLHandler
86550>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86551>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
86552>>>
86552>>>        If (hoSQLConnect <> 0) Begin
86554>>>            Get SqlOpen of hoSQLConnect to hStmt
86555>>>            If (hStmt <> 0) Begin
86557>>>                Send SqlSetProcedurename of hStmt sStmt
86558>>>                If (sArgument <> "") Begin
86560>>>                    Send SqlSetArgument  of hStmt 1 sArgument
86561>>>                End
86561>>>>
86561>>>
86561>>>                Send SqlCall             of hStmt
86562>>>                Get SqlReturnValue       of hStmt to iRetval
86563>>>                If (iRetval = 0) Begin
86565>>>                    Repeat
86565>>>>
86565>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
86566>>>                        If (iCols > 0) Begin
86568>>>                            Repeat
86568>>>>
86568>>>                                Get SqlFetch of hStmt to iFetchResult
86569>>>                                If (iFetchResult <> 0) Begin
86571>>>                                    Get SqlColumnValue of hStmt 1 to sValue
86572>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
86573>>>                                End
86573>>>>
86573>>>                            Until (iFetchResult = 0)
86575>>>                        End
86575>>>>
86575>>>                        Get SqlNextResultSet of hStmt to iRetval
86576>>>                    Until (iRetval = 0)
86578>>>                    Send SqlClose of hStmt
86579>>>                End
86579>>>>
86579>>>            End
86579>>>>
86579>>>            Send SqlDisconnect of hoSQLConnect
86580>>>        End
86580>>>>
86580>>>        Function_Return sReturnArray
86581>>>    End_Function
86582>>>
86582>>>    Function _SqlDatabasesArrayDB2 Returns String[]
86584>>>        String[] sReturnArray
86585>>>        String sDataSource
86585>>>        Handle hoSQLHandler
86585>>>        Integer iItem
86585>>>
86585>>>        Get phoDB2SQLHandler to hoSQLHandler
86586>>>        Send SeedDataSources of hoSQLHandler
86587>>>
86587>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86588>>>
86588>>>        Repeat
86588>>>>
86588>>>            Get DataSources of hoSQLHandler to sDataSource
86589>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
86590>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
86591>>>            Increment iItem
86592>>>        Until (sDataSource = "")
86594>>>
86594>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86595>>>
86595>>>        Function_Return sReturnArray
86596>>>    End_Function
86597>>>
86597>>>    Function _SqlDatabasesArrayODBC Returns String[]
86599>>>        String[] sReturnArray
86600>>>        String sDataSource
86600>>>        Handle hoSQLHandler
86600>>>        Integer iItem
86600>>>
86600>>>        Get phoODBCSQLHandler to hoSQLHandler
86601>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86602>>>
86602>>>        Send SeedDataSources of hoSQLHandler
86603>>>
86603>>>        Repeat
86603>>>>
86603>>>            Get DataSources of hoSQLHandler to sDataSource
86604>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
86606>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
86607>>>                Increment iItem
86608>>>            End
86608>>>>
86608>>>        Until (sDataSource = "")
86610>>>
86610>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
86611>>>
86611>>>        Function_Return sReturnArray
86612>>>    End_Function
86613>>>
86613>>>    // We might have a split Sql script where the info about which database to use is
86613>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
86613>>>    // insert it for scriplets to come after the first one.
86613>>>    Function _SqlFormatStatement String sStmt Returns String
86615>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
86615>>>        Integer iStart iEnd iDbType
86615>>>        Boolean bOK
86615>>>
86615>>>        Get piDbType to iDbType
86616>>>        Get psDriverID to sDriverID
86617>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
86618>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
86619>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
86620>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
86621>>>        Move (Replaces(" ", sStmt, "")) to sTmp
86622>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
86624>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
86625>>>            Move (Pos("]", sTmp)) to iEnd
86626>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
86627>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
86628>>>            Set Private.psUseDatabase to sUseDatabase
86629>>>        End
86629>>>>
86629>>>        Else Begin
86630>>>            Move (Uppercase(sStmt)) to sTmp
86631>>>
86631>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
86631>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
86633>>>                Get Private.psUseDatabase to sUseDatabase
86634>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
86635>>>            End
86635>>>>
86635>>>
86635>>>            // This is a bit special to place here but was done so because it was easier that way.
86635>>>            // We will get an error when trying to create a view if it already exists.
86635>>>            // So to avoid such errors; we first remove it & then recreate it.
86635>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
86638>>>                // Make sure we only have one space between statements/words.
86638>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
86639>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
86640>>>                Move (Trim(sTmp)) to sTmp
86641>>>                Move (Pos(" ", sTmp)) to iEnd
86642>>>                Move (Left(sTmp, iEnd)) to sTmp
86643>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
86645>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
86646>>>                End
86646>>>>
86646>>>                Move (Trim(sTmp)) to sTmp
86647>>>                // Remove data view as it already exists!
86647>>>                Get SqlViewRemove sDriverID sTmp to bOK
86648>>>            End
86648>>>>
86648>>>        End
86648>>>>
86648>>>
86648>>>        Function_Return sStmt
86649>>>    End_Function
86650>>>
86650>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
86650>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
86652>>>        String sRetval
86652>>>        Integer iDbType iSize iItem iIndex
86652>>>        tSQLKeyWords[] SQLKeywordArray
86652>>>        tSQLKeyWords[] SQLKeywordArray
86653>>>        tSQLKeyWords   SQLKeyWords
86653>>>        tSQLKeyWords   SQLKeyWords
86653>>>
86653>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
86653>>>        Get piDbType to iDbType
86654>>>        Move iDbType             to SQLKeyWords.iSQLDbType
86655>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
86656>>>
86656>>>        Get paSQLKeywordArray to SQLKeywordArray
86657>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
86658>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
86659>>>
86659>>>        Function_Return sRetval
86660>>>    End_Function
86661>>>
86661>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
86661>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
86663>>>        String[] sSQLScriptArray
86664>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
86664>>>        Integer iCh iSize iArgSize iPos iCount
86664>>>        Boolean bCommentStart bCommentEnd bDashComment
86664>>>
86664>>>        Move False to bCommentStart
86665>>>        Move False to bCommentEnd
86666>>>        Move False to bDashComment
86667>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
86668>>>        Move "*/"  to sCommentEnd
86669>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
86670>>>
86670>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
86671>>>        Decrement iSize
86672>>>        Move "" to sText
86673>>>
86673>>>        For iCount from 0 to iSize
86679>>>>
86679>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
86680>>>            Move (Trim(sLine)) to sTmp
86681>>>            If (sTmp <> "") Begin
86683>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
86684>>>                If (bCommentStart = False) Begin
86686>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
86687>>>                    If (bCommentStart = False) Begin
86689>>>                    End
86689>>>>
86689>>>                End
86689>>>>
86689>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
86690>>>                If (bCommentEnd = True) Begin
86692>>>                    Move False to bCommentStart
86693>>>                End
86693>>>>
86693>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
86695>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
86696>>>                End
86696>>>>
86696>>>            End
86696>>>>
86696>>>        Loop
86697>>>>
86697>>>
86697>>>        // Update the retval struct array:
86697>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
86698>>>        Function_Return SqlScriptArray
86699>>>    End_Function
86700>>>    
86700>>>
86700>>>    // *** Database API Functions: ***
86700>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86700>>>    // make changes/updates to the database.
86700>>>    //
86700>>>    //
86700>>>    // This might not do what you think - Here's what it does:
86700>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86700>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86700>>>    // to the SQL table.
86700>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86700>>>    // already exists in SQL.
86700>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86700>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86700>>>    // restructuring an existing table.
86700>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86702>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
86702>>>        String sDriverID sTableName sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86702>>>        Handle hToTable
86702>>>        Integer iPos
86702>>>
86702>>>        Move True to bUseConnectionID
86703>>>        If (num_arguments > 1) Begin
86705>>>            Move bUseConnID to bUseConnectionID
86706>>>        End
86706>>>>
86706>>>
86706>>>        Get psDriverID to sDriverID
86707>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86707>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86708>>>        If (bExists = False) Begin
86710>>>            Function_Return False
86711>>>        End
86711>>>>
86711>>>
86711>>>        Get UtilTableIsAlias hTable to bIsAlias
86712>>>        
86712>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86713>>>        If (bOK = False) Begin
86715>>>            Function_Return False
86716>>>        End
86716>>>>
86716>>>
86716>>>        // Then we need to check that the function hasn't been called before; which in case
86716>>>        // we do nothing
86716>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86717>>>        If (bExists = True) Begin
86719>>>            Function_Return False
86720>>>        End
86720>>>>
86720>>>
86720>>>        Get psConnectionID     to sConnectionID
86721>>>        Get psConnectionString to sConnectionString
86722>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86724>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86725>>>>
86725>>>            Function_Return False
86726>>>        End
86726>>>>
86726>>>
86726>>>        Get psSchema to sSchema
86727>>>        If (sSchema = "") Begin
86729>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86730>>>        End
86730>>>>
86730>>>
86730>>>        Get IsMertechDriver sDriverID to bMertechDriver
86731>>>
86731>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
86731>>>        // was a programmer's error and we adjust for it here.
86731>>>        If (bMertechDriver = True) Begin
86733>>>            Move False to bUseConnectionID
86734>>>        End
86734>>>>
86734>>>
86734>>>        // If we should use a connection id we need to check it exists;
86734>>>        // else we create it before attempting creating the table
86734>>>        If (bUseConnectionID = True) Begin
86736>>>            Get AutoConnectionIDLogin to bOK
86737>>>            If (bOk = False) Begin
86739>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86740>>>>
86740>>>                Function_Return False
86741>>>            End
86741>>>>
86741>>>        End
86741>>>>
86741>>>
86741>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86744>>>        Get _TableNameOnly sRootName to sRootName
86745>>>        If (sRootName = "") Begin
86747>>>            Function_Return False
86748>>>        End
86748>>>>
86748>>>        Move (sRootName + ".int")                    to sPhysicalName
86749>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86752>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName  
86755>>>
86755>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86755>>>        // because then the table should not be visible to users.
86755>>>        Move (Pos("@", sDisplayName)) to iPos
86756>>>        If (iPos <> 1) Begin
86758>>>            If (sDisplayName contains ".") Begin
86760>>>                Move (Pos(".", sDisplayName)) to iPos
86761>>>                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86762>>>                Move (sSchema + "." + sDisplayName)       to sDisplayName
86763>>>            End
86763>>>>
86763>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86765>>>                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86766>>>            End
86766>>>>
86766>>>        End
86766>>>>
86766>>>
86766>>>        If (bIsAlias = False) Begin
86768>>>            Get OpenTableExclusive hTable to bOpened
86769>>>            If (bOpened = False) Begin
86771>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86772>>>>
86772>>>                Function_Return False
86773>>>            End
86773>>>>
86773>>>        End
86773>>>>
86773>>>
86773>>>        If (ghoProgressBar <> 0) Begin
86775>>>            Send DoAdvance of ghoProgressBar
86776>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86777>>>        End
86777>>>>
86777>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86777>>>        Move hTable to hToTable
86778>>>        Move False to Err
86779>>>
86779>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86779>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
86779>>>        // a proper and updated .int file.
86779>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86782>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86783>>>        
86783>>>        If (bIsAlias = False) Begin
86785>>>            Structure_Start hToTable sDriverID
86786>>>                If (bUseConnectionID = True) Begin
86788>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86791>>>                End
86791>>>>
86791>>>                Else Begin
86792>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86795>>>                End
86795>>>>
86795>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86798>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86798>>>                Move False to Err
86799>>>                Move 0 to LastErr
86800>>>            Structure_End hToTable
86802>>>        End
86802>>>>
86802>>>
86802>>>        Move (not(Err)) to bOK
86803>>>        If (bOK = True) Begin
86805>>>            // The attributes set above will always trigger an error
86805>>>            // We also adjust the Filelist entries
86805>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86808>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86811>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86814>>>
86814>>>            // This pseudo updates the .int file to make it up-to-date with the SQL back-end.
86814>>>            Get SqlUtilUpdateIntFile hTable to bOK
86815>>>        End
86815>>>>
86815>>>
86815>>>        Function_Return (bOK = True)
86816>>>    End_Function
86817>>>
86817>>>    // Sample usage:
86817>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86817>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86817>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86819>>>        Boolean bOK
86819>>>
86819>>>        Get AutoConnectionIDLogin to bOK
86820>>>        Move False to Err
86821>>>        Get OpenTableExclusive hTable to bOK
86822>>>        If (bOK = False) Begin
86824>>>            Function_Return False
86825>>>        End
86825>>>>
86825>>>        Structure_Start hTable
86826>>>            Set_Attribute iAttribute of hTable to iValue
86829>>>        Structure_End hTable
86831>>>
86831>>>        Function_Return (Err = False)
86832>>>    End_Function
86833>>>
86833>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86833>>>    // or to change the filelist slot names.
86833>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86835>>>        Boolean bExists
86835>>>        Integer iPos
86835>>>        
86835>>>        Move False to Err
86836>>>        Get UtilTableNumberIsInUse hTable to bExists
86837>>>        If (bExists = False) Begin
86839>>>            Function_Return False
86840>>>        End
86840>>>>
86840>>>
86840>>>        If (ghoProgressBar <> 0) Begin
86842>>>            Send DoAdvance of ghoProgressBar
86843>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86844>>>        End
86844>>>>
86844>>>        // If all strings are empty it means that we should remove this entry from filelist.
86844>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86846>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86849>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86852>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86855>>>            Function_Return (Err = False) // And we're done.
86856>>>        End
86856>>>>
86856>>>
86856>>>        If (sDriverID <> DATAFLEX_ID) Begin
86858>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86861>>>        End
86861>>>>
86861>>>        Else Begin
86862>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86865>>>        End
86865>>>>
86865>>>
86865>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86868>>>
86868>>>        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
86870>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
86873>>>        End
86873>>>>
86873>>>        Else Begin
86874>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86877>>>        End
86877>>>>
86877>>>
86877>>>        Function_Return (Err = False)
86878>>>    End_Function
86879>>>
86879>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86881>>>        Boolean bOK
86881>>>
86881>>>        Get AutoConnectionIDLogin to bOK
86882>>>        Move False to Err
86883>>>        Get OpenTableExclusive hTable to bOK
86884>>>        If (bOK = False) Begin
86886>>>            Function_Return False
86887>>>        End
86887>>>>
86887>>>
86887>>>        Structure_Start hTable
86888>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86891>>>        Structure_End hTable
86893>>>
86893>>>        Function_Return (Err = False)
86894>>>    End_Function
86895>>>
86895>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86897>>>        Boolean bOK
86897>>>
86897>>>        Move False to Err
86898>>>        Get AutoConnectionIDLogin to bOK
86899>>>        Open hToTable
86901>>>        Get OpenTableExclusive hTable to bOK
86902>>>        If (bOK = False) Begin
86904>>>            Function_Return False
86905>>>        End
86905>>>>
86905>>>
86905>>>        Structure_Start hTable
86906>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86909>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86912>>>        Structure_End hTable
86914>>>
86914>>>        Function_Return (Err = False)
86915>>>    End_Function
86916>>>
86916>>>    Procedure ApiTableConvertAllAddException Integer hTable
86918>>>        Integer[] iTableConvertExceptions
86919>>>        Get piTableConvertExceptions to iTableConvertExceptions
86920>>>        Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
86921>>>        Set piTableConvertExceptions to iTableConvertExceptions
86922>>>    End_Procedure
86923>>>
86923>>>    Procedure ApiTableConvertALLToSql
86925>>>        Integer[] iTablesArray
86926>>>        Integer iSize iCount
86926>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86926>>>        String sDriverID
86926>>>
86926>>>        Get psDriverID to sDriverID
86927>>>        Get pbUseConnectionID to bUseConnectionID
86928>>>        Get pbToANSI          to bToANSI
86929>>>        Get pbRecnum          to bRecnum
86930>>>        Get pbCopyData        to bCopyData
86931>>>        If (ghoDbUpdateHandler > 0) Begin
86933>>>            Get pbContinueOnError to bContinueOnError
86934>>>        End
86934>>>>
86934>>>
86934>>>        Get _AllTablesToConvert to iTablesArray
86935>>>        Move (SizeOfArray(iTablesArray)) to iSize
86936>>>        Decrement iSize
86937>>>        For iCount from 0 to iSize
86943>>>>
86943>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86944>>>            // Probably the right logic here is to just continue trying to convert every table even
86944>>>            // if there was an error converting one table...
86944>>>            //If (bContinueOnError = False and bOK = False) Break
86944>>>        Loop
86945>>>>
86945>>>
86945>>>    End_Procedure
86946>>>
86946>>>    Procedure ApiTableAttachALLToSql 
86948>>>        Integer[] iTablesArray
86949>>>        Integer iSize iCount
86949>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86949>>>        String sDriverID
86949>>>
86949>>>        Get psDriverID to sDriverID
86950>>>        Get pbUseConnectionID to bUseConnectionID
86951>>>        Get pbToANSI          to bToANSI
86952>>>        Get pbRecnum          to bRecnum
86953>>>        Get pbCopyData        to bCopyData
86954>>>        If (ghoDbUpdateHandler > 0) Begin
86956>>>            Get pbContinueOnError to bContinueOnError
86957>>>        End
86957>>>>
86957>>>
86957>>>        Get _AllTablesToConvert to iTablesArray
86958>>>        Move (SizeOfArray(iTablesArray)) to iSize
86959>>>        Decrement iSize
86960>>>        For iCount from 0 to iSize
86966>>>>
86966>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86967>>>        Loop
86968>>>>
86968>>>
86968>>>    End_Procedure
86969>>>
86969>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86971>>>        Handle hToTable hoLogFile
86971>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
86971>>>        String sPhysicalName sRootName sLogicalName sDisplayName sEmpty sConnectionID sConnectionString
86971>>>        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86971>>>        tSQLConnection SQLConnection
86971>>>        tSQLConnection SQLConnection
86971>>>
86971>>>        Get UtilTableIsAlias hTable to bIsAlias 
86972>>>        // If this is an Alias file there is nothing to convert to SQL.
86972>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86972>>>        If (bIsAlias = True) Begin   
86974>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86977>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86979>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName) 
86982>>>                Get psConnectionID to sConnectionID
86983>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86984>>>            End
86984>>>>
86984>>>            Function_Return True
86985>>>        End
86985>>>>
86985>>>        
86985>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86988>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86991>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86994>>>
86994>>>        If (ghoProgressBar <> 0) Begin
86996>>>            Send DoAdvance of ghoProgressBar
86997>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sLogicalName) * "Number:" * String(hTable))
86998>>>        End  
86998>>>>
86998>>>        
86998>>>        // Marco Kuipers suggestion;
86998>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86998>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
86998>>>        // table again.
86998>>>        Get UtilTableIsSQL hTable to bOK
86999>>>        If (bOK = False) Begin
87001>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists 
87002>>>            If (bExists = True) Begin
87004>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87005>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87006>>>                Get phoLogFile to hoLogFile
87007>>>                If (hoLogFile <> 0) Begin
87009>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
87010>>>                    Send LogError sWarning False
87011>>>                End                                        
87011>>>>
87011>>>                Else Begin
87012>>>                    Error DFERR_PROGRAM sWarning
87013>>>>
87013>>>                End
87013>>>>
87013>>>            End
87013>>>>
87013>>>        End
87013>>>>
87013>>>        
87013>>>        // Does the rootname contain a driver?
87013>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87015>>>            // Does the table already exist as an SQL table?
87015>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87016>>>            // It can happen that the table is missing from Filelist.cfg but still
87016>>>            // exist on the SQL side, in case we want to search for the table by its name.
87016>>>            If (bExists = False) Begin
87018>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
87019>>>            End
87019>>>>
87019>>>            If (bExists = True) Begin
87021>>>                Set TableName_Text of ghoStatusPanel to ""
87022>>>                Function_Return False
87023>>>            End
87023>>>>
87023>>>        End
87023>>>>
87023>>>
87023>>>        Move CS_ANSI_Txt to sANSI_OEM
87024>>>        If (bToAnsi = False) Begin
87026>>>            Move CS_OEM_Txt to sANSI_OEM
87027>>>        End
87027>>>>
87027>>>
87027>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
87028>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
87028>>>        // passed as True, we adjust for that here.
87028>>>        Get IsMertechDriver sDriverID to bMertechDriver
87029>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
87031>>>            Move False to bUseConnectionID
87032>>>        End
87032>>>>
87032>>>
87032>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87033>>>        Move SQLConnection.sSchema           to sSchema
87034>>>        If (sSchema = "") Begin
87036>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema 
87037>>>            Move (Lowercase(sSchema))        to sSchema
87038>>>        End
87038>>>>
87038>>>
87038>>>        If (sDriverID = ORAFLEX) Begin
87040>>>            Move SQLConnection.sUserID       to sSchema
87041>>>        End
87041>>>>
87041>>>
87041>>>        Move SQLConnection.sDatabase         to sDatabase
87042>>>        Move SQLConnection.sConnectionID     to sConnectionID
87043>>>        Move SQLConnection.sConnectionString to sConnectionString
87044>>>        If (sConnectionID = "" or sConnectionString = "") Begin
87046>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
87047>>>>
87047>>>            Function_Return False
87048>>>        End
87048>>>>
87048>>>
87048>>>        Get AutoConnectionIDLogin to bOK
87049>>>        Open hTable
87051>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87054>>>        If (bOpened = False) Begin
87056>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
87057>>>>
87057>>>            Function_Return False
87058>>>        End
87058>>>>
87058>>>
87058>>>        If (ghoProgressBar <> 0) Begin
87060>>>            Send DoAdvance of ghoProgressBar
87061>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
87062>>>        End  
87062>>>>
87062>>>        
87062>>>        Move 0 to hToTable
87063>>>        Get _TableNameOnly sRootName                 to sRootName
87064>>>        Move (sRootName + ".int")                    to sPhysicalName
87065>>>
87065>>>        Case Begin
87065>>>            Case (sDriverID = MSSQLDRV_ID)
87067>>>                Case Break
87068>>>            Case (sDriverID = ODBC_DRV_ID)
87071>>>                Case Break
87072>>>            Case (sDriverID = DB2_DRV_ID)
87075>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87076>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
87077>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87078>>>                Case Break
87079>>>            Case (sDriverID = ORAFLEX)
87082>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87083>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87084>>>                Case Break
87085>>>            Case (sDriverID = MDSMySQL)
87088>>>                Case Break
87089>>>            Case (sDriverID = MDSPgSQL)
87092>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
87093>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
87094>>>                Case Break
87095>>>            Case (sDriverID = DATAFLEX_ID)
87098>>>                Case Break
87099>>>            Case Else
87099>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
87100>>>>
87100>>>                Case Break
87101>>>        Case End
87101>>>
87101>>>        Move False to Err
87102>>>        
87102>>>        If (bIsAlias = False) Begin
87104>>>    
87104>>>            If (bMertechDriver = True) Begin
87106>>>                // Note: This function also sets the Err flag.
87106>>>                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
87107>>>            End
87107>>>>
87107>>>    
87107>>>            If (bMertechDriver = False) Begin
87109>>>                Structure_Start hToTable sDriverID
87110>>>                    Structure_Copy hTable to hToTable
87111>>>    
87111>>>                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
87114>>>    
87114>>>                    If (sDriverID <> DATAFLEX_ID) Begin
87116>>>                        If (bUseConnectionID = True) Begin
87118>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
87121>>>                        End
87121>>>>
87121>>>                        Else Begin
87122>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
87125>>>                        End
87125>>>>
87125>>>    
87125>>>                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
87128>>>                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
87131>>>    
87131>>>                        If (sSchema <> "") Begin
87133>>>                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
87136>>>                        End
87136>>>>
87136>>>    
87136>>>                        If (sDriverID = DB2_DRV_ID) Begin
87138>>>                            If (sLongTableSpace <> "") Begin
87140>>>                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
87143>>>                            End
87143>>>>
87143>>>                            If (sBaseTableSpace <> "") Begin
87145>>>                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
87148>>>                            End
87148>>>>
87148>>>                            If (sIndexTableSpace <> "") Begin
87150>>>                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
87153>>>                            End
87153>>>>
87153>>>                        End
87153>>>>
87153>>>                    End
87153>>>>
87153>>>    
87153>>>                Structure_End hToTable
87155>>>            End
87155>>>>
87155>>>    
87155>>>            Move (not(Err)) to bOK
87156>>>            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
87158>>>                If (bIsAlias = False) Begin
87160>>>                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
87161>>>                    If (ghoDbUpdateHandler > 0) Begin
87163>>>                        Get pbContinueOnError to bContinueOnError
87164>>>                    End
87164>>>>
87164>>>                    // If the data copy failed we will keep the newly created SQL table but
87164>>>                    // rename it by adding a GUID at the end of the table name
87164>>>                    // - or as much as "fit" because different SQL back-ends have
87164>>>                    // different rules how long a table name can be.
87164>>>                    // The new table will probably contain data but something went
87164>>>                    // wrong while converting the data from embedded to SQL.
87164>>>                    If (bOK = False and bContinueOnError = False) Begin
87166>>>                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
87167>>>                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
87168>>>                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
87169>>>>
87169>>>                    End
87169>>>>
87169>>>                End
87169>>>>
87169>>>            End
87169>>>>
87169>>>        End
87169>>>>
87169>>>        
87169>>>        If (bMertechDriver = True) Begin
87171>>>            Open hTable
87173>>>        End
87173>>>>
87173>>>
87173>>>        // This must be after copying data...
87173>>>        If (Err = False) Begin
87175>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
87178>>>            // We also adjust the display name by prefixing it by the schema name;
87178>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
87180>>>                // The max length for the display_name is 31 characters...
87180>>>                If (Length(sSchema + "." + sDisplayName) < 31) Begin
87182>>>                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
87185>>>                End
87185>>>>
87185>>>            End
87185>>>>
87185>>>        End
87185>>>>
87185>>>        
87185>>>        Close hTable
87186>>>        Move (not(Err)) to bOK
87187>>>        Function_Return (bOK = True)
87188>>>    End_Function  
87189>>>    
87189>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
87189>>>    // It will first drop all indicies, copy the data and then recreate indicies.
87189>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
87189>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
87191>>>        Boolean bOpened bOK
87191>>>        Integer hToTable iIndex iCount iRetval iVoid iOrgFreq
87191>>>        String sErrorFile sEmpty sPath
87191>>>
87191>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
87194>>>        Get AutoConnectionIDLogin to bOK
87195>>>        If (sDriverID = DATAFLEX_ID) Begin
87197>>>            Send IncreaseSortBufferSize
87198>>>//            Send SetAllIndexesToBatch hToTable
87198>>>        End
87198>>>>
87198>>>
87198>>>        Move False to Err
87199>>>        Open sPhysicalName as hToTable
87201>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
87204>>>        If (bOpened = False) Begin
87206>>>            Function_Return False
87207>>>        End
87207>>>>
87207>>>
87207>>>        If (ghoStatusPanel <> 0) Begin
87209>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
87210>>>        End
87210>>>>
87210>>>
87210>>>        Move "" to sEmpty
87211>>>        Move False to Err
87212>>>        Move True to bOK
87213>>>
87213>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87216>>>//        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
87216>>>        If (sDriverID <> DATAFLEX_ID) Begin
87218>>>            // Remove all indices to speed up copying of data:
87218>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
87223>>>            If (iRetval <> 0) Begin
87225>>>                Error DFERR_PROGRAM ("Failed dropping indices for table:" * sRootName)
87226>>>>
87226>>>                Function_Return False
87227>>>            End
87227>>>>
87227>>>        End
87227>>>>
87227>>>
87227>>>        Move (sRootName + ".err") to sErrorFile
87228>>>        Move 0 to iIndex
87229>>>        Move False to Err
87230>>>
87230>>>        Copy_Records hFromTable to hToTable using 0 Callback Self
87233>>>
87233>>>        If (Err = False) Begin
87235>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
87236>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
87237>>>        End
87237>>>>
87237>>>
87237>>>        If (sDriverID <> DATAFLEX_ID) Begin
87239>>>            // Recreate indices:
87239>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
87244>>>        End
87244>>>>
87244>>>
87244>>>        Close hToTable
87245>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
87248>>>
87248>>>        If (bOK = True) Begin
87250>>>            Move (not(Err)) to bOK
87251>>>        End
87251>>>>
87251>>>
87251>>>        If (ghoStatusPanel <> 0) Begin
87253>>>            Set TableName_Text of ghoStatusPanel to ""
87254>>>            Set Message_Text   of ghoStatusPanel to ""
87255>>>            Set Action_Text    of ghoStatusPanel to ""
87256>>>        End
87256>>>>
87256>>>
87256>>>        Function_Return (bOK = True)
87257>>>    End_Function
87258>>>
87258>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
87258>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
87258>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
87260>>>        Handle hFile
87260>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
87260>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
87260>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened
87260>>>        tSQLConnection SQLConnection
87260>>>        tSQLConnection SQLConnection
87260>>>        tAPIColumn[] aColumns
87260>>>        tAPIColumn[] aColumns
87261>>>        tColumnType ColumnType
87261>>>        tColumnType ColumnType
87261>>>        
87261>>>        // First check if the passed filenumber already exists; in case we do nothing
87261>>>        Get UtilTableExists hTable to bOk
87262>>>        If (bOk = True) Begin
87264>>>            Function_Return False
87265>>>        End
87265>>>>
87265>>>        
87265>>>        Move sLogicalName to sTableName
87266>>>        If (ghoProgressBar <> 0) Begin
87268>>>            Send DoAdvance of ghoProgressBar
87269>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable))
87270>>>        End
87270>>>>
87270>>>
87270>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
87271>>>        Get psDriverID to sDriverID
87272>>>        Get IsSQLDriver sDriverID to bSqlDriver
87273>>>        Get piDbType to iDbType
87274>>>
87274>>>        // If no columns passed in, we need to create a "dummy" column 
87274>>>        Move False to bDeleteDummy 
87275>>>        If (Num_Arguments = 8) Begin
87277>>>            Move aColumnIn to aColumns
87278>>>        End
87278>>>>
87278>>>        If ((SizeOfArray(aColumns)) = 0) Begin
87280>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
87281>>>            Move ColumnType.iType to iDataType
87282>>>            If (bRecnum = False) Begin
87284>>>                Move C_tAPIColumn_Identity to iIdentityType
87285>>>            End                                            
87285>>>>
87285>>>            Else Begin
87286>>>                Move C_tAPIColumn_None     to iIdentityType
87287>>>            End
87287>>>>
87287>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
87288>>>            Move True to bDeleteDummy 
87289>>>        End  
87289>>>>
87289>>>        
87289>>>        // If columns have been passed as an array we need to check if an identity column
87289>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
87289>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be 
87289>>>        // two identity columns and SQL doesn't like that and throws an error.
87289>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
87291>>>            Move (SizeOfArray(aColumns)) to iSize
87292>>>            Decrement iSize
87293>>>            for iCount from 0 to iSize
87299>>>>
87299>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
87301>>>                    Move False to bRecnum
87302>>>                End
87302>>>>
87302>>>            Loop
87303>>>>
87303>>>        End
87303>>>>
87303>>>        
87303>>>        // If this is a SQL based driver we also check if the table exists
87303>>>        // in the SQL back end; in case we do nothing.
87303>>>        If (bSqlDriver = True) Begin
87305>>>            // Get all connection properties
87305>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87306>>>            Move SQLConnection.sSchema to sSchema
87307>>>            If (sSchema = "") Begin
87309>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87310>>>            End   
87310>>>>
87310>>>
87310>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
87311>>>            // It can happen that the table is missing from Filelist.cfg but still
87311>>>            // exist on the SQL side, in case we want to search for the table by its name.
87311>>>            If (bExists = False) Begin
87313>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
87314>>>            End
87314>>>>
87314>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
87314>>>            // we will just add it to Filelist.cfg
87314>>>            If (bExists = True) Begin
87316>>>                If (bExistsInFilelist = False) Begin
87318>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87320>>>                        Move (sDriverID + ":" + sRootName) to sRootName
87321>>>                    End
87321>>>>
87321>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87324>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87327>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName                        
87330>>>                    Move False to bSysFile
87331>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
87332>>>                End
87332>>>>
87332>>>                Function_Return False
87333>>>            End
87333>>>>
87333>>>        End
87333>>>>
87333>>>
87333>>>        Move CS_ANSI_Txt to sANSI_OEM
87334>>>        If (num_arguments > 6) Begin
87336>>>            If (bANSI = False) Begin
87338>>>                Move CS_OEM_Txt to sANSI_OEM
87339>>>            End
87339>>>>
87339>>>        End
87339>>>>
87339>>>
87339>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
87339>>>        // is a programmer's error and we auto-correct for it here.
87339>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
87339>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
87339>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
87339>>>        // set it back and use a Mertech function to convert it to SQL.
87339>>>        Get IsMertechDriver sDriverID to bMertechDriver
87340>>>        If (bMertechDriver = True) Begin
87342>>>            If (bUseConnectionID = True) Begin
87344>>>                Move False to bUseConnectionID
87345>>>            End
87345>>>>
87345>>>            Move sDriverID to sOriginalDriverID
87346>>>            Move DATAFLEX_ID to sDriverID
87347>>>        End
87347>>>>
87347>>>
87347>>>        Move False to Err
87348>>>        If (sDriverID = DATAFLEX_ID) Begin
87350>>>            Move sRootName to sPhysicalFile
87351>>>        End
87351>>>>
87351>>>
87351>>>        If (sDriverID <> DATAFLEX_ID) Begin
87353>>>            Move SQLConnection.sConnectionID to sConnectionID
87354>>>
87354>>>            // If DAW driver and we should use a connection id we need to
87354>>>            // check if the connection ID exists; else we create it before attempting creating the table
87354>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
87356>>>                Get IsConnectionID sConnectionID sDriverID to bExists
87357>>>                If (bExists = False) Begin
87359>>>                    Get UtilCreateConnectionID sConnectionID to bOk
87360>>>                    If (bOk = False) Begin
87362>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87363>>>>
87363>>>                        Function_Return False
87364>>>                    End
87364>>>>
87364>>>                End
87364>>>>
87364>>>            End
87364>>>>
87364>>>
87364>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
87366>>>                Move (sTableName + ".int") to sPhysicalFile
87367>>>            End                                            
87367>>>>
87367>>>            Else Begin
87368>>>                Move (sRootName + ".int") to sPhysicalFile
87369>>>            End
87369>>>>
87369>>>            Move (Uppercase(sDisplayName)) to sVal
87370>>>            If (not(sVal contains (sSchema + "."))) Begin
87372>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87373>>>            End
87373>>>>
87373>>>        End
87373>>>>
87373>>>        Move False to Err
87374>>>        Move 0 to hFile
87375>>>
87375>>>        Structure_Start hFile sDriverID
87376>>>            If (sDriverID <> DATAFLEX_ID) Begin
87378>>>                If (bUseConnectionID = True) Begin
87380>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
87383>>>                End
87383>>>>
87383>>>                Else Begin
87384>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
87387>>>                End
87387>>>>
87387>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
87390>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
87393>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
87396>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
87399>>>
87399>>>                If (sSchema <> "") Begin
87401>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
87404>>>                End
87404>>>>
87404>>>
87404>>>                If (sDriverID = DB2_DRV_ID) Begin
87406>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
87408>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
87411>>>                    End
87411>>>>
87411>>>                End
87411>>>>
87411>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
87413>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
87415>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
87418>>>                    End
87418>>>>
87418>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
87420>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
87423>>>                    End
87423>>>>
87423>>>                End
87423>>>>
87423>>>            End
87423>>>>
87423>>>
87423>>>            Set_Attribute DF_FILE_PHYSICAL_NAME                of hFile to sPhysicalFile
87426>>>            Send ApiColumnsAddToTable hFile aColumns True
87427>>>        Structure_End hFile
87429>>>
87429>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
87429>>>        If (bMertechDriver = True) Begin
87431>>>            Move sOriginalDriverID to sDriverID
87432>>>            If (not(sVal contains (sSchema + "."))) Begin
87434>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
87435>>>            End
87435>>>>
87435>>>            // Note: This function also sets the Err flag.
87435>>>            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
87436>>>        End
87436>>>>
87436>>>
87436>>>        Move (not(Err)) to bOK
87437>>>        If (bOk = True) Begin
87439>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
87441>>>                Move (sDriverID + ":" + sRootName) to sRootName
87442>>>            End
87442>>>>
87442>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87445>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87448>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87451>>>
87451>>>            // Lastly we remove the temporary column we created above, if all went well.
87451>>>            If (bDeleteDummy) Begin
87453>>>                Get ApiColumnRemove hTable "temp" to bOk
87454>>>            End
87454>>>>
87454>>>        End
87454>>>>
87454>>>        
87454>>>        Close hTable
87455>>>        Function_Return (bOK = True)
87456>>>    End_Function
87457>>>
87457>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
87459>>>        Boolean bExists
87459>>>
87459>>>        Move False to Err
87460>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
87463>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
87466>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
87469>>>
87469>>>        Function_Return (Err = False)
87470>>>    End_Function
87471>>>
87471>>>    // ToDo: Needs to be revised
87471>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
87473>>>        Handle hTable
87473>>>        String sDEFName sDataPath sDriverID
87473>>>        Boolean bExists
87473>>>
87473>>>        // Do nothing if MSSQL Driver.
87473>>>//        Get IsMSSQLDriver to bExists
87473>>>//        If (bExists = True) Begin
87473>>>//            Procedure_Return
87473>>>//        End
87473>>>
87473>>>        Get psDataPathFirstPart to sDataPath
87474>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
87475>>>        If (bExists = True) Begin
87477>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
87477>>>            // still be missing from the filelist and needs to be added.
87477>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
87478>>>            If (bExists = True) Begin
87480>>>                Procedure_Return
87481>>>            End
87481>>>>
87481>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
87481>>>            Else Begin
87482>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
87485>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
87488>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
87491>>>                Procedure_Return
87492>>>            End
87492>>>>
87492>>>        End
87492>>>>
87492>>>
87492>>>        Move (sPath + sFileName + ".def") to sDEFName
87493>>>        Move 0 to hTable
87494>>>        Move False to Err
87495>>>
87495>>>        Structure_Start hTable DATAFLEX_ID
87496>>>            Load_Def sDEFName Onto hTable
87497>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
87500>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
87502>>>
87502>>>        Move iFilelistSlot to hTable
87503>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
87506>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
87509>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
87512>>>
87512>>>    End_Procedure
87513>>>
87513>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
87515>>>        Boolean bTmp bErr bOK
87515>>>        String sTableName sDisplayName sFileName sDBOKeyWord sVal
87515>>>
87515>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
87515>>>        Move Err to bTmp
87516>>>        Move False to Err
87517>>>
87517>>>        Get AutoConnectionIDLogin to bOK
87518>>>        // First get the info for the current filelist slot:
87518>>>        Open iFromFileSlot
87520>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
87523>>>        If (bOK = True) Begin
87525>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
87528>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
87531>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
87534>>>
87534>>>            //...then move it.
87534>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
87537>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
87540>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
87543>>>
87543>>>            //...and finally remove the old filelist values.
87543>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
87546>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
87549>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
87552>>>        End
87552>>>>
87552>>>        Close iFromFileSlot
87553>>>
87553>>>        Move Err to bErr
87554>>>        Move bTmp to Err
87555>>>        Function_Return (bErr = False)
87556>>>    End_Function
87557>>>
87557>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
87559>>>        Handle hTable
87559>>>        Boolean bOK
87559>>>
87559>>>        Get AutoConnectionIDLogin to bOK
87560>>>        Move False to Err
87561>>>        Open hTableFrom Mode DF_EXCLUSIVE
87563>>>        If (hTableTo > 0) Begin
87565>>>            Open hTableTo
87567>>>        End
87567>>>>
87567>>>        Move hTableFrom to hTable
87568>>>
87568>>>        Structure_Start hTable
87569>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87572>>>            If (iColumnTo <> 0) Begin
87574>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87577>>>            End
87577>>>>
87577>>>        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE
87579>>>
87579>>>        Close hTableFrom
87580>>>        If (hTableTo > 0) Begin
87582>>>            Close hTableTo
87583>>>        End
87583>>>>
87583>>>
87583>>>        Function_Return (Err = False)
87584>>>    End_Function
87585>>>
87585>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87585>>>    Function ApiTableRemove Handle hTable Returns Boolean
87587>>>        String sTableName sDriverID
87587>>>        Boolean bOk
87587>>>        String sDataPath
87587>>>
87587>>>        Get AutoConnectionIDLogin to bOK
87588>>>        Move False to Err
87589>>>        Get psDriverID to sDriverID
87590>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87591>>>        If (sTableName = "") Begin
87593>>>            Function_Return False
87594>>>        End
87594>>>>
87594>>>
87594>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87595>>>        Delete_db sTableName
87596>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87597>>>
87597>>>        If (sDriverID <> DATAFLEX_ID) Begin
87599>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
87600>>>            Get psDataPathFirstPart to sDataPath
87601>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87602>>>        End
87602>>>>
87602>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87602>>>        If (hTable <> 0) Begin
87604>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87607>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87610>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87613>>>        End
87613>>>>
87613>>>        
87613>>>        Close hTable
87614>>>        Function_Return (hTable <> 0)
87615>>>    End_Function
87616>>>
87616>>>    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
87618>>>        Handle hTable
87618>>>        Boolean bOK
87618>>>
87618>>>        Get AutoConnectionIDLogin to bOK
87619>>>        Move False to Err
87620>>>        Open hTableTo Mode DF_EXCLUSIVE
87622>>>        Move hTableTo to hTable
87623>>>
87623>>>        Structure_Start hTable
87624>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87627>>>        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE
87629>>>
87629>>>        Close hTableTo
87630>>>        Function_Return (Err = False)
87631>>>    End_Function
87632>>>
87632>>>    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87634>>>        String sPhysicalName sDataPath sDriverID
87634>>>        Boolean bOK bExists
87634>>>        Integer iRetval
87634>>>
87634>>>        Move False to Err
87635>>>        Get psDataPathFirstPart to sDataPath
87636>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87639>>>
87639>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87642>>>        Close hTable
87643>>>        If (sDriverID = DATAFLEX_ID) Begin
87645>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
87646>>>            If (bExists = True) Begin
87648>>>                If (Uppercase(sPhysicalName) = Uppercase(sRootName)) Begin
87650>>>                    Function_Return False
87651>>>                End
87651>>>>
87651>>>            End
87651>>>>
87651>>>            Copy_db (sDataPath + sPhysicalName) to (sDataPath + sRootName)
87654>>>        End
87654>>>>
87654>>>
87654>>>        If (sDriverID <> DATAFLEX_ID) Begin
87656>>>            Move (sDriverID + ":" + sRootName) to sRootName
87657>>>        End
87657>>>>
87657>>>
87657>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87660>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87663>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87666>>>
87666>>>        // We need a short break here before attempting to delete the physical file or Windows
87666>>>        // might report "File in use..." and the deletion will fail.
87666>>>        Sleep 2
87667>>>        If (sDriverID = DATAFLEX_ID) Begin
87669>>>            Get vDeleteFile (sDataPath + sPhysicalName + ".*") to bOK
87670>>>        End
87670>>>>
87670>>>
87670>>>        Function_Return (Err = False)
87671>>>    End_Function
87672>>>
87672>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87674>>>        Move False to Err
87675>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87678>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87681>>>
87681>>>        Function_Return (Err = False)
87682>>>    End_Function                        
87683>>>    
87683>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
87683>>>    // Note that it first removes any driver prefixes in the rootname.
87683>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
87685>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
87685>>>        Boolean bTheSame bIsSQL 
87685>>>        Handle hTable
87685>>>        
87685>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87685>>>        Move APITableInfo.iTableNumber      to hTable
87686>>>        Get UtilTableIsSQL hTable           to bIsSQL
87687>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
87688>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo  
87691>>>        Get _TableNameOnly sRootNameTo                to sRootNameTo
87692>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87695>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
87698>>>        
87698>>>        If (bCompareFilelistUppercase = True) Begin
87700>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bTheSame                  
87701>>>        End
87701>>>>
87701>>>        Else Begin
87702>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bTheSame                  
87703>>>        End
87703>>>>
87703>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
87703>>>            
87703>>>        Function_Return bTheSame
87704>>>    End_Function  
87705>>>    
87705>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87707>>>        Handle hFile hTable 
87707>>>        String sTableName sLogicalName sDisplayName 
87707>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
87707>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
87707>>>        Boolean bOk bExists bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened bSameColumnDefinitions
87707>>>        Boolean bUseConnectionID bToANSI bRecnum bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase bExistingTable
87707>>>        Boolean bIsSame bSameTableNames bIsOpen bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
87707>>>        tSQLConnection SQLConnection  
87707>>>        tSQLConnection SQLConnection  
87707>>>        tColumnType    ColumnType
87707>>>        tColumnType    ColumnType
87707>>>        tAPITable      APITableFrom APITableTo
87707>>>        tAPITable      APITableFrom APITableTo
87707>>>        
87707>>>        // We don't allow update of the framework's DbVersion table.
87707>>>        If (Uppercase(sTableName) = "DBVERSION") Begin
87709>>>            Function_Return False
87710>>>        End
87710>>>>
87710>>>        
87710>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87711>>>        Get piDbType                            to iDbType
87712>>>        Get pbUseConnectionID                   to bUseConnectionID
87713>>>        Get pbRecnum                            to bRecnum
87714>>>        Get pbToANSI                            to bToANSI
87715>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87716>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87717>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase 
87718>>>        
87718>>>        Move CS_ANSI_Txt to sANSI_OEM
87719>>>        If (bToANSI = False) Begin
87721>>>            Move CS_OEM_Txt to sANSI_OEM
87722>>>        End
87722>>>>
87722>>>        Move APITableNameInfoFrom.sRootName  to sTableName
87723>>>        Get _TableNameOnly sTableName        to sTableName
87724>>>        If (sDriverIDFrom = DATAFLEX_ID) Begin
87726>>>            Move sTableName to sPhysicalFile
87727>>>        End
87727>>>>
87727>>>
87727>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
87727>>>        // is a programmer's error and we auto-correct for it here.
87727>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
87727>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
87727>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
87727>>>        // set it back and use a Mertech function to convert it to SQL.
87727>>>        Get IsMertechDriver sDriverIDFrom to bMertechDriver
87728>>>        If (bMertechDriver = True) Begin
87730>>>            If (bUseConnectionID = True) Begin
87732>>>                Move False to bUseConnectionID
87733>>>            End
87733>>>>
87733>>>            Move sDriverIDFrom to sOriginalDriverID
87734>>>            Move DATAFLEX_ID to sDriverIDFrom
87735>>>        End
87735>>>>
87735>>>        
87735>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87736>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87737>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87738>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87739>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87740>>>        Move APITableNameInfoFrom.sRootName     to sRootName
87741>>>        Move APITableNameInfoFrom.sLogicalName  to sLogicalName
87742>>>        Move APITableNameInfoFrom.sDisplayName  to sDisplayName
87743>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87744>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87745>>>        
87745>>>        // 'To' table properties:
87745>>>        Get UtilTableIsAlias hTable             to bIsAliasTo
87746>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
87747>>>        If (bIsSQLTableTo = False) Begin
87749>>>            Move DATAFLEX_ID to sDriverIDTo
87750>>>        End                                
87750>>>>
87750>>>        Else Begin
87751>>>            Move sDriverIDFrom to sDriverIDTo
87752>>>        End
87752>>>>
87752>>>        
87752>>>        // Does the 'To' table exist in Filelist.cfg _and_ on disk (embedded) or on the SQL back-end.
87752>>>        Get UtilTableExists  hTable             to bExistingTable
87753>>>        If (bExistingTable = False and bIsSQLTableFrom = True and bMertechDriver = False) Begin
87755>>>            Move True                           to bIsSQLTableTo 
87756>>>            Move sDriverIDFrom                  to sDriverIDTo   
87757>>>        End
87757>>>>
87757>>>        // Does table exist in Filelist.cfg:
87757>>>        Get UtilTableNumberIsInUse hTable       to bExistsInFilelist 
87758>>>
87758>>>        If (bIsSQLTableFrom = False and sDriverIDFrom <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverIDFrom)) Begin
87760>>>            Move (sDriverIDFrom + ":" + sRootName) to sRootName
87761>>>        End
87761>>>>
87761>>>
87761>>>        If (ghoProgressBar <> 0) Begin
87763>>>            Send DoAdvance of ghoProgressBar   
87764>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sTableName) * "Number:" * String(hTable))
87765>>>        End   
87765>>>>
87765>>>        
87765>>>        // a) The table is an Alias table:
87765>>>        //
87765>>>        // If this is an Alias file the Logical or Display name might have changed. Other than that
87765>>>        // there is nothing that can be updated for an Alias table.
87765>>>        // But we change all three attributes in case this is a new Alias table.
87765>>>        If (bIsAliasFrom = True) Begin           
87767>>>            // ToDo: The first param needs to be paramerized:
87767>>>            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
87768>>>            If (bSameTableNames = True) Begin
87770>>>                Function_Return True
87771>>>            End
87771>>>>
87771>>>            Else Begin 
87772>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87774>>>                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sTableName
87777>>>                End                                                           
87777>>>>
87777>>>                Else Begin
87778>>>                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName  
87781>>>                End
87781>>>>
87781>>>                Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
87784>>>                Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName                        
87787>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87789>>>                    Get SqlUtilCreateIntFile hTable sDriverIDFrom sConnectionID True False to bOk
87790>>>                End
87790>>>>
87790>>>            End  
87790>>>>
87790>>>            Function_Return True
87791>>>        End                                                           
87791>>>>
87791>>>        
87791>>>        Move hTable         to APITableTo.ApiTableInfo.iTableNumber
87792>>>        If (bIsSQLTableTo = True) Begin
87794>>>            Move sRootName  to APITableTo.ApiTableInfo.sRootName
87795>>>        End 
87795>>>>
87795>>>        Else Begin
87796>>>            Move sTableName to APITableTo.ApiTableInfo.sRootName
87797>>>        End
87797>>>>
87797>>>        
87797>>>        Move sLogicalName   to APITableTo.ApiTableInfo.sLogicalName
87798>>>        Move sDisplayName   to APITableTo.ApiTableInfo.sDisplayName
87799>>>        Move bIsAliasTo     to APITableTo.ApiTableInfo.bIsAlias
87800>>>        Move bIsSQLTableTo  to APITableTo.ApiTableInfo.bIsSQL
87801>>>        
87801>>>        // b) Table exists in Filelist.cfg. We will then compare & check the Filelist.cfg entries for differences.
87801>>>        If (bExistsInFilelist = True) Begin
87803>>>            // ToDo: The first param needs to be paramerized:
87803>>>            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
87804>>>            If (bSameTableNames = False) Begin
87806>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87808>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87811>>>                End
87811>>>>
87811>>>                Else Begin
87812>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to APITableFrom.ApiTableInfo.sRootName
87815>>>                End
87815>>>>
87815>>>                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableFrom.ApiTableInfo.sLogicalName
87818>>>                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableFrom.ApiTableInfo.sDisplayName                        
87821>>>            End  
87821>>>>
87821>>>        End                                     
87821>>>>
87821>>>        
87821>>>        // c) Both exists in Filelist.cfg and the table exists on disk (embedded) or as an SQL table. 
87821>>>        //    We then check for differences.
87821>>>        If (bExistingTable = True) Begin 
87823>>>            Get UtilColumnsStructFill  hTable to APITableTo.aApiColumns
87824>>>            Get UtilIndexesStructFill  hTable to APITableTo.aApiIndexes
87825>>>            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
87826>>>        
87826>>>            Move False to bFilelistError
87827>>>            Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87828>>>            // If there was a "Filelist" error (aka the logical names for the 'From' and 'To' tables weren't the same,
87828>>>            // we will _not_ attempt to make any table changes. An error has by now been generated and will
87828>>>            // appear in the logfile.
87828>>>            // Of course, if the tables were the same we also do nothing.
87828>>>            If (bFilelistError = True or bIsSame = True) Begin
87830>>>                Set TableName_Text of ghoStatusPanel to ""
87831>>>                Function_Return True
87832>>>            End
87832>>>>
87832>>>        End
87832>>>>
87832>>>        
87832>>>        // d) Create as new Table?
87832>>>        //
87832>>>        Move False to Err
87833>>>        If (bExistingTable = False) Begin
87835>>>            Get ApiTableCreate hTable sRootName sDisplayName sTableName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87836>>>            Function_Return bOk // And we're done.
87837>>>        End
87837>>>>
87837>>>        
87837>>>        // e) If we got this far we need to Update the table:
87837>>>        //    This is the last case (a-e).
87837>>>        If (ghoProgressBar <> 0) Begin
87839>>>            Send DoAdvance of ghoProgressBar   
87840>>>            Set TableName_Text of ghoStatusPanel to ("Updating Table:" * String(sTableName) * "Number:" * String(hTable))
87841>>>        End
87841>>>>
87841>>>        
87841>>>        // If an SQL 'To' table we fetch the connection details for login & Schema:
87841>>>        If (bIsSQLTableTo = True) Begin
87843>>>
87843>>>            // Get connection properties
87843>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
87844>>>            Move SQLConnection.sSchema to sSchema
87845>>>            If (sSchema = "") Begin
87847>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
87848>>>            End                                            
87848>>>>
87848>>>            Move SQLConnection.sConnectionID to sConnectionID
87849>>>
87849>>>            // If a DAW driver and using a connection id we need to check if it exists;
87849>>>            // else we create it before attempting creating the table
87849>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
87851>>>                Get IsConnectionID sConnectionID sDriverIDFrom to bExists
87852>>>                If (bExists = False) Begin
87854>>>                    Get UtilCreateConnectionID sConnectionID to bOk
87855>>>                    If (bOk = False) Begin
87857>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
87858>>>>
87858>>>                        Function_Return False
87859>>>                    End
87859>>>>
87859>>>                End
87859>>>>
87859>>>            End
87859>>>>
87859>>>
87859>>>            Move (sTableName + ".int") to sPhysicalFile
87860>>>            Move (Uppercase(sDisplayName)) to sVal
87861>>>            // Pre-face the DisplayName with the schema name;
87861>>>            // that is how DAW's tools does it.
87861>>>            If (not(sVal contains (sSchema + "."))) Begin
87863>>>                Move (Lowercase(sSchema) + "." + sLogicalName) to sDisplayName
87864>>>            End
87864>>>>
87864>>>        End 
87864>>>>
87864>>>        
87864>>>        Open hTable Mode DF_EXCLUSIVE
87866>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87869>>>        If (bOpened = False) Begin
87871>>>            Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87872>>>            Function_Return False
87873>>>        End
87873>>>>
87873>>>                
87873>>>        Move False to Err
87874>>>        Move hTable to hFile
87875>>>
87875>>>        // This will create new columns or update existing ones.     
87875>>>        Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87876>>>                
87876>>>        If (bOk = True) Begin             
87878>>>            If (bExistingTable = False) Begin
87880>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87882>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87885>>>                End                                                            
87885>>>>
87885>>>                Else Begin
87886>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
87889>>>                End
87889>>>>
87889>>>                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87892>>>                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName 
87895>>>                If (bIsSQLTableTo = True) Begin
87897>>>                    Get SqlUtilUpdateIntFile hTable to bOk
87898>>>                End
87898>>>>
87898>>>            End
87898>>>>
87898>>>
87898>>>            // Compare Indexes and if different; either create or change them 
87898>>>            Get UtilIndexesStructFill hTable to APITableTo.aApiIndexes
87899>>>            Get UtilIndexesCompare hTable APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
87900>>>            If (bIsSame = False) Begin
87902>>>                Get UtilIndexesUpdate hFile APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87903>>>            End
87903>>>>
87903>>>            
87903>>>            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
87904>>>            Get UtilRelationsCompare hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
87905>>>            If (bIsSame = False) Begin
87907>>>                Get UtilRelationsUpdate hFile APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87908>>>            End
87908>>>>
87908>>>        End
87908>>>>
87908>>>        
87908>>>        Close hTable
87909>>>        Set TableName_Text of ghoStatusPanel to ""
87910>>>
87910>>>        Function_Return (bOK = True)
87911>>>    End_Function                                                                                                        
87912>>>
87912>>>    // *** Field/Column Level Functions: ***
87912>>>    //
87912>>>    // Adds a column name to the passed table number.
87912>>>    // Note: Types must be the standard DF_ASCII, DF_DATE etcetera and _cannot_ be any of the SQL_xxx types.
87912>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87914>>>        Integer iColumn iCount iFile iPrecision
87914>>>        Boolean bExists bOK bInitializeValue bRetval
87914>>>        String sDdSrcPath sTableName sColumnValue
87914>>>
87914>>>        Get UtilColumnExists hTable sFieldName to bExists
87915>>>        If (bExists = True) Begin
87917>>>            Function_Return False
87918>>>        End 
87918>>>>
87918>>>        If (num_arguments > 4) Begin
87920>>>            Move iPrec to iPrecision
87921>>>        End
87921>>>>
87921>>>        If (iPrecision > 0) Begin
87923>>>            Move (iLength + iPrecision) to iLength
87924>>>        End
87924>>>>
87924>>>        If (num_arguments > 6) Begin
87926>>>            Move bInitVal to bInitializeValue
87927>>>            Move sColVal  to sColumnValue
87928>>>        End
87928>>>>
87928>>>        If (iType < -1490) Begin
87930>>>            Move (iType + 1500) to iType
87931>>>        End
87931>>>>
87931>>>        
87931>>>        Get AutoConnectionIDLogin to bOK
87932>>>        Move False to Err
87933>>>        // Structure_start will change the value of hTable...
87933>>>        Move hTable to iFile
87934>>>        Open iFile Mode DF_EXCLUSIVE
87936>>>
87936>>>        Structure_Start iFile
87937>>>            Move 0 to iColumn
87938>>>            Create_Field hTable At iColumn
87939>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87942>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87945>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to iLength
87948>>>//            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength - iPrecision)
87948>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87951>>>        Structure_End iFile
87953>>>
87953>>>        // If in development environment; create .fd file:
87953>>>        Open hTable
87955>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87956>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87957>>>        If (iCount > 1) Begin
87959>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87960>>>        End
87960>>>>
87960>>>        Get vFolderExists sDDSrcPath to bExists
87961>>>        If (bExists = True) Begin
87963>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87964>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87967>>>            Get _TableNameOnly sTableName to sTableName
87968>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87970>>>        End
87970>>>>
87970>>>        
87970>>>        // Check for a default value
87970>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87972>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87973>>>        End
87973>>>>
87973>>>        Close hTable
87974>>>
87974>>>        Function_Return (Err = False)
87975>>>    End_Function   
87976>>>    
87976>>>    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean 
87978>>>        Integer iColumn iCount iFile
87978>>>        Boolean bExists bOK  
87978>>>        String sDdSrcPath sTableName
87978>>>    
87978>>>        Get AutoConnectionIDLogin to bOK
87979>>>        Move False to Err   
87980>>>        
87980>>>        // Structure_start will change the value of hTable...
87980>>>        Move hTable to iFile
87981>>>        Open iFile Mode DF_EXCLUSIVE
87983>>>        
87983>>>        Structure_Start iFile
87984>>>            Send ApiColumnsAddToTable iFile aColumns False
87985>>>        Structure_End iFile
87987>>>        
87987>>>        // If in development environment; create .fd file:
87987>>>        Open hTable
87989>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87990>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87991>>>        If (iCount > 1) Begin
87993>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath    
87994>>>        End 
87994>>>>
87994>>>        Get vFolderExists sDDSrcPath to bExists
87995>>>        If (bExists = True) Begin                                   
87997>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath 
87998>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
88001>>>            Get _TableNameOnly sTableName to sTableName 
88002>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
88004>>>        End
88004>>>>
88004>>>        Close hTable
88005>>>
88005>>>        Function_Return (Err = False)
88006>>>    End_Function
88007>>>
88007>>>    // To update all records for a table column with a fixed value.
88007>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
88009>>>        Integer iRecs iCurrErr iField iRecord
88009>>>        Boolean bRetval bOpen
88009>>>        
88009>>>        Move 0 to iRecs                
88010>>>        Move False to bRetval 
88011>>>        Move Err to iCurrErr
88012>>>        Move False to Err
88013>>>        
88013>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88016>>>        If (bOpen = False) Begin
88018>>>            Open hTable
88020>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88023>>>            If (bOpen = False) Begin
88025>>>                Function_Return bRetval
88026>>>            End
88026>>>>
88026>>>        End
88026>>>>
88026>>>        
88026>>>        Field_Map hTable sFieldName to iField
88028>>>        If (iField <> 0) Begin
88030>>>            Clear hTable
88031>>>            Repeat
88031>>>>
88031>>>                Vfind hTable 0 GT
88033>>>                If (Found) Begin
88035>>>                    If (ghoStatusPanel <> 0) Begin
88037>>>                        Get_Field_Value hTable 0 to iRecord
88040>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
88041>>>                    End
88041>>>>
88041>>>                    Reread hTable
88045>>>                        Set_Field_Value hTable iField to sColumnValue
88048>>>                        SaveRecord hTable
88049>>>                    Unlock   
88050>>>>
88050>>>                End
88050>>>>
88050>>>           Until (not(Found))
88052>>>        End
88052>>>>
88052>>>        
88052>>>        Move (Err = False) to bRetval
88053>>>        Move iCurrErr to Err
88054>>>        
88054>>>        Function_Return bRetval
88055>>>    End_Function  
88056>>>    
88056>>>    Procedure ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating
88058>>>        Integer iCount iSize iColumn iType iIndex iDbType
88058>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen
88058>>>        String sFieldName sDriverID sTableName
88058>>>        
88058>>>        Get psDriverID to sDriverID                      
88059>>>        Get piDbType to iDbType
88060>>>        Get UtilTableHandleToString hTable to sTableName
88061>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
88062>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver                     
88063>>>        Get UtilTableIsSQL hTable to bIsSqlTable 
88064>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
88066>>>            Move True to bIsSqlTable
88067>>>        End
88067>>>>
88067>>>        Move False to bIsOpen
88068>>>        If (hTable > 0) Begin
88070>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88073>>>        End
88073>>>>
88073>>>        If (bIsOpen = True) Begin
88075>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88078>>>        End 
88078>>>>
88078>>>        Else Begin
88079>>>            Move True to bRecnumTable
88080>>>        End
88080>>>>
88080>>>        
88080>>>        Move (SizeOfArray(aColumns)) to iSize
88081>>>        Decrement iSize
88082>>>        for iCount from 0 to iSize   
88088>>>>
88088>>>            Move aColumns[iCount].sFieldName to sFieldName
88089>>>            If (hTable > 0) Begin    
88091>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88092>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88093>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
88096>>>                Move (Trim(sFieldName) <> "") to bFieldExists
88097>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88098>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88099>>>            End
88099>>>>
88099>>>            Else Begin
88100>>>                Move False to bFieldExists
88101>>>            End
88101>>>>
88101>>>            
88101>>>            If (bFieldExists = False) Begin 
88103>>>                Move 0 to iColumn
88104>>>                Create_Field hTable At iColumn                                                   
88105>>>            End  
88105>>>>
88105>>>            Else Begin
88106>>>                Move iCount to iColumn
88107>>>            End
88107>>>>
88107>>>            
88107>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
88108>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName                             
88111>>>
88111>>>            Move aColumns[iCount].iType to iType
88112>>>            Move (not(iType < -1490)) to bNativeType
88113>>>            If (iType < -1490) Begin
88115>>>                Move (iType + 1500) to iType
88116>>>            End
88116>>>>
88116>>>            
88116>>>            If (bIsSqlTable = True) Begin
88118>>>                If (bCreating = True) Begin
88120>>>                    Set_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
88123>>>                End
88123>>>>
88123>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
88126>>>            End
88126>>>>
88126>>>            Else Begin
88127>>>                If (bCreating = False) Begin
88129>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
88130>>>                End
88130>>>>
88130>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
88133>>>            End
88133>>>>
88133>>>            
88133>>>            If (iType <> DF_DATE and iType <> DF_DATETIME) Begin
88135>>>                Set_Attribute DF_FIELD_LENGTH of hTable iColumn to aColumns[iCount].iLength
88138>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
88141>>>            End
88141>>>>
88141>>>            
88141>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
88143>>>                If (bRecnumTable = False) Begin
88145>>>                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True 
88148>>>                End
88148>>>>
88148>>>                
88148>>>                // If we have an identity table - we must create a primary_key table. 
88148>>>                Move 0 to iIndex 
88149>>>                Create_Index hTable at iIndex
88150>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
88153>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn  
88156>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
88159>>>                If (bIsDAWSqlDriver = True and bIsSqlTable = True) Begin
88161>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True     
88164>>>                End
88164>>>>
88164>>>            End
88164>>>>
88164>>>        Loop
88165>>>>
88165>>>    End_Procedure
88166>>>
88166>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88168>>>        Integer iCount iSize iColumn iType iIndex iColumnsToSize hFile
88168>>>        Boolean bFieldExists bNativeType bIsDAWSqlDriver bIsSame bOK bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen
88168>>>        String sFieldName sTableName sDriverTo
88168>>>        
88168>>>        Move False to Err
88169>>>        Get IsDAWSQLDriver sDriverIDFrom to bIsDAWSqlDriver
88170>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
88171>>>        If (bIsSQLTableTo = False) Begin
88173>>>            Move DATAFLEX_ID to sDriverTo
88174>>>        End                            
88174>>>>
88174>>>        Else Begin
88175>>>            Get psDriverID to sDriverTo
88176>>>        End
88176>>>>
88176>>>        Get UtilTableHandleToString hTable to sTableName
88177>>>        
88177>>>        Move (SizeOfArray(aColumnsFrom)) to iSize 
88178>>>        Move (SizeOfArray(aColumnsTo)) to iColumnsToSize
88179>>>        Get OpenTableExclusive hTable to bOpened
88180>>>        
88180>>>        Decrement iSize
88181>>>        For iCount from 0 to iSize   
88187>>>>
88187>>>            Move aColumnsFrom[iCount].sFieldName   to sFieldName
88188>>>            Move aColumnsFrom[iCount].iFieldNumber to iColumn
88189>>>            If (hTable > 0) Begin                       
88191>>>                Move False to bFieldExists
88192>>>                If (iCount < iColumnsToSize) Begin
88194>>>                    Move aColumnsTo[iCount].sFieldName to sFieldName
88195>>>                    Move (Trim(sFieldName) <> "") to bFieldExists
88196>>>                End
88196>>>>
88196>>>            End
88196>>>>
88196>>>            Else Begin
88197>>>                Move False to bFieldExists
88198>>>            End
88198>>>>
88198>>>            
88198>>>            If (bFieldExists = True) Begin     
88200>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88201>>>                Get UtilColumnCompare sDriverIDFrom bIsSQLTableFrom bIsSQLTableTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DateTime to bIsSame
88202>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88203>>>                If (bIsSame = False) Begin  
88205>>>                    // ToDo: We might need to set more properties for the field than what currently is set...
88205>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88206>>>                    Get ApiColumnChangeByColumnNumber sDriverIDFrom bIsSQLTableFrom hTable bIsSQLTableTo aColumnsFrom[iCount].sFieldName aColumnsFrom[iCount].iFieldNumber aColumnsFrom[iCount].iType aColumnsFrom[iCount].iLength aColumnsFrom[iCount].iPrecision aColumnsFrom[iCount].iOptions to bOK
88207>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
88208>>>                End
88208>>>>
88208>>>            End
88208>>>>
88208>>>            
88208>>>            If (bFieldExists = False) Begin  
88210>>>                Move False to bIsOpen
88211>>>                If (hTable > 0) Begin        
88213>>>                    Close hTable
88214>>>                    Open hTable Mode DF_EXCLUSIVE
88216>>>                    Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88219>>>                End
88219>>>>
88219>>>                If (bIsOpen = True) Begin
88221>>>                    Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88224>>>                End 
88224>>>>
88224>>>                Else Begin
88225>>>                    Move True to bRecnumTable
88226>>>                End
88226>>>>
88226>>>
88226>>>                Move hTable to hFile
88227>>>                Structure_Start hFile sDriverIDFrom
88228>>>                    Move aColumnsFrom[iCount].iFieldNumber to iColumn
88229>>>                    Create_Field hFile At iColumn                                                   
88230>>>                    Set_Attribute DF_FIELD_NAME   of hFile iColumn to aColumnsFrom[iCount].sFieldName                                 
88233>>>//                    If (bIsSQLTable = True) Begin
88233>>>//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength - aColumnsFrom[iCount].iPrecision)
88233>>>                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to aColumnsFrom[iCount].iLength
88236>>>//                    End
88236>>>//                    Else Begin
88236>>>//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength + aColumnsFrom[iCount].iPrecision)
88236>>>//                    End
88236>>>                    
88236>>>                    If (aColumnsFrom[iCount].iPrecision > 0) Begin
88238>>>                        Set_Attribute DF_FIELD_PRECISION of hFile iColumn to aColumnsFrom[iCount].iPrecision
88241>>>                    End
88241>>>>
88241>>>                    
88241>>>                    Move aColumnsFrom[iCount].iType to iType
88242>>>                    Move (not(iType < -1490)) to bNativeType
88243>>>                    If (iType < -1490) Begin
88245>>>                        Move (iType + 1500) to iType
88246>>>                    End
88246>>>>
88246>>>                    // ToDo: This test is not enough. Do check for bSQLTableFrom
88246>>>                    If (bIsSQLTableTo = True) Begin
88248>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
88251>>>                    End
88251>>>>
88251>>>                    Else Begin
88252>>>                        Set_Attribute DF_FIELD_TYPE of hFile iColumn to iType
88255>>>                    End
88255>>>>
88255>>>                    
88255>>>                    If (aColumnsFrom[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
88257>>>                        If (bRecnumTable = False) Begin
88259>>>                            Set_Attribute DF_FIELD_IS_IDENTITY     of hFile iColumn to True 
88262>>>                        End
88262>>>>
88262>>>                        // If we have an identity table - we must create a primary_key table. 
88262>>>                        Move 0 to iIndex 
88263>>>                        Create_Index hFile at iIndex
88264>>>                        Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88267>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn  
88270>>>                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile iIndex to 1
88273>>>                        If (bIsDAWSqlDriver = True) Begin
88275>>>                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True     
88278>>>                        End
88278>>>>
88278>>>                    End  
88278>>>>
88278>>>                Structure_End hFile
88280>>>    
88280>>>            End
88280>>>>
88280>>>        Loop
88281>>>>
88281>>>            
88281>>>        Function_Return (Err = False)
88282>>>    End_Function
88283>>>
88283>>>    // Changes a field type, length and precision for the passed table number and field name
88283>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
88285>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
88285>>>        Boolean bOK bIsSqlTable  
88285>>>        String sFieldNameTo
88285>>>
88285>>>        If (num_arguments > 4) Begin
88287>>>            Move iPrec to iPrecFrom
88288>>>        End
88288>>>>
88288>>>        If (iTypeFrom < -1490) Begin
88290>>>            Move (iTypeFrom + 1500) to iTypeFrom
88291>>>        End
88291>>>>
88291>>>        
88291>>>        Get AutoConnectionIDLogin to bOK
88292>>>        Move False to Err
88293>>>        Get OpenTableExclusive hTable to bOK
88294>>>        If (bOK = False) Begin
88296>>>            Function_Return False
88297>>>        End  
88297>>>>
88297>>>        
88297>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88298>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88299>>>        Field_Map hTable sFieldNameFrom to iColumn
88301>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88302>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88303>>>        If (Err = True) Begin
88305>>>            Function_Return False
88306>>>        End
88306>>>>
88306>>>        
88306>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88309>>>        Get UtilTableIsSQL hTable to bIsSqlTable
88310>>>        If (bIsSqlTable = False) Begin
88312>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88315>>>        End
88315>>>>
88315>>>        Else Begin
88316>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
88319>>>        End 
88319>>>>
88319>>>        // Let the driver decide the other values;
88319>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88322>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
88325>>>        
88325>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
88327>>>            Function_Return False
88328>>>        End
88328>>>>
88328>>>
88328>>>        Structure_Start hTable      
88329>>>            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88332>>>            If (bIsSqlTable = False) Begin
88334>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
88337>>>            End
88337>>>>
88337>>>            Else Begin
88338>>>                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
88341>>>            End
88341>>>>
88341>>>            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88344>>>//            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to (iLengthFrom - iPrecFrom)
88344>>>            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88347>>>        Structure_End hTable
88349>>>
88349>>>        Function_Return (Err = False)
88350>>>    End_Function
88351>>>
88351>>>    // Changes a field type, length and precision for the passed table number and field name
88351>>>    Function ApiColumnChangeByColumnNumber String sDriverID Boolean bIsSQLTableFrom Handle hTable Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
88353>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType
88353>>>        Boolean bOK bIsSQL 
88353>>>        String sFieldNameTo    
88353>>>        tColumnType ColumnType
88353>>>        tColumnType ColumnType
88353>>>        
88353>>>        Get piDbType to iDbType
88354>>>        If (num_arguments > 4) Begin
88356>>>            Move iPrec to iPrecFrom                                    
88357>>>            Move iOpt  to iOptionFrom
88358>>>        End
88358>>>>
88358>>>        If (iTypeFrom < -1490) Begin
88360>>>            Move (iTypeFrom + 1500) to iTypeFrom
88361>>>        End
88361>>>>
88361>>>        
88361>>>        Get UtilTableIsSql hTable to bIsSQL
88362>>>        Get AutoConnectionIDLogin to bOK
88363>>>        Move False to Err
88364>>>        Get OpenTableExclusive hTable to bOK
88365>>>        If (bOK = False) Begin
88367>>>            Function_Return False
88368>>>        End  
88368>>>>
88368>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
88371>>>        
88371>>>        If (bIsSQLTableTo = True) Begin
88373>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
88376>>>        End
88376>>>>
88376>>>        Else Begin
88377>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
88380>>>        End
88380>>>>
88380>>>        
88380>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
88383>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
88386>>>        Get_Attribute DF_FIELD_IS_IDENTITY          of hTable iColumn to iOptionTo
88389>>>        
88389>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
88389>>>        // data types between Embedded and SQL.
88389>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88391>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iTypeFrom
88392>>>        End
88392>>>>
88392>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88395>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeTo   iLengthTo   to iTypeTo
88396>>>        End
88396>>>>
88396>>>        
88396>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
88398>>>            Function_Return False
88399>>>        End
88399>>>>
88399>>>
88399>>>        Structure_Start hTable      
88400>>>            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
88403>>>            If (bIsSQLTableTo = False) Begin
88405>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
88408>>>            End
88408>>>>
88408>>>            Else Begin
88409>>>                Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iDataFlexType
88410>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iDataFlexType
88413>>>                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
88416>>>            End
88416>>>>
88416>>>            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
88419>>>            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
88422>>>            
88422>>>            If (bIsSQL = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88424>>>                Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
88427>>>            End
88427>>>>
88427>>>        Structure_End hTable
88429>>>
88429>>>        Function_Return (Err = False)
88430>>>    End_Function
88431>>>
88431>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
88433>>>        Boolean bOK
88433>>>
88433>>>        Get AutoConnectionIDLogin to bOK
88434>>>        Move False to Err
88435>>>        Get OpenTableExclusive hTable to bOK
88436>>>        If (bOK = False) Begin
88438>>>            Function_Return False
88439>>>        End
88439>>>>
88439>>>
88439>>>        Structure_Start hTable
88440>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
88443>>>        Structure_End hTable
88445>>>
88445>>>        Function_Return (Err = False)
88446>>>    End_Function
88447>>>
88447>>>    // To move an existing field to another position in a table.
88447>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Returns Boolean
88449>>>        String sColumn sDriverID
88449>>>        Integer iType iLength iPrecision
88449>>>        Boolean bOK
88449>>>
88449>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88452>>>        If (sDriverID = DFBTRDRV_ID) Begin
88454>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
88455>>>>
88455>>>            Function_Return False
88456>>>        End
88456>>>>
88456>>>
88456>>>        Close hTable
88457>>>        Get AutoConnectionIDLogin to bOK
88458>>>        Get OpenTableExclusive hTable to bOK
88459>>>        If (bOK = False) Begin
88461>>>            Function_Return False
88462>>>        End
88462>>>>
88462>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
88465>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
88468>>>
88468>>>        If (iType <> DF_DATE) Begin
88470>>>            Get_Attribute DF_FIELD_LENGTH of hTable iOld to iLength
88473>>>        End
88473>>>>
88473>>>
88473>>>        If (iType = DF_BCD) Begin
88475>>>            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
88478>>>        End
88478>>>>
88478>>>        Move False to Err
88479>>>
88479>>>        Structure_Start hTable
88480>>>            Delete_Field hTable iOld
88481>>>            Create_Field hTable At iNew
88482>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
88485>>>            Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
88488>>>
88488>>>            If (iType <> DF_DATE) Begin
88490>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
88493>>>            End
88493>>>>
88493>>>
88493>>>            If (iType = DF_BCD) Begin
88495>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
88498>>>            End
88498>>>>
88498>>>
88498>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
88501>>>        Structure_End hTable
88503>>>
88503>>>        Function_Return (Err = False)
88504>>>    End_Function
88505>>>
88505>>>    // Deletes a column name for the passed table number (and column number).
88505>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
88507>>>        Integer iColumn
88507>>>        Boolean bOK
88507>>>
88507>>>        Get AutoConnectionIDLogin to bOK 
88508>>>        Move False to Err
88509>>>        Close hTable
88510>>>        Get OpenTableExclusive hTable to bOK
88511>>>        If (bOK = False) Begin
88513>>>            Function_Return False
88514>>>        End
88514>>>>
88514>>>        
88514>>>        If (not(Err)) Begin
88516>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88517>>>            Field_Map hTable sFieldName to iColumn
88519>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88520>>>            If (Err = True) Begin
88522>>>                Function_Return False
88523>>>            End
88523>>>>
88523>>>            Move False to Err
88524>>>    
88524>>>            Structure_Start hTable
88525>>>                Delete_Field hTable iColumn
88526>>>            Structure_End hTable
88528>>>        End  
88528>>>>
88528>>>        Else Begin
88529>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
88530>>>>
88530>>>        End
88530>>>>
88530>>>
88530>>>        Function_Return (Err = False)
88531>>>    End_Function
88532>>>
88532>>>    // Renames a field for the passed table number & old field name & new field name
88532>>>    // Returns True if no errors occured.
88532>>>    // Sample usage:
88532>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
88532>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
88534>>>        Integer iField
88534>>>        Boolean bOK
88534>>>
88534>>>        Get AutoConnectionIDLogin to bOK
88535>>>        Move False to Err
88536>>>        Get OpenTableExclusive hTable to bOK
88537>>>        If (bOK = False) Begin
88539>>>            Function_Return False
88540>>>        End
88540>>>>
88540>>>
88540>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88541>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88542>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88543>>>        Structure_Start hTable
88544>>>            Field_Map hTable sOldFieldName to iField
88546>>>            If (iField > 0) Begin
88548>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
88551>>>            End
88551>>>>
88551>>>            Else Begin
88552>>>                Move 0 to LastErr
88553>>>                Move False to Err
88554>>>            End
88554>>>>
88554>>>        Structure_End hTable
88556>>>
88556>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88557>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
88558>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88559>>>
88559>>>        Function_Return (Err = False)
88560>>>    End_Function
88561>>>
88561>>>    // *** Index Level Functions: ***
88561>>>    //
88561>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88561>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88561>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88561>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88563>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
88563>>>        String sDriverID
88563>>>        Boolean bOK
88563>>>
88563>>>        Get AutoConnectionIDLogin to bOK
88564>>>        Move -1 to iSegment1
88565>>>        Move -1 to iSegment2
88566>>>        Move -1 to iSegment3
88567>>>        Move -1 to iSegment4
88568>>>        Move -1 to iSegment5
88569>>>        Move -1 to iSegment6
88570>>>        Move -1 to iSegment7
88571>>>        Move -1 to iSegment8
88572>>>        Move -1 to iSegment9
88573>>>        Move -1 to iSegment10
88574>>>
88574>>>        If (num_arguments > 3) Begin
88576>>>            Move iSgmnt1 to iSegment1
88577>>>        End
88577>>>>
88577>>>        If (num_arguments > 4) Begin
88579>>>            Move iSgmnt2 to iSegment2
88580>>>        End
88580>>>>
88580>>>        If (num_arguments > 5) Begin
88582>>>            Move iSgmnt3 to iSegment3
88583>>>        End
88583>>>>
88583>>>        If (num_arguments > 6) Begin
88585>>>            Move iSgmnt4 to iSegment4
88586>>>        End
88586>>>>
88586>>>        If (num_arguments > 7) Begin
88588>>>            Move iSgmnt5 to iSegment5
88589>>>        End
88589>>>>
88589>>>        If (num_arguments > 8) Begin
88591>>>            Move iSgmnt6 to iSegment6
88592>>>        End
88592>>>>
88592>>>        If (num_arguments > 9) Begin
88594>>>            Move iSgmnt7 to iSegment7
88595>>>        End
88595>>>>
88595>>>        If (num_arguments > 10) Begin
88597>>>            Move iSgmnt8 to iSegment8
88598>>>        End
88598>>>>
88598>>>        If (num_arguments > 11) Begin
88600>>>            Move iSgmnt9 to iSegment9
88601>>>        End
88601>>>>
88601>>>        If (num_arguments > 12) Begin
88603>>>            Move iSgmnt10 to iSegment10
88604>>>        End
88604>>>>
88604>>>
88604>>>        Move False to Err
88605>>>        Move hTable to iTableNo
88606>>>        Get OpenTableExclusive hTable to bOK
88607>>>        If (bOK = False) Begin
88609>>>            Function_Return False
88610>>>        End
88610>>>>
88610>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88613>>>
88613>>>        // We start by deleting the index
88613>>>        Structure_Start hTable sDriverID
88614>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88615>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88616>>>            Delete_Index iTableNo iIndex
88617>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88618>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88619>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88621>>>
88621>>>        Move False to Err
88622>>>        Move iTableNo to hTable
88623>>>        Get OpenTableExclusive hTable to bOK
88624>>>        If (bOK = False) Begin
88626>>>            Function_Return False
88627>>>        End
88627>>>>
88627>>>
88627>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88628>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88628>>>        Structure_Start hTable sDriverID
88629>>>            Create_Index hTable At iIndex
88630>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88633>>>
88633>>>            If (iSgmnt1 <> -1) Begin
88635>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88638>>>            End
88638>>>>
88638>>>            If (iSegment2 <> -1) Begin
88640>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88643>>>            End
88643>>>>
88643>>>            If (iSegment3 <> -1) Begin
88645>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88648>>>            End
88648>>>>
88648>>>            If (iSegment4 <> -1) Begin
88650>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88653>>>            End
88653>>>>
88653>>>            If (iSegment5 <> -1) Begin
88655>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88658>>>            End
88658>>>>
88658>>>            If (iSegment6 <> -1) Begin
88660>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88663>>>            End
88663>>>>
88663>>>            If (iSegment7 <> -1) Begin
88665>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88668>>>            End
88668>>>>
88668>>>            If (iSegment8 <> -1) Begin
88670>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88673>>>            End
88673>>>>
88673>>>            If (iSegment9 <> -1) Begin
88675>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88678>>>            End
88678>>>>
88678>>>            If (iSegment10 <> -1) Begin
88680>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88683>>>            End
88683>>>>
88683>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88685>>>
88685>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88686>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
88686>>>
88686>>>        Function_Return (Err = False)
88687>>>    End_Function
88688>>>
88688>>>    Function APIIndexCreateByFieldNames Handle hTable Integer iIndex tAPIIndexSegment[] aIndexSegments Returns Boolean 
88690>>>        String[] aFields
88691>>>        Integer iCount iSize iMax iTableNo iField iSegments
88691>>>        String sDriverID
88691>>>        Boolean bOK 
88691>>>
88691>>>        Move (SizeOfArray(aIndexSegments)) to iSize
88692>>>        If (iSize = 0) Begin
88694>>>            Function_Return False                                                            
88695>>>        End
88695>>>>
88695>>>        Decrement iSize
88696>>>        
88696>>>        Move hTable to iTableNo
88697>>>        Get AutoConnectionIDLogin to bOK
88698>>>        Move False to Err
88699>>>        Get OpenTableExclusive hTable to bOK
88700>>>        If (bOK = False) Begin
88702>>>            Function_Return False
88703>>>        End
88703>>>>
88703>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88706>>>        
88706>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER 
88707>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88708>>>        Send Ignore_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
88709>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88710>>>        // We will only attempt to delete the index in case it exists.
88710>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88713>>>        If (iSegments > 0) Begin
88715>>>            // We start by deleting the index
88715>>>            Structure_Start hTable sDriverID 
88716>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88717>>>                Delete_Index iTableNo iIndex
88718>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
88719>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE
88721>>>        End
88721>>>>
88721>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER 
88722>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88723>>>        Send Trap_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
88724>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88725>>>        
88725>>>        Move False to Err
88726>>>        Move 0 to LastErr
88727>>>        Move iTableNo to hTable
88728>>>        Get OpenTableExclusive hTable to bOK
88729>>>        If (bOK = False) Begin
88731>>>            Function_Return False
88732>>>        End
88732>>>>
88732>>>    
88732>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88733>>>        Structure_Start hTable sDriverID
88734>>>            Create_Index hTable At iIndex
88735>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iSize + 1)
88738>>>            for iCount from 0 to iSize
88744>>>>
88744>>>                Move aIndexSegments[iCount].iFieldNumber to iField
88745>>>                If (iField <> -1) Begin 
88747>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iCount + 1) to iField
88750>>>                End
88750>>>>
88750>>>            Loop
88751>>>>
88751>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88753>>>
88753>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88754>>>        Function_Return (Err = False)
88755>>>    End_Function
88756>>>    
88756>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88758>>>        Boolean bOK
88758>>>
88758>>>        Get AutoConnectionIDLogin to bOK
88759>>>        Move False to Err
88760>>>        Get OpenTableExclusive hTable to bOK
88761>>>        If (bOK = False) Begin
88763>>>            Function_Return False
88764>>>        End
88764>>>>
88764>>>        Structure_Start hTable
88765>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88768>>>        Structure_End hTable
88770>>>
88770>>>        Function_Return (Err = False)
88771>>>    End_Function
88772>>>
88772>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88774>>>        Integer iCase
88774>>>        Boolean bOK
88774>>>
88774>>>        If (bUppercase = True) Begin
88776>>>            Move DF_CASE_IGNORED to iCase
88777>>>        End
88777>>>>
88777>>>        Else Begin
88778>>>            Move DF_CASE_USED to iCase
88779>>>        End
88779>>>>
88779>>>
88779>>>        Get AutoConnectionIDLogin to bOK
88780>>>        Move False to Err
88781>>>        Get OpenTableExclusive hTable to bOK
88782>>>        If (bOK = False) Begin
88784>>>            Function_Return False
88785>>>        End
88785>>>>
88785>>>        Structure_Start hTable
88786>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88789>>>        Structure_End hTable
88791>>>
88791>>>        Function_Return (Err = False)
88792>>>    End_Function
88793>>>
88793>>>    // To delete an index
88793>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88795>>>        Integer iTableNo iNumSegments
88795>>>        String sDriverID
88795>>>        Boolean bOK
88795>>>
88795>>>        Get AutoConnectionIDLogin to bOK
88796>>>        Move False to Err
88797>>>        Move hTable to iTableNo
88798>>>        Get OpenTableExclusive hTable to bOK
88799>>>        If (bOK = False) Begin
88801>>>            Function_Return False
88802>>>        End
88802>>>>
88802>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88805>>>
88805>>>        // Check to see if the index exists or not...
88805>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88808>>>        If (iNumSegments = 0) Begin
88810>>>            Function_Return False
88811>>>        End
88811>>>>
88811>>>
88811>>>        Structure_Start hTable sDriverID
88812>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88813>>>            Delete_Index iTableNo iIndex
88814>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88815>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88817>>>
88817>>>        Function_Return (Err = False)
88818>>>    End_Function
88819>>>
88819>>>    // Delete an Index Segment
88819>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88821>>>        Boolean bOK bSQLDriver bIndexTemporary
88821>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88821>>>        Integer iIndexType
88821>>>        String sDriverID 
88821>>>
88821>>>        Get AutoConnectionIDLogin to bOK
88822>>>        Move False to Err
88823>>>    
88823>>>        Get OpenTableExclusive hTable to bOK
88824>>>        If (bOK = False) Begin
88826>>>            Function_Return False
88827>>>        End
88827>>>>
88827>>>        
88827>>>        // Check to see if the index exists or not...
88827>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88830>>>        If (iNumSegments = 0) Begin
88832>>>            Function_Return False
88833>>>        End
88833>>>>
88833>>>        
88833>>>        Move False to bIndexTemporary
88834>>>        Get psDriverID to sDriverID
88835>>>        Get IsSQLDriver sDriverID to bSQLDriver
88836>>>        If (bSQLDriver) Begin
88838>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88841>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88844>>>                Move True to bIndexTemporary
88845>>>        End
88845>>>>
88845>>>    
88845>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88845>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88847>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88850>>>            If (iSegment = iNumSegments) Begin
88852>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88855>>>            End
88855>>>>
88855>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88858>>>                For iCurSegment from iSegment to (iNumSegments - 1)
88864>>>>
88864>>>                    //*** Move index segment attributes
88864>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88867>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88870>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88873>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88876>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88879>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88882>>>                Loop
88883>>>>
88883>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88886>>>            End
88886>>>>
88886>>>        End
88886>>>>
88886>>>
88886>>>        Else Begin
88887>>>           Structure_Start hTable
88888>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88891>>>               If (iSegment = iNumSegments) Begin
88893>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88896>>>               End
88896>>>>
88896>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88899>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
88905>>>>
88905>>>                       //*** Move index segment attributes
88905>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88908>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88911>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88914>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88917>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88920>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88923>>>                   Loop
88924>>>>
88924>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88927>>>               End
88927>>>>
88927>>>           Structure_End hTable
88929>>>        End
88929>>>>
88929>>>        
88929>>>        Function_Return (Err = False)
88930>>>    End_Function
88931>>>    
88931>>>    // Add/Insert an Index Segment
88931>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
88933>>>        Boolean bOK bSQLDriver bIndexTemporary
88933>>>        Integer iSQLType iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
88933>>>        Integer iIndexType
88933>>>        String sDriverId
88933>>>        
88933>>>        Get AutoConnectionIDLogin to bOK
88934>>>        Move False to Err
88935>>>    
88935>>>        Get OpenTableExclusive hTable to bOK
88936>>>        If (bOK = False) Begin
88938>>>            Function_Return False
88939>>>        End
88939>>>>
88939>>>        
88939>>>        Move False to bIndexTemporary
88940>>>        // Check to see if the index exists or not...
88940>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88943>>>        If (iNumSegments = 0) Begin
88945>>>            Function_Return False
88946>>>        End
88946>>>>
88946>>>    
88946>>>        Get psDriverID to sDriverID
88947>>>        Get IsSQLDriver sDriverID to bSQLDriver
88948>>>        If (bSQLDriver) Begin
88950>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88953>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88956>>>                Move True to bIndexTemporary
88957>>>        End
88957>>>>
88957>>>
88957>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88957>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88959>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88962>>>    
88962>>>           If (iSegment > iNumSegments) Begin
88964>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88967>>>               Move (iNumSegments + 1) to iCurSegment
88968>>>           End
88968>>>>
88968>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88971>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88974>>>               Move iNumSegments to iCurSegment
88975>>>           
88975>>>               While (iCurSegment > iSegment)
88979>>>                   //*** Move index segment attributes
88979>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
88982>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
88985>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
88988>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
88991>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
88994>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
88997>>>                   Decrement iCurSegment
88998>>>               End
88999>>>>
88999>>>           
88999>>>               //*** Now set new segment attributes
88999>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89002>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89005>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89008>>>           End
89008>>>>
89008>>>        End
89008>>>>
89008>>>        
89008>>>        Else Begin
89009>>>           Structure_Start hTable
89010>>>              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89013>>>           
89013>>>              If (iSegment > iNumSegments) Begin
89015>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89018>>>                  Move (iNumSegments + 1) to iCurSegment
89019>>>              End
89019>>>>
89019>>>              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89022>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89025>>>                  Move iNumSegments to iCurSegment
89026>>>              
89026>>>                  While (iCurSegment > iSegment)
89030>>>                      //*** Move index segment attributes
89030>>>                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89033>>>                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89036>>>                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89039>>>                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89042>>>                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89045>>>                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89048>>>                      Decrement iCurSegment
89049>>>                  End
89050>>>>
89050>>>              
89050>>>                  //*** Now set new segment attributes
89050>>>                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89053>>>                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89056>>>                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89059>>>              End
89059>>>>
89059>>>           Structure_End hTable
89061>>>        End
89061>>>>
89061>>>        
89061>>>        Function_Return (Err = False)
89062>>>    End_Function
89063>>>    
89063>>>    // Returns an SQL Driver ID if it appears as a prefix for the passed sRootName
89063>>>    // If no driver found the DATAFLEX_ID is returned
89063>>>//    Function UtilDriverIDFromRootName String sRootName Returns String
89063>>>//        String sDriverID
89063>>>//        Integer iPos
89063>>>//        Move (Pos(":", sRootName)) to iPos
89063>>>//        If (iPos <> 0) Begin
89063>>>//            Move (Left(sRootName, (iPos -1))) to sDriverID
89063>>>//        End
89063>>>//        Else Begin
89063>>>//            Move DATAFLEX_ID to sDriverID
89063>>>//        End
89063>>>//        Function_Return sDriverID
89063>>>//    End_Function              
89063>>>    
89063>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89063>>>    // Note that it first removes any driver prefixes in the rootname.
89063>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfoFrom tAPITableNameInfo APITableInfoTo Returns Boolean
89065>>>        Boolean bTheSame 
89065>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89065>>>        
89065>>>        Get _TableNameOnly APITableInfoFrom.sRootName to sRootNameFrom
89066>>>        Get _TableNameOnly APITableInfoTo.sRootName   to sRootNameTo                                    
89067>>>        Move APITableInfoFrom.sLogicalName            to sLogicalNameFrom
89068>>>        Move APITableInfoTo.sLogicalName              to sLogicalNameTo
89069>>>        Move APITableInfoFrom.sDisplayName            to sDisplayNameFrom
89070>>>        Move APITableInfoTo.sDisplayName              to sDisplayNameTo
89071>>>        If (bCompareFilelistUppercase = True) Begin
89073>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bTheSame
89074>>>        End
89074>>>>
89074>>>        Else Begin
89075>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bTheSame                  
89076>>>        End
89076>>>>
89076>>>            
89076>>>        Function_Return bTheSame
89077>>>    End_Function                
89078>>>    
89078>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89080>>>        Handle hTableFrom hTableTo 
89080>>>        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
89080>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase 
89080>>>        String sRootName sDriverID
89080>>>
89080>>>        Move False to bFilelistError
89081>>>        Move True to bIsSame
89082>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89083>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89084>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89085>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89086>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo          
89087>>>        
89087>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89088>>>        Get _TableNameOnly sRootName             to sRootName
89089>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89090>>>
89090>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89090>>>        // bCodeGenerateMode = True = Code Generation mode.
89090>>>        If (bCodeGenerateMode = True) Begin
89092>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89092>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89094>>>                Function_Return False
89095>>>            End
89095>>>>
89095>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89096>>>            If (bIsSame = False) Begin   
89098>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89099>>>                Move True to bFilelistError
89100>>>                Function_Return False
89101>>>            End
89101>>>>
89101>>>        End
89101>>>>
89101>>>        
89101>>>        If (bCodeGenerateMode = False) Begin
89103>>>            // Then we want to create this table
89103>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89105>>>                Function_Return False
89106>>>            End
89106>>>>
89106>>>                
89106>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89107>>>            If (bIsSame = False) Begin
89109>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89110>>>>
89110>>>                Move True to bFilelistError
89111>>>                Function_Return False
89112>>>            End
89112>>>>
89112>>>        End
89112>>>>
89112>>>
89112>>>        // Check columns:                        
89112>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89113>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89114>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom 
89115>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89116>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverID
89117>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns  
89118>>>        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bIsSame
89119>>>        If (bIsSame = False) Begin
89121>>>            Function_Return False
89122>>>        End
89122>>>>
89122>>>        
89122>>>        // ...then check indexes:
89122>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89123>>>        Get UtilIndexesCompare    hTableFrom APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
89124>>>        If (bIsSame = False) Begin
89126>>>            Function_Return False
89127>>>        End
89127>>>>
89127>>>        
89127>>>        // ...and finally relationships:
89127>>>        Get UtilRelationStructFill hTableFrom to APITableTo.aApiRelations
89128>>>        Get UtilRelationsCompare      hTableFrom APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
89129>>>        
89129>>>        Function_Return (bIsSame = True)
89130>>>    End_Function
89131>>>    
89131>>>    // Similar to UtilTableCompare, but takes two tAPITable struct arrays as parameters and a apitableboolean struct as params.
89131>>>    Function UtilTableCompare_Ex tAPITable CompareTableFrom tAPITable CompareTableTo tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89133>>>        Handle hTableFrom hTableTo 
89133>>>        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
89133>>>        tAPITableNameInfo APITableInfoFrom APITableInfoTo
89133>>>        tAPITableNameInfo APITableInfoFrom APITableInfoTo
89133>>>        tAPIIndex[]    aIndexesFrom   aIndexesTo
89133>>>        tAPIIndex[]    aIndexesFrom   aIndexesTo
89135>>>        tAPIColumn[]   aColumnsFrom   aColumnsTo
89135>>>        tAPIColumn[]   aColumnsFrom   aColumnsTo
89137>>>        tAPIRelation[] aRelationsFrom aRelationsTo        
89137>>>        tAPIRelation[] aRelationsFrom aRelationsTo        
89139>>>        String sRootName sDriverID
89139>>>        
89139>>>        If (CompareTableFrom.ApiTableInfo.iTableNumber < 0 or CompareTableTo.ApiTableInfo.iTableNumber < 0) Begin
89141>>>            Move True to bFilelistError
89142>>>            Function_Return False    
89143>>>        End 
89143>>>>
89143>>>        
89143>>>        Move True  to bIsSame 
89144>>>        Move False to bFilelistError
89145>>>        
89145>>>        Move CompareTableFrom.ApiTableInfo  to APITableInfoFrom
89146>>>        Move CompareTableFrom.aApiColumns   to aColumnsFrom
89147>>>        Move CompareTableFrom.aApiIndexes   to aIndexesFrom
89148>>>        Move CompareTableFrom.aApiRelations to aRelationsFrom  
89149>>>        Move APITableInfoFrom.iTableNumber  to hTableFrom 
89150>>>        Move APITableInfoFrom.bIsSQL        to bIsSQLFrom         
89151>>>        Move APITableInfoFrom.sDriverID     to sDriverID
89152>>>        
89152>>>        Move CompareTableTo.ApiTableInfo    to APITableInfoTo
89153>>>        Move CompareTableTo.aApiColumns     to aColumnsTo
89154>>>        Move CompareTableTo.aApiIndexes     to aIndexesTo
89155>>>        Move CompareTableTo.aApiRelations   to aRelationsTo
89156>>>        Move APITableInfoTo.iTableNumber    to hTableTo          
89157>>>        Move APITableInfoTo.bIsSQL          to bIsSQLTo
89158>>>        
89158>>>        Move APITableInfoTo.sRootName       to sRootName
89159>>>        Get _TableNameOnly sRootName        to sRootName
89160>>>
89160>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89160>>>        // bCodeGenerateMode = True = Code Generation mode.
89160>>>        If (bCodeGenerateMode = True) Begin
89162>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89162>>>            If (Trim(APITableInfoTo.sLogicalName) = "") Begin
89164>>>                Function_Return False
89165>>>            End                                                                    
89165>>>>
89165>>>            Move (Uppercase(APITableInfoFrom.sLogicalName) = Uppercase(APITableInfoTo.sLogicalName)) to bIsSame
89166>>>            If (bIsSame = False) Begin
89168>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableInfoFrom.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableInfoTo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89169>>>                Move True to bFilelistError
89170>>>                Function_Return False
89171>>>            End
89171>>>>
89171>>>        End
89171>>>>
89171>>>        
89171>>>        If (bCodeGenerateMode = False) Begin
89173>>>            If (Trim(Uppercase(APITableInfoTo.sLogicalName)) = "") Begin
89175>>>                // Then we might want to create this table
89175>>>                Function_Return False
89176>>>            End
89176>>>>
89176>>>            
89176>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableInfoFrom APITableInfoTo to bIsSame
89177>>>            If (bIsSame = False) Begin
89179>>>                Function_Return False
89180>>>            End
89180>>>>
89180>>>        End
89180>>>>
89180>>>
89180>>>        // Check columns:         
89180>>>        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom aColumnsTo CompareTableBooleans.bCompareDate_DateTime to bIsSame
89181>>>        If (bIsSame = False) Begin
89183>>>            Function_Return False
89184>>>        End
89184>>>>
89184>>>        
89184>>>        // ...then check indexes:
89184>>>        Get UtilIndexesCompare hTableFrom aIndexesFrom aIndexesTo CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89185>>>        If (bIsSame = False) Begin
89187>>>            Function_Return False
89188>>>        End
89188>>>>
89188>>>        
89188>>>        // ...and finally relationships:
89188>>>        Get UtilRelationsCompare hTableFrom aRelationsFrom aRelationsTo to bIsSame
89189>>>        
89189>>>        Function_Return (bIsSame = True)
89190>>>    End_Function
89191>>>    
89191>>>    // Compare multiple columns. (For 'From' & 'To' tables)
89191>>>    Function UtilColumnsCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
89193>>>        Boolean bIsSame        
89193>>>        Integer iCount iSize iSizeFrom iSizeTo iColumn iType iLength
89193>>>        String sColumnNameFrom sColumnNameTo
89193>>>        
89193>>>        Move True to bIsSame
89194>>>        Move (SizeOfArray(aColumnsFrom)) to iSizeFrom
89195>>>        Move (SizeOfArray(aColumnsTo))   to iSizeTo
89196>>>        If (iSizeFrom <> iSizeTo) Begin
89198>>>            Function_Return False
89199>>>        End          
89199>>>>
89199>>>        Move (iSizeFrom max iSizeTo)     to iSize
89200>>>        
89200>>>        Decrement iSize
89201>>>        for iCount from 0 to iSize   
89207>>>>
89207>>>            If (iCount <= iSizeFrom and iCount <= iSizeTo) Begin
89209>>>                Get UtilColumnCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DataTime to bIsSame
89210>>>            End 
89210>>>>
89210>>>            Else Begin
89211>>>                Move False to bIsSame
89212>>>            End
89212>>>>
89212>>>            
89212>>>            If (bIsSame = False) Begin
89214>>>                Function_Return False
89215>>>            End
89215>>>>
89215>>>        Loop
89216>>>>
89216>>>        
89216>>>        Function_Return (bIsSame = True)
89217>>>    End_Function
89218>>>    
89218>>>    // Compares a single column (For 'From' & 'To' tables)
89218>>>    Function UtilColumnCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn aColumnsFrom tAPIColumn aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
89220>>>        Boolean bIsSame 
89220>>>        Integer iFromType iToType iDbType                    
89220>>>        tColumnType ColumnType
89220>>>        tColumnType ColumnType
89220>>>        
89220>>>        Get piDbType to iDbType
89221>>>        Move (aColumnsFrom.iFieldNumber <> 0 and aColumnsTo.iFieldNumber <> 0) to bIsSame
89222>>>        // Check that _both_ field_number and field_name are the same
89222>>>        // else they needs to be changed...                                  
89222>>>        If (bIsSame = False) Begin
89224>>>            Move (aColumnsFrom.iFieldNumber = aColumnsTo.iFieldNumber) to bIsSame
89225>>>        End
89225>>>>
89225>>>        If (bIsSame = False) Begin
89227>>>            Function_Return False
89228>>>        End
89228>>>>
89228>>>        Move (aColumnsFrom.sFieldName = aColumnsTo.sFieldName) to bIsSame
89229>>>        If (bIsSame = False) Begin
89231>>>            Function_Return False
89232>>>        End
89232>>>>
89232>>>        
89232>>>        Move aColumnsFrom.iType to iFromType
89233>>>        Move aColumnsTo.iType   to iToType
89234>>>        
89234>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
89234>>>        // data types between Embedded and SQL.
89234>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
89236>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iFromType aColumnsFrom.iLength to iFromType
89237>>>        End
89237>>>>
89237>>>        Else If (bIsSQLFrom = False and bIsSQLTo = True) Begin
89240>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iToType   aColumnsFrom.iLength to iToType
89241>>>        End
89241>>>>
89241>>>        
89241>>>        // *** THIS NEEDS TO BE REDONE ***
89241>>>        
89241>>>        // Make Date and DateTime comparison?
89241>>>        If (bCompareDate_DataTime = True and iFromType = DF_DATE or iFromType = DF_DATETIME or iFromType = SQL_TYPE_TIMESTAMP or iFromType = SQL_TYPE_TIMESTAMP2) Begin
89243>>>            Move (iFromType = iToType) to bIsSame
89244>>>            If (bIsSame = False) Begin
89246>>>                Function_Return False
89247>>>            End
89247>>>>
89247>>>        End
89247>>>>
89247>>>        
89247>>>        // This is when checking for other field types than dates...
89247>>>//        If (bCompareDate_DataTime = False and iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
89247>>>            Move (iFromType = iToType) to bIsSame
89248>>>            If (bIsSame = False) Begin
89250>>>                Function_Return False
89251>>>            End
89251>>>>
89251>>>//        End
89251>>>        
89251>>>        // If the field is of Date type (any of them) we don't compare length & precision.
89251>>>        If (iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
89253>>>            Move (aColumnsFrom.iLength = aColumnsTo.iLength) to bIsSame
89254>>>            If (bIsSame = False) Begin
89256>>>                Function_Return False
89257>>>            End                                               
89257>>>>
89257>>>            Move (aColumnsFrom.iPrecision = aColumnsTo.iPrecision) to bIsSame
89258>>>            If (bIsSame = False) Begin
89260>>>                Function_Return False
89261>>>            End                                               
89261>>>>
89261>>>        End
89261>>>>
89261>>>        
89261>>>        Move (aColumnsFrom.iOptions = aColumnsTo.iOptions) to bIsSame
89262>>>        If (bIsSame = False) Begin
89264>>>            Function_Return False
89265>>>        End                                               
89265>>>>
89265>>>
89265>>>        Function_Return True
89266>>>    End_Function
89267>>>    
89267>>>    // Compares multiple indexes for a 'From' and a 'To' table.
89267>>>    Function UtilIndexesCompare Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
89269>>>        Boolean bIsSame bDAWSQLDriver 
89269>>>        Integer iCount iSize iSizeFrom iSizeTo iSegment iNumSegments iColumn
89269>>>        String sIndexNameFrom sIndexNameTo sDriverID sColumnNameFrom
89269>>>        
89269>>>        Move True to bIsSame
89270>>>        Get psDriverID to sDriverID
89271>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
89272>>>        
89272>>>        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
89273>>>        Move (SizeOfArray(aIndexesTo))   to iSizeTo  
89274>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89276>>>            Function_Return True
89277>>>        End
89277>>>>
89277>>>        If (iSizeFrom <> iSizeTo) Begin
89279>>>            Function_Return False
89280>>>        End          
89280>>>>
89280>>>        Move (iSizeFrom max iSizeTo) to iSize
89281>>>
89281>>>        Decrement iSize
89282>>>        For iCount from 0 to iSize 
89288>>>>
89288>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89289>>>            Get UtilIndexCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
89290>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89291>>>            If (bIsSame = False) Begin
89293>>>                Function_Return False
89294>>>            End
89294>>>>
89294>>>        Loop
89295>>>>
89295>>>        
89295>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89296>>>        Function_Return bIsSame
89297>>>    End_Function
89298>>>    
89298>>>    // Compares a single index for a 'From' and a 'To' table.
89298>>>    Function UtilIndexCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
89300>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
89300>>>        String sDriverID  
89300>>>        Integer iSegment
89300>>>        
89300>>>        Move True to bIsSame
89301>>>        Get psDriverID to sDriverID
89302>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
89303>>>        Get IsSQLDriver sDriverID to bIsSqlTable
89304>>>        If (bIsSqlTable = True) Begin
89306>>>            Get UtilTableIsSQL hTable to bIsSqlTable
89307>>>        End
89307>>>>
89307>>>        
89307>>>        Move True to bIsSame
89308>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
89310>>>            // Don't think we should do this. Or should we?
89310>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
89310>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89311>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
89312>>>            If (bIsSame = False) Begin
89314>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89315>>>                Function_Return False
89316>>>            End
89316>>>>
89316>>>        End
89316>>>>
89316>>>        
89316>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89317>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
89318>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89319>>>        If (bIsSame = False) Begin
89321>>>            Function_Return False
89322>>>        End                      
89322>>>>
89322>>>        
89322>>>        Get UtilIndexSegmentsCompare aIndexFrom aIndexTo bCompareIndexUppercase bCompareIndexAscending to iSegment
89323>>>        If (iSegment = -1) Begin
89325>>>            Move True to bIsSame
89326>>>        End  
89326>>>>
89326>>>        Else Begin                                                         
89327>>>            Move True to aIndexTo.bShouldChange
89328>>>            Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
89329>>>        End
89329>>>>
89329>>>        
89329>>>        Function_Return (bIsSame = True)
89330>>>    End_Function
89331>>>    
89331>>>    // Compares each segment for the passed index.
89331>>>    // Returns -1 if same; else returns the index segment that differs.
89331>>>    Function UtilIndexSegmentsCompare tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
89333>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment                                                
89333>>>        Boolean bIsSame
89333>>>        
89333>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89334>>>        Move (SizeOfArray(aIndexFrom.IndexSegmentArray)) to iNumSegmentsFrom
89335>>>        Move (SizeOfArray(aIndexTo.IndexSegmentArray))   to iNumSegmentsTo
89336>>>        Move (iNumSegmentsFrom max iNumSegmentsTo)       to iNumSegments
89337>>>        
89337>>>        Decrement iNumSegments
89338>>>        for iSegment from 0 to iNumSegments  
89344>>>>
89344>>>            Move False to bIsSame
89345>>>            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
89347>>>                Get UtilIndexSegmentCompare aIndexFrom.IndexSegmentArray[iSegment] aIndexTo.IndexSegmentArray[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
89348>>>            End
89348>>>>
89348>>>            If (bIsSame = False) Begin
89350>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89351>>>                Move True to aIndexTo.bShouldChange
89352>>>                Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
89353>>>                Function_Return iSegment
89354>>>            End
89354>>>>
89354>>>        Loop             
89355>>>>
89355>>>        
89355>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89356>>>        Function_Return -1 // This means bIsSame = True
89357>>>    End_Function
89358>>>    
89358>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
89360>>>        Integer iNumSegments iSegment                                                
89360>>>        Boolean bIsSame
89360>>>
89360>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
89361>>>        If (bIsSame = False) Begin
89363>>>            Function_Return False
89364>>>        End
89364>>>>
89364>>>        If (bCompareIndexUppercase = True) Begin
89366>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
89367>>>            If (bIsSame = False) Begin
89369>>>                Function_Return False
89370>>>            End
89370>>>>
89370>>>        End
89370>>>>
89370>>>        If (bCompareIndexAscending = True) Begin
89372>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
89373>>>            If (bIsSame = False) Begin
89375>>>                Function_Return False
89376>>>            End
89376>>>>
89376>>>        End
89376>>>>
89376>>>        
89376>>>        Function_Return True
89377>>>    End_Function
89378>>>    
89378>>>    // This is the same as the UtilIndexCompare function _except_ it only checks if the Index type and number are equal or not.
89378>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
89380>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
89380>>>        Integer iCount iSize iSegment iNumSegments iIndexSegment
89380>>>        String sDriverID 
89380>>>        
89380>>>        Move True to bIsSame
89381>>>        Get psDriverID to sDriverID
89382>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
89383>>>        Get IsSQLDriver sDriverID to bIsSqlTable
89384>>>        If (bIsSqlTable = True) Begin
89386>>>            Get UtilTableIsSQL hTable to bIsSqlTable
89387>>>        End
89387>>>>
89387>>>        
89387>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89388>>>        Move True to bIsSame
89389>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
89391>>>            // Don't think we should do this. Or should we?
89391>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
89391>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
89392>>>            If (bIsSame = False) Begin
89394>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89395>>>                Function_Return False
89396>>>            End
89396>>>>
89396>>>        End
89396>>>>
89396>>>        
89396>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
89397>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89398>>>        If (bIsSame = False) Begin
89400>>>            Function_Return False
89401>>>        End                      
89401>>>>
89401>>>        
89401>>>        Function_Return bIsSame
89402>>>    End_Function
89403>>>    
89403>>>    // Compares multiple relationships for a 'From' and a 'To' table
89403>>>    Function UtilRelationsCompare Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
89405>>>        Boolean bIsSame
89405>>>        Integer iSize iCount
89405>>>        
89405>>>        Move True to bIsSame
89406>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
89407>>>        Decrement iSize
89408>>>        For iCount from 0 to iSize   
89414>>>>
89414>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89415>>>            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
89416>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89417>>>            If (bIsSame = False) Begin
89419>>>                Function_Return False
89420>>>            End
89420>>>>
89420>>>        Loop
89421>>>>
89421>>>        
89421>>>        Function_Return bIsSame
89422>>>    End_Function
89423>>>
89423>>>    // Compares a single relationship for a 'From' and a 'To' table
89423>>>    Function UtilRelationCompare Handle hTable tAPIRelation aRelationsFrom tAPIRelation aRelationsTo Returns Boolean
89425>>>        Boolean bIsSame
89425>>>        Integer iSize iCount
89425>>>        
89425>>>        Move True to bIsSame
89426>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89427>>>        Move (aRelationsFrom.hTableFrom = aRelationsTo.hTableFrom) to bIsSame
89428>>>        If (bIsSame = False) Begin
89430>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89431>>>            Function_Return False
89432>>>        End
89432>>>>
89432>>>        Move (aRelationsFrom.hTableTo = aRelationsTo.hTableTo) to bIsSame
89433>>>        If (bIsSame = False) Begin
89435>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89436>>>            Function_Return False
89437>>>        End
89437>>>>
89437>>>        Move (aRelationsFrom.iColumnFrom = aRelationsTo.iColumnFrom) to bIsSame
89438>>>        If (bIsSame = False) Begin
89440>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89441>>>            Function_Return False
89442>>>        End
89442>>>>
89442>>>        
89442>>>        Move (aRelationsFrom.iColumnTo = aRelationsTo.iColumnTo) to bIsSame
89443>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89444>>>
89444>>>        Function_Return bIsSame
89445>>>    End_Function
89446>>>
89446>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
89446>>>    // already exists. Instead it checks if the table needs to be updated with any of the struct arrays,
89446>>>    // for fields, indexes or relations.
89446>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
89448>>>        Boolean bIsSame bOK
89448>>>        Integer iSize iCount 
89448>>>        
89448>>>        Move True to bOK
89449>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
89450>>>        Decrement iSize
89451>>>        for iCount from 0 to iSize
89457>>>>
89457>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89458>>>            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
89459>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89460>>>            If (bIsSame = False) Begin
89462>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89463>>>                Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo to bOK
89464>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89465>>>            End
89465>>>>
89465>>>        Loop
89466>>>>
89466>>>        
89466>>>        Function_Return bOK
89467>>>    End_Function
89468>>>    
89468>>>    Function UtilIndexesUpdate Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
89470>>>        Boolean bIsSame bOK
89470>>>        Integer iSizeFrom iSizeTo iCount iIndexSegment                   
89470>>>        String sIndexFields
89470>>>        
89470>>>        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
89471>>>        Move (SizeOfArray(aIndexesTo))   to iSizeTo 
89472>>>        Decrement iSizeTo
89473>>>        Decrement iSizeFrom
89474>>>        for iCount from 0 to iSizeFrom
89480>>>>
89480>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89481>>>            Get UtilIndexTypeNumberCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] to bIsSame
89482>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89483>>>            If (bIsSame = False and iSizeTo <> 0 and iCount <= iSizeTo) Begin
89485>>>//                Get ApiIndexRemove hTable aIndexesTo[iCount].iIndexNumber to bOK 
89485>>>                Get APIIndexCreateByFieldNames hTable iCount aIndexesFrom[iCount].IndexSegmentArray to bOK
89486>>>            End
89486>>>>
89486>>>            If (bIsSame = True) Begin
89488>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT 
89489>>>                Move 0 to iIndexSegment
89490>>>                Get UtilIndexSegmentsCompare aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to iIndexSegment
89491>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89492>>>                If (iIndexSegment <> -1) Begin
89494>>>                    Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount].iIndexNumber aIndexesFrom[iCount].IndexSegmentArray to bOK
89495>>>                End
89495>>>>
89495>>>            End
89495>>>>
89495>>>        Loop
89496>>>>
89496>>>    
89496>>>        Function_Return bOK
89497>>>    End_Function  
89498>>>    
89498>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
89498>>>//        Boolean bEqual bPrimaryKey bSqlDriver bDawSqlDriver bIsOpen
89498>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
89498>>>//        String sFieldName sDriverID
89498>>>//        
89498>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89498>>>//        If (bIsOpen = False) Begin
89498>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89498>>>//            Open hTable
89498>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89498>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89498>>>//            If (bIsOpen = False) Begin
89498>>>//                Function_Return False
89498>>>//            End
89498>>>//        End
89498>>>//
89498>>>//        Move True to bEqual
89498>>>//        Get psDriverID to sDriverID
89498>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
89498>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
89498>>>//        Move (SizeOfArray(aColumns)) to iSize
89498>>>//        Decrement iSize   
89498>>>//        
89498>>>//        For iCount from 0 to iSize
89498>>>//            Move 0 to iOptions    
89498>>>//            Move False to bPrimaryKey
89498>>>//            Move aColumns[iCount].sFieldName to sFieldName               
89498>>>//            
89498>>>//            // We need to use the column name - not the column integer as
89498>>>//            // the order does not need to be the same, and the logic should still work.
89498>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
89498>>>//            If (iColumn > 0) Begin
89498>>>//                If (bDawSqlDriver = True) Begin
89498>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89498>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
89498>>>//                    If (iType <> aColumns[iCount].iType) Begin
89498>>>//                        Move False to bEqual
89498>>>//                    End
89498>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bPrimaryKey
89498>>>//                    If (bPrimaryKey = True) Begin
89498>>>//                        Move C_tAPIColumn_Identity to iOptions
89498>>>//                    End
89498>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
89498>>>//                        Move False to bEqual
89498>>>//                    End
89498>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89498>>>//                End
89498>>>//                Else Begin
89498>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
89498>>>//                    If (iType <> aColumns[iCount].iType) Begin
89498>>>//                        Move False to bEqual
89498>>>//                    End
89498>>>//                End
89498>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
89498>>>//                If (iLength <> aColumns[iCount].iLength) Begin
89498>>>//                    Move False to bEqual
89498>>>//                End
89498>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
89498>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
89498>>>//                    Move False to bEqual
89498>>>//                End
89498>>>//                If (bEqual = False) Begin
89498>>>//                    Function_Return False
89498>>>//                End
89498>>>//            End
89498>>>//                    
89498>>>//            Else Begin
89498>>>//                Function_Return False
89498>>>//            End
89498>>>//        Loop
89498>>>//        
89498>>>//        Function_Return bEqual
89498>>>//    End_Function  
89498>>>    
89498>>>    // To fill a complete Table structure (tAPITable) with data.
89498>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89498>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89498>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89498>>>    Function UtilTableStructFill Boolean bStatusPanel Boolean bFromTables Returns tAPITable[]
89500>>>        tAPIColumn[]    aApiColumns   
89500>>>        tAPIColumn[]    aApiColumns   
89501>>>        tAPIIndex[]     aApiIndexes   
89501>>>        tAPIIndex[]     aApiIndexes   
89502>>>        tAPIRelation[]  aApiRelations 
89502>>>        tAPIRelation[]  aApiRelations 
89503>>>        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
89503>>>        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
89505>>>        Handle hTable
89505>>>        Integer iCount iPos 
89505>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
89505>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID
89505>>>        
89505>>>        Move 0 to hTable
89506>>>        Move 0 to iCount
89507>>>        Repeat
89507>>>>
89507>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89510>>>            If (hTable > 0 and hTable <> 50) Begin
89512>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable    to sRootName   
89515>>>                Get _TableNameOnly sRootName                 to sTableName
89516>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName   
89519>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
89522>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bIsOpen
89523>>>                Get_Attribute DF_FILE_DRIVER       of hTable to sDriverID
89526>>>                If (bStatusPanel = True) Begin
89528>>>                    If (bFromTables = True) Begin
89530>>>                        Set Message_Text of ghoStatusPanel to "Reading 'From' Table Structure:"
89531>>>                    End 
89531>>>>
89531>>>                    Else Begin
89532>>>                        Set Message_Text of ghoStatusPanel to "Reading 'To' Table Structure:"
89533>>>                    End
89533>>>>
89533>>>                    Set Action_Text of ghoStatusPanel  to (sTableName * "Number:" * String(hTable))
89534>>>                End
89534>>>>
89534>>>                
89534>>>                Get UtilColumnsStructFill  hTable to aApiColumns
89535>>>                Get UtilIndexesStructFill  hTable to aApiIndexes
89536>>>                Get UtilRelationStructFill hTable to aApiRelations
89537>>>                Get UtilTableIsAlias       hTable to bIsAlias  
89538>>>                Get UtilTableIsSQL         hTable to bIsSQL
89539>>>                
89539>>>                Move hTable                                  to aApiTables[iCount].ApiTableInfo.iTableNumber
89540>>>                Move sRootName                               to aApiTables[iCount].ApiTableInfo.sRootName
89541>>>                Move sLogicalName                            to aApiTables[iCount].ApiTableInfo.sLogicalName
89542>>>                Move sDisplayName                            to aApiTables[iCount].ApiTableInfo.sDisplayName
89543>>>                Move sDriverID                               to aApiTables[iCount].ApiTableInfo.sDriverID
89544>>>                Move bIsAlias                                to aApiTables[iCount].ApiTableInfo.bIsAlias
89545>>>                Move bIsSQL                                  to aApiTables[iCount].ApiTableInfo.bIsSQL
89546>>>                Move aApiColumns                             to aApiTables[iCount].aApiColumns
89547>>>                Move aApiIndexes                             to aApiTables[iCount].aApiIndexes
89548>>>                Move aApiRelations                           to aApiTables[iCount].aApiRelations
89549>>>                Increment iCount
89550>>>            End     
89550>>>>
89550>>>            
89550>>>            If (bStatusPanel = True) Begin
89552>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89553>>>                If (bUserCancel = True) Begin
89555>>>                    Send Stop_StatusPanel of ghoStatusPanel
89556>>>                    Function_Return aApiTablesEmpty
89557>>>                End
89557>>>>
89557>>>            End
89557>>>>
89557>>>
89557>>>        Until (hTable = 0)    
89559>>>    
89559>>>        Function_Return aApiTables    
89560>>>    End_Function
89561>>>
89561>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
89563>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
89563>>>        Boolean bPrimaryKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable
89563>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89563>>>        tAPIColumn[] APIColumns APIColumnsEmpty
89565>>>        String sDriverID sFieldName sRootName sLogicalName sValue
89565>>>        
89565>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
89566>>>        Get piDbType to iDbType
89567>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89570>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89573>>>        Open hTable
89575>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89578>>>        If (bIsOpen = False) Begin
89580>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89581>>>            Open hTable
89583>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89584>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89587>>>            If (bIsOpen = False) Begin
89589>>>                Set Error_Report_Mode to DUF_ERROR_REPORT 
89590>>>                Function_Return APIColumnsEmpty
89591>>>            End
89591>>>>
89591>>>        End
89591>>>>
89591>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89594>>>        Get IsSQLDriver    sDriverID to bSqlDriver
89595>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver       
89596>>>        
89596>>>        If (sDriverID <> DATAFLEX_ID) Begin
89598>>>            Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
89599>>>            If (bIsSqlTable = True) Begin
89601>>>                Get UtilTableExists hTable to bExists
89602>>>                If (bExists = False) Begin
89604>>>                    Function_Return APIColumnsEmpty
89605>>>                End
89605>>>>
89605>>>            End                                    
89605>>>>
89605>>>        End
89605>>>>
89605>>>        
89605>>>        Move 0 to iCount
89606>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89609>>>        For iColumn from 1 to iNumColumns
89615>>>>
89615>>>            Move 0 to iOptions       
89616>>>            Move False to bPrimaryKey         
89617>>>            Move False to Err
89618>>>            Move 0     to LastErr     
89619>>>            If (bDawSqlDriver = True) Begin
89621>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  
89622>>>                If (bIsSqlTable = True) Begin
89624>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
89627>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
89630>>>                End
89630>>>>
89630>>>                Else Begin
89631>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType 
89634>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
89635>>>                End
89635>>>>
89635>>>                
89635>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
89635>>>//                Get_Attribute DF_Field_Number of hTable iColumn to i
89635>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
89638>>>                Move (iCheckFieldNumber >= 0) to bExists
89639>>>//                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists           
89639>>>                If (bExists = False) Begin
89641>>>                    Move 0 to APIColumns[iCount].iType
89642>>>                End
89642>>>>
89642>>>                If (bExists = True) Begin
89644>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bPrimaryKey                
89647>>>                End
89647>>>>
89647>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89648>>>                If (bPrimaryKey = True) Begin
89650>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
89651>>>                End
89651>>>>
89651>>>            End
89651>>>>
89651>>>            Else Begin
89652>>>                Move False to Err
89653>>>                Move 0     to LastErr
89654>>>                If (bIsSqlTable = True) Begin
89656>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
89659>>>                End
89659>>>>
89659>>>                Else Begin
89660>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
89663>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
89664>>>                End
89664>>>>
89664>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
89664>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists           
89665>>>                If (bExists = False) Begin
89667>>>                    Move 0 to APIColumns[iCount].iType
89668>>>                End
89668>>>>
89668>>>            End
89668>>>>
89668>>>            
89668>>>            If (bExists = True) Begin                                                          
89670>>>                Move iColumn to APIColumns[iCount].iFieldNumber
89671>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
89674>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems. 
89674>>>//                If (bIsSqlTable = True) Begin
89674>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
89674>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
89674>>>//                End
89674>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
89677>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
89680>>>                
89680>>>                // If the length was zero we might have an Overlap(!) field.
89680>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
89680>>>                If (APIColumns[iCount].iLength = 0) Begin
89682>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
89685>>>                    If (iType = DF_OVERLAP) Begin
89687>>>                        Move 0 to APIColumns[iCount].iFieldNumber
89688>>>                        Move 0 to APIColumns[iCount].iLength
89689>>>                        Move 0 to APIColumns[iCount].iOptions
89690>>>                        Move 0 to APIColumns[iCount].iPrecision
89691>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
89692>>>                        Move "" to APIColumns[iCount].sFieldName
89693>>>                        Decrement iCount
89694>>>                    End                                                          
89694>>>>
89694>>>                End
89694>>>>
89694>>>            End
89694>>>>
89694>>>            Increment iCount
89695>>>        Loop
89696>>>>
89696>>>        
89696>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89697>>>        Function_Return APIColumns                          
89698>>>    End_Function        
89699>>>    
89699>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
89701>>>        tAPIIndex[] APIIndexes
89701>>>        tAPIIndex[] APIIndexes
89702>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn iIndexType iCase
89702>>>        String sDriverID
89702>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
89702>>>        
89702>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89703>>>        Get psDriverID to sDriverID
89704>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver 
89705>>>        Get UtilTableIsSQL hTable to bIsSQLTable
89706>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89709>>>        If (bIsOpen = False) Begin
89711>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89712>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89713>>>            Open hTable
89715>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89716>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89717>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89720>>>            If (bIsOpen = False) Begin
89722>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89723>>>                Function_Return APIIndexes
89724>>>            End
89724>>>>
89724>>>        End
89724>>>>
89724>>>        
89724>>>        Move 0 to iCount
89725>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
89728>>>        for iIndex from 1 to iIndexes                                              
89734>>>>
89734>>>            // This is a test that the index exists as there might be "holes" aka the index
89734>>>            // numbers doesn not need to be consequitive:
89734>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89737>>>            If (iNumSegments > 0) Begin
89739>>>            
89739>>>                Move iIndex to APIIndexes[iCount].iIndexNumber    
89740>>>                If (bIsSQLTable = True) Begin
89742>>>                    Get_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndexes[iCount].sSQLIndexName
89745>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
89748>>>                End
89748>>>>
89748>>>    
89748>>>                Move 0 to iSegmentCount
89749>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments       
89752>>>                for iSegment from 1 to iNumSegments     
89758>>>>
89758>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
89761>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
89762>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
89765>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
89768>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
89771>>>                    Increment iSegmentCount
89772>>>                Loop                                                                                       
89773>>>>
89773>>>            End
89773>>>>
89773>>>    
89773>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89774>>>            Increment iCount
89775>>>        Loop                              
89776>>>>
89776>>>        
89776>>>        Function_Return APIIndexes
89777>>>    End_Function
89778>>>    
89778>>>    Function UtilRelationStructFill Handle hTable Returns tAPIRelation[]
89780>>>        tAPIRelation[] APIRelations
89780>>>        tAPIRelation[] APIRelations
89781>>>        Integer iColumn iNumColumns iCount
89781>>>        Handle hParent 
89781>>>        Boolean bIsOpen
89781>>>        
89781>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89782>>>        Move 0 to iCount
89783>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89786>>>        If (bIsOpen = False) Begin
89788>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89789>>>            Open hTable
89791>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89792>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89795>>>            If (bIsOpen = False) Begin
89797>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
89798>>>                Function_Return APIRelations
89799>>>            End
89799>>>>
89799>>>        End
89799>>>>
89799>>>
89799>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89802>>>        For iColumn from 1 to iNumColumns
89808>>>>
89808>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
89811>>>            If (hParent <> 0) Begin
89813>>>                Move (String(hParent))   to APIRelations[iCount].hTableFrom
89814>>>                Move (String(iColumn))   to APIRelations[iCount].iColumnFrom
89815>>>                Move (String(hTable))    to APIRelations[iCount].hTableTo
89816>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to APIRelations[iCount].iColumnTo
89819>>>                Increment iCount
89820>>>            End         
89820>>>>
89820>>>        Loop                                                    
89821>>>>
89821>>>        
89821>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89822>>>        Function_Return APIRelations
89823>>>    End_Function
89824>>>    
89824>>>    // Checks if a field name exists in a table definition
89824>>>    // Returns True if it does
89824>>>    // Sample:
89824>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
89824>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
89826>>>        Integer iNumColumns iColumn
89826>>>        String sColumn
89826>>>        Boolean bExists bOK bOpen
89826>>>
89826>>>        Get AutoConnectionIDLogin to bOK
89827>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89828>>>        Open hTable
89830>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89831>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89834>>>        If (bOpen = False) Begin
89836>>>            Function_Return False
89837>>>        End
89837>>>>
89837>>>
89837>>>        Move False to bExists
89838>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89841>>>        for iColumn from 1 to iNumColumns
89847>>>>
89847>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
89850>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
89852>>>                Move iNumColumns to iColumn
89853>>>                Move True to bExists
89854>>>            End
89854>>>>
89854>>>        Loop
89855>>>>
89855>>>        Close hTable
89856>>>
89856>>>        Function_Return bExists
89857>>>    End_Function
89858>>>    
89858>>>    // Returns the field/column number for the passed FieldName as an integer.
89858>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
89860>>>        Integer iNumColumns iColumn iRetval
89860>>>        String sColumn
89860>>>        Boolean bExists bOK bOpen
89860>>>
89860>>>        Get AutoConnectionIDLogin to bOK
89861>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89862>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89863>>>        Open hTable
89865>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89866>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89869>>>        If (bOpen = False) Begin
89871>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
89872>>>            Function_Return False
89873>>>        End
89873>>>>
89873>>>        
89873>>>        Move 0 to iColumn                  
89874>>>        Move 0 to iRetval
89875>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89878>>>        for iColumn from 1 to iNumColumns
89884>>>>
89884>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
89887>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
89889>>>                Move iColumn to iRetval
89890>>>                Move iNumColumns to iColumn
89891>>>            End
89891>>>>
89891>>>        Loop
89892>>>>
89892>>>        Close hTable
89893>>>
89893>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89894>>>        Function_Return iRetval
89895>>>    End_Function
89896>>>
89896>>>    // Checks if the current psConnectionID is logged in; if not
89896>>>    // attempts to make a login.
89896>>>    // Because
89896>>>    // Returns True if already logged in or the new login was successful.
89896>>>    // *** Utility Messages ***
89896>>>    //
89896>>>    //
89896>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
89896>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
89896>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
89896>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
89898>>>        Boolean bError bFound
89898>>>
89898>>>        Move False to Err
89899>>>        Open CodeMast
89901>>>        Open CodeType
89903>>>
89903>>>        If (bCodeType = True) Begin
89905>>>            Clear CodeType
89906>>>            Move sTypeValue to CODETYPE.Type
89907>>>            Find eq CODETYPE.Type
89908>>>>
89908>>>            Move (Found = True) to bFound
89909>>>            If (bFound = True) Begin
89911>>>                Reread CodeType
89915>>>            End
89915>>>>
89915>>>            If (bFound = False) Begin
89917>>>                Clear CodeType
89918>>>            End
89918>>>>
89918>>>                Move sTypeValue to CODETYPE.Type
89919>>>                Move sValue2    to CODETYPE.Description
89920>>>                Move sValue3    to CODETYPE.Comment
89921>>>                SaveRecord CODETYPE
89922>>>            If (bFound = True) Begin
89924>>>                Unlock
89925>>>>
89925>>>            End
89925>>>>
89925>>>        End
89925>>>>
89925>>>
89925>>>        If (bCodeType = False) Begin
89927>>>            Clear CODEMAST
89928>>>            Move sTypeValue to CODEMAST.Type
89929>>>            Move sValue2    to CODEMAST.Code
89930>>>            Find eq CODEMAST.Code
89931>>>>
89931>>>            Move (Found = True) to bFound
89932>>>            If (bFound = True) Begin
89934>>>                Reread CODEMAST
89938>>>            End
89938>>>>
89938>>>            If (bFound = False) Begin
89940>>>                Clear CODEMAST
89941>>>            End
89941>>>>
89941>>>                Move sTypeValue to CODEMAST.Type
89942>>>                Move sValue2    to CODEMAST.Code
89943>>>                Move sValue3    to CODEMAST.Description
89944>>>                SaveRecord CODEMAST
89945>>>            If (bFound = True) Begin
89947>>>            Unlock
89948>>>>
89948>>>            End
89948>>>>
89948>>>        End
89948>>>>
89948>>>
89948>>>        Close CodeMast
89949>>>        Close CodeType
89950>>>
89950>>>        Function_Return (Err = False)
89951>>>    End_Function
89952>>>
89952>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
89952>>>    // CodeType and then spins through all CodeMast records to change all related records.
89952>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
89954>>>        Boolean bFound
89954>>>
89954>>>        Move False to Err
89955>>>        Open CodeMast
89957>>>        Open CodeType
89959>>>
89959>>>        Clear CodeType
89960>>>        Move sFromValue to CODETYPE.Type
89961>>>        Find eq CODETYPE.Type
89962>>>>
89962>>>        If (Found = True) Begin
89964>>>            Reread CODETYPE
89968>>>                Move sToValue to CODETYPE.Type
89969>>>                SaveRecord CODETYPE
89970>>>            Unlock
89971>>>>
89971>>>        End
89971>>>>
89971>>>
89971>>>        Clear CODEMAST
89972>>>        Find gt CODEMAST by Recnum
89973>>>>
89973>>>        While (Found = True)
89977>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
89978>>>            If (bFound = True) Begin
89980>>>                Reread CODEMAST
89984>>>                    Move sToValue to CODEMAST.Type
89985>>>                    SaveRecord CODEMAST
89986>>>                Unlock
89987>>>>
89987>>>            End
89987>>>>
89987>>>            Find gt CODEMAST by Recnum
89988>>>>
89988>>>        Loop
89989>>>>
89989>>>
89989>>>        Close CodeMast
89990>>>        Close CodeType
89991>>>
89991>>>        Function_Return (Err = False)
89992>>>    End_Function
89993>>>
89993>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
89993>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
89995>>>        Boolean bError bFound
89995>>>
89995>>>        Move False to Err
89996>>>        Open CodeMast
89998>>>
89998>>>        Clear CODEMAST
89999>>>        Move sTypeValue to CODEMAST.Type
90000>>>        Move sValue2    to CODEMAST.Code
90001>>>        Find eq CODEMAST.Code
90002>>>>
90002>>>        Move (Found = True) to bFound
90003>>>        If (bFound = True) Begin
90005>>>            Delete CODEMAST
90006>>>        End
90006>>>>
90006>>>
90006>>>        Close CodeMast
90007>>>
90007>>>        Function_Return (Err = False)
90008>>>    End_Function
90009>>>
90009>>>    // Note:
90009>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90009>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90009>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90009>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90009>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90009>>>    Function UtilTableHandleToString Handle hTable Returns String
90011>>>        String sTableName
90011>>>        Boolean bOpen bExists bRecnum bOK
90011>>>
90011>>>        Get UtilTableNumberIsInUse hTable to bExists
90012>>>        If (bExists = False) Begin
90014>>>            Function_Return ""
90015>>>        End
90015>>>>
90015>>>
90015>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90016>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90019>>>        If (bOpen = False) Begin
90021>>>            Get AutoConnectionIDLogin to bOK
90022>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90023>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90024>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90025>>>            Open hTable
90027>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90028>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90029>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90030>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90033>>>        End
90033>>>>
90033>>>        If (bOpen = True) Begin
90035>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90036>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90039>>>            // If blank it is an embedded table:
90039>>>            If (sTableName = "") Begin
90041>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90044>>>                Move 0 to LastErr
90045>>>                Move False to Err
90046>>>            End
90046>>>>
90046>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90047>>>        End
90047>>>>
90047>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90048>>>
90048>>>        Function_Return sTableName
90049>>>    End_Function
90050>>>
90050>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90050>>>    // Returns 0 if unsuccessful.
90050>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90050>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90052>>>        String sValue sPrefixTableName sDriverID
90052>>>        Handle hTable hRetval
90052>>>
90052>>>        Get psDriverID to sDriverID
90053>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90055>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90056>>>        End
90056>>>>
90056>>>        Move 0 to hTable
90057>>>        Move 0 to hRetval
90058>>>        Repeat
90058>>>>
90058>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90061>>>            If (hTable <> 0) Begin
90063>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90066>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90068>>>                    Move hTable to hRetval
90069>>>                    Move 0 to hTable
90070>>>                End
90070>>>>
90070>>>            End
90070>>>>
90070>>>        Until (hTable = 0)
90072>>>
90072>>>        Function_Return hRetval
90073>>>    End_Function
90074>>>
90074>>>    // Check if the file exists in the Data folder,
90074>>>    // else creates it from memory as it has been compiled into the program as a resource:
90074>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
90076>>>        String sPath sDataPath
90076>>>        Boolean bExists
90076>>>
90076>>>        Get psDataPathFirstPart to sPath
90077>>>        Move (sPath + sFileName) to sFileName
90078>>>        Get vFilePathExists sFileName to bExists
90079>>>
90079>>>        If (bExists = False) Begin
90081>>>            // Read from memory & create file on disk.
90081>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
90082>>>            Get vFilePathExists sFileName to bExists
90083>>>        End
90083>>>>
90083>>>        Function_Return bExists
90084>>>    End_Function
90085>>>
90085>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90085>>>    // The reciprocal function of UtilColumnTypeToInteger.
90085>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90087>>>        tColumnType RetvalType
90087>>>        tColumnType RetvalType
90087>>>
90087>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90088>>>        Function_Return RetvalType.iType
90089>>>    End_Function
90090>>>
90090>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90090>>>    // The reciprocal function of UtilColumnTypeToString.
90090>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90092>>>        tColumnType RetvalType
90092>>>        tColumnType RetvalType
90092>>>        String sValue
90092>>>
90092>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90093>>>        Function_Return RetvalType.sType
90094>>>    End_Function
90095>>>
90095>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
90097>>>        tColumnType RetvalType 
90097>>>        tColumnType RetvalType 
90097>>>        Integer iRetval
90097>>>        
90097>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90098>>>        Move RetvalType.iDataFlexType to iRetval
90099>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
90101>>>            If (iLength <= 255) Begin
90103>>>                Move DF_ASCII to iRetval
90104>>>            End
90104>>>>
90104>>>        End                             
90104>>>>
90104>>>        Function_Return iRetval
90105>>>    End_Function
90106>>>
90106>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90108>>>        tColumnType RetvalType
90108>>>        tColumnType RetvalType
90108>>>        String sValue
90108>>>
90108>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90109>>>        Function_Return RetvalType.sPrecision
90110>>>    End_Function
90111>>>
90111>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90113>>>        tColumnType RetvalType
90113>>>        tColumnType RetvalType
90113>>>        String sValue
90113>>>
90113>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90114>>>        Function_Return RetvalType.bFixedSize
90115>>>    End_Function
90116>>>
90116>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90118>>>        tColumnType RetvalType
90118>>>        tColumnType RetvalType
90118>>>        String sValue
90118>>>        Integer iRetval iPos
90118>>>
90118>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90119>>>        Move RetvalType.sPrecision to sValue
90120>>>        Move (Pos(".", sValue)) to iPos
90121>>>        If (iPos <> 0) Begin
90123>>>            Move (Left(sValue, (iPos -1))) to iRetval
90124>>>        End
90124>>>>
90124>>>        Else Begin
90125>>>            Move sValue to iRetval
90126>>>        End
90126>>>>
90126>>>        Function_Return iRetval
90127>>>    End_Function
90128>>>
90128>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90130>>>        tColumnType RetvalType
90130>>>        tColumnType RetvalType
90130>>>        String sValue
90130>>>        Integer iRetval iPos
90130>>>
90130>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90131>>>        Move RetvalType.sPrecision to sValue
90132>>>        Move (Pos(".", sValue)) to iPos
90133>>>        If (iPos = 0) Begin
90135>>>            Function_Return 0
90136>>>        End
90136>>>>
90136>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90137>>>
90137>>>        Function_Return iRetval
90138>>>    End_Function
90139>>>
90139>>>    // The default value used for a datatype as specified in the driver int file.
90139>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
90141>>>        String sRetval sServer
90141>>>        tColumnType RetvalType
90141>>>        tColumnType RetvalType
90141>>>        Integer iDriver iDataFlexType
90141>>>        Handle hDatabase
90141>>>
90141>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90142>>>        Move RetvalType.iDataFlexType to iDataFlexType
90143>>>        Get DriverIndex sDriverID to iDriver
90144>>>        Get psServer to sServer
90145>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
90146>>>        If (hDatabase = 0) Begin
90148>>>            Function_Return ""
90149>>>        End
90149>>>>
90149>>>
90149>>>        Case Begin
90149>>>            Case (iDataFlexType = DF_ASCII)
90151>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
90154>>>                Case Break
90155>>>            Case (iDataFlexType = DF_BCD)
90158>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
90161>>>                Case Break
90162>>>            Case (iDataFlexType = DF_BINARY)
90165>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
90168>>>                Case Break
90169>>>            Case (iDataFlexType = DF_DATE)
90172>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
90175>>>                Case Break
90176>>>            Case (iDataFlexType = DF_DATETIME)
90179>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
90182>>>                Case Break
90183>>>            Case (iDataFlexType = DF_TEXT)
90186>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
90189>>>                Case Break
90190>>>            Case Else
90190>>>                Move "" to sRetval
90191>>>        Case End
90191>>>
90191>>>        Function_Return sRetval
90192>>>    End_Function
90193>>>
90193>>>    // Returns a struct array with the default column types for the SQL back-end and how they
90193>>>    // are mapped to the standard DataFlex data types.
90193>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
90193>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
90195>>>        tColumnType[] ColumnTypeArray EmptyArray
90195>>>        tColumnType[] ColumnTypeArray EmptyArray
90197>>>        String sDataType
90197>>>        Integer iDataType iDriverID iCount  
90197>>>        Boolean bSQLDriver
90197>>>
90197>>>        Move 0 to iCount
90198>>>        Get DriverIndex sDriverID to iDriverID
90199>>>        Get IsSQLDriver sDriverID to bSQLDriver
90200>>>        If (bSQLDriver = False) Begin
90202>>>            Function_Return EmptyArray
90203>>>        End
90203>>>>
90203>>>
90203>>>        // DF_ASCII
90203>>>        If (sDriverID = ODBC_DRV_ID) Begin
90205>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
90208>>>        End
90208>>>>
90208>>>        Else Begin
90209>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
90212>>>        End
90212>>>>
90212>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90213>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
90214>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
90215>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90216>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90217>>>        Increment iCount
90218>>>
90218>>>        // DF_BINARY
90218>>>        If (sDriverID = ODBC_DRV_ID) Begin
90220>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
90223>>>        End
90223>>>>
90223>>>        Else Begin
90224>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
90227>>>        End
90227>>>>
90227>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90228>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
90229>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
90230>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90231>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90232>>>        Increment iCount
90233>>>
90233>>>        // DF_DATE
90233>>>        If (sDriverID = ODBC_DRV_ID) Begin
90235>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
90238>>>        End
90238>>>>
90238>>>        Else Begin
90239>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
90242>>>        End
90242>>>>
90242>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90243>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
90244>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
90245>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90246>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90247>>>        Increment iCount
90248>>>
90248>>>        // DF_DATETIME
90248>>>        If (sDriverID = ODBC_DRV_ID) Begin
90250>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
90253>>>        End
90253>>>>
90253>>>        Else Begin
90254>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
90257>>>        End
90257>>>>
90257>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90258>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
90259>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
90260>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90261>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90262>>>        Increment iCount
90263>>>
90263>>>        // DF_NUMERIC
90263>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
90263>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
90263>>>        // we make them here all "Numeric"... 
90263>>>        Case Begin
90263>>>            Case (sDriverID = MSSQLDRV_ID)
90265>>>                Move SQL_NUMERIC to iDataType 
90266>>>                Move "numeric"   to sDataType
90267>>>                Case Break
90268>>>            Case (sDriverID = DB2_DRV_ID)
90271>>>                Move SQL_NUMERIC to iDataType
90272>>>                Move "NUMERIC"   to sDataType
90273>>>                Case Break                   
90274>>>            Case (sDriverID = SQLFLEX)
90277>>>                Move eSQLServer_NUMERIC to iDataType
90278>>>                Move "numeric"   to sDataType
90279>>>                Case Break                   
90280>>>            Case (sDriverID = MDSMySQL)
90283>>>                Move eMySQL_DECIMAL to iDataType
90284>>>                Move "decimal"   to sDataType
90285>>>                Case Break       
90286>>>            Case (sDriverID = ORAFLEX)
90289>>>                Move eOracle_NUMBER to iDataType
90290>>>                Move "NUMBER"   to sDataType
90291>>>                Case Break       
90292>>>            Case (sDriverID = MDSPgSQL)
90295>>>                Move ePgSQL_FLOAT4 to iDataType
90296>>>                Move "decimal"   to sDataType
90297>>>                Case Break       
90298>>>            Case Else
90298>>>                Move DF_BCD      to iDataType
90299>>>                Move "Numeric"   to sDataType
90300>>>        Case End
90300>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
90301>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
90302>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90303>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90304>>>        Increment iCount
90305>>>
90305>>>        // DF_TEXT
90305>>>        If (sDriverID = ODBC_DRV_ID) Begin
90307>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
90310>>>        End
90310>>>>
90310>>>        Else Begin
90311>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
90314>>>        End
90314>>>>
90314>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
90315>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
90316>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
90317>>>        Move sDataType   to ColumnTypeArray[iCount].sType
90318>>>        Move iDataType   to ColumnTypeArray[iCount].iType
90319>>>
90319>>>        Function_Return ColumnTypeArray
90320>>>    End_Function 
90321>>>    
90321>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
90323>>>        tColumnType[] ColumnTypeArray
90323>>>        tColumnType[] ColumnTypeArray
90324>>>        tColumnType   ColumnType 
90324>>>        tColumnType   ColumnType 
90324>>>        Integer iCount iSize
90324>>>        
90324>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
90325>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
90326>>>        Decrement iSize
90327>>>        
90327>>>        for iCount from 0 to iSize
90333>>>>
90333>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
90335>>>                Move ColumnTypeArray[iCount].bFixedSize     to ColumnType.bFixedSize
90336>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
90337>>>                Move ColumnTypeArray[iCount].iType          to ColumnType.iType
90338>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
90339>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
90340>>>                Move ColumnTypeArray[iCount].sType          to ColumnType.sType
90341>>>                Move iSize to iCount
90342>>>            End
90342>>>>
90342>>>        Loop
90343>>>>
90343>>>        
90343>>>        Function_Return ColumnType
90344>>>    End_Function
90345>>>
90345>>>    // Returns a struct with the default column types for the SQL back-end and how they
90345>>>    // are mapped to a framework DataFlex data type.
90345>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
90347>>>        tColumnType ColumnType
90347>>>        tColumnType ColumnType
90347>>>        String sDataType
90347>>>        Integer iDriverID iDataType iCount
90347>>>
90347>>>        Move 0 to iCount
90348>>>        Get DriverIndex sDriverID to iDriverID
90349>>>            
90349>>>        Case Begin
90349>>>            // DF_ASCII
90349>>>            Case (iType = DF_ASCII_DUF)
90351>>>                If (sDriverID = ODBC_DRV_ID) Begin
90353>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
90356>>>                End
90356>>>>
90356>>>                Else Begin
90357>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType 
90360>>>                End
90360>>>>
90360>>>                Move DF_ASCII    to ColumnType.iDataFlexType
90361>>>                Move "ASCII"     to ColumnType.sDataFlexType
90362>>>                Move sDataType   to ColumnType.sType
90363>>>                Move DF_ASCII    to ColumnType.iType
90364>>>                Move False       to ColumnType.bFixedSize
90365>>>                Case Break
90366>>>                
90366>>>            // DF_BINARY
90366>>>            Case (iType = DF_BINARY_DUF)
90369>>>                If (sDriverID = ODBC_DRV_ID) Begin
90371>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
90374>>>                End
90374>>>>
90374>>>                Else Begin
90375>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
90378>>>                End
90378>>>>
90378>>>                Move DF_BINARY   to ColumnType.iDataFlexType
90379>>>                Move "Binary"    to ColumnType.sDataFlexType
90380>>>                Move sDataType   to ColumnType.sType
90381>>>                Move DF_BINARY   to ColumnType.iType
90382>>>                Move False       to ColumnType.bFixedSize
90383>>>                Case Break
90384>>>    
90384>>>            // DF_DATE
90384>>>            Case (iType = DF_DATE_DUF)
90387>>>                If (sDriverID = ODBC_DRV_ID) Begin
90389>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
90392>>>                End
90392>>>>
90392>>>                Else Begin
90393>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
90396>>>                End
90396>>>>
90396>>>                Move DF_DATE     to ColumnType.iDataFlexType
90397>>>                Move "Date"      to ColumnType.sDataFlexType
90398>>>                Move sDataType   to ColumnType.sType
90399>>>                Move DF_DATE     to ColumnType.iType
90400>>>                Move True        to ColumnType.bFixedSize
90401>>>                Case Break
90402>>>    
90402>>>            // DF_DATETIME       
90402>>>            Case (iType = DF_DATETIME_DUF)
90405>>>                If (sDriverID = ODBC_DRV_ID) Begin
90407>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
90410>>>                End
90410>>>>
90410>>>                Else Begin
90411>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
90414>>>                End
90414>>>>
90414>>>                Move DF_DATETIME to ColumnType.iDataFlexType
90415>>>                Move "DateTime"  to ColumnType.sDataFlexType
90416>>>                Move sDataType   to ColumnType.sType
90417>>>                Move DF_DATETIME to ColumnType.iType
90418>>>                Move True        to ColumnType.bFixedSize
90419>>>                Case Break
90420>>>    
90420>>>            // DF_NUMERIC
90420>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
90420>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
90420>>>            // we make them here all "Numeric"...
90420>>>            // If (sDriverID = ODBC_DRV_ID) Begin
90420>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
90420>>>            // End
90420>>>            // Else Begin
90420>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
90420>>>            // End 
90420>>>            // ToDo: How should we find the best "Numeric" data type here?
90420>>>            Case (iType = DF_BCD_DUF)
90423>>>                Move DF_BCD      to ColumnType.iDataFlexType
90424>>>                Move "Numeric"   to ColumnType.sDataFlexType
90425>>>                Move "Numeric"   to ColumnType.sType
90426>>>                Move SQL_NUMERIC to ColumnType.iType
90427>>>                Move False       to ColumnType.bFixedSize
90428>>>                Case Break
90429>>>                
90429>>>            // DF_TEXT
90429>>>            Case (iType = DF_TEXT_DUF)
90432>>>                If (sDriverID = ODBC_DRV_ID) Begin
90434>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
90437>>>                End
90437>>>>
90437>>>                Else Begin
90438>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
90441>>>                End
90441>>>>
90441>>>                Move DF_TEXT     to ColumnType.iDataFlexType
90442>>>                Move "Text"      to ColumnType.sDataFlexType
90443>>>                Move sDataType   to ColumnType.sType
90444>>>                Move DF_TEXT     to ColumnType.iType
90445>>>                Move False       to ColumnType.bFixedSize
90446>>>                Case Break
90447>>>                
90447>>>            Case Else
90447>>>                Move -1999       to ColumnType.iDataFlexType
90448>>>                Move "Undefined" to ColumnType.sDataFlexType
90449>>>                Move "Undefined" to ColumnType.sType
90450>>>                Move -1999       to ColumnType.iType
90451>>>                Move True        to ColumnType.bFixedSize
90452>>>
90452>>>        Case End
90452>>>
90452>>>        Function_Return ColumnType
90453>>>    End_Function
90454>>>
90454>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
90456>>>        String sDataPath sDriverID
90456>>>        Boolean bMertechDriver bOK
90456>>>        Integer iPos
90456>>>
90456>>>        If (sTableName contains ".") Begin
90458>>>            Move (Pos(".", sTableName)) to iPos
90459>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
90460>>>        End
90460>>>>
90460>>>
90460>>>        Get psDriverID to sDriverID
90461>>>        Get psDataPathFirstPart to sDataPath
90462>>>        Get IsMertechDriver sDriverID to bMertechDriver
90463>>>        // First delete the cache file:
90463>>>        If (bMertechDriver = False) Begin
90465>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
90466>>>        End
90466>>>>
90466>>>        Else Begin
90467>>>            Get _MertechDeleteTDFile sTableName to bOK
90468>>>        End
90468>>>>
90468>>>
90468>>>        Function_Return bOK
90469>>>    End_Function
90470>>>
90470>>>    // Changes source code files.
90470>>>    // Pass a file name with full path and a value to search for, together with the value
90470>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
90470>>>    // to use a Connection ID.
90470>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
90470>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
90470>>>    // Returns True if no errors occured.
90470>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
90472>>>        Integer iCh iRow iItems iCount
90472>>>        String sValue sRow
90472>>>        String[] sFileArray
90473>>>        Boolean bExists
90473>>>
90473>>>        Move False to Err
90474>>>        Move 0 to iRow
90475>>>
90475>>>        Get vFilePathExists sFileName to bExists
90476>>>        If (bExists = False) Begin
90478>>>            If (bShowResult = True) Begin
90480>>>                Showln "File does not exist: " sFileName
90483>>>            End
90483>>>>
90483>>>            Function_Return False
90484>>>        End
90484>>>>
90484>>>
90484>>>        Get Seq_Open_Input_Channel sFileName to iCh
90485>>>        If (iCh < 1) Begin
90487>>>            Function_Return False
90488>>>        End
90488>>>>
90488>>>
90488>>>        If (bShowResult = True) Begin
90490>>>            Showln ""
90492>>>            Showln "sFileName = " sFileName
90495>>>            Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
90500>>>        End
90500>>>>
90500>>>
90500>>>        While (not(SeqEof))
90504>>>            Readln channel iCh sRow
90506>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
90508>>>                If (bShowResult = True) Begin
90510>>>                    Showln "Changed from: " sRow " to: " sChangeTo
90515>>>                End
90515>>>>
90515>>>                // Change the whole line to the new connection id:
90515>>>                Move sChangeTo to sRow
90516>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
90516>>>            End
90516>>>>
90516>>>            Move sRow to sFileArray[iRow]
90517>>>            Increment iRow
90518>>>        End
90519>>>>
90519>>>        Send Seq_Close_Channel iCh
90520>>>
90520>>>        Sleep 1 // Wait for Windows to close the file
90521>>>
90521>>>        Get Seq_Open_Output_Channel sFileName to iCh
90522>>>        If (iCh < 1) Begin
90524>>>            Function_Return False
90525>>>        End
90525>>>>
90525>>>        Move (SizeOfArray(sFileArray)) to iItems
90526>>>        Decrement iItems
90527>>>
90527>>>        For iCount from 0 to iItems
90533>>>>
90533>>>            Move sFileArray[iCount] to sValue
90534>>>            Writeln channel iCh sValue
90537>>>        Loop
90538>>>>
90538>>>        Send Seq_Close_Channel iCh
90539>>>
90539>>>        Function_Return (Err = False)
90540>>>    End_Function
90541>>>
90541>>>    // This might be needed by API-methods when a connection id is to be used and
90541>>>    // the connection ID hasn't been established with the driver's CLI interface.
90541>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
90541>>>    Function UtilCreateConnectionID String sConnectionID Returns Boolean
90543>>>        String sConnectionString sDriverID
90543>>>        Boolean bOK bSilent bDawDriver
90543>>>        Handle hoCLI
90543>>>
90543>>>        Move False to bOK
90544>>>        Get psDriverID to sDriverID
90545>>>        Get IsDAWSQLDriver sDriverID to bDawDriver
90546>>>        If (bDawDriver = False) Begin
90548>>>            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
90549>>>>
90549>>>            Function_Return False
90550>>>        End
90550>>>>
90550>>>
90550>>>        Get psConnectionString to sConnectionString
90551>>>        Get pbSilentLogin      to bSilent
90552>>>
90552>>>        Get phoCLIHandler to hoCLI
90553>>>        If (hoCLI <> 0) Begin
90555>>>            Set psDriverID of hoCLI to sDriverID
90556>>>            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
90557>>>        End
90557>>>>
90557>>>
90557>>>        Function_Return (bOK = False)
90558>>>    End_Function
90559>>>
90559>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
90559>>>    // and opens it in "notepad.exe".
90559>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
90559>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
90559>>>    Procedure UtilShowErrorList
90561>>>        tSqlErrorArray aSqlErrorArray
90561>>>        tSqlErrorArray aSqlErrorArray
90561>>>        Integer iRows iCount iCh iErrorNum
90561>>>        String sPath sFileName sErrorTxt sStatement
90561>>>
90561>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
90562>>>        Get vFolderFormat sPath to sPath
90563>>>        Move "SQLErrorLog.txt"  to sFileName
90564>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
90565>>>            Get paSqlErrorArray to aSqlErrorArray
90566>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
90567>>>            If (iRows > 0) Begin
90569>>>                Decrement iRows
90570>>>                for iCount from 0 to iRows
90576>>>>
90576>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
90577>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
90578>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
90579>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
90585>>>                    Writeln channel iCh "SQL Statement: " sStatement
90589>>>                Loop
90590>>>>
90590>>>            End
90590>>>>
90590>>>        Send Seq_Close_Channel iCh
90591>>>
90591>>>        If (iRows > 0) Begin
90593>>>            Runprogram Background "Notepad.exe" (sPath + sFileName)
90594>>>        End
90594>>>>
90594>>>    End_Procedure
90595>>>    
90595>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
90595>>>    // and the table needs to exist as an SQL table.
90595>>>    Function UtilTableIsSql Handle hTable Returns Boolean
90597>>>        String sRootName sLogicalName sDriverID
90597>>>        Boolean bIsSQL
90597>>>        
90597>>>        Move False to bIsSQL
90598>>>        If (hTable > 0) Begin
90600>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90603>>>            Move (sRootName contains ":") to bIsSQL
90604>>>            If (bIsSQL = True) Begin               
90606>>>                Get psDriverID to sDriverID
90607>>>                Get _TableNameOnly sRootName to sRootName
90608>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
90609>>>            End
90609>>>>
90609>>>        End
90609>>>>
90609>>>
90609>>>        Function_Return bIsSQL
90610>>>    End_Function
90611>>>
90611>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
90613>>>        Boolean bIsSQL
90613>>>        Move (sRootName contains ":") to bIsSQL
90614>>>        Function_Return bIsSQL
90615>>>    End_Function
90616>>>
90616>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
90616>>>    // An Alias file/table is a filelist number that share the same Physical filename
90616>>>    // but the Logical name is different.
90616>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
90616>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
90616>>>//        String sPhysicalName sPhysicalNameCompare
90616>>>//        Boolean bWasOpen bOpened bOK
90616>>>//        Integer iCount 
90616>>>//        
90616>>>//        Move 0 to iCount    
90616>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
90616>>>//        If (bWasOpen = False) Begin
90616>>>//            Open hTable
90616>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
90616>>>//            If (bOpened = False) Begin
90616>>>//                Function_Return False
90616>>>//            End  
90616>>>//        End
90616>>>//        
90616>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
90616>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
90616>>>//        If (bWasOpen = False and bOpened = True) Begin
90616>>>//            Close hTable
90616>>>//        End
90616>>>//
90616>>>//        Move 0 to hTable
90616>>>//        Repeat
90616>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90616>>>//            If (hTable > 0 and hTable <> 50) Begin
90616>>>//                Open hTable
90616>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
90616>>>//                If (bOpened = True) Begin
90616>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
90616>>>//                    Close hTable
90616>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
90616>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
90616>>>//                        Increment iCount 
90616>>>//                    End
90616>>>//                End
90616>>>//            End
90616>>>//        Until (hTable = 0)
90616>>>//        
90616>>>//        If (iCount > 1) Begin
90616>>>//            Function_Return True
90616>>>//        End
90616>>>//
90616>>>//        Function_Return False
90616>>>//    End_Function  
90616>>>
90616>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
90618>>>        String sPhysicalName sPhysicalNameCompare
90618>>>        Integer iCount iMaster iAlias iInTable
90618>>>        
90618>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
90621>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
90622>>>        Move hTable to iInTable
90623>>>        Move 0 to hTable                      
90624>>>        Move 0 to iCount    
90625>>>        
90625>>>        Repeat
90625>>>>
90625>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90628>>>            If (hTable > 0 and hTable <> 50) Begin
90630>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
90633>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
90634>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
90636>>>                
90636>>>                    If (iCount = 0) Begin
90638>>>                        Move hTable to iMaster
90639>>>                    End
90639>>>>
90639>>>                    If (iCount > 0) Begin
90641>>>                        Move hTable to iAlias
90642>>>                    End
90642>>>>
90642>>>                    Increment iCount 
90643>>>                End
90643>>>>
90643>>>            End
90643>>>>
90643>>>        Until (hTable = 0)
90645>>>        
90645>>>        If (iCount > 1) Begin
90647>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
90648>>>        End
90648>>>>
90648>>>
90648>>>        Function_Return False
90649>>>    End_Function  
90650>>>    
90650>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
90650>>>//        String sDDSrcPath sDataPath sLogicalName
90650>>>//        Boolean bOK bExists
90650>>>//        
90650>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath  
90650>>>//        If (Right(sDataPath, 1) = "\") Begin
90650>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
90650>>>//        End
90650>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
90650>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
90650>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
90650>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
90650>>>//        
90650>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90650>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
90650>>>//        
90650>>>//        Function_Return bExists
90650>>>//    End_Function  
90650>>>
90650>>>    // To Open a table with any driver.
90650>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
90650>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
90650>>>    //
90650>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
90650>>>    // The found flag is still used to indicate if the open was successful or not. The function
90650>>>    // returns a True if successful (table could be opened).
90650>>>    //
90650>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
90650>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
90650>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
90650>>>    // set properly we can open the table.
90650>>>    //
90650>>>    // DAW Driver Syntax:
90650>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
90650>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
90650>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
90650>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
90650>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
90650>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
90650>>>    //
90650>>>    // DAW Driver Sample:
90650>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
90650>>>    //
90650>>>    // Mertech Driver Samples:
90650>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
90650>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
90650>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
90650>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
90650>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
90652>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
90652>>>        Boolean bOpen bMertechDriver bOK
90652>>>        Integer iRetval
90652>>>        tSQLConnection SQLConnection
90652>>>        tSQLConnection SQLConnection
90652>>>
90652>>>        Move sTableName to sTableNameOrg
90653>>>        If (hTable > 0) Begin
90655>>>//        If (hTable > 0 and Trim(sTableName) = "") Begin
90655>>>            Send Ignore_Error of Error_Object_Id 20529
90656>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90657>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
90658>>>            Open hTable
90660>>>            Send Trap_Error of Error_Object_Id 20529
90661>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90662>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND  
90663>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90666>>>            If (bOpen = True) Begin
90668>>>                Function_Return True
90669>>>            End
90669>>>>
90669>>>        End
90669>>>>
90669>>>
90669>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90670>>>        Move SQLConnection.sDriverID to sDriverID
90671>>>        Get IsMertechDriver sDriverID to bMertechDriver
90672>>>        Move SQLConnection.sConnectionString to sConnection
90673>>>        Move SQLConnection.sSchema to sSchema
90674>>>        If (sSchema = "") Begin
90676>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90677>>>        End
90677>>>>
90677>>>
90677>>>        // We need to remove the ".int" part of the table name because
90677>>>        // the table name after the "#" in the connection syntax below wants the
90677>>>        // "bare" table name without any extension.
90677>>>        If (sDriverID <> DATAFLEX_ID) Begin
90679>>>            If (Lowercase(sTableName) contains ".int") Begin
90681>>>                Get ParseFileExtension sTableName to sExt
90682>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
90683>>>            End
90683>>>>
90683>>>            Else Begin
90684>>>                Move sTableName to sTableNameShort
90685>>>                Move (Append(sTableName, ".int")) to sTableName
90686>>>            End
90686>>>>
90686>>>            If (bMertechDriver = False) Begin
90688>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
90689>>>                Move sConnection to sTableName
90690>>>            End
90690>>>>
90690>>>        End
90690>>>>
90690>>>
90690>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90691>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
90692>>>        If (hTable = 0) Begin
90694>>>            Get NextFreeFilelistSlot to hTable
90695>>>        End
90695>>>>
90695>>>
90695>>>        Case Begin
90695>>>            Case (sDriverID = MSSQLDRV_ID)
90697>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90697>>>                If (iMode <> DF_EXCLUSIVE) Begin
90699>>>                    Open sTableName as hTable
90701>>>                End
90701>>>>
90701>>>                Else Begin
90702>>>                    Get OpenTableExclusive hTable to bOK
90703>>>                    If (bOK = False) Begin
90705>>>                        Function_Return False
90706>>>                    End
90706>>>>
90706>>>                End
90706>>>>
90706>>>                Case Break
90707>>>
90707>>>            Case (sDriverID = DB2_DRV_ID)
90710>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90710>>>                If (iMode <> DF_EXCLUSIVE) Begin
90712>>>                    Open sTableName as hTable
90714>>>                End
90714>>>>
90714>>>                Else Begin
90715>>>                    Get OpenTableExclusive hTable to bOK
90716>>>                    If (bOK = False) Begin
90718>>>                        Function_Return False
90719>>>                    End
90719>>>>
90719>>>                End
90719>>>>
90719>>>                Case Break
90720>>>
90720>>>            Case (sDriverID = ODBC_DRV_ID)
90723>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90723>>>                If (iMode <> DF_EXCLUSIVE) Begin
90725>>>                    Open sTableName as hTable
90727>>>                End
90727>>>>
90727>>>                Else Begin
90728>>>                    Get OpenTableExclusive hTable to bOK
90729>>>                    If (bOK = False) Begin
90731>>>                        Function_Return False
90732>>>                    End
90732>>>>
90732>>>                End
90732>>>>
90732>>>                Case Break
90733>>>
90733>>>            Case (sDriverID = SQLFLEX)
90736>>>                // ToDo: What is the <owner>? Same as Schema?
90736>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
90736>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
90737>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90737>>>                If (iMode <> DF_EXCLUSIVE) Begin
90739>>>                    Open sTableName as hTable
90741>>>                End
90741>>>>
90741>>>                Else Begin
90742>>>                    Get OpenTableExclusive hTable to bOK
90743>>>                    If (bOK = False) Begin
90745>>>                        Function_Return False
90746>>>                    End
90746>>>>
90746>>>                End
90746>>>>
90746>>>                Case Break
90747>>>
90747>>>            Case (sDriverID = MDSMySQL)
90750>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
90750>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
90751>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90751>>>                If (iMode <> DF_EXCLUSIVE) Begin
90753>>>                    Open sTableName as hTable
90755>>>                End
90755>>>>
90755>>>                Else Begin
90756>>>                    Get OpenTableExclusive hTable to bOK
90757>>>                    If (bOK = False) Begin
90759>>>                        Function_Return False
90760>>>                    End
90760>>>>
90760>>>                End
90760>>>>
90760>>>                Case Break
90761>>>
90761>>>            Case (sDriverID = MDSPgSQL)
90764>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
90764>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
90765>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90765>>>                If (iMode <> DF_EXCLUSIVE) Begin
90767>>>                    Open sTableName as hTable
90769>>>                End
90769>>>>
90769>>>                Else Begin
90770>>>                    Get OpenTableExclusive hTable to bOK
90771>>>                    If (bOK = False) Begin
90773>>>                        Function_Return False
90774>>>                    End
90774>>>>
90774>>>                End
90774>>>>
90774>>>                Case Break
90775>>>
90775>>>            Case (sDriverID = ORAFLEX)
90778>>>                // ToDo: What is the <owner>? Same as Schema?
90778>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
90778>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
90779>>>                // If not df_exclusive mode, we use the "Open As" syntax.
90779>>>                If (iMode <> DF_EXCLUSIVE) Begin
90781>>>                    Open sTableName as hTable
90783>>>                End
90783>>>>
90783>>>                Else Begin
90784>>>                    Get OpenTableExclusive hTable to bOK
90785>>>                    If (bOK = False) Begin
90787>>>                        Function_Return False
90788>>>                    End
90788>>>>
90788>>>                End
90788>>>>
90788>>>                Case Break
90789>>>
90789>>>            Case (sDriverID = DATAFLEX_ID)
90792>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
90794>>>                    Open sTableName as hTable
90796>>>                End
90796>>>>
90796>>>                Else If (iMode = DF_EXCLUSIVE) Begin
90799>>>                    Get OpenTableExclusive hTable to bOK
90800>>>                    If (bOK = False) Begin
90802>>>                        Function_Return False
90803>>>                    End
90803>>>>
90803>>>                End
90803>>>>
90803>>>                Else Begin
90804>>>                    Open hTable
90806>>>                End
90806>>>>
90806>>>                Case Break
90807>>>
90807>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
90807>>>
90807>>>            Case Else
90807>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
90808>>>>
90808>>>        Case End
90808>>>
90808>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90809>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
90810>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
90812>>>            Move False to Found
90813>>>        End
90813>>>>
90813>>>        // If open failed, the Err is set to true,
90813>>>        // but we don't want that because it could end our loop.
90813>>>        Move False to Err
90814>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90817>>>
90817>>>        Function_Return bOpen
90818>>>    End_Function
90819>>>
90819>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
90819>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
90819>>>    // if it is an SQL table
90819>>>    Function UtilTableExists Handle hTable Returns Boolean
90821>>>        Boolean bExists bIsSQLTable
90821>>>        String sDataPath sRootName
90821>>>        
90821>>>        Get UtilTableNumberIsInUse hTable to bExists
90822>>>        If (bExists = False) Begin
90824>>>            Function_Return False
90825>>>        End
90825>>>>
90825>>>        
90825>>>        Move False to bIsSQLTable
90826>>>        If (hTable > 0) Begin
90828>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90831>>>            Move (sRootName contains ":") to bIsSQLTable
90832>>>        End
90832>>>>
90832>>>        If (bIsSQLTable = True) Begin
90834>>>            Get UtilTableIsSQL hTable to bExists
90835>>>            Function_Return bExists
90836>>>        End
90836>>>>
90836>>>        Else Begin
90837>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90838>>>            Get vFolderFormat sDataPath to sDataPath
90839>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
90840>>>        End
90840>>>>
90840>>>        
90840>>>        Function_Return bExists
90841>>>    End_Function               
90842>>>    
90842>>>    // Pass a table handle
90842>>>    // Returns True if the table exists in filelist.cfg.
90842>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
90844>>>        Handle hTable
90844>>>        Boolean bFound
90844>>>
90844>>>        Move False to bFound
90845>>>        Move 0 to hTable
90846>>>        Repeat
90846>>>>
90846>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90849>>>            If (hTable > 0) Begin
90851>>>                If (hTable = hCheckTable) Begin
90853>>>                    Move True to bFound
90854>>>                End
90854>>>>
90854>>>            End
90854>>>>
90854>>>            If (bFound = True) Break
90857>>>        Until (hTable = 0)
90859>>>
90859>>>        Function_Return (bFound = True)
90860>>>    End_Function
90861>>>
90861>>>    // Pass a table's logical name
90861>>>    // Returns True if the table exists in filelist.cfg.
90861>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
90863>>>        Handle hTable
90863>>>        Boolean bFound                           
90863>>>        String sCompareTable
90863>>>
90863>>>        Move False to bFound
90864>>>        Move 0 to hTable
90865>>>        Repeat
90865>>>>
90865>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90868>>>            If (hTable > 0) Begin
90870>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
90873>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
90875>>>                    Move True to bFound
90876>>>                End
90876>>>>
90876>>>            End
90876>>>>
90876>>>            If (bFound = True) Break
90879>>>        Until (hTable = 0)
90881>>>
90881>>>        Function_Return (bFound = True)
90882>>>    End_Function    
90883>>>    
90883>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
90885>>>        Boolean bOK bRecnum bToAnsi
90885>>>        Integer iCh                   
90885>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
90885>>>        
90885>>>        If (Trim(sDataPath) = "") Begin
90887>>>            Function_Return False
90888>>>        End
90888>>>>
90888>>>        
90888>>>        Move False to Err
90889>>>        Get psDriverID     to sDriverID
90890>>>        Get psConnectionID to sConnectionID
90891>>>        Get psSchema       to sSchemaName
90892>>>        Get True           to bRecnum
90893>>>        Get pbToANSI       to bToAnsi
90894>>>        Move CS_ANSI_Txt to sANSI_OEM
90895>>>        If (bToAnsi = False) Begin
90897>>>            Move CS_OEM_Txt to sANSI_OEM
90898>>>        End
90898>>>>
90898>>>        
90898>>>        Get vFolderFormat sDataPath to sDataPath
90899>>>        Move "CodeMast.int"         to sFileName
90900>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
90901>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
90904>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
90907>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
90910>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
90913>>>            Writeln channel iCh ("")
90916>>>            Writeln channel iCh ("RECNUM_TABLE YES")
90919>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
90922>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
90925>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
90928>>>            Writeln channel iCh ("")
90931>>>            Writeln channel iCh ("INDEX_NUMBER 1")
90934>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
90937>>>            Writeln channel iCh ("")
90940>>>        Send Seq_Close_Channel iCh
90941>>>        
90941>>>        Get vFolderFormat sDataPath to sDataPath
90942>>>        Move "CodeType.int"         to sFileName
90943>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
90944>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
90947>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
90950>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
90953>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
90956>>>            Writeln channel iCh ("")
90959>>>            Writeln channel iCh ("RECNUM_TABLE YES")
90962>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
90965>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
90968>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
90971>>>            Writeln channel iCh ("")
90974>>>            Writeln channel iCh ("INDEX_NUMBER 0")
90977>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
90980>>>            Writeln channel iCh ("")
90983>>>            Writeln channel iCh ("INDEX_NUMBER 1")
90986>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
90989>>>            Writeln channel iCh ("")
90992>>>        Send Seq_Close_Channel iCh
90993>>>    
90993>>>        Function_Return (Err = False)
90994>>>    End_Function
90995>>>
90995>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
90997>>>        String  sRetval sColumnName
90997>>>        String[] sOverlapFieldsArray
90998>>>        Integer iType iColumn iColumns
90998>>>        Boolean bOpen bOverlap
90998>>>
90998>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91001>>>        If (bOpen = False) Begin
91003>>>            Open hTable
91005>>>        End
91005>>>>
91005>>>
91005>>>        Move "" to sRetval
91006>>>
91006>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
91009>>>
91009>>>        for iColumn from 0 to iColumns
91015>>>>
91015>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
91018>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
91020>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
91023>>>                If (bOverlap) Begin
91025>>>                    If (sRetval <> "") Begin
91027>>>                        Append sRetval ","
91028>>>                    End
91028>>>>
91028>>>                    Append sRetval iColumn
91029>>>                End
91029>>>>
91029>>>            End
91029>>>>
91029>>>        Loop
91030>>>>
91030>>>
91030>>>        If (bOpen = False) Begin
91032>>>            Close hTable
91033>>>        End
91033>>>>
91033>>>
91033>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
91034>>>
91034>>>        Function_Return sOverlapFieldsArray
91035>>>    End_Function
91036>>>
91036>>>    // Returns a struct array with all data types for the passed driver & dbtype.
91036>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
91038>>>        tColumnType[] ColumnType
91038>>>        tColumnType[] ColumnType
91039>>>
91039>>>        Case Begin
91039>>>            Case (iDbType = EN_dbTypeDataFlex)
91041>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
91042>>>                Case Break
91043>>>
91043>>>            Case (iDbType = EN_DbTypeDB2)
91046>>>                Get _UtilEnumerateDB2Types to ColumnType
91047>>>                Case Break
91048>>>
91048>>>            Case (iDbType = EN_DbTypeMSSQL)
91051>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
91052>>>                Case Break
91053>>>
91053>>>            Case (sDriverID = MDSMySQL)
91056>>>                Get _UtilEnumerateMySQLTypes to ColumnType
91057>>>                Case Break
91058>>>
91058>>>            Case (sDriverID = ORAFLEX)
91061>>>                Get _UtilEnumerateOracleTypes to ColumnType
91062>>>                Case Break
91063>>>
91063>>>            Case (sDriverID = MDSPgSQL)
91066>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
91067>>>                Case Break
91068>>>        Case End
91068>>>
91068>>>        Function_Return ColumnType
91069>>>    End_Function 
91070>>>    
91070>>>    Function UtilEnumerateMSSQLODBCDrivers Returns String
91072>>>        Handle hoRegistry hoODBCDriverNames
91072>>>        Boolean bExists bKeyOpened
91072>>>        String sKey
91072>>>        String[] sDrivers
91073>>>        Integer iDriverNames iDriverName
91073>>>        
91073>>>        Get Create (RefClass (cRegistry)) to hoRegistry
91074>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91075>>>        Set pfAccessRights of hoRegistry to Key_Read
91076>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
91077>>>        Get KeyExists of hoRegistry sKey to bExists
91078>>>        If (bExists) Begin
91080>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
91081>>>            If (bKeyOpened) Begin
91083>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
91084>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
91085>>>                If (iDriverNames > 0) Begin
91087>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
91088>>>                    Decrement iDriverNames
91089>>>                    for iDriverName from 0 to iDriverNames
91095>>>>
91095>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
91096>>>                      Loop
91097>>>>
91097>>>                End
91097>>>>
91097>>>                Send CloseKey of hoRegistry
91098>>>            End
91098>>>>
91098>>>        End
91098>>>>
91098>>>        Send Destroy of hoRegistry
91099>>>        
91099>>>        Function_Return sDrivers
91100>>>    End_Function
91101>>>
91101>>>    // DataFlex Embedded Database Data Types:
91101>>>    // Helper function for UtilEnumerateColumnTypes
91101>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
91103>>>        tColumnType[] ColumnType
91103>>>        tColumnType[] ColumnType
91104>>>        Integer i
91104>>>
91104>>>        Move DF_ASCII           to ColumnType[i].iType
91105>>>        Move "ASCII"            to ColumnType[i].sType
91106>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91107>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91108>>>        Move "254"              to ColumnType[i].sPrecision
91109>>>        Increment i
91110>>>
91110>>>        Move DF_BCD             to ColumnType[i].iType
91111>>>        Move "Numeric"          to ColumnType[i].sType
91112>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91113>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91114>>>        Move "14.8"             to ColumnType[i].sPrecision
91115>>>        Increment i
91116>>>
91116>>>        Move DF_DATE            to ColumnType[i].iType
91117>>>        Move "Date"             to ColumnType[i].sType
91118>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
91119>>>        Move "Date"             to ColumnType[i].sDataFlexType
91120>>>        Move "6.0"              to ColumnType[i].sPrecision
91121>>>        Move True               to ColumnType[i].bFixedSize
91122>>>        Increment i
91123>>>
91123>>>        Move DF_TEXT            to ColumnType[i].iType
91124>>>        Move "Text"             to ColumnType[i].sType
91125>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91126>>>        Move "Text"             to ColumnType[i].sDataFlexType
91127>>>        Move "16384"            to ColumnType[i].sPrecision
91128>>>        Increment i
91129>>>
91129>>>        Move DF_BINARY          to ColumnType[i].iType
91130>>>        Move "Binary"           to ColumnType[i].sType
91131>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91132>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91133>>>        Move "16384"            to ColumnType[i].sPrecision
91134>>>        Increment i
91135>>>
91135>>>        Move DF_DATETIME        to ColumnType[i].iType
91136>>>        Move "DateTime"         to ColumnType[i].sType
91137>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91138>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
91139>>>        Move "23"               to ColumnType[i].sPrecision
91140>>>        Move True               to ColumnType[i].bFixedSize
91141>>>        Increment i
91142>>>
91142>>>        Move DF_OVERLAP         to ColumnType[i].iType
91143>>>        Move "Overlap"          to ColumnType[i].sType
91144>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
91145>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
91146>>>        Move "0.0"              to ColumnType[i].sPrecision
91147>>>
91147>>>        Function_Return ColumnType
91148>>>    End_Function
91149>>>
91149>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
91151>>>        tColumnType[] ColumnType
91151>>>        tColumnType[] ColumnType
91152>>>        Integer i
91152>>>
91152>>>        Move SQL_DBCLOB         to ColumnType[i].iType
91153>>>        Move "DBCLOB"           to ColumnType[i].sType
91154>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91155>>>        Move "Text"             to ColumnType[i].sDataFlexType
91156>>>        Move "16384"            to ColumnType[i].sPrecision
91157>>>        Increment i
91158>>>
91158>>>        Move SQL_BIGINT         to ColumnType[i].iType
91159>>>        Move "BIGINT"           to ColumnType[i].sType
91160>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91161>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91162>>>        Move "14.0"             to ColumnType[i].sPrecision
91163>>>        Increment i
91164>>>
91164>>>        Move SQL_BLOB           to ColumnType[i].iType
91165>>>        Move "BLOB"             to ColumnType[i].sType
91166>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91167>>>        Move "BINARY"           to ColumnType[i].sDataFlexType
91168>>>        Move "16384"            to ColumnType[i].sPrecision
91169>>>        Increment i
91170>>>
91170>>>        Move SQL_CHAR           to ColumnType[i].iType
91171>>>        Move "CHAR"             to ColumnType[i].sType
91172>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91173>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91174>>>        Move "254"              to ColumnType[i].sPrecision
91175>>>        Increment i
91176>>>
91176>>>        // ToDo: We need to change the sType when using this!
91176>>>        Move SQL_CHARBIT            to ColumnType[i].iType
91177>>>        Move "CHAR FOR BIT DATA"    to ColumnType[i].sType
91178>>>        Move DF_BINARY              to ColumnType[i].iDataFlexType
91179>>>        Move "Binary"               to ColumnType[i].sDataFlexType
91180>>>        Move "254"                  to ColumnType[i].sPrecision
91181>>>        Increment i
91182>>>
91182>>>        Move SQL_DATE           to ColumnType[i].iType
91183>>>        Move "DATE"             to ColumnType[i].sType
91184>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
91185>>>        Move "Date"             to ColumnType[i].sDataFlexType
91186>>>        Move "6.0"              to ColumnType[i].sPrecision
91187>>>        Move True               to ColumnType[i].bFixedSize
91188>>>        Increment i
91189>>>
91189>>>        Move SQL_CLOB           to ColumnType[i].iType
91190>>>        Move "CLOB"             to ColumnType[i].sType
91191>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91192>>>        Move "Text"             to ColumnType[i].sDataFlexType
91193>>>        Move "16384"            to ColumnType[i].sPrecision
91194>>>        Increment i
91195>>>
91195>>>        Move SQL_DECIMAL        to ColumnType[i].iType
91196>>>        Move "DECIMAL"          to ColumnType[i].sType
91197>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91198>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91199>>>        Move "14.8"             to ColumnType[i].sPrecision
91200>>>        Increment i
91201>>>
91201>>>        Move SQL_DOUBLE         to ColumnType[i].iType
91202>>>        Move "DOUBLE"           to ColumnType[i].sType
91203>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91204>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91205>>>        Move "14.8"             to ColumnType[i].sPrecision
91206>>>        Increment i
91207>>>
91207>>>        Move SQL_FLOAT          to ColumnType[i].iType
91208>>>        Move "FLOAT"            to ColumnType[i].sType
91209>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91210>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91211>>>        Move "14.8"             to ColumnType[i].sPrecision
91212>>>        Increment i
91213>>>
91213>>>        Move SQL_GRAPHIC        to ColumnType[i].iType
91214>>>        Move "GRAPHIC"          to ColumnType[i].sType
91215>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91216>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91217>>>        Move "255"              to ColumnType[i].sPrecision
91218>>>        Increment i
91219>>>
91219>>>        Move SQL_INTEGER        to ColumnType[i].iType
91220>>>        Move "INTEGER"          to ColumnType[i].sType
91221>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91222>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91223>>>        Move "9.0"              to ColumnType[i].sPrecision
91224>>>        Increment i
91225>>>
91225>>>        Move SQL_LONGVARCHAR    to ColumnType[i].iType
91226>>>        Move "LONG VARCHAR"     to ColumnType[i].sType
91227>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91228>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91229>>>        Move "32000"            to ColumnType[i].sPrecision
91230>>>        Increment i
91231>>>
91231>>>        Move SQL_LONGVARCHARBIT to ColumnType[i].iType
91232>>>        Move "LONG VARCHAR BIT" to ColumnType[i].sType
91233>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91234>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91235>>>        Move "32000"            to ColumnType[i].sPrecision
91236>>>        Increment i
91237>>>
91237>>>        Move SQL_LONGVARGRAPHIC to ColumnType[i].iType
91238>>>        Move "LONG VARGRAPHIC"  to ColumnType[i].sType
91239>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91240>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91241>>>        Move "32000"            to ColumnType[i].sPrecision
91242>>>        Increment i
91243>>>
91243>>>        Move SQL_NUMERIC        to ColumnType[i].iType
91244>>>        Move "NUMERIC"          to ColumnType[i].sType
91245>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91246>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91247>>>        Move "14.8"             to ColumnType[i].sPrecision
91248>>>        Increment i
91249>>>
91249>>>        Move SQL_REAL           to ColumnType[i].iType
91250>>>        Move "REAL"             to ColumnType[i].sType
91251>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91252>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91253>>>        Move "14.8"             to ColumnType[i].sPrecision
91254>>>        Increment i
91255>>>
91255>>>        Move SQL_SMALLINT       to ColumnType[i].iType
91256>>>        Move "SMALLINT"         to ColumnType[i].sType
91257>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91258>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
91259>>>        Move "5.0"              to ColumnType[i].sPrecision
91260>>>        Increment i
91261>>>
91261>>>        Move SQL_TIME           to ColumnType[i].iType
91262>>>        Move "TIME"             to ColumnType[i].sType
91263>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91264>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91265>>>        Move "19.0"             to ColumnType[i].sPrecision
91266>>>        Move True               to ColumnType[i].bFixedSize
91267>>>        Increment i
91268>>>
91268>>>        Move SQL_TIMESTAMP      to ColumnType[i].iType
91269>>>        Move "TIMESTAMP"        to ColumnType[i].sType
91270>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91271>>>        Move "DATETIME"         to ColumnType[i].sDataFlexType
91272>>>        Move "23.6"             to ColumnType[i].sPrecision
91273>>>        Move True               to ColumnType[i].bFixedSize
91274>>>        Increment i
91275>>>
91275>>>        Move SQL_VARCHAR        to ColumnType[i].iType
91276>>>        Move "VARCHAR"          to ColumnType[i].sType
91277>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91278>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91279>>>        Move "16384"            to ColumnType[i].sPrecision
91280>>>        Increment i
91281>>>
91281>>>        // ToDo: We need to change the sType when using this!
91281>>>        Move SQL_VARCHARBIT         to ColumnType[i].iType
91282>>>        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sType
91283>>>        Move DF_TEXT                to ColumnType[i].iDataFlexType
91284>>>        Move "TEXT"                 to ColumnType[i].sDataFlexType
91285>>>        Move "16384"                to ColumnType[i].sPrecision
91286>>>        Increment i
91287>>>
91287>>>        Move SQL_VARGRAPHIC     to ColumnType[i].iType
91288>>>        Move "VARGRAPHIC"       to ColumnType[i].sType
91289>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91290>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91291>>>        Move "16384"            to ColumnType[i].sPrecision
91292>>>
91292>>>        Move SQL_XML            to ColumnType[i].iType
91293>>>        Move "XML"              to ColumnType[i].sType
91294>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91295>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91296>>>        Move "16384"            to ColumnType[i].sPrecision
91297>>>
91297>>>        Function_Return ColumnType
91298>>>    End_Function
91299>>>
91299>>>    // Microsoft SQL Server Database Data Types:
91299>>>    // Helper function for UtilEnumerateColumnTypes
91299>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
91301>>>        tColumnType[] ColumnType
91301>>>        tColumnType[] ColumnType
91302>>>        Integer i
91302>>>
91302>>>        If (sDriverID = MSSQLDRV_ID) Begin
91304>>>            Move SQL_BIGINT         to ColumnType[i].iType
91305>>>            Move "bigint"           to ColumnType[i].sType
91306>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91307>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91308>>>            Move "14.0"             to ColumnType[i].sPrecision
91309>>>            Move True               to ColumnType[i].bFixedSize
91310>>>            Increment i
91311>>>
91311>>>            Move SQL_BINARY         to ColumnType[i].iType
91312>>>            Move "binary"           to ColumnType[i].sType
91313>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
91314>>>            Move "Binary"           to ColumnType[i].sDataFlexType
91315>>>            Move "8000"             to ColumnType[i].sPrecision
91316>>>            Increment i
91317>>>
91317>>>            Move SQL_BIT            to ColumnType[i].iType
91318>>>            Move "bit"              to ColumnType[i].sType
91319>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91320>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91321>>>            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
91322>>>            Move True               to ColumnType[i].bFixedSize
91323>>>            Increment i
91324>>>
91324>>>            Move SQL_CHAR           to ColumnType[i].iType
91325>>>            Move "char"             to ColumnType[i].sType
91326>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91327>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91328>>>            Move "8000"             to ColumnType[i].sPrecision
91329>>>            Increment i
91330>>>
91330>>>            Move SQL_DATE           to ColumnType[i].iType
91331>>>            Move "date"             to ColumnType[i].sType
91332>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
91333>>>            Move "Date"             to ColumnType[i].sDataFlexType
91334>>>            Move "6.0"              to ColumnType[i].sPrecision
91335>>>            Move True               to ColumnType[i].bFixedSize
91336>>>            Increment i
91337>>>
91337>>>            Move SQL_DATETIME       to ColumnType[i].iType
91338>>>            Move "datetime"         to ColumnType[i].sType
91339>>>            Move DF_DATETIME        to ColumnType[i].iDataFlexType
91340>>>            Move "DateTime"         to ColumnType[i].sDataFlexType
91341>>>            Move "23.3"             to ColumnType[i].sPrecision
91342>>>            Move True               to ColumnType[i].bFixedSize
91343>>>            Increment i
91344>>>
91344>>>            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iType
91345>>>            Move "datetime2"         to ColumnType[i].sType
91346>>>            Move DF_DATETIME         to ColumnType[i].iDataFlexType
91347>>>            Move "DateTime"          to ColumnType[i].sDataFlexType
91348>>>            Move "23.6"              to ColumnType[i].sPrecision
91349>>>            Move True                to ColumnType[i].bFixedSize
91350>>>            Increment i
91351>>>
91351>>>            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iType
91352>>>            Move "datetimeoffset"       to ColumnType[i].sType
91353>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
91354>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
91355>>>            Move "34.0"                 to ColumnType[i].sPrecision
91356>>>            Move True                   to ColumnType[i].bFixedSize
91357>>>            Increment i
91358>>>
91358>>>            Move SQL_DECIMAL        to ColumnType[i].iType
91359>>>            Move "decimal"          to ColumnType[i].sType
91360>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91361>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91362>>>            Move "14.8"             to ColumnType[i].sPrecision
91363>>>            Increment i
91364>>>
91364>>>            Move SQL_FLOAT          to ColumnType[i].iType
91365>>>            Move "float"            to ColumnType[i].sType
91366>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91367>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91368>>>            Move "14.8"             to ColumnType[i].sPrecision
91369>>>            Increment i
91370>>>
91370>>>            Move SQL_INTEGER        to ColumnType[i].iType
91371>>>            Move "int"              to ColumnType[i].sType
91372>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91373>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91374>>>            Move "8.0"              to ColumnType[i].sPrecision
91375>>>            Move True               to ColumnType[i].bFixedSize
91376>>>            Increment i
91377>>>
91377>>>            Move SQL_TYPE_MONEY     to ColumnType[i].iType
91378>>>            Move "money"            to ColumnType[i].sType
91379>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91380>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91381>>>            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
91382>>>            Increment i
91383>>>
91383>>>            Move SQL_WCHAR          to ColumnType[i].iType
91384>>>            Move "nchar"            to ColumnType[i].sType
91385>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91386>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91387>>>            Move "4000"             to ColumnType[i].sPrecision
91388>>>            Increment i
91389>>>
91389>>>            Move SQL_WLONGVARCHAR   to ColumnType[i].iType
91390>>>            Move "ntext"            to ColumnType[i].sType
91391>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91392>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91393>>>            Move "16384"            to ColumnType[i].sPrecision
91394>>>            Increment i
91395>>>
91395>>>            Move SQL_NUMERIC        to ColumnType[i].iType
91396>>>            Move "numeric"          to ColumnType[i].sType
91397>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91398>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91399>>>            Move "14.8"             to ColumnType[i].sPrecision
91400>>>            Increment i
91401>>>
91401>>>            Move SQL_WVARCHAR       to ColumnType[i].iType
91402>>>            Move "nvarchar"         to ColumnType[i].sType
91403>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91404>>>            Move "Text"             to ColumnType[i].sDataFlexType
91405>>>            Move "4000"             to ColumnType[i].sPrecision
91406>>>            Increment i
91407>>>
91407>>>            Move SQL_VARCHARMAX     to ColumnType[i].iType
91408>>>            Move "nvarchar(max)"    to ColumnType[i].sType
91409>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91410>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91411>>>            Move "16384"            to ColumnType[i].sPrecision
91412>>>            Move True               to ColumnType[i].bFixedSize
91413>>>            Increment i
91414>>>
91414>>>            Move SQL_REAL           to ColumnType[i].iType
91415>>>            Move "real"             to ColumnType[i].sType
91416>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91417>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
91418>>>            Move "14.8"             to ColumnType[i].sPrecision
91419>>>            Increment i
91420>>>
91420>>>            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iType
91421>>>            Move "smalldatetime"        to ColumnType[i].sType
91422>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
91423>>>            Move "DATETIME"             to ColumnType[i].sDataFlexType
91424>>>            Move "23.0"                 to ColumnType[i].sPrecision
91425>>>            Move True                   to ColumnType[i].bFixedSize
91426>>>            Increment i
91427>>>
91427>>>            Move SQL_SMALLINT       to ColumnType[i].iType
91428>>>            Move "smallint"         to ColumnType[i].sType
91429>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91430>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
91431>>>            Move "4.0"              to ColumnType[i].sPrecision
91432>>>            Move True               to ColumnType[i].bFixedSize
91433>>>            Increment i
91434>>>
91434>>>            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iType
91435>>>            Move "smallmoney"        to ColumnType[i].sType
91436>>>            Move DF_BCD              to ColumnType[i].iDataFlexType
91437>>>            Move "NUMERIC"           to ColumnType[i].sDataFlexType
91438>>>            Move "10.0"              to ColumnType[i].sPrecision
91439>>>            Increment i
91440>>>
91440>>>            Move SQL_TEXT           to ColumnType[i].iType
91441>>>            Move "text"             to ColumnType[i].sType
91442>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91443>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91444>>>            Move "8000"             to ColumnType[i].sPrecision
91445>>>            Move True               to ColumnType[i].bFixedSize
91446>>>            Increment i
91447>>>
91447>>>            Move SQL_TIME           to ColumnType[i].iType
91448>>>            Move "time"             to ColumnType[i].sType
91449>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91450>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91451>>>            Move "19.0"             to ColumnType[i].sPrecision
91452>>>            Move True               to ColumnType[i].bFixedSize
91453>>>            Increment i
91454>>>
91454>>>            Move SQL_TINYINT        to ColumnType[i].iType
91455>>>            Move "tinyint"          to ColumnType[i].sType
91456>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91457>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
91458>>>            Move "2.0"              to ColumnType[i].sPrecision
91459>>>            Move True               to ColumnType[i].bFixedSize
91460>>>            Increment i
91461>>>
91461>>>            Move SQL_GUID           to ColumnType[i].iType
91462>>>            Move "uniqueidentifier" to ColumnType[i].sType
91463>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91464>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91465>>>            Move "36"               to ColumnType[i].sPrecision
91466>>>            Move True               to ColumnType[i].bFixedSize
91467>>>            Increment i
91468>>>
91468>>>            Move SQL_VARBINARY      to ColumnType[i].iType
91469>>>            Move "varbinary"        to ColumnType[i].sType
91470>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
91471>>>            Move "BINARY"           to ColumnType[i].sDataFlexType
91472>>>            Move "16384"            to ColumnType[i].sPrecision
91473>>>            Increment i
91474>>>
91474>>>            Move SQL_LONGVARBINARY  to ColumnType[i].iType
91475>>>            Move "varbinary(max)"   to ColumnType[i].sType
91476>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
91477>>>            Move "BINARY"           to ColumnType[i].sDataFlexType
91478>>>            Move "16384"            to ColumnType[i].sPrecision
91479>>>            Move True               to ColumnType[i].bFixedSize
91480>>>            Increment i
91481>>>
91481>>>            Move SQL_VARCHAR        to ColumnType[i].iType
91482>>>            Move "varchar"          to ColumnType[i].sType
91483>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
91484>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91485>>>            Move "8000"             to ColumnType[i].sPrecision
91486>>>            Increment i
91487>>>
91487>>>            Move SQL_LONGVARCHAR    to ColumnType[i].iType
91488>>>            Move "varchar(max)"     to ColumnType[i].sType
91489>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91490>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91491>>>            Move "16384"            to ColumnType[i].sPrecision
91492>>>            Move True               to ColumnType[i].bFixedSize
91493>>>            Increment i
91494>>>
91494>>>            Move SQL_SS_XML         to ColumnType[i].iType
91495>>>            Move "xml"              to ColumnType[i].sType
91496>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91497>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91498>>>            Move "16384"            to ColumnType[i].sPrecision
91499>>>            Increment i
91500>>>
91500>>>            Move SQL_TYPE_DATE      to ColumnType[i].iType
91501>>>            Move "DATE"             to ColumnType[i].sType
91502>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
91503>>>            Move "date"             to ColumnType[i].sDataFlexType
91504>>>            Move "6.0"              to ColumnType[i].sPrecision
91505>>>            Move True               to ColumnType[i].bFixedSize
91506>>>            Increment i
91507>>>
91507>>>            Move SQL_TYPE_TIME      to ColumnType[i].iType
91508>>>            Move "time"             to ColumnType[i].sType
91509>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91510>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91511>>>            Move "8.7"              to ColumnType[i].sPrecision
91512>>>            Move True               to ColumnType[i].bFixedSize
91513>>>            Increment i
91514>>>
91514>>>            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iType
91515>>>            Move "datetime"         to ColumnType[i].sType
91516>>>            Move DF_DATETIME        to ColumnType[i].iDataFlexType
91517>>>            Move "DateTime"         to ColumnType[i].sDataFlexType
91518>>>            Move "23.6"             to ColumnType[i].sPrecision
91519>>>            Move True               to ColumnType[i].bFixedSize
91520>>>            Increment i
91521>>>
91521>>>        End
91521>>>>
91521>>>
91521>>>        // Mertech SQLFlex driver
91521>>>        If (sDriverID = SQLFLEX) Begin
91523>>>            Move eSQLServer_BIGINT  to ColumnType[i].iType
91524>>>            Move "BigInt"           to ColumnType[i].sType
91525>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91526>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91527>>>            Move "14.0"             to ColumnType[i].sPrecision
91528>>>            Move True               to ColumnType[i].bFixedSize
91529>>>            Increment i
91530>>>
91530>>>            Move eSQLServer_BINARY  to ColumnType[i].iType
91531>>>            Move "Binary"           to ColumnType[i].sType
91532>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
91533>>>            Move "Binary"           to ColumnType[i].sDataFlexType
91534>>>            Move "8000"             to ColumnType[i].sPrecision
91535>>>            Increment i
91536>>>
91536>>>            Move eSQLServer_BIT     to ColumnType[i].iType
91537>>>            Move "Bit"              to ColumnType[i].sType
91538>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91539>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91540>>>            Move "1.0"              to ColumnType[i].sPrecision
91541>>>            Move True               to ColumnType[i].bFixedSize // In SQL allows 1, 0, or "NULL"
91542>>>            Increment i
91543>>>
91543>>>            Move eSQLServer_CHAR    to ColumnType[i].iType
91544>>>            Move "Char"             to ColumnType[i].sType
91545>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91546>>>            Move "Text"             to ColumnType[i].sDataFlexType
91547>>>            Move "8000"             to ColumnType[i].sPrecision
91548>>>            Increment i
91549>>>
91549>>>            Move eSQLServer_DATE    to ColumnType[i].iType
91550>>>            Move "Date"             to ColumnType[i].sType
91551>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
91552>>>            Move "Date"             to ColumnType[i].sDataFlexType
91553>>>            Move "6.0"              to ColumnType[i].sPrecision
91554>>>            Move True               to ColumnType[i].bFixedSize
91555>>>            Increment i
91556>>>
91556>>>            Move eSQLServer_DATETIME    to ColumnType[i].iType
91557>>>            Move "DateTime"             to ColumnType[i].sType
91558>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
91559>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
91560>>>            Move "23.3"                 to ColumnType[i].sPrecision
91561>>>            Move True                   to ColumnType[i].bFixedSize
91562>>>            Increment i
91563>>>
91563>>>            Move eSQLServer_DATETIME2   to ColumnType[i].iType
91564>>>            Move "DateTime2"            to ColumnType[i].sType
91565>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
91566>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
91567>>>            Move "23.6"                 to ColumnType[i].sPrecision
91568>>>            Move True                   to ColumnType[i].bFixedSize
91569>>>            Increment i
91570>>>
91570>>>            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iType
91571>>>            Move "DateTimeOffest"           to ColumnType[i].sType
91572>>>            Move DF_DATETIME                to ColumnType[i].iDataFlexType
91573>>>            Move "DateTime"                 to ColumnType[i].sDataFlexType
91574>>>            Move "23.0"                     to ColumnType[i].sPrecision
91575>>>            Move True                       to ColumnType[i].bFixedSize
91576>>>            Increment i
91577>>>
91577>>>            Move eSQLServer_DECIMAL to ColumnType[i].iType
91578>>>            Move "Decimal"          to ColumnType[i].sType
91579>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91580>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91581>>>            Move "14.8"             to ColumnType[i].sPrecision
91582>>>            Increment i
91583>>>
91583>>>            Move eSQLServer_DOUBLE  to ColumnType[i].iType
91584>>>            Move "Double"           to ColumnType[i].sType
91585>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91586>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91587>>>            Move "14.8"             to ColumnType[i].sPrecision
91588>>>            Increment i
91589>>>
91589>>>            Move eSQLServer_FLOAT   to ColumnType[i].iType
91590>>>            Move "Float"            to ColumnType[i].sType
91591>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91592>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91593>>>            Move "14.8"             to ColumnType[i].sPrecision
91594>>>            Increment i
91595>>>
91595>>>            Move eSQLServer_INT     to ColumnType[i].iType
91596>>>            Move "Int"              to ColumnType[i].sType
91597>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91598>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91599>>>            Move "11.0"             to ColumnType[i].sPrecision
91600>>>            Increment i
91601>>>
91601>>>            Move eSQLServer_NCHAR   to ColumnType[i].iType
91602>>>            Move "Nchar"            to ColumnType[i].sType
91603>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91604>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91605>>>            Move "4000"             to ColumnType[i].sPrecision
91606>>>            Increment i
91607>>>
91607>>>            Move eSQLServer_NTEXT   to ColumnType[i].iType
91608>>>            Move "Ntext"            to ColumnType[i].sType
91609>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91610>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91611>>>            Move "16384"            to ColumnType[i].sPrecision
91612>>>            Increment i
91613>>>
91613>>>            Move eSQLServer_NUMERIC to ColumnType[i].iType
91614>>>            Move "Numeric"          to ColumnType[i].sType
91615>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91616>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91617>>>            Move "14.8"             to ColumnType[i].sPrecision
91618>>>            Increment i
91619>>>
91619>>>            Move eSQLServer_NVARCHAR    to ColumnType[i].iType
91620>>>            Move "NvarChar"             to ColumnType[i].sType
91621>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
91622>>>            Move "Text"                 to ColumnType[i].sDataFlexType
91623>>>            Move "4000"                 to ColumnType[i].sPrecision
91624>>>            Increment i
91625>>>
91625>>>            Move eSQLServer_NVARCHARMAX to ColumnType[i].iType
91626>>>            Move "NvarCharMax"          to ColumnType[i].sType
91627>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
91628>>>            Move "Text"                 to ColumnType[i].sDataFlexType
91629>>>            Move "16384"                to ColumnType[i].sPrecision
91630>>>            Move True                   to ColumnType[i].bFixedSize
91631>>>            Increment i
91632>>>
91632>>>            Move eSQLServer_REAL    to ColumnType[i].iType
91633>>>            Move "Real"             to ColumnType[i].sType
91634>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91635>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
91636>>>            Move "14.8"             to ColumnType[i].sPrecision
91637>>>            Increment i
91638>>>
91638>>>            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iType
91639>>>            Move "SmallDateTime"            to ColumnType[i].sType
91640>>>            Move DF_DATETIME                to ColumnType[i].iDataFlexType
91641>>>            Move "DATETIME"                 to ColumnType[i].sDataFlexType
91642>>>            Move "23.0"                     to ColumnType[i].sPrecision
91643>>>            Move True                       to ColumnType[i].bFixedSize
91644>>>            Increment i
91645>>>
91645>>>            Move eSQLServer_SMALLINT    to ColumnType[i].iType
91646>>>            Move "SmallInt"             to ColumnType[i].sType
91647>>>            Move DF_BCD                 to ColumnType[i].iDataFlexType
91648>>>            Move "NUMERIC"              to ColumnType[i].sDataFlexType
91649>>>            Move "6.0"                  to ColumnType[i].sPrecision
91650>>>            Increment i
91651>>>
91651>>>            Move eSQLServer_TEXT    to ColumnType[i].iType
91652>>>            Move "Text"             to ColumnType[i].sType
91653>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91654>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91655>>>            Move "8000"             to ColumnType[i].sPrecision
91656>>>            Move True               to ColumnType[i].bFixedSize
91657>>>            Increment i
91658>>>
91658>>>            Move eSQLServer_TIME    to ColumnType[i].iType
91659>>>            Move "Time"             to ColumnType[i].sType
91660>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91661>>>            Move "Date"             to ColumnType[i].sDataFlexType
91662>>>            Move "16.0"             to ColumnType[i].sPrecision
91663>>>            Move True               to ColumnType[i].bFixedSize
91664>>>            Increment i
91665>>>
91665>>>            Move eSQLServer_TIMESTAMP   to ColumnType[i].iType
91666>>>            Move "TimeStamp"            to ColumnType[i].sType
91667>>>            Move DF_ASCII               to ColumnType[i].iDataFlexType
91668>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
91669>>>            Move "8.0"                  to ColumnType[i].sPrecision
91670>>>            Move True                   to ColumnType[i].bFixedSize
91671>>>            Increment i
91672>>>
91672>>>            Move eSQLServer_TINYINT to ColumnType[i].iType
91673>>>            Move "TinyInt"          to ColumnType[i].sType
91674>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
91675>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
91676>>>            Move "3.0"              to ColumnType[i].sPrecision
91677>>>            Increment i
91678>>>
91678>>>            Move eSQLServer_GUID    to ColumnType[i].iType
91679>>>            Move "UniqueIdentifier" to ColumnType[i].sType
91680>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
91681>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
91682>>>            Move "38"               to ColumnType[i].sPrecision
91683>>>            Move True               to ColumnType[i].bFixedSize
91684>>>            Increment i
91685>>>
91685>>>            Move eSQLServer_VARBINARY   to ColumnType[i].iType
91686>>>            Move "VarBinary"            to ColumnType[i].sType
91687>>>            Move DF_BINARY              to ColumnType[i].iDataFlexType
91688>>>            Move "BINARY"               to ColumnType[i].sDataFlexType
91689>>>            Move "8000"                 to ColumnType[i].sPrecision
91690>>>            Increment i
91691>>>
91691>>>            Move eSQLServer_VARBINARYMAX to ColumnType[i].iType
91692>>>            Move "VarBinary(Max)"        to ColumnType[i].sType
91693>>>            Move DF_BINARY               to ColumnType[i].iDataFlexType
91694>>>            Move "BINARY"                to ColumnType[i].sDataFlexType
91695>>>            Move "16384"                 to ColumnType[i].sPrecision
91696>>>            Move True                    to ColumnType[i].bFixedSize
91697>>>            Increment i
91698>>>
91698>>>            Move eSQLServer_VARCHAR to ColumnType[i].iType
91699>>>            Move "VarChar"          to ColumnType[i].sType
91700>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
91701>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91702>>>            Move "8000"             to ColumnType[i].sPrecision
91703>>>            Increment i
91704>>>
91704>>>            Move eSQLServer_VARCHARMAX  to ColumnType[i].iType
91705>>>            Move "VarChar(Max)"         to ColumnType[i].sType
91706>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
91707>>>            Move "TEXT"                 to ColumnType[i].sDataFlexType
91708>>>            Move "16384"                to ColumnType[i].sPrecision
91709>>>            Move True                   to ColumnType[i].bFixedSize
91710>>>            Increment i
91711>>>
91711>>>            Move eSQLServer_SQLVARIANT  to ColumnType[i].iType
91712>>>            Move "SQL_Variant"          to ColumnType[i].sType
91713>>>            Move DF_BINARY              to ColumnType[i].iDataFlexType
91714>>>            Move "Binary"               to ColumnType[i].sDataFlexType
91715>>>            Move "8016"                 to ColumnType[i].sPrecision
91716>>>            Move True                   to ColumnType[i].bFixedSize
91717>>>            Increment i
91718>>>
91718>>>            Move eSQLServer_XML     to ColumnType[i].iType
91719>>>            Move "XML"              to ColumnType[i].sType
91720>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
91721>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
91722>>>            Move "16384"            to ColumnType[i].sPrecision
91723>>>        End
91723>>>>
91723>>>
91723>>>        Function_Return ColumnType
91724>>>    End_Function
91725>>>
91725>>>    // MySQL Data Types
91725>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
91727>>>        tColumnType[] ColumnType
91727>>>        tColumnType[] ColumnType
91728>>>        Integer i
91728>>>
91728>>>        Move eMySQL_LONGLONG    to ColumnType[i].iType
91729>>>        Move "bigint"           to ColumnType[i].sType
91730>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91731>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91732>>>        Move "14.0"             to ColumnType[i].sPrecision
91733>>>        Increment i
91734>>>
91734>>>        Move eMySQL_BIT         to ColumnType[i].iType
91735>>>        Move "bit"              to ColumnType[i].sType
91736>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91737>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91738>>>        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
91739>>>        Move True               to ColumnType[i].bFixedSize
91740>>>        Increment i
91741>>>
91741>>>        Move eMySQL_BLOB        to ColumnType[i].iType
91742>>>        Move "blob"             to ColumnType[i].sType
91743>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91744>>>        Move "BINARY"           to ColumnType[i].sDataFlexType
91745>>>        Move "16384"            to ColumnType[i].sPrecision
91746>>>        Increment i
91747>>>
91747>>>        Move eMySQL_STRING      to ColumnType[i].iType
91748>>>        Move "char"             to ColumnType[i].sType
91749>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91750>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
91751>>>        Move "254"              to ColumnType[i].sPrecision
91752>>>        Increment i
91753>>>
91753>>>        Move eMySQL_DATE        to ColumnType[i].iType
91754>>>        Move "date"             to ColumnType[i].sType
91755>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
91756>>>        Move "Date"             to ColumnType[i].sDataFlexType
91757>>>        Move "6.0"              to ColumnType[i].sPrecision
91758>>>        Move True               to ColumnType[i].bFixedSize
91759>>>        Increment i
91760>>>
91760>>>        Move eMySQL_DATETIME    to ColumnType[i].iType
91761>>>        Move "datetime"         to ColumnType[i].sType
91762>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91763>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
91764>>>        Move "23.0"             to ColumnType[i].sPrecision
91765>>>        Move True               to ColumnType[i].bFixedSize
91766>>>        Increment i
91767>>>
91767>>>        Move eMySQL_DECIMAL     to ColumnType[i].iType
91768>>>        Move "decimal"          to ColumnType[i].sType
91769>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91770>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91771>>>        Move "14.8"             to ColumnType[i].sPrecision
91772>>>        Increment i
91773>>>
91773>>>        Move eMySQL_DOUBLE      to ColumnType[i].iType
91774>>>        Move "double"           to ColumnType[i].sType
91775>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91776>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91777>>>        Move "14.8"             to ColumnType[i].sPrecision
91778>>>        Increment i
91779>>>
91779>>>        Move eMySQL_ENUM        to ColumnType[i].iType
91780>>>        Move "enum"             to ColumnType[i].sType
91781>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91782>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91783>>>        Move "254"              to ColumnType[i].sPrecision
91784>>>        Increment i
91785>>>
91785>>>        Move eMySQL_FLOAT       to ColumnType[i].iType
91786>>>        Move "float"            to ColumnType[i].sType
91787>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91788>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91789>>>        Move "14.8"             to ColumnType[i].sPrecision
91790>>>        Increment i
91791>>>
91791>>>        Move eMySQL_INT24       to ColumnType[i].iType
91792>>>        Move "int"              to ColumnType[i].sType
91793>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91794>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
91795>>>        Move "11.0"             to ColumnType[i].sPrecision
91796>>>        Increment i
91797>>>
91797>>>        Move eMySQL_LONG_BLOB   to ColumnType[i].iType
91798>>>        Move "longblob"         to ColumnType[i].sType
91799>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91800>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91801>>>        Move "16384"            to ColumnType[i].sPrecision
91802>>>        Increment i
91803>>>
91803>>>        Move eMySQL_LONG_TEXT   to ColumnType[i].iType
91804>>>        Move "longtext"         to ColumnType[i].sType
91805>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91806>>>        Move "Text"             to ColumnType[i].sDataFlexType
91807>>>        Move "16384"            to ColumnType[i].sPrecision
91808>>>        Increment i
91809>>>
91809>>>        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iType
91810>>>        Move "mediumblob"       to ColumnType[i].sType
91811>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91812>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91813>>>        Move "16384"            to ColumnType[i].sPrecision
91814>>>        Increment i
91815>>>
91815>>>        Move eMySQL_INT24       to ColumnType[i].iType
91816>>>        Move "mediumint"        to ColumnType[i].sType
91817>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91818>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91819>>>        Move "9.0"              to ColumnType[i].sPrecision
91820>>>
91820>>>        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iType
91821>>>        Move "mediumtext"       to ColumnType[i].sType
91822>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91823>>>        Move "Text"             to ColumnType[i].sDataFlexType
91824>>>        Move "16384"            to ColumnType[i].sPrecision
91825>>>        Increment i
91826>>>
91826>>>        Move eMySQL_SET         to ColumnType[i].iType
91827>>>        Move "set"              to ColumnType[i].sType
91828>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91829>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91830>>>        Move "254"              to ColumnType[i].sPrecision
91831>>>        Increment i
91832>>>
91832>>>        Move eMySQL_SHORT       to ColumnType[i].iType
91833>>>        Move "smallint"         to ColumnType[i].sType
91834>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91835>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91836>>>        Move "6.0"              to ColumnType[i].sPrecision
91837>>>        Increment i
91838>>>
91838>>>        Move eMySQL_TEXT        to ColumnType[i].iType
91839>>>        Move "text"             to ColumnType[i].sType
91840>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91841>>>        Move "Text"             to ColumnType[i].sDataFlexType
91842>>>        Move "16384"            to ColumnType[i].sPrecision
91843>>>        Increment i
91844>>>
91844>>>        Move eMySQL_TIME        to ColumnType[i].iType
91845>>>        Move "time"             to ColumnType[i].sType
91846>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
91847>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
91848>>>        Move "10.0"             to ColumnType[i].sPrecision
91849>>>        Move True               to ColumnType[i].bFixedSize
91850>>>        Increment i
91851>>>
91851>>>        Move eMySQL_TIMESTAMP   to ColumnType[i].iType
91852>>>        Move "timestamp"        to ColumnType[i].sType
91853>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91854>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
91855>>>        Move "23.0"             to ColumnType[i].sPrecision
91856>>>        Move True               to ColumnType[i].bFixedSize
91857>>>        Increment i
91858>>>
91858>>>        Move eMySQL_TINY_BLOB   to ColumnType[i].iType
91859>>>        Move "tinyblob"         to ColumnType[i].sType
91860>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91861>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91862>>>        Move "254"              to ColumnType[i].sPrecision
91863>>>        Increment i
91864>>>
91864>>>        Move eMySQL_TINY        to ColumnType[i].iType
91865>>>        Move "tinyint"          to ColumnType[i].sType
91866>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91867>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
91868>>>        Move "4.0"              to ColumnType[i].sPrecision
91869>>>        Increment i
91870>>>
91870>>>        Move eMySQL_TINY_TEXT   to ColumnType[i].iType
91871>>>        Move "tinytext"         to ColumnType[i].sType
91872>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91873>>>        Move "Text"             to ColumnType[i].sDataFlexType
91874>>>        Move "254"              to ColumnType[i].sPrecision
91875>>>        Increment i
91876>>>
91876>>>        Move eMySQL_VAR_STRING  to ColumnType[i].iType
91877>>>        Move "varchar"          to ColumnType[i].sType
91878>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91879>>>        Move "Text"             to ColumnType[i].sDataFlexType
91880>>>        Move "16384"            to ColumnType[i].sPrecision
91881>>>        Increment i
91882>>>
91882>>>        Move eMySQL_YEAR        to ColumnType[i].iType
91883>>>        Move "year"             to ColumnType[i].sType
91884>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91885>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
91886>>>        Move "4.0"              to ColumnType[i].sPrecision
91887>>>        Move True               to ColumnType[i].bFixedSize
91888>>>        Increment i
91889>>>
91889>>>        Function_Return ColumnType
91890>>>    End_Function
91891>>>
91891>>>    // Oracle Data Types
91891>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
91893>>>        tColumnType[] ColumnType
91893>>>        tColumnType[] ColumnType
91894>>>        Integer i
91894>>>
91894>>>        Move eOracle_BLOB       to ColumnType[i].iType
91895>>>        Move "BLOB"             to ColumnType[i].sType
91896>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91897>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91898>>>        Move "16384"            to ColumnType[i].sPrecision
91899>>>        Increment i
91900>>>
91900>>>        Move eOracle_CHAR       to ColumnType[i].iType
91901>>>        Move "CHAR"             to ColumnType[i].sType
91902>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91903>>>        Move "Text"             to ColumnType[i].sDataFlexType
91904>>>        Move "2000"             to ColumnType[i].sPrecision
91905>>>        Increment i
91906>>>
91906>>>        Move eOracle_CLOB       to ColumnType[i].iType
91907>>>        Move "CLOB"             to ColumnType[i].sType
91908>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91909>>>        Move "Text"             to ColumnType[i].sDataFlexType
91910>>>        Move "16384"            to ColumnType[i].sPrecision
91911>>>        Increment i
91912>>>
91912>>>        Move eOracle_DATE       to ColumnType[i].iType
91913>>>        Move "DATE"             to ColumnType[i].sType
91914>>>        Move DF_Date            to ColumnType[i].iDataFlexType
91915>>>        Move "Date"             to ColumnType[i].sDataFlexType
91916>>>        Move "6.0"              to ColumnType[i].sPrecision
91917>>>        Move True               to ColumnType[i].bFixedSize
91918>>>        Increment i
91919>>>
91919>>>        Move eOracle_FLOAT      to ColumnType[i].iType
91920>>>        Move "FLOAT"            to ColumnType[i].sType
91921>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91922>>>        Move "Number"           to ColumnType[i].sDataFlexType
91923>>>        Move "14.8"             to ColumnType[i].sPrecision
91924>>>        Increment i
91925>>>
91925>>>        Move eOracle_INT        to ColumnType[i].iType
91926>>>        Move "INT"              to ColumnType[i].sType
91927>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91928>>>        Move "Number"           to ColumnType[i].sDataFlexType
91929>>>        Move "14.0"             to ColumnType[i].sPrecision
91930>>>        Increment i
91931>>>
91931>>>        Move eOracle_INTERVALDS to ColumnType[i].iType
91932>>>        Move "INTERVALDAYTOSEC" to ColumnType[i].sType
91933>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91934>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
91935>>>        Move "23.0"             to ColumnType[i].sPrecision
91936>>>        Move True               to ColumnType[i].bFixedSize
91937>>>        Increment i
91938>>>
91938>>>        Move eOracle_INTERVALYM  to ColumnType[i].iType
91939>>>        Move "INTERVALYEARTOMON" to ColumnType[i].sType
91940>>>        Move DF_DATETIME         to ColumnType[i].iDataFlexType
91941>>>        Move "DateTime"          to ColumnType[i].sDataFlexType
91942>>>        Move "23.0"              to ColumnType[i].sPrecision
91943>>>        Move True                to ColumnType[i].bFixedSize
91944>>>        Increment i
91945>>>
91945>>>        Move eOracle_RAW        to ColumnType[i].iType
91946>>>        Move "LONG"             to ColumnType[i].sType
91947>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91948>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91949>>>        Move "16384"            to ColumnType[i].sPrecision
91950>>>        Increment i
91951>>>
91951>>>        Move eOracle_LONGRAW    to ColumnType[i].iType
91952>>>        Move "LONG RAW"         to ColumnType[i].sType
91953>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91954>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91955>>>        Move "16384"            to ColumnType[i].sPrecision
91956>>>        Increment i
91957>>>
91957>>>        Move eOracle_NCHAR      to ColumnType[i].iType
91958>>>        Move "NCHAR"            to ColumnType[i].sType
91959>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91960>>>        Move "Text"             to ColumnType[i].sDataFlexType
91961>>>        Move "2000"             to ColumnType[i].sPrecision
91962>>>        Increment i
91963>>>
91963>>>        Move eOracle_NCLOB      to ColumnType[i].iType
91964>>>        Move "NCLOB"            to ColumnType[i].sType
91965>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91966>>>        Move "Text"             to ColumnType[i].sDataFlexType
91967>>>        Move "16384"            to ColumnType[i].sPrecision
91968>>>        Increment i
91969>>>
91969>>>        Move eOracle_NUMBER     to ColumnType[i].iType
91970>>>        Move "NUMBER"           to ColumnType[i].sType
91971>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
91972>>>        Move "Number"           to ColumnType[i].sDataFlexType
91973>>>        Move "14.8"             to ColumnType[i].sPrecision
91974>>>        Increment i
91975>>>
91975>>>        Move eOracle_NVARCHAR2  to ColumnType[i].iType
91976>>>        Move "NVARCHAR2"        to ColumnType[i].sType
91977>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91978>>>        Move "Text"             to ColumnType[i].sDataFlexType
91979>>>        Move "4000"             to ColumnType[i].sPrecision
91980>>>        Increment i
91981>>>
91981>>>        Move eOracle_RAW        to ColumnType[i].iType
91982>>>        Move "RAW"              to ColumnType[i].sType
91983>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
91984>>>        Move "Binary"           to ColumnType[i].sDataFlexType
91985>>>        Move "2000"             to ColumnType[i].sPrecision
91986>>>        Increment i
91987>>>
91987>>>        Move eOracle_ROWID      to ColumnType[i].iType
91988>>>        Move "ROWID"            to ColumnType[i].sType
91989>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
91990>>>        Move "Text"             to ColumnType[i].sDataFlexType
91991>>>        Move "16384"            to ColumnType[i].sPrecision
91992>>>        Increment i
91993>>>
91993>>>        Move eOracle_TIMESTAMP  to ColumnType[i].iType
91994>>>        Move "TimeStamp"        to ColumnType[i].sType
91995>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
91996>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
91997>>>        Move "11.0"             to ColumnType[i].sPrecision
91998>>>        Move True               to ColumnType[i].bFixedSize
91999>>>        Increment i
92000>>>
92000>>>        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iType
92001>>>        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sType
92002>>>        Move DF_DATETIME            to ColumnType[i].iDataFlexType
92003>>>        Move "DateTime"             to ColumnType[i].sDataFlexType
92004>>>        Move "13.0"                 to ColumnType[i].sPrecision
92005>>>        Move True                   to ColumnType[i].bFixedSize
92006>>>        Increment i
92007>>>
92007>>>        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iType
92008>>>        Move "TIMEZONETIMEZONE"     to ColumnType[i].sType
92009>>>        Move DF_DATETIME            to ColumnType[i].iDataFlexType
92010>>>        Move "DateTime"             to ColumnType[i].sDataFlexType
92011>>>        Move "11.0"                 to ColumnType[i].sPrecision
92012>>>        Move True                   to ColumnType[i].bFixedSize
92013>>>        Increment i
92014>>>
92014>>>        Move eOracle_VARCHAR2   to ColumnType[i].iType
92015>>>        Move "VARCHAR"          to ColumnType[i].sType
92016>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92017>>>        Move "Text"             to ColumnType[i].sDataFlexType
92018>>>        Move "16384"            to ColumnType[i].sPrecision
92019>>>
92019>>>        Function_Return ColumnType
92020>>>    End_Function
92021>>>
92021>>>    // PostgreSQL Data Types
92021>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
92023>>>        tColumnType[] ColumnType
92023>>>        tColumnType[] ColumnType
92024>>>        Integer i
92024>>>
92024>>>        Move ePgSQL_INT8        to ColumnType[i].iType
92025>>>        Move "bigint"           to ColumnType[i].sType
92026>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92027>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92028>>>        Move "14.0"             to ColumnType[i].sPrecision
92029>>>        Move True               to ColumnType[i].bFixedSize
92030>>>        Increment i
92031>>>
92031>>>        Move ePgSQL_BIT         to ColumnType[i].iType
92032>>>        Move "bit"              to ColumnType[i].sType
92033>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92034>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92035>>>        Move "16384"            to ColumnType[i].sPrecision
92036>>>        Increment i
92037>>>
92037>>>        Move ePgSQL_BOOL        to ColumnType[i].iType
92038>>>        Move "boolean"          to ColumnType[i].sType
92039>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92040>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92041>>>        Move "1"                to ColumnType[i].sPrecision
92042>>>        Increment i
92043>>>
92043>>>        Move ePgSQL_BYTEA       to ColumnType[i].iType
92044>>>        Move "bytea"            to ColumnType[i].sType
92045>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92046>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92047>>>        Move "16384"            to ColumnType[i].sPrecision
92048>>>        Increment i
92049>>>
92049>>>        Move ePgSQL_CHAR        to ColumnType[i].iType
92050>>>        Move "char"             to ColumnType[i].sType
92051>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92052>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92053>>>        Move "2000"             to ColumnType[i].sPrecision
92054>>>        Increment i
92055>>>
92055>>>        Move ePgSQL_CITEXT      to ColumnType[i].iType
92056>>>        Move "citext"           to ColumnType[i].sType
92057>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92058>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92059>>>        Move "254"              to ColumnType[i].sPrecision
92060>>>        Increment i
92061>>>
92061>>>        Move ePgSQL_DATE        to ColumnType[i].iType
92062>>>        Move "date"             to ColumnType[i].sType
92063>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
92064>>>        Move "Date"             to ColumnType[i].sDataFlexType
92065>>>        Move "6.0"              to ColumnType[i].sPrecision
92066>>>        Move True               to ColumnType[i].bFixedSize
92067>>>        Increment i
92068>>>
92068>>>        Move ePgSQL_FLOAT4      to ColumnType[i].iType
92069>>>        Move "decimal"          to ColumnType[i].sType
92070>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92071>>>        Move "Decimal"          to ColumnType[i].sDataFlexType
92072>>>        Move "14.8"             to ColumnType[i].sPrecision
92073>>>        Increment i
92074>>>
92074>>>        Move ePgSQL_FLOAT8      to ColumnType[i].iType
92075>>>        Move "double"           to ColumnType[i].sType
92076>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92077>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92078>>>        Move "22"               to ColumnType[i].sPrecision
92079>>>        Increment i
92080>>>
92080>>>        Move ePgSQL_INT4        to ColumnType[i].iType
92081>>>        Move "integer"          to ColumnType[i].sType
92082>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92083>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92084>>>        Move "8.0"              to ColumnType[i].sPrecision
92085>>>        Increment i
92086>>>
92086>>>        Move ePgSQL_MONEY       to ColumnType[i].iType
92087>>>        Move "money"            to ColumnType[i].sType
92088>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92089>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92090>>>        Move "8.0"              to ColumnType[i].sPrecision
92091>>>        Increment i
92092>>>
92092>>>        Move ePgSQL_OID         to ColumnType[i].iType
92093>>>        Move "oid"              to ColumnType[i].sType
92094>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92095>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92096>>>        Move "16384"            to ColumnType[i].sPrecision
92097>>>        Increment i
92098>>>
92098>>>        Move ePgSQL_FLOAT4      to ColumnType[i].iType
92099>>>        Move "real"             to ColumnType[i].sType
92100>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92101>>>        Move "Real"             to ColumnType[i].sDataFlexType
92102>>>        Move "6.6"              to ColumnType[i].sPrecision
92103>>>        Increment i
92104>>>
92104>>>        Move ePgSQL_REGPROC     to ColumnType[i].iType
92105>>>        Move "regproc"          to ColumnType[i].sType
92106>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92107>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92108>>>        Move "64"               to ColumnType[i].sPrecision
92109>>>        Increment i
92110>>>
92110>>>        Move ePgSQL_INT2        to ColumnType[i].iType
92111>>>        Move "smallint"         to ColumnType[i].sType
92112>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92113>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92114>>>        Move "6.0"              to ColumnType[i].sPrecision
92115>>>        Increment i
92116>>>
92116>>>        Move ePgSQL_TEXT        to ColumnType[i].iType
92117>>>        Move "text"             to ColumnType[i].sType
92118>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92119>>>        Move "Text"             to ColumnType[i].sDataFlexType
92120>>>        Move "16384"            to ColumnType[i].sPrecision
92121>>>        Increment i
92122>>>
92122>>>        Move ePgSQL_TIME        to ColumnType[i].iType
92123>>>        Move "time"             to ColumnType[i].sType
92124>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92125>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92126>>>        Move "15.0"             to ColumnType[i].sPrecision
92127>>>        Increment i
92128>>>
92128>>>        Move ePgSQL_TIMESTAMP   to ColumnType[i].iType
92129>>>        Move "timestamp"        to ColumnType[i].sType
92130>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92131>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92132>>>        Move "23.0"             to ColumnType[i].sPrecision
92133>>>        Move True               to ColumnType[i].bFixedSize
92134>>>        Increment i
92135>>>
92135>>>        Move ePgSQL_UUID        to ColumnType[i].iType
92136>>>        Move "uuid"             to ColumnType[i].sType
92137>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92138>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92139>>>        Move "40"               to ColumnType[i].sPrecision
92140>>>        Move True               to ColumnType[i].bFixedSize
92141>>>        Increment i
92142>>>
92142>>>        Move ePgSQL_VARCHAR     to ColumnType[i].iType
92143>>>        Move "varchar"          to ColumnType[i].sType
92144>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92145>>>        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
92146>>>        Move "16384"            to ColumnType[i].sPrecision
92147>>>        Increment i
92148>>>
92148>>>        Function_Return ColumnType
92149>>>    End_Function
92150>>>
92150>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
92150>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
92152>>>        Integer iValue iSize iCount iStart iDriverID
92152>>>        tColumnType[] ColumnTypeArray
92152>>>        tColumnType[] ColumnTypeArray
92153>>>        tColumnType RetvalType
92153>>>        tColumnType RetvalType
92153>>>        String sValue  
92153>>>        Boolean bFrameworkDataFlexType
92153>>>
92153>>>        Move "Undefined" to RetvalType.sType
92154>>>        Move -1999       to RetvalType.iType
92155>>>
92155>>>        Move 0 to iStart
92156>>>        Move (Uppercase(sType)) to sType
92157>>>        Move (iType <= -1490) to bFrameworkDataFlexType
92158>>>        If (bFrameworkDataFlexType = True) Begin
92160>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
92161>>>            Function_Return RetvalType
92162>>>        End
92162>>>>
92162>>>
92162>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
92163>>>
92163>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
92164>>>        Decrement iSize
92165>>>
92165>>>        for iCount from iStart to iSize
92171>>>>
92171>>>            Move ColumnTypeArray[iCount].iType to iValue
92172>>>            Move ColumnTypeArray[iCount].sType to sValue
92173>>>            If (bIntegerInputType = True) Begin
92175>>>                If (iValue = iType) Begin
92177>>>                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
92178>>>                    Move iType                                  to RetvalType.iType
92179>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
92180>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
92181>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
92182>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
92183>>>                    Move iSize to iCount // We're done!
92184>>>                End
92184>>>>
92184>>>            End
92184>>>>
92184>>>            Else Begin
92185>>>                Move (Uppercase(sValue)) to sValue
92186>>>                If (sValue = sType) Begin
92188>>>                    Move sType                                  to RetvalType.sType
92189>>>                    Move ColumnTypeArray[iCount].iType          to RetvalType.iType
92190>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
92191>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
92192>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
92193>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
92194>>>                    Move iSize to iCount // We're done!
92195>>>                End
92195>>>>
92195>>>            End
92195>>>>
92195>>>        Loop            
92196>>>>
92196>>>        
92196>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
92196>>>        // In which case we search for a match in DataFlex standard types:
92196>>>        If (RetvalType.sType = "Undefined") Begin
92198>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
92199>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
92200>>>            Decrement iSize
92201>>>    
92201>>>            for iCount from iStart to iSize
92207>>>>
92207>>>                Move ColumnTypeArray[iCount].iType to iValue
92208>>>                Move ColumnTypeArray[iCount].sType to sValue
92209>>>                If (iValue = iType) Begin
92211>>>                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
92212>>>                    Move iType                                  to RetvalType.iType
92213>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
92214>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
92215>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
92216>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
92217>>>                    Move iSize to iCount // We're done!
92218>>>                End
92218>>>>
92218>>>            Loop    
92219>>>>
92219>>>        End
92219>>>>
92219>>>
92219>>>        Function_Return RetvalType
92220>>>    End_Function
92221>>>
92221>>>    Function _AllTablesToConvert Returns Integer[]
92223>>>        Integer[] iTableConvertExceptions iTablesArray
92225>>>        Handle hTable
92225>>>        Integer iIndex
92225>>>        String sTableName
92225>>>        Boolean bFlexErrs
92225>>>
92225>>>        // a) Get the exception table array the developer has specified
92225>>>        Get piTableConvertExceptions to iTableConvertExceptions
92226>>>
92226>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
92226>>>        Repeat
92226>>>>
92226>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92229>>>            If (hTable <> 0) Begin
92231>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92234>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
92235>>>                If (bFlexErrs = False) Begin
92237>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
92239>>>                        Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
92240>>>                        If (iIndex = -1) Begin
92242>>>                            Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
92243>>>                        End
92243>>>>
92243>>>                    End
92243>>>>
92243>>>                End
92243>>>>
92243>>>            End
92243>>>>
92243>>>        Until (hTable = 0)
92245>>>
92245>>>        Move 0 to hTable
92246>>>
92246>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
92246>>>        Repeat
92246>>>>
92246>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92249>>>            If (hTable > 0) Begin
92251>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92254>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
92255>>>                If (bFlexErrs = False) Begin
92257>>>                    Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
92258>>>                    If (iIndex = -1) Begin
92260>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
92261>>>                    End
92261>>>>
92261>>>                End
92261>>>>
92261>>>            End
92261>>>>
92261>>>        Until (hTable = 0)
92263>>>
92263>>>        Function_Return iTablesArray
92264>>>    End_Function
92265>>>
92265>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[] 
92267>>>        tAPIColumn NewAPIColumn 
92267>>>        tAPIColumn NewAPIColumn 
92267>>>        
92267>>>        Move sFieldName to NewAPIColumn.sFieldName
92268>>>        Move iType      to NewAPIColumn.iType
92269>>>        Move iLength    to NewAPIColumn.iLength
92270>>>        Move iPrecision to NewAPIColumn.iPrecision
92271>>>        Move iOptions   to NewAPIColumn.iOptions
92272>>>        
92272>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
92273>>>        
92273>>>        Function_Return aCurrent
92274>>>    End_Function
92275>>>
92275>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
92277>>>        String sRetval sFieldName
92277>>>        Integer iCount iSize
92277>>>        
92277>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
92278>>>        Decrement iSize
92279>>>        for iCount from 0 to iSize
92285>>>>
92285>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
92286>>>            Move (sRetval * (String(sFieldName))) to sRetval
92287>>>        Loop                                                
92288>>>>
92288>>>        Move (Trim(sRetval)) to sRetval
92289>>>        
92289>>>        Function_Return sRetval
92290>>>    End_Function
92291>>>
92291>>>    // *** Miscellaneous other functions ***
92291>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
92291>>>    //
92291>>>
92291>>>    // Callback functionality used when e.g. calling driver functions directly.
92291>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
92293>>>        Integer iRetval iPos iPerc
92293>>>        String sVal1 sVal2
92293>>>        Number nReady nTotal
92293>>>
92293>>>        Send DoAdvance of ghoProgressBar
92294>>>
92294>>>        If (sCallback_Text contains "Copy records") Begin
92296>>>            Move CS_SQLCopyingData to sCallback_Text
92297>>>        End
92297>>>>
92297>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
92299>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
92300>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
92301>>>        End
92301>>>>
92301>>>        If (sCallback_Text contains "Creating index") Begin
92303>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
92304>>>        End
92304>>>>
92304>>>
92304>>>        Case Begin
92304>>>            Case (iCallback_Type = DF_Message_Text)
92306>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
92306>>>                Set Action_Text  of ghoStatusPanel to ""
92307>>>                Case Break
92308>>>            Case (iCallback_Type = DF_Message_Heading_1)
92311>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92312>>>                Set Action_Text  of ghoStatusPanel to ""
92313>>>                Case Break
92314>>>            Case (iCallback_Type = DF_Message_Heading_2)
92317>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92318>>>                Set Action_Text  of ghoStatusPanel to ""
92319>>>                Case Break
92320>>>            Case (iCallback_Type = DF_Message_Heading_3)
92323>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92324>>>                Set Action_Text  of ghoStatusPanel to ""
92325>>>                Case Break
92326>>>            Case (iCallback_Type = DF_Message_Heading_4)
92329>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92330>>>                Set Action_Text  of ghoStatusPanel to ""
92331>>>                Case Break
92332>>>            Case (iCallback_Type = DF_Message_Heading_5)
92335>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92336>>>                Set Action_Text  of ghoStatusPanel to ""
92337>>>                Case Break
92338>>>            Case (iCallback_Type = DF_Message_Warning)
92341>>>                Send None
92342>>>                Case Break
92343>>>            Case (iCallback_Type = DF_Message_Progress_Title)
92346>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
92347>>>                Set Action_Text  of ghoStatusPanel to ""
92348>>>                Case Break
92349>>>            Case (iCallback_Type = DF_Message_Progress_Value)
92352>>>                //*** Interpret numbers
92352>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
92353>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
92354>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
92355>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
92356>>>                Case Break
92357>>>            Case Else
92357>>>                Set Message_Text to ""
92358>>>                Set Action_Text  to ""
92359>>>        Case End
92359>>>
92359>>>        Send ProcessEvents of ghoStatusPanel
92360>>>        Function_Return False
92361>>>    End_Function
92362>>>
92362>>>    Procedure IncreaseSortBufferSize
92364>>>        String sNull
92364>>>        Integer iSortBufferSize
92364>>>        Boolean bBufferSet
92364>>>
92364>>>        Move "" to sNull
92365>>>        Move (1024 * 128) to iSortBufferSize
92366>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback Self Passing sNull sNull iSortBufferSize Result bBufferSet
92371>>>
92371>>>    End_Procedure
92372>>>
92372>>>    Procedure SetAllIndexesToBatch Handle hTable
92374>>>        Integer iLastIndex iIndex iNumSegments iIndexType
92374>>>        String sTable
92374>>>        Boolean bOK
92374>>>        
92374>>>        If (hTable > 0) Begin
92376>>>            Close hTable
92377>>>            Get OpenTableExclusive hTable to bOK
92378>>>            If (bOK = False) Begin
92380>>>                Function_Return False
92381>>>            End
92381>>>>
92381>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92384>>>            for iIndex from 1 to iLastIndex
92390>>>>
92390>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92393>>>                If (iNumSegments > 0) Begin
92395>>>                    Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92398>>>                End
92398>>>>
92398>>>            Loop
92399>>>>
92399>>>            Close hTable
92400>>>        End
92400>>>>
92400>>>    End_Procedure
92401>>>
92401>>>    Function NextFreeFilelistSlot Returns Handle
92403>>>        Handle hTable
92403>>>
92403>>>        Move 0 to hTable
92404>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92407>>>
92407>>>        Function_Return hTable
92408>>>    End_Function
92409>>>
92409>>>    // For debugging purposes. To print Sql statements as they are build...
92409>>>    Procedure DebugPrint String sStmt String sFileName
92411>>>        Integer iCh
92411>>>        Get Seq_Append_Output_Channel sFileName to iCh
92412>>>            Write channel iCh sStmt
92414>>>        Send Seq_Close_Channel iCh
92415>>>    End_Procedure
92416>>>
92416>>>    // Returns the integer number for the passed Driver ID that is
92416>>>    // needed by some database API calls.
92416>>>    Function DriverIndex String sDriverID Returns Integer
92418>>>        String  sCurrentDriver
92418>>>        Integer iNumberOfDrivers iDriver iCount
92418>>>
92418>>>        Move 0 to iDriver
92419>>>
92419>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92422>>>        for iCount from 1 to iNumberOfDrivers
92428>>>>
92428>>>
92428>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92431>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92433>>>                Move iCount to iDriver
92434>>>            End
92434>>>>
92434>>>        Loop
92435>>>>
92435>>>
92435>>>        // In case it was not found, it wasn't loaded so we do that now.
92435>>>        If (iDriver = 0) Begin
92437>>>            Move False to Err
92438>>>            Load_Driver sDriverID
92439>>>            If (Err = False) Begin
92441>>>                Move 1 to iDriver
92442>>>            End
92442>>>>
92442>>>        End
92442>>>>
92442>>>
92442>>>        Function_Return iDriver
92443>>>    End_Function
92444>>>
92444>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE  
92444>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92444>>>    //       so in that case we "cheat" and report those tables were opened OK.
92444>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92446>>>        Integer iMode
92446>>>        Boolean bOpened bCodeMasterType                        
92446>>>        String sTableName
92446>>>        
92446>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92447>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92450>>>        If (bOpened) Begin
92452>>>            If (IsDebuggerPresent()) Begin
92454>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92457>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92459>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92460>>>                    Function_Return True
92461>>>                End
92461>>>>
92461>>>            End
92461>>>>
92461>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92464>>>            If (iMode=DF_EXCLUSIVE) Begin
92466>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92467>>>                Function_Return True
92468>>>            End
92468>>>>
92468>>>            Close hTable
92469>>>        End
92469>>>>
92469>>>        Else Begin
92470>>>            Open hTable
92472>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92475>>>            If (bOpened and IsDebuggerPresent()) Begin
92477>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92480>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92482>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92483>>>                    Function_Return True
92484>>>                End
92484>>>>
92484>>>            End
92484>>>>
92484>>>            
92484>>>        End
92484>>>>
92484>>>
92484>>>        Open hTable Mode DF_EXCLUSIVE
92486>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92489>>>
92489>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92490>>>        Function_Return bOpened
92491>>>    End_Function
92492>>>    
92492>>>    Function AutoConnectionIDLogin Returns Boolean
92494>>>        String sConnectionID sConnectionString sDriverID
92494>>>        Boolean bExists bOK bDAWDriver bSQLDriver
92494>>>        Handle hoCLI hoDriver
92494>>>        Integer iRetval
92494>>>        tSQLConnection SQLConnection
92494>>>        tSQLConnection SQLConnection
92494>>>        
92494>>>        Get psDriverID to sDriverID
92495>>>        Get IsSQLDriver sDriverID to bSQLDriver
92496>>>        If (bSQLDriver = False) Begin
92498>>>            Function_Return True
92499>>>        End                     
92499>>>>
92499>>>        
92499>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92500>>>        Move SQLConnection.sDriverID                  to sDriverID
92501>>>        Move SQLConnection.sConnectionString          to sConnectionString
92502>>>        Get IsDAWSQLDriver sDriverID to bOK
92503>>>        If (bOK = True) Begin
92505>>>//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
92505>>>        End
92505>>>>
92505>>>        If (bOK = False) Begin
92507>>>            Get _MertechSQLManagerHandle to hoCLI
92508>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92509>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
92510>>>            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
92512>>>                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92513>>>                Send Destroy of hoDriver
92514>>>            End
92514>>>>
92514>>>            Function_Return False
92515>>>        End
92515>>>>
92515>>>
92515>>>        Move SQLConnection.sConnectionID to sConnectionID
92516>>>
92516>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92517>>>        If (bExists = False) Begin
92519>>>            // We always start by deleting the current connection - if any - because the
92519>>>            // login details my have changed.
92519>>>            Get phoCLIHandler to hoCLI
92520>>>            Set psDriverID    of hoCLI to sDriverID
92521>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92522>>>            Get UtilCreateConnectionID sConnectionID to bOk
92523>>>            If (bOk = False) Begin
92525>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92526>>>>
92526>>>                Function_Return False
92527>>>            End
92527>>>>
92527>>>            Move bOK to bExists
92528>>>        End
92528>>>>
92528>>>
92528>>>        Function_Return (bExists = True)
92529>>>    End_Function
92530>>>
92530>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92530>>>    // Returns: False if nobody else is running
92530>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92530>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92530>>>    //      tables are not locked as DataFlex tables are.
92530>>>    Function IsDatabaseInUse Returns Boolean
92532>>>        Handle  hTable
92532>>>        Integer iTemp
92532>>>        String  sRootName sOrgOpenPath sOrgFileList
92532>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
92532>>>
92532>>>        Get AutoConnectionIDLogin to bOK
92533>>>        Move 0 to hTable
92534>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92537>>>        Move False to bErr
92538>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92539>>>
92539>>>        Repeat
92539>>>>
92539>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92542>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92543>>>
92543>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92543>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
92544>>>            Move False to bOpen
92545>>>
92545>>>            // Don't bother about FlexErrs (Normally table 50)
92545>>>            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
92547>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92548>>>                Open hTable
92550>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92553>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92554>>>                If (bOpen = True) Begin
92556>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92556>>>                    Get UtilTableIsAlias hTable to bAlias
92557>>>                    If (bAlias = False) Begin 
92559>>>                        Close hTable
92560>>>                        Get OpenTableExclusive hTable to bOpen
92561>>>                        If (bOpen = False) Begin
92563>>>                            Move True to bErr
92564>>>                        End
92564>>>>
92564>>>                    End
92564>>>>
92564>>>                End 
92564>>>>
92564>>>                Close hTable
92565>>>            End
92565>>>>
92565>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92568>>>            If (bErr = True ) Break
92571>>>        Until (not(hTable))
92573>>>
92573>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92574>>>        Move False to Err
92575>>>
92575>>>        Function_Return bErr
92576>>>    End_Function
92577>>>
92577>>>    // Checks if the passed connection id exists in the CLI interface.
92577>>>    // This might be needed by API-methods when a connection id is to be used and
92577>>>    // the connection id hasn't been established with the driver's CLI interface.
92577>>>    // NOTE: Only applicable for DAW drivers.
92577>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
92579>>>        String sID sConnString
92579>>>        Integer iDriver iNumConn iCount
92579>>>        Handle hoCLI
92579>>>        Boolean bOK
92579>>>
92579>>>        Get IsDAWSQLDriver sDriverID to bOK
92580>>>        If (bOK = False) Begin
92582>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
92583>>>>
92583>>>            Function_Return False
92584>>>        End
92584>>>>
92584>>>
92584>>>        Move False to bOK
92585>>>        Get phoCLIHandler to hoCLI
92586>>>        If (hoCLI <> 0) Begin
92588>>>            Set psDriverID of hoCLI to sDriverID
92589>>>            Get DriverIndex of hoCLI sDriverID to iDriver
92590>>>
92590>>>            // If driver not loaded; load it.
92590>>>            If (iDriver = 0) Begin
92592>>>                Load_Driver sDriverID
92593>>>                Get DriverIndex sDriverID to iDriver
92594>>>            End
92594>>>>
92594>>>            If (iDriver <> 0) Begin
92596>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
92599>>>                Decrement iNumConn
92600>>>                for iCount from 0 to iNumConn
92606>>>>
92606>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
92609>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
92612>>>                    If (sID = sConnectionID) Move True to bOK
92615>>>                Loop
92616>>>>
92616>>>            End
92616>>>>
92616>>>        End
92616>>>>
92616>>>
92616>>>        Function_Return bOK
92617>>>    End_Function
92618>>>
92618>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
92620>>>        Boolean bOK
92620>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
92621>>>        Function_Return bOK
92622>>>    End_Function
92623>>>
92623>>>    Function IsMertechDriver String sDriverID Returns Boolean
92625>>>        Boolean bOK
92625>>>        Move False to bOK
92626>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
92627>>>        Function_Return bOK
92628>>>    End_Function
92629>>>
92629>>>    Function IsMSSQLDriver Returns Boolean
92631>>>        Handle ho
92631>>>        Integer iDriverIndex
92631>>>
92631>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
92632>>>
92632>>>        Function_Return (iDriverIndex <> 0)
92633>>>    End_Function
92634>>>
92634>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
92634>>>    // attempt to load the driver.
92634>>>    // Returns true if the passed driver is SQL based.
92634>>>    Function IsSQLDriver String sDriverID Returns Boolean
92636>>>        Boolean bOK
92636>>>        Integer iDriver
92636>>>
92636>>>        Get IsDAWSQLDriver sDriverID to bOK
92637>>>
92637>>>        If (bOK = False) Begin
92639>>>            Get IsMertechDriver sDriverID to bOK
92640>>>        End
92640>>>>
92640>>>
92640>>>        Function_Return bOK
92641>>>    End_Function
92642>>>
92642>>>    // *** Error Handler ***
92642>>>    //
92642>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
92642>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
92642>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
92644>>>        String sText
92644>>>        Integer iSize iErrorMode
92644>>>        tSqlErrorArray aSqlErrorArray
92644>>>        tSqlErrorArray aSqlErrorArray
92644>>>
92644>>>        If (pbProcessingError(Self)) Begin
92646>>>            Procedure_Return
92647>>>        End
92647>>>>
92647>>>
92647>>>        Get Error_Report_Mode to iErrorMode
92648>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
92650>>>            Procedure_Return
92651>>>        End
92651>>>>
92651>>>
92651>>>        Set pbProcessingError to True
92652>>>        Set pbSqlError to True
92653>>>        Get paSqlErrorArray      to aSqlErrorArray
92654>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
92655>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
92656>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
92657>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
92658>>>        Set paSqlErrorArray      to aSqlErrorArray
92659>>>        Set pbProcessingError to False
92660>>>    End_Procedure
92661>>>
92661>>>    // *** Miscellanous Helper Functions ***
92661>>>    //
92661>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
92661>>>    // returns the table name only; stripped of any path or filename extension.
92661>>>    Function _TableNameOnly String sName Returns String
92663>>>        String sPath sExt
92663>>>
92663>>>        Get ParseFolderName sName to sPath
92664>>>        If (sPath <> "") Begin
92666>>>            Move (Replace(sPath, sName, "")) to sName
92667>>>        End
92667>>>>
92667>>>        Get ParseFileExtension sName to sExt
92668>>>        If (sExt <> "") Begin
92670>>>            Move (Replace(("." + sExt), sName, "")) to sName
92671>>>        End
92671>>>>
92671>>>
92671>>>        Function_Return sName
92672>>>    End_Function
92673>>>
92673>>>    // Returns the first datapath found in the psDataPath property.
92673>>>    // The returned path always ends with a "\"
92673>>>    Function psDataPathFirstPart Returns String
92675>>>        String sDataPath
92675>>>        Integer iCount
92675>>>
92675>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92676>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
92677>>>        If (iCount > 1) Begin
92679>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
92680>>>        End
92680>>>>
92680>>>        If (sDataPath <> "") Begin
92682>>>            Get vFolderFormat sDataPath to sDataPath
92683>>>        End
92683>>>>
92683>>>
92683>>>        Function_Return sDataPath
92684>>>    End_Function
92685>>>
92685>>>    // *** Property Messages ***
92685>>>    //
92685>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
92685>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
92685>>>    //
92685>>>
92685>>>    Function pSQLConnection Returns tSQLConnection
92687>>>        tSQLConnection SQLConnection
92687>>>        tSQLConnection SQLConnection
92687>>>        If (ghoSQLConnectionHandler = 0) Begin
92689>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
92689>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92690>>>>
92690>>>            Function_Return
92691>>>        End
92691>>>>
92691>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92692>>>        Function_Return SQLConnection
92693>>>    End_Function
92694>>>
92694>>>    Procedure Set psServer String sValue
92696>>>        If (ghoSQLConnectionHandler = 0) Begin
92698>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
92698>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92699>>>>
92699>>>            Procedure_Return
92700>>>        End
92700>>>>
92700>>>        Set psServer of ghoSQLConnectionHandler to sValue
92701>>>    End_Procedure
92702>>>
92702>>>    Function psServer Returns String
92704>>>        String sValue
92704>>>        If (ghoSQLConnectionHandler = 0) Begin
92706>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92707>>>>
92707>>>            Function_Return
92708>>>        End
92708>>>>
92708>>>        Get psServer of ghoSQLConnectionHandler to sValue
92709>>>        Function_Return sValue
92710>>>    End_Function
92711>>>
92711>>>    Procedure Set psDatabase String sValue
92713>>>        If (ghoSQLConnectionHandler = 0) Begin
92715>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92716>>>>
92716>>>            Procedure_Return
92717>>>        End
92717>>>>
92717>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
92718>>>    End_Procedure
92719>>>
92719>>>    Function psDatabase Returns String
92721>>>        String sValue
92721>>>        If (ghoSQLConnectionHandler = 0) Begin
92723>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92724>>>>
92724>>>            Function_Return
92725>>>        End
92725>>>>
92725>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
92726>>>        Function_Return sValue
92727>>>    End_Function
92728>>>
92728>>>    Procedure Set psUserID String sValue
92730>>>        If (ghoSQLConnectionHandler = 0) Begin
92732>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92733>>>>
92733>>>            Function_Return
92734>>>        End
92734>>>>
92734>>>        Set psUserID of ghoSQLConnectionHandler to sValue
92735>>>    End_Procedure
92736>>>
92736>>>    Function psUserID Returns String
92738>>>        String sValue
92738>>>        If (ghoSQLConnectionHandler = 0) Begin
92740>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92741>>>>
92741>>>            Function_Return
92742>>>        End
92742>>>>
92742>>>        Get psUserID of ghoSQLConnectionHandler to sValue
92743>>>        Function_Return sValue
92744>>>    End_Function
92745>>>
92745>>>    Procedure Set psPassword String sValue
92747>>>        If (ghoSQLConnectionHandler = 0) Begin
92749>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92750>>>>
92750>>>            Procedure_Return
92751>>>        End
92751>>>>
92751>>>        Set psPassword of ghoSQLConnectionHandler to sValue
92752>>>    End_Procedure
92753>>>
92753>>>    Function psPassword Returns String
92755>>>        String sValue
92755>>>        If (ghoSQLConnectionHandler = 0) Begin
92757>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92758>>>>
92758>>>            Function_Return
92759>>>        End
92759>>>>
92759>>>        Get psPassword of ghoSQLConnectionHandler to sValue
92760>>>        Function_Return sValue
92761>>>    End_Function
92762>>>
92762>>>    Procedure Set pbTrusted Boolean bValue
92764>>>        If (ghoSQLConnectionHandler = 0) Begin
92766>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92767>>>>
92767>>>            Procedure_Return
92768>>>        End
92768>>>>
92768>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
92769>>>    End_Procedure
92770>>>
92770>>>    Function pbTrusted Returns Boolean
92772>>>        Boolean bValue
92772>>>        If (ghoSQLConnectionHandler = 0) Begin
92774>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92775>>>>
92775>>>            Function_Return
92776>>>        End
92776>>>>
92776>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
92777>>>        Function_Return bValue
92778>>>    End_Function
92779>>>
92779>>>    Procedure Set pbSilentLogin Boolean bValue
92781>>>        If (ghoSQLConnectionHandler = 0) Begin
92783>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92784>>>>
92784>>>            Procedure_Return
92785>>>        End
92785>>>>
92785>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
92786>>>    End_Procedure
92787>>>
92787>>>    Function pbSilentLogin Returns Boolean
92789>>>        Boolean bValue
92789>>>        If (ghoSQLConnectionHandler = 0) Begin
92791>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92792>>>>
92792>>>            Function_Return
92793>>>        End
92793>>>>
92793>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
92794>>>        Function_Return bValue
92795>>>    End_Function
92796>>>
92796>>>    Procedure Set psConnectionID String sValue
92798>>>        If (ghoSQLConnectionHandler = 0) Begin
92800>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92801>>>>
92801>>>            Procedure_Return
92802>>>        End
92802>>>>
92802>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
92803>>>    End_Procedure
92804>>>
92804>>>    Function psConnectionID Returns String
92806>>>        String sValue
92806>>>        If (ghoSQLConnectionHandler = 0) Begin
92808>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92809>>>>
92809>>>            Function_Return
92810>>>        End
92810>>>>
92810>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
92811>>>        Function_Return sValue
92812>>>    End_Function
92813>>>
92813>>>    Procedure Set psConnectionString String sValue
92815>>>        If (ghoSQLConnectionHandler = 0) Begin
92817>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92818>>>>
92818>>>            Procedure_Return
92819>>>        End
92819>>>>
92819>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
92820>>>    End_Procedure
92821>>>
92821>>>    Function psConnectionString Returns String
92823>>>        String sValue
92823>>>        If (ghoSQLConnectionHandler = 0) Begin
92825>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92826>>>>
92826>>>            Function_Return
92827>>>        End
92827>>>>
92827>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
92828>>>        Function_Return sValue
92829>>>    End_Function
92830>>>
92830>>>    // The normal connection string looks something like this;
92830>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
92830>>>    // ...and the full connection string looks like this;
92830>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
92830>>>    Function psFullConnectionString Returns String
92832>>>        String sConnectionID sConnectionString
92832>>>        If (ghoSQLConnectionHandler = 0) Begin
92834>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92835>>>>
92835>>>            Function_Return
92836>>>        End
92836>>>>
92836>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
92837>>>        Move (Trim(sConnectionID)) to sConnectionID
92838>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
92839>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
92840>>>    End_Function
92841>>>
92841>>>    Function piConnectionOptions Returns Integer
92843>>>        Integer iValue
92843>>>        If (ghoSQLConnectionHandler = 0) Begin
92845>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92846>>>>
92846>>>            Function_Return
92847>>>        End
92847>>>>
92847>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
92848>>>        Function_Return iValue
92849>>>    End_Function
92850>>>
92850>>>    Procedure Set psSchema String sValue
92852>>>        tSQLConnection SQLConnection
92852>>>        tSQLConnection SQLConnection
92852>>>        If (ghoSQLConnectionHandler = 0) Begin
92854>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92855>>>>
92855>>>            Procedure_Return
92856>>>        End
92856>>>>
92856>>>        Set psSchema of ghoSQLConnectionHandler to sValue
92857>>>    End_Procedure
92858>>>
92858>>>    Function psSchema Returns String
92860>>>        String sRetval
92860>>>        If (ghoSQLConnectionHandler = 0) Begin
92862>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92863>>>>
92863>>>            Function_Return
92864>>>        End
92864>>>>
92864>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
92865>>>        Function_Return sRetval
92866>>>    End_Function
92867>>>
92867>>>    Procedure Set psBaseTableSpace String sValue
92869>>>        String sRetval
92869>>>        If (ghoSQLConnectionHandler = 0) Begin
92871>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92872>>>>
92872>>>            Procedure_Return
92873>>>        End
92873>>>>
92873>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
92874>>>    End_Procedure
92875>>>
92875>>>    Function psBaseTableSpace Returns String
92877>>>        String sRetval
92877>>>        If (ghoSQLConnectionHandler = 0) Begin
92879>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92880>>>>
92880>>>            Function_Return
92881>>>        End
92881>>>>
92881>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
92882>>>        Function_Return sRetval
92883>>>    End_Function
92884>>>
92884>>>    Procedure Set psLongTableSpace String sValue
92886>>>        If (ghoSQLConnectionHandler = 0) Begin
92888>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92889>>>>
92889>>>            Procedure_Return
92890>>>        End
92890>>>>
92890>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
92891>>>    End_Procedure
92892>>>
92892>>>    Function psLongTableSpace Returns String
92894>>>        String sRetval
92894>>>        If (ghoSQLConnectionHandler = 0) Begin
92896>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92897>>>>
92897>>>            Function_Return
92898>>>        End
92898>>>>
92898>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
92899>>>        Function_Return sRetval
92900>>>    End_Function
92901>>>
92901>>>    Procedure Set psIndexTableSpace String sValue
92903>>>        If (ghoSQLConnectionHandler = 0) Begin
92905>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92906>>>>
92906>>>            Procedure_Return
92907>>>        End
92907>>>>
92907>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
92908>>>    End_Procedure
92909>>>
92909>>>    Function psIndexTableSpace Returns String
92911>>>        String sRetval
92911>>>        If (ghoSQLConnectionHandler = 0) Begin
92913>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92914>>>>
92914>>>            Function_Return
92915>>>        End
92915>>>>
92915>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
92916>>>        Function_Return sRetval
92917>>>    End_Function
92918>>>
92918>>>    Procedure Set pbUseConnectionID Boolean bState
92920>>>        If (ghoSQLConnectionHandler = 0) Begin
92922>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92923>>>>
92923>>>            Procedure_Return
92924>>>        End
92924>>>>
92924>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
92925>>>    End_Procedure
92926>>>
92926>>>    Function pbUseConnectionID Returns Boolean
92928>>>        Boolean bState
92928>>>        If (ghoSQLConnectionHandler = 0) Begin
92930>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92931>>>>
92931>>>            Function_Return
92932>>>        End
92932>>>>
92932>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
92933>>>        Function_Return bState
92934>>>    End_Function
92935>>>
92935>>>    Procedure Set pbToANSI Boolean bState
92937>>>        If (ghoSQLConnectionHandler = 0) Begin
92939>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92940>>>>
92940>>>            Procedure_Return
92941>>>        End
92941>>>>
92941>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
92942>>>    End_Procedure
92943>>>
92943>>>    Function pbToANSI Returns Boolean
92945>>>        Boolean bState
92945>>>        If (ghoSQLConnectionHandler = 0) Begin
92947>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92948>>>>
92948>>>            Function_Return
92949>>>        End
92949>>>>
92949>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
92950>>>        Function_Return bState
92951>>>    End_Function
92952>>>
92952>>>    Procedure Set pbRecnum Boolean bState
92954>>>        If (ghoSQLConnectionHandler = 0) Begin
92956>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92957>>>>
92957>>>            Procedure_Return
92958>>>        End
92958>>>>
92958>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
92959>>>    End_Procedure
92960>>>
92960>>>    Function pbRecnum Returns Boolean
92962>>>        Boolean bState
92962>>>        If (ghoSQLConnectionHandler = 0) Begin
92964>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92965>>>>
92965>>>            Function_Return
92966>>>        End
92966>>>>
92966>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
92967>>>        Function_Return bState
92968>>>    End_Function
92969>>>
92969>>>    Procedure Set pbCopyData Boolean bState
92971>>>        If (ghoSQLConnectionHandler = 0) Begin
92973>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92974>>>>
92974>>>            Procedure_Return
92975>>>        End
92975>>>>
92975>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
92976>>>    End_Procedure
92977>>>
92977>>>    Function pbCopyData Returns Boolean
92979>>>        Boolean bState
92979>>>        If (ghoSQLConnectionHandler = 0) Begin
92981>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92982>>>>
92982>>>            Function_Return
92983>>>        End
92983>>>>
92983>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
92984>>>        Function_Return bState
92985>>>    End_Function
92986>>>
92986>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92988>>>        If (ghoSQLConnectionHandler = 0) Begin
92990>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92991>>>>
92991>>>            Procedure_Return
92992>>>        End
92992>>>>
92992>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92993>>>    End_Procedure
92994>>>
92994>>>    Function pbCompareDate_DateTime Returns Boolean
92996>>>        Boolean bState
92996>>>        If (ghoSQLConnectionHandler = 0) Begin
92998>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
92999>>>>
92999>>>            Function_Return
93000>>>        End
93000>>>>
93000>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
93001>>>        Function_Return bState
93002>>>    End_Function
93003>>>
93003>>>    Procedure Set pbCompareIndexAscending Boolean bState
93005>>>        If (ghoSQLConnectionHandler = 0) Begin
93007>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93008>>>>
93008>>>            Procedure_Return
93009>>>        End
93009>>>>
93009>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93010>>>    End_Procedure
93011>>>
93011>>>    Function pbCompareIndexAscending Returns Boolean
93013>>>        Boolean bState
93013>>>        If (ghoSQLConnectionHandler = 0) Begin
93015>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93016>>>>
93016>>>            Function_Return
93017>>>        End
93017>>>>
93017>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
93018>>>        Function_Return bState
93019>>>    End_Function
93020>>>
93020>>>    Procedure Set pbCompareIndexUppercase Boolean bState
93022>>>        If (ghoSQLConnectionHandler = 0) Begin
93024>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93025>>>>
93025>>>            Procedure_Return
93026>>>        End
93026>>>>
93026>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93027>>>    End_Procedure
93028>>>
93028>>>    Function pbCompareIndexUppercase Returns Boolean
93030>>>        Boolean bState
93030>>>        If (ghoSQLConnectionHandler = 0) Begin
93032>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
93033>>>>
93033>>>            Function_Return
93034>>>        End
93034>>>>
93034>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
93035>>>        Function_Return bState
93036>>>    End_Function
93037>>>
93037>>>    Procedure Set psDriverDefaultValueASCII String sValue
93039>>>        If (ghoSQLConnectionHandler = 0) Begin
93041>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93042>>>>
93042>>>            Procedure_Return
93043>>>        End
93043>>>>
93043>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
93044>>>    End_Procedure
93045>>>
93045>>>    Function psDriverDefaultValueASCII Returns String
93047>>>        String sRetval
93047>>>        If (ghoSQLConnectionHandler = 0) Begin
93049>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93050>>>>
93050>>>            Function_Return
93051>>>        End
93051>>>>
93051>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
93052>>>        Function_Return sRetval
93053>>>    End_Function
93054>>>
93054>>>    Procedure Set psDriverDefaultValueBinary String sValue
93056>>>        If (ghoSQLConnectionHandler = 0) Begin
93058>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93059>>>>
93059>>>            Procedure_Return
93060>>>        End
93060>>>>
93060>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
93061>>>    End_Procedure
93062>>>
93062>>>    Function psDriverDefaultValueBinary Returns String
93064>>>        String sRetval
93064>>>        If (ghoSQLConnectionHandler = 0) Begin
93066>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93067>>>>
93067>>>            Function_Return
93068>>>        End
93068>>>>
93068>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
93069>>>        Function_Return sRetval
93070>>>    End_Function
93071>>>
93071>>>    Procedure Set psDriverDefaultValueDate String sValue
93073>>>        If (ghoSQLConnectionHandler = 0) Begin
93075>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93076>>>>
93076>>>            Procedure_Return
93077>>>        End
93077>>>>
93077>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
93078>>>    End_Procedure
93079>>>
93079>>>    Function psDriverDefaultValueDate Returns String
93081>>>        String sRetval
93081>>>        If (ghoSQLConnectionHandler = 0) Begin
93083>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93084>>>>
93084>>>            Function_Return
93085>>>        End
93085>>>>
93085>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
93086>>>        Function_Return sRetval
93087>>>    End_Function
93088>>>
93088>>>    Procedure Set psDriverDefaultValueDateTime String sValue
93090>>>        If (ghoSQLConnectionHandler = 0) Begin
93092>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93093>>>>
93093>>>            Procedure_Return
93094>>>        End
93094>>>>
93094>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
93095>>>    End_Procedure
93096>>>
93096>>>    Function psDriverDefaultValueDateTime Returns String
93098>>>        String sRetval
93098>>>        If (ghoSQLConnectionHandler = 0) Begin
93100>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93101>>>>
93101>>>            Function_Return
93102>>>        End
93102>>>>
93102>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
93103>>>        Function_Return sRetval
93104>>>    End_Function
93105>>>
93105>>>    Procedure Set psDriverDefaultValueNumeric String sValue
93107>>>        If (ghoSQLConnectionHandler = 0) Begin
93109>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93110>>>>
93110>>>            Procedure_Return
93111>>>        End
93111>>>>
93111>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
93112>>>    End_Procedure
93113>>>
93113>>>    Function psDriverDefaultValueNumeric Returns String
93115>>>        String sRetval
93115>>>        If (ghoSQLConnectionHandler = 0) Begin
93117>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93118>>>>
93118>>>            Function_Return
93119>>>        End
93119>>>>
93119>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
93120>>>        Function_Return sRetval
93121>>>    End_Function
93122>>>
93122>>>    Procedure Set psDriverDefaultValueText String sValue
93124>>>        If (ghoSQLConnectionHandler = 0) Begin
93126>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93127>>>>
93127>>>            Procedure_Return
93128>>>        End
93128>>>>
93128>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
93129>>>    End_Procedure
93130>>>
93130>>>    Function psDriverDefaultValueText Returns String
93132>>>        String sRetval
93132>>>        If (ghoSQLConnectionHandler = 0) Begin
93134>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93135>>>>
93135>>>            Function_Return
93136>>>        End
93136>>>>
93136>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
93137>>>        Function_Return sRetval
93138>>>    End_Function
93139>>>
93139>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
93141>>>        If (ghoSQLConnectionHandler = 0) Begin
93143>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93144>>>>
93144>>>            Procedure_Return
93145>>>        End
93145>>>>
93145>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
93146>>>    End_Procedure
93147>>>
93147>>>    Function pbDriverDefaultNullableASCII Returns Boolean
93149>>>        Boolean bState
93149>>>        If (ghoSQLConnectionHandler = 0) Begin
93151>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93152>>>>
93152>>>            Function_Return
93153>>>        End
93153>>>>
93153>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
93154>>>        Function_Return bState
93155>>>    End_Function
93156>>>
93156>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
93158>>>        If (ghoSQLConnectionHandler = 0) Begin
93160>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93161>>>>
93161>>>            Procedure_Return
93162>>>        End
93162>>>>
93162>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
93163>>>    End_Procedure
93164>>>
93164>>>    Function pbDriverDefaultNullableBinary Returns Boolean
93166>>>        Boolean bState
93166>>>        If (ghoSQLConnectionHandler = 0) Begin
93168>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93169>>>>
93169>>>            Function_Return
93170>>>        End
93170>>>>
93170>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
93171>>>        Function_Return bState
93172>>>    End_Function
93173>>>
93173>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
93175>>>        If (ghoSQLConnectionHandler = 0) Begin
93177>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93178>>>>
93178>>>            Procedure_Return
93179>>>        End
93179>>>>
93179>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
93180>>>    End_Procedure
93181>>>
93181>>>    Function pbDriverDefaultNullableDate Returns Boolean
93183>>>        Boolean bState
93183>>>        If (ghoSQLConnectionHandler = 0) Begin
93185>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93186>>>>
93186>>>            Function_Return
93187>>>        End
93187>>>>
93187>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
93188>>>        Function_Return bState
93189>>>    End_Function
93190>>>
93190>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
93192>>>        If (ghoSQLConnectionHandler = 0) Begin
93194>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93195>>>>
93195>>>            Procedure_Return
93196>>>        End
93196>>>>
93196>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
93197>>>    End_Procedure
93198>>>
93198>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
93200>>>        Boolean bState
93200>>>        If (ghoSQLConnectionHandler = 0) Begin
93202>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93203>>>>
93203>>>            Function_Return
93204>>>        End
93204>>>>
93204>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
93205>>>        Function_Return bState
93206>>>    End_Function
93207>>>
93207>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
93209>>>        If (ghoSQLConnectionHandler = 0) Begin
93211>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93212>>>>
93212>>>            Procedure_Return
93213>>>        End
93213>>>>
93213>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
93214>>>    End_Procedure
93215>>>
93215>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
93217>>>        Boolean bState
93217>>>        If (ghoSQLConnectionHandler = 0) Begin
93219>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93220>>>>
93220>>>            Function_Return
93221>>>        End
93221>>>>
93221>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
93222>>>        Function_Return bState
93223>>>    End_Function
93224>>>
93224>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
93226>>>        If (ghoSQLConnectionHandler = 0) Begin
93228>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93229>>>>
93229>>>            Procedure_Return
93230>>>        End
93230>>>>
93230>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
93231>>>    End_Procedure
93232>>>
93232>>>    Function pbDriverDefaultNullableText Returns Boolean
93234>>>        Boolean bState
93234>>>        If (ghoSQLConnectionHandler = 0) Begin
93236>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
93237>>>>
93237>>>            Function_Return
93238>>>        End
93238>>>>
93238>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
93239>>>        Function_Return bState
93240>>>    End_Function
93241>>>
93241>>>    // Note: If the psDriverID + other connection properties are to be changed,
93241>>>    //       the psDriverID *must* be the first property that gets changed!
93241>>>    //       Otherwise errors might be raised by the driver when e.g. the format
93241>>>    //       for a connection string has the wrong format for that driver.
93241>>>    Procedure Set psDriverID String sValue
93243>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93244>>>        Delegate Set psDriverID to sValue
93246>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93247>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
93248>>>    End_Procedure
93249>>>
93249>>>    Function psDriverID Returns String
93251>>>        String sDriverID
93251>>>
93251>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93252>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
93252>>>        Delegate Get psDriverID to sDriverID
93254>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93255>>>        Move False to Err
93256>>>
93256>>>        // ...and in case it didn't use property of this class. Then the library is
93256>>>        // probably used as "utilites" from a special made program and
93256>>>        // the ghoSQLConnectionHandler must have been setup
93256>>>        If (sDriverID = "") Begin
93258>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
93259>>>        End
93259>>>>
93259>>>        Function_Return sDriverID
93260>>>    End_Function
93261>>>
93261>>>    Procedure Set piDbType Integer iValue
93263>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93264>>>        Delegate Set piDbType to iValue
93266>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93267>>>        Set piDbType of ghoSQLConnectionHandler to iValue
93268>>>    End_Procedure
93269>>>
93269>>>    Function piDbType Returns String
93271>>>        Integer iRetval
93271>>>
93271>>>//        Move False to Err
93271>>>//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
93271>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
93271>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93271>>>//        Delegate Get piDbType to iRetval
93271>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
93271>>>//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
93271>>>
93271>>>        // ...and in case it didn't use property of this class. Then the library is
93271>>>        // probably used as "utilites" from a special made program and
93271>>>        // the ghoSQLConnectionHandler must have been setup
93271>>>//        If (Err = True) Begin
93271>>>            Get piDbType of ghoSQLConnectionHandler to iRetval
93272>>>//        End
93272>>>
93272>>>//        Move False to Err
93272>>>        Function_Return iRetval
93273>>>    End_Function  
93274>>>    
93274>>>    Function phoLogFile Returns Handle
93276>>>        Handle hoLogFile
93276>>>        
93276>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93277>>>        Delegate Get phoLogFile to hoLogFile
93279>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93280>>>
93280>>>        Function_Return hoLogFile
93281>>>    End_Function
93282>>>
93282>>>    Function pnCurrentVersionUpdate Returns Number
93284>>>        Number nCurrentVersionUpdate
93284>>>
93284>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93285>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
93287>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93288>>>
93288>>>        Function_Return nCurrentVersionUpdate
93289>>>    End_Function
93290>>>    
93290>>>    Procedure LogError String sText Boolean bError
93292>>>        Handle hoLogFile 
93292>>>        Number nCurrentVersionUpdate
93292>>>        
93292>>>        Get phoLogFile to hoLogFile
93293>>>        If (hoLogFile = 0) Begin
93295>>>            Procedure_Return
93296>>>        End 
93296>>>>
93296>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
93297>>>        
93297>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93298>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
93299>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93300>>>    End_Procedure        
93301>>>    
93301>>>    Function pbContinueOnError Returns Boolean
93303>>>        Boolean bContinueOnError
93303>>>        If (ghoDbUpdateHandler > 0) Begin
93305>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
93306>>>        End
93306>>>>
93306>>>        Function_Return bContinueOnError
93307>>>    End_Function
93308>>>
93308>>>    // Messages not available in pre DF18 versions:
93308>>>
93308>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer 
93310>>>        Integer iMax iPos 
93310>>>        String sName 
93310>>>        
93310>>>        Move (Lowercase(sField)) to sField
93311>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax 
93314>>>        for iPos from 0 to iMax 
93320>>>>
93320>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName 
93323>>>            Move (Lowercase(sName)) to sName 
93324>>>            If (sName = sField) Begin
93326>>>                Function_Return iPos 
93327>>>            End
93327>>>>
93327>>>        Loop
93328>>>>
93328>>>        Function_Return -1 
93329>>>    End_Function
93330>>>
93330>>>
93330>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
93330>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
93330>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
93330>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
93330>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
93330>>>    //   ALTER TABLE MyTable
93330>>>    //       REBUILD
93330>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
93332>>>        Boolean bOK
93332>>>
93332>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
93334>>>            Function_Return False
93335>>>        End
93335>>>>
93335>>>
93335>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
93335>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
93336>>>
93336>>>        Function_Return (bOK = True)
93337>>>    End_Function
93338>>>
93338>>>
93338>>>    // *** Helper functions with compiled sql script code ***
93338>>>    //
93338>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
93338>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
93338>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
93338>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
93338>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
93338>>>    //   ALTER TABLE MyTable
93338>>>    //       REBUILD
93338>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
93340>>>        tSQLScriptArray SQLScriptArray
93340>>>        tSQLScriptArray SQLScriptArray
93340>>>        String sDriverID sVal
93340>>>        Boolean bOK
93340>>>        Integer iSize iCount
93340>>>
93340>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
93342>>>            Function_Return False
93343>>>        End
93343>>>>
93343>>>
93343>>>        Get psDriverID to sDriverID
93344>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
93345>>>        If (SQLScriptArray.bError = True) Begin
93347>>>            Function_Return False
93348>>>        End
93348>>>>
93348>>>
93348>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
93349>>>        Decrement iSize
93350>>>
93350>>>        for iCount from 0 to iSize
93356>>>>
93356>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
93358>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
93359>>>            End
93359>>>>
93359>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
93361>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
93362>>>            End
93362>>>>
93362>>>        Loop
93363>>>>
93363>>>
93363>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
93364>>>
93364>>>        Function_Return (bOK = True)
93365>>>    End_Function
93366>>>
93366>>>    // *** Helper functions for Mertech Drivers ***
93366>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
93366>>>    // and commands that the Studio editor knows nothing about.
93366>>>    Function _MertechDeleteTDFile String sTableName Returns Integer
93368>>>        Integer iRetval
93368>>>        String sPath
93368>>>
93368>>>        If (sPath = "" or sTableName = "") Begin
93370>>>            Function_Return 0
93371>>>        End
93371>>>>
93371>>>
93371>>>        Get vFolderFormat sPath to sPath
93372>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
93373>>>        Function_Return iRetval
93374>>>    End_Function
93375>>>
93375>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
93377>>>        Move False to Err
93378>>>        Function_Return (Err = False)
93379>>>    End_Function
93380>>>
93380>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
93382>>>        Integer iNumItems iCount
93382>>>        String[] sReturnArray
93383>>>        String sServer
93383>>>
93383>>>
93383>>>        Function_Return sReturnArray
93384>>>    End_Function
93385>>>
93385>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
93387>>>        String[] sReturnArray
93388>>>        String sServer
93388>>>
93388>>>
93388>>>        Function_Return sReturnArray
93389>>>    End_Function
93390>>>
93390>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
93392>>>        Handle hoSQLHandler hoSQLConnect
93392>>>
93392>>>        Move 0 to hoSQLConnect
93393>>>
93393>>>        Function_Return hoSQLConnect
93394>>>    End_Function
93395>>>
93395>>>    // Returns the handle of the Mertech SQL handler.
93395>>>    // It also ensures that the correct Server & Database attributes are set both for
93395>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
93395>>>    Function _MertechSQLManagerHandle Returns Handle
93397>>>        Handle hoSQLHandler
93397>>>        String sDriverID sServer sDatabase
93397>>>
93397>>>        Move 0 to hoSQLHandler
93398>>>        Get psDriverID to sDriverID
93399>>>        Get psServer   to sServer
93400>>>        Get psDatabase to sDatabase
93401>>>
93401>>>        Function_Return hoSQLHandler
93402>>>    End_Function
93403>>>
93403>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
93403>>>    // macro-commands <sigh!>
93403>>>    // Note: The function sets the Err flag.
93403>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
93405>>>        Move False to Err
93406>>>
93406>>>
93406>>>        Function_Return (Err = False)
93407>>>    End_Function
93408>>>
93408>>>End_Class
93409>Use AddToStudio.dg
Including file: AddToStudio.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\AddToStudio.dg)
93409>>>Use Windows.pkg
93409>>>Use Dfspnfrm.pkg
93409>>>Use cRegistry.pkg
93409>>>Use vWin32fh.pkg
93409>>>
93409>>>Enum_List
93409>>>    Define cx_RegKeyAlreadyExist
93409>>>    Define cx_RegKeyCreated
93409>>>    Define cx_RegkeyFailed
93409>>>    Define cx_RegKeyVDFKeyDoesNotExist
93409>>>    Define CX_InstalledOkVdfUnder16
93409>>>End_Enum_List
93409>>>
93409>>>// Note: The "Visual" part will automatically be removed if
93409>>>// the current DataFlex version is above 17.
93409>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
93409>>>Define CS_StudioTools       for "\Studio\Tools"
93409>>>Define CS_RegApplication    for "<application>"
93409>>>Define CS_RegWorkspace      for "<workspace>"
93409>>>Define CS_CommandLine       for "CommandLine"
93409>>>Define CS_Name              for "Name"
93409>>>Define CS_Separator         for "Separator"
93409>>>Define CS_Command           for "Command"
93409>>>
93409>>>
93409>>>Object oAddToStudio_dg is a ModalPanel
93411>>>    Set Size to 81 330
93412>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
93413>>>    Set piMinSize to 79 211
93414>>>    Set Location to 5 4
93415>>>    Set Locate_Mode to Center_On_Parent
93416>>>
93416>>>    Property String psTag CS_RegApplication
93418>>>
93418>>>    Object oStudioIntegration_grp is a Group
93420>>>        Set Size to 45 299
93421>>>        Set Location to 8 15
93422>>>        Set Label to "DataFlex Studio Integration"
93423>>>
93423>>>        Object oStudioMajorVersion_sf is a SpinForm
93425>>>            Set Size to 12 27
93426>>>            Set Location to 18 168
93427>>>            Set Maximum_Position to 30
93428>>>            Set Minimum_Position to 14
93429>>>            Set Label_Col_Offset to 2
93430>>>            Set Label_Justification_Mode to JMode_Right
93431>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
93432>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
93433>>>            Set Value to FMAC_VERSION
93434>>>            Set peAnchors to anNone
93435>>>        End_Object
93436>>>
93436>>>        Object oStudioMinorVersion_sf is a SpinForm
93438>>>            Set Size to 12 27
93439>>>            Set Location to 18 254
93440>>>            Set Label_Col_Offset to 2
93441>>>            Set Label to "Minor Version"
93442>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
93443>>>            Set Maximum_Position to 9
93444>>>            Set Minimum_Position to 0
93445>>>            Set Value to FMAC_REVISION
93446>>>            Set Label_Justification_Mode to JMode_Right
93447>>>            Set peAnchors to anNone
93448>>>        End_Object
93449>>>
93449>>>    End_Object
93450>>>
93450>>>    Object oOK_btn is a Button
93452>>>        Set Size to 14 50
93453>>>        Set Location to 59 207
93454>>>        Set Label to "Add Now"
93455>>>        Set Status_Help to "Add to DataFlex Studios 'Tools' menu. The Studio version can be selected with the two spinforms. The COMManifestStudio program gets added to the Studios Tools menu. When selected from the Studio it will pass the current project name on the command line so that the current program's manifest file is automatically loaded by the COMManifestStudio program."
93456>>>        Set peAnchors to anTopRight
93457>>>
93457>>>        Procedure OnClick
93460>>>            Integer iRetval iMajorVersion iMinorVersion
93460>>>            String sText sStudioVersion
93460>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
93461>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
93462>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
93463>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
93464>>>            Case Begin
93464>>>                Case (iRetval = cx_RegKeyAlreadyExist)
93466>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
93467>>>                    Break
93468>>>                Case (iRetval = cx_RegKeyCreated)
93471>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
93472>>>                    Break
93473>>>                Case (iRetval = cx_RegkeyFailed)
93476>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
93477>>>                    Break
93478>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
93481>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
93482>>>                    Break
93483>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
93486>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
93487>>>                    Break
93488>>>            Case End
93488>>>
93488>>>            Send Info_Box sText
93489>>>        End_Procedure
93490>>>    End_Object
93491>>>
93491>>>    Object oCancel_Btn is a Button
93493>>>        Set Label to "&Close"
93494>>>        Set Location to 59 264
93495>>>        Set peAnchors to anBottomRight
93496>>>
93496>>>        Procedure OnClick
93499>>>            Send Close_Panel
93500>>>        End_Procedure
93501>>>
93501>>>    End_Object
93502>>>
93502>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
93505>>>        Boolean bOk bExists bOpen
93505>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
93505>>>        Handle hoReg hoArray
93505>>>        Integer i iItems iCreated iRetval
93505>>>
93505>>>        Move False to bOk
93506>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
93507>>>        If (sStudioVersion > "17.1") Begin
93509>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
93510>>>        End
93510>>>>
93510>>>
93510>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
93511>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
93512>>>        Get vFolderFormat sProgramPath to sProgramPath
93513>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
93514>>>        Get Module_Name to sProgram
93515>>>        Get Create U_cRegistry to hoReg
93516>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
93517>>>
93517>>>        // First check if the DataFlex version is installed
93517>>>        Get KeyExists of hoReg sStudioPath to bExists
93518>>>        If (bExists = False) Begin
93520>>>            Send Destroy of hoReg
93521>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
93522>>>        End
93522>>>>
93522>>>
93522>>>        // Then check if any tools have been installed in the Tools Menu.
93522>>>        // If no tools created yet, create the Tools registry key.
93522>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
93523>>>        Get KeyExists of hoReg sStudioPath to bExists
93524>>>        If (bExists = False) Begin
93526>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
93527>>>            Get CreateKey of hoReg sStudioPath to iCreated
93528>>>            If (iCreated <> 0) Begin
93530>>>                Move cx_RegkeyFailed to iRetval
93531>>>            End
93531>>>>
93531>>>            Else Begin
93532>>>                Move True to bExists
93533>>>            End
93533>>>>
93533>>>        End
93533>>>>
93533>>>
93533>>>        If (bExists = True) Begin
93535>>>            Get OpenKey of hoReg sStudioPath to bOk
93536>>>            If (bOk = True) Begin
93538>>>                Get Create U_Array to hoArray
93539>>>                Get GetSubkeys of hoReg hoArray to iItems
93540>>>                Decrement iItems
93541>>>                Move False to bExists
93542>>>                Set pfAccessRights of hoReg to KEY_READ
93543>>>                // Check if the key already exists:
93543>>>                For i from 0 to iItems
93549>>>>
93549>>>                    Get Value of hoArray item i to sKey
93550>>>                    Move (sStudioPath + "\" + sKey) to sKey
93551>>>                    Get OpenKey of hoReg sKey to bOpen
93552>>>                    If (bOpen = True) Begin
93554>>>                        Get ReadString of hoReg CS_Name to sValue
93555>>>                        If (sValue = sProduct) Move True to bExists
93558>>>                    End
93558>>>>
93558>>>                Loop
93559>>>>
93559>>>                Send Destroy of hoArray
93560>>>                If (bExists = False) Begin
93562>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
93563>>>                    // We need to create the next key number:
93563>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
93563>>>                    Increment iItems
93564>>>                    Increment iItems
93565>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
93566>>>                    If (iCreated = 0) Begin
93568>>>                        Send WriteString of hoReg CS_Name sProduct
93569>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
93569>>>                        If (sStudioVersion >= "16.0") Begin
93571>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
93572>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
93573>>>                        End
93573>>>>
93573>>>                        Else Begin
93574>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
93575>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
93576>>>                        End
93576>>>>
93576>>>                        Send WriteDword  of hoReg CS_Separator 1
93577>>>                        Move cx_RegKeyCreated to iRetval
93578>>>                    End
93578>>>>
93578>>>                    Else Begin
93579>>>                        Move cx_RegkeyFailed to iRetval
93580>>>                    End
93580>>>>
93580>>>                End
93580>>>>
93580>>>                Else Begin
93581>>>                    Move cx_RegKeyAlreadyExist to iRetval
93582>>>                End
93582>>>>
93582>>>                Send CloseKey of hoReg
93583>>>            End
93583>>>>
93583>>>        End
93583>>>>
93583>>>
93583>>>        Send Destroy of hoReg
93584>>>        Function_Return iRetval
93585>>>    End_Function
93586>>>
93586>>>    Procedure Page Integer iPageObject
93589>>>        Forward Send Page iPageObject
93591>>>        Set Icon to "SQLConnections.ico"
93592>>>    End_Procedure
93593>>>
93593>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
93594>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
93595>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
93596>>>End_Object
93597>Set psTag of (oAddToStudio_dg(Self)) to CS_RegWorkspace
93598>
93598>Object oCreateDbVersionTable_pnl is a BasicPanel
93600>    Set Location to 1 0
93601>    Set Size to 204 398
93602>    Set Locate_Mode to Center_On_Screen
93603>    Set Label to "The Database Update Framework - Create a DbVersion Table"
93604>    Set Icon to "DbUpdate.ico"
93605>    Set pbAcceptDropFiles to True
93606>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
93607>    Set Maximize_Icon to False
93608>
93608>    Property Handle phoDialogCommandbar
93610>
93610>    Object oDbUpdateFunctionLibrary is a cDbUpdateFunctionLibrary
93612>    End_Object
93613>
93613>    Object oGeneralInfo_tb is a TextBox
93615>        Set Auto_Size_State to False
93616>        Set Size to 33 342
93617>        Set Location to 18 27
93618>        Set Label to "Utility to create a system table and a column to keep the database update version to be used for the Entry_Item in the cDbUpdateHandler object. There is also a function 'SQLCreateDbVersionTable' for creating it as a SQL table at customer site."
93619>        Set Justification_Mode to JMode_Left
93620>        Set FontItalics to True
93621>    End_Object
93622>
93622>    Object oLineControl is a LineControl
93624>        Set Size to 2 374
93625>        Set Location to 63 12
93626>        Set peAnchors to anTopLeftRight
93627>    End_Object
93628>
93628>    Object oFileList_fm is a Form
93630>        Set Size to 13 246
93631>        Set Location to 89 27
93632>        Set Label to "Filelist.cfg:     (You can drop a Filelist.cfg here)"
93633>        Set Label_Col_Offset to 0
93634>        Set Label_Justification_Mode to JMode_Top
93635>        Set peAnchors to anTopLeftRight
93636>        Set Enabled_State to False
93637>        Set Label_Row_Offset to 1
93638>        Set FontWeight to fw_Bold
93639>
93639>        Procedure Prompt
93642>            String sValue sPath sFilelistName sFileMask
93642>            Get Value to sValue
93643>
93643>            Move (Trim(sValue)) to sValue
93644>            If (sValue <> "") Begin
93646>                Get ParseFolderName sValue to sPath
93647>            End
93647>
93647>            Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
93648>            Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sFilelistName
93649>            If (sFilelistName <> "") Begin
93651>                Set Value to sFilelistName
93652>            End
93652>        End_Procedure
93653>
93653>        Procedure OnChange
93656>            String sFilelistName sPath sOpenPath sDataPath sDdSrcPath sHomeFolder sDataFolder
93656>            Handle hTable
93656>            Boolean bOK bExists
93656>
93656>            Get psOpenPath of ghoApplication to sOpenPath
93657>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93658>            If (sOpenPath contains sDataPath) Begin
93660>                Move (Replace((sDataPath + "\;"), sOpenPath, "")) to sOpenPath
93661>            End
93661>
93661>            Get Value to sFilelistName
93662>            // This might be true if there was no .ws file on startup.
93662>            If (sFilelistName = "") Begin
93664>                Send Prompt
93665>                Procedure_Return
93666>            End
93666>            Get ParseFolderName sFilelistName to sPath
93667>            If (Right(sPath, 1) ="\") Begin
93669>                Move (Left(sPath, Length(sPath) -1)) to sPath
93670>            End
93670>            If (sPath = "") Begin
93672>                Procedure_Return
93673>            End
93673>            Set_Directory sPath
93674>
93674>            Set_Attribute DF_OPEN_PATH to (sPath + ";" + sOpenPath)
93677>            Set_Attribute DF_FILELIST_NAME to sFilelistName
93680>            // Change output folder so files are written to the correct Data folder.
93680>            // For some reason the psDataPath isn't used by default by the Structure_End command.
93680>
93680>            Set psDataPath of (phoWorkspace(ghoApplication))  to sPath
93681>            Set psFileList of (phoWorkspace(ghoApplication))  to sFilelistName
93682>
93682>            // We also need to output the .fd file if in development environment.
93682>            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDdSrcPath
93683>            If (not(sOpenPath contains sDdSrcPath)) Begin
93685>                Get ExtractFilePath of (phoWorkspace(ghoApplication)) sPath to sHomeFolder
93686>                Move (Append(sHomeFolder, "DdSrc")) to sDdSrcPath
93687>                Get vFolderExists sDdSrcPath to bExists
93688>                If (bExists = True) Begin
93690>                    Set psDdSrcPath of (phoWorkspace(ghoApplication)) to sDdSrcPath
93691>                End
93691>            End
93691>            Move 0 to hTable
93692>            Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
93695>            Set Value of oTableNo_sf to hTable
93696>        End_Procedure
93697>
93697>        Procedure Activating
93700>            String sFilelistName
93700>            Forward Send Activating
93702>            Get psFilelistName of ghoApplication to sFilelistName
93703>            Set Value to sFilelistName
93704>        End_Procedure
93705>
93705>    End_Object
93706>
93706>    Object oSelect_btn is a Button
93708>        Set Size to 13 61
93709>        Set Location to 89 309
93710>        Set Label to "Select..."
93711>        Set psToolTip to "Select a Filelist.cfg from a Data folder where an embedded DbVersion table should be created."
93712>        Set peAnchors to anTopRight
93713>
93713>        Procedure OnClick
93716>            Send Prompt of oFileList_fm
93717>        End_Procedure
93718>
93718>    End_Object
93719>
93719>    Object oTableName_fm is a Form
93721>        Set Size to 13 100
93722>        Set Location to 125 27
93723>        Set Label to "Table Name:"
93724>        Set Label_Col_Offset to 0
93725>        Set Label_Row_Offset to 1
93726>        Set Label_Justification_Mode to JMode_Top
93727>        Set Enabled_State to False
93728>        Set Value to "DbVersion"
93729>    End_Object
93730>
93730>    Object oColumnName_fm is a Form
93732>        Set Size to 13 84
93733>        Set Location to 125 133
93734>        Set Label to "Column Name:"
93735>        Set Label_Col_Offset to 0
93736>        Set Label_Row_Offset to 1
93737>        Set Label_Justification_Mode to JMode_Top
93738>        Set Enabled_State to False
93739>        Set Value to "DatabaseVersion"
93740>    End_Object
93741>
93741>    Object oDataType_cf is a ComboForm
93743>        Set Size to 11 63
93744>        Set Location to 125 225
93745>        Set Label to "Data Type:"
93746>        Set Label_Col_Offset to 0
93747>        Set Label_Row_Offset to 1
93748>        Set Label_Justification_Mode to JMode_Top
93749>        Set Entry_State to False
93750>        Set Enabled_State to False
93751>
93751>        Procedure Combo_Fill_List
93754>            tColumnType[] ColumnTypeArray
93754>            tColumnType[] ColumnTypeArray
93755>            Integer iSize iCount iStart
93755>
93755>            Send Delete_Data
93756>            Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
93757>            Move (SizeOfArray(ColumnTypeArray)) to iSize
93758>            Decrement iSize
93759>            For iCount from 0 to iSize
93765>                Send Combo_Add_Item ColumnTypeArray[iCount].sType
93766>            Loop
93767>            Set Value to "NUMERIC"
93768>            Set Enabled_State of oLength_sf to False
93769>            Set Enabled_State of oDecimals_sf to False
93770>            Set Value of oLength_sf   to 4
93771>            Set Value of oDecimals_sf to 2
93772>        End_Procedure
93773>
93773>        Procedure OnChange
93776>            String sDataType sPrecision
93776>            Integer iDataType iSize iDec
93776>            Boolean bFixed
93776>
93776>            Get SelectedType to iDataType
93777>            Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to iSize
93778>            Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to iDec
93779>            Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iDataType to bFixed
93780>            Set Enabled_State of oLength_sf   to (bFixed = False)
93781>            Set Enabled_State of oDecimals_sf to (bFixed = False)
93782>            Set Value of oLength_sf to iSize
93783>            If (iDec = 0) Begin
93785>                Set Value of oDecimals_sf to ""
93786>            End
93786>            Else Begin
93787>                Set Value of oDecimals_sf to iDec
93788>            End
93788>            If (bFixed = False) Begin
93790>                Set Enabled_State of oDecimals_sf to (iDec <> 0)
93791>            End
93791>        End_Procedure
93792>
93792>        Function SelectedType Returns Integer
93795>            String sDataType
93795>            Integer iDataType
93795>
93795>            Get Value to sDataType
93796>            Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sDataType to iDataType
93797>
93797>            Function_Return iDataType
93798>        End_Function
93799>
93799>    End_Object
93800>
93800>    Object oLength_sf is a SpinForm
93802>        Set Label to "Length:"
93803>        Set Size to 13 38
93804>        Set Location to 125 297
93805>        Set Label_Col_Offset to 0
93806>        Set Label_Justification_Mode to JMode_Top
93807>        Set Label_Row_Offset to 1
93808>        Set Value to "4"
93809>        Set Maximum_Position to 50
93810>        Set Minimum_Position to 1
93811>        Set Enabled_State to False
93812>    End_Object
93813>
93813>    Object oDecimals_sf is a SpinForm
93815>        Set Label to "Decimals:"
93816>        Set Size to 13 33
93817>        Set Location to 125 344
93818>        Set Label_Col_Offset to 0
93819>        Set Label_Justification_Mode to JMode_Top
93820>        Set Label_Row_Offset to 1
93821>        Set Value to "2"
93822>        Set Maximum_Position to 8
93823>        Set Minimum_Position to 1
93824>        Set Enabled_State to False
93825>    End_Object
93826>
93826>    Object oTableNo_sf is a SpinForm
93828>        Set Label to "Filelist No:"
93829>        Set psToolTip to "When a new Filelist.cfg is selected, the first free slot number will be shown here."
93830>        Set Size to 13 32
93831>        Set Location to 155 27
93832>        Set Label_Col_Offset to 0
93833>        Set Label_Justification_Mode to JMode_Top
93834>        Set Label_Row_Offset to 1
93835>        Set Value to "2"
93836>        Set Maximum_Position to 4095
93837>        Set Minimum_Position to 1
93838>    End_Object
93839>
93839>    Object oFilelistInfo_tb is a TextBox
93841>        Set Size to 9 138
93842>        Set Location to 157 64
93843>        Set Label to "Default is to use the first free Filelist.cfg slot"
93844>    End_Object
93845>
93845>    Object oUseDefaults_cb is a CheckBox
93847>        Set Size to 10 50
93848>        Set Location to 157 225
93849>        Set Label to "Change Defaults"
93850>        Set psToolTip to "You REALLY have to know what you're doing if you want to change the defaults! Leave them as is if you are not 100% sure."
93851>
93851>        Procedure OnChange
93854>            Boolean bChecked
93854>
93854>            Get Checked_State to bChecked
93855>            Set Enabled_State of oTableName_fm  to (bChecked = True)
93856>            Set Enabled_State of oColumnName_fm to (bChecked = True)
93857>            Set Enabled_State of oDataType_cf   to (bChecked = True)
93858>            Set Enabled_State of oLength_sf     to (bChecked = True)
93859>            Set Enabled_State of oDecimals_sf   to (bChecked = True)
93860>        End_Procedure
93861>
93861>    End_Object
93862>
93862>    Object oCreateTable_btn is a Button
93864>        Set Size to 14 54
93865>        Set Location to 155 309
93866>        Set Label to "Create Table"
93867>        Set FontWeight to fw_Bold
93868>        Property String psToolTip1 "This will create a table & column for the Embedded database, to be used with the DataFlex Update Framework."
93870>        Property String psToolTip2 "There is also a 'SQLCreateDbVersionTable' function that can be used to create/move the Table at customer site to SQL."
93872>        Set psToolTip to (psToolTip1(Self) + psToolTip2(Self))
93873>
93873>        Procedure OnClick
93876>            String sTableName sColumnName sInfoTxt1 sInfoTxt2 sDataType sFileList sDataPath
93876>            Integer iLength iDecimals iDataType iRetval iMin iMax
93876>            Boolean bOK
93876>            Handle hTable
93876>
93876>            Get Value of oFileList_fm  to sFileList
93877>            Get Value of oTableName_fm to sTableName
93878>            Move (Trim(sTableName))    to sTableName
93879>            If (sTableName = "") Begin
93881>                Send Info_Box "You first need to enter a table name."
93882>                Procedure_Return
93883>            End
93883>
93883>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93884>            Get vFolderFormat sDataPath to sDataPath
93885>            Set psDriverID                      of ghoDbUpdateFunctionLibrary to DATAFLEX_ID
93886>            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to iRetval
93887>            If (iRetval <> 0) Begin
93889>                Send Info_Box ("Sorry, a table named: '" + sTableName + "' already exists in" * sFileList + "!")
93890>                Procedure_Return
93891>            End
93891>
93891>            Get Value of oColumnName_fm      to sColumnName
93892>            Move (Trim(sColumnName))         to sColumnName
93893>            If (sColumnName = "") Begin
93895>                Send Info_Box "You need to enter a column name."
93896>                Procedure_Return
93897>            End
93897>
93897>            Get Value        of oDataType_cf to sDataType
93898>            Get SelectedType of oDataType_cf to iDataType
93899>            Get Value        of oLength_sf   to iLength
93900>            If (iLength < 1) Begin
93902>                Send Info_Box "You need to enter a proper length for the column"
93903>                Procedure_Return
93904>            End
93904>            Get Value of oDecimals_sf to iDecimals
93905>
93905>            Get Value of oTableNo_sf  to hTable
93906>            Get Maximum_Position of oTableNo_sf to iMax
93907>            Get Minimum_Position of oTableNo_sf to iMin
93908>            If (hTable < iMin or hTable > iMax) Begin
93910>                Send Info_Box "The selected Filelist number must be in the range: 1-4095"
93911>                Procedure_Return
93912>            End
93912>            Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bOK
93913>            If (bOK = True) Begin
93915>                Send Info_Box "The selected Filelist number exists and cannot be used to create a new table!"
93916>                Procedure_Return
93917>            End
93917>
93917>            // Reserved filelist numbers 48-50, 250-300
93917>            Move (hTable <> 48 and hTable <> 49 and hTable <> 50 and (hTable < 250 or hTable > 300)) to bOK
93918>            If (bOK = False) Begin
93920>                Send Info_Box "The selected Filelist number is in the range of reserved filelist numbers; 48-50 and 250-300"
93921>                Procedure_Return
93922>            End
93922>
93922>            Get psToolTip1 to sInfoTxt1
93923>            Get psToolTip2 to sInfoTxt2
93924>            Get YesNo_Box (sInfoTxt1 + "\n\n" + sInfoTxt2 + "\n\nContinue?") to iRetval
93925>            If (iRetval <> MBR_Yes) Begin
93927>                Procedure_Return
93928>            End
93928>
93928>            Send Cursor_Wait of Cursor_Control
93929>
93929>            Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName False True True to bOk
93930>            If (bOk = False) Begin
93932>                Send Info_Box "Sorry, it didn't work to create the table."
93933>                Procedure_Return
93934>            End
93934>
93934>            Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
93935>            Get ApiColumnAdd            of ghoDbUpdateFunctionLibrary hTable sColumnName iDataType iLength iDecimals to bOk
93936>            If (bOK = True) Begin
93938>                Move ("The table was created and Column '" + sColumnName + "'" * sDataType * String(iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt1
93939>            End
93939>            Else Begin
93940>                Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt1
93941>            End
93941>            Send Cursor_Ready of Cursor_Control
93942>            Send Info_Box sInfoTxt1
93943>        End_Procedure
93944>
93944>    End_Object
93945>
93945>    Procedure OnFileDropped String sFilename Boolean bLast
93948>        String sFilelistName
93948>
93948>        Forward Send OnFileDropped sFilename bLast
93950>
93950>        Move (Trim(sFilename)) to sFilename
93951>        Get ExtractFileName sFilename   to sFilelistName
93952>        Move (Uppercase(sFilelistName)) to sFilelistName
93953>        If (bLast = True and sFilelistName = "FILELIST.CFG") Begin
93955>            Set Value     of oFileList_fm to sFilename
93956>            Send OnChange of oFileList_fm
93957>        End
93957>    End_Procedure
93958>
93958>    // Put a status bar at the bottom of the panel, which makes
93958>    // status_help work and puts a gripper in the lower right corner.
93958>    Procedure End_Construct_Object
93961>        Integer iStyle iSize iOffset
93961>
93961>        Forward Send End_Construct_Object
93963>
93963>        Get Border_Style to iStyle
93964>        Move 8 to iOffset
93965>        If (iStyle = Border_Thick) Begin
93967>            Object oDialogCommandbar is a cCJCommandBarSystem
93969>                Object oStatusBar is a cCJStatusBar
93971>                    Set phoDialogCommandbar to Self
93972>                    Object oStatusIdle is a cCJStatusBarPane
93974>                        Set piId to sbpIDIdlePane
93975>                        Set pbStyleStretch to True
93976>                    End_Object
93977>                End_Object
93978>            End_Object
93979>            Get Size to iSize
93980>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
93981>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
93982>        End
93982>
93982>    End_Procedure
93983>
93983>    Procedure Popup
93986>        Set Statusbar_Id to (phoDialogCommandbar(Self))
93987>        Forward Send Popup
93989>    End_Procedure
93990>
93990>    Procedure Page Integer iPageObject
93993>        Integer hWnd
93993>        Forward Send Page iPageObject
93995>
93995>        Get Window_Handle to hWnd
93996>
93996>        If ((ghoSkinFramework<>0) and (hWnd<>0)) Begin
93998>            Send ComRemoveWindow to ghoSkinFramework hWnd
93999>            Send ComApplyWindow  to ghoSkinFramework hWnd
94000>        End
94000>    End_Procedure
94001>
94001>    Object oAddToStudio_btn is a Button
94003>        Set Size to 14 52
94004>        Set Location to 179 82
94005>        Set Label to "Add to Studio"
94006>        Set peAnchors to anNone
94007>        Set psToolTip to "Dialog that adds this program to the Studio's 'Tools' menu."
94008>
94008>        Procedure OnClick
94011>            Send Popup of oAddToStudio_dg
94012>        End_Procedure
94013>
94013>    End_Object
94014>
94014>    Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StdAbout.pkg)
94014>>>//************************************************************************
94014>>>// Confidential Trade Secret.
94014>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
94014>>>// as an unpublished work.  All rights reserved.
94014>>>// DataFlex is a registered trademark of Data Access Corporation.
94014>>>//
94014>>>//************************************************************************
94014>>>//************************************************************************
94014>>>//
94014>>>// $File name  : StdAbout.pkg
94014>>>// $File title : Standard about object package for VDF
94014>>>// Notice      :
94014>>>// $Author(s)  : John Tuohy
94014>>>//
94014>>>// $Rev History
94014>>>//
94014>>>// JT 06/27/97   File created
94014>>>//************************************************************************
94014>>>
94014>>>// This provides a quick and simple way to create an about package for a program.
94014>>>// You need to create a message inside you client area called Activate_About.
94014>>>// Within this message you should send the message DoAbout passing needed
94014>>>// string information.
94014>>>//
94014>>>//       Procedure Activate_About
94014>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
94014>>>//       End_Procedure
94014>>>//    where: sTitle =     Name of application. If none provided, uses caption
94014>>>//                        bar title
94014>>>//           sVersion   = Version Line. If none provided, will be blank
94014>>>//           sCopyRight = Copyright Line. If none provided, will be blank
94014>>>//           sAuthor    = Author name, blank if none provided
94014>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
94014>>>//                        is used.
94014>>>// It is expected that you will place this in your own object package. For
94014>>>// example an order about package may look like this:
94014>>>//
94014>>>//   // OrderAbout.pkg
94014>>>//   Use StdAbout.pkg
94014>>>//   Procedure Activate_About
94014>>>//      String sTitle sCopyright sVersion sAuthor
94014>>>//      Move "My Order Entry System" to sTitle
94014>>>//      Move "Version 2.1" to sVersion
94014>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
94014>>>//      Move "John Smith"  to sAuthor
94014>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
94014>>>//   end_procedure
94014>>>//   // end of file.
94014>>>
94014>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DfAbout.pkg)
94014>>>>>//************************************************************************
94014>>>>>// Confidential Trade Secret.
94014>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
94014>>>>>// as an unpublished work.  All rights reserved.
94014>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
94014>>>>>//
94014>>>>>//************************************************************************
94014>>>>>//************************************************************************
94014>>>>>//
94014>>>>>// $File name  : DfAbout.pkg
94014>>>>>// $File title : About class support
94014>>>>>// Notice      :
94014>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
94014>>>>>//
94014>>>>>// $Rev History
94014>>>>>//
94014>>>>>// NGS 08/16/2013 Improved by using a cRichEdit object were the params gets added to.
94014>>>>>//                The objects that previously were popupated with values from the params,
94014>>>>>//                and their corresponding "Procedure Set..." messages, were removed as
94014>>>>>//                the edit object is used instead.
94014>>>>>//                The number of params to the DoAbout procedure was increased to ten, so
94014>>>>>//                it is easier to add whatever extra text strings needed/wanted.
94014>>>>>//                The StdAbout.pkg was also changed for this to work. It allows for an extra
94014>>>>>//                five new params to be passed, but these new params are all optional.
94014>>>>>//                So the interface will work exactly as before - if no extra parameters are passed.
94014>>>>>//                Also added an extra bitmap object to show the "Powered By Visual DataFlex" logo, in
94014>>>>>//                the lower left corner of the About object, beneath the "main" About bitmap.
94014>>>>>//                Note: It is assumed that the bitmap "PoweredByVisualDataFlex.bmp" exists.
94014>>>>>//                The background was changed to clWhite for easier usage of bitmaps. Just set the background
94014>>>>>//                color of your bitmap to white and the bitmap will not look jagged.
94014>>>>>//                If an Internet address is passed as one of the params, it will be underlined and clickable.
94014>>>>>//                An e-mail address can also be passed; e.g. "E-mail: mailto:mail@myemailaccount.com" and will
94014>>>>>//                also be clickable.
94014>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
94014>>>>>//                Windows for the size first.
94014>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
94014>>>>>//                with anchor technique. Removed unnessary property in the
94014>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
94014>>>>>//                object To better look in Windows XP. Repositioned the close
94014>>>>>//                button in the sysinfo dialog To line up with the display area
94014>>>>>//                Replaced obsolete code and techniques. Removed dead code.
94014>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
94014>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
94014>>>>>//                the global Workspace object, if it is present
94014>>>>>// JJT 11/05/98   Added version information
94014>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
94014>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
94014>>>>>//                workspace package.
94014>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
94014>>>>>//                class can create this object.
94014>>>>>//                Cleaned up the interface (used correct classes and messages)
94014>>>>>//                Added workspace reporting support To sys-info.
94014>>>>>//                Turned off wrapping in the sys-info editor.
94014>>>>>// KR  ??/??/96   File created
94014>>>>>//************************************************************************
94014>>>>>Use LanguageText.pkg
94014>>>>>Use Windows.pkg
94014>>>>>Use DFbitmap.pkg
94014>>>>>Use GlobalFunctionsProcedures.pkg
94014>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cRichEdit.pkg)
94014>>>>>>>use Windows.pkg
94014>>>>>>>Use cEdit_Mixin.pkg
94014>>>>>>>
94014>>>>>>>// DFO: cRichEdit.Dfo
94014>>>>>>>// DFC: cRichEdit.Dfc
94014>>>>>>>
94014>>>>>>>// constants used for RichEdit Properties
94014>>>>>>>// peAlignment 
94014>>>>>>>Enum_List 
94014>>>>>>>    Define alLeft   for 1 
94014>>>>>>>    Define alRight  for 2 
94014>>>>>>>    Define alCenter for 3 
94014>>>>>>>End_Enum_List 
94014>>>>>>>
94014>>>>>>>// peBullets 
94014>>>>>>>Enum_List 
94014>>>>>>>    Define buNone 
94014>>>>>>>    Define buBullets 
94014>>>>>>>    Define buArabicNumbers 
94014>>>>>>>    Define buLowerLetters 
94014>>>>>>>    Define buUpperLetters 
94014>>>>>>>    Define buLowerRomans 
94014>>>>>>>    Define buUpperRomans 
94014>>>>>>>End_Enum_List 
94014>>>>>>>
94014>>>>>>>// peBulletStyle 
94014>>>>>>>Enum_List 
94014>>>>>>>    Define busRightParen   for 0 
94014>>>>>>>    Define busEncloseParen for 256 
94014>>>>>>>    Define busPeriod       for 512 
94014>>>>>>>    Define busNumberOnly   for 768 
94014>>>>>>>    Define busNoDisplay    for 1024 
94014>>>>>>>End_Enum_List
94014>>>>>>>    
94014>>>>>>>// peLineSpacingType
94014>>>>>>>Enum_List 
94014>>>>>>>    Define lstSingle
94014>>>>>>>    Define lstSingleAndOneHalf
94014>>>>>>>    Define lstDouble
94014>>>>>>>End_Enum_List
94014>>>>>>>
94014>>>>>>>Class cRichEdit Is A DFBaseRichEdit
94015>>>>>>>
94015>>>>>>>    Procedure Construct_Object
94017>>>>>>>        Forward Send Construct_Object
94019>>>>>>>        Send Define_cEdit_Mixin
94020>>>>>>>
94020>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
94021>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
94022>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
94023>>>>>>>
94023>>>>>>>    End_Procedure // Construct_Object
94024>>>>>>>
94024>>>>>>>    Import_Class_Protocol cEdit_Mixin
94025>>>>>>>    
94025>>>>>>>    Procedure ToggleBold
94027>>>>>>>        Set pbBold to (not(pbBold(self))) 
94028>>>>>>>    end_procedure
94029>>>>>>>    
94029>>>>>>>    Procedure ToggleItalics
94031>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
94032>>>>>>>    end_procedure
94033>>>>>>>    
94033>>>>>>>    Procedure ToggleUnderline
94035>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
94036>>>>>>>    end_procedure
94037>>>>>>>
94037>>>>>>>End_Class
94038>>>>>>>
94038>>>>>Use cTextEdit.pkg
94038>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\gFormatNumbers.pkg)
94038>>>>>>>//****************************************************************************//
94038>>>>>>>//                                                                            //
94038>>>>>>>// $File name  : gFormatNumbers.pkg                                           //
94038>>>>>>>// $File title : Globals for formating numbers and currency                   //
94038>>>>>>>// Notice      :                                                              //
94038>>>>>>>// $Author(s)  : John Tuohy                                                   //
94038>>>>>>>//                                                                            //
94038>>>>>>>// Confidential Trade Secret.                                                 //
94038>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
94038>>>>>>>// All Rights reserved                                                        //
94038>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
94038>>>>>>>// $Rev History                                                               //
94038>>>>>>>//                                                                            //
94038>>>>>>>// 25.08.99 Created                                                           //
94038>>>>>>>//****************************************************************************//
94038>>>>>>>
94038>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cFormatter.pkg)
94038>>>>>>>>>//****************************************************************************//
94038>>>>>>>>>//                                                                            //
94038>>>>>>>>>// $File name  : cFormatter.pkg                                               //
94038>>>>>>>>>// $File title : cFormatter class (private class)                             //
94038>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
94038>>>>>>>>>//                                                                            //
94038>>>>>>>>>// Confidential Trade Secret.                                                 //
94038>>>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
94038>>>>>>>>>// All Rights reserved                                                        //
94038>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
94038>>>>>>>>>//                                                                            //
94038>>>>>>>>>// $Rev History                                                               //
94038>>>>>>>>>//                                                                            //
94038>>>>>>>>>// 25.08.99 Created                                                           //
94038>>>>>>>>>//****************************************************************************//
94038>>>>>>>>>use VDFBase.pkg
94038>>>>>>>>>
94038>>>>>>>>>Class cFormatter is an cObject
94039>>>>>>>>>
94039>>>>>>>>>    Procedure Construct_object
94041>>>>>>>>>        Integer iCh
94041>>>>>>>>>        forward send construct_object
94043>>>>>>>>>        Property String  psCurrencySymbol
94044>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
94045>>>>>>>>>
94045>>>>>>>>>        Property string  psLeft
94046>>>>>>>>>        Property string  psright
94047>>>>>>>>>        Property integer pbThousandsSep
94048>>>>>>>>>        Property integer piPoints
94049>>>>>>>>>
94049>>>>>>>>>        Property string  psCurPosLeft
94050>>>>>>>>>        Property string  psCurPosright
94051>>>>>>>>>        Property integer pbCurPosThousandsSep
94052>>>>>>>>>        Property integer piCurPosPoints
94053>>>>>>>>>
94053>>>>>>>>>        Property string  psCurNegLeft
94054>>>>>>>>>        Property string  psCurNegright
94055>>>>>>>>>        Property integer pbCurNegThousandsSep
94056>>>>>>>>>        Property integer piCurNegPoints
94057>>>>>>>>>
94057>>>>>>>>>        Property string  psNumPosLeft
94058>>>>>>>>>        Property string  psNumPosright
94059>>>>>>>>>        Property integer pbNumPosThousandsSep
94060>>>>>>>>>        Property integer piNumPosPoints
94061>>>>>>>>>
94061>>>>>>>>>        Property string  psNumNegLeft
94062>>>>>>>>>        Property string  psNumNegright
94063>>>>>>>>>        Property integer pbNumNegThousandsSep
94064>>>>>>>>>        Property integer piNumNegPoints
94065>>>>>>>>>
94065>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" true  // currency
94066>>>>>>>>>        Send SetFormat  ",#.*"           false // numeric
94067>>>>>>>>>
94067>>>>>>>>>    end_procedure
94068>>>>>>>>>
94068>>>>>>>>>    // internal
94068>>>>>>>>>    // parse passed format string and set temporary properties with result
94068>>>>>>>>>    //
94068>>>>>>>>>    Procedure ParseFormat string sFmt
94070>>>>>>>>>
94070>>>>>>>>>        string sLeft sRight sDigit
94070>>>>>>>>>        integer bSep iPos i iDigits
94070>>>>>>>>>
94070>>>>>>>>>        // replace any literals. A "/" followed by anything.
94070>>>>>>>>>        // some literals are special. $ . , / #
94070>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
94071>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
94072>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
94073>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
94074>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
94075>>>>>>>>>        Move (Character(9)) to sDigit
94076>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
94077>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
94078>>>>>>>>>
94078>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
94079>>>>>>>>>        If bSep Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
94082>>>>>>>>>
94082>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(self))) to sFmt // replace any $ with currency symbol
94083>>>>>>>>>
94083>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
94084>>>>>>>>>
94084>>>>>>>>>        // Move all the special literals back into place before parsing
94084>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
94085>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
94086>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
94087>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
94088>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
94089>>>>>>>>>
94089>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
94091>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
94092>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
94094>>>>>>>>>               Move -2 to iDigits
94095>>>>>>>>>               increment i
94096>>>>>>>>>            end
94096>>>>>>>>>>
94096>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
94100>>>>>>>>>                 Increment i
94101>>>>>>>>>            end
94102>>>>>>>>>>
94102>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
94103>>>>>>>>>            If (iDigits=0) Move (i-1) to iDigits
94106>>>>>>>>>            //
94106>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
94107>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
94111>>>>>>>>>                 increment i
94112>>>>>>>>>            end
94113>>>>>>>>>>
94113>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
94114>>>>>>>>>        end
94114>>>>>>>>>>
94114>>>>>>>>>        else begin                             // we have no decinal
94115>>>>>>>>>            Move 0 to iDigits                  // so points is none
94116>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
94117>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
94119>>>>>>>>>                Move sFmt to sLeft
94120>>>>>>>>>                Move ""   to sRight
94121>>>>>>>>>            end
94121>>>>>>>>>>
94121>>>>>>>>>            else begin
94122>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
94123>>>>>>>>>                Move 1 to i
94124>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
94128>>>>>>>>>                    Increment i
94129>>>>>>>>>                end
94130>>>>>>>>>>
94130>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
94131>>>>>>>>>            end
94131>>>>>>>>>>
94131>>>>>>>>>        end
94131>>>>>>>>>>
94131>>>>>>>>>        // set temporary format properties and exit
94131>>>>>>>>>        Set pbThousandsSep to bSep
94132>>>>>>>>>        set psLeft         to sLeft
94133>>>>>>>>>        set psRight        to sRight
94134>>>>>>>>>        Set piPoints       to iDigits
94135>>>>>>>>>     End_procedure
94136>>>>>>>>>
94136>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
94136>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
94136>>>>>>>>>    //
94136>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
94136>>>>>>>>>    //
94136>>>>>>>>>    Procedure SetFormat string sFmt integer bCurrency
94138>>>>>>>>>        string sPos sNeg
94138>>>>>>>>>        integer iPos
94138>>>>>>>>>
94138>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
94139>>>>>>>>>        If iPos begin
94141>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
94142>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
94143>>>>>>>>>        end
94143>>>>>>>>>>
94143>>>>>>>>>        else Begin
94144>>>>>>>>>            Move sFmt         to sPos
94145>>>>>>>>>            Move ("-" + sFmt) to sNeg
94146>>>>>>>>>        end
94146>>>>>>>>>>
94146>>>>>>>>>        Send ParseFormat sPos
94147>>>>>>>>>        If bCurrency begin
94149>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(self))
94150>>>>>>>>>            set psCurPosLeft         to (psLeft(self))
94151>>>>>>>>>            set psCurPosRight        to (psRight(self))
94152>>>>>>>>>            Set piCurPosPoints       to (piPoints(self))
94153>>>>>>>>>        End
94153>>>>>>>>>>
94153>>>>>>>>>        else Begin
94154>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(self))
94155>>>>>>>>>            set psNumPosLeft         to (psLeft(self))
94156>>>>>>>>>            set psNumPosRight        to (psRight(self))
94157>>>>>>>>>            Set piNumPosPoints       to (piPoints(self))
94158>>>>>>>>>        end
94158>>>>>>>>>>
94158>>>>>>>>>
94158>>>>>>>>>        Send ParseFormat sNeg
94159>>>>>>>>>        If bCurrency begin
94161>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(self))
94162>>>>>>>>>            set psCurNegLeft         to (psLeft(self))
94163>>>>>>>>>            set psCurNegRight        to (psRight(self))
94164>>>>>>>>>            Set piCurNegPoints       to (piPoints(self))
94165>>>>>>>>>        End
94165>>>>>>>>>>
94165>>>>>>>>>        else Begin
94166>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(self))
94167>>>>>>>>>            set psNumNegLeft         to (psLeft(self))
94168>>>>>>>>>            set psNumNegRight        to (psRight(self))
94169>>>>>>>>>            Set piNumNegPoints       to (piPoints(self))
94170>>>>>>>>>        end
94170>>>>>>>>>>
94170>>>>>>>>>    End_procedure
94171>>>>>>>>>
94171>>>>>>>>>    // low level formatting. Pass parameters
94171>>>>>>>>>    Function Format_Num number nNumber integer iPoints integer bSep ;                       string sPrefix string sSuffix returns string
94173>>>>>>>>>        string  sLeft sRight sNumber sSep sDec
94173>>>>>>>>>        integer bIsNegative iDec iLen iCh
94173>>>>>>>>>
94173>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
94176>>>>>>>>>        Move (Character(iCh)) to sDec
94177>>>>>>>>>
94177>>>>>>>>>        Move (abs(nNumber)) to sNumber
94178>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
94179>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
94180>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
94181>>>>>>>>>        // format for decimal separator
94181>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+repeat("0",iPoints),iPoints)) to sRight
94184>>>>>>>>>
94184>>>>>>>>>        // format for thousand sep.
94184>>>>>>>>>        If bSep Begin
94186>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
94189>>>>>>>>>            Move (Character(iCh)) to sSep
94190>>>>>>>>>            Move (Length(sLeft)) to iLen
94191>>>>>>>>>            While (iLen>3)
94195>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
94196>>>>>>>>>                Move (iLen-3) to iLen
94197>>>>>>>>>            End
94198>>>>>>>>>>
94198>>>>>>>>>        End
94198>>>>>>>>>>
94198>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
94198>>>>>>>>>        If (iPoints>0 OR (iPoints=-2 AND sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
94201>>>>>>>>>        Function_return (sPrefix + sLeft+ sSuffix)
94202>>>>>>>>>    End_Function
94203>>>>>>>>>
94203>>>>>>>>>    // Public: Format for currency
94203>>>>>>>>>    //
94203>>>>>>>>>    Function FormatCur number nNumber integer iPoints returns string
94205>>>>>>>>>        string  sLeft sRight
94205>>>>>>>>>        integer bSep
94205>>>>>>>>>        If (nNumber<0) Begin
94207>>>>>>>>>            get pbCurNegThousandsSep to bSep
94208>>>>>>>>>            get psCurNegLeft         to sLeft
94209>>>>>>>>>            get psCurNegRight        to sRight
94210>>>>>>>>>            If (iPoints=-1) get piCurNegPoints       to iPoints
94213>>>>>>>>>        end
94213>>>>>>>>>>
94213>>>>>>>>>        Else Begin
94214>>>>>>>>>            get pbCurPosThousandsSep to bSep
94215>>>>>>>>>            get psCurPosLeft         to sLeft
94216>>>>>>>>>            get psCurPosRight        to sRight
94217>>>>>>>>>            If (iPoints=-1) get piCurPosPoints       to iPoints
94220>>>>>>>>>        end
94220>>>>>>>>>>
94220>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
94221>>>>>>>>>    End_function
94222>>>>>>>>>
94222>>>>>>>>>    // Public: Format for numeric
94222>>>>>>>>>    //
94222>>>>>>>>>    Function FormatNum number nNumber integer iPoints returns string
94224>>>>>>>>>        string  sLeft sRight
94224>>>>>>>>>        integer bSep
94224>>>>>>>>>        If (nNumber<0) Begin
94226>>>>>>>>>            get pbNumNegThousandsSep to bSep
94227>>>>>>>>>            get psNumNegLeft         to sLeft
94228>>>>>>>>>            get psNumNegRight        to sRight
94229>>>>>>>>>            If (iPoints=-1) get piNumNegPoints       to iPoints
94232>>>>>>>>>        end
94232>>>>>>>>>>
94232>>>>>>>>>        Else Begin
94233>>>>>>>>>            get pbNumPosThousandsSep to bSep
94234>>>>>>>>>            get psNumPosLeft         to sLeft
94235>>>>>>>>>            get psNumPosRight        to sRight
94236>>>>>>>>>            If (iPoints=-1) get piNumPosPoints       to iPoints
94239>>>>>>>>>        end
94239>>>>>>>>>>
94239>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
94240>>>>>>>>>    End_function
94241>>>>>>>>>
94241>>>>>>>>>
94241>>>>>>>>>    // Public: Format passing format string
94241>>>>>>>>>    //
94241>>>>>>>>>    Function FormatVal number nNumber string sFmt returns string
94243>>>>>>>>>        integer iPos bIsNeg
94243>>>>>>>>>        string  sLeft sRight
94243>>>>>>>>>        integer iPoints bSep
94243>>>>>>>>>        Move (nNumber<0) to bIsNeg
94244>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
94245>>>>>>>>>        Case Begin
94245>>>>>>>>>            Case (iPos and Not(bIsNeg))      Move (left(sFmt,iPos-1))    to sFmt
94248>>>>>>>>>            Case (iPos and bIsNeg)           Move (mid(sFmt,255,iPos+1)) to sFmt
94252>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) Move sFmt                   to sFmt
94256>>>>>>>>>            Case else                        Move ("-" + sFmt)           to sFmt
94258>>>>>>>>>        case end
94258>>>>>>>>>        Send ParseFormat sFmt
94259>>>>>>>>>        get pbThousandsSep to bSep
94260>>>>>>>>>        get psLeft         to sLeft
94261>>>>>>>>>        get psRight        to sRight
94262>>>>>>>>>        get piPoints       to iPoints
94263>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
94264>>>>>>>>>    end_function
94265>>>>>>>>>
94265>>>>>>>>>End_Class
94266>>>>>>>
94266>>>>>>>// for now, this object is private. All access is through the following
94266>>>>>>>// global functions
94266>>>>>>>
94266>>>>>>>//Object oFmt is a cFormatter
94266>>>>>>>//end_object
94266>>>>>>>
94266>>>>>>>Global_variable handle ghoFormatter
94266>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
94267>>>>>>>
94267>>>>>>>Function FormatNumber Global number nNum integer iPoints returns string
94269>>>>>>>    Function_return (FormatNum(ghoFormatter, nNum,iPoints))
94270>>>>>>>end_function
94271>>>>>>>
94271>>>>>>>Function FormatCurrency Global number nNum integer iPoints returns string
94273>>>>>>>    Function_return (FormatCur(ghoFormatter, nNum,iPoints))
94274>>>>>>>end_function
94275>>>>>>>
94275>>>>>>>Function FormatValue Global number nNum string sFmt returns string
94277>>>>>>>    Function_return (FormatVal(ghoFormatter, nNum,sFmt))
94278>>>>>>>end_function
94279>>>>>>>
94279>>>>>>>Procedure SetCurrencyFormat Global string sFmt
94281>>>>>>>    Send SetFormat of ghoFormatter sFmt True
94282>>>>>>>end_function
94283>>>>>>>
94283>>>>>>>Procedure SetNumberFormat Global string sFmt
94285>>>>>>>    Send SetFormat of ghoFormatter sFmt False
94286>>>>>>>end_function
94287>>>>>>>
94287>>>>>Use MapiDllCalls.Pkg
Including file: MapiDllCalls.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiDllCalls.Pkg)
94287>>>>>>>Use MapiConstants.Pkg
Including file: MapiConstants.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiConstants.Pkg)
94287>>>>>>>>>Type MapiSession
94287>>>>>>>>>   Field MapiSession.SessionID As Integer
94287>>>>>>>>>End_type // MapiSession
94287>>>>>>>>>
94287>>>>>>>>>Type MapiMessagePointer
94287>>>>>>>>>   Field MapiMessagePointer.lppMessage As Pointer
94287>>>>>>>>>End_Type // MapiMessagePointer
94287>>>>>>>>>
94287>>>>>>>>>Type MapiRecipPointer
94287>>>>>>>>>   Field MapiRecipPointer.lppRecip As Pointer
94287>>>>>>>>>End_Type // MapiRecipPointer
94287>>>>>>>>>
94287>>>>>>>>>Type MapiNewRecipsPointer
94287>>>>>>>>>   Field MapiNewRecipsPointer.lppNewRecips As Pointer
94287>>>>>>>>>End_Type // MapiNewRecipsPointer
94287>>>>>>>>>
94287>>>>>>>>>Type MapiNewRecipsCounter
94287>>>>>>>>>   Field MapiNewRecipsCounter.lpnNewRecips As Integer
94287>>>>>>>>>End_Type // MapiNewRecipsCounter
94287>>>>>>>>>
94287>>>>>>>>>Type MapiFileDesc
94287>>>>>>>>>   Field MapiFileDesc.ulReserved As Integer      // Reserved for future use (must be 0)
94287>>>>>>>>>   Field MapiFileDesc.flFlags As Integer         // Flags
94287>>>>>>>>>   Field MapiFileDesc.nPosition As Integer       // character in text to be replaced by attachment
94287>>>>>>>>>   Field MapiFileDesc.lpszPathName As Pointer    // Full path name of attachment file
94287>>>>>>>>>   Field MapiFileDesc.lpszFileName As Pointer    // Original file name (optional)
94287>>>>>>>>>   Field MapiFileDesc.lpFileType As Pointer     // Attachment file type (can be lpMapiFileTagExt)
94287>>>>>>>>>End_Type // MapiFileDesc
94287>>>>>>>>>
94287>>>>>>>>>Define MAPI_OLE        For |CI$00000001
94287>>>>>>>>>Define MAPI_OLE_STATIC For |CI$00000002
94287>>>>>>>>>
94287>>>>>>>>>Define MAPI_NOATTACHMENT_POSITION For |CI$FFFFFFFF
94287>>>>>>>>>
94287>>>>>>>>>Type MapiFileTagExt
94287>>>>>>>>>   Field MapiFileTagExt.ulReserved As Integer  // Reserved, must be zero.
94287>>>>>>>>>   Field MapiFileTagExt.cbTag As Integer       // Size (in bytes) of
94287>>>>>>>>>   Field MapiFileTagExt.lpTag As Pointer       // X.400 OID for this attachment type
94287>>>>>>>>>   Field MapiFileTagExt.cbEncoding As Integer  // Size (in bytes) of
94287>>>>>>>>>   Field MapiFileTagExt.lpEncoding As Pointer  // X.400 OID for this attachment's encoding
94287>>>>>>>>>End_Type // MapiFileTagExt
94287>>>>>>>>>
94287>>>>>>>>>Type MapiRecipDesc
94287>>>>>>>>>   Field MapiRecipDesc.ulReserved As Integer   // Reserved for future use
94287>>>>>>>>>   Field MapiRecipDesc.ulRecipClass As Integer // Recipient class
94287>>>>>>>>>                                               // MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG
94287>>>>>>>>>   Field MapiRecipDesc.lpszName As Pointer     // Recipient name
94287>>>>>>>>>   Field MapiRecipDesc.lpszAddress As Pointer  // Recipient address (optional)
94287>>>>>>>>>   Field MapiRecipDesc.ulEIDSize As Pointer    // Count in bytes of size of pEntryID
94287>>>>>>>>>   Field MapiRecipDesc.lpEntryID As Pointer    // System-specific recipient reference
94287>>>>>>>>>End_Type // MapiRecipDesc
94287>>>>>>>>>
94287>>>>>>>>>Define MAPI_ORIG   For 0 // Recipient is message originator
94287>>>>>>>>>Define MAPI_TO     For 1 // Recipient is a primary recipient
94287>>>>>>>>>Define MAPI_CC     For 2 // Recipient is a copy recipient
94287>>>>>>>>>Define MAPI_BCC    For 3 // Recipient is blind copy recipient
94287>>>>>>>>>
94287>>>>>>>>>Type MapiMessage
94287>>>>>>>>>   Field MapiMessage.ulReserved As Integer                   // Reserved for future use (M.B. 0)
94287>>>>>>>>>   Field MapiMessage.lpszSubject As Pointer                  // Message Subject
94287>>>>>>>>>   Field MapiMessage.lpszNoteText As Pointer                 // Message Text
94287>>>>>>>>>   Field MapiMessage.lpszMessageType As Pointer              // Message Class
94287>>>>>>>>>   Field MapiMessage.lpszDateReceived As Pointer             // in YYYY/MM/DD HH:MM format
94287>>>>>>>>>   Field MapiMessage.lpszConversationID As Pointer           // conversation thread ID
94287>>>>>>>>>   Field MapiMessage.flFlags As Integer                      // unread,return receipt
94287>>>>>>>>>   Field MapiMessage.lpOriginator As Pointer                 // Originator descriptor
94287>>>>>>>>>   Field MapiMessage.nRecipCount As Integer                  // Number of recipients
94287>>>>>>>>>   Field MapiMessage.lpRecips As Pointer                     // Recipient descriptors
94287>>>>>>>>>   Field MapiMessage.nFileCount As Integer                   // # of file attachments
94287>>>>>>>>>   Field MapiMessage.lpFiles As Pointer                      // Attachment descriptors
94287>>>>>>>>>End_Type // MapiMessage
94287>>>>>>>>>
94287>>>>>>>>>Define MAPI_UNREAD            For |CI$00000001
94287>>>>>>>>>Define MAPI_RECEIPT_REQUESTED For |CI$00000002
94287>>>>>>>>>Define MAPI_SENT              For |CI$00000004
94287>>>>>>>>>
94287>>>>>>>>>// MAPILogon() flags.
94287>>>>>>>>>Define MAPI_LOGON_UI         For |CI$00000001 // Display logon UI
94287>>>>>>>>>Define MAPI_PASSWORD_UI      For |CI$00020000 // prompt for password only
94287>>>>>>>>>Define MAPI_NEW_SESSION      For |CI$00000002 // Don't use shared session
94287>>>>>>>>>Define MAPI_FORCE_DOWNLOAD   For |CI$00001000 // Get new mail before return
94287>>>>>>>>>Define MAPI_ALLOW_OTHERS     For |CI$00000008 // Make this a shared session
94287>>>>>>>>>Define MAPI_EXPLICIT_PROFILE For |CI$00000010 // Don't use default profile
94287>>>>>>>>>Define MAPI_EXTENDED         For |CI$00000020 // Extended MAPI Logon
94287>>>>>>>>>Define MAPI_USE_DEFAULT      For |CI$00000040 // Use default profile in logon
94287>>>>>>>>>
94287>>>>>>>>>Define MAPI_SIMPLE_DEFAULT  For (MAPI_LOGON_UI + MAPI_FORCE_DOWNLOAD + MAPI_ALLOW_OTHERS)
94287>>>>>>>>>Define MAPI_SIMPLE_EXPLICIT For (MAPI_NEW_SESSION + MAPI_FORCE_DOWNLOAD + MAPI_EXPLICIT_PROFILE)
94287>>>>>>>>>
94287>>>>>>>>>// MAPILogoff() flags.
94287>>>>>>>>>Define MAPI_LOGOFF_SHARED For |CI$00000001 // Close all shared sessions
94287>>>>>>>>>Define MAPI_LOGOFF_UI     For |CI$00000002 // It's OK to present UI
94287>>>>>>>>>
94287>>>>>>>>>// MAPISendMail() flags.
94287>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
94287>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
94287>>>>>>>>>
94287>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Display a send note UI
94287>>>>>>>>>Define MAPI_USE_DEFAULT For |CI$00000040 // Use default profile in logon
94287>>>>>>>>>
94287>>>>>>>>>// MAPIFindNext() flags.
94287>>>>>>>>>Define MAPI_UNREAD_ONLY    For |CI$00000020 // Only unread messages
94287>>>>>>>>>Define MAPI_GUARANTEE_FIFO For |CI$00000100 // use date order
94287>>>>>>>>>Define MAPI_LONG_MSGID     For |CI$00004000 // allow 512 char returned ID
94287>>>>>>>>>
94287>>>>>>>>>// MAPIReadMail() flags.
94287>>>>>>>>>Define MAPI_PEEK            For |CI$00000080 // Do not mark as read.
94287>>>>>>>>>Define MAPI_SUPPRESS_ATTACH For |CI$00000800 // header + body, no files
94287>>>>>>>>>Define MAPI_ENVELOPE_ONLY   For |CI$00000040 // Only header information
94287>>>>>>>>>Define MAPI_BODY_AS_FILE    For |CI$00000200
94287>>>>>>>>>
94287>>>>>>>>>// MAPISaveMail() flags.
94287>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
94287>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
94287>>>>>>>>>Define MAPI_LONG_MSGID  For |CI$00004000 // allow 512 char returned ID
94287>>>>>>>>>
94287>>>>>>>>>// MAPIAddress() flags.
94287>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
94287>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
94287>>>>>>>>>
94287>>>>>>>>>// MAPIDetails() flags.
94287>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
94287>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
94287>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
94287>>>>>>>>>
94287>>>>>>>>>// MAPIResolveName() flags.
94287>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
94287>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
94287>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Prompt for choices if ambiguous
94287>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
94287>>>>>>>>>
94287>>>>>>>>>Define SUCCESS_SUCCESS                 For 0
94287>>>>>>>>>Define MAPI_USER_ABORT                 For 1
94287>>>>>>>>>Define MAPI_E_USER_ABORT               For MAPI_USER_ABORT
94287>>>>>>>>>Define MAPI_E_FAILURE                  For 2
94287>>>>>>>>>Define MAPI_E_LOGON_FAILURE            For 3
94287>>>>>>>>>Define MAPI_E_LOGIN_FAILURE            For MAPI_E_LOGON_FAILURE
94287>>>>>>>>>Define MAPI_E_DISK_FULL                For 4
94287>>>>>>>>>Define MAPI_E_INSUFFICIENT_MEMORY      For 5
94287>>>>>>>>>Define MAPI_E_ACCESS_DENIED            For 6
94287>>>>>>>>>Define MAPI_E_TOO_MANY_SESSIONS        For 8
94287>>>>>>>>>Define MAPI_E_TOO_MANY_FILES           For 9
94287>>>>>>>>>Define MAPI_E_TOO_MANY_RECIPIENTS      For 10
94287>>>>>>>>>Define MAPI_E_ATTACHMENT_NOT_FOUND     For 11
94287>>>>>>>>>Define MAPI_E_ATTACHMENT_OPEN_FAILURE  For 12
94287>>>>>>>>>Define MAPI_E_ATTACHMENT_WRITE_FAILURE For 13
94287>>>>>>>>>Define MAPI_E_UNKNOWN_RECIPIENT        For 14
94287>>>>>>>>>Define MAPI_E_BAD_RECIPTYPE            For 15
94287>>>>>>>>>Define MAPI_E_NO_MESSAGES              For 16
94287>>>>>>>>>Define MAPI_E_INVALID_MESSAGE          For 17
94287>>>>>>>>>Define MAPI_E_TEXT_TOO_LARGE           For 18
94287>>>>>>>>>Define MAPI_E_INVALID_SESSION          For 19
94287>>>>>>>>>Define MAPI_E_TYPE_NOT_SUPPORTED       For 20
94287>>>>>>>>>Define MAPI_E_AMBIGUOUS_RECIPIENT      For 21
94287>>>>>>>>>Define MAPI_E_AMBIG_RECIP              For MAPI_E_AMBIGUOUS_RECIPIENT
94287>>>>>>>>>Define MAPI_E_MESSAGE_IN_USE           For 22
94287>>>>>>>>>Define MAPI_E_NETWORK_FAILURE          For 23
94287>>>>>>>>>Define MAPI_E_INVALID_EDITFIELDS       For 24
94287>>>>>>>>>Define MAPI_E_INVALID_RECIPS           For 25
94287>>>>>>>>>Define MAPI_E_NOT_SUPPORTED            For 26
94287>>>>>>>Use WinKern.pkg
94287>>>>>>>
94287>>>>>>>External_Function MAPILogon "MAPILogon" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszProfileName ;   Pointer lpszPassword ;   Integer flFlags ;   Integer ulReserved ;   Pointer lplhSession ;   Returns Integer
94288>>>>>>>External_Function MAPILogoff "MAPILogoff" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
94289>>>>>>>External_Function MAPIFindNext "MAPIFindNext" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageType ;   Pointer lpszSeedMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
94290>>>>>>>External_Function MAPIFreeBuffer "MAPIFreeBuffer" Mapi32.Dll ;   Pointer pv ;   Returns Integer
94291>>>>>>>External_Function MAPIReadMail "MAPIReadMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppMessage ;   Returns Integer
94292>>>>>>>External_Function MAPIAddress "MAPIAddress" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszCaption ;   Integer nEditFields ;   Pointer lpszLabels ;   Integer nRecips ;   Pointer lpRecips ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpnNewRecips ;   Pointer lppNewRecips ;   Returns Integer
94293>>>>>>>External_Function MAPIResolveName "MAPIResolveName" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszName ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppRecip ;   Returns Integer
94294>>>>>>>External_Function MAPISendMail "MAPISendMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
94295>>>>>>>External_Function MAPISaveMail "MAPISaveMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
94296>>>>>>>External_Function MAPIDeleteMail "MAPIDeleteMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
94297>>>>>>>External_Function MAPISendDocuments "MAPISendDocuments" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszDelimChar ;   Pointer lpszFullPaths ;   Pointer lpszFileNames ;   Integer ulReserved ;   Returns Integer
94298>>>>>>>External_Function MAPIDetails "MAPIDetails" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpRecip ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
94299>>>>>>>
94299>>>>>>>External_Function ShellExecute "ShellExecuteA" Shell32.Dll ;   Handle hwnd ;   String sOperation ;   String sFile ;   String sParameters ;   String sDirectory ;   Integer nShowCmd ;   Returns VOID_TYPE
94300>>>>>Use DFBTRDRV.PKG
94300>>>>>Use MSSqldrv.pkg
94300>>>>>Use db2_drv.pkg
94300>>>>>Use odbc_drv.pkg
94300>>>>>Use seq_chnl.pkg
94300>>>>>Use Std_help.pkg
Including file: Std_help.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Std_help.pkg)
94300>>>>>>>// STD_HELP.PKG
94300>>>>>>>//
94300>>>>>>>// Global Help Object
94300>>>>>>>//
94300>>>>>>>//  Creates all Help Support required to access WINDOWs help system
94300>>>>>>>//  with DataFlex. Creates a global object named Help_Object.
94300>>>>>>>//
94300>>>>>>>//  9/19/97 JJT - Modified to define stadnard help Ids if they are undefined
94300>>>>>>>
94300>>>>>>>use DFHlpSys.pkg // Context Sensitive Help Support for Windows and HTML
Including file: Dfhlpsys.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfhlpsys.pkg)
94300>>>>>>>>>//************************************************************************
94300>>>>>>>>>//
94300>>>>>>>>>// Confidential Trade Secret.
94300>>>>>>>>>// Copyright (c) 1997-2002 Data Access Corporation, Miami Florida
94300>>>>>>>>>// as an unpublished work.  All rights reserved.
94300>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
94300>>>>>>>>>//
94300>>>>>>>>>//***********************************************************************/
94300>>>>>>>>>
94300>>>>>>>>>//************************************************************************
94300>>>>>>>>>// DFHlpSys.pkg
94300>>>>>>>>>//  12-07-1994 : Created
94300>>>>>>>>>//  8/29/2002  : major changes
94300>>>>>>>>>//
94300>>>>>>>>>// Author: John J. Tuohy
94300>>>>>>>>>//
94300>>>>>>>>>// This package loads support the windows help and html help. It used to define
94300>>>>>>>>>// a bunch of desktop help messages, but as of 8.3 those have been moved into
94300>>>>>>>>>// objects via a dfbase mixin. The only reason this package remains here is that
94300>>>>>>>>>// std_help.pkg calls it.
94300>>>>>>>>>//************************************************************************
94300>>>>>>>>>
94300>>>>>>>>>use DFHlpCl.pkg    // Define the Help_System Class for windows
Including file: Dfhlpcl.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfhlpcl.pkg)
94300>>>>>>>>>>>//************************************************************************
94300>>>>>>>>>>>//
94300>>>>>>>>>>>// Confidential Trade Secret.
94300>>>>>>>>>>>// Copyright 1997-2001 Data Access Corporation, Miami FL, USA
94300>>>>>>>>>>>// All Rights reserved
94300>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//************************************************************************
94300>>>>>>>>>>>//
94300>>>>>>>>>>>// $File name  : DFHlpCl.pkg
94300>>>>>>>>>>>// $File title : HelpSystem class support
94300>>>>>>>>>>>// Notice      :
94300>>>>>>>>>>>// $Author(s)  : John Tuohy
94300>>>>>>>>>>>//
94300>>>>>>>>>>>// $Rev History
94300>>>>>>>>>>>//
94300>>>>>>>>>>>// 07/19/01 SWB - added support for the Application object's psHelpFile
94300>>>>>>>>>>>//                to override any value in the global Workspace object
94300>>>>>>>>>>>// 11/17/97 JJT - added missing set help_filename method.
94300>>>>>>>>>>>// 10/15/97 JJT - changed define_symbol to define
94300>>>>>>>>>>>// 6/27/97  JJT - Modified low level help calls to work better in 95 help.
94300>>>>>>>>>>>// 07/23/96 JJT - New Class names
94300>>>>>>>>>>>// 01/27/96 JJT - Changed to from DAF to DF
94300>>>>>>>>>>>// 02/14/95 JJT - Added DFGSINI for 3.01/3.05 dual support of .ini name
94300>>>>>>>>>>>//                and section name.
94300>>>>>>>>>>>//************************************************************************
94300>>>>>>>>>>>// VDF8 changes
94300>>>>>>>>>>>// 10/23/2001 JJT - use ReadString instead of System_profile_string
94300>>>>>>>>>>>//************************************************************************
94300>>>>>>>>>>>
94300>>>>>>>>>>>// Help System Package
94300>>>>>>>>>>>//
94300>>>>>>>>>>>// Public Properties that should be set:
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//     Property String  Help_Filename   (Help_File_Default(self))
94300>>>>>>>>>>>//     Property Integer Help_Id_General 0
94300>>>>>>>>>>>//     Property Integer Help_Id_Index   0
94300>>>>>>>>>>>//     Property Integer Help_Id_Keys    0
94300>>>>>>>>>>>//     Property Integer Help_Id_Files   0
94300>>>>>>>>>>>//     Property Integer Help_Id_Errors  0
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//
94300>>>>>>>>>>>// Public messsages which are sent to this object:
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//    procedure View_Context_KeyWord_Help integer Obj
94300>>>>>>>>>>>//    procedure View_Context_ID_Help      integer Obj
94300>>>>>>>>>>>//    procedure View_Context_Help         integer Obj
94300>>>>>>>>>>>//    procedure View_Help_for_help        integer Obj
94300>>>>>>>>>>>//    procedure View_help_index           integer Obj
94300>>>>>>>>>>>//    procedure View_Keys_Help            integer Obj
94300>>>>>>>>>>>//    procedure View_File_Help            integer Obj
94300>>>>>>>>>>>//    procedure View_Error_Help           integer Obj
94300>>>>>>>>>>>//    procedure View_Help_on_Topic        integer Obj
94300>>>>>>>>>>>//
94300>>>>>>>>>>>// Protected Messages:
94300>>>>>>>>>>>//        These messages invoke the Window's help system and are not
94300>>>>>>>>>>>//        directly sent by outside objects. They are sent by public
94300>>>>>>>>>>>//        "view_xxx" messages and might be used if you are creating
94300>>>>>>>>>>>//        a sub-class of an object-class.
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//    Procedure Exec_System_Context_Help  integer Context_id
94300>>>>>>>>>>>//    Procedure Exec_System_Help          string  Keyword
94300>>>>>>>>>>>//    Procedure Exec_Context_Help         string  Context
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//    Functions for converting DF help IDs to windows Help Ids
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//        Any of these can return either a string or an integer.
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//    Function System_Help_Context_id Integer ID Returns String
94300>>>>>>>>>>>//           Convert a DF help context id into a windows id. By default,
94300>>>>>>>>>>>//           just return the same value (a one to one match). This is called
94300>>>>>>>>>>>//           by View_Context_id_help and View_Context_Help
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//    Function System_Help_File_Id Integer File# Integer Field# Returns String
94300>>>>>>>>>>>//           Convert file and field into a help id. By default it returns the
94300>>>>>>>>>>>//           file#. Called by View_File_Help.
94300>>>>>>>>>>>//
94300>>>>>>>>>>>//    Function System_Help_Error_id Integer Id Returns String
94300>>>>>>>>>>>//           Convert an error message into an ID. Right now it returns the
94300>>>>>>>>>>>//           the general error context id property, Help_id_errors. This
94300>>>>>>>>>>>//           will invoke general error help. If you want error support at the
94300>>>>>>>>>>>//           error# level you will have to determine the program to help
94300>>>>>>>>>>>//           interface yourself. Errors have a very large range and it is
94300>>>>>>>>>>>//           therefore hard to come up with an automatic numbering scheme.
94300>>>>>>>>>>>//           Called by View_Error_Help.
94300>>>>>>>>>>>
94300>>>>>>>>>>>
94300>>>>>>>>>>>Use Windows.pkg
94300>>>>>>>>>>>Use WinHlp.pkg // low level help call to windows API provides global message gDoWinHelp
94300>>>>>>>>>>>Use HelpSystemConstants.pkg // constants used by help system
94300>>>>>>>>>>>
94300>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
94300>>>>>>>>>>>Register_function peHelpType  returns integer
94300>>>>>>>>>>>
94300>>>>>>>>>>>class HelpSystem is an cObject
94301>>>>>>>>>>>
94301>>>>>>>>>>>    register_function Help_File_Default returns string
94301>>>>>>>>>>>
94301>>>>>>>>>>>    procedure Construct_Object
94303>>>>>>>>>>>       Forward send Construct_Object
94305>>>>>>>>>>>
94305>>>>>>>>>>>       // Help file name only. If set, this overrides all other settings.
94305>>>>>>>>>>>       Property String psHelpFile
94306>>>>>>>>>>>
94306>>>>>>>>>>>       // Help_FileName
94306>>>>>>>>>>>       //   full path name of Help file. The default value grabs its value
94306>>>>>>>>>>>       //   from .ini or environment settings. See functiob Help_file_Default
94306>>>>>>>>>>>       //
94306>>>>>>>>>>>       Property String  Private.Help_Filename (Help_File_Default(self))
94307>>>>>>>>>>>
94307>>>>>>>>>>>       // The following properties are the default values for the help files
94307>>>>>>>>>>>       // IDs for the various subjects. Setting these requires an agreement
94307>>>>>>>>>>>       // between the DF help system and the help file.
94307>>>>>>>>>>>       //
94307>>>>>>>>>>>       Property Integer Help_Id_General  0
94308>>>>>>>>>>>       Property Integer Help_Id_Index    0
94309>>>>>>>>>>>       Property Integer Help_Id_Keys     0
94310>>>>>>>>>>>       Property Integer Help_Id_Files    0
94311>>>>>>>>>>>       Property Integer Help_Id_Errors   0
94312>>>>>>>>>>>
94312>>>>>>>>>>>       // this is now the default help object
94312>>>>>>>>>>>       Move self to Help_Object_id
94313>>>>>>>>>>>    End_Procedure
94314>>>>>>>>>>>
94314>>>>>>>>>>>   // New rules for VDF8:
94314>>>>>>>>>>>   // 1. If psHelpFile exists, find the file in the file path and use it
94314>>>>>>>>>>>   // 2. If application object exists and help type is windows, use psHelpFile from there, find in file path and use it.
94314>>>>>>>>>>>   // 3. If no help file exists, use thge old private help name (which gets the full name from the registry -only if no app object)
94314>>>>>>>>>>>   //    Last method is deprecated and only used for old applications
94314>>>>>>>>>>>   //
94314>>>>>>>>>>>   Function Help_filename returns string
94316>>>>>>>>>>>        string sHelpName
94316>>>>>>>>>>>        // If ghoWorkSpace Get Help_FileName of ghoWorkSpace to sHelpName // removed for VDF8
94316>>>>>>>>>>>
94316>>>>>>>>>>>        // If an Application object is used, take the name from there.
94316>>>>>>>>>>>        Get psHelpFile to sHelpName
94317>>>>>>>>>>>        If (sHelpName="" AND ghoApplication AND peHelpType(ghoApplication)=htWinHelp) Begin
94319>>>>>>>>>>>            Get psHelpFile of ghoApplication To sHelpName
94320>>>>>>>>>>>            //Move (psHelpPath(phoWorkspace(ghoApplication)) -"\" -sHelpName) To sHelpName
94320>>>>>>>>>>>        End
94320>>>>>>>>>>>>
94320>>>>>>>>>>>        If (sHelpName<>"") begin
94322>>>>>>>>>>>            Get_File_Path sHelpName To sHelpName
94323>>>>>>>>>>>            Function_Return sHelpName
94324>>>>>>>>>>>        end
94324>>>>>>>>>>>>
94324>>>>>>>>>>>        // if not set anywhere (and ideally it is) we use this.
94324>>>>>>>>>>>        Get Private.Help_FileName to sHelpName
94325>>>>>>>>>>>        Function_Return sHelpName
94326>>>>>>>>>>>    End_Function
94327>>>>>>>>>>>
94327>>>>>>>>>>>    Procedure Set Help_FileName string sName
94329>>>>>>>>>>>        Set Private.Help_FileName to sName
94330>>>>>>>>>>>    End_Procedure
94331>>>>>>>>>>>
94331>>>>>>>>>>>
94331>>>>>>>>>>>
94331>>>>>>>>>>>    // Consider this message PRIVATE in that it should only be changed
94331>>>>>>>>>>>    // by a sub-class and not an object. It is called in construct_object
94331>>>>>>>>>>>    // before it knows about object augmentations!!!!
94331>>>>>>>>>>>    //
94331>>>>>>>>>>>    //  Sets the Help_file_name by looking at the .INI file for:
94331>>>>>>>>>>>    //        HELP_DIR    - help directory (will check environment variable
94331>>>>>>>>>>>    //                      windir if not found - avoid this usage). If not
94331>>>>>>>>>>>    //                      blank append "\" as required.
94331>>>>>>>>>>>    //
94331>>>>>>>>>>>    //        HELP_FILE   - help file name. If blank uses the default help
94331>>>>>>>>>>>    //                      file name
94331>>>>>>>>>>>    //
94331>>>>>>>>>>>    Function Help_File_Default Returns String
94333>>>>>>>>>>>       String HelpFileDir HelpFileName sSubKey
94333>>>>>>>>>>>       // if using the application object we expect the help name to be
94333>>>>>>>>>>>       // defined in the application object or directly in the help object. No Exceptions
94333>>>>>>>>>>>       If (ghoApplication) function_return ""
94336>>>>>>>>>>>
94336>>>>>>>>>>>       // else if no application (and hence no WS) use an old deprecated method of checking
94336>>>>>>>>>>>       // for the module name in local_machine.
94336>>>>>>>>>>>       Get Module_name of Desktop to sSubKey
94337>>>>>>>>>>>       Get_Profile_String sSubKey HELP_DIR to HelpFileDir
94340>>>>>>>>>>>       Get_Profile_String sSubKey HELP_FILE to HelpFileName
94343>>>>>>>>>>>       // if dir exists, sure it has a "\" at the end. If no directory the
94343>>>>>>>>>>>       // dir must be blank so current directory is searched
94343>>>>>>>>>>>       If ( (HelpFileDir<>'') AND (Right(HelpFileDir,1)<>"\") ) ;          Move (HelpFileDir - '\') to HelpFileDir
94346>>>>>>>>>>>       If HelpFileName eq '' Move DEFAULT_HELP_FILENAME to HelpFileName
94349>>>>>>>>>>>       Function_Return (HelpFileDir - HelpFileName)
94350>>>>>>>>>>>    End_Function
94351>>>>>>>>>>>
94351>>>>>>>>>>>    // The System_Help_xxxx messages convert a DF help integer ID into
94351>>>>>>>>>>>    // a context value that can be used by the windows help system. If
94351>>>>>>>>>>>    // you return a number or a string. Numbers will get used for context ID
94351>>>>>>>>>>>    // help, non-numbers get used for keyword context help
94351>>>>>>>>>>>
94351>>>>>>>>>>>    // By default return ID passed. This creates a direct mapping between
94351>>>>>>>>>>>    // context IDs in your object and the context IDs in windows help.
94351>>>>>>>>>>>    //
94351>>>>>>>>>>>    Function System_Help_Context_id Integer ID Returns String
94353>>>>>>>>>>>       Function_Return ID
94354>>>>>>>>>>>    End_Function // System_Help_Context_id
94355>>>>>>>>>>>
94355>>>>>>>>>>>    // Returns the file# which assumes that we have a direct mapping between
94355>>>>>>>>>>>    // the file number and a window's help context_id. We are ignoring field#
94355>>>>>>>>>>>    // in this case (although your augmentation would not have to). If the
94355>>>>>>>>>>>    // file# is 0, return a the HELP_ID context id.
94355>>>>>>>>>>>    //
94355>>>>>>>>>>>    Function System_Help_File_Id Integer File# Integer Field# Returns String
94357>>>>>>>>>>>       String rVal
94357>>>>>>>>>>>       if File# eq 0 Move (Help_id_files(self)) to rVal
94360>>>>>>>>>>>       Else Move File# to rVal
94362>>>>>>>>>>>       Function_Return Rval
94363>>>>>>>>>>>    End_Function // System_Help_File_id
94364>>>>>>>>>>>
94364>>>>>>>>>>>    // Convert an error id into a help context id. Return the general
94364>>>>>>>>>>>    // Help id property value. We do this because error number have
94364>>>>>>>>>>>    // a rather large range (1-9000) and just using the number would consume
94364>>>>>>>>>>>    // too much of the context id space.
94364>>>>>>>>>>>    //
94364>>>>>>>>>>>    Function System_Help_Error_id Integer Id Returns String
94366>>>>>>>>>>>       Function_Return (Help_Id_Errors(self))
94367>>>>>>>>>>>    End_Function // System_Help_Error_id
94368>>>>>>>>>>>
94368>>>>>>>>>>>    // Use this if you want your help context to be keyword based
94368>>>>>>>>>>>    //
94368>>>>>>>>>>>    procedure View_Context_KeyWord_Help integer Obj
94370>>>>>>>>>>>       String Context
94370>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of obj HELP_CONTEXT_KEYWORD to Context
94373>>>>>>>>>>>       Send Exec_System_Help Context
94374>>>>>>>>>>>    end_procedure
94375>>>>>>>>>>>
94375>>>>>>>>>>>    // Use this if you want your help context to be ID based
94375>>>>>>>>>>>    //
94375>>>>>>>>>>>    procedure View_Context_ID_Help integer Obj
94377>>>>>>>>>>>       Integer Context_ID
94377>>>>>>>>>>>       String Context
94377>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of Obj HELP_CONTEXT_ID to Context_ID
94380>>>>>>>>>>>       Get System_Help_Context_id Context_Id to Context
94381>>>>>>>>>>>       Send Exec_Context_Help Context
94382>>>>>>>>>>>    end_procedure
94383>>>>>>>>>>>
94383>>>>>>>>>>>    // Use this is you want the object requesting help to support either
94383>>>>>>>>>>>    // keyword or context ID help (it will use whatever it finds first).
94383>>>>>>>>>>>    //
94383>>>>>>>>>>>    procedure View_Context_Help integer Obj
94385>>>>>>>>>>>       String Context
94385>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of obj HELP_CONTEXT_ID_OR_KEY to Context
94388>>>>>>>>>>>       if (left(context,1)) in '0123456789' ;          Get System_Help_Context_id Context to Context
94391>>>>>>>>>>>       Send Exec_Context_Help Context
94392>>>>>>>>>>>    end_procedure
94393>>>>>>>>>>>
94393>>>>>>>>>>>    Procedure View_Help_for_Help Integer obj
94395>>>>>>>>>>>        Send Exec_System_Help HELP_FOR_HELP_STRING
94396>>>>>>>>>>>    end_procedure
94397>>>>>>>>>>>
94397>>>>>>>>>>>    Procedure View_Help_Index integer obj
94399>>>>>>>>>>>       Send Exec_Context_Help (Help_id_index(self))
94400>>>>>>>>>>>    End_Procedure // View_help_index
94401>>>>>>>>>>>
94401>>>>>>>>>>>    procedure View_Keys_Help Integer Obj
94403>>>>>>>>>>>        Send Exec_Context_Help (Help_id_keys(self))
94404>>>>>>>>>>>    end_procedure
94405>>>>>>>>>>>
94405>>>>>>>>>>>    Procedure View_File_Help Integer Obj
94407>>>>>>>>>>>       String Context FilFld
94407>>>>>>>>>>>       Integer File# Field# Dot
94407>>>>>>>>>>>       If Obj gt 0 Begin
94409>>>>>>>>>>>          // This should return the file and field as a string in
94409>>>>>>>>>>>          // FFF.fff format (F=File, f=format).
94409>>>>>>>>>>>          Get Help_Context of Obj HELP_CONTEXT_DATAFILE to FilFld
94410>>>>>>>>>>>          // Parse FilFld into File# and Field#.
94410>>>>>>>>>>>          Pos '.' in FilFld to Dot
94412>>>>>>>>>>>>
94412>>>>>>>>>>>          if Dot ne 0 begin
94414>>>>>>>>>>>             Left FilFld to File#  (dot-1)
94416>>>>>>>>>>>>
94416>>>>>>>>>>>             Mid  FilFld to Field# 255 (dot+1)
94419>>>>>>>>>>>>
94419>>>>>>>>>>>          End
94419>>>>>>>>>>>>
94419>>>>>>>>>>>       End
94419>>>>>>>>>>>>
94419>>>>>>>>>>>       Get System_Help_File_id File# Field# to Context
94420>>>>>>>>>>>       Send Exec_Context_Help Context
94421>>>>>>>>>>>    End_Procedure // View_File_Help
94422>>>>>>>>>>>
94422>>>>>>>>>>>    //  View help on an error. Current version uses context id help.
94422>>>>>>>>>>>    //  The error number should be in global integer last_err
94422>>>>>>>>>>>    //
94422>>>>>>>>>>>    procedure View_Error_Help Integer Obj
94424>>>>>>>>>>>        String Context
94424>>>>>>>>>>>        If Obj gt 0 ;           Get Help_Context of obj HELP_CONTEXT_ERROR to Context
94427>>>>>>>>>>>        if (left(context,1)) in '0123456789' ;           Get System_Help_Error_id Context to Context
94430>>>>>>>>>>>        Send Exec_Context_Help Context
94431>>>>>>>>>>>    end_procedure
94432>>>>>>>>>>>
94432>>>>>>>>>>>    // View list of help topics.
94432>>>>>>>>>>>    //
94432>>>>>>>>>>>    Procedure View_Help_on_Topic Integer obj
94434>>>>>>>>>>>        Send Exec_System_Help HELP_ON_TOPIC_STRING
94435>>>>>>>>>>>    end_procedure
94436>>>>>>>>>>>
94436>>>>>>>>>>>    // Request context help. If context is a number assume that it is
94436>>>>>>>>>>>    // context id help, else assume it is keyword help.
94436>>>>>>>>>>>    //
94436>>>>>>>>>>>    Procedure Exec_Context_Help string Context
94438>>>>>>>>>>>       if (left(context,1)) in '0123456789' ;    // if first character is a          Send Exec_System_Context_Help Context  // numeric we assume ID help
94441>>>>>>>>>>>       else ;                                    // otherwise we assume key-          Send Exec_System_Help Context          // word help.
94443>>>>>>>>>>>    End_Procedure // Exec_Context_Help
94444>>>>>>>>>>>
94444>>>>>>>>>>>    // NOTE: the following two messages are the only messages that directly make calls
94444>>>>>>>>>>>    //       to the windows API. This is important. These two messages could be changed
94444>>>>>>>>>>>    //       to call other help systems (e.g. HTML help) and the rest of the high level
94444>>>>>>>>>>>    //       program remains the same. These are the only two messages that are
94444>>>>>>>>>>>    //       expected to be windows help centric.
94444>>>>>>>>>>>
94444>>>>>>>>>>>    // Get Context Id help for passed ID. Use help file as defined
94444>>>>>>>>>>>    // in Help_filename. If id is 0 use general help id (which must be
94444>>>>>>>>>>>    // defined.
94444>>>>>>>>>>>    //
94444>>>>>>>>>>>    Procedure Exec_System_Context_Help integer Context_id
94446>>>>>>>>>>>        If Context_Id eq 0 ; // if zero, see if we have a contents page            Move (Help_Id_General(self)) to Context_id
94449>>>>>>>>>>>        If Context_Id eq 0 ; // if still zero, jump to the topics popup dialog            Send Exec_System_Help HELP_ON_TOPIC_STRING
94452>>>>>>>>>>>        Else ;            Send gDoWinHelp WH_INTCONTEXT (Help_Filename(self)) Context_Id
94454>>>>>>>>>>>    end_procedure
94455>>>>>>>>>>>
94455>>>>>>>>>>>    // Get keyword help for passed keyword. Use help file as defined
94455>>>>>>>>>>>    // in help_filename.
94455>>>>>>>>>>>    //
94455>>>>>>>>>>>    procedure Exec_System_Help string Keyword
94457>>>>>>>>>>>        If Keyword eq HELP_FOR_HELP_STRING ;            Send gDoWinHelp WH_HELPONHELP
94460>>>>>>>>>>>        else if (Keyword eq HELP_ON_TOPIC_STRING OR KeyWord="");            Send gDoWinHelp WH_FINDER (Help_Filename(self))
94464>>>>>>>>>>>        else ;            Send gDoWinHelp WH_STRINGCONTEXT (Help_Filename(self)) KeyWord
94466>>>>>>>>>>>    end_procedure
94467>>>>>>>>>>>
94467>>>>>>>>>>>end_class
94468>>>>>>>>>use cHtmlHelp.pkg //  Define the help class for Html
94468>>>>>>>
94468>>>>>>>
94468>>>>>>>// This file needs to be provided by the developer. It will contain
94468>>>>>>>// symbolic replacements for the ID integer values used to access the
94468>>>>>>>// the windows help file's topics.
94468>>>>>>>//
94468>>>>>>>use Help_ids.inc
Including file: Help_ids.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Help_ids.inc)
94468>>>>>>>>>// Help_ids.inc
94468>>>>>>>>>//
94468>>>>>>>>>// Context ids. This uses help file Developer5.chm.
94468>>>>>>>>>//
94468>>>>>>>>>// This is a sample version. YOU must supply
94468>>>>>>>>>// the ID values
94468>>>>>>>>>
94468>>>>>>>>>//  Generic Context Ids
94468>>>>>>>>>//
94468>>>>>>>>>Define SQLConnectionsProgram for 0
94468>>>>>>>>>
94468>>>>>>>>>// It is expected that file-names ids will be the same as their
94468>>>>>>>>>// filenumber.
94468>>>>>>>>>
94468>>>>>>>>>
94468>>>>>>>>>//  View and selection-list specific context ids
94468>>>>>>>>>//
94468>>>>>>>>>//..........add view, object, selection-list ids here....
94468>>>>>>>
94468>>>>>>>// If the following are not defined in help_ids.inc,
94468>>>>>>>//  create default 0 values for them
94468>>>>>>>Define GeneralHelpId    for    0
94468>>>>>>>Define KeysHelpId       for    0
94468>>>>>>>Define FileHelpId       for    0
94468>>>>>>>Define ErrorHelpId      for    0  // probably not used in VDF
94468>>>>>>>Define IndexHelpId      for    0  // probably not used in VDF
94468>>>>>>>
94468>>>>>>>object Help_Object is a HelpSystem // global windows HLP help object
94470>>>>>>>
94470>>>>>>>   Set Help_Id_General to GeneralHelpId    // these should all be defined
94471>>>>>>>   Set Help_Id_Index   to IndexHelpId      // in help_ids.inc.
94472>>>>>>>   Set Help_Id_Keys    to KeysHelpId       //
94473>>>>>>>   Set Help_Id_Files   to FileHelpId       //
94474>>>>>>>   Set Help_Id_Errors  to ErrorHelpId      //
94475>>>>>>>
94475>>>>>>>end_object
94476>>>>>>>
94476>>>>>>>Object oHtmlHelp is a cHtmlHelp // this also defines ghoHtmlHelp
94478>>>>>>>End_Object
94479>>>>>
94479>>>>>Register_Function phoWorkspace Returns Handle
94479>>>>>Register_Function Help_filename Returns String
94479>>>>>Register_Function GetHelpFile Returns String
94479>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
94479>>>>>
94479>>>>>// Use of Mertech drivers:
94479>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>// *** Constant Declarations: ***
94479>>>>>//
94479>>>>>
94479>>>>>// NOTE: These text constants should be added to the various "Language_xxx.inc" files:
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>
94479>>>>>// System icon menu constants. If the upper left hand
94479>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
94479>>>>>    Define SC_RESTORE  for |CI$F120
94479>>>>>    Define SC_MOVE     for |CI$F010
94479>>>>>    Define SC_SIZE     for |CI$F000
94479>>>>>    Define SC_MINIMIZE for |CI$F020
94479>>>>>    Define SC_MAXIMIZE for |CI$F030
94479>>>>>    Define SC_CLOSE    for |CI$F060
94479>>>>>    Define SC_KEYMENU  for |CI$F100
94479>>>>>    Define SC_NEXTWINDOW for |CI$F040
94479>>>>>    Define SC_PREVWINDOW for |CI$F050
94479>>>>>
94479>>>>>// *** Struct Declarations: ***
94479>>>>>Struct tWinMemoryStatusEx
94479>>>>>    UInteger dwLength
94479>>>>>    UInteger dwMemoryLoad
94479>>>>>    UBigInt ullTotalPhys
94479>>>>>    UBigInt ullAvailPhys
94479>>>>>    UBigInt ullTotalPageFile
94479>>>>>    UBigInt ullAvailPageFile
94479>>>>>    UBigInt ullTotalVirtual
94479>>>>>    UBigInt ullAvailVirtual
94479>>>>>    UBigInt ullAvailExtendedVirtual
94479>>>>>End_Struct
94479>>>>>
94479>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
94479>>>>>Type MEMORYSTATUS
94479>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
94479>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
94479>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
94479>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
94479>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
94479>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
94479>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
94479>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
94479>>>>>End_Type
94479>>>>>
94479>>>>>// *** External Function calls: ***
94479>>>>>//
94479>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
94480>>>>>
94480>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
94481>>>>>
94481>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
94482>>>>>
94482>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
94483>>>>>
94483>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
94484>>>>>
94484>>>>>// *** Global/Desktop Function Declarations: ***
94484>>>>>
94484>>>>>Function ComputerName for Desktop Returns String
94486>>>>>    String sName
94486>>>>>    Get_Environment "COMPUTERNAME" to sName
94487>>>>>>
94487>>>>>    Function_Return sName
94488>>>>>End_Function
94489>>>>>
94489>>>>>Function Network_User_Name for cDesktop Returns String
94491>>>>>    String sName
94491>>>>>    Get_Environment "USERNAME" to sName
94492>>>>>>
94492>>>>>    Function_Return sName
94493>>>>>End_Function
94494>>>>>
94494>>>>>// *** Class Declarations: ***
94494>>>>>//
94494>>>>>Class cBitmapContainerVDFLink is a BitmapContainer
94495>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
94497>>>>>        Send Mouse_Up iWindowNumber iPosition
94498>>>>>    End_Procedure
94499>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
94501>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
94503>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
94504>>>>>    End_Procedure
94505>>>>>End_Class
94506>>>>>
94506>>>>>Class cCopyEditorContentButton is a Button
94507>>>>>    Procedure Construct_Object
94509>>>>>        Forward Send Construct_Object
94511>>>>>        Property Handle phoEditorHandle
94512>>>>>        Set psToolTip to C_$DescCopy
94513>>>>>    End_Procedure
94514>>>>>
94514>>>>>    Procedure CopyToWindowsClipboard
94516>>>>>        String sValue
94516>>>>>        Handle hoEditor
94516>>>>>        Boolean bCanCopy
94516>>>>>        Address aEditorAddress
94516>>>>>
94516>>>>>        Get phoEditorHandle to hoEditor
94517>>>>>        Send Select_All of hoEditor
94518>>>>>        Get CanCopy of hoEditor to bCanCopy
94519>>>>>        If (bCanCopy = True) Begin
94521>>>>>            Get paValue of hoEditor to aEditorAddress
94522>>>>>            Move aEditorAddress to sValue
94523>>>>>            Send Copy   of hoEditor
94524>>>>>            // Remove the selection after text is copied to the clipboard.
94524>>>>>            Send Beginning_of_Data of hoEditor
94525>>>>>            Send Info_Box C_$CopyToClipboard_Text
94526>>>>>        End
94526>>>>>>
94526>>>>>    End_Procedure
94527>>>>>End_Class
94528>>>>>
94528>>>>>Class SysinfoDisplay is a cTextEdit
94529>>>>>    Procedure Construct_Object
94531>>>>>        Forward Send Construct_Object
94533>>>>>
94533>>>>>        Set Size to 104 247
94534>>>>>        Set Location to 4 6
94535>>>>>        Set Border_Style to Border_None
94536>>>>>        Set peAnchors to anAll
94537>>>>>        Set Read_Only_State to True
94538>>>>>        Set pbWrap to True
94539>>>>>    End_Procedure
94540>>>>>
94540>>>>>    // Augmented class message to adjust certain text strings that are wrong...
94540>>>>>
94540>>>>>    Procedure AppendTextLn String sText
94542>>>>>        String sWorkspaceWSFile
94542>>>>>
94542>>>>>        // Only works for English:
94542>>>>>        If (ghoApplication > 0) Begin
94544>>>>>            If (sText contains "Workspace Name") Begin
94546>>>>>                Move "Workspace Config Filename:" to sText
94547>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
94548>>>>>                Move (sText * sWorkspaceWSFile) to sText
94549>>>>>            End
94549>>>>>>
94549>>>>>        End
94549>>>>>>
94549>>>>>        Send AppendText sText
94550>>>>>        Send AppendText (character(10))
94551>>>>>    End_Procedure
94552>>>>>
94552>>>>>    //****************************************************************************
94552>>>>>    // $Module type: PROCEDURE
94552>>>>>    // $Module name: Show_Current_Directory
94552>>>>>    // $Author     : VOO
94552>>>>>    // Created     : 06-10-96 @ 15:24
94552>>>>>    //
94552>>>>>    // Description
94552>>>>>    //    This method will show the name Of the current directory in the system
94552>>>>>    //    information box
94552>>>>>    //
94552>>>>>    // $Rev History
94552>>>>>    //    06-10-96  Module header created
94552>>>>>    //****************************************************************************
94552>>>>>    Procedure Show_Current_Directory
94554>>>>>        String sDir
94554>>>>>
94554>>>>>        Get_Current_Directory To sDir
94555>>>>>
94555>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
94556>>>>>    End_Procedure
94557>>>>>
94557>>>>>    Procedure Show_Windows_Directory
94559>>>>>        String sWindir
94559>>>>>
94559>>>>>        Get_Windows_Directory To sWindir
94560>>>>>
94560>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
94561>>>>>    End_Procedure
94562>>>>>
94562>>>>>    Procedure Show_Current_User
94564>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
94565>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
94566>>>>>    End_Procedure
94567>>>>>
94567>>>>>    Procedure Show_Number_Format
94569>>>>>        Integer iFormat
94569>>>>>        String sFormatText
94569>>>>>
94569>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
94572>>>>>        Move (Character (iFormat)) To sFormatText
94573>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
94574>>>>>
94574>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
94577>>>>>        Move (Character (iFormat)) to sFormatText
94578>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
94579>>>>>    End_Procedure
94580>>>>>
94580>>>>>    Procedure Show_Filelist_Name
94582>>>>>        String sFilename
94582>>>>>
94582>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
94585>>>>>
94585>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
94586>>>>>    End_Procedure
94587>>>>>
94587>>>>>    Procedure Show_Lock_Delay
94589>>>>>        Integer iLockdelay
94589>>>>>
94589>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
94592>>>>>
94592>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
94593>>>>>    End_Procedure
94594>>>>>
94594>>>>>    Procedure Show_Lock_Timeout
94596>>>>>        Integer iLockTimeout
94596>>>>>
94596>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
94599>>>>>
94599>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
94600>>>>>    End_Procedure
94601>>>>>
94601>>>>>    Procedure Show_Screen_Size
94603>>>>>        Integer iYscreensize iXscreensize
94603>>>>>
94603>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
94604>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
94605>>>>>
94605>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
94606>>>>>    End_Procedure
94607>>>>>
94607>>>>>    Procedure Show_Page_Size
94609>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
94610>>>>>    End_procedure
94611>>>>>
94611>>>>>    Procedure Show_Date
94613>>>>>        Date dToday
94613>>>>>
94613>>>>>        Sysdate dToday
94614>>>>>
94614>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
94615>>>>>    End_procedure
94616>>>>>
94616>>>>>    Procedure Show_Date_Format
94618>>>>>        Integer iDateFormat
94618>>>>>        String sDateFormat
94618>>>>>
94618>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
94621>>>>>        Case Begin
94621>>>>>            Case (iDateFormat = DF_DATE_USA)
94623>>>>>                Move C_$USA To sDateFormat
94624>>>>>                Case Break
94625>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
94628>>>>>                Move C_$European To sDateFormat
94629>>>>>                Case Break
94630>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
94633>>>>>                Move C_$Military To sDateFormat
94634>>>>>                Case Break
94635>>>>>            Case Else
94635>>>>>                Move C_$UnknownDateType To sDateFormat
94636>>>>>                Case Break
94637>>>>>        Case End
94637>>>>>
94637>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
94638>>>>>    End_Procedure
94639>>>>>
94639>>>>>    // 2013-08-14 NGS
94639>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
94639>>>>>    Procedure Show_Systemresources
94641>>>>>        tWinMemoryStatusEx MemoryStatusInfo
94641>>>>>        tWinMemoryStatusEx MemoryStatusInfo
94641>>>>>        Integer iRetval
94641>>>>>        Number nValue
94641>>>>>        String sValue
94641>>>>>
94641>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
94642>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
94643>>>>>        If (iRetval = 0) Begin
94645>>>>>            Move (ShowLastError ()) to iRetval
94646>>>>>            Procedure_Return
94647>>>>>        End
94647>>>>>>
94647>>>>>
94647>>>>>        Send AppendTextLn ""
94648>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
94649>>>>>
94649>>>>>        // Show memory in Gigabytes:
94649>>>>>        Move (nValue/1024/1024/1024) to nValue
94650>>>>>        Move (Round(nValue)) to nValue
94651>>>>>        Get FormatNumber nValue 2 to sValue
94652>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
94653>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
94654>>>>>
94654>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
94654>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
94655>>>>>        Move (Round(nValue)) to nValue
94656>>>>>        Get FormatNumber nValue 0 to sValue
94657>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
94658>>>>>
94658>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
94658>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
94659>>>>>        Move (Round(nValue)) to nValue
94660>>>>>        Get FormatNumber nValue 0 to sValue
94661>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
94662>>>>>
94662>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
94662>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
94663>>>>>        Move (Round(nValue)) to nValue
94664>>>>>        Get FormatNumber nValue 0 to sValue
94665>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
94666>>>>>
94666>>>>>        // Add an empty row after the memory information:
94666>>>>>        Send AppendTextLn ""
94667>>>>>    End_Procedure
94668>>>>>
94668>>>>>    Procedure Show_Registration
94670>>>>>        String sRegName
94670>>>>>        Integer iSN iUsersMax iUserCount
94670>>>>>
94670>>>>>        Registration sRegName iSN
94671>>>>>>
94671>>>>>        Get_Licensed_Max_Users to iUsersMax
94672>>>>>        Get_Current_User_Count to iUserCount
94673>>>>>
94673>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
94674>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
94675>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
94676>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
94677>>>>>    End_Procedure
94678>>>>>
94678>>>>>    //****************************************************************************
94678>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
94678>>>>>    // To the workspace object passing the an object and message To send back
94678>>>>>    // To this object. It is expected that the workspace object will send this
94678>>>>>    // message for every line Of information it wants displayed (passing the
94678>>>>>    // information To be displayed
94678>>>>>    //****************************************************************************
94678>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
94678>>>>>
94678>>>>>    Procedure Show_ServicePack
94680>>>>>        String sKey sVersion sDataFlex
94680>>>>>        Handle hoRegistry
94680>>>>>        Boolean bExists bOpened
94680>>>>>
94680>>>>>        Move "DataFlex"        to sDataFlex
94681>>>>>
94681>>>>>        Get Create U_cRegistry to hoRegistry
94682>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
94683>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
94684>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
94685>>>>>
94685>>>>>        If (bExists) Begin
94687>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
94688>>>>>        End
94688>>>>>>
94688>>>>>        Else Begin
94689>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
94690>>>>>        End
94690>>>>>>
94690>>>>>        Get KeyExists of hoRegistry sKey to bExists
94691>>>>>        If (bExists) Begin
94693>>>>>            Get OpenKey of hoRegistry sKey to bOpened
94694>>>>>            If (bOpened) Begin
94696>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
94697>>>>>                If (bExists) Begin
94699>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
94700>>>>>                End
94700>>>>>>
94700>>>>>                Send CloseKey of hoRegistry
94701>>>>>            End
94701>>>>>>
94701>>>>>        End
94701>>>>>>
94701>>>>>        Send Destroy of hoRegistry
94702>>>>>
94702>>>>>        If (sVersion <> "") Begin
94704>>>>>           Send AppendTextLn sVersion
94705>>>>>           Send AppendTextLn ""
94706>>>>>        End
94706>>>>>>
94706>>>>>    End_Procedure
94707>>>>>
94707>>>>>    Procedure Show_WorkspaceInformation
94709>>>>>        Integer hoWorkspace
94709>>>>>
94709>>>>>        If (ghoApplication <> 0) Begin
94711>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
94712>>>>>            If (hoWorkspace <> 0) Begin
94714>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
94715>>>>>            End
94715>>>>>>
94715>>>>>        End
94715>>>>>>
94715>>>>>    End_Procedure
94716>>>>>
94716>>>>>    //****************************************************************************
94716>>>>>    // If connection ids are used, we will send the message EnumerateConnections
94716>>>>>    // to the connection manager object passing the an object and message to send
94716>>>>>    // back to this object. It is expected that the connection manager object will
94716>>>>>    // send this message for every line Of information it wants displayed (passing
94716>>>>>    // the information To be displayed
94716>>>>>    //****************************************************************************
94716>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
94716>>>>>
94716>>>>>    Procedure Show_ConnectionIdInformation
94718>>>>>        If (ghoConnection > 0) Begin
94720>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
94721>>>>>            Send AppendTextLn ""
94722>>>>>        End
94722>>>>>>
94722>>>>>    End_Procedure
94723>>>>>
94723>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
94725>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
94726>>>>>    End_Function
94727>>>>>
94727>>>>>    Procedure Show_Versions
94729>>>>>        Integer iVersion iRevision iBuild
94729>>>>>
94729>>>>>        Version_information iVersion iRevision iBuild
94731>>>>>
94731>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
94732>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
94733>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
94734>>>>>    End_Procedure
94735>>>>>
94735>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
94737>>>>>        Boolean bOK
94737>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
94738>>>>>        Function_Return bOK
94739>>>>>    End_Function
94740>>>>>
94740>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
94742>>>>>        Boolean bOK
94742>>>>>        Function_Return bOK
94743>>>>>    End_Function
94744>>>>>
94744>>>>>    //***
94744>>>>>    //*** BW
94744>>>>>    //*** Procedure: Show_Drivers
94744>>>>>    //*** Purpose  : Show loaded database drivers
94744>>>>>    //***
94744>>>>>
94744>>>>>    Procedure Show_Drivers
94746>>>>>        String sDriverID sVersion sClient sMertechSQLFlexVersion sValue
94746>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
94746>>>>>        Handle hoCLIHandler hoBtrvHandler
94746>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
94746>>>>>
94746>>>>>        Move False to bStudioLicense
94747>>>>>
94747>>>>>        Get Create U_cCLIHandler      to hoCLIHandler
94748>>>>>        Get Create U_cDFBtrDrvHandler to hoBtrvHandler
94749>>>>>
94749>>>>>        // For testing purposes:
94749>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
94749>>>>>//        Load_Driver MSSQLDRV_ID
94749>>>>>//        Load_Driver ODBC_DRV_ID
94749>>>>>//        Load_Driver DB2_DRV_ID
94749>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
94749>>>>>//
94749>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
94749>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
94749>>>>>//            Load_Driver SQLFLEX
94749>>>>>//            Load_Driver MDSPgSQL
94749>>>>>//            Load_Driver MDSMySQL
94749>>>>>//            Load_Driver ORAFLEX
94749>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
94749>>>>>//        #ENDIF
94749>>>>>        Move False to Err
94750>>>>>
94750>>>>>        // Loop through all loaded drivers.
94750>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
94753>>>>>        If (iNumberOfDrivers > 1) Begin
94755>>>>>            Send AppendTextLn ""
94756>>>>>        End
94756>>>>>>
94756>>>>>        For iDriver from 1 to iNumberOfDrivers
94762>>>>>>
94762>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
94762>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
94762>>>>>            // would be thrown, so we safeguard from that here.
94762>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
94763>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
94766>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
94767>>>>>            Get IsDAWSQLDriver sDriverID to bIsDAWDriver
94768>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
94769>>>>>
94769>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
94771>>>>>
94771>>>>>                // Pervasive/Btrieve database
94771>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
94773>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
94774>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
94775>>>>>                    If (sClient <> "0.0.0") Begin
94777>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
94778>>>>>                    End
94778>>>>>>
94778>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
94779>>>>>                    If (sClient <> "0.0.0") Begin
94781>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
94782>>>>>                    End
94782>>>>>>
94782>>>>>                End
94782>>>>>>
94782>>>>>
94782>>>>>                Else Begin
94783>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
94784>>>>>                    Move 0 to iNumServers
94785>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
94787>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
94790>>>>>                    End
94790>>>>>>
94790>>>>>
94790>>>>>                    If (bIsDAWDriver = True) Begin
94792>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
94794>>>>>                            // This info is only available for the MS SQL driver:
94794>>>>>                            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient
94797>>>>>                            If (iClient = 13) Move C_$SQLSERVER2016DRVRSTR              to sClient
94800>>>>>                            If (iClient = 12) Move C_$SQLSERVER2014DRVRSTR              to sClient
94803>>>>>                            If (iClient = 11) Move C_$SQL_Server_Native_Client_11_0     to sClient
94806>>>>>                            If (iClient = 10) Move C_$SQL_Server_Native_Client_10_0     to sClient
94809>>>>>                            If (iClient = 9)  Move C_$SQL_Native_Client                 to sClient
94812>>>>>                            If (iClient = 8)  Move C_$SQL_Server_SQL_Server_2000_client to sClient
94815>>>>>                            If (sClient <> "") Begin
94817>>>>>                                Move ("    " + sClient) to sClient
94818>>>>>                            End
94818>>>>>>
94818>>>>>                        End
94818>>>>>>
94818>>>>>
94818>>>>>                        Get CKRevision of hoCLIHandler to sVersion
94819>>>>>                    End
94819>>>>>>
94819>>>>>
94819>>>>>                    If (bIsMertechDriver = True) Begin
94821>>>>>                    End
94821>>>>>>
94821>>>>>
94821>>>>>                    // If the serialnumber is = 0, it means that the
94821>>>>>                    // Studio licens is in use and there is no
94821>>>>>                    // number of max users defined because the driver is
94821>>>>>                    // relying on the info from the VDF license.
94821>>>>>                    If (bStudioLicense = False) Begin
94823>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
94824>>>>>                        Move (iSerialNo = 0) to bStudioLicense
94825>>>>>                    End
94825>>>>>>
94825>>>>>                End
94825>>>>>>
94825>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
94826>>>>>                If (iNumServers <> 0) Begin
94828>>>>>                    For iCount from 1 to iNumServers
94834>>>>>>
94834>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
94837>>>>>                        Send AppendTextLn ("    " + "Server/DSN:" * sValue)
94838>>>>>                    Loop
94839>>>>>>
94839>>>>>                End
94839>>>>>>
94839>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
94841>>>>>                    Send AppendTextLn sClient
94842>>>>>                End
94842>>>>>>
94842>>>>>            End
94842>>>>>>
94842>>>>>        Loop
94843>>>>>>
94843>>>>>
94843>>>>>        Send AppendTextLn ""
94844>>>>>        If (bStudioLicense = False) Begin
94846>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
94847>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
94848>>>>>        End
94848>>>>>>
94848>>>>>        Else Begin
94849>>>>>            Send AppendTextLn C_$VDF_Studio_License_Text
94850>>>>>        End
94850>>>>>>
94850>>>>>        Send Destroy of hoCLIHandler
94851>>>>>        Send Destroy of hoBtrvHandler
94852>>>>>    End_Procedure
94853>>>>>
94853>>>>>    Procedure Show_HelpFile
94855>>>>>        String sHelpFile
94855>>>>>        Integer eHelpType
94855>>>>>
94855>>>>>        If (ghoApplication <> 0) Begin
94857>>>>>            Get peHelpType Of ghoApplication To eHelpType
94858>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
94860>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
94861>>>>>            End
94861>>>>>>
94861>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
94864>>>>>                Get Help_filename Of Help_object_id To sHelpFile
94865>>>>>            End
94865>>>>>>
94865>>>>>            Else Begin
94866>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
94867>>>>>            End
94867>>>>>>
94867>>>>>
94867>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
94868>>>>>        End
94868>>>>>>
94868>>>>>    End_Procedure
94869>>>>>
94869>>>>>    Procedure Show_EnterAsTab
94871>>>>>        Boolean bEnterKeyAsTabKey
94871>>>>>        String sText
94871>>>>>
94871>>>>>        If (ghoApplication <> 0) Begin
94873>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
94874>>>>>            If (bEnterKeyAsTabKey) Begin
94876>>>>>                Move "True" To sText
94877>>>>>            End
94877>>>>>>
94877>>>>>            Else Begin
94878>>>>>                Move "False" To sText
94879>>>>>            End
94879>>>>>>
94879>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
94880>>>>>        End
94880>>>>>>
94880>>>>>    End_Procedure
94881>>>>>
94881>>>>>    //****************************************************************************
94881>>>>>    // $Module type: PROCEDURE
94881>>>>>    // $Module name: Add_Focus
94881>>>>>    // $Author     : VOO
94881>>>>>    // Created     : 24-09-96 @ 19:43
94881>>>>>    //
94881>>>>>    // Description
94881>>>>>    //    During activation we will remove the old information and add the newly
94881>>>>>    //    found systeminformation
94881>>>>>    //
94881>>>>>    // $Rev History
94881>>>>>    //    24-09-96  Module header created
94881>>>>>    //****************************************************************************
94881>>>>>    Procedure Add_Focus Integer hoRoot
94883>>>>>        Forward Send Add_Focus hoRoot
94885>>>>>
94885>>>>>        Send Delete_Data
94886>>>>>
94886>>>>>        Set Changed_State To False
94887>>>>>        Set Read_Only_State To True
94888>>>>>
94888>>>>>        Send Show_Registration
94889>>>>>        Send Show_Drivers
94890>>>>>        Send AppendTextLn ""
94891>>>>>
94891>>>>>        Send Show_ServicePack
94892>>>>>        If (ghoApplication <> 0) Begin
94894>>>>>            Send Show_WorkSpaceInformation
94895>>>>>            Send Show_HelpFile
94896>>>>>            Send AppendTextLn ""
94897>>>>>        End
94897>>>>>>
94897>>>>>        Else Begin
94898>>>>>            Send AppendTextLn ""
94899>>>>>        End
94899>>>>>>
94899>>>>>
94899>>>>>        If (ghoConnection <> 0) Begin
94901>>>>>            Send Show_ConnectionIdInformation
94902>>>>>        End
94902>>>>>>
94902>>>>>
94902>>>>>        Send Show_Current_User
94903>>>>>        Send Show_Windows_Directory
94904>>>>>        Send Show_Current_Directory
94905>>>>>
94905>>>>>        // This is already shown in the workspace details,
94905>>>>>        // unless no workspace object is present:
94905>>>>>        If (ghoApplication = 0) Begin
94907>>>>>            Send Show_Filelist_Name
94908>>>>>        End
94908>>>>>>
94908>>>>>
94908>>>>>        If (ghoApplication <> 0) Begin
94910>>>>>            Send AppendTextLn ""
94911>>>>>            Send Show_EnterAsTab
94912>>>>>        End
94912>>>>>>
94912>>>>>
94912>>>>>        Send Show_Versions
94913>>>>>        Send Show_Screen_Size
94914>>>>>        Send Show_Page_Size
94915>>>>>        Send Show_Number_Format
94916>>>>>        Send Show_Date_Format
94917>>>>>        Send Show_Lock_Delay
94918>>>>>        Send Show_Lock_Timeout
94919>>>>>        Send Show_Date
94920>>>>>        Send Show_Systemresources
94921>>>>>        Send Beginning_of_Data
94922>>>>>
94922>>>>>        Set Icon to 'default.ico'
94923>>>>>    End_Procedure
94924>>>>>End_Class
94925>>>>>
94925>>>>>//****************************************************************************
94925>>>>>// $Module type: OBJECT
94925>>>>>// $Module name: Sysinfo_Dialog
94925>>>>>// $Author     : VOO
94925>>>>>// Created     : 24-09-96 @ 18:47
94925>>>>>//
94925>>>>>// Description
94925>>>>>//    This object shows the systeminformation on the screen
94925>>>>>//
94925>>>>>// $Rev History
94925>>>>>//    24-09-96  Module header created
94925>>>>>//****************************************************************************
94925>>>>>Class SysInfoDialog is a ModalPanel
94926>>>>>    Procedure Construct_Object
94928>>>>>        Forward Send Construct_Object
94930>>>>>
94930>>>>>        Set Label to C_$SystemInformation
94931>>>>>        Set Size to 140 267
94932>>>>>        Set Locate_Mode to CENTER_ON_PARENT
94933>>>>>        Set Border_Style to Border_Thick
94934>>>>>        Set Sysmenu_Icon to False
94935>>>>>
94935>>>>>        // "+1" will make the panel to paint correctly.
94935>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
94936>>>>>
94936>>>>>        // 2014-09-14 NGS
94936>>>>>        // Added a container object around the cTexteditor
94936>>>>>        // object to get a border around the text.
94936>>>>>        Object oSysinfoDisplayContainer is a Container3d
94938>>>>>            Set Location to 2 4
94939>>>>>            Set Size to 110 255
94940>>>>>            Set Border_Style to Border_ClientEdge
94941>>>>>            Set Color to clWhite
94942>>>>>            Set peAnchors to anAll
94943>>>>>
94943>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
94945>>>>>            End_Object
94946>>>>>
94946>>>>>        End_Object
94947>>>>>
94947>>>>>        Object oCloseButton is a Button
94949>>>>>            Set Label to C_$Close
94950>>>>>            Set Location to 120 210
94951>>>>>            Set Message item 0 to msg_Close_Panel
94952>>>>>            Set Default_State To True
94953>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
94953>>>>>            // and changes its peAnchors, we might as well prepare this object
94953>>>>>            // for that situation.
94953>>>>>            Set peAnchors to anBottomRight
94954>>>>>        End_Object
94955>>>>>
94955>>>>>        Object oCopyButton is a cCopyEditorContentButton
94957>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
94958>>>>>            Set Size to 14 50
94959>>>>>            Set Location to 120 158
94960>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
94960>>>>>            // we might as well prepare the object for it.
94960>>>>>            Set peAnchors to anBottomRight
94961>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
94962>>>>>        End_Object
94963>>>>>
94963>>>>>        On_Key kCancel Send Close_Panel
94964>>>>>    End_Procedure
94965>>>>>
94965>>>>>    Procedure Page Integer iPageObject
94967>>>>>        Handle hMenu
94967>>>>>        Integer iPrevState
94967>>>>>
94967>>>>>        Forward Send Page iPageObject
94969>>>>>
94969>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
94969>>>>>        //
94969>>>>>    End_Procedure
94970>>>>>
94970>>>>>End_Class
94971>>>>>
94971>>>>>Class cAboutEdit is an cRichEdit
94972>>>>>    Procedure Construct_Object
94974>>>>>        Forward Send Construct_Object
94976>>>>>
94976>>>>>        Set Size to 57 153
94977>>>>>        Set Location to 8 60
94978>>>>>
94978>>>>>        Set Read_Only_State to True
94979>>>>>        Set Skip_State to True
94980>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
94980>>>>>        // or 1/20 of a printer's point.
94980>>>>>//        Set piFontSize    to (9 * 20)
94980>>>>>        Set piRightMargin to (0.1 * 1440)
94981>>>>>        Set Border_Style  to Border_None
94982>>>>>    End_Procedure
94983>>>>>
94983>>>>>    // Adds a line of text to the edit object
94983>>>>>    Procedure Add_Line String sVal
94985>>>>>        String sText
94985>>>>>        Address aAddress
94985>>>>>        Get paValue to aAddress
94986>>>>>        Move aAddress to sText
94987>>>>>        Move (sText + String(sVal)) to sVal
94988>>>>>        GetAddress of sVal to aAddress
94989>>>>>        Set paValue to aAddress
94990>>>>>    End_Procedure
94991>>>>>
94991>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
94991>>>>>    // Note that we use the paValue interface,
94991>>>>>    // because the object isn't paged yet when we add the
94991>>>>>    // values and the COM edit object needs to be paged
94991>>>>>    // for the "Set Value" interface to be used.
94991>>>>>    Procedure Add_LineLn String sVal
94993>>>>>        String sText
94993>>>>>        Address aAddress
94993>>>>>        Get paValue to aAddress
94994>>>>>        Move aAddress to sText
94995>>>>>        Move (sText + String(sVal) + Character(10) + Character(13)) to sVal
94996>>>>>        GetAddress of sVal to aAddress
94997>>>>>        Set paValue to aAddress
94998>>>>>    End_Procedure
94999>>>>>
94999>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
95001>>>>>        String sLinkText
95001>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
95002>>>>>        Send Show_HomePage sLinkText
95003>>>>>    End_Procedure
95004>>>>>
95004>>>>>End_Class
95005>>>>>
95005>>>>>// Purpose:
95005>>>>>//
95005>>>>>// Ken Ross 12/17/96 5:16PM
95005>>>>>//
95005>>>>>Class AboutDialog is a ModalPanel
95006>>>>>    Procedure Construct_Object
95008>>>>>
95008>>>>>        Forward Send Construct_Object
95010>>>>>
95010>>>>>        Set Label to C_$About
95011>>>>>        Set Size to 96 230
95012>>>>>        Set Locate_Mode To CENTER_ON_PARENT
95013>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
95014>>>>>//        Set Sysmenu_Icon to True
95014>>>>>
95014>>>>>        Object oSysInfoDialog is a SysInfoDialog
95016>>>>>        End_Object
95017>>>>>
95017>>>>>        Object oBox is a Container3d
95019>>>>>            Set Border_Style to Border_Normal
95020>>>>>            Set Size to 70 220
95021>>>>>            Set Location to 4 5
95022>>>>>            Set Color to clWhite
95023>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
95023>>>>>            // we might as well prepare the object for it.
95023>>>>>            Set peAnchors to anAll
95024>>>>>
95024>>>>>            Object oAboutGraphic is a BitmapContainer
95026>>>>>                Set Border_Style To Border_None
95027>>>>>                Set Bitmap_Style to Bitmap_Center
95028>>>>>                Set Color to clWhite
95029>>>>>                Set Size to 45 50
95030>>>>>                Set Location to 0 3
95031>>>>>            End_Object
95032>>>>>
95032>>>>>            Object oPoweredByVDFGraphic is a cBitmapContainerVDFLink
95034>>>>>                Set Border_Style to Border_None
95035>>>>>                Set Bitmap_Style to Bitmap_Center
95036>>>>>                Set Color to clWhite
95037>>>>>                Set Size to 30 55 //28 50
95038>>>>>                Set Location to 44 3
95039>>>>>            End_Object
95040>>>>>
95040>>>>>            Object oInfoList_Editor is an cAboutEdit
95042>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
95042>>>>>                // we might as well prepare the object for it.
95042>>>>>                Set peAnchors to anAll
95043>>>>>            End_Object
95044>>>>>
95044>>>>>            // These objects are here for backwards compatability only.
95044>>>>>            // They are not used.
95044>>>>>            Object oProductName is a TextBox
95046>>>>>                Set Label To C_$ProductName
95047>>>>>                Set Size To 10 45
95048>>>>>                Set Location To 8 53
95049>>>>>                Set Visible_State to False
95050>>>>>                Set Focus_Mode to NonFocusable
95051>>>>>            End_Object
95052>>>>>
95052>>>>>            Object oVersion is a TextBox
95054>>>>>                Set Label To C_$Version
95055>>>>>                Set Size To 10 25
95056>>>>>                Set Location To 21 53
95057>>>>>                Set Visible_State to False
95058>>>>>                Set Focus_Mode to NonFocusable
95059>>>>>            End_Object
95060>>>>>
95060>>>>>            Object oCopyright is a TextBox
95062>>>>>                Set Label To C_$Copyright
95063>>>>>                Set Size To 10 31
95064>>>>>                Set Location To 34 53
95065>>>>>                Set Visible_State to False
95066>>>>>                Set Focus_Mode to NonFocusable
95067>>>>>            End_Object
95068>>>>>
95068>>>>>            Object oAuthor is a TextBox
95070>>>>>                Set Label To C_$Author
95071>>>>>                Set Size To 10 22
95072>>>>>                Set Location To 46 53
95073>>>>>                Set Visible_State to False
95074>>>>>                Set Focus_Mode to NonFocusable
95075>>>>>            End_Object
95076>>>>>
95076>>>>>        End_Object
95077>>>>>
95077>>>>>        Object oOKButton Is A Button
95079>>>>>            On_Item C_$Close Send Close_Panel
95080>>>>>            Set Location to 78 176
95081>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
95081>>>>>            // we might as well prepare the object for it.
95081>>>>>            Set peAnchors to anBottomRight
95082>>>>>        End_Object
95083>>>>>
95083>>>>>        Object oSysInfoButton Is A Button
95085>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
95086>>>>>            Set Location to 78 123
95087>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
95087>>>>>            // we might as well prepare the object for it.
95087>>>>>            Set peAnchors to anBottomRight
95088>>>>>        End_Object
95089>>>>>
95089>>>>>        Object oCopyButton is a cCopyEditorContentButton
95091>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
95092>>>>>            Set Size to 14 50
95093>>>>>            Set Location to 78 70
95094>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
95094>>>>>            // we might as well prepare the object for it.
95094>>>>>            Set peAnchors to anBottomRight
95095>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
95096>>>>>        End_Object
95097>>>>>
95097>>>>>        On_Key Kcancel Send KeyAction of oOKButton
95098>>>>>        Set Logo    to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
95099>>>>>//        Set LogoVDF to "PoweredByDataFlex.bmp"
95099>>>>>        Set LogoVDF to "PoweredByOrange.bmp"
95100>>>>>    End_Procedure
95101>>>>>
95101>>>>>    Procedure Page Integer iPageObject
95103>>>>>        Handle hMenu
95103>>>>>        Integer iPrevState
95103>>>>>
95103>>>>>        Forward Send Page iPageObject
95105>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
95105>>>>>//        Set Icon to "ActionAbout.ico"
95105>>>>>
95105>>>>>        // Shadow upper left corner menu items: (icon menu items)
95105>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
95106>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
95107>>>>>        // The "Move" menu command may come in handy to have.
95107>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
95107>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
95108>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
95109>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
95110>>>>>        // The "Close" menu command may be good to have.
95110>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
95110>>>>>    End_Procedure
95111>>>>>
95111>>>>>    Procedure Set ProductName String sText
95113>>>>>        Set Value of oProductName to sText
95114>>>>>    End_Procedure
95115>>>>>
95115>>>>>    Procedure Set Copyright String sText
95117>>>>>        Set Value of oCopyright to sText
95118>>>>>    End_Procedure
95119>>>>>
95119>>>>>    Procedure Set Author String sText
95121>>>>>        Set Value of oAuthor to sText
95122>>>>>    End_Procedure
95123>>>>>
95123>>>>>    Procedure Set Version String sVersion
95125>>>>>        Handle hoVersionInfo
95125>>>>>        Boolean bIncluded
95125>>>>>        Integer iMajor iMinor iRelease iBuild
95125>>>>>        Date dCompileDate
95125>>>>>
95125>>>>>        If (sVersion = "") Begin
95127>>>>>            // This automatically shows the program version of the program, if available.
95127>>>>>            // It will be displayed as the second item in the edit object.
95127>>>>>            If (ghoApplication <> 0) Begin
95129>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
95130>>>>>                If (hoVersionInfo <> 0) Begin
95132>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
95133>>>>>                    If (bIncluded) Begin
95135>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
95136>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
95137>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
95138>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
95139>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
95140>>>>>                    End
95140>>>>>>
95140>>>>>                End
95140>>>>>>
95140>>>>>            End
95140>>>>>>
95140>>>>>        End
95140>>>>>>
95140>>>>>
95140>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
95140>>>>>        Get GetCompileDate to dCompileDate
95141>>>>>        If (sVersion <> "") Begin
95143>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
95144>>>>>        End
95144>>>>>>
95144>>>>>    End_Procedure
95145>>>>>
95145>>>>>    Function GetCompileDate Returns Date
95147>>>>>        Date dCompileDate
95147>>>>>        String sAppFilename sData sCompileDate
95147>>>>>        Integer iChannel iPos iDateFormat
95147>>>>>
95147>>>>>        // Get full path to the current running executable
95147>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
95148>>>>>
95148>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
95148>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
95149>>>>>        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
95151>>>>>        Read_Block channel iChannel sData 75            // The compile information we're interested in
95153>>>>>        Send Seq_Close_Channel iChannel
95154>>>>>
95154>>>>>        // The data is padded with Character(0)s. Strip them out
95154>>>>>        Move (CString(sData)) to sData
95155>>>>>
95155>>>>>        // The compile date is after the first ", ", so string parsing is required
95155>>>>>        Move (Pos(", ", sData)) to iPos
95156>>>>>        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
95157>>>>>        // If the current date format is non US, we need to temporary
95157>>>>>        // change the format and then move the string to the date variable.
95157>>>>>        Get_Attribute DF_DATE_FORMAT        to iDateFormat
95160>>>>>        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
95163>>>>>        Move (Date(sCompileDate))           to dCompileDate
95164>>>>>        Set_Attribute DF_DATE_FORMAT        to iDateFormat // Reset date format
95167>>>>>
95167>>>>>        Function_Return dCompileDate
95168>>>>>    End_Function
95169>>>>>
95169>>>>>    Procedure Add_LineLn String sValue
95171>>>>>        Send Add_LineLn of oInfoList_Editor sValue
95172>>>>>    End_Procedure
95173>>>>>
95173>>>>>    Procedure Add_Line String sValue
95175>>>>>        Send Add_Line of oInfoList_Editor sValue
95176>>>>>    End_Procedure
95177>>>>>
95177>>>>>    Procedure Set Logo string sLogo
95179>>>>>        // Square bitmaps of 80x80 work best
95179>>>>>        Set Bitmap of oAboutGraphic to sLogo
95180>>>>>    End_Procedure
95181>>>>>
95181>>>>>    Procedure Set LogoVDF String sLogo
95183>>>>>        Set Bitmap of oPoweredByVDFGraphic to sLogo
95184>>>>>    End_Procedure
95185>>>>>
95185>>>>>    Procedure Show_Sysinfo
95187>>>>>        Send Popup_Modal of oSysinfoDialog
95188>>>>>    End_Procedure
95189>>>>>
95189>>>>>    Procedure Show_HomePage String sWebpage
95191>>>>>        Handle hWnd hInstance
95191>>>>>        Get Window_Handle to hWnd
95192>>>>>        Move (ShellExecute(hWnd, "open", (Trim(sWebpage)), "", "", 1)) to hInstance
95193>>>>>    End_Procedure
95194>>>>>
95194>>>>>//    Procedure End_Construct_Object
95194>>>>>//        Handle hoVersionInfo
95194>>>>>//        Boolean bIncluded
95194>>>>>//        Integer iMajor iMinor iRelease iBuild
95194>>>>>//        String sLabel sVersion
95194>>>>>//
95194>>>>>//        If (sVersion = "") Begin
95194>>>>>//            // This automatically shows the program version of the program, if available.
95194>>>>>//            // It will be displayed as the last item in the edit object.
95194>>>>>//            If (ghoApplication <> 0) Begin
95194>>>>>//                Get phoVersionInfo of ghoApplication to hoVersionInfo
95194>>>>>//                If (hoVersionInfo <> 0) Begin
95194>>>>>//                    Get pbIncluded of hoVersionInfo to bIncluded
95194>>>>>//                    If (bIncluded) Begin
95194>>>>>//                        Get piVersionMajor of hoVersionInfo to iMajor
95194>>>>>//                        Get piVersionMinor of hoVersionInfo to iMinor
95194>>>>>//                        Get piVersionRelease of hoVersionInfo to iRelease
95194>>>>>//                        Get piVersionBuild of hoVersionInfo to iBuild
95194>>>>>//                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
95194>>>>>//                        Set Version to sLabel
95194>>>>>//                    End
95194>>>>>//                End
95194>>>>>//            End
95194>>>>>//        End
95194>>>>>//
95194>>>>>//        Forward Send End_Construct_Object
95194>>>>>//    End_Procedure
95194>>>>>
95194>>>>>End_Class
95195>>>
95195>>>// *************************************************************************
95195>>>//  Public message. This is the default message. It is expected that you will
95195>>>//   create your own message to override this
95195>>>// *************************************************************************
95195>>>
95195>>>Procedure Activate_About
95198>>>   Send DoAbout "" "" "" "" ""
95199>>>End_Procedure
95200>>>
95200>>>// *************************************************************************
95200>>>//  Public message. It is expected that you will send this message (most
95200>>>//  likely from Activate_About. This creates an about object, activates it
95200>>>//  and destroys it when done. It is not exepected that you will augment this.
95200>>>// *************************************************************************
95200>>>// Sample usage:
95200>>>//   The first two params will automatically be filled from the application settings if not provided.
95200>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
95200>>>
95200>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;                  String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
95203>>>        Integer hoObj hoMain iArgs
95203>>>        String sValue
95203>>>
95203>>>        // Create object
95203>>>        Object About is an AboutDialog
95205>>>            // Uncomment these two lines if you would like to have a resizable About object.
95205>>>//            Set Border_Style to Border_Thick
95205>>>//            Set peAnchors to anAll
95205>>>
95205>>>            // Add checking for the number of arguments passed to avoid runtime errors
95205>>>            // if one of them is not passed. This makes the interface
95205>>>            // more flexible.
95205>>>            Move num_arguments to iArgs
95206>>>
95206>>>            // If no title is passed use the label of the main panel (if a main panel exists).
95206>>>            If (iArgs > 0 and sTitle = "") Begin
95208>>>                Get Main_Window of Desktop to hoMain
95209>>>                If hoMain Get Label of hoMain to sValue
95212>>>            End
95212>>>>
95212>>>            Else If (iArgs > 0 and sTitle <> "") Begin
95215>>>                Move sTitle to sValue
95216>>>            End
95216>>>>
95216>>>            Else If (iArgs = 0) Begin
95219>>>                Get Main_Window of Desktop to hoMain
95220>>>                If hoMain Get Label of hoMain to sValue
95223>>>            End
95223>>>>
95223>>>
95223>>>            If (sValue <> "") Send Add_LineLn sValue
95226>>>            Move "" to sValue
95227>>>
95227>>>            // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
95227>>>            // For this to work the Project Properties Version must have been set in the Studio.
95227>>>            If (iArgs < 2) Begin
95229>>>                Move "" to sValue
95230>>>            End
95230>>>>
95230>>>            Else Begin
95231>>>                Move sVersion to sValue
95232>>>            End
95232>>>>
95232>>>            Set Version to sValue
95233>>>
95233>>>            If (iArgs > 2 and sCopyRight <> "") Send Add_LineLn sCopyRight
95236>>>
95236>>>            // If only the five "standard" params were passed we don't add an extra linefeed;
95236>>>            // else we do.
95236>>>            If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
95238>>>                Send Add_Line sAuthor
95239>>>            End
95239>>>>
95239>>>            Else If (iArgs > 5 and sAuthor <> "") Begin
95242>>>                Send Add_LineLn sAuthor
95243>>>            End
95243>>>>
95243>>>
95243>>>            // Square bitmaps of 80x80 works best
95243>>>            If (iArgs > 4 and sBitmap <> "") Begin
95245>>>               Set Logo to sBitMap
95246>>>            End
95246>>>>
95246>>>
95246>>>            // Here starts handling of the five optional params:
95246>>>            If (iArgs = 6 and sParam6  <> "") Begin
95248>>>                Send Add_Line sParam6
95249>>>            End
95249>>>>
95249>>>            Else If (iArgs > 6 and sParam6  <> "") Begin
95252>>>                Send Add_LineLn sParam6
95253>>>            End
95253>>>>
95253>>>
95253>>>            If (iArgs = 7 and sParam7  <> "") Begin
95255>>>                Send Add_Line sParam7
95256>>>            End
95256>>>>
95256>>>            Else If (iArgs > 7 and sParam7  <> "") Begin
95259>>>                Send Add_LineLn sParam7
95260>>>            End
95260>>>>
95260>>>
95260>>>            If (iArgs = 8 and sParam8  <> "") Begin
95262>>>                Send Add_Line sParam8
95263>>>            End
95263>>>>
95263>>>            Else If (iArgs > 8 and sParam8  <> "") Begin
95266>>>                Send Add_LineLn sParam8
95267>>>            End
95267>>>>
95267>>>
95267>>>            If (iArgs = 9 and sParam9  <> "") Begin
95269>>>                Send Add_Line sParam9
95270>>>            End
95270>>>>
95270>>>            Else If (iArgs > 9 and sParam9  <> "") Begin
95273>>>                Send Add_LineLn sParam9
95274>>>            End
95274>>>>
95274>>>
95274>>>            If (iArgs = 10 and sParam10 <> "") Begin
95276>>>                Send Add_Line sParam10
95277>>>            End
95277>>>>
95277>>>
95277>>>            Move Self to hoObj
95278>>>        End_Object
95279>>>
95279>>>        Send Popup   of hoObj // Popup the about object
95280>>>        Send Destroy of hoObj // When done, it will be destroyed
95281>>>End_Procedure
95282>    Procedure Activate_About
95285>        Send DoAbout "" "" ("Copyright 2016-2017" * psCompany(ghoApplication)) "Author: Nils G. Svedmyr" "DbUpdate.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com"
95286>    End_Procedure
95287>
95287>    Object oAbout_btn is a Button
95289>        Set Location to 179 27
95290>        Set Label to "About"
95291>        Set peAnchors to anNone
95292>
95292>        Procedure OnClick
95295>            Send Activate_About
95296>        End_Procedure
95297>
95297>    End_Object
95298>
95298>    Procedure ShowProgramHelp
95301>        Send DoDisplayKeyword of ghoHtmlHelp "CreateDbVersionTable Tool"
95302>    End_Procedure
95303>
95303>    On_Key Key_F1 Send ShowProgramHelp
95304>End_Object
95305>
95305>Send Activate of oCreateDbVersionTable_pnl
95306>Start_UI
95307>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 52258
Total Resources: 3
Total Commands : 95306
Total Windows  : 1
Total Pages    : 1
Static Data    : 683487
Message area   : 612035
Total Blocks   : 34069
