Compiling Program: C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFTestProgram.src
Memory Available: 2147483646
1>//  TestProject for Windows application
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dfallent.pkd)
79228>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardCommandBarSystem.pkg)
79228>>>// these are all the packages used in a standard MDI menubar/toolbar system
79228>>>
79228>>>Use cCJCommandBarSystem.pkg
79228>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJStandardMenuItemClasses.pkg)
79228>>>>>Use Dfpanel.pkg
79228>>>>>Use cCJCommandBarSystem.pkg
79228>>>>>Use LanguageText.pkg
79228>>>>>
79228>>>>>
79228>>>>>Class cCJUndoMenuItem is a cCJMenuItem
79229>>>>>    
79229>>>>>    Procedure Construct_Object
79231>>>>>        Forward Send Construct_Object
79233>>>>>        Set psCaption   to C_$CaptionUndo
79234>>>>>        Set psToolTip to C_$ToolTipUndo
79235>>>>>        Set psDescription to C_$DescUndo
79236>>>>>        Set psImage to "ActionUndo.ico"
79237>>>>>        Set pbActiveUpdate to True
79238>>>>>        Set psCategory to C_$CategoryEdit
79239>>>>>        Set psShortcut to C_$Key_Ctrl_Z
79240>>>>>    End_Procedure
79241>>>>>
79241>>>>>    Procedure OnExecute Variant vCommandBarControl
79243>>>>>        Send Undo of (focus(Self))
79244>>>>>    End_Procedure
79245>>>>>    
79245>>>>>    Function IsEnabled Returns Boolean
79247>>>>>        Boolean bEnabled
79247>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
79248>>>>>        Function_Return bEnabled
79249>>>>>    End_Function
79250>>>>>         
79250>>>>>End_Class
79251>>>>>
79251>>>>>
79251>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
79252>>>>>    
79252>>>>>    Procedure Construct_Object
79254>>>>>        Forward Send Construct_Object
79256>>>>>        Set psCaption   to C_$CaptionDelete
79257>>>>>        Set psToolTip to C_$ToolTipDelete
79258>>>>>        Set psDescription to C_$DescDelete
79259>>>>>        Set psImage to "actionDelete.ico"
79260>>>>>        Set psShortcut to C_$Key_Delete
79261>>>>>        Set pbActiveUpdate to True
79262>>>>>        Set psCategory to C_$CategoryEdit
79263>>>>>    End_Procedure
79264>>>>>
79264>>>>>
79264>>>>>    Procedure OnExecute Variant vCommandBarControl
79266>>>>>        Send Delete of (focus(Self))
79267>>>>>    End_Procedure
79268>>>>>    
79268>>>>>    Function IsEnabled Returns Boolean
79270>>>>>        Boolean bEnabled
79270>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
79271>>>>>        Function_Return bEnabled
79272>>>>>    End_Function
79273>>>>>         
79273>>>>>End_Class
79274>>>>>
79274>>>>>
79274>>>>>Class cCJCutMenuItem is a cCJMenuItem
79275>>>>>    
79275>>>>>    Procedure Construct_Object
79277>>>>>        Forward Send Construct_Object
79279>>>>>        Set psCaption   to C_$CaptionCut
79280>>>>>        Set psToolTip to C_$TooltipCut
79281>>>>>        Set psDescription to C_$DescCut
79282>>>>>        Set psImage to "actionCut.ico"
79283>>>>>        Set psShortcut to C_$Key_Ctrl_X
79284>>>>>        Set pbActiveUpdate to True
79285>>>>>        Set psCategory to C_$CategoryEdit
79286>>>>>    End_Procedure
79287>>>>>
79287>>>>>
79287>>>>>    Procedure OnExecute Variant vCommandBarControl
79289>>>>>        Send Cut of (focus(Self))
79290>>>>>    End_Procedure
79291>>>>>    
79291>>>>>    Function IsEnabled Returns Boolean
79293>>>>>        Boolean bEnabled
79293>>>>>        Get CanCut of (Focus(Self)) to bEnabled
79294>>>>>        Function_Return bEnabled
79295>>>>>    End_Function
79296>>>>>         
79296>>>>>End_Class
79297>>>>>
79297>>>>>
79297>>>>>Class cCJCopyMenuItem is a cCJMenuItem
79298>>>>>    
79298>>>>>    Procedure Construct_Object
79300>>>>>        Forward Send Construct_Object
79302>>>>>        Set psCaption   to C_$CaptionCopy
79303>>>>>        Set psToolTip to C_$ToolTipCopy
79304>>>>>        Set psDescription to C_$DescCopy
79305>>>>>        Set psImage to "actionCopy.ico"
79306>>>>>        Set psShortcut to C_$Key_Ctrl_C
79307>>>>>        Set pbActiveUpdate to True
79308>>>>>        Set psCategory to C_$CategoryEdit
79309>>>>>    End_Procedure
79310>>>>>
79310>>>>>
79310>>>>>    Procedure OnExecute Variant vCommandBarControl
79312>>>>>        Send Copy of (focus(Self))
79313>>>>>    End_Procedure
79314>>>>>    
79314>>>>>    Function IsEnabled Returns Boolean
79316>>>>>        Boolean bEnabled
79316>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
79317>>>>>        Function_Return bEnabled
79318>>>>>    End_Function
79319>>>>>         
79319>>>>>End_Class
79320>>>>>
79320>>>>>
79320>>>>>Class cCJPasteMenuItem is a cCJMenuItem
79321>>>>>    
79321>>>>>    Procedure Construct_Object
79323>>>>>        Forward Send Construct_Object
79325>>>>>        Set psCaption   to C_$CaptionPaste
79326>>>>>        Set psToolTip to C_$ToolTipPaste
79327>>>>>        Set psDescription to C_$DescPaste
79328>>>>>        Set psImage to "actionPaste.ico"
79329>>>>>        Set pbActiveUpdate to True
79330>>>>>        Set psShortcut to C_$Key_Ctrl_V
79331>>>>>        Set psCategory to C_$CategoryEdit
79332>>>>>    End_Procedure
79333>>>>>
79333>>>>>
79333>>>>>    Procedure OnExecute Variant vCommandBarControl
79335>>>>>        Send Paste of (focus(Self))
79336>>>>>    End_Procedure
79337>>>>>    
79337>>>>>    Function IsEnabled Returns Boolean
79339>>>>>        Boolean bEnabled
79339>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
79340>>>>>        Function_Return bEnabled
79341>>>>>    End_Function
79342>>>>>         
79342>>>>>End_Class
79343>>>>>
79343>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
79344>>>>>    
79344>>>>>    Procedure Construct_Object
79346>>>>>        Forward Send Construct_Object
79348>>>>>        Set psCaption   to C_$CaptionSelectAll
79349>>>>>        Set psToolTip to C_$ToolTipSelectAll
79350>>>>>        Set psDescription to C_$DescSelectAll
79351>>>>>        Set pbActiveUpdate to True
79352>>>>>        Set psShortcut to C_$Key_Ctrl_A
79353>>>>>        Set psCategory to C_$CategoryEdit
79354>>>>>    End_Procedure
79355>>>>>
79355>>>>>
79355>>>>>    Procedure OnExecute Variant vCommandBarControl
79357>>>>>        Send Select_All of (focus(Self))
79358>>>>>    End_Procedure
79359>>>>>    
79359>>>>>    Function IsEnabled Returns Boolean
79361>>>>>        Boolean bEnabled
79361>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
79362>>>>>        Function_Return bEnabled
79363>>>>>    End_Function
79364>>>>>         
79364>>>>>End_Class
79365>>>>>
79365>>>>> 
79365>>>>>Class cCJExitMenuItem is a cCJMenuItem
79366>>>>>
79366>>>>>    Procedure Construct_Object
79368>>>>>        Forward Send Construct_Object
79370>>>>>        Set psCaption to C_$CaptionExit
79371>>>>>        Set psToolTip to C_$ToolTipExit
79372>>>>>        Set psDescription to C_$ToolTipExit
79373>>>>>        Set psShortcut to C_$Key_Alt_F4
79374>>>>>        Set psCategory to C_$CategoryFile
79375>>>>>    End_Procedure
79376>>>>>
79376>>>>>    Procedure OnExecute Variant vCommandBarControl
79378>>>>>        Send Exit_Application of Desktop
79379>>>>>    End_Procedure
79380>>>>>
79380>>>>>End_Class           
79381>>>>>
79381>>>>>Class cCJHelpMenuItem is a cCJMenuItem    
79382>>>>>
79382>>>>>    Procedure Construct_Object
79384>>>>>        Forward Send Construct_Object
79386>>>>>        Set psCaption to C_$CaptionHelp
79387>>>>>        Set psDescription to C_$ToolTipHelp
79388>>>>>        Set psToolTip to C_$DescHelp
79389>>>>>        Set psImage to "ActionHelp.ico"
79390>>>>>        Set psShortcut to "F1"
79391>>>>>        Set psCategory to C_$CategoryHelp
79392>>>>>    End_Procedure
79393>>>>>    
79393>>>>>    Procedure OnExecute Variant vCommandBarControl
79395>>>>>        Send Help of (Focus(Self))
79396>>>>>    End_Procedure
79397>>>>>
79397>>>>>End_Class
79398>>>>>
79398>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
79399>>>>>
79399>>>>>    Procedure Construct_Object
79401>>>>>        Forward Send Construct_Object
79403>>>>>        Set psCaption to C_$CaptionAddStatusbar
79404>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
79405>>>>>        Set psDescription to  C_$DescAddStatusbar
79406>>>>>        Set psCategory to C_$CategoryWindow
79407>>>>>    End_Procedure
79408>>>>>
79408>>>>>    Procedure OnExecute Variant vCommandBarControl
79410>>>>>        Handle hoCommandBars hoClientArea
79410>>>>>        Get CommandBarSystemObject to hoCommandBars
79411>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79412>>>>>        If hoClientArea Begin
79414>>>>>            // the clientarea's parent panel has message
79414>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
79415>>>>>        End
79415>>>>>>
79415>>>>>    End_Procedure
79416>>>>>
79416>>>>>     Function IsChecked Returns Boolean
79418>>>>>        Boolean bOn
79418>>>>>        Handle hoCommandBars hoClientArea
79418>>>>>        Get CommandBarSystemObject to hoCommandBars
79419>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79420>>>>>        If hoClientArea Begin
79422>>>>>            // the clientarea's parent panel has message
79422>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
79423>>>>>        End
79423>>>>>>
79423>>>>>        Function_Return bOn
79424>>>>>     End_Function
79425>>>>>End_Class
79426>>>>>
79426>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
79427>>>>>
79427>>>>>    Procedure Construct_Object
79429>>>>>        Forward Send Construct_Object
79431>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
79432>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
79433>>>>>        Set psDescription to C_$DescAutoArrangeIcons
79434>>>>>        Set psCategory to C_$CategoryWindow
79435>>>>>    End_Procedure
79436>>>>>
79436>>>>>    Procedure OnExecute Variant vCommandBarControl
79438>>>>>        Handle hoCommandBars hoClientArea
79438>>>>>        Get CommandBarSystemObject to hoCommandBars
79439>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79440>>>>>        If hoClientArea Begin
79442>>>>>            // the clientarea's parent panel has message
79442>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
79443>>>>>        End
79443>>>>>>
79443>>>>>    End_Procedure
79444>>>>>    
79444>>>>>     Function IsChecked Returns Boolean
79446>>>>>        Boolean bOn
79446>>>>>        Handle hoCommandBars hoClientArea
79446>>>>>        Get CommandBarSystemObject to hoCommandBars
79447>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79448>>>>>        If hoClientArea Begin
79450>>>>>            // the clientarea's parent panel has message
79450>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
79451>>>>>        End
79451>>>>>>
79451>>>>>        Function_Return bOn
79452>>>>>     End_Function
79453>>>>>End_Class
79454>>>>>
79454>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
79455>>>>>
79455>>>>>    Procedure Construct_Object
79457>>>>>        Forward Send Construct_Object
79459>>>>>        Set psCaption to C_$CaptionRestoreMenus
79460>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
79461>>>>>        Set psDescription to C_$DescRestoreMenus
79462>>>>>        Set psCategory to C_$CategoryWindow
79463>>>>>    End_Procedure
79464>>>>>
79464>>>>>    Procedure OnExecute Variant vCommandBarControl
79466>>>>>        Handle hoCommandBars
79466>>>>>        Get CommandBarSystemObject to hoCommandBars
79467>>>>>        Send RestoreLayout of hoCommandBars
79468>>>>>    End_Procedure
79469>>>>>    
79469>>>>>End_Class
79470>>>>>
79470>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
79471>>>>>
79471>>>>>    Procedure Construct_Object
79473>>>>>        Forward Send Construct_Object
79475>>>>>        Set psCaption to C_$CaptionCascade
79476>>>>>        Set psToolTip to C_$ToolTipCascade
79477>>>>>        Set psDescription to  C_$DescCascade
79478>>>>>        Set psImage to "ActionCascade.ico"
79479>>>>>        Set psCategory to C_$CategoryWindow
79480>>>>>    End_Procedure
79481>>>>>    
79481>>>>>    Procedure OnExecute Variant vCommandBarControl
79483>>>>>        Handle hoCommandBars hoClientArea
79483>>>>>        Get CommandBarSystemObject to hoCommandBars
79484>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79485>>>>>        If hoClientArea Begin
79487>>>>>            Send Cascade_Windows of hoClientArea
79488>>>>>        End
79488>>>>>>
79488>>>>>    End_Procedure
79489>>>>>End_Class
79490>>>>>
79490>>>>>Class cCJTileHorizontally is a cCJMenuItem
79491>>>>>
79491>>>>>    Procedure Construct_Object
79493>>>>>        Forward Send Construct_Object
79495>>>>>        Set psCaption to C_$CaptionTileHorizontally 
79496>>>>>        Set psToolTip to C_$ToolTipTileHorizontally  
79497>>>>>        Set psDescription to  C_$DescTileHorizontally
79498>>>>>        Set psImage to "ActionTileHorizontally.ico"
79499>>>>>        Set psCategory to C_$CategoryWindow
79500>>>>>    End_Procedure
79501>>>>>
79501>>>>>    Procedure OnExecute Variant vCommandBarControl
79503>>>>>        Handle hoCommandBars hoClientArea
79503>>>>>        Get CommandBarSystemObject to hoCommandBars
79504>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79505>>>>>        If hoClientArea Begin
79507>>>>>            Send Tile_Windows_Horizontal of hoClientArea
79508>>>>>        End
79508>>>>>>
79508>>>>>    End_Procedure
79509>>>>>End_Class
79510>>>>>
79510>>>>>Class cCJTileVertically is a cCJMenuItem
79511>>>>>
79511>>>>>    Procedure Construct_Object
79513>>>>>        Forward Send Construct_Object
79515>>>>>        Set psCaption to C_$CaptionTileVertically  
79516>>>>>        Set psToolTip to C_$ToolTipTileVertically
79517>>>>>        Set psDescription to  C_$DescTileVertically
79518>>>>>        Set psImage to "ActionTileVertically.ico"
79519>>>>>        Set psCategory to C_$CategoryWindow
79520>>>>>    End_Procedure
79521>>>>>
79521>>>>>    Procedure OnExecute Variant vCommandBarControl
79523>>>>>        Handle hoCommandBars hoClientArea
79523>>>>>        Get CommandBarSystemObject to hoCommandBars
79524>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79525>>>>>        If hoClientArea Begin
79527>>>>>            Send Tile_Windows_Vertical of hoClientArea
79528>>>>>        End
79528>>>>>>
79528>>>>>    End_Procedure
79529>>>>>End_Class
79530>>>>>
79530>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
79531>>>>>
79531>>>>>    Procedure Construct_Object
79533>>>>>        Forward Send Construct_Object
79535>>>>>        Set psCaption to C_$CaptionMinimizeWindows 
79536>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
79537>>>>>        Set psDescription to  C_$DescMinimizeWindows
79538>>>>>        Set psCategory to C_$CategoryWindow
79539>>>>>    End_Procedure
79540>>>>>
79540>>>>>    Procedure OnExecute Variant vCommandBarControl
79542>>>>>        Handle hoCommandBars hoClientArea
79542>>>>>        Get CommandBarSystemObject to hoCommandBars
79543>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79544>>>>>        If hoClientArea Begin
79546>>>>>            // the clientarea's parent panel has message
79546>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
79547>>>>>        End
79547>>>>>>
79547>>>>>    End_Procedure
79548>>>>>End_Class
79549>>>>>
79549>>>>>
79549>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
79550>>>>>
79550>>>>>    Procedure Construct_Object
79552>>>>>        Forward Send Construct_Object
79554>>>>>        Set psCaption to C_$CaptionRestoreWindows
79555>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
79556>>>>>        Set psDescription to  C_$DescRestoreWindows
79557>>>>>        Set psCategory to C_$CategoryWindow
79558>>>>>    End_Procedure
79559>>>>>
79559>>>>>    Procedure OnExecute Variant vCommandBarControl
79561>>>>>        Handle hoCommandBars hoClientArea
79561>>>>>        Get CommandBarSystemObject to hoCommandBars
79562>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79563>>>>>        If hoClientArea Begin
79565>>>>>            // the clientarea's parent panel has message
79565>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
79566>>>>>        End
79566>>>>>>
79566>>>>>    End_Procedure
79567>>>>>End_Class
79568>>>>>
79568>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
79569>>>>>
79569>>>>>    Procedure Construct_Object
79571>>>>>        Forward Send Construct_Object
79573>>>>>        Set psCaption to C_$CaptionArrangeIcons  
79574>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
79575>>>>>        Set psDescription to  C_$DescArrangeIcons
79576>>>>>        Set psCategory to C_$CategoryWindow
79577>>>>>    End_Procedure
79578>>>>>
79578>>>>>    Procedure OnExecute Variant vCommandBarControl
79580>>>>>        Handle hoCommandBars hoClientArea
79580>>>>>        Get CommandBarSystemObject to hoCommandBars
79581>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79582>>>>>        If hoClientArea Begin
79584>>>>>            Send Arrange_Icons of hoClientArea
79585>>>>>        End
79585>>>>>>
79585>>>>>    End_Procedure
79586>>>>>
79586>>>>>End_Class
79587>>>>>    
79587>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJAboutMenuItem.pkg)
79587>>>>>Use cCJCommandBarSystem.pkg
79587>>>>>Use LanguageText.pkg
79587>>>>>
79587>>>>>// It is expected that if you use this class that you provide an about object that is
79587>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
79587>>>>>// because you may wish to create your own custom about package.
79587>>>>>
79587>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
79588>>>>>
79588>>>>>    Procedure Construct_Object
79590>>>>>        Forward Send Construct_Object
79592>>>>>        Set psCaption to C_$CaptionAbout
79593>>>>>        Set psDescription to C_$ToolTipAbout
79594>>>>>        Set psToolTip to C_$DescAbout
79595>>>>>        Set psImage to "ActionAbout.ico"
79596>>>>>        Set psCategory to C_$CategoryHelp
79597>>>>>    End_Procedure
79598>>>>>    
79598>>>>>    Procedure OnExecute Variant vCommandBarControl
79600>>>>>        Handle hoCommandBars hoClientArea
79600>>>>>        Get CommandBarSystemObject to hoCommandBars
79601>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
79602>>>>>        If hoClientArea Begin
79604>>>>>            Send Activate_About of hoClientArea
79605>>>>>        End
79605>>>>>>
79605>>>>>    End_Procedure
79606>>>>>
79606>>>>>End_Class
79607>>>>>
79607>>>>>
79607>>>Use cCJDeoMenuItemClasses.pkg
79607>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJMDIWindowsMenuItem.pkg)
79607>>>>>Use cCJCommandBarSystem.pkg
79607>>>>>
79607>>>>>Register_Function Client_ID Returns Integer
79607>>>>>
79607>>>>>// only used by cCJMDIWIndowsMenuItem
79607>>>>>Class cCJMDIWindowItem is a cCJMenuItem
79608>>>>>
79608>>>>>    Procedure Construct_Object
79610>>>>>        Forward Send Construct_Object
79612>>>>>        Property Handle phWindow 0 // object id of view
79613>>>>>        Set pbControlFlagNoMovable to True
79614>>>>>        Set pbActiveUpdate to True
79615>>>>>    End_Procedure
79616>>>>>    
79616>>>>>    Procedure OnExecute Variant vCommandBarControl
79618>>>>>        Handle hWindow
79618>>>>>        Get phWindow to hWindow
79619>>>>>        Send Activate_View of hWindow
79620>>>>>    End_Procedure
79621>>>>>    
79621>>>>>End_Class                
79622>>>>>
79622>>>>>
79622>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
79623>>>>>    
79623>>>>>    Procedure Construct_Object
79625>>>>>        Forward Send Construct_Object
79627>>>>>        Property Handle[] phArrayOfWindows
79628>>>>>        Set peControlType to xtpControlPopup
79629>>>>>        Set psCategory to C_$CategoryWindow
79630>>>>>    End_Procedure
79631>>>>>    
79631>>>>>     // This adds MDI windows to the existing menu items.
79631>>>>>     // This removes any existing windows menus and always adds a new set to the end
79631>>>>>
79631>>>>>     Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
79633>>>>>        Handle  hClientArea hView
79633>>>>>        String  sLabel
79633>>>>>        Integer i iWindows
79633>>>>>        Handle[] hArrayOfWindows
79634>>>>>        Variant vItem
79634>>>>>        
79634>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
79634>>>>>        // also assume that destroying an action removes all menu instances of that action
79634>>>>>        Get phArrayOfWindows to hArrayOfWindows
79635>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
79636>>>>>        For i from 0 to (iWindows-1)
79642>>>>>>
79642>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
79643>>>>>        Loop
79644>>>>>>
79644>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
79645>>>>>
79645>>>>>        // Add all views to this menu. Create the action and add the item
79645>>>>>        Move 0 to i
79646>>>>>        Get Client_Id to hClientArea // object id of client area
79647>>>>>        If (hClientArea > 0) Begin
79649>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
79650>>>>>            While (hView <> 0)
79654>>>>>                If (Active_State(hView)) Begin
79656>>>>>                    // create the action
79656>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
79657>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
79658>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
79659>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
79660>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
79662>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
79663>>>>>                    End
79663>>>>>>
79663>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
79664>>>>>                    If (i=0) Begin
79666>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
79667>>>>>                    End
79667>>>>>>
79667>>>>>                    // Create a menu item for this action
79667>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
79668>>>>>                    Increment i
79669>>>>>                End
79669>>>>>>
79669>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
79670>>>>>            Loop
79671>>>>>>
79671>>>>>        End
79671>>>>>>
79671>>>>>
79671>>>>>        Set phArrayOfWindows to hArrayOfWindows
79672>>>>>
79672>>>>>     End_Procedure
79673>>>>>     
79673>>>>>End_Class
79674>>>>>
79674>Use cCJCommandBarSystem.pkg
79674>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJSkinFramework.pkg)
79674>>>Use windows.pkg
79674>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJComSkinFramework.pkg)
79674>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v17.3.0\Bin\Codejock.SkinFramework.v17.3.0.ocx
79674>>>>>Use FlexCom20.pkg
79674>>>>>
79674>>>>>// Changes to Imported package
79674>>>>>//     OLEXTPxx to XTPxx
79674>>>>>//     OLExtpxx to xtpxx
79674>>>>>//     OLESkinFramework to SkinFramework
79674>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
79674>>>>>//     cCom classes to cCJ
79674>>>>>//     cCJAutomationObject back to cComAutomationObject
79674>>>>>//     cCJActiveXControl back to cComActiveXControl
79674>>>>>//     cCJSkinFramework to cCJComSkinFramework
79674>>>>>//     Use statements as noted below (classes moved to these files)
79674>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
79674>>>>>
79674>>>>>// These have been extracted from this class and moved into seperate packages
79674>>>>>// because other Codejock classes use these.
79674>>>>>Use cCJColorManager.pkg     // cCJColorManager
79674>>>>>
79674>>>>>Define SkinFrameworkApplyOptions for Integer
79674>>>>>    Define xtpSkinApplyMetrics for 1
79674>>>>>    Define xtpSkinApplyFrame for 2
79674>>>>>    Define xtpSkinApplyColors for 4
79674>>>>>    Define xtpSkinApplyMenus for 8
79674>>>>>
79674>>>>>// CLSID: {AFA0E6A1-28D7-4F2C-87A7-7266367B4655}
79674>>>>>// Dispatch interface for SkinFramework Control
79674>>>>>Class cCJ_DSkinFramework is a Mixin
79675>>>>>
79675>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
79677>>>>>        SkinFrameworkApplyOptions retVal
79677>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
79678>>>>>        Function_Return retVal
79679>>>>>    End_Function
79680>>>>>
79680>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
79682>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
79683>>>>>    End_Procedure
79684>>>>>
79684>>>>>    Function ComAutoApplyNewWindows Returns Boolean
79686>>>>>        Boolean retVal
79686>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
79687>>>>>        Function_Return retVal
79688>>>>>    End_Function
79689>>>>>
79689>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
79691>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
79692>>>>>    End_Procedure
79693>>>>>
79693>>>>>    Function ComAutoApplyNewThreads Returns Boolean
79695>>>>>        Boolean retVal
79695>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
79696>>>>>        Function_Return retVal
79697>>>>>    End_Function
79698>>>>>
79698>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
79700>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
79701>>>>>    End_Procedure
79702>>>>>
79702>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
79704>>>>>        Handle hDispatchDriver
79704>>>>>        Boolean retVal
79704>>>>>        Get phDispatchDriver to hDispatchDriver
79705>>>>>        Send PrepareParams to hDispatchDriver 2
79706>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
79707>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
79708>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
79709>>>>>        Function_Return retVal
79710>>>>>    End_Function
79711>>>>>
79711>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
79713>>>>>        Handle hDispatchDriver
79713>>>>>        Get phDispatchDriver to hDispatchDriver
79714>>>>>        Send PrepareParams to hDispatchDriver 1
79715>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79716>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
79717>>>>>    End_Procedure
79718>>>>>
79718>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
79720>>>>>        Handle hDispatchDriver
79720>>>>>        Get phDispatchDriver to hDispatchDriver
79721>>>>>        Send PrepareParams to hDispatchDriver 2
79722>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79723>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
79724>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
79725>>>>>    End_Procedure
79726>>>>>
79726>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
79728>>>>>        Handle hDispatchDriver
79728>>>>>        Get phDispatchDriver to hDispatchDriver
79729>>>>>        Send PrepareParams to hDispatchDriver 1
79730>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79731>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
79732>>>>>    End_Procedure
79733>>>>>
79733>>>>>    Procedure ComRemoveAllWindows
79735>>>>>        Handle hDispatchDriver
79735>>>>>        Get phDispatchDriver to hDispatchDriver
79736>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
79737>>>>>    End_Procedure
79738>>>>>
79738>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
79740>>>>>        Handle hDispatchDriver
79740>>>>>        Get phDispatchDriver to hDispatchDriver
79741>>>>>        Send PrepareParams to hDispatchDriver 2
79742>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
79743>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
79744>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
79745>>>>>    End_Procedure
79746>>>>>
79746>>>>>    Procedure ComRemoveWindowClass String llClassName
79748>>>>>        Handle hDispatchDriver
79748>>>>>        Get phDispatchDriver to hDispatchDriver
79749>>>>>        Send PrepareParams to hDispatchDriver 1
79750>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
79751>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
79752>>>>>    End_Procedure
79753>>>>>
79753>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
79755>>>>>        Handle hDispatchDriver
79755>>>>>        Variant retVal
79755>>>>>        Get phDispatchDriver to hDispatchDriver
79756>>>>>        Send PrepareParams to hDispatchDriver 2
79757>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
79758>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
79759>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
79760>>>>>        Function_Return retVal
79761>>>>>    End_Function
79762>>>>>
79762>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
79764>>>>>        Handle hDispatchDriver
79764>>>>>        Variant retVal
79764>>>>>        Get phDispatchDriver to hDispatchDriver
79765>>>>>        Send PrepareParams to hDispatchDriver 1
79766>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
79767>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
79768>>>>>        Function_Return retVal
79769>>>>>    End_Function
79770>>>>>
79770>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
79772>>>>>        Handle hDispatchDriver
79772>>>>>        OLE_COLOR retVal
79772>>>>>        Get phDispatchDriver to hDispatchDriver
79773>>>>>        Send PrepareParams to hDispatchDriver 1
79774>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79775>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
79776>>>>>        Function_Return retVal
79777>>>>>    End_Function
79778>>>>>
79778>>>>>    Procedure ComExcludeModule String llModuleName
79780>>>>>        Handle hDispatchDriver
79780>>>>>        Get phDispatchDriver to hDispatchDriver
79781>>>>>        Send PrepareParams to hDispatchDriver 1
79782>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
79783>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
79784>>>>>    End_Procedure
79785>>>>>
79785>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
79787>>>>>        Handle hDispatchDriver
79787>>>>>        Variant retVal
79787>>>>>        Get phDispatchDriver to hDispatchDriver
79788>>>>>        Send PrepareParams to hDispatchDriver 2
79789>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
79790>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
79791>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
79792>>>>>        Function_Return retVal
79793>>>>>    End_Function
79794>>>>>
79794>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
79796>>>>>        Handle hDispatchDriver
79796>>>>>        Get phDispatchDriver to hDispatchDriver
79797>>>>>        Send PrepareParams to hDispatchDriver 2
79798>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
79799>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
79800>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
79801>>>>>    End_Procedure
79802>>>>>
79802>>>>>    Procedure ComAboutBox
79804>>>>>        Handle hDispatchDriver
79804>>>>>        Get phDispatchDriver to hDispatchDriver
79805>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
79806>>>>>    End_Procedure
79807>>>>>End_Class
79808>>>>>
79808>>>>>// CLSID: {40217CB8-4463-4030-B324-AC6A8075FEC8}
79808>>>>>// Event interface for SkinFramework Control
79808>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
79809>>>>>
79809>>>>>    Procedure RegisterComEvents
79811>>>>>    End_Procedure
79812>>>>>End_Class
79813>>>>>
79813>>>>>// CoClass
79813>>>>>// ProgID: Codejock.SkinFramework.17.3.0
79813>>>>>// CLSID: {DE67160B-9A3E-4EA6-846E-8C9A72F9F203}
79813>>>>>// SkinFramework Control
79813>>>>>Class cCJComSkinFramework is a cComActiveXControl
79814>>>>>    Import_Class_Protocol cCJ_DSkinFramework
79815>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
79816>>>>>
79816>>>>>    Procedure Construct_Object
79818>>>>>        Forward Send Construct_Object
79820>>>>>        Set psProgID to "{DE67160B-9A3E-4EA6-846E-8C9A72F9F203}"
79821>>>>>        Set psEventId to "{40217CB8-4463-4030-B324-AC6A8075FEC8}"
79822>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2016 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v17.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
79823>>>>>        Set peAutoCreate to acAutoCreate
79824>>>>>    End_Procedure
79825>>>>>End_Class
79826>>>>>
79826>>>>>// CLSID: {06E8A85B-70E4-4F71-A0FC-D1D5658C7E17}
79826>>>>>// SkinFramework Global Settings
79826>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
79827>>>>>
79827>>>>>    Function ComLicense Returns String
79829>>>>>        String retVal
79829>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
79830>>>>>        Function_Return retVal
79831>>>>>    End_Function
79832>>>>>
79832>>>>>    Procedure Set ComLicense String value
79834>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
79835>>>>>    End_Procedure
79836>>>>>
79836>>>>>    Function ComTitle Returns String
79838>>>>>        String retVal
79838>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
79839>>>>>        Function_Return retVal
79840>>>>>    End_Function
79841>>>>>
79841>>>>>    Procedure Set ComTitle String value
79843>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
79844>>>>>    End_Procedure
79845>>>>>
79845>>>>>    Function ComVersion Returns String
79847>>>>>        Handle hDispatchDriver
79847>>>>>        String retVal
79847>>>>>        Get phDispatchDriver to hDispatchDriver
79848>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
79849>>>>>        Function_Return retVal
79850>>>>>    End_Function
79851>>>>>
79851>>>>>    Function ComUnicode Returns Boolean
79853>>>>>        Handle hDispatchDriver
79853>>>>>        Boolean retVal
79853>>>>>        Get phDispatchDriver to hDispatchDriver
79854>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
79855>>>>>        Function_Return retVal
79856>>>>>    End_Function
79857>>>>>
79857>>>>>    Function ComOcxPath Returns String
79859>>>>>        Handle hDispatchDriver
79859>>>>>        String retVal
79859>>>>>        Get phDispatchDriver to hDispatchDriver
79860>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
79861>>>>>        Function_Return retVal
79862>>>>>    End_Function
79863>>>>>End_Class
79864>>>>>
79864>>>>>// CoClass
79864>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.17.3.0
79864>>>>>// CLSID: {C4136A4A-67FD-4FC1-BA62-A715B4D60808}
79864>>>>>// SkinFramework Global Settings
79864>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
79865>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
79866>>>>>
79866>>>>>    Procedure Construct_Object
79868>>>>>        Forward Send Construct_Object
79870>>>>>        Set psProgID to "{C4136A4A-67FD-4FC1-BA62-A715B4D60808}"
79871>>>>>        Set peAutoCreate to acNoAutoCreate
79872>>>>>    End_Procedure
79873>>>>>End_Class
79874>>>>>
79874>>>>>// CLSID: {27E4AC9B-4A2D-4FBB-A782-BD76BEFA4345}
79874>>>>>Class cCJSkinIniFile is a cComAutomationObject
79875>>>>>
79875>>>>>    Function ComColorScheme Returns String
79877>>>>>        String retVal
79877>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
79878>>>>>        Function_Return retVal
79879>>>>>    End_Function
79880>>>>>
79880>>>>>    Procedure Set ComColorScheme String value
79882>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
79883>>>>>    End_Procedure
79884>>>>>
79884>>>>>    Function ComFontSize Returns String
79886>>>>>        String retVal
79886>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
79887>>>>>        Function_Return retVal
79888>>>>>    End_Function
79889>>>>>
79889>>>>>    Procedure Set ComFontSize String value
79891>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
79892>>>>>    End_Procedure
79893>>>>>
79893>>>>>    Function ComIniFileName Returns String
79895>>>>>        String retVal
79895>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
79896>>>>>        Function_Return retVal
79897>>>>>    End_Function
79898>>>>>
79898>>>>>    Procedure Set ComIniFileName String value
79900>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
79901>>>>>    End_Procedure
79902>>>>>End_Class
79903>>>>>
79903>>>>>// CLSID: {5005F22B-A30E-4B12-B142-E97F62A927A6}
79903>>>>>Class cCJSkinDescription is a cComAutomationObject
79904>>>>>
79904>>>>>    Function ComName Returns String
79906>>>>>        String retVal
79906>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
79907>>>>>        Function_Return retVal
79908>>>>>    End_Function
79909>>>>>
79909>>>>>    Procedure Set ComName String value
79911>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
79912>>>>>    End_Procedure
79913>>>>>
79913>>>>>    Function ComPath Returns String
79915>>>>>        String retVal
79915>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
79916>>>>>        Function_Return retVal
79917>>>>>    End_Function
79918>>>>>
79918>>>>>    Procedure Set ComPath String value
79920>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
79921>>>>>    End_Procedure
79922>>>>>
79922>>>>>    Function ComCount Returns Integer
79924>>>>>        Handle hDispatchDriver
79924>>>>>        Integer retVal
79924>>>>>        Get phDispatchDriver to hDispatchDriver
79925>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
79926>>>>>        Function_Return retVal
79927>>>>>    End_Function
79928>>>>>
79928>>>>>    Function ComIniFile Integer llIndex Returns Variant
79930>>>>>        Handle hDispatchDriver
79930>>>>>        Variant retVal
79930>>>>>        Get phDispatchDriver to hDispatchDriver
79931>>>>>        Send PrepareParams to hDispatchDriver 1
79932>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79933>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
79934>>>>>        Function_Return retVal
79935>>>>>    End_Function
79936>>>>>
79936>>>>>    Function Com_NewEnum Returns Variant
79938>>>>>        Handle hDispatchDriver
79938>>>>>        Variant retVal
79938>>>>>        Get phDispatchDriver to hDispatchDriver
79939>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
79940>>>>>        Function_Return retVal
79941>>>>>    End_Function
79942>>>>>End_Class
79943>>>>>
79943>>>>>// CLSID: {C4367A33-2A7C-4CC6-BF0C-C50383B34B51}
79943>>>>>Class cCJSkinDescriptions is a cComAutomationObject
79944>>>>>
79944>>>>>    Function ComCount Returns Integer
79946>>>>>        Handle hDispatchDriver
79946>>>>>        Integer retVal
79946>>>>>        Get phDispatchDriver to hDispatchDriver
79947>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
79948>>>>>        Function_Return retVal
79949>>>>>    End_Function
79950>>>>>
79950>>>>>    Function ComSkin Integer llIndex Returns Variant
79952>>>>>        Handle hDispatchDriver
79952>>>>>        Variant retVal
79952>>>>>        Get phDispatchDriver to hDispatchDriver
79953>>>>>        Send PrepareParams to hDispatchDriver 1
79954>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
79955>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
79956>>>>>        Function_Return retVal
79957>>>>>    End_Function
79958>>>>>
79958>>>>>    Function Com_NewEnum Returns Variant
79960>>>>>        Handle hDispatchDriver
79960>>>>>        Variant retVal
79960>>>>>        Get phDispatchDriver to hDispatchDriver
79961>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
79962>>>>>        Function_Return retVal
79963>>>>>    End_Function
79964>>>>>End_Class
79965>>>>>
79965>>>>>// CLSID: {128507E0-C56F-43C0-BCF1-8193B35FE4C4}
79965>>>>>Class cCJSkinSchema is a cComAutomationObject
79966>>>>>End_Class
79967>>>Use cApplication.pkg
79967>>>
79967>>>Struct tSkinInformation
79967>>>    String sName     // description of the skin
79967>>>    String sSkinfile // file path. Can be relative or full
79967>>>    String sSkinIni  // section name
79967>>>End_Struct
79967>>>
79967>>>
79967>>>Class cCJSkinFramework is a cCJComSkinFramework
79968>>>    
79968>>>    Procedure Construct_Object
79970>>>        Forward Send Construct_Object
79972>>>        
79972>>>        Property String psSkinFile ""
79973>>>        Property String psSkinIni ""
79974>>>        Property Boolean pbLoadPreference False
79975>>>        
79975>>>        Set peAutoCreate to acAutoCreate
79976>>>        
79976>>>        Move Self to ghoSkinFramework
79977>>>    End_Procedure
79978>>>    
79978>>>    // return the default skin path, which is the programs directory.
79978>>>    // This requires an application object.
79978>>>    // If you want to different skin path, override this.
79978>>>    Function SkinPath Returns String
79980>>>        String sPath sPaths
79980>>>        Handle hoWorkspace
79980>>>        If ghoApplication Begin
79982>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79983>>>            Get psProgramPath of hoWorkspace to sPaths
79984>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
79985>>>        End
79985>>>>
79985>>>        Else Begin
79986>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
79987>>>>
79987>>>        End
79987>>>>
79987>>>        Function_Return sPath
79988>>>    End_Function
79989>>>    
79989>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
79989>>>    // returns itself. If it is not, it uses SkinPath to get the path.
79989>>>    Function SkinQFile Returns String
79991>>>        String sFile sPath sSep
79991>>>        Boolean bQualified
79991>>>        Get psSkinFile to sFile
79992>>>        If not (IsFileNameQualified(sFile)) Begin
79994>>>            Get SkinPath to sPath
79995>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
79996>>>            Move (sPath - sSep - sFile) to sFile
79997>>>        End
79997>>>>
79997>>>        Function_Return sFile
79998>>>    End_Function
79999>>>        
79999>>>    // defines the default VDF window class mapping.    
79999>>>    Procedure OnAddVDFWindowClasses
80001>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
80002>>>        Send ComAddWindowClass "DFentry"                 "Edit"
80003>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
80004>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
80005>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
80006>>>        Send ComAddWindowClass "DFformlist"              "Edit"
80007>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
80008>>>        Send ComAddWindowClass "DFbutton"                "Button"
80009>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
80010>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
80011>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
80012>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient" 
80013>>>        Send ComAddWindowClass "DFedit"                  "edit"
80014>>>        Send ComAddWindowClass "DFlistedit"              "edit"
80015>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
80016>>>        Send ComAddWindowClass "DFgroup"                 "Button"
80017>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
80018>>>        // External class
80018>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
80019>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
80020>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
80021>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
80022>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
80023>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
80024>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
80025>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
80026>>>    End_Procedure
80027>>>    
80027>>>    // Used to support developer designed class mappings (e.g. COM controls)
80027>>>    Procedure OnAddCustomWindowClasses
80029>>>    End_Procedure
80030>>>
80030>>>    // called when object is created during end_construct_object.
80030>>>    Procedure OnCreate
80032>>>        Integer iOpts
80032>>>        Boolean bUseWindowsFont
80032>>>        Forward Send OnCreate
80034>>>        
80034>>>        // if we are using the windows fonts we will disable the apply metrics which
80034>>>        // never really looked good anyway. This test only exists or legacy purposes
80034>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
80035>>>        If bUseWindowsFont Begin
80037>>>            Get ComApplyOptions to iOpts
80038>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
80039>>>        End
80039>>>>
80039>>>
80039>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down. 
80039>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
80039>>>        // and this was the suggested workaround.
80039>>>        Set ComAutoApplyNewThreads to False
80040>>>
80040>>>        Send OnAddVDFWindowClasses
80041>>>        Send OnAddCustomWindowClasses
80042>>>        
80042>>>        // if preferences are used, it will set psSkinFile and psSkinIni
80042>>>        If (pbLoadPreference(Self)) Begin
80044>>>            Send LoadSkinPreference
80045>>>        End
80045>>>>
80045>>>        // if a skin file name exists, we apply the skin.    
80045>>>        If (psSkinFile(Self)<>"") Begin
80047>>>            Send ApplySkin
80048>>>        End        
80048>>>>
80048>>>    End_Procedure
80049>>>    
80049>>>    // called by framework as part of application exit.
80049>>>    Procedure Broadcast_Notify_Exit_Application
80051>>>        Send Notify_Exit_Application
80052>>>    End_Procedure // Notify_Exit_Application
80053>>>
80053>>>    Procedure Notify_Exit_Application
80055>>>        If (pbLoadPreference(Self)) Begin
80057>>>            Send SaveSkinPreference
80058>>>        End
80058>>>>
80058>>>    End_Procedure
80059>>>
80059>>>    Procedure NotifyPreApplySkin
80061>>>        Broadcast Send OnPreApplySkin of Desktop True       
80063>>>    End_Procedure
80064>>>
80064>>>    Procedure NotifyPostApplySkin
80066>>>        Broadcast Send OnPostApplySkin of Desktop True       
80068>>>    End_Procedure
80069>>>    
80069>>>    // returns an array of all skins in the path. If path is "", use the default path.
80069>>>    // If the default path is used, returns the file names as relative names, else use full path.
80069>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
80071>>>        tSkinInformation[] Skins
80071>>>        tSkinInformation[] Skins
80072>>>        String sSkinName sSkinFile sDefaultPath sSep
80072>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
80072>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
80072>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
80072>>>        Integer iPos iDfltLen
80072>>>        Boolean bUseRelativePath
80072>>>        
80072>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
80073>>>        
80073>>>        Get SkinPath to sDefaultPath
80074>>>        If (sPath="") Begin
80076>>>            Move sDefaultPath to sPath
80077>>>        End
80077>>>>
80077>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
80078>>>        Move (Length(sDefaultPath)) to iDfltLen
80079>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
80080>>>
80080>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
80081>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
80083>>>
80083>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
80084>>>            Get Create U_cCJSkinDescription to hSkinDescription
80085>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
80086>>>            
80086>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
80087>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
80088>>>            
80088>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
80094>>>>
80094>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
80095>>>                Set pvComObject of hSkinDescription to vSkinDescription
80096>>>
80096>>>                Get ComCount of hSkinDescription to iNumSkins
80097>>>                    
80097>>>                For iSkinsCount from 0 to (iNumSkins-1)
80103>>>>
80103>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
80104>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
80105>>>
80105>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
80106>>>                    Get ComPath of hSkinDescription to sSkinFile
80107>>>                    If bUseRelativePath Begin
80109>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
80110>>>                        If iPos Begin
80112>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile   
80113>>>                            While (Left(sSkinFile,1)=sSep)
80117>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile   
80118>>>                            Loop                         
80119>>>>
80119>>>                        End
80119>>>>
80119>>>                    End
80119>>>>
80119>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
80120>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
80121>>>
80121>>>                    Increment iArrayItem
80122>>>                Loop
80123>>>>
80123>>>            Loop
80124>>>>
80124>>>                            
80124>>>            Send Destroy of hSkinDescriptions
80125>>>            Send Destroy of hSkinDescription
80126>>>            Send Destroy of hSkinIniFile
80127>>>                
80127>>>        End
80127>>>>
80127>>>        Function_Return Skins
80128>>>    End_Function 
80129>>>    
80129>>>    // Save the skin preference. This requires an application object.
80129>>>    // Only do this if the application object allows it. 
80129>>>    // This is called during startup if pbLoadPreference is True
80129>>>    // Suitable for override
80129>>>    Procedure SaveSkinPreference 
80131>>>        String sSkin sIni
80131>>>        If ghoApplication Begin
80133>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80135>>>                Get psSkinFile to sSkin
80136>>>                Get psSkinIni to sIni
80137>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
80138>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
80139>>>            End
80139>>>>
80139>>>        End
80139>>>>
80139>>>        Else Begin
80140>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80141>>>>
80141>>>        End
80141>>>>
80141>>>    End_Procedure
80142>>>
80142>>>    // Load the skin preference. This requires an application object.
80142>>>    // Only do this if the application object allows it. 
80142>>>    // This is called during startup if pbLoadPreference is True
80142>>>    // Suitable for override
80142>>>    Procedure LoadSkinPreference 
80144>>>        String sSkin sIni
80144>>>        Boolean bExists
80144>>>        If ghoApplication Begin
80146>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
80148>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
80149>>>                If bExists Begin
80151>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
80152>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
80153>>>                    Set psSkinFile to sSkin
80154>>>                    Set psSkinIni to sIni
80155>>>                End
80155>>>>
80155>>>            End
80155>>>>
80155>>>        End
80155>>>>
80155>>>        Else Begin
80156>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
80157>>>>
80157>>>        End
80157>>>>
80157>>>    End_Procedure
80158>>>
80158>>>    // Can be called to apply the current skin.
80158>>>    Procedure ApplySkin
80160>>>        Boolean bOk
80160>>>        String sSkin sIni
80160>>>        If (IsComObjectCreated(Self)) Begin
80162>>>            Get SkinQFile to sSkin
80163>>>            Get psSkinIni to sIni
80164>>>            
80164>>>            Send NotifyPreApplySkin
80165>>>            // when skins are used we don't want to use built in Visual Styles
80165>>>            Send EnableVisualStyles of Desktop (sSkin="")
80166>>>            Get ComLoadSkin sSkin sIni to bOK
80167>>>            If (sSkin<>"" and not(bOk)) Begin
80169>>>                // if not ok, no skin was appied. Enable visual styles
80169>>>                Send EnableVisualStyles of Desktop True
80170>>>            End
80170>>>>
80170>>>            Send NotifyPostApplySkin
80171>>>        End
80171>>>>
80171>>>    End_Procedure
80172>>>
80172>>>
80172>>>End_Class
80173>
80173>Object oHtmlHelp is a cHtmlHelp
80175>    Set pbAlwaysOnTop to False
80176>
80176>    // Overriden class message to also handle internet HTML Help links;
80176>    // which in which case we should not try to find the path to the help file.
80176>    Function GetHelpFile Returns String
80179>        String sHelpFile
80179>
80179>        Get psHelpFile of ghoApplication to sHelpFile
80180>        If (sHelpFile <> "" and not(sHelpFile contains "http:")) Begin
80182>            Get_File_Path sHelpFile to sHelpFile
80183>        End
80183>        Function_Return sHelpFile
80184>    End_Function
80185>
80185>End_Object
80186>
80186>Object oApplication is a cApplication
80188>    Set peHelpType to htHtmlHelp
80189>
80189>    // Note: These help file settings gets changed by the Help toolbar button(s).
80189>    Set psHelpFile to "DataFlex.chm"  //"Developer5.chm"
80190>//    Set psHelpFile to "http://www.rdctools.com/HTMLHelp/Developer5.htm"
80190>
80190>    Set pbPreserveEnvironment to True
80191>    Set psProduct to "Database Update Framework Lab"
80192>    Set psCompany to "RDC Tools International"
80193>
80193>    // DF 19 and up.
80193>
80193>End_Object
80194>
80194>// Unmark the following line if using Mertech drivers!
80194>Define DUF_Use_Mertech_Drivers
80194>
80194>//Object oCJSkinFramework is a cCJSkinFramework
80194>//    Set pbLoadPreference to True
80194>//End_Object
80194>
80194>Object oToolTipController is a cToolTipController
80196>    Set piDurationPopup to 10000
80197>    Set piMaxWidth to 500
80198>    Move Self to ghoToolTipController
80199>End_Object
80200>
80200>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oEditContextMenu.pkg)
80200>>>Use cCJStandardMenuItemClasses.pkg
80200>>>
80200>>>Object oEditContextMenu is a cCJContextMenu
80202>>>    
80202>>>    Move Self to Default_Form_Floating_Menu_ID
80203>>>    
80203>>>    Object oUndoMenuItem is a cCJUndoMenuItem
80205>>>    End_Object
80206>>>    
80206>>>    Object oCutMenuItem is a cCJCutMenuItem
80208>>>        Set pbControlBeginGroup to True
80209>>>    End_Object
80210>>>    
80210>>>    Object oCopyMenuItem is a cCJCopyMenuItem
80212>>>    End_Object
80213>>>
80213>>>    Object oPasteMenuItem is a cCJPasteMenuItem
80215>>>    End_Object
80216>>>
80216>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
80218>>>    End_Object
80219>>>
80219>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
80221>>>        Set pbControlBeginGroup to True
80222>>>    End_Object
80223>>>
80223>>>End_Object
80224>>>
80224>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\oDEOEditContextMenu17.pkg)
80224>>>Use Windows.pkg
80224>>>Use cCJStandardMenuItemClasses.pkg
80224>>>Use cCJDeoMenuItemClasses.pkg
80224>>>
80224>>>
80224>>>Object oDEOEditContextMenu17 is a cCJContextMenu
80226>>>    
80226>>>    Move Self to Default_dbFloating_Menu_ID
80227>>>    
80227>>>    Object oUndoMenuItem is a cCJUndoMenuItem
80229>>>    End_Object
80230>>>    
80230>>>    Object oCutMenuItem is a cCJCutMenuItem
80232>>>        Set pbControlBeginGroup to True
80233>>>    End_Object
80234>>>    
80234>>>    Object oCopyMenuItem is a cCJCopyMenuItem
80236>>>    End_Object
80237>>>
80237>>>    Object oPasteMenuItem is a cCJPasteMenuItem
80239>>>    End_Object
80240>>>
80240>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
80242>>>    End_Object
80243>>>
80243>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
80245>>>        Set pbControlBeginGroup to True
80246>>>    End_Object
80247>>>
80247>>>    Object oPromptMenuItem is a cCJPromptMenuItem
80249>>>        Set pbControlBeginGroup to True
80250>>>    End_Object
80251>>>
80251>>>    Object oFindNextMenu is a cCJFindNextMenuItem
80253>>>        Set pbControlBeginGroup to True
80254>>>    End_Object
80255>>>
80255>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
80257>>>    End_Object
80258>>>
80258>>>    Object oClearMenuItem is a cCJClearMenuItem
80260>>>        Set pbControlBeginGroup to True
80261>>>    End_Object
80262>>>
80262>>>    Object oClearAllMenu is a cCJClearAllMenuItem
80264>>>    End_Object
80265>>>
80265>>>    Object oSaveMenu is a cCJSaveMenuItem
80267>>>    End_Object
80268>>>    
80268>>>    Object oDeleteMenu is a cCJDeleteMenuItem
80270>>>    End_Object
80271>>>
80271>>>    Object oRememberitem is a cCJRememberFieldMenuItem
80273>>>        Set pbControlBeginGroup to True
80274>>>    End_Object
80275>>>
80275>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
80277>>>    End_Object
80278>>>
80278>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
80280>>>    End_Object
80281>>>
80281>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
80283>>>    End_Object
80284>>>
80284>>>End_Object
80285>Use cSkinComboBoxCJMenuItem.pkg
Including file: cSkinComboBoxCJMenuItem.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSkinComboBoxCJMenuItem.pkg)
80285>>>Use cCJCommandBarSystem.pkg
80285>>>Use cCJSkinFramework.pkg
80285>>>Use Wingdi.pkg
80285>>>
80285>>>
80285>>>Define CS_NoSkinShort for "-None"
80285>>>Define CS_NoSkinLong  for "Do not use a skin"
80285>>>
80285>>>Class cSkinComboBoxCJMenuItem is a cCJMenuItem
80286>>>
80286>>>    Procedure Construct_Object
80288>>>        Forward Send Construct_Object
80290>>>
80290>>>        Set peControlType to xtpControlComboBox
80291>>>
80291>>>        Property tSkinInformation[] pSkins
80292>>>
80292>>>    End_Procedure
80293>>>
80293>>>    Procedure End_Construct_Object
80295>>>        Forward Send End_Construct_Object
80297>>>    End_Procedure
80298>>>
80298>>>    // Custom array sort for the tSkinInformation struct array.
80298>>>    // Used by LoadSkins message to sort the skin array alphabetically after it has been loaded.
80298>>>    // Why?
80298>>>    // First of all, structs can't be used with the standard SortArray function, that is why we need to
80298>>>    // create a custom sort algorithm.
80298>>>    // Secondly the list of skins would else be sorted in the alphabetical order by the file names.
80298>>>    // However, it is not always the case that the skin description (sName) is the same as the file name.
80298>>>    // If it isn't (which is almost always the case if you have many skin files) the list will look
80298>>>    // randomly ordered. This custom sort method will take care of that.
80298>>>    Function SkinSort tSkinInformation sDescription tSkinInformation sSearchDescription Returns Integer
80300>>>        Integer iRetVal
80300>>>        If ((sDescription.sName * sDescription.sSkinIni) > (sSearchDescription.sName * sSearchDescription.sSkinIni)) Function_Return (GT)
80303>>>        If ((sDescription.sName * sDescription.sSkinIni) < (sSearchDescription.sName * sSearchDescription.sSkinIni)) Function_Return (LT)
80306>>>        Function_Return (EQ)
80307>>>    End_Function
80308>>>
80308>>>    Procedure OnCreateControl Handle hoObj
80310>>>        Forward Send OnCreateControl hoObj
80312>>>
80312>>>        Set ComDropDownWidth of hoObj to 150
80313>>>        Set ComWidth         of hoObj to 150
80314>>>        Send LoadSkins
80315>>>        Send FillComboList hoObj
80316>>>    End_Procedure
80317>>>
80317>>>    // Load all skins. We will only look for skins in expected
80317>>>    // directory which is the Programs folder.
80317>>>    // Important: When loading skins they will be sorted alphabetically. (See Skinsort function above).
80317>>>    // This is not the case with the 'standard' VDF behaviour.
80317>>>    Procedure LoadSkins
80319>>>        Integer iCount iItems iRow iSize
80319>>>        Boolean bFound
80319>>>        String sFile sIni sSkin
80319>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
80319>>>        tSkinInformation[] SkinsArray SkinsArrayNoLarge
80321>>>        tSkinInformation NoneRow
80321>>>        tSkinInformation NoneRow
80321>>>
80321>>>        If (ghoSkinFramework > 0) Begin
80323>>>            Get EnumerateSkins of ghoSkinFramework "" True   to SkinsArray
80324>>>
80324>>>            Move (SortArray(SkinsArray, Self, get_SkinSort)) to SkinsArray
80325>>>            Move CS_NoSkinShort to NoneRow.sName
80326>>>            Move CS_NoSkinLong  to NoneRow.sSkinfile
80327>>>            Move CS_NoSkinLong  to NoneRow.sSkinIni
80328>>>            Move (InsertInArray(SkinsArray, 0, NoneRow))     to SkinsArray
80329>>>
80329>>>            // Get the currently loaded skin.
80329>>>            Get psSkinFile of ghoSkinFramework to sFile
80330>>>            Get psSkinIni  of ghoSkinFramework to sIni
80331>>>
80331>>>            // Remove all Extra Large and Large skins from the array.
80331>>>            Move (SizeOfArray(SkinsArray)) to iItems
80332>>>            Decrement iItems
80333>>>            For iCount from 0 to iItems
80339>>>>
80339>>>                Move SkinsArray[iCount].sSkinIni to sSkin
80340>>>                Move (Uppercase(sSkin) contains " LARGE") to bFound
80341>>>                If (bFound = False) Begin
80343>>>                    Move (SizeOfArray(SkinsArrayNoLarge)) to iSize
80344>>>                    Move SkinsArray[iCount].sName         to SkinsArrayNoLarge[iSize].sName
80345>>>                    Move SkinsArray[iCount].sSkinfile     to SkinsArrayNoLarge[iSize].sSkinfile
80346>>>                    Move SkinsArray[iCount].sSkinIni      to SkinsArrayNoLarge[iSize].sSkinIni
80347>>>                End
80347>>>>
80347>>>            Loop
80348>>>>
80348>>>            Set pSkins to SkinsArrayNoLarge
80349>>>        End
80349>>>>
80349>>>    End_Procedure
80350>>>
80350>>>    // Fills the CodeJock combobox with all skins from the current Programs folder.
80350>>>    Procedure FillComboList Handle hoCombo
80352>>>        Integer iCount iItems iCurrent iTxtEntentSize
80352>>>        String  sFile sIni sCurrSkin
80352>>>        String  sSkin sSkinText
80352>>>        tSkinInformation[] SkinsArray
80352>>>        tSkinInformation[] SkinsArray
80353>>>        Integer iSize
80353>>>
80353>>>        If (ghoSkinFramework < 1) Procedure_Return
80356>>>
80356>>>        // Get the currently loaded skin.
80356>>>        Get psSkinFile of ghoSkinFramework to sFile
80357>>>        Get psSkinIni  of ghoSkinFramework to sIni
80358>>>        Get pSkins to SkinsArray
80359>>>        Move (SizeOfArray(SkinsArray)) to iItems
80360>>>        Decrement iItems
80361>>>        Send ComClear of hoCombo
80362>>>
80362>>>        For iCount from 0 to iItems
80368>>>>
80368>>>            Move SkinsArray[iCount].sSkinIni  to sSkin
80369>>>            Move (Replace(".ini", sSkin, "")) to sSkin
80370>>>            Move (SkinsArray[iCount].sName * "-" * sSkin) to sSkinText
80371>>>            Send ComAddItem of hoCombo sSkinText (iCount +1)
80372>>>            Get Text_Extent sSkinText to iSize
80373>>>            If (iSize > iTxtEntentSize) Begin
80375>>>                Move iSize to iTxtEntentSize
80376>>>            End
80376>>>>
80376>>>            Move (SkinsArray[iCount].sSkinFile * "-" * SkinsArray[iCount].sSkinIni) to sCurrSkin
80377>>>            If (sCurrSkin = (sFile * "-" * sIni)) Begin
80379>>>                Move iCount to iCurrent
80380>>>            End
80380>>>>
80380>>>        Loop
80381>>>>
80381>>>
80381>>>        Move (Low(iTxtEntentSize) + 30)  to iSize
80382>>>        Set ComDropDownWidth of hoCombo  to iSize
80383>>>        Set ComWidth         of hoCombo  to iSize
80384>>>        Set ComListIndex     of hoCombo  to (iCurrent +1)
80385>>>    End_Procedure
80386>>>
80386>>>    // Event for when an item is selected from the comboform
80386>>>    Procedure OnExecute Variant vCommandBarControl
80388>>>        Handle  hoCombo
80388>>>        Integer iSelection
80388>>>        String  sSkinFile sSkinIni
80388>>>        tSkinInformation[] SkinsArray
80388>>>        tSkinInformation[] SkinsArray
80389>>>
80389>>>        // Create and bind proxy control
80389>>>        Get CreateProxyControl vCommandBarControl to hoCombo
80390>>>        // Get the current selection
80390>>>        Get ComListIndex of hoCombo to iSelection
80391>>>        Decrement iSelection
80392>>>        Get pSkins to SkinsArray
80393>>>        Move SkinsArray[iSelection].sSkinfile to sSkinFile
80394>>>        Move SkinsArray[iSelection].sSkinIni  to sSkinIni
80395>>>
80395>>>        Send DoChangeSkin sSkinFile sSkinIni
80396>>>
80396>>>        // Dispose of the proxy control
80396>>>        Send Destroy of hoCombo
80397>>>    End_Procedure
80398>>>
80398>>>    // Send this message to change the current skin.
80398>>>    Procedure DoChangeSkin String sSkinFile String sSkinIni
80400>>>        Handle hoClient
80400>>>
80400>>>        Set psSkinFile of ghoSkinFramework to sSkinFile
80401>>>        Set psSkinIni  of ghoSkinFramework to sSkinIni
80402>>>        Send ApplySkin of ghoSkinFramework
80403>>>
80403>>>        // Note: The following line is essential for the resizing logic
80403>>>        // to function properly when changing a skin and a view is maximized.
80403>>>        Move (Client_Id(phoMainPanel(ghoApplication))) to hoClient
80404>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) +2))
80405>>>        Set Size of hoClient to (Hi(Size(hoClient))) (Low(Size(hoClient) -2))
80406>>>    End_Procedure
80407>>>
80407>>>    // Returns: DPI setting as an integer.
80407>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
80407>>>    //                      iDPI=120 is "Medium setting" 125%
80407>>>    //                      iDPI= 144 is "Large setting" 150%
80407>>>    Function GetCurrentDPI Returns Integer
80409>>>        Handle hDC
80409>>>        Integer iPixelsX
80409>>>        Move (GetDC(0)) to hDC
80410>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
80411>>>        Move (ReleaseDC(0, hDC)) to hDC
80412>>>        Function_Return iPixelsX
80413>>>    End_Function
80414>>>
80414>>>End_Class
80415>
80415>Object oMain is a Panel
80417>    Set Label to "Test Program - The Database Update Framework"
80418>    Set Location to 4 3
80419>    Set Size to 349 493
80420>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
80421>    Set Icon to "DbUpdateFrameworkDF19.ico"
80422>
80422>    Property Handle phoViewMenu 0
80424>    Property Handle phoReportMenu 0
80426>
80426>    Object oCommandBarSystem is a cCJCommandBarSystem
80428>        Set pbTimerUpdate to True
80429>            Set pbAutoResizeIcons to True
80430>            Set pbTabbedWorkspaces to True // Switch on for DF 19 to see the new tabbed-view look.
80431>
80431>        Procedure OnCreateCommandBars
80434>            Forward Send OnCreateCommandBars
80436>            Send DisplayTabWorkspace
80437>        End_Procedure
80438>
80438>        Procedure DisplayTabWorkspace
80441>            Variant vTab vPaintManager
80441>            Handle hoTab hoPaintManager  hoOptions
80441>            Integer iSize
80441>
80441>            If (not(IsComObjectCreated(Self))) Procedure_Return
80444>
80444>            Get OptionsObject to hoOptions
80445>
80445>            // Create the tab workspace object. It will get created for the Client_Area so
80445>            // each view will be displayd on a separate tab-page (instead of the standard VDF MDI-interface)
80445>            Get Create (RefClass(cCJTabWorkspace)) to hoTab
80446>            Get ComShowTabWorkspace True to vTab
80447>            // Connect the CodeJock side to the DataFlex proxy object.
80447>            Set pvComObject  of hoTab to vTab
80448>
80448>            Set ComFlags of hoTab to xtpWorkspaceShowCloseTab
80449>            Send ComEnableGroups of hoTab
80450>
80450>            // Create a paint manager object that is needed to set some
80450>            // of the tab-workspace properties.
80450>            Get Create (RefClass(cCJTabPaintManager)) to hoPaintManager
80451>            Get ComPaintManager of hoTab          to vPaintManager
80452>            Set pvComObject     of hoPaintManager to vPaintManager
80453>            // This will truncate the middle part of long items
80453>            Set ComDrawTextPathEllipsis of hoPaintManager to True
80454>            Set ComLayout               of hoPaintManager to xtpTabLayoutMultiRow
80455>
80455>//#IF (Required_RT_Version < 19)
80455>//            Move 16 to iSize
80455>//            Send ComSetIconSize         of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
80455>//            Move 24 to iSize
80455>//            Send ComSetIconSize         of hoPaintManager  iSize iSize  // Set icon size for Tab-workspace.
80455>//#ELSE
80455>            Get Create (RefClass(cCJPaintManager)) to hoPaintManager
80456>            Get ComPaintManager of hoPaintManager  to vPaintManager
80457>            Set pvComObject     of hoPaintManager  to vPaintManager
80458>            Set ComAutoResizeIcons of hoPaintManager to True
80459>//#ENDIF
80459>            Send Destroy of hoPaintManager
80460>            Send ComRecalcLayout
80461>            Send Destroy of hoTab
80462>        End_Procedure
80463>
80463>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
80463>        // the previous tab workspace view.
80463>        Object oPreviousTabAction is a cCJAction
80465>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
80466>            Procedure OnExecute Variant vCommandBarControl
80469>                Handle hoCommandBars hoClientArea
80469>                Forward Send OnExecute vCommandBarControl
80471>                Get CommandBarSystemObject to hoCommandBars
80472>                Get ClientAreaObject of hoCommandBars to hoClientArea
80473>                If hoClientArea Begin
80475>                    Send Switch_Next_View of hoClientArea
80476>                End
80476>            End_Procedure
80477>        End_Object
80478>
80478>        Object oMenuBar is a cCJMenuBar
80480>
80480>            Object oFileMenu is a cCJMenuItem
80482>                Set peControlType to xtpControlPopup
80483>                Set psCaption to "&File"
80484>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
80485>                Set psCategory to "Menus"
80486>
80486>                Object oClearMenuItem is a cCJClearMenuItem
80488>                    Set pbAddToDesignerMenu to True
80489>                End_Object
80490>
80490>                Object oClearAllMenu is a cCJClearAllMenuItem
80492>                    Set pbAddToDesignerMenu to True
80493>                End_Object
80494>
80494>                Object oPromptMenuItem is a cCJPromptMenuItem
80496>                    Set pbAddToDesignerMenu to True
80497>                    Set pbControlBeginGroup to True
80498>                End_Object
80499>
80499>                Object oFindMenuItem is a cCJFindMenuItem
80501>                    Set pbAddToDesignerMenu to True
80502>                    Set pbControlBeginGroup to True
80503>                End_Object
80504>
80504>                Object oFindNextMenu is a cCJFindNextMenuItem
80506>                    Set pbAddToDesignerMenu to True
80507>                End_Object
80508>
80508>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
80510>                    Set pbAddToDesignerMenu to True
80511>                End_Object
80512>
80512>                Object oFindFirstMenu is a cCJFindFirstMenuItem
80514>                    Set pbAddToDesignerMenu to True
80515>                End_Object
80516>
80516>                Object oFindLastMenu is a cCJFindLastMenuItem
80518>                    Set pbAddToDesignerMenu to True
80519>                End_Object
80520>
80520>                Object oSaveMenuItem is a cCJSaveMenuItem
80522>                    Set pbAddToDesignerMenu to True
80523>                    Set pbControlBeginGroup to True
80524>                End_Object
80525>
80525>                Object oDeleteMenuItem is a cCJDeleteMenuItem
80527>                    Set pbAddToDesignerMenu to True
80528>                End_Object
80529>
80529>                Object oExitMenu is a cCJExitMenuItem
80531>                    Set pbControlBeginGroup to True
80532>                End_Object
80533>
80533>            End_Object
80534>
80534>            Object oViewMenu is a cCJMenuItem
80536>                Set peControlType to xtpControlPopup
80537>                Set psCaption to "&View"
80538>                Set psToolTip to "View"
80539>                Set psDescription to "Available Views"
80540>
80540>                Object oSQLConnectionsMenuItem is a cCJMenuItem
80542>                    Set psCaption to "SQL Connections"
80543>                    Set psTooltip to "SQL Connections"
80544>
80544>                    Procedure OnExecute Variant vCommandBarControl
80547>                        Handle hoClient
80547>                        Get Client_Id to hoClient
80548>                        Send Activate_oSQLConnections_vw of hoClient
80549>                    End_Procedure
80550>                End_Object
80551>
80551>                Object oSQLFunctionsMenuItem is a cCJMenuItem
80553>                    Set psCaption to "SQL Functions"
80554>                    Set psTooltip to "SQL Functions"
80555>
80555>                    Procedure OnExecute Variant vCommandBarControl
80558>                        Handle hoClient
80558>                        Get Client_Id to hoClient
80559>                        Send Activate_oSQLFunctions_vw of hoClient
80560>                    End_Procedure
80561>                End_Object
80562>
80562>                Object oAPIFunctionsMenuItem is a cCJMenuItem
80564>                    Set psCaption to "API Functions Tests"
80565>                    Set psTooltip to "API Functions Tests"
80566>
80566>                    Procedure OnExecute Variant vCommandBarControl
80569>                        Handle hoClient
80569>                        Get Client_Id to hoClient
80570>                        Send Activate_oAPIFunctions_vw of hoClient
80571>                    End_Procedure
80572>                End_Object
80573>
80573>                Object oUtilFunctionsMenuItem is a cCJMenuItem
80575>                    Set psCaption to "Util Functions Tests"
80576>                    Set psTooltip to "Util Functions Tests"
80577>
80577>                    Procedure OnExecute Variant vCommandBarControl
80580>                        Handle hoClient
80580>                        Get Client_Id to hoClient
80581>                        Send Activate_oUtilFunctions_vw of hoClient
80582>                    End_Procedure
80583>                End_Object
80584>
80584>                // for testing we define the view and report menus for auto activate
80584>                Delegate Set phoViewMenu to Self
80586>            End_Object
80587>
80587>            Object oReportMenu is a cCJMenuItem
80589>                Set peControlType to xtpControlPopup
80590>                Set psCaption to "&Report"
80591>                Set psToolTip to "Report"
80592>                Set psDescription to "Available Reports"
80593>
80593>                // for testing we define the view and report menus for auto activate
80593>                Delegate Set phoReportMenu to Self
80595>            End_Object
80596>
80596>            Object oNavigateMenu is a cCJMenuItem
80598>                Set peControlType to xtpControlPopup
80599>                Set psCaption to "&Navigate"
80600>                Set psTooltip to "Navigate"
80601>                Set psDescription to "Move to different areas of the application"
80602>
80602>                Object oNextAreaMenu is a cCJNextAreaMenu
80604>                End_Object
80605>
80605>                Object oPriorAreaMenu is a cCJPriorAreaMenu
80607>                End_Object
80608>
80608>                Object oNextViewMenu is a cCJNextViewMenu
80610>                End_Object
80611>
80611>                Object oPriorViewMenu is a cCJPriorViewMenu
80613>                End_Object
80614>
80614>                Object oPromptMenu is a cCJPromptMenuItem
80616>                    Set pbControlBeginGroup to True
80617>                End_Object
80618>
80618>                Object oZoomMenu is a cCJZoomMenuItem
80620>                End_Object
80621>
80621>            End_Object
80622>
80622>            Object oWindowMenu is a cCJMDIWindowsMenuItem
80624>                Set peControlType to xtpControlPopup
80625>                Set psCaption to "&Window"
80626>                Set psToolTip to "Window"
80627>                Set psDescription to "Display Current Views and set other display options."
80628>
80628>                // These are the static windows items. More will be created in onPopupInit
80628>                Object oDisplayOptionsMenu is a cCJMenuItem
80630>                    Set peControlType to xtpControlPopup
80631>                    Set psCaption to "&Display Options"
80632>                    Set psToolTip to "Display Options"
80633>                    Set psDescription to "Set display options"
80634>
80634>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
80636>                    End_Object
80637>
80637>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
80639>                    End_Object
80640>
80640>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
80642>                        Set pbControlBeginGroup to True
80643>                    End_Object
80644>
80644>                End_Object
80645>
80645>                Object oCascadeMenu is a cCJCascadeMenuItem
80647>                    Set pbControlBeginGroup to True
80648>                End_Object
80649>
80649>                Object oHorizTile is a cCJTileHorizontally
80651>                End_Object
80652>
80652>                Object oVertTile is a cCJTileVertically
80654>                End_Object
80655>
80655>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
80657>                    Set pbControlBeginGroup to True
80658>                End_Object
80659>
80659>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
80661>                End_Object
80662>
80662>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
80664>                    Set pbControlBeginGroup to True
80665>                End_Object
80666>
80666>            End_Object
80667>
80667>            Object oHelpMenu is a cCJMenuItem
80669>                Set peControlType to xtpControlPopup
80670>                Set psCaption to "&Help"
80671>                Set psDescription to "Access Information for learning and using this DataFlex application."
80672>                Set psToolTip to "Help"
80673>
80673>                Object oHelpMenuItem is a cCJHelpMenuItem
80675>                End_Object
80676>
80676>                Object oAboutMenuItem is a cCJAboutMenuItem
80678>                End_Object
80679>
80679>            End_Object
80680>
80680>        End_Object
80681>
80681>        Object oFindToolBar is a cCJToolbar
80683>            Set psTitle to "Finding Toolbar"
80684>            Set peStretched to stStretchShared
80685>
80685>            Object oFindFirstTool is a cCJFindFirstMenuItem
80687>            End_Object
80688>
80688>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
80690>            End_Object
80691>
80691>            Object oFindMenuTool is a cCJFindMenuItem
80693>            End_Object
80694>
80694>            Object oFindNextTool is a cCJFindNextMenuItem
80696>            End_Object
80697>
80697>            Object oFindLastTool is a cCJFindLastMenuItem
80699>            End_Object
80700>
80700>            Object oPromptToolItem is a cCJPromptMenuItem
80702>                Set pbControlBeginGroup to True
80703>            End_Object
80704>
80704>            Object oMenuItem1 is a cCJMenuItem
80706>                Set psImage to "All.ico"
80707>            End_Object
80708>
80708>        End_Object
80709>
80709>        Object oFileToolBar is a cCJToolbar
80711>            Set psTitle to "Data Entry Toolbar"
80712>
80712>            Object oClearToolItem is a cCJClearMenuItem
80714>                Set peControlStyle to xtpButtonIconAndCaption
80715>            End_Object
80716>
80716>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
80718>                Set peControlStyle to xtpButtonIconAndCaption
80719>            End_Object
80720>
80720>            Object oSaveToolItem is a cCJSaveMenuItem
80722>                Set peControlStyle to xtpButtonIconAndCaption
80723>                Set pbControlBeginGroup to True
80724>            End_Object
80725>
80725>            Object oDeleteToolItem is a cCJDeleteMenuItem
80727>                Set peControlStyle to xtpButtonIconAndCaption
80728>            End_Object
80729>
80729>        End_Object
80730>
80730>        Object oEditToolBar is a cCJToolbar
80732>            Set psTitle to "Edit Toolbar"
80733>
80733>            Object oCutToolbarItem is a cCJCutMenuItem
80735>            End_Object
80736>
80736>            Object oCopyToolbarItem is a cCJCopyMenuItem
80738>            End_Object
80739>
80739>            Object oPasteToolbarItem is a cCJPasteMenuItem
80741>            End_Object
80742>
80742>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
80744>                Set pbControlBeginGroup to True
80745>            End_Object
80746>
80746>        End_Object
80747>
80747>        Object oStatusBar is a cCJStatusBar
80749>
80749>            Object oStatusPane1 is a cCJStatusBarPane
80751>                Set piID to sbpIDIdlePane
80752>                Set pbStyleStretch to True
80753>            End_Object
80754>
80754>            Object oStatusPane2 is a cCJStatusBarPane
80756>                Set phoViewPane to Self
80757>                Set pbStyleStretch to True
80758>            End_Object
80759>
80759>        End_Object
80760>
80760>        Object oCJSkinSelector_Toolbar is a cCJToolbar
80762>            Set peStretched to stStretchShared
80763>            Object oSkinSelector_cf is a cSkinComboBoxCJMenuItem  
80765>                Set psToolTip to "Select a skin to change the appearance of the application."
80766>            End_Object
80767>
80767>            Object oThemeItem is a cCJMenuItem
80769>                Set peControlType to xtpControlComboBox
80770>                Set psToolTip to "Select a theme to change the appearance of menu- and toolbars."
80771>                
80771>                Procedure OnCreateControl Handle hoObj
80774>                    Variant vVar
80774>                    Integer iItem eTheme
80774>                    Set ComWidth of hoObj to 250
80775>                    Send FillComboList hoObj
80776>                    Get peVisualTheme to eTheme
80777>                    Get FindDataItem hoObj eTheme to iItem
80778>                    Set ComListIndex of hoObj to (If(iItem,iItem,1))
80779>                End_Procedure
80780>                
80780>                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
80783>                    Integer iCount i eTheme
80783>                    Get ComListCount of hoCombo to iCount
80784>                    For i from 1 to iCount
80790>                        Get ComItemData of hoCombo i to eTheme
80791>                        If (eTheme=eVal) Begin
80793>                            Function_Return i
80794>                        End
80794>                    Loop
80795>                    Function_Return 0
80796>                End_Function
80797>                
80797>                Procedure AddTheme Handle hoCombo String sText Integer eTheme
80800>                    Integer iCount
80800>                    Get ComListCount of hoCombo to iCount
80801>                    Increment iCount
80802>                    Send ComAddItem  of hoCombo sText iCount
80803>                    Set ComItemData  of hoCombo iCount to  eTheme
80804>                End_Procedure
80805>
80805>                Procedure FillComboList Handle hoCombo
80808>                    Send ComClear     of hoCombo
80809>
80809>                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word  
80810>                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook  
80811>                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel 
80812>                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint  
80813>                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher  
80814>                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote  
80815>                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
80816>                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
80817>                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
80818>                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
80819>
80819>                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue  
80820>                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black  
80821>                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver  
80822>
80822>                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua 
80823>                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black 
80824>                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue 
80825>                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver 
80826>
80826>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
80827>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
80828>                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
80829>
80829>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
80830>                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
80831>
80831>                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
80832>                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
80833>
80833>                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
80834>                    
80834>                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
80835>
80835>                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
80836>                End_Procedure 
80837>                
80837>                Function CurrentTheme Handle vCommandBarControl Returns Integer
80840>                    Handle hMessage hoClient hoCombo
80840>                    Integer iIndex
80840>                    // create and bind  proxy control
80840>                    Get CreateProxyControl vCommandBarControl to hoCombo
80841>                    // get the current selection
80841>                    Get ComListIndex of hoCombo to iIndex
80842>                    // note the index selections are 1 based
80842>                    If (iIndex > 0) Begin
80844>                        // get the ItemData for the selected item and send that message
80844>                        Get ComItemData of hoCombo iIndex to hMessage
80845>                        Function_Return hMessage
80846>                    End
80846>                    // dispose of the proxy control
80846>                    Send Destroy of hoCombo
80847>                End_Function
80848>    
80848>                Procedure OnExecute Variant vCommandBarControl
80851>                    Integer eTheme
80851>                    Integer iColor
80851>                    Get CurrentTheme vCommandBarControl to eTheme
80852>                    Set peVisualTheme of ghoCommandBars to eTheme
80853>                    Send ComRecalcLayout of ghoCommandBars 
80854>                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor 
80855>                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
80857>//                    Showln "background color = " iColor
80857>                End_Procedure
80858>                
80858>                Procedure SetTheTheme Integer eTheme
80861>                    Set peVisualTheme of ghoCommandBars to eTheme
80862>                    Send ComRecalcLayout of ghoCommandBars 
80863>                End_Procedure
80864>            
80864>                Function ConvertSystemColor Integer iColor Returns Integer
80867>                    Integer iSysColor
80867>                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
80869>                        Move clNone to iColor
80870>                    End
80870>                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
80873>                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
80874>                        Move (GetSysColor(iSysColor)) to iColor
80875>                    End
80875>                    Function_Return iColor
80876>                End_Function
80877>
80877>            End_Object
80878>            
80878>            Object oAbout_MenuItem is a cCJMenuItem
80880>                Set psCaption to "About"
80881>                Set psToolTip to "About Info"
80882>                Set psDescription to "About the program"
80883>                Set psImage to "ActionAbout.ico"
80884>                Set pbControlBeginGroup to True
80885>                Procedure OnExecute Variant vCommandBarControl
80888>                    Forward Send OnExecute vCommandBarControl
80890>                    Send Activate_About of (Client_Id(ghoCommandBars))
80891>                End_Procedure
80892>            End_Object
80893>
80893>            Object oHelpMenuItem is a cCJHelpMenuItem
80895>                Set peControlType to xtpControlSplitButtonPopup
80896>
80896>                Procedure OnExecute Variant vCommandBarControl
80899>                    Forward Send OnExecute vCommandBarControl
80901>                    Set psHelpFile of ghoApplication to "DataFlex.chm"
80902>                    Send ShowProgramHelp
80903>                End_Procedure
80904>
80904>                Object oHelpMenuItemLocal is a cCJMenuItem
80906>                    Set psCaption to "Local HTML Help"
80907>                    Set psImage to "ActionHelp.ico"
80908>                    Procedure OnExecute Variant vCommandBarControl
80911>                        Set psHelpFile of ghoApplication to "DataFlex.chm"
80912>                        Send ShowProgramHelp
80913>                    End_Procedure
80914>                End_Object
80915>
80915>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
80917>                    Set psCaption to "Internet Online HTML Help"
80918>                    Set psImage to "ActionHelp.ico"
80919>                    Procedure OnExecute Variant vCommandBarControl
80922>                        Send vShellExecute "open" "http://www.rdctools.com/HTMLHelp/Developer5.htm" "" ""
80923>                    End_Procedure
80924>
80924>                End_Object
80925>            End_Object
80926>
80926>            Object oExitMenuItem is a cCJExitMenuItem
80928>                Set psImage to "ActionExitApp.ico"
80929>                Set psToolTip to "Exit application"
80930>                Set psDescription to "Exit the program (Alt+F4)"
80931>                Set pbControlBeginGroup to True
80932>            End_Object
80933>
80933>        End_Object
80934>
80934>    End_Object
80935>
80935>    Object oClientArea is a ClientArea
80937>
80937>        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
Including file: Dd_debug.dg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dd_debug.dg)
80937>>>// dd_debug.dg - DDO debugger/inspector
80937>>>//
80937>>>// Copyright Data Access WorldWide 2003
80937>>>// John Tuohy
80937>>>//
80937>>>// By adding this to any Windows view or application (with a "use DD_Debug.dg") you can
80937>>>// inspect your DDOs and make sure they are doing what you think. To invoke this panel you
80937>>>// need to press ctrl/d (or send DebugDDs).
80937>>>//
80937>>>// As of 9.1, this also tests for sending reentrant messages to the DDO when the DDO is busy.
80937>>>// Normally, these messages are ignored - now you get an error message (so you can fix it).
80937>>>// Also, you can set a limit for number of filtered records so you can see if you are using
80937>>>// optimized and non-optimized indexes the way you think you are.
80937>>>//
80937>>>// NOTE: This package should NEVER appear in a deployed application. It is just for your
80937>>>//       own development and testing.
80937>>>
80937>>>
80937>>>
80937>>>Validate_Packages 18 0 1
80937>>>
80937>>>Define CR_LF for (Character(13)+Character(10))
80937>>>
80937>>>// This provides support for DDO Rentancy checking and for testing for
80937>>>// non-optimal finding.
80937>>>Use DD_OperationChecker.pkg
Including file: dd_OperationChecker.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\dd_OperationChecker.pkg)
80937>>>>>// dd_OperationChecker.pkg for VDF10.0
80937>>>>>//
80937>>>>>// Copyright Data Access WorldWide 2003
80937>>>>>// John Tuohy
80937>>>>>//
80937>>>>>//
80937>>>>>// One of the harder DDO errors to see is the issue of reentrancy. A number of the DDO operations are not
80937>>>>>// reentrant. When a message such as Request_Save, Request_find or Clear is sent to a DDO all DDOs are considered
80937>>>>>// to be "busy" until the operationis complete. While DDOs are busy you can not send messages to ANY other DDO in
80937>>>>>// ANY other part of your application. The file structure of DDOs and the the C structure of DDOs do not allow this.
80937>>>>>// If you do send a reentrant message while the DDOs are busy the reentrant message is ignored. Here lies the problem.
80937>>>>>// You are trying to perform some kind of DDO customization and some of these customized behaviors are ignored without
80937>>>>>// any kind of warning or error.
80937>>>>>//
80937>>>>>// The following DDO messages are non re-entrant. While any of these methods are being processed you cannot send any of these
80937>>>>>// messages to any DDOs.
80937>>>>>//
80937>>>>>//     Clear
80937>>>>>//     Clear_All
80937>>>>>//     Request_save
80937>>>>>//     Request_delete
80937>>>>>//     Request_assign
80937>>>>>//     Request_find
80937>>>>>//     Request_Superfind
80937>>>>>//     Find_by_recnum
80937>>>>>//
80937>>>>>//
80937>>>>>// This package provides diagnostic code that checks these messages and makes sure that are not trying to call them in a busy state.
80937>>>>>// Instead of the busy operation being ignored, an error will be reported. Once you see the error, you can fix it.
80937>>>>>//
80937>>>>>// In addition, there is a check built in here for non-optimal finding operations. You can set the value of giNonOptimalFindCount
80937>>>>>// to a non zero value and when a find operation filters that many recods, you will get an error.
80937>>>>>//
80937>>>>>// IMPORTANT: This is a debug package and should never be used in deployed applications. It should be used by the developer
80937>>>>>// to test their application. Once tested, the code should be removed.
80937>>>>>//
80937>>>>>// To Use
80937>>>>>// ------
80937>>>>>//
80937>>>>>// This is used as part of DD_Debug.dg. While this could be used stand-alone you really don't want to do this.
80937>>>>>//
80937>>>>>// NOTE: This can only be used with VDF9.1 or above. If you try to use this with older packages this will not compile!
80937>>>>>
80937>>>>>Validate_Packages 9 1 0
80937>>>>>Use Data_set.pkg
80937>>>>>
80937>>>>>// This variable determines of the rentrancy tests should be performed. dd_debug will use and set this
80937>>>>>Global_variable Integer gbTestRentrancy
80937>>>>>Move 1 to gbTestRentrancy
80938>>>>>
80938>>>>>// This determines how many failed finds is considered to be non-optimal. When 0, there is no check.
80938>>>>>Global_variable Integer giNonOptimalFindCount
80938>>>>>Move 0 to giNonOptimalFindCount
80939>>>>>
80939>>>>>Procedure CheckRentrancy for DataSet handle hoDD string sMessage
80941>>>>>    String sMess sVal
80941>>>>>    
80941>>>>>    If (gbTestRentrancy=0 or operation_mode=mode_waiting) Procedure_Return
80944>>>>>    
80944>>>>>    If (OPERATION_MODE=MODE_VALIDATING and Lowercase(sMessage)<>"request_save") Begin
80946>>>>>        // mode_validating is not really a non-reentrant DD function from the runtime's point of view. The DDs
80946>>>>>        // keep track of this mode. Therefore, we will let a re-entrant DD message pass through for all cases, except
80946>>>>>        // request_save because trying to perform a save while inside of a validate is most likely wrong.
80946>>>>>        Procedure_Return
80947>>>>>    End
80947>>>>>>
80947>>>>>    
80947>>>>>    Move ("DDO re-entrant operation attempted.\n\n"+;          "Message = " - sMessage - ".  Object =" - name(hoDD) -".\n"+ ;          "\nCurrent Operation_mode is " + string(operation_mode) +;          "\nCurrent Operation_origin is " + string(operation_origin) * name(operation_origin) ) to sMess
80948>>>>>    Error DFERR_PROGRAM sMess
80949>>>>>>
80949>>>>>end_procedure
80950>>>>>
80950>>>>>Procedure NonOptimalTest for DataSet  Handle hoDD string sMessage integer iOldDif integer iFile integer iIndex
80952>>>>>    string sMess
80952>>>>>    Integer iNewDif
80952>>>>>
80952>>>>>    Move (constrain_tests_count - Constrain_found_count) to iNewDif
80953>>>>>    If (iNewDif-iOldDif>giNonOptimalFindCount) Begin
80955>>>>>        Move ("Constrained Find may not be Optimized.\n\n"+;              "Message =" - sMessage - ".  Object = " - name(hoDD) -".\n"+ ;              "Test finds exceeds the limit of" * string(giNonOptimalFindCount) * "filtered records.\n" +;              "Number of records searched = " + string(iNewDif-iOldDif) + ".") to sMess
80956>>>>>        If (iFile>0) Begin
80958>>>>>            // if iFile is zero we don't don't which file is being found (i.e. Locate_next)
80958>>>>>            Move (sMess + "\nFile = " + string(iFile) + ". Index = "+ string(iIndex) + ".") to sMess
80959>>>>>        End
80959>>>>>>
80959>>>>>        Error DFERR_PROGRAM sMess
80960>>>>>>
80960>>>>>    end
80960>>>>>>
80960>>>>>end_procedure
80961>>>>>
80961>>>>>
80961>>>>>Procedure Clear for DataSet
80963>>>>>    Send CheckRentrancy self "clear"
80964>>>>>    forward send clear
80966>>>>>end_procedure
80967>>>>>
80967>>>>>Procedure Clear_All for DataSet
80969>>>>>    Send CheckRentrancy self "clear_all"
80970>>>>>    forward send clear_all
80972>>>>>end_procedure
80973>>>>>
80973>>>>>Procedure Request_Save for DataSet
80975>>>>>    Send CheckRentrancy self "request_save"
80976>>>>>    forward send request_save
80978>>>>>end_procedure
80979>>>>>
80979>>>>>Procedure Request_Delete for DataSet
80981>>>>>    Send CheckRentrancy self "request_delete"
80982>>>>>    forward send request_delete
80984>>>>>end_procedure
80985>>>>>
80985>>>>>Procedure Request_Assign for DataSet integer iFile
80987>>>>>    Send CheckRentrancy self "request_assign"
80988>>>>>    If (num_arguments=0) ;        forward send request_assign
80992>>>>>    else ;        forward send request_assign iFile
80995>>>>>end_procedure
80996>>>>>
80996>>>>>Procedure Find_By_Recnum for DataSet integer iFile integer iRecord
80998>>>>>    Send CheckRentrancy self "Find_by_recnum"
80999>>>>>    forward send Find_by_recnum iFile iRecord
81001>>>>>end_procedure
81002>>>>>
81002>>>>>Procedure Request_Find for DataSet integer iMode integer iFile integer iIndex
81004>>>>>    Integer iOldDif
81004>>>>>    Send CheckRentrancy self "request_find"
81005>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
81006>>>>>    forward send request_find iMode iFile iIndex
81008>>>>>    If (giNonOptimalFindCount>0) Begin
81010>>>>>        Send NonOptimalTest self "request_find" iOldDif iFile iIndex
81011>>>>>    End
81011>>>>>>
81011>>>>>end_procedure
81012>>>>>
81012>>>>>Procedure Request_Read for DataSet integer iMode integer iFile integer iIndex
81014>>>>>    Integer iOldDif
81014>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
81015>>>>>    forward send request_Read iMode iFile iIndex
81017>>>>>    If (giNonOptimalFindCount>0) Begin
81019>>>>>        Send NonOptimalTest  self "request_read" iOldDif iFile iIndex
81020>>>>>    End
81020>>>>>>
81020>>>>>end_procedure
81021>>>>>
81021>>>>>
81021>>>>>Procedure Request_Superfind for DataSet integer iMode integer iFile integer iField
81023>>>>>    Integer iOldDif
81023>>>>>    Send CheckRentrancy self "request_Superfind"
81024>>>>>    Move (constrain_tests_count - Constrain_found_count) to iOldDif
81025>>>>>    forward send Request_Superfind iMode iFile iField
81027>>>>>    If (giNonOptimalFindCount>0) Begin
81029>>>>>        Send NonOptimalTest  self "request_Superfind" iOldDif 0 0 // we don't have a file or an index
81030>>>>>    End
81030>>>>>>
81030>>>>>end_procedure
81031>>>>>
81031>>>
81031>>>Procedure EnumerateDDs for DataDictionary integer iMsg integer hId
81033>>>    Send iMsg of hID Self
81034>>>End_Procedure
81035>>>
81035>>>
81035>>>
81035>>>Use Windows.pkg
81035>>>Use dfCmbFrm.pkg
Including file: Dfcmbfrm.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfcmbfrm.pkg)
81035>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
81035>>>Use dfTabDg.pkg
Including file: Dftabdg.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dftabdg.pkg)
81035>>>>>Use windows.pkg // this now lives here. (you don't need to ever use this). 
81035>>>Use DataDict.pkg
81035>>>Use cTextEdit.pkg
81035>>>
81035>>>Class cDDDebugResults is a cTextEdit
81036>>>    Procedure Construct_Object
81038>>>        Forward Send Construct_Object
81040>>>        
81040>>>        Set peAnchors to anAll
81041>>>        Set pbWrap to False
81042>>>        Set Read_Only_State to True
81043>>>        Set psTypeface to "Courier New"
81044>>>        Set FontPointHeight to 9
81045>>>        
81045>>>        Property String psEditValue ''
81046>>>    End_Procedure
81047>>>    
81047>>>    Procedure Delete_Data
81049>>>        Forward Send Delete_Data
81051>>>        
81051>>>        Set psEditValue to ''
81052>>>    End_Procedure
81053>>>    
81053>>>    Procedure Page Integer iPageObject
81055>>>        String sEditValue
81055>>>        
81055>>>        Forward Send Page iPageObject
81057>>>        If (iPageObject > 0) Begin
81059>>>            Get psEditValue to sEditValue
81060>>>            Set Value to sEditValue
81061>>>        End
81061>>>>
81061>>>    End_Procedure
81062>>>
81062>>>    Procedure Insert String sVal
81064>>>        Handle hWnd
81064>>>        String sEditValue
81064>>>        
81064>>>        Get Window_Handle to hWnd
81065>>>        If (hWnd <> 0) Begin
81067>>>            Send AppendText sVal
81068>>>        End
81068>>>>
81068>>>        Else Begin
81069>>>            Get psEditValue to sEditValue
81070>>>            Move (sEditValue + sVal) to sEditValue
81071>>>            Set psEditValue to sEditValue
81072>>>        End
81072>>>>
81072>>>    End_Procedure
81073>>>End_Class
81074>>>
81074>>>Object oDD_Debug is a ModalPanel
81076>>>
81076>>>    Property handle phoInvokingView    0
81078>>>    Property handle phoCurrentDD       0
81080>>>    Property handle phoFieldsEditId    0
81082>>>    Property Handle phoMiscEditId      0
81084>>>    Property Handle phoConstraintsEditId      0
81086>>>
81086>>>    Set Locate_mode to Center_on_screen
81087>>>    Set Border_Style to Border_Thick
81088>>>
81088>>>    On_key kCancel Send Close_Panel
81089>>>
81089>>>    Function IsRecnumTable integer iFile Returns boolean
81092>>>        Boolean bRecnumTable
81092>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFIle to bRecnumTable
81095>>>        Function_Return bRecnumTable
81096>>>    End_Function
81097>>>
81097>>>
81097>>>
81097>>>
81097>>>    Set Minimize_Icon to FALSE
81098>>>    Set Label to "Data Dictionary Inspector"
81099>>>    Set Location to 4 3
81100>>>    Set Size to 263 410
81101>>>
81101>>>
81101>>>
81101>>>
81101>>>    Object oDDCombo is a ComboForm
81103>>>
81103>>>        Set Label to "DD:"
81104>>>        Set Size to 13 103
81105>>>        Set Location to 6 19
81106>>>        Set Form_Border to 0
81107>>>        Set Label_Col_Offset to 2
81108>>>        Set Label_Justification_Mode to jMode_Right
81109>>>
81109>>>        set entry_state 0 to False
81110>>>        set combo_sort_state to false
81111>>>        Set peAnchors to anNone
81112>>>
81112>>>        Procedure AddDDs integer hDD
81115>>>            Integer iCnt
81115>>>            String sName
81115>>>            Get Combo_Item_Count to iCnt
81116>>>            Get Object_label of hDD to sName
81117>>>            Send Combo_Add_Item sName
81118>>>            Set Aux_Value of (combo_data_object(self)) iCnt to hDD
81119>>>            If (hDD=phoCurrentDD(self)) Set Value 0 to sName
81122>>>        End_procedure
81123>>>
81123>>>        Procedure Fill_List
81126>>>            Integer hVw
81126>>>            Get phoInvokingView to hVw
81127>>>            Send Combo_Delete_Data
81128>>>            Broadcast Send EnumerateDDs to hVw msg_AddDDs Self
81130>>>            //Set Value 0 to (Combo_value(self,0))
81130>>>            Send onChange
81131>>>        End_Procedure
81132>>>
81132>>>
81132>>>        Procedure onChange
81135>>>            Integer iItem hDD
81135>>>            Get combo_item_matching (value(self,0)) to iItem
81136>>>            if (iItem>=0) begin
81138>>>               Get Aux_Value of (combo_data_object(self)) iItem to hDD
81139>>>               Delegate Set phoCurrentDD to hDD
81141>>>               Delegate Send RefreshNewDD
81143>>>            end
81143>>>>
81143>>>        End_procedure
81144>>>
81144>>>    End_Object    // oDDCombo
81145>>>
81145>>>    Object oCurRec is a Form
81147>>>
81147>>>        Set Label to "Current Rec"
81148>>>        Set Size to 13 37
81149>>>        Set Location to 6 165
81150>>>        Set Label_Col_Offset to 2
81151>>>        Set Label_Justification_Mode to jMode_Right
81152>>>
81152>>>        Set numeric_mask 0 to 8 0
81153>>>        Set peAnchors to anNone
81154>>>
81154>>>        Procedure NewRec // note that this is never used.
81157>>>            Integer iRec iFile hDD
81157>>>            Get phoCurrentDD to hDD
81158>>>            if hDD Begin
81160>>>               get value 0 to iRec
81161>>>               Get Main_file of hDD to iFile
81162>>>               Set_Field_Value iFile 0 to iRec  // compatibility w/ recnum
81165>>>               send Find of hDD EQ 0
81166>>>               Send refreshAll
81167>>>            end
81167>>>>
81167>>>        End_procedure
81168>>>
81168>>>    End_Object    // oCurRec
81169>>>
81169>>>    Object oFindCurRec is a Button
81171>>>
81171>>>        Set Label to "Find"
81172>>>        Set Size to 13 20
81173>>>        Set Location to 6 205
81174>>>        Set peAnchors to anNone
81175>>>
81175>>>        Procedure OnClick
81178>>>            Integer iRec iFile hDD
81178>>>            Get phoCurrentDD to hDD
81179>>>            if hDD Begin
81181>>>               Get Main_file of hDD to iFile
81182>>>               If (IsRecnumTable(self,iFile)) begin
81184>>>                  Get value of oCurRec 0 to iRec
81185>>>                  Set_Field_Value iFile 0 to iRec // compatibility w/ recnum
81188>>>                  send Find of hDD EQ 0
81189>>>                  Send refreshAll
81190>>>               End
81190>>>>
81190>>>            end
81190>>>>
81190>>>        End_procedure
81191>>>
81191>>>    End_Object    // oFindCurRec
81192>>>
81192>>>    Object oDDRelatesTo is a ComboForm
81194>>>
81194>>>
81194>>>        Set Label to "Related To File:"
81195>>>        Set Size to 13 117
81196>>>        Set Location to 6 281
81197>>>        Set Form_Border to 0
81198>>>        Set Label_Col_Offset to 2
81199>>>        Set Label_Justification_Mode to jMode_Right
81200>>>
81200>>>        set entry_state 0 to False
81201>>>        set combo_sort_state to false
81202>>>        Set peAnchors to anNone
81203>>>
81203>>>        Procedure Fill_List
81206>>>            Integer hDD iCnt iLmt iFile hCDO iCFile
81206>>>            String sName
81206>>>            Send Combo_Delete_Data
81207>>>            Get phoCurrentDD to hDD
81208>>>            If hDD eq 0 Procedure_Return
81211>>>            Get Constrain_file of hDD to iCFile
81212>>>            Get Combo_data_object to hCDO
81213>>>            Move (server_file_count(hDD)-1) to iLmt
81214>>>            Send Combo_add_item "None"
81215>>>            Set Aux_Value of hCDO 0 to iFile
81216>>>            If iCFile eq 0 set Value 0 to "None"
81219>>>            For iCnt from 0 to iLmt
81225>>>>
81225>>>                Get Server_File of hDD iCnt to iFile
81226>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sName
81229>>>                Send Combo_add_item sName
81230>>>                Set Aux_Value of hCDO (iCnt+1) to iFile
81231>>>                If iFile eq iCFile set Value 0 to sName
81234>>>            Loop
81235>>>>
81235>>>
81235>>>        End_Procedure
81236>>>
81236>>>
81236>>>        Procedure onChange
81239>>>            Integer iItem iFile hDD
81239>>>            Get phoCurrentDD to hDD
81240>>>            If (hDD=0) Procedure_Return
81243>>>            Get combo_item_matching (value(self,0)) to iItem
81244>>>            if (iItem>=0) begin
81246>>>               Get Aux_Value of (combo_data_object(self)) iItem to iFile
81247>>>               Set constrain_file of hDD to iFile
81248>>>               Send RebuildAllConstraints of hDD 
81249>>>//               Send rebuild_constraints of hDD
81249>>>               Delegate Send RefreshAll
81251>>>            end
81251>>>>
81251>>>        End_procedure
81252>>>
81252>>>    End_Object    // oDDRelatesTo
81253>>>
81253>>>    Object oShouldSave is a CheckBox
81255>>>
81255>>>        set enabled_state to False
81256>>>
81256>>>
81256>>>        Set Label to "Should Save"
81257>>>        Set Size to 10 55
81258>>>        Set Location to 22 5
81259>>>        Set peAnchors to anNone
81260>>>
81260>>>
81260>>>
81260>>>    End_Object    // oShouldSave
81261>>>
81261>>>    Object oChangedState is a CheckBox
81263>>>
81263>>>        set enabled_state to False
81264>>>
81264>>>
81264>>>        Set Label to "Changed State"
81265>>>        Set Size to 10 60
81266>>>        Set Location to 22 64
81267>>>        Set peAnchors to anNone
81268>>>
81268>>>
81268>>>
81268>>>    End_Object    // oChangedState
81269>>>
81269>>>    Object oAutoFill is a CheckBox
81271>>>        Set Label to "Auto-Fill"
81272>>>        Set Size to 10 41
81273>>>        Set Location to 22 128
81274>>>        Set peAnchors to anNone
81275>>>
81275>>>        Procedure Select_Toggling integer iItm integer bState
81278>>>            forward send select_toggling iItm bState
81280>>>            Set auto_fill_state of (phoCurrentDD(self)) to (checked_state(self))
81281>>>        End_Procedure
81282>>>
81282>>>    End_Object    // oAutoFill
81283>>>
81283>>>    Object oFillFromTop is a CheckBox
81285>>>        Set Label to "First-Rec Auto-fill"
81286>>>        Set Size to 10 71
81287>>>        Set Location to 22 172
81288>>>        Set peAnchors to anNone
81289>>>
81289>>>        Procedure Select_Toggling integer iItm integer bState
81292>>>            forward send select_toggling iItm bState
81294>>>            Set pbAutoFillFromFirst of (phoCurrentDD(self)) to (checked_state(self))
81295>>>        End_Procedure
81296>>>
81296>>>    End_Object    // oFillFromTop
81297>>>
81297>>>    Object oDDOrdering is a ComboForm
81299>>>        Set Label to "Ordering"
81300>>>        Set Size to 13 117
81301>>>        Set Location to 20 281
81302>>>        Set Form_Border to 0
81303>>>        Set Label_Col_Offset to 2
81304>>>        Set Label_Justification_Mode to jMode_Right
81305>>>
81305>>>        Set entry_state 0 to False
81306>>>        Set combo_sort_state to false
81307>>>        Set peAnchors to anNone
81308>>>
81308>>>        Procedure RefreshNewDD
81311>>>            Integer hDD iFile iSegs iNdxs i
81311>>>            Send Combo_Delete_Data
81312>>>            Get phoCurrentDD to hDD
81313>>>            If hDD Begin
81315>>>               Send Combo_Add_Item "Best.-1"
81316>>>               Send Combo_Add_Item "Index.0"
81317>>>               Get Main_file of hDD to iFile
81318>>>               Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iNdxs
81321>>>               For i from 1 to iNdxs
81327>>>>
81327>>>                  Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile i to iSegs
81330>>>                  If iSegs Send Combo_Add_Item ("Index."-string(i))
81333>>>               Loop
81334>>>>
81334>>>            End
81334>>>>
81334>>>        End_procedure
81335>>>
81335>>>        Procedure Set Ordering integer iOrdr
81338>>>           If iOrdr eq -1 Set Value 0 to "Best.-1"
81341>>>           else Set Value 0 to ("Index."-string(iOrdr))
81343>>>        end_procedure
81344>>>
81344>>>        Procedure OnChange
81347>>>            Integer hDD
81347>>>            String sVal
81347>>>            Get value 0 to sVal
81348>>>            get phoCurrentDD to hDD
81349>>>            If hDD set Ordering of hDD to (mid(sVal, 10, pos(".",sVal)+1))
81352>>>        End_procedure
81353>>>
81353>>>    End_Object    // oDDOrdering
81354>>>
81354>>>
81354>>>    Object oTD is a TabDialog
81356>>>        Set Size to 149 389
81357>>>        Set Location to 33 11
81358>>>        Set Rotate_Mode to RM_Rotate
81359>>>        Set peAnchors to anAll
81360>>>
81360>>>        Object oTP_Constraints is a TabPage
81362>>>            Set Label to "Constraints"
81363>>>            Set Tab_ToolTip_Value to "DD Constraints and Filters"
81364>>>            Delegate Set phoConstraintsEditId to Self
81366>>>            
81366>>>            Object oConstraintsEdit is a cDDDebugResults
81368>>>                Function FormatFileFieldName Integer iFile Integer iField Returns String
81371>>>                    String sFile sField sRet
81371>>>                    Boolean bOpen
81371>>>                    Get_Attribute DF_FILE_OPENED of iFile to bOpen
81374>>>                    If (bOpen) Begin
81376>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sFile
81379>>>                        Get_Attribute DF_FIELD_NAME of iFile iField to sField
81382>>>                        Function_Return (sFile+"."+sField)    
81383>>>                    End
81383>>>>
81383>>>                    Else Begin
81384>>>                        Function_Return "file not open"
81385>>>                    End
81385>>>>
81385>>>                End_Function
81386>>>
81386>>>                 Procedure ShowDDOConstraints Handle hoDD
81389>>>                    Integer i j iMain iCurrentDDFile
81389>>>                    tConstraintDef[] Constraints
81389>>>                    tConstraintDef[] Constraints
81390>>>                    String sFilter 
81390>>>                    Handle hoDDOther
81390>>>                    
81390>>>                    Get Main_File of hoDD to iMain
81391>>>                    Get DDOConstraints of  hoDD to Constraints
81392>>>                    
81392>>>                    Send Insert "Current DDO Constraints"
81393>>>                    Send Insert CR_LF
81394>>>                    Send Insert ("  Number of Constraints = " + String(SizeOfArray(Constraints)))
81395>>>                    Send Insert CR_LF
81396>>>
81396>>>                    For i from 0 to (SizeOfArray(Constraints)-1)
81402>>>>
81402>>>                        If (iCurrentDDFile<>Constraints[i].iFile) Begin
81404>>>                            Send Insert CR_LF
81405>>>                            Move Constraints[i].iFile to iCurrentDDFile
81406>>>                            If (Constraints[i].iFile<>iMain) Begin
81408>>>                                Get Which_Data_Set of hoDD Constraints[i].iFile to hoDDOther
81409>>>                            End
81409>>>>
81409>>>                            Else Begin
81410>>>                                Move hoDD to hoDDOther
81411>>>                            End
81411>>>>
81411>>>                            Send Insert  ("Constraints from ")
81412>>>                            
81412>>>                            If (hoDDOther) Begin
81414>>>                                Send Insert  (Object_Label(hoDDOther))
81415>>>                            End
81415>>>>
81415>>>                            Else Begin
81416>>>                                // not sure this could ever happen
81416>>>                                Send Insert  ("unknown. No DDO for file "+String(Constraints[i].iFile))
81417>>>                            End
81417>>>>
81417>>>                            
81417>>>                            If (hoDD<>hoDDOther) Begin
81419>>>                                Send Insert " (inherited)"
81420>>>                            End
81420>>>>
81420>>>                            
81420>>>                            Send Insert CR_LF
81421>>>                        End
81421>>>>
81421>>>                        
81421>>>                        
81421>>>                        Send Insert ("  " +String(i+1) + " Type=")
81422>>>                        Case Begin
81422>>>                            Case (Constraints[i].eType=CONST_VALUE) Send Insert "CONST_VALUE"
81425>>>                            Case (Constraints[i].eType=CONST_CHILD) Send Insert "CONST_CHILD"
81429>>>                            Case (Constraints[i].eType=CONST_FIELD) Send Insert "CONST_FIELD"
81433>>>                            Case (Constraints[i].eType=CONST_EXP) Send Insert "CONST_EXP"
81437>>>                            Case (Constraints[i].eType=CONST_RELATES) Send Insert "CONST_RELATES"
81441>>>                        Case End
81441>>>                        
81441>>>                        If (Constraints[i].eType=CONST_VALUE or Constraints[i].eType=CONST_FIELD) Begin
81443>>>                            Send Insert " mode="
81444>>>                            Case Begin
81444>>>                                Case (Constraints[i].eMODE=CONST_LT) Send Insert "LT"
81447>>>                                Case (Constraints[i].eMODE=CONST_LE) Send Insert "LE"
81451>>>                                Case (Constraints[i].eMODE=CONST_EQ) Send Insert "EQ"
81455>>>                                Case (Constraints[i].eMODE=CONST_GE) Send Insert "GE"
81459>>>                                Case (Constraints[i].eMODE=CONST_GT) Send Insert "GT"
81463>>>                                Case (Constraints[i].eMODE=CONST_NE) Send Insert "NE"
81467>>>                                Case (Constraints[i].eMODE=CONST_Matches) Send Insert "matches"
81471>>>                                Case (Constraints[i].eMODE=CONST_Contains) Send Insert "contains"
81475>>>                                Case (Constraints[i].eMODE=CONST_MatchesJumpIn) Send Insert "matches_JumpIn"
81479>>>                            Case End
81479>>>                        End
81479>>>>
81479>>>                        If (Constraints[i].eType<>CONST_EXP) Begin
81481>>>                            Send Insert (" File.Field=" + String(Constraints[i].iFile))
81482>>>                            Send Insert ("."  + String(Constraints[i].iField))
81483>>>                            Send Insert (" (" + FormatFileFieldName(Self,Constraints[i].iFile,Constraints[i].iField)+")")
81484>>>                        End
81484>>>>
81484>>>                        If (Constraints[i].eType=CONST_CHILD or Constraints[i].eType=CONST_FIELD) Begin
81486>>>                            Send Insert (" Other File.Field="  + String(Constraints[i].iOtherFile))
81487>>>                            Send Insert ("."  + String(Constraints[i].iOtherField))
81488>>>                            Send Insert (" (" + FormatFileFieldName(Self,Constraints[i].iOtherFile,Constraints[i].iOtherField)+")")
81489>>>                        End
81489>>>>
81489>>>                        Else If (Constraints[i].eType=CONST_VALUE) Begin
81492>>>                            Send Insert  (" Value=" + String(Constraints[i].sValue))
81493>>>                        End
81493>>>>
81493>>>                        Send Insert CR_LF
81494>>>                    Loop
81495>>>>
81495>>>                    
81495>>>                    Send Insert CR_LF
81496>>>                    
81496>>>                    Send ShowIndices hoDD
81497>>>                    
81497>>>                    
81497>>>                 End_Procedure
81498>>>                 
81498>>>                Procedure ShowIndices Handle hoDD
81501>>>                
81501>>>                    Integer iLastIndex
81501>>>                    Integer iIndex i
81501>>>                    Integer iNumSegments
81501>>>                    Integer hTable
81501>>>                    tDDOConstraintFindMeta FindMeta
81501>>>                    tDDOConstraintFindMeta FindMeta
81501>>>                    Get Main_File of hoDD to hTable
81502>>>                    
81502>>>                    Send Insert CR_LF
81503>>>                    Send Insert "Indexes and Constraints"
81504>>>                    Send Insert CR_LF
81505>>>                
81505>>>                    Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
81508>>>                    For iIndex from 1 to iLastIndex
81514>>>>
81514>>>                        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
81517>>>                        If (iNumSegments > 0) Begin
81519>>>                            
81519>>>                            Get DDOConstraintFindMeta of hoDD (GE) iIndex to FindMeta 
81520>>>
81520>>>                            Send Insert ("    Index " + String(iIndex)+": ")
81521>>>                            If (FindMeta.iJumpInSegments>0 or FindMeta.bJumpOut or FindMeta.bPreRelate or FindMeta.bPostRelate) Begin
81523>>>                                Send Insert ( "Jumpin "+String(FindMeta.iJumpInSegments)+" of "+String(iNumSegments)+". " )
81524>>>                                Send Insert ( (If(FindMeta.bJumpOut,"JumpOut. ", "")) + (If(FindMeta.bPreRelate,"Pre-Relate. ", "")) + (If(FindMeta.bPostRelate,"Post-Relate. ", "")) )
81525>>>                            End
81525>>>>
81525>>>                            Else Begin
81526>>>                                Send Insert "No Constraints"
81527>>>                            End
81527>>>>
81527>>>                            Send Insert CR_LF
81528>>>                        End
81528>>>>
81528>>>                    Loop
81529>>>>
81529>>>                End_Procedure // ShowIndices
81530>>>
81530>>>                Procedure RefreshAll
81533>>>                    Handle hDD
81533>>>                    Get phoCurrentDD to hDD
81534>>>                    Set Dynamic_update_state to False
81535>>>                    Send Delete_Data
81536>>>                    If (hDD) Begin
81538>>>                        Send ShowDDOConstraints hDD
81539>>>                    End
81539>>>>
81539>>>                    Send Beginning_Of_Data
81540>>>                    Set Dynamic_update_state to True
81541>>>                End_Procedure
81542>>>
81542>>>
81542>>>
81542>>>                Set Size to 100 375
81543>>>                Set Location to 4 4
81544>>>
81544>>>
81544>>>
81544>>>            End_Object
81545>>>            
81545>>>            Object oSQLFilterCkBox is a CheckBox
81547>>>                Set Size to 10 50
81548>>>                Set Location to 122 4
81549>>>                Set Label to "Use SQL Filter"
81550>>>                Set peAnchors to anBottom
81551>>>            
81551>>>                Procedure Select_Toggling Integer iItm Integer bState
81554>>>                    Handle hoDDO
81554>>>                    Boolean bFilter
81554>>>                    Get phoCurrentDD to hoDDO
81555>>>                    Forward Send select_toggling iItm bState
81557>>>                    Get Checked_State to bFilter
81558>>>                    Set pbUseDDSQLFilters of hoDDO to bFilter
81559>>>                    Send ApplySQLFilterInfo
81560>>>                End_Procedure
81561>>>            
81561>>>            End_Object
81562>>>
81562>>>            Object oInherit is a CheckBox
81564>>>                Set Label to "Inherit Constraints"
81565>>>                Set Size to 10 69
81566>>>                Set Location to 107 4
81567>>>                Set peAnchors to anBottomLeft
81568>>>        
81568>>>                Procedure Select_Toggling Integer iItm Integer bState
81571>>>                    Integer hDD
81571>>>                    Get phoCurrentDD to hDD
81572>>>                    Forward Send select_toggling iItm bState
81574>>>                    Set pbInheritConstraints of hDD to (checked_state(Self))
81575>>>                    If (hDD>0) Begin
81577>>>                        Send RebuildAllConstraints of hDD 
81578>>>//                        Send rebuild_constraints to hDD
81578>>>                        Send RefreshAll
81579>>>                    End
81579>>>>
81579>>>                End_Procedure
81580>>>        
81580>>>            End_Object    // oInherit
81581>>>
81581>>>            Object oSQLFilter is a Form
81583>>>                Set Size to 13 316
81584>>>                Set Location to 119 63
81585>>>                Set peAnchors to anBottomLeftRight
81586>>>                Procedure OnChange
81589>>>                    Handle hoDDO
81589>>>                    String sValue
81589>>>                    Get phoCurrentDD to hoDDO
81590>>>                    Get Value to sValue
81591>>>                    Set psSQLFilter of hoDDO to sValue
81592>>>                End_Procedure
81593>>>            End_Object
81594>>>            
81594>>>            Procedure ApplySQLFilterInfo
81597>>>                Integer iValue
81597>>>                Boolean bFilter bAllowed
81597>>>                Handle hoDDO
81597>>>                String sFilter
81597>>>                
81597>>>                Get phoCurrentDD to hoDDO
81598>>>                Get SupportsSQLFilters of hoDDO to bAllowed
81599>>>                Set Enabled_state of oSQLFilterCkBox to bAllowed
81600>>>                Get pbUseDDSQLFilters of hoDDO to bFilter
81601>>>                Get psSQLFilter of hoDDO to sFilter
81602>>>                Set Checked_State of oSQLFilterCkBox to bFilter
81603>>>                Set Enabled_state of oSQLFilter to bFilter
81604>>>                Set Value of oSQLFilter to sFilter
81605>>>            End_Procedure
81606>>>
81606>>>            Procedure RefreshAll
81609>>>                Send RefreshAll of oConstraintsEdit
81610>>>                Send ApplySQLFilterInfo
81611>>>            End_Procedure
81612>>>        End_Object
81613>>>        Object oTP_Field_Values is a TabPage
81615>>>            Set Label to "Field Values"
81616>>>            Set Tab_ToolTip_Value to "DD Field Values"
81617>>>            Object oFieldsEdit is a cDDDebugResults
81619>>>                delegate set phoFieldsEditId to self
81621>>>
81621>>>                Set Size to 127 375
81622>>>                Set Location to 4 4
81623>>>
81623>>>                Procedure RefreshAll
81626>>>                    Integer hDD hRB iMax iItem iFile
81626>>>                    Integer iOldErrorReport hOldErr
81626>>>                    String sLine sFieldName sChanged sVld sFrnVld sVal
81626>>>
81626>>>                    get phoCurrentDD to hDD
81627>>>                    get Record_Buffer of hDD to hRB
81628>>>                    Get main_file of hDD to iFile
81629>>>                    Set Dynamic_update_state to false
81630>>>                    Send Delete_Data
81631>>>
81631>>>                    Get Error_Report_Mode of hDD to iOldErrorReport
81632>>>                    Set Error_Report_Mode of hDD to DD_ERROR_NO_REPORT
81633>>>                    Move Error_Object_id to hOldErr
81634>>>                    Move hDD to Error_Object_id
81635>>>
81635>>>                    // Write the Header
81635>>>                    Send Insert "Field                           Chg Vld FrnVld Value"
81636>>>                    Send Insert CR_LF
81637>>>                    Send Insert "-----------------------------------------------------------------------------------------------------------"
81638>>>                    Send Insert CR_LF
81639>>>
81639>>>                    // Write the bodies for the fields
81639>>>                    Get Item_Count of hRB to iMax
81640>>>                    Decrement iMax
81641>>>                    For iItem From 0 to iMax
81647>>>>
81647>>>                        Get_Attribute DF_FIELD_NAME of iFile iItem to sFieldName
81650>>>                        Move (Pad(sFieldName,32)) to sFieldName
81651>>>                        Move (string(Item_Changed_State(hRB, iItem))) to sChanged
81652>>>                        // this will test it as a standard validation
81652>>>                        Move hDD to Operation_Origin
81653>>>                        Move (If(Validate_Field(hDD,iItem),"N","Y")) to sVld
81654>>>                        // this will test it as a foreign validation
81654>>>                        Move 0 to Operation_Origin
81655>>>                        Move (If(Validate_Field(hDD,iItem),"N","Y")) to sFrnVld
81656>>>                        //              Print (Item_Entry_MSG(hRB, iItem))
81656>>>                        //              Print (Item_Exit_MSG(hRB, iItem))
81656>>>                        //              Print (Item_Validate_MSG(hRB, iItem))
81656>>>                        Move (Field_Current_Value(hDD, iItem)) to sVal
81657>>>                        Move (sFormat("%1 %2   %3   %4     %5", sFieldName, sChanged, sVld, sFrnVld, sVal)) to sLine
81658>>>                        Send Insert sLine
81659>>>                        Send Insert CR_LF
81660>>>                    Loop
81661>>>>
81661>>>                    Send Insert CR_LF
81662>>>                    Send Insert "Existing_Key_Value = "
81663>>>                    Send Insert (Existing_Key_Value(hDD))
81664>>>                    Send Insert CR_LF
81665>>>
81665>>>                    Send Beginning_of_Data
81666>>>                    Set Dynamic_update_state to true
81667>>>                    Set Error_Report_Mode of hDD to iOldErrorReport
81668>>>                    Move hOldErr to Error_Object_id
81669>>>                End_procedure
81670>>>
81670>>>
81670>>>            End_Object    // oFieldsEdit
81671>>>
81671>>>        End_Object    // oTP_Field_Values
81672>>>        
81672>>>
81672>>>        Object oTP_Misc is a TabPage
81674>>>            Set Label to "Misc"
81675>>>            Set Tab_ToolTip_Value to "Other DD static values"
81676>>>            Object oMiscEdit is a cDDDebugResults
81678>>>                delegate set phoMiscEditId to self
81680>>>
81680>>>                Procedure RefreshAll
81683>>>                    Integer hDD hRB iMax iItem iFile iFIl iObj iOldSt
81683>>>                    Integer iCnt hVw iBase iType iFAObj iOldErrorReport hOldErr iMaster
81683>>>                    String sDummy sView sName sDummy2 sFieldName sType sLine
81683>>>                    Handle hoMaster
81683>>>
81683>>>                    Get phoInvokingView to hVw
81684>>>                    Get Name of hVw to sView
81685>>>
81685>>>                    get phoCurrentDD to hDD
81686>>>                    get Record_Buffer    of hDD to hRB
81687>>>                    get Field_Attributes of hDD to iFAObj
81688>>>                    Get main_file of hDD to iFile
81689>>>                    Set Dynamic_update_state to False
81690>>>                    Send Delete_Data
81691>>>
81691>>>                    Send Insert "Current DDO = "
81692>>>                    Send Insert (String(hDD) * "-" * Object_Label(hDD))
81693>>>                    Send Insert CR_LF
81694>>>                    
81694>>>                    Send Insert "Main File = "
81695>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of iFile to sName
81698>>>                    Send Insert (String(iFile) * "-" * sName)
81699>>>                    Send Insert CR_LF
81700>>>                    
81700>>>                    
81700>>>                    
81700>>>                    Send Insert "Driver File = "
81701>>>                    Get_Attribute DF_FILE_DRIVER of iFile to sName
81704>>>                    Send Insert sName
81705>>>                    Send Insert CR_LF
81706>>>                    Send Insert CR_LF
81707>>>
81707>>>                    // see if this has a master table (i.e., if this DDO is an alias)
81707>>>                    Get MasterForAlias of hDD to iMaster
81708>>>                    If (iMaster<>0) Begin
81710>>>                        Get Data_Set of hDD iMaster to hoMaster
81711>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iMaster to sName
81714>>>                        Send Insert "Alias Table Information"
81715>>>                        Send Insert CR_LF
81716>>>                        Send Insert ("    Master Table: " + String(iMaster) * "-" * sName)
81717>>>                        Send Insert CR_LF
81718>>>                        // it is possible the master is not in this DDO structure. If so
81718>>>                        // this will be treated as a regular table.
81718>>>                        If (hoMaster) Begin
81720>>>                            Send Insert "    Master DDO = "
81721>>>                            Send Insert (String(hoMaster) * "-" * Object_Label(hoMaster))
81722>>>                        End
81722>>>>
81722>>>                        Else Begin
81723>>>                            Send Insert "    ** The master table is not part of the DDO structure"
81724>>>                            Send Insert CR_LF
81725>>>                            Send Insert "       therefore this DDO will be locked as a regular non-alias table."
81726>>>                        End
81726>>>>
81726>>>                        Send Insert CR_LF
81727>>>                        Send Insert CR_LF
81728>>>                    End
81728>>>>
81728>>>                    
81728>>>                    
81728>>>
81728>>>                    Send Insert "Current DDO Container = "
81729>>>                    Send Insert (String(hVw) * "-" * Object_Label(hVw) * "(" - sView - ")")
81730>>>                    Send Insert CR_LF
81731>>>                    Send Insert CR_LF
81732>>>
81732>>>                    //Send Insert "Keys_Fields = "
81732>>>                    //Send Insert (Key_Fields(hDD))
81732>>>                    //Send Insert CR_LF
81732>>>
81732>>>                    Send Insert "Protect_Key_State = "
81733>>>                    Send Insert (If(Protect_Key_State(hDD),"True","False"))
81734>>>                    Send Insert CR_LF
81735>>>
81735>>>                    Send Insert "Cascade_Delete_State = "
81736>>>                    Send Insert (If(Cascade_Delete_State(hDD),"True","False"))
81737>>>                    Send Insert CR_LF
81738>>>                    Send Insert CR_LF
81739>>>
81739>>>                    Send Insert "Required Server Files = "
81740>>>                    Send Insert (Server_File_Count(hDD))
81741>>>                    Send Insert CR_LF
81742>>>                    For iCnt from 0 to (Server_File_Count(hDD)-1)
81748>>>>
81748>>>                        Get Server_File of hDD iCnt to iFil
81749>>>                        Send Insert ("     " +string(iFil)+" - ")
81750>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81753>>>                        Send Insert sDummy
81754>>>                        Send Insert CR_LF
81755>>>                    Loop
81756>>>>
81756>>>                    Send Insert  CR_LF
81757>>>
81757>>>                    Send Insert "Required Client Files = "
81758>>>                    Send Insert (Client_File_Count(hDD))
81759>>>                    Send Insert CR_LF
81760>>>                    For iCnt from 0 to (Client_File_Count(hDD)-1)
81766>>>>
81766>>>                        Get Client_File of hDD iCnt to iFil
81767>>>                        Send Insert ("     " +string(iFil)+" - ")
81768>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81771>>>                        Send Insert sDummy
81772>>>                        Send Insert CR_LF
81773>>>                    Loop
81774>>>>
81774>>>                    Send Insert  CR_LF
81775>>>
81775>>>                    Send Insert "Required Other Files = "
81776>>>                    Send Insert (System_File_Count(hDD))
81777>>>                    Send Insert CR_LF
81778>>>                    For iCnt from 0 to (System_File_Count(hDD)-1)
81784>>>>
81784>>>                        Get System_File_Number of hDD iCnt to iFil
81785>>>                        Send Insert ("     " +string(iFil)+" - ")
81786>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81789>>>                        Send Insert sDummy
81790>>>                        Get System_File_Lock_Mode of hDD iCnt to iFil
81791>>>                        Case Begin
81791>>>                            case (iFil=DD_Lock_on_All)             Move " - Lock on all" to sDummy
81794>>>                            case (iFil=DD_Lock_on_Delete)          Move " - Lock on Delete" to sDummy
81798>>>                            case (iFil=DD_Lock_on_new_Save_delete) Move " - Lock on new save/delete" to sDummy
81802>>>                            case (iFil=DD_Lock_on_Save)            Move " - Lock on save" to sDummy
81806>>>                            case (iFil=DD_Lock_on_new_Save)        Move " - Lock on new save" to sDummy
81810>>>                            case else                              Move " - No Lock" to sDummy
81812>>>                        case end
81812>>>                        Send Insert sDummy
81813>>>                        Send Insert CR_LF
81814>>>                    Loop
81815>>>>
81815>>>                    Send Insert  CR_LF
81816>>>
81816>>>                    Send Insert "Attached DDO Server DDO = "
81817>>>                    Send Insert (Data_set_server_Count(hDD))
81818>>>                    Send Insert CR_LF
81819>>>                    For iCnt from 0 to (Data_set_server_Count(hDD)-1)
81825>>>>
81825>>>                        Get Data_Set_Server of hDD iCnt to iObj
81826>>>                        Get Main_file of iObj to iFil
81827>>>                        Move (replace(sView+".",Name(iObj),"")) to sName
81828>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
81829>>>                        Send Insert ("     " +string(iFil)+" - ")
81830>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81833>>>                        Send Insert sDummy
81834>>>                        Send Insert CR_LF
81835>>>                    Loop
81836>>>>
81836>>>                    Send Insert  CR_LF
81837>>>
81837>>>                    Send Insert "Attached DDO CLient DDOs = "
81838>>>                    Send Insert  (Data_set_Client_Count(hDD))
81839>>>                    Send Insert  CR_LF
81840>>>                    For iCnt from 0 to (Data_set_Client_Count(hDD)-1)
81846>>>>
81846>>>                        Get Data_Set_Client of hDD iCnt to iObj
81847>>>                        Get Main_file of iObj to iFil
81848>>>                        Move (replace(sView+".",Name(iObj),"")) to sName
81849>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
81850>>>                        Send Insert ("     " +string(iFil)+" - ")
81851>>>                        Get_Attribute DF_FILE_LOGICAL_NAME of iFil to sDummy
81854>>>                        Send Insert sDummy
81855>>>                        Send Insert CR_LF
81856>>>                    Loop
81857>>>>
81857>>>                    Send Insert CR_LF
81858>>>
81858>>>                    Send Insert  "Valid Save Structure = "
81859>>>                    Send Insert  (if(Validate_Save_Structure(hDD,1),"No","Yes"))
81860>>>                    Send Insert  CR_LF
81861>>>
81861>>>                    Get Cascade_delete_State of hDD to ioldst
81862>>>                    Set Cascade_delete_State of hDD to TRUE
81863>>>                    Send Insert  "Valid Cascade Delete Structure = "
81864>>>                    Send Insert  (if(Validate_Delete_Structure(hDD,1),"No","Yes"))
81865>>>                    Send Insert  CR_LF
81866>>>
81866>>>                    Set Cascade_delete_State of hDD to False
81867>>>                    Send Insert  "Valid No Cascade Delete Structure = "
81868>>>                    Send Insert  (if(Validate_Delete_Structure(hDD,1),"No","Yes"))
81869>>>                    Send Insert  CR_LF
81870>>>                    Set Cascade_delete_State of hDD to ioldst
81871>>>
81871>>>                    Send Insert  CR_LF
81872>>>                    Send Insert  "Attached DEOs = "
81873>>>                    Send Insert  (Data_set_user_Interface_Count(hDD))
81874>>>                    Send Insert  CR_LF
81875>>>                    For iCnt from 0 to (Data_set_User_Interface_Count(hDD)-1)
81881>>>>
81881>>>                        Get Data_Set_User_Interface of hDD iCnt to iObj
81882>>>                        Move (replace(sView+".",Object_Label(iObj),"")) to sName
81883>>>                        Send Insert ("     " +string(iObj)+" - "+sname)
81884>>>                        If Not (Extended_deo_State(iObj)) Send Insert  ("  (**Not XDEO)")
81887>>>                        else If (Data_File(iObj,0)<>iFile) Send Insert  ("    (foreign)")
81891>>>
81891>>>                        Send Insert  CR_LF
81892>>>                    Loop
81893>>>>
81893>>>                    Send Insert  CR_LF
81894>>>
81894>>>                    // Write the bodies for the fields
81894>>>                    // Write the Header
81894>>>                    Send Insert "              Extended Field Attributes"
81895>>>                    Send Insert CR_LF
81896>>>                    Send Insert "Field                            Type             Valid Values"
81897>>>                    Send Insert CR_LF
81898>>>                    Send Insert "-----------------------------------------------------------------------------------------------------------"
81899>>>                    Send Insert CR_LF
81900>>>
81900>>>                    Get Error_Report_Mode of hDD to iOldErrorReport
81901>>>                    Set Error_Report_Mode of hDD to DD_ERROR_NO_REPORT
81902>>>                    Move Error_Object_id to hOldErr
81903>>>                    Move hDD to Error_Object_id
81904>>>                    Get Item_Count of hRB to iMax
81905>>>                    Decrement iMax
81906>>>                    For iItem From 0 to iMax
81912>>>>
81912>>>                        Move (iItem * FA_COUNT) to iBase
81913>>>                        Get_Attribute DF_FIELD_NAME of iFile iItem to sFieldName
81916>>>                        Move (pad(sFieldName,32)) to sFieldName
81917>>>                        Get Field_Validation_Type of hDD iItem to iType
81918>>>                        Case Begin
81918>>>                            Case (iType=FA_VALIDATION_TYPE_RANGE)
81920>>>                                Move "Range" to sDummy
81921>>>                                Move ("Min="+Value(iFAObj,iBase+FA_MIN_VALUE) * ;                                    "Max="+Value(iFAObj,iBase+FA_MAX_VALUE)) ;                                        to sDummy2
81922>>>                                Case Break
81923>>>                            Case (iType=FA_VALIDATION_TYPE_CHECK)
81926>>>                                Move "Check" to sDummy
81927>>>                                Move ("Values =" * Value(iFAObj,iBase+FA_CHECK_VALUE)) to sDummy2
81928>>>                                Case Break
81929>>>                            Case (iType=FA_VALIDATION_TYPE_CHECKBOX)
81932>>>                                Move "CheckBox" to sDummy
81933>>>                                Move ("True="+ Value(iFAObj,iBase+FA_CHECKBOX_TRUE) * ;                                    "False="+ Value(iFAObj,iBase+FA_CHECKBOX_FALSE)) ;                                        to sDummy2
81934>>>                                Case Break
81935>>>                            Case (iType=FA_VALIDATION_TYPE_TABLE)
81938>>>                                Move "Table" to sDummy
81939>>>                                Move ("Id="+ Value(iFAObj,iBase+FA_TABLE_OBJECT) * ;                                      Name( Value(iFAObj,iBase+FA_TABLE_OBJECT) )) ;                                        to sDummy2
81940>>>                                Case Break
81941>>>                            Case Else
81941>>>                                Move "None" to sDummy
81942>>>                                Move "" to sDummy2
81943>>>                        Case end
81943>>>                        Move (Pad(sDummy,14)) to sDummy
81944>>>                        Move (SFormat("%1 %2 %3 %4", sFieldName, sType, sDummy, sDummy2)) to sLine
81945>>>                        Send Insert sLine
81946>>>                        Send Insert  CR_LF
81947>>>                    Loop
81948>>>>
81948>>>
81948>>>                    Send Beginning_Of_Data
81949>>>                    Set Dynamic_update_state to True
81950>>>                    Set Error_Report_Mode of hDD to iOldErrorReport
81951>>>                    Move hOldErr to Error_Object_id
81952>>>                end_procedure
81953>>>
81953>>>
81953>>>
81953>>>                Set Size to 127 375
81954>>>                Set Location to 4 4
81955>>>
81955>>>
81955>>>
81955>>>            End_Object    // oMiscEdit
81956>>>
81956>>>        End_Object    // oTP_Misc
81957>>>
81957>>>    End_Object    // oTD
81958>>>
81958>>>    Object oFindCounts is a Group
81960>>>        Set Size to 40 390
81961>>>        Set Location to 182 10
81962>>>        Set Label to "Constraint Find Counts"
81963>>>        Set peAnchors to anBottomLeft
81964>>>        Object oTestsCount is a Form
81966>>>
81966>>>            Set enabled_state to false
81967>>>
81967>>>            Set Label to "Tests_Count"
81968>>>            Set Size to 13 37
81969>>>            Set Location to 10 47
81970>>>            Set Label_Col_Offset to 2
81971>>>            Set Label_Justification_Mode to jMode_Right
81972>>>
81972>>>            Set Numeric_mask 0 to 8 0
81973>>>
81973>>>        End_Object    // oTestsCount
81974>>>
81974>>>        Object oFoundCount is a Form
81976>>>
81976>>>            Set enabled_state to false
81977>>>
81977>>>            Set Label to "Found_Count"
81978>>>            Set Size to 13 37
81979>>>            Set Location to 10 137
81980>>>            Set Label_Col_Offset to 2
81981>>>            Set Label_Justification_Mode to jMode_Right
81982>>>
81982>>>            Set Numeric_mask 0 to 8 0
81983>>>
81983>>>        End_Object    // oFoundCount
81984>>>
81984>>>        Object oDifference is a Form
81986>>>
81986>>>            Set enabled_state to false
81987>>>
81987>>>            Set Label to "Difference"
81988>>>            Set Size to 13 37
81989>>>            Set Location to 10 213
81990>>>            Set Label_Col_Offset to 2
81991>>>            Set Label_Justification_Mode to jMode_Right
81992>>>
81992>>>            Set Numeric_mask 0 to 8 0
81993>>>
81993>>>        End_Object    // oDifference
81994>>>
81994>>>        Object oClearCounts is a Button
81996>>>
81996>>>
81996>>>
81996>>>            Set Label to "Clear Count"
81997>>>            Set Size to 13 50
81998>>>            Set Location to 10 260
81999>>>
81999>>>            Procedure OnClick
82002>>>                Send ClearCounts
82003>>>            End_procedure
82004>>>
82004>>>
82004>>>        End_Object    // oClearCounts
82005>>>
82005>>>        Object oNonOptimalWarnings is a CheckBox
82007>>>            Set Label to "Report errors if more than"
82008>>>            Set Size to 10 93
82009>>>            Set Location to 24 6
82010>>>
82010>>>            Procedure OnChange
82013>>>                Delegate Send SetNonOptimalWarnings
82015>>>            End_Procedure // OnChange
82016>>>
82016>>>        End_Object    // oNonOptimalWarnings
82017>>>
82017>>>        Object oNonOptFinds is a Form
82019>>>
82019>>>            Set Numeric_mask 0 to 6 0
82020>>>
82020>>>            Set Size to 13 25
82021>>>            Set Location to 24 104
82022>>>
82022>>>
82022>>>            Set Value 0 to 50
82023>>>
82023>>>            Procedure OnChange
82026>>>                Delegate Send SetNonOptimalWarnings
82028>>>            End_Procedure // OnChange
82029>>>
82029>>>        End_Object    // oNonOptFinds
82030>>>
82030>>>        Object oNonOptTb is a Textbox
82032>>>            Set Label to "records are filtered."
82033>>>            Set Location to 25 132
82034>>>            Set Size to 10 61
82035>>>        End_Object    // oNonOptTb
82036>>>
82036>>>
82036>>>        Procedure ClearCounts
82039>>>            Move 0 to Constrain_tests_count
82040>>>            Move 0 to Constrain_found_Count
82041>>>            Send RefreshCounts
82042>>>        End_procedure
82043>>>
82043>>>        procedure RefreshCounts
82046>>>            Set Value of oTestsCount to constrain_tests_count
82047>>>            Set Value of oFoundCount to constrain_Found_count
82048>>>            Set Value of oDifference to (constrain_tests_count - Constrain_found_count)
82049>>>        end_procedure
82050>>>
82050>>>
82050>>>    End_Object    // oFindCounts
82051>>>
82051>>>    Object oFindGp is a Group
82053>>>
82053>>>
82053>>>
82053>>>        Set Size to 30 185
82054>>>        Set Location to 225 10
82055>>>        Set Label to "Find Record"
82056>>>        Set peAnchors to anBottomLeft
82057>>>        Object oFindBgn is a Button
82059>>>            Set Size to 14 18
82060>>>            Set Location to 10 9
82061>>>            Set peImageAlign to Button_ImageList_Align_Center
82062>>>            Set psImage to "ActionFirst.ico"
82063>>>
82063>>>            Procedure OnClick
82066>>>                Delegate Send FindRec FIRST_RECORD
82068>>>            End_procedure
82069>>>
82069>>>
82069>>>        End_Object    // oFindBgn
82070>>>
82070>>>        Object oFindPrev is a Button
82072>>>            Set Size to 14 18
82073>>>            Set Location to 10 31
82074>>>            Set peImageAlign to Button_ImageList_Align_Center
82075>>>            Set psImage to "ActionPrevious.ico"
82076>>>
82076>>>            Procedure OnClick
82079>>>                Delegate Send FindRec LT
82081>>>            End_procedure
82082>>>
82082>>>
82082>>>        End_Object    // oFindPrev
82083>>>
82083>>>        Object oFindNext is a Button
82085>>>
82085>>>            Set Size to 14 18
82086>>>            Set Location to 10 53
82087>>>            Set peImageAlign to Button_ImageList_Align_Center
82088>>>            Set psImage to "ActionNext.ico"
82089>>>
82089>>>            Procedure OnClick
82092>>>                Delegate Send FindRec Gt
82094>>>            End_procedure
82095>>>
82095>>>
82095>>>        End_Object    // oFindNext
82096>>>
82096>>>        Object oFindEnd is a Button
82098>>>
82098>>>            Set Size to 14 18
82099>>>            Set Location to 10 75
82100>>>            Set peImageAlign to Button_ImageList_Align_Center
82101>>>            Set psImage to "ActionLast.ico"
82102>>>
82102>>>            Procedure OnClick
82105>>>                Delegate Send FindRec LAST_RECORD
82107>>>            End_procedure
82108>>>
82108>>>
82108>>>        End_Object    // oFindEnd
82109>>>
82109>>>        Object oFindIndex is a ComboForm
82111>>>
82111>>>
82111>>>
82111>>>            Set Size to 13 85
82112>>>            Set Location to 11 97
82113>>>            Set Form_Border to 0
82114>>>            Set Label_Col_Offset to 2
82115>>>            Set Label_Justification_Mode to jMode_Right
82116>>>
82116>>>            Procedure Fill_list
82119>>>                Integer hDD iFile iSegs iNdxs i
82119>>>                Send Combo_Delete_Data
82120>>>                Get phoCurrentDD to hDD
82121>>>                If hDD Begin
82123>>>                    Send Combo_Add_Item "Index.0"
82124>>>                    Get Main_file of hDD to iFile
82125>>>                    Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iNdxs
82128>>>                    For i from 1 to iNdxs
82134>>>>
82134>>>                        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile i to iSegs
82137>>>                        If iSegs Send Combo_Add_Item ("Index."-string(i))
82140>>>                    Loop
82141>>>>
82141>>>                End
82141>>>>
82141>>>                Set Value 0 to (combo_value(self,0))
82142>>>            End_procedure
82143>>>
82143>>>            Function Ordering returns integer
82146>>>                String sVal
82146>>>                Get Value 0 to sVal
82147>>>                Function_return (integer(mid(sVal, 10, pos(".",sVal)+1)))
82148>>>            end_function
82149>>>
82149>>>        End_Object    // oFindIndex
82150>>>
82150>>>
82150>>>        Procedure FindRec integer iMode
82153>>>            Integer hDD iNdx
82153>>>            Get Ordering of oFindIndex to iNdx
82154>>>            Get phoCurrentDD to hDD
82155>>>            If hDD Begin
82157>>>                Send Find of hDD iMode iNdx
82158>>>                Send RefreshAll
82159>>>            End
82159>>>>
82159>>>        End_procedure
82160>>>
82160>>>         Procedure RefreshNewDD
82163>>>             Send Fill_List of oFindIndex
82164>>>         End_procedure
82165>>>
82165>>>    End_Object    // oFindGp
82166>>>
82166>>>    Object oCheckRentrancy is a CheckBox
82168>>>        Set Label to "Report DD Rentrancy Errors"
82169>>>        Set Size to 10 105
82170>>>        Set Location to 224 294
82171>>>        Set peAnchors to anBottomLeft
82172>>>
82172>>>        Procedure OnChange
82175>>>            Get Checked_State To gbTestRentrancy
82176>>>        End_Procedure // OnChange
82177>>>
82177>>>    End_Object    // oCheckRentrancy
82178>>>
82178>>>    Object oClearAll_bn is a Button
82180>>>
82180>>>
82180>>>
82180>>>        Set Label to "Clear& All"
82181>>>        Set Location to 241 242
82182>>>        Set peAnchors to anBottomLeft
82183>>>
82183>>>        Procedure OnClick
82186>>>            Integer hDD
82186>>>            get phoCurrentDD to hDD
82187>>>            if hDD Send clear_all to hdd
82190>>>            Send RefreshALL
82191>>>        end_procedure
82192>>>
82192>>>    End_Object    // oClearAll_bn
82193>>>
82193>>>    Object oClear_bn is a Button
82195>>>
82195>>>
82195>>>
82195>>>        Set Label to "&Clear"
82196>>>        Set Location to 241 295
82197>>>        Set peAnchors to anBottomLeft
82198>>>
82198>>>        Procedure OnClick
82201>>>            Integer hDD
82201>>>            get phoCurrentDD to hDD
82202>>>            if hDD Send clear to hdd
82205>>>            Send RefreshALL
82206>>>        end_procedure
82207>>>
82207>>>
82207>>>    End_Object    // oClear_bn
82208>>>
82208>>>    Object oClose_bn is a Button
82210>>>
82210>>>
82210>>>
82210>>>        Set Label to "&Close"
82211>>>        Set Location to 241 350
82212>>>        Set peAnchors to anBottomLeft
82213>>>
82213>>>        Procedure OnClick
82216>>>            Send Close_Panel
82217>>>        end_procedure
82218>>>
82218>>>
82218>>>    End_Object    // oClose_bn
82219>>>
82219>>>    Procedure RefreshAll
82222>>>        Integer hDD
82222>>>        Boolean bIsRecnumTable
82222>>>        get phoCurrentDD to hDD
82223>>>        Get IsRecnumTable (main_file(hDD)) to bIsRecnumTable
82224>>>        Set Value          of oCurRec 0 to (If(bIsRecnumTable, current_record(hDD), 0))
82225>>>        Set checked_state  of oChangedState to (Changed_State(hDD))
82226>>>        set checked_state  of oShouldSave   to (Should_save(hDD))
82227>>>        Send RefreshAll    of (phoFieldsEditId(self))
82228>>>        Send RefreshCounts of oFindCounts
82229>>>    End_procedure
82230>>>
82230>>>    Procedure SetNonOptimalWarnings
82233>>>        Integer iValue
82233>>>        Boolean bChecked
82233>>>        Get Checked_State of oNonOptimalWarnings to bChecked
82234>>>        Get Value of oNonOptFinds to iValue
82235>>>        Move (if(bChecked,iValue,0)) to giNonOptimalFindCount
82236>>>        Set Enabled_state of oNonOptFinds to bChecked
82237>>>    End_procedure
82238>>>
82238>>>    Procedure RefreshNewDD
82241>>>        Integer hDD
82241>>>        get phoCurrentDD to hDD
82242>>>        Send Fill_list of oDDRelatesTo
82243>>>        set checked_state of oAutoFill to (Auto_Fill_State(hDD)<>0)
82244>>>        set checked_state of oInherit  to (pbInheritConstraints(hDD))
82245>>>        set checked_state of oFillFromTop to (pbAutoFillFromFirst(hDD))
82246>>>        Send RefreshAll   to (phoMiscEditId(self))
82247>>>        Send RefreshAll   to (phoConstraintsEditId(Self))
82248>>>        Send RefreshAll
82249>>>
82249>>>        Send RefreshNewDD of oDDOrdering
82250>>>        Send RefreshNewDD of oFindGP
82251>>>        Set  Ordering     of oDDOrdering to (ordering(hDD))
82252>>>    End_procedure
82253>>>
82253>>>
82253>>>    Procedure refresh
82256>>>        Send Fill_list of oDDCombo
82257>>>        Send SetNonOptimalWarnings
82258>>>        set checked_state of oCheckRentrancy to gbTestRentrancy
82259>>>    end_procedure
82260>>>
82260>>>    Procedure ShowDDs Integer hoDD
82263>>>        Integer hoVw
82263>>>        Get parent of hoDD  to hoVw
82264>>>        Set phoCurrentDD    to hoDD
82265>>>        Set phoInvokingView to hoVw
82266>>>        Send Refresh
82267>>>        Send Popup
82268>>>    End_Procedure
82269>>>
82269>>>
82269>>>
82269>>>End_Object    // oDD_Debug
82270>>>
82270>>>
82270>>>
82270>>>Procedure DebugDDs FOR cObject
82272>>>   Integer hDD
82272>>>   get Server to hDD
82273>>>   if hDD Send ShowDDs of oDD_Debug hDD
82276>>>End_Procedure
82277>>>
82277>>>On_key key_Ctrl+Key_D Send DebugDDs
82278>>>
82278>
82278>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\StdAbout.pkg)
82278>>>//************************************************************************
82278>>>// Confidential Trade Secret.
82278>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
82278>>>// as an unpublished work.  All rights reserved.
82278>>>// DataFlex is a registered trademark of Data Access Corporation.
82278>>>//
82278>>>//************************************************************************
82278>>>//************************************************************************
82278>>>//
82278>>>// $File name  : StdAbout.pkg
82278>>>// $File title : Standard about object package for VDF
82278>>>// Notice      :
82278>>>// $Author(s)  : John Tuohy
82278>>>//
82278>>>// $Rev History
82278>>>//
82278>>>// JT 06/27/97   File created
82278>>>//************************************************************************
82278>>>
82278>>>// This provides a quick and simple way to create an about package for a program.
82278>>>// You need to create a message inside you client area called Activate_About.
82278>>>// Within this message you should send the message DoAbout passing needed
82278>>>// string information.
82278>>>//
82278>>>//       Procedure Activate_About
82278>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
82278>>>//       End_Procedure
82278>>>//    where: sTitle =     Name of application. If none provided, uses caption
82278>>>//                        bar title
82278>>>//           sVersion   = Version Line. If none provided, will be blank
82278>>>//           sCopyRight = Copyright Line. If none provided, will be blank
82278>>>//           sAuthor    = Author name, blank if none provided
82278>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
82278>>>//                        is used.
82278>>>// It is expected that you will place this in your own object package. For
82278>>>// example an order about package may look like this:
82278>>>//
82278>>>//   // OrderAbout.pkg
82278>>>//   Use StdAbout.pkg
82278>>>//   Procedure Activate_About
82278>>>//      String sTitle sCopyright sVersion sAuthor
82278>>>//      Move "My Order Entry System" to sTitle
82278>>>//      Move "Version 2.1" to sVersion
82278>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
82278>>>//      Move "John Smith"  to sAuthor
82278>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
82278>>>//   end_procedure
82278>>>//   // end of file.
82278>>>
82278>>>Use DfAbout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DfAbout.pkg)
82278>>>>>//************************************************************************
82278>>>>>// Confidential Trade Secret.
82278>>>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
82278>>>>>// as an unpublished work.  All rights reserved.
82278>>>>>// DataFlex Is A registered trademark Of Data Access Corporation.
82278>>>>>//
82278>>>>>//************************************************************************
82278>>>>>//************************************************************************
82278>>>>>//
82278>>>>>// $File name  : DfAbout.pkg
82278>>>>>// $File title : About class support
82278>>>>>// Notice      :
82278>>>>>// $Author(s)  : Vincent Oorsprong, Ken Ross
82278>>>>>//
82278>>>>>// $Rev History
82278>>>>>//
82278>>>>>// NGS 08/16/2013 Improved by using a cRichEdit object were the params gets added to.
82278>>>>>//                The objects that previously were popupated with values from the params,
82278>>>>>//                and their corresponding "Procedure Set..." messages, were removed as
82278>>>>>//                the edit object is used instead.
82278>>>>>//                The number of params to the DoAbout procedure was increased to ten, so
82278>>>>>//                it is easier to add whatever extra text strings needed/wanted.
82278>>>>>//                The StdAbout.pkg was also changed for this to work. It allows for an extra
82278>>>>>//                five new params to be passed, but these new params are all optional.
82278>>>>>//                So the interface will work exactly as before - if no extra parameters are passed.
82278>>>>>//                Also added an extra bitmap object to show the "Powered By Visual DataFlex" logo, in
82278>>>>>//                the lower left corner of the About object, beneath the "main" About bitmap.
82278>>>>>//                Note: It is assumed that the bitmap "PoweredByVisualDataFlex.bmp" exists.
82278>>>>>//                The background was changed to clWhite for easier usage of bitmaps. Just set the background
82278>>>>>//                color of your bitmap to white and the bitmap will not look jagged.
82278>>>>>//                If an Internet address is passed as one of the params, it will be underlined and clickable.
82278>>>>>//                An e-mail address can also be passed; e.g. "E-mail: mailto:mail@myemailaccount.com" and will
82278>>>>>//                also be clickable.
82278>>>>>// VOO 02/22/2012 Replaced obsolete code, improved Network_User_Name by asking
82278>>>>>//                Windows for the size first.
82278>>>>>// VOO 07/25/2003 Removed OnResize procedure for sysinfo dialog. Replaced logic
82278>>>>>//                with anchor technique. Removed unnessary property in the
82278>>>>>//                sysinfo dialog. Changed the size Of the about & sysinfo dialog
82278>>>>>//                object To better look in Windows XP. Repositioned the close
82278>>>>>//                button in the sysinfo dialog To line up with the display area
82278>>>>>//                Replaced obsolete code and techniques. Removed dead code.
82278>>>>>// JJT 10/23/2001 removed all ghoworkspace support. Uses app object or nothing
82278>>>>>// SWB 07/19/01   Added support Of the Application object in preference to
82278>>>>>//                the global Workspace object, if it is present
82278>>>>>// JJT 11/05/98   Added version information
82278>>>>>// VOO 29/10/98   Replaced the GetFreeSystemResources for the Win32 variant
82278>>>>>// JJT 7/31/97    Registered Enumerate Workspace so dfabout can exist without
82278>>>>>//                workspace package.
82278>>>>>// JJT 6/27/97    Turned the sysinfo objects into classes so the AboutDialog
82278>>>>>//                class can create this object.
82278>>>>>//                Cleaned up the interface (used correct classes and messages)
82278>>>>>//                Added workspace reporting support To sys-info.
82278>>>>>//                Turned off wrapping in the sys-info editor.
82278>>>>>// KR  ??/??/96   File created
82278>>>>>//************************************************************************
82278>>>>>Use LanguageText.pkg
82278>>>>>Use Windows.pkg
82278>>>>>Use DFbitmap.pkg
82278>>>>>Use GlobalFunctionsProcedures.pkg
82278>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cRichEdit.pkg)
82278>>>>>>>use Windows.pkg
82278>>>>>>>Use cEdit_Mixin.pkg
82278>>>>>>>
82278>>>>>>>// DFO: cRichEdit.Dfo
82278>>>>>>>// DFC: cRichEdit.Dfc
82278>>>>>>>
82278>>>>>>>// constants used for RichEdit Properties
82278>>>>>>>// peAlignment 
82278>>>>>>>Enum_List 
82278>>>>>>>    Define alLeft   for 1 
82278>>>>>>>    Define alRight  for 2 
82278>>>>>>>    Define alCenter for 3 
82278>>>>>>>End_Enum_List 
82278>>>>>>>
82278>>>>>>>// peBullets 
82278>>>>>>>Enum_List 
82278>>>>>>>    Define buNone 
82278>>>>>>>    Define buBullets 
82278>>>>>>>    Define buArabicNumbers 
82278>>>>>>>    Define buLowerLetters 
82278>>>>>>>    Define buUpperLetters 
82278>>>>>>>    Define buLowerRomans 
82278>>>>>>>    Define buUpperRomans 
82278>>>>>>>End_Enum_List 
82278>>>>>>>
82278>>>>>>>// peBulletStyle 
82278>>>>>>>Enum_List 
82278>>>>>>>    Define busRightParen   for 0 
82278>>>>>>>    Define busEncloseParen for 256 
82278>>>>>>>    Define busPeriod       for 512 
82278>>>>>>>    Define busNumberOnly   for 768 
82278>>>>>>>    Define busNoDisplay    for 1024 
82278>>>>>>>End_Enum_List
82278>>>>>>>    
82278>>>>>>>// peLineSpacingType
82278>>>>>>>Enum_List 
82278>>>>>>>    Define lstSingle
82278>>>>>>>    Define lstSingleAndOneHalf
82278>>>>>>>    Define lstDouble
82278>>>>>>>End_Enum_List
82278>>>>>>>
82278>>>>>>>Class cRichEdit Is A DFBaseRichEdit
82279>>>>>>>
82279>>>>>>>    Procedure Construct_Object
82281>>>>>>>        Forward Send Construct_Object
82283>>>>>>>        Send Define_cEdit_Mixin
82284>>>>>>>
82284>>>>>>>        On_key Key_Ctrl+Key_B send ToggleBold
82285>>>>>>>        On_key Key_Ctrl+Key_I send ToggleItalics
82286>>>>>>>        On_key Key_Ctrl+Key_U send ToggleUnderline
82287>>>>>>>
82287>>>>>>>    End_Procedure // Construct_Object
82288>>>>>>>
82288>>>>>>>    Import_Class_Protocol cEdit_Mixin
82289>>>>>>>    
82289>>>>>>>    Procedure ToggleBold
82291>>>>>>>        Set pbBold to (not(pbBold(self))) 
82292>>>>>>>    end_procedure
82293>>>>>>>    
82293>>>>>>>    Procedure ToggleItalics
82295>>>>>>>        Set pbItalics to (not(pbItalics(self))) 
82296>>>>>>>    end_procedure
82297>>>>>>>    
82297>>>>>>>    Procedure ToggleUnderline
82299>>>>>>>       Set pbUnderLine to (not(pbUnderLine(self))) 
82300>>>>>>>    end_procedure
82301>>>>>>>
82301>>>>>>>End_Class
82302>>>>>>>
82302>>>>>Use cTextEdit.pkg
82302>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\gFormatNumbers.pkg)
82302>>>>>>>//****************************************************************************//
82302>>>>>>>//                                                                            //
82302>>>>>>>// $File name  : gFormatNumbers.pkg                                           //
82302>>>>>>>// $File title : Globals for formating numbers and currency                   //
82302>>>>>>>// Notice      :                                                              //
82302>>>>>>>// $Author(s)  : John Tuohy                                                   //
82302>>>>>>>//                                                                            //
82302>>>>>>>// Confidential Trade Secret.                                                 //
82302>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
82302>>>>>>>// All Rights reserved                                                        //
82302>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
82302>>>>>>>// $Rev History                                                               //
82302>>>>>>>//                                                                            //
82302>>>>>>>// 25.08.99 Created                                                           //
82302>>>>>>>//****************************************************************************//
82302>>>>>>>
82302>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cFormatter.pkg)
82302>>>>>>>>>//****************************************************************************//
82302>>>>>>>>>//                                                                            //
82302>>>>>>>>>// $File name  : cFormatter.pkg                                               //
82302>>>>>>>>>// $File title : cFormatter class (private class)                             //
82302>>>>>>>>>// $Author(s)  : John Tuohy                                                   //
82302>>>>>>>>>//                                                                            //
82302>>>>>>>>>// Confidential Trade Secret.                                                 //
82302>>>>>>>>>// Copyright 1999 Data Access Corporation, Miami FL, USA                      //
82302>>>>>>>>>// All Rights reserved                                                        //
82302>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.             //
82302>>>>>>>>>//                                                                            //
82302>>>>>>>>>// $Rev History                                                               //
82302>>>>>>>>>//                                                                            //
82302>>>>>>>>>// 25.08.99 Created                                                           //
82302>>>>>>>>>//****************************************************************************//
82302>>>>>>>>>use VDFBase.pkg
82302>>>>>>>>>
82302>>>>>>>>>Class cFormatter is an cObject
82303>>>>>>>>>
82303>>>>>>>>>    Procedure Construct_object
82305>>>>>>>>>        Integer iCh
82305>>>>>>>>>        forward send construct_object
82307>>>>>>>>>        Property String  psCurrencySymbol
82308>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
82309>>>>>>>>>
82309>>>>>>>>>        Property string  psLeft
82310>>>>>>>>>        Property string  psright
82311>>>>>>>>>        Property integer pbThousandsSep
82312>>>>>>>>>        Property integer piPoints
82313>>>>>>>>>
82313>>>>>>>>>        Property string  psCurPosLeft
82314>>>>>>>>>        Property string  psCurPosright
82315>>>>>>>>>        Property integer pbCurPosThousandsSep
82316>>>>>>>>>        Property integer piCurPosPoints
82317>>>>>>>>>
82317>>>>>>>>>        Property string  psCurNegLeft
82318>>>>>>>>>        Property string  psCurNegright
82319>>>>>>>>>        Property integer pbCurNegThousandsSep
82320>>>>>>>>>        Property integer piCurNegPoints
82321>>>>>>>>>
82321>>>>>>>>>        Property string  psNumPosLeft
82322>>>>>>>>>        Property string  psNumPosright
82323>>>>>>>>>        Property integer pbNumPosThousandsSep
82324>>>>>>>>>        Property integer piNumPosPoints
82325>>>>>>>>>
82325>>>>>>>>>        Property string  psNumNegLeft
82326>>>>>>>>>        Property string  psNumNegright
82327>>>>>>>>>        Property integer pbNumNegThousandsSep
82328>>>>>>>>>        Property integer piNumNegPoints
82329>>>>>>>>>
82329>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" true  // currency
82330>>>>>>>>>        Send SetFormat  ",#.*"           false // numeric
82331>>>>>>>>>
82331>>>>>>>>>    end_procedure
82332>>>>>>>>>
82332>>>>>>>>>    // internal
82332>>>>>>>>>    // parse passed format string and set temporary properties with result
82332>>>>>>>>>    //
82332>>>>>>>>>    Procedure ParseFormat string sFmt
82334>>>>>>>>>
82334>>>>>>>>>        string sLeft sRight sDigit
82334>>>>>>>>>        integer bSep iPos i iDigits
82334>>>>>>>>>
82334>>>>>>>>>        // replace any literals. A "/" followed by anything.
82334>>>>>>>>>        // some literals are special. $ . , / #
82334>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
82335>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
82336>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
82337>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
82338>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
82339>>>>>>>>>        Move (Character(9)) to sDigit
82340>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
82341>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
82342>>>>>>>>>
82342>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
82343>>>>>>>>>        If bSep Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
82346>>>>>>>>>
82346>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(self))) to sFmt // replace any $ with currency symbol
82347>>>>>>>>>
82347>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
82348>>>>>>>>>
82348>>>>>>>>>        // Move all the special literals back into place before parsing
82348>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
82349>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
82350>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
82351>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
82352>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
82353>>>>>>>>>
82353>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
82355>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
82356>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
82358>>>>>>>>>               Move -2 to iDigits
82359>>>>>>>>>               increment i
82360>>>>>>>>>            end
82360>>>>>>>>>>
82360>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
82364>>>>>>>>>                 Increment i
82365>>>>>>>>>            end
82366>>>>>>>>>>
82366>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
82367>>>>>>>>>            If (iDigits=0) Move (i-1) to iDigits
82370>>>>>>>>>            //
82370>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
82371>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
82375>>>>>>>>>                 increment i
82376>>>>>>>>>            end
82377>>>>>>>>>>
82377>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
82378>>>>>>>>>        end
82378>>>>>>>>>>
82378>>>>>>>>>        else begin                             // we have no decinal
82379>>>>>>>>>            Move 0 to iDigits                  // so points is none
82380>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
82381>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
82383>>>>>>>>>                Move sFmt to sLeft
82384>>>>>>>>>                Move ""   to sRight
82385>>>>>>>>>            end
82385>>>>>>>>>>
82385>>>>>>>>>            else begin
82386>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
82387>>>>>>>>>                Move 1 to i
82388>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
82392>>>>>>>>>                    Increment i
82393>>>>>>>>>                end
82394>>>>>>>>>>
82394>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
82395>>>>>>>>>            end
82395>>>>>>>>>>
82395>>>>>>>>>        end
82395>>>>>>>>>>
82395>>>>>>>>>        // set temporary format properties and exit
82395>>>>>>>>>        Set pbThousandsSep to bSep
82396>>>>>>>>>        set psLeft         to sLeft
82397>>>>>>>>>        set psRight        to sRight
82398>>>>>>>>>        Set piPoints       to iDigits
82399>>>>>>>>>     End_procedure
82400>>>>>>>>>
82400>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
82400>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
82400>>>>>>>>>    //
82400>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
82400>>>>>>>>>    //
82400>>>>>>>>>    Procedure SetFormat string sFmt integer bCurrency
82402>>>>>>>>>        string sPos sNeg
82402>>>>>>>>>        integer iPos
82402>>>>>>>>>
82402>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
82403>>>>>>>>>        If iPos begin
82405>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
82406>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
82407>>>>>>>>>        end
82407>>>>>>>>>>
82407>>>>>>>>>        else Begin
82408>>>>>>>>>            Move sFmt         to sPos
82409>>>>>>>>>            Move ("-" + sFmt) to sNeg
82410>>>>>>>>>        end
82410>>>>>>>>>>
82410>>>>>>>>>        Send ParseFormat sPos
82411>>>>>>>>>        If bCurrency begin
82413>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(self))
82414>>>>>>>>>            set psCurPosLeft         to (psLeft(self))
82415>>>>>>>>>            set psCurPosRight        to (psRight(self))
82416>>>>>>>>>            Set piCurPosPoints       to (piPoints(self))
82417>>>>>>>>>        End
82417>>>>>>>>>>
82417>>>>>>>>>        else Begin
82418>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(self))
82419>>>>>>>>>            set psNumPosLeft         to (psLeft(self))
82420>>>>>>>>>            set psNumPosRight        to (psRight(self))
82421>>>>>>>>>            Set piNumPosPoints       to (piPoints(self))
82422>>>>>>>>>        end
82422>>>>>>>>>>
82422>>>>>>>>>
82422>>>>>>>>>        Send ParseFormat sNeg
82423>>>>>>>>>        If bCurrency begin
82425>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(self))
82426>>>>>>>>>            set psCurNegLeft         to (psLeft(self))
82427>>>>>>>>>            set psCurNegRight        to (psRight(self))
82428>>>>>>>>>            Set piCurNegPoints       to (piPoints(self))
82429>>>>>>>>>        End
82429>>>>>>>>>>
82429>>>>>>>>>        else Begin
82430>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(self))
82431>>>>>>>>>            set psNumNegLeft         to (psLeft(self))
82432>>>>>>>>>            set psNumNegRight        to (psRight(self))
82433>>>>>>>>>            Set piNumNegPoints       to (piPoints(self))
82434>>>>>>>>>        end
82434>>>>>>>>>>
82434>>>>>>>>>    End_procedure
82435>>>>>>>>>
82435>>>>>>>>>    // low level formatting. Pass parameters
82435>>>>>>>>>    Function Format_Num number nNumber integer iPoints integer bSep ;                       string sPrefix string sSuffix returns string
82437>>>>>>>>>        string  sLeft sRight sNumber sSep sDec
82437>>>>>>>>>        integer bIsNegative iDec iLen iCh
82437>>>>>>>>>
82437>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
82440>>>>>>>>>        Move (Character(iCh)) to sDec
82441>>>>>>>>>
82441>>>>>>>>>        Move (abs(nNumber)) to sNumber
82442>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
82443>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
82444>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
82445>>>>>>>>>        // format for decimal separator
82445>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+repeat("0",iPoints),iPoints)) to sRight
82448>>>>>>>>>
82448>>>>>>>>>        // format for thousand sep.
82448>>>>>>>>>        If bSep Begin
82450>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
82453>>>>>>>>>            Move (Character(iCh)) to sSep
82454>>>>>>>>>            Move (Length(sLeft)) to iLen
82455>>>>>>>>>            While (iLen>3)
82459>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
82460>>>>>>>>>                Move (iLen-3) to iLen
82461>>>>>>>>>            End
82462>>>>>>>>>>
82462>>>>>>>>>        End
82462>>>>>>>>>>
82462>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
82462>>>>>>>>>        If (iPoints>0 OR (iPoints=-2 AND sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
82465>>>>>>>>>        Function_return (sPrefix + sLeft+ sSuffix)
82466>>>>>>>>>    End_Function
82467>>>>>>>>>
82467>>>>>>>>>    // Public: Format for currency
82467>>>>>>>>>    //
82467>>>>>>>>>    Function FormatCur number nNumber integer iPoints returns string
82469>>>>>>>>>        string  sLeft sRight
82469>>>>>>>>>        integer bSep
82469>>>>>>>>>        If (nNumber<0) Begin
82471>>>>>>>>>            get pbCurNegThousandsSep to bSep
82472>>>>>>>>>            get psCurNegLeft         to sLeft
82473>>>>>>>>>            get psCurNegRight        to sRight
82474>>>>>>>>>            If (iPoints=-1) get piCurNegPoints       to iPoints
82477>>>>>>>>>        end
82477>>>>>>>>>>
82477>>>>>>>>>        Else Begin
82478>>>>>>>>>            get pbCurPosThousandsSep to bSep
82479>>>>>>>>>            get psCurPosLeft         to sLeft
82480>>>>>>>>>            get psCurPosRight        to sRight
82481>>>>>>>>>            If (iPoints=-1) get piCurPosPoints       to iPoints
82484>>>>>>>>>        end
82484>>>>>>>>>>
82484>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
82485>>>>>>>>>    End_function
82486>>>>>>>>>
82486>>>>>>>>>    // Public: Format for numeric
82486>>>>>>>>>    //
82486>>>>>>>>>    Function FormatNum number nNumber integer iPoints returns string
82488>>>>>>>>>        string  sLeft sRight
82488>>>>>>>>>        integer bSep
82488>>>>>>>>>        If (nNumber<0) Begin
82490>>>>>>>>>            get pbNumNegThousandsSep to bSep
82491>>>>>>>>>            get psNumNegLeft         to sLeft
82492>>>>>>>>>            get psNumNegRight        to sRight
82493>>>>>>>>>            If (iPoints=-1) get piNumNegPoints       to iPoints
82496>>>>>>>>>        end
82496>>>>>>>>>>
82496>>>>>>>>>        Else Begin
82497>>>>>>>>>            get pbNumPosThousandsSep to bSep
82498>>>>>>>>>            get psNumPosLeft         to sLeft
82499>>>>>>>>>            get psNumPosRight        to sRight
82500>>>>>>>>>            If (iPoints=-1) get piNumPosPoints       to iPoints
82503>>>>>>>>>        end
82503>>>>>>>>>>
82503>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
82504>>>>>>>>>    End_function
82505>>>>>>>>>
82505>>>>>>>>>
82505>>>>>>>>>    // Public: Format passing format string
82505>>>>>>>>>    //
82505>>>>>>>>>    Function FormatVal number nNumber string sFmt returns string
82507>>>>>>>>>        integer iPos bIsNeg
82507>>>>>>>>>        string  sLeft sRight
82507>>>>>>>>>        integer iPoints bSep
82507>>>>>>>>>        Move (nNumber<0) to bIsNeg
82508>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
82509>>>>>>>>>        Case Begin
82509>>>>>>>>>            Case (iPos and Not(bIsNeg))      Move (left(sFmt,iPos-1))    to sFmt
82512>>>>>>>>>            Case (iPos and bIsNeg)           Move (mid(sFmt,255,iPos+1)) to sFmt
82516>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) Move sFmt                   to sFmt
82520>>>>>>>>>            Case else                        Move ("-" + sFmt)           to sFmt
82522>>>>>>>>>        case end
82522>>>>>>>>>        Send ParseFormat sFmt
82523>>>>>>>>>        get pbThousandsSep to bSep
82524>>>>>>>>>        get psLeft         to sLeft
82525>>>>>>>>>        get psRight        to sRight
82526>>>>>>>>>        get piPoints       to iPoints
82527>>>>>>>>>        Function_return (Format_Num(self, nNumber,iPoints,bSep,sLeft,sRight))
82528>>>>>>>>>    end_function
82529>>>>>>>>>
82529>>>>>>>>>End_Class
82530>>>>>>>
82530>>>>>>>// for now, this object is private. All access is through the following
82530>>>>>>>// global functions
82530>>>>>>>
82530>>>>>>>//Object oFmt is a cFormatter
82530>>>>>>>//end_object
82530>>>>>>>
82530>>>>>>>Global_variable handle ghoFormatter
82530>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
82531>>>>>>>
82531>>>>>>>Function FormatNumber Global number nNum integer iPoints returns string
82533>>>>>>>    Function_return (FormatNum(ghoFormatter, nNum,iPoints))
82534>>>>>>>end_function
82535>>>>>>>
82535>>>>>>>Function FormatCurrency Global number nNum integer iPoints returns string
82537>>>>>>>    Function_return (FormatCur(ghoFormatter, nNum,iPoints))
82538>>>>>>>end_function
82539>>>>>>>
82539>>>>>>>Function FormatValue Global number nNum string sFmt returns string
82541>>>>>>>    Function_return (FormatVal(ghoFormatter, nNum,sFmt))
82542>>>>>>>end_function
82543>>>>>>>
82543>>>>>>>Procedure SetCurrencyFormat Global string sFmt
82545>>>>>>>    Send SetFormat of ghoFormatter sFmt True
82546>>>>>>>end_function
82547>>>>>>>
82547>>>>>>>Procedure SetNumberFormat Global string sFmt
82549>>>>>>>    Send SetFormat of ghoFormatter sFmt False
82550>>>>>>>end_function
82551>>>>>>>
82551>>>>>Use MapiDllCalls.Pkg
Including file: MapiDllCalls.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiDllCalls.Pkg)
82551>>>>>>>Use MapiConstants.Pkg
Including file: MapiConstants.Pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MapiConstants.Pkg)
82551>>>>>>>>>Type MapiSession
82551>>>>>>>>>   Field MapiSession.SessionID As Integer
82551>>>>>>>>>End_type // MapiSession
82551>>>>>>>>>
82551>>>>>>>>>Type MapiMessagePointer
82551>>>>>>>>>   Field MapiMessagePointer.lppMessage As Pointer
82551>>>>>>>>>End_Type // MapiMessagePointer
82551>>>>>>>>>
82551>>>>>>>>>Type MapiRecipPointer
82551>>>>>>>>>   Field MapiRecipPointer.lppRecip As Pointer
82551>>>>>>>>>End_Type // MapiRecipPointer
82551>>>>>>>>>
82551>>>>>>>>>Type MapiNewRecipsPointer
82551>>>>>>>>>   Field MapiNewRecipsPointer.lppNewRecips As Pointer
82551>>>>>>>>>End_Type // MapiNewRecipsPointer
82551>>>>>>>>>
82551>>>>>>>>>Type MapiNewRecipsCounter
82551>>>>>>>>>   Field MapiNewRecipsCounter.lpnNewRecips As Integer
82551>>>>>>>>>End_Type // MapiNewRecipsCounter
82551>>>>>>>>>
82551>>>>>>>>>Type MapiFileDesc
82551>>>>>>>>>   Field MapiFileDesc.ulReserved As Integer      // Reserved for future use (must be 0)
82551>>>>>>>>>   Field MapiFileDesc.flFlags As Integer         // Flags
82551>>>>>>>>>   Field MapiFileDesc.nPosition As Integer       // character in text to be replaced by attachment
82551>>>>>>>>>   Field MapiFileDesc.lpszPathName As Pointer    // Full path name of attachment file
82551>>>>>>>>>   Field MapiFileDesc.lpszFileName As Pointer    // Original file name (optional)
82551>>>>>>>>>   Field MapiFileDesc.lpFileType As Pointer     // Attachment file type (can be lpMapiFileTagExt)
82551>>>>>>>>>End_Type // MapiFileDesc
82551>>>>>>>>>
82551>>>>>>>>>Define MAPI_OLE        For |CI$00000001
82551>>>>>>>>>Define MAPI_OLE_STATIC For |CI$00000002
82551>>>>>>>>>
82551>>>>>>>>>Define MAPI_NOATTACHMENT_POSITION For |CI$FFFFFFFF
82551>>>>>>>>>
82551>>>>>>>>>Type MapiFileTagExt
82551>>>>>>>>>   Field MapiFileTagExt.ulReserved As Integer  // Reserved, must be zero.
82551>>>>>>>>>   Field MapiFileTagExt.cbTag As Integer       // Size (in bytes) of
82551>>>>>>>>>   Field MapiFileTagExt.lpTag As Pointer       // X.400 OID for this attachment type
82551>>>>>>>>>   Field MapiFileTagExt.cbEncoding As Integer  // Size (in bytes) of
82551>>>>>>>>>   Field MapiFileTagExt.lpEncoding As Pointer  // X.400 OID for this attachment's encoding
82551>>>>>>>>>End_Type // MapiFileTagExt
82551>>>>>>>>>
82551>>>>>>>>>Type MapiRecipDesc
82551>>>>>>>>>   Field MapiRecipDesc.ulReserved As Integer   // Reserved for future use
82551>>>>>>>>>   Field MapiRecipDesc.ulRecipClass As Integer // Recipient class
82551>>>>>>>>>                                               // MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG
82551>>>>>>>>>   Field MapiRecipDesc.lpszName As Pointer     // Recipient name
82551>>>>>>>>>   Field MapiRecipDesc.lpszAddress As Pointer  // Recipient address (optional)
82551>>>>>>>>>   Field MapiRecipDesc.ulEIDSize As Pointer    // Count in bytes of size of pEntryID
82551>>>>>>>>>   Field MapiRecipDesc.lpEntryID As Pointer    // System-specific recipient reference
82551>>>>>>>>>End_Type // MapiRecipDesc
82551>>>>>>>>>
82551>>>>>>>>>Define MAPI_ORIG   For 0 // Recipient is message originator
82551>>>>>>>>>Define MAPI_TO     For 1 // Recipient is a primary recipient
82551>>>>>>>>>Define MAPI_CC     For 2 // Recipient is a copy recipient
82551>>>>>>>>>Define MAPI_BCC    For 3 // Recipient is blind copy recipient
82551>>>>>>>>>
82551>>>>>>>>>Type MapiMessage
82551>>>>>>>>>   Field MapiMessage.ulReserved As Integer                   // Reserved for future use (M.B. 0)
82551>>>>>>>>>   Field MapiMessage.lpszSubject As Pointer                  // Message Subject
82551>>>>>>>>>   Field MapiMessage.lpszNoteText As Pointer                 // Message Text
82551>>>>>>>>>   Field MapiMessage.lpszMessageType As Pointer              // Message Class
82551>>>>>>>>>   Field MapiMessage.lpszDateReceived As Pointer             // in YYYY/MM/DD HH:MM format
82551>>>>>>>>>   Field MapiMessage.lpszConversationID As Pointer           // conversation thread ID
82551>>>>>>>>>   Field MapiMessage.flFlags As Integer                      // unread,return receipt
82551>>>>>>>>>   Field MapiMessage.lpOriginator As Pointer                 // Originator descriptor
82551>>>>>>>>>   Field MapiMessage.nRecipCount As Integer                  // Number of recipients
82551>>>>>>>>>   Field MapiMessage.lpRecips As Pointer                     // Recipient descriptors
82551>>>>>>>>>   Field MapiMessage.nFileCount As Integer                   // # of file attachments
82551>>>>>>>>>   Field MapiMessage.lpFiles As Pointer                      // Attachment descriptors
82551>>>>>>>>>End_Type // MapiMessage
82551>>>>>>>>>
82551>>>>>>>>>Define MAPI_UNREAD            For |CI$00000001
82551>>>>>>>>>Define MAPI_RECEIPT_REQUESTED For |CI$00000002
82551>>>>>>>>>Define MAPI_SENT              For |CI$00000004
82551>>>>>>>>>
82551>>>>>>>>>// MAPILogon() flags.
82551>>>>>>>>>Define MAPI_LOGON_UI         For |CI$00000001 // Display logon UI
82551>>>>>>>>>Define MAPI_PASSWORD_UI      For |CI$00020000 // prompt for password only
82551>>>>>>>>>Define MAPI_NEW_SESSION      For |CI$00000002 // Don't use shared session
82551>>>>>>>>>Define MAPI_FORCE_DOWNLOAD   For |CI$00001000 // Get new mail before return
82551>>>>>>>>>Define MAPI_ALLOW_OTHERS     For |CI$00000008 // Make this a shared session
82551>>>>>>>>>Define MAPI_EXPLICIT_PROFILE For |CI$00000010 // Don't use default profile
82551>>>>>>>>>Define MAPI_EXTENDED         For |CI$00000020 // Extended MAPI Logon
82551>>>>>>>>>Define MAPI_USE_DEFAULT      For |CI$00000040 // Use default profile in logon
82551>>>>>>>>>
82551>>>>>>>>>Define MAPI_SIMPLE_DEFAULT  For (MAPI_LOGON_UI + MAPI_FORCE_DOWNLOAD + MAPI_ALLOW_OTHERS)
82551>>>>>>>>>Define MAPI_SIMPLE_EXPLICIT For (MAPI_NEW_SESSION + MAPI_FORCE_DOWNLOAD + MAPI_EXPLICIT_PROFILE)
82551>>>>>>>>>
82551>>>>>>>>>// MAPILogoff() flags.
82551>>>>>>>>>Define MAPI_LOGOFF_SHARED For |CI$00000001 // Close all shared sessions
82551>>>>>>>>>Define MAPI_LOGOFF_UI     For |CI$00000002 // It's OK to present UI
82551>>>>>>>>>
82551>>>>>>>>>// MAPISendMail() flags.
82551>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82551>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82551>>>>>>>>>
82551>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Display a send note UI
82551>>>>>>>>>Define MAPI_USE_DEFAULT For |CI$00000040 // Use default profile in logon
82551>>>>>>>>>
82551>>>>>>>>>// MAPIFindNext() flags.
82551>>>>>>>>>Define MAPI_UNREAD_ONLY    For |CI$00000020 // Only unread messages
82551>>>>>>>>>Define MAPI_GUARANTEE_FIFO For |CI$00000100 // use date order
82551>>>>>>>>>Define MAPI_LONG_MSGID     For |CI$00004000 // allow 512 char returned ID
82551>>>>>>>>>
82551>>>>>>>>>// MAPIReadMail() flags.
82551>>>>>>>>>Define MAPI_PEEK            For |CI$00000080 // Do not mark as read.
82551>>>>>>>>>Define MAPI_SUPPRESS_ATTACH For |CI$00000800 // header + body, no files
82551>>>>>>>>>Define MAPI_ENVELOPE_ONLY   For |CI$00000040 // Only header information
82551>>>>>>>>>Define MAPI_BODY_AS_FILE    For |CI$00000200
82551>>>>>>>>>
82551>>>>>>>>>// MAPISaveMail() flags.
82551>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82551>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82551>>>>>>>>>Define MAPI_LONG_MSGID  For |CI$00004000 // allow 512 char returned ID
82551>>>>>>>>>
82551>>>>>>>>>// MAPIAddress() flags.
82551>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82551>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82551>>>>>>>>>
82551>>>>>>>>>// MAPIDetails() flags.
82551>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82551>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82551>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
82551>>>>>>>>>
82551>>>>>>>>>// MAPIResolveName() flags.
82551>>>>>>>>>Define MAPI_LOGON_UI    For |CI$00000001 // Display logon UI
82551>>>>>>>>>Define MAPI_NEW_SESSION For |CI$00000002 // Don't use shared session
82551>>>>>>>>>Define MAPI_DIALOG      For |CI$00000008 // Prompt for choices if ambiguous
82551>>>>>>>>>Define MAPI_AB_NOMODIFY For |CI$00000400 // Don't allow mods of AB entries
82551>>>>>>>>>
82551>>>>>>>>>Define SUCCESS_SUCCESS                 For 0
82551>>>>>>>>>Define MAPI_USER_ABORT                 For 1
82551>>>>>>>>>Define MAPI_E_USER_ABORT               For MAPI_USER_ABORT
82551>>>>>>>>>Define MAPI_E_FAILURE                  For 2
82551>>>>>>>>>Define MAPI_E_LOGON_FAILURE            For 3
82551>>>>>>>>>Define MAPI_E_LOGIN_FAILURE            For MAPI_E_LOGON_FAILURE
82551>>>>>>>>>Define MAPI_E_DISK_FULL                For 4
82551>>>>>>>>>Define MAPI_E_INSUFFICIENT_MEMORY      For 5
82551>>>>>>>>>Define MAPI_E_ACCESS_DENIED            For 6
82551>>>>>>>>>Define MAPI_E_TOO_MANY_SESSIONS        For 8
82551>>>>>>>>>Define MAPI_E_TOO_MANY_FILES           For 9
82551>>>>>>>>>Define MAPI_E_TOO_MANY_RECIPIENTS      For 10
82551>>>>>>>>>Define MAPI_E_ATTACHMENT_NOT_FOUND     For 11
82551>>>>>>>>>Define MAPI_E_ATTACHMENT_OPEN_FAILURE  For 12
82551>>>>>>>>>Define MAPI_E_ATTACHMENT_WRITE_FAILURE For 13
82551>>>>>>>>>Define MAPI_E_UNKNOWN_RECIPIENT        For 14
82551>>>>>>>>>Define MAPI_E_BAD_RECIPTYPE            For 15
82551>>>>>>>>>Define MAPI_E_NO_MESSAGES              For 16
82551>>>>>>>>>Define MAPI_E_INVALID_MESSAGE          For 17
82551>>>>>>>>>Define MAPI_E_TEXT_TOO_LARGE           For 18
82551>>>>>>>>>Define MAPI_E_INVALID_SESSION          For 19
82551>>>>>>>>>Define MAPI_E_TYPE_NOT_SUPPORTED       For 20
82551>>>>>>>>>Define MAPI_E_AMBIGUOUS_RECIPIENT      For 21
82551>>>>>>>>>Define MAPI_E_AMBIG_RECIP              For MAPI_E_AMBIGUOUS_RECIPIENT
82551>>>>>>>>>Define MAPI_E_MESSAGE_IN_USE           For 22
82551>>>>>>>>>Define MAPI_E_NETWORK_FAILURE          For 23
82551>>>>>>>>>Define MAPI_E_INVALID_EDITFIELDS       For 24
82551>>>>>>>>>Define MAPI_E_INVALID_RECIPS           For 25
82551>>>>>>>>>Define MAPI_E_NOT_SUPPORTED            For 26
82551>>>>>>>Use WinKern.pkg
82551>>>>>>>
82551>>>>>>>External_Function MAPILogon "MAPILogon" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszProfileName ;   Pointer lpszPassword ;   Integer flFlags ;   Integer ulReserved ;   Pointer lplhSession ;   Returns Integer
82552>>>>>>>External_Function MAPILogoff "MAPILogoff" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
82553>>>>>>>External_Function MAPIFindNext "MAPIFindNext" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageType ;   Pointer lpszSeedMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
82554>>>>>>>External_Function MAPIFreeBuffer "MAPIFreeBuffer" Mapi32.Dll ;   Pointer pv ;   Returns Integer
82555>>>>>>>External_Function MAPIReadMail "MAPIReadMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppMessage ;   Returns Integer
82556>>>>>>>External_Function MAPIAddress "MAPIAddress" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszCaption ;   Integer nEditFields ;   Pointer lpszLabels ;   Integer nRecips ;   Pointer lpRecips ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpnNewRecips ;   Pointer lppNewRecips ;   Returns Integer
82557>>>>>>>External_Function MAPIResolveName "MAPIResolveName" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszName ;   Integer flFlags ;   Integer ulReserved ;   Pointer lppRecip ;   Returns Integer
82558>>>>>>>External_Function MAPISendMail "MAPISendMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
82559>>>>>>>External_Function MAPISaveMail "MAPISaveMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpMessage ;   Integer flFlags ;   Integer ulReserved ;   Pointer lpszMessageID ;   Returns Integer
82560>>>>>>>External_Function MAPIDeleteMail "MAPIDeleteMail" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpszMessageID ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
82561>>>>>>>External_Function MAPISendDocuments "MAPISendDocuments" Mapi32.Dll ;   Integer ulUIParam ;   Pointer lpszDelimChar ;   Pointer lpszFullPaths ;   Pointer lpszFileNames ;   Integer ulReserved ;   Returns Integer
82562>>>>>>>External_Function MAPIDetails "MAPIDetails" Mapi32.Dll ;   Integer lhSession ;   Integer ulUIParam ;   Pointer lpRecip ;   Integer flFlags ;   Integer ulReserved ;   Returns Integer
82563>>>>>>>
82563>>>>>>>External_Function ShellExecute "ShellExecuteA" Shell32.Dll ;   Handle hwnd ;   String sOperation ;   String sFile ;   String sParameters ;   String sDirectory ;   Integer nShowCmd ;   Returns VOID_TYPE
82564>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.0\Pkg\DFBTRDRV.PKG)
82564>>>>>>>//****************************************************************************
82564>>>>>>>//
82564>>>>>>>// $File name  : DFBTRDRV.PKG
82564>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
82564>>>>>>>// Notice      : This package contains constants and commands, used to call
82564>>>>>>>//               specific functions in the DFBTRDRV.
82564>>>>>>>// $Author(s)  : Eddy Kleinjan
82564>>>>>>>//
82564>>>>>>>// $System     : DataFlex Connectivity Kit for Pervasive.SQL
82564>>>>>>>// Created     : 01-07-97 @ 12:00:00
82564>>>>>>>//
82564>>>>>>>// Changed     : 04-04-2001.
82564>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.145
82564>>>>>>>//
82564>>>>>>>// Changed     : June 6, 2001
82564>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.148
82564>>>>>>>//
82564>>>>>>>//               Added DFBTR_DDF_OWNER command.
82564>>>>>>>//
82564>>>>>>>// Changed     : June 12, 2001
82564>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 1.3.0.149
82564>>>>>>>//
82564>>>>>>>//               Added DF_FIELD_IS_NULL and DF_FIELD_NULL_ALLOWED attributes
82564>>>>>>>//
82564>>>>>>>// Changed     : August 4, 2004
82564>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.1
82564>>>>>>>//
82564>>>>>>>//               Added cDfbtrdrvHandler class.
82564>>>>>>>//               New functions in this class:
82564>>>>>>>//                  Function CKRevision Returns String
82564>>>>>>>//                  Function CkUsesUri Returns Integer
82564>>>>>>>//                  Function PSQLRequesterVersionInfo Integer iFileNum Returns String
82564>>>>>>>//                  Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
82564>>>>>>>//                  Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
82564>>>>>>>//
82564>>>>>>>// Changed     : September 30, 2005
82564>>>>>>>//               DataFlex Connectity Kit for Pervasive.SQL version 3.0.0.14
82564>>>>>>>//
82564>>>>>>>//               Bugfix: Prevent compiler errors when no (df)error.pkg is used
82564>>>>>>>//****************************************************************************
82564>>>>>>>Use Ui
82564>>>>>>>//
82564>>>>>>>// Driver Indentification
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//*** Driver attributes
82564>>>>>>>//
82564>>>>>>>// Call_Driver functions ID's
82564>>>>>>>//
82564>>>>>>>//
82564>>>>>>>// DFBTRFN_CONVERT_FILE options
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// DFBTRFN_SET_OWNER options
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to create all vars which may be needed
82564>>>>>>>// in other commands.
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to set the owner of a Btrieve file.
82564>>>>>>>// File must have been opened.
82564>>>>>>>// Filenumber needs to be passed.
82564>>>>>>>// To clear set the owner to "".
82564>>>>>>>// Examples:
82564>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
82564>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
82564>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
82564>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
82564>>>>>>>// To clear:
82564>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to parse DFBTR_SET_OWNVER
82564>>>>>>>// options.
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to parse for Callback
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to clear the owner of a Btrieve file.
82564>>>>>>>// File must have been opened.
82564>>>>>>>// Filenumber needs to be passed.
82564>>>>>>>// Examples:
82564>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to add a owner name to the internal list of ownernames
82564>>>>>>>// which will be tries when opening files.
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to remove all owners from the internal list of ownernames
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to set the owner name to be used when opening the DDF files.
82564>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
82564>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
82564>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to change the transaction type.
82564>>>>>>>// Valid types are:
82564>>>>>>>//     DFBTRTT_NONE
82564>>>>>>>//     DFBTRTT_EXCLUSIVE
82564>>>>>>>//     DFBTRTT_CONCURRENT
82564>>>>>>>//
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to get the current transaction type.
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to set explicit_locking
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to get explicit locking
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//
82564>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
82564>>>>>>>//
82564>>>>>>>
82564>>>>>>>//*****************************************************************************
82564>>>>>>>//*** Class  : cDfbtrdrvHandler                                                  ***
82564>>>>>>>//*** Purpose: An instance of this class can be used as a broker object to  ***
82564>>>>>>>//***          call several Dfbtrdrv releated methods.                           ***
82564>>>>>>>//*****************************************************************************
82564>>>>>>>
82564>>>>>>>Class cDFBtrDrvHandler Is An Array
82565>>>>>>>
82565>>>>>>>    Procedure Construct_Object Integer iImage
82567>>>>>>>        Forward Send Construct_object iImage
82569>>>>>>>
82569>>>>>>>        Property String  psDriverID       Public "DFBTRDRV"
82570>>>>>>>    End_Procedure // Construct_Object
82571>>>>>>>
82571>>>>>>>
82571>>>>>>>
82571>>>>>>>    //***
82571>>>>>>>    //*** Function: CKRevsion
82571>>>>>>>    //*** Purpose : The revsion of a Dfbtrdrv Connectivity Kit
82571>>>>>>>    //***
82571>>>>>>>
82571>>>>>>>    Function CKRevision Returns String
82573>>>>>>>        Local String  sDriverID
82573>>>>>>>        Local String  sRevision
82573>>>>>>>        Local String  sVoid
82573>>>>>>>        Local Integer iRetval
82573>>>>>>>
82573>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82573>>>>>>>        // This error would otherwise be raised when we have an older
82573>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82573>>>>>>>        Send Ignore_error To Error_object_Id 20491
82574>>>>>>>        Get psDriverID To sDriverID
82575>>>>>>>        Move (Repeat(" ", 255)) To sRevision
82576>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
82581>>>>>>>        Send Trap_Error To Error_object_Id 20491
82582>>>>>>>        If (Trim(sRevision) = "") Begin
82584>>>>>>>            // Unable to get the revision. return all zeroes.
82584>>>>>>>            Move "0.0.0.0" To sRevision
82585>>>>>>>        End
82585>>>>>>>>
82585>>>>>>>        Function_Return sRevision
82586>>>>>>>    End_Function // CKRevision
82587>>>>>>>
82587>>>>>>>    Function CkUsesUri Returns Integer
82589>>>>>>>        Local String  sDriverID
82589>>>>>>>        Local String  sVoid1
82589>>>>>>>        Local String  sVoid2
82589>>>>>>>        Local Integer iRetval
82589>>>>>>>
82589>>>>>>>        Get psDriverID To sDriverID
82590>>>>>>>
82590>>>>>>>        Move 0 To iRetval
82591>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82591>>>>>>>        // This error would otherwise be raised when we have an older
82591>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
82591>>>>>>>        Send Ignore_error To Error_object_Id 20491
82592>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
82597>>>>>>>        Send Trap_Error To Error_object_Id 20491
82598>>>>>>>
82598>>>>>>>        Function_Return iRetval
82599>>>>>>>    End_Function // CKUsesUri
82600>>>>>>>
82600>>>>>>>
82600>>>>>>>
82600>>>>>>>    //***
82600>>>>>>>    //*** Function: ExtractPartFromRevsion
82600>>>>>>>    //*** Purpose : Extarct the Nth part of a a.b.c.d revsion string.
82600>>>>>>>    //***
82600>>>>>>>    //*** Returns : The part version number or -1 if there is no such part number.
82600>>>>>>>    //***
82600>>>>>>>
82600>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
82602>>>>>>>        Local Integer iPartRev
82602>>>>>>>        Local Integer iCurrentPart
82602>>>>>>>        Local Integer iSeparatorPos
82602>>>>>>>
82602>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
82605>>>>>>>
82605>>>>>>>        Move 0 To iCurrentPart
82606>>>>>>>        Repeat
82606>>>>>>>>
82606>>>>>>>            Move (Pos(".", sRevision)) To iSeparatorPos
82607>>>>>>>            If (iSeparatorPos > 0) Begin
82609>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) To iPartRev
82610>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) To sRevision
82611>>>>>>>                Increment iCurrentPart
82612>>>>>>>            End
82612>>>>>>>>
82612>>>>>>>            Else If (sRevision <> "") Begin
82615>>>>>>>                Move sRevision To iPartRev
82616>>>>>>>                Move "" To sRevision
82617>>>>>>>                Increment iCurrentPart
82618>>>>>>>            End
82618>>>>>>>>
82618>>>>>>>            Else ;                Move -1 To iPartRev
82620>>>>>>>        Until (iCurrentPart >= iPartNum Or iPartRev = -1)
82622>>>>>>>
82622>>>>>>>        Function_Return iPartRev
82623>>>>>>>    End_Function // EcxtractPartFromRevision
82624>>>>>>>
82624>>>>>>>
82624>>>>>>>
82624>>>>>>>    //***
82624>>>>>>>    //*** Function: CKMajorRevision
82624>>>>>>>    //*** Purpose : Returns the major revision of the CK
82624>>>>>>>    //***
82624>>>>>>>
82624>>>>>>>    Function CKMajorRevision Returns Integer
82626>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
82627>>>>>>>    End_Function // CKMajorRevision
82628>>>>>>>
82628>>>>>>>
82628>>>>>>>
82628>>>>>>>    //***
82628>>>>>>>    //*** Function: CKMinorRevision
82628>>>>>>>    //*** Purpose : Returns the minor revision of the CK
82628>>>>>>>    //***
82628>>>>>>>
82628>>>>>>>    Function CKMinorRevision Returns Integer
82630>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
82631>>>>>>>    End_Function // CKMinorRevision
82632>>>>>>>
82632>>>>>>>
82632>>>>>>>
82632>>>>>>>    //***
82632>>>>>>>    //*** Function: CKReleaseRevision
82632>>>>>>>    //*** Purpose : Returns the release revision of the CK
82632>>>>>>>    //***
82632>>>>>>>
82632>>>>>>>    Function CKReleaseRevision Returns Integer
82634>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
82635>>>>>>>    End_Function // CKReleaseRevision
82636>>>>>>>
82636>>>>>>>
82636>>>>>>>
82636>>>>>>>    //***
82636>>>>>>>    //*** Function: CKBuildRevision
82636>>>>>>>    //*** Purpose : Returns the major revision of the CK
82636>>>>>>>    //***
82636>>>>>>>
82636>>>>>>>    Function CKBuildRevision Returns Integer
82638>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
82639>>>>>>>    End_Function // CKBuildRevision
82640>>>>>>>
82640>>>>>>>
82640>>>>>>>
82640>>>>>>>    //***
82640>>>>>>>    //*** Function: IsMinimalRevision
82640>>>>>>>    //*** Purpose : Determines if the CK conforms to a passed minimal revsion.
82640>>>>>>>    //***
82640>>>>>>>
82640>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
82642>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_return (TRUE)
82645>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
82648>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_return (TRUE)
82651>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
82654>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_return (TRUE)
82657>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) And iBuild <= CKBuildRevision(Current_object)) ;                    Function_return (TRUE)
82661>>>>>>>            End
82661>>>>>>>>
82661>>>>>>>        End
82661>>>>>>>>
82661>>>>>>>
82661>>>>>>>        Function_Return (FALSE)
82662>>>>>>>    End_Function // IsMinimalRevision
82663>>>>>>>
82663>>>>>>>    //   Functions to query the Pervasive.SQL version:
82663>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
82663>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
82663>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
82663>>>>>>>    //
82663>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
82663>>>>>>>    //   in the following format:
82663>>>>>>>    //       <version>.<revision>.<type>
82663>>>>>>>    //   possible values for <type>:
82663>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
82663>>>>>>>    //         server using Workgroup authentication mode
82663>>>>>>>    //       C for client cache engine
82663>>>>>>>    //       D for DOS workstation
82663>>>>>>>    //       N for client Requester
82663>>>>>>>    //       S for NetWare server
82663>>>>>>>    //       T for 32-bit Windows server engine
82663>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
82663>>>>>>>    //
82663>>>>>>>    //   example:
82663>>>>>>>    //       8.50.T
82663>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
82663>>>>>>>    //   32-bits Windows server.
82663>>>>>>>    //
82663>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
82663>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
82663>>>>>>>    //
82663>>>>>>>    //   If the version information is not available or can not be obtained
82663>>>>>>>    //   the functions will return "0.0.0"
82663>>>>>>>
82663>>>>>>>
82663>>>>>>>    //***
82663>>>>>>>    //*** Function: PSQLRequesterVersionInfo
82663>>>>>>>    //*** Purpose : Returns the version information of the
82663>>>>>>>    //***           Pervasive.SQL Client requester.
82663>>>>>>>
82663>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
82665>>>>>>>
82665>>>>>>>        Local String  sDriverID
82665>>>>>>>        Local String  sVersion
82665>>>>>>>        Local String  sVoid
82665>>>>>>>        Local Integer iRetval
82665>>>>>>>
82665>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82665>>>>>>>        // This error would otherwise be raised when we have an older
82665>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82665>>>>>>>        Send Ignore_error To Error_object_Id 20491
82666>>>>>>>        Get psDriverID To sDriverID
82667>>>>>>>        Move (Repeat(" ", 255)) To sVersion
82668>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
82673>>>>>>>        Send Trap_Error To Error_object_Id 20491
82674>>>>>>>        If (Trim(sVersion) = "") Begin
82676>>>>>>>            // Unable to get the revision. return all zeroes.
82676>>>>>>>            Move "0.0.0" To sVersion
82677>>>>>>>        End
82677>>>>>>>>
82677>>>>>>>        Function_Return sVersion
82678>>>>>>>    End_Function //  PSQLRequesterVersion
82679>>>>>>>
82679>>>>>>>    //***
82679>>>>>>>    //*** Function: PSQLLocalEngineVersionInfo
82679>>>>>>>    //*** Purpose : Returns the version information of the
82679>>>>>>>    //***           Pervasive.SQL Local Engine
82679>>>>>>>
82679>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
82681>>>>>>>
82681>>>>>>>        Local String  sDriverID
82681>>>>>>>        Local String  sVersion
82681>>>>>>>        Local String  sVoid
82681>>>>>>>        Local Integer iRetval
82681>>>>>>>
82681>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82681>>>>>>>        // This error would otherwise be raised when we have an older
82681>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82681>>>>>>>        Send Ignore_error To Error_object_Id 20491
82682>>>>>>>        Get psDriverID To sDriverID
82683>>>>>>>        Move (Repeat(" ", 255)) To sVersion
82684>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
82689>>>>>>>        Send Trap_Error To Error_object_Id 20491
82690>>>>>>>        If (Trim(sVersion) = "") Begin
82692>>>>>>>            // Unable to get the revision. return all zeroes.
82692>>>>>>>            Move "0.0.0" To sVersion
82693>>>>>>>        End
82693>>>>>>>>
82693>>>>>>>        Function_Return sVersion
82694>>>>>>>    End_Function //  PSQLLocalEngineVersion
82695>>>>>>>
82695>>>>>>>    //***
82695>>>>>>>    //*** Function: PSQLServerEngineVersionInfo
82695>>>>>>>    //*** Purpose : Returns the version information of the
82695>>>>>>>    //***           Pervasive.SQL Server Engine
82695>>>>>>>
82695>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
82697>>>>>>>
82697>>>>>>>        Local String  sDriverID
82697>>>>>>>        Local String  sVersion
82697>>>>>>>        Local String  sVoid
82697>>>>>>>        Local Integer iRetval
82697>>>>>>>
82697>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
82697>>>>>>>        // This error would otherwise be raised when we have an older
82697>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
82697>>>>>>>        Send Ignore_error To Error_object_Id 20491
82698>>>>>>>        Get psDriverID To sDriverID
82699>>>>>>>        Move (Repeat(" ", 255)) To sVersion
82700>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
82705>>>>>>>        Send Trap_Error To Error_object_Id 20491
82706>>>>>>>        If (Trim(sVersion) = "") Begin
82708>>>>>>>            // Unable to get the revision. return all zeroes.
82708>>>>>>>            Move "0.0.0" To sVersion
82709>>>>>>>        End
82709>>>>>>>>
82709>>>>>>>        Function_Return sVersion
82710>>>>>>>    End_Function //  PSQLServerEngineVersion
82711>>>>>>>
82711>>>>>>>End_Class // cDfbtrdrvHandler
82712>>>>>>>
82712>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\MSSqldrv.pkg)
82712>>>>>>>//*****************************************************************************
82712>>>>>>>//*** MSSQLDRV.PKG                                                          ***
82712>>>>>>>//***                                                                       ***
82712>>>>>>>//*** Author: Ben Weijers                                                   ***
82712>>>>>>>//***         Data Access Nederland                                         ***
82712>>>>>>>//***         29 June 1998                                                  ***
82712>>>>>>>//***                                                                       ***
82712>>>>>>>//***                                                                       ***
82712>>>>>>>//*** Purpose:                                                              ***
82712>>>>>>>//***   Package that declares MS SQL driver constants and functions.        ***
82712>>>>>>>//****                                                                      ***
82712>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
82712>>>>>>>//***   MS SQL Client specific code to a DataFlex application.              ***
82712>>>>>>>//***   Updated:  June 4th 2012 (Current CK build: 5.1.0.96)                ***
82712>>>>>>>//***             Changed EnumerateServers function to use the highest      ***
82712>>>>>>>//***             available SQL Server client driver.                       ***
82712>>>>>>>//***             Moved SQL Server client constants from cli.pkg to         ***
82712>>>>>>>//***             mssqldrv.pkg                                              ***
82712>>>>>>>//***   Updated:  November 6th 2013 (Current CK build: 6.0.0.19)            ***
82712>>>>>>>//***             Added constants for SQL Server specific native types      ***
82712>>>>>>>//***             ( var...(max) types, money types, datetime types)         ***
82712>>>>>>>//*****************************************************************************
82712>>>>>>>
82712>>>>>>>Use Cli.pkg
82712>>>>>>>Use SQL.pkg
82712>>>>>>>
82712>>>>>>>//*** Driver Indentification
82712>>>>>>>
82712>>>>>>>//*** Error number constants
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>//*** Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>// SQL Server spcific types. 
82712>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
82712>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
82712>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
82712>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
82712>>>>>>>
82712>>>>>>>// SQL Server spcific types. 
82712>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
82712>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
82712>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
82712>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
82712>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
82712>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
82712>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>//*****************************************************************************
82712>>>>>>>//*** MSSQL_SetConstraint <FileNum> <ConstraintText>                        ***
82712>>>>>>>//***                                                                       ***
82712>>>>>>>//***   Setup a constraint for a file.                                      ***
82712>>>>>>>//*****************************************************************************
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>
82712>>>>>>>Class cMSSQLHandler Is A cCLIHandler
82713>>>>>>>
82713>>>>>>>    Procedure Construct_Object
82715>>>>>>>        Forward Send Construct_Object
82717>>>>>>>
82717>>>>>>>        Set psDriverID To MSSQLDRV_ID
82718>>>>>>>    End_Procedure // Construct_Object
82719>>>>>>>
82719>>>>>>>
82719>>>>>>>
82719>>>>>>>    //***
82719>>>>>>>    //*** Function: ExtractList
82719>>>>>>>    //*** Purpose : Extract the list from the out connect string.
82719>>>>>>>    //***
82719>>>>>>>
82719>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
82721>>>>>>>        Local String  sItem
82721>>>>>>>        Local Integer iStart
82721>>>>>>>        Local Integer iEnd
82721>>>>>>>
82721>>>>>>>        If (hoStore = 0) ;            Move Current_object To hoStore
82724>>>>>>>
82724>>>>>>>        Send Delete_Data To hoStore
82725>>>>>>>        Move (Pos("{", sOutConnStr)) To iStart
82726>>>>>>>        While (iStart > 0)
82730>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) To sOutConnStr
82731>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 To iStart
82734>>>>>>>            Else Begin
82735>>>>>>>                Move (Pos(",", sOutConnStr)) To iStart
82736>>>>>>>                Move (Pos("}", sOutConnStr)) To iEnd
82737>>>>>>>                If ((iStart = 0) Or (iEnd < iStart)) ;                    Move iEnd To iStart
82740>>>>>>>
82740>>>>>>>                If (iStart > 0) ;                    Set Value Of hoStore Item (Item_Count(Current_Object)) To (Left(sOutConnStr, iStart - 1))
82743>>>>>>>
82743>>>>>>>                If (iStart = iEnd) ;                    Move 0 To iStart
82746>>>>>>>            End
82746>>>>>>>>
82746>>>>>>>        Loop
82747>>>>>>>>
82747>>>>>>>
82747>>>>>>>        Function_Return (Item_Count(hoStore))
82748>>>>>>>    End_Procedure // ExtractList
82749>>>>>>>
82749>>>>>>>
82749>>>>>>>
82749>>>>>>>    //***
82749>>>>>>>    //*** Function: BrowseConnect
82749>>>>>>>    //*** Purpose : Call the driver's browse connect function
82749>>>>>>>    //***
82749>>>>>>>
82749>>>>>>>    Function BrowseConnect String sInConnStr Returns String
82751>>>>>>>        Local String  sDriver
82751>>>>>>>        Local String  sOutConnStr
82751>>>>>>>        Local Integer iArg
82751>>>>>>>        Local Integer iRetval
82751>>>>>>>
82751>>>>>>>        Get psDriverID To sDriver
82752>>>>>>>        If (sDriver <> "") Begin
82754>>>>>>>            Move (Repeat(" ", 8192)) To sOutConnStr
82755>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
82760>>>>>>>        End
82760>>>>>>>>
82760>>>>>>>
82760>>>>>>>        Function_Return sOutConnStr
82761>>>>>>>    End_Function// BrowseConnect
82762>>>>>>>
82762>>>>>>>
82762>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
82764>>>>>>>        Local String  sDriver
82764>>>>>>>        Local String  sOutConnStr
82764>>>>>>>        Local Integer iArg
82764>>>>>>>        Local Integer iRetval
82764>>>>>>>        
82764>>>>>>>        Move 1 to iArg // Browses only local
82765>>>>>>>
82765>>>>>>>        Get psDriverID to sDriver
82766>>>>>>>        If (sDriver <> "") Begin
82768>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
82769>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
82774>>>>>>>        End
82774>>>>>>>>
82774>>>>>>>
82774>>>>>>>        Function_Return sOutConnStr
82775>>>>>>>    End_Function// BrowseConnect
82776>>>>>>>
82776>>>>>>>
82776>>>>>>>    Function DriverIndex String sDriver Returns Integer
82778>>>>>>>    
82778>>>>>>>        Local String  sCurrentDriver
82778>>>>>>>        Local Integer iNumberOfDrivers iDriver iCount
82778>>>>>>>    
82778>>>>>>>        Move 0 to iDriver
82779>>>>>>>    
82779>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
82782>>>>>>>        For iCount from 1 to iNumberOfDrivers
82788>>>>>>>>
82788>>>>>>>    
82788>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
82791>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
82793>>>>>>>                Move iCount to iDriver
82794>>>>>>>            End
82794>>>>>>>>
82794>>>>>>>        Loop
82795>>>>>>>>
82795>>>>>>>    
82795>>>>>>>        Function_Return iDriver
82796>>>>>>>    
82796>>>>>>>    End_Function 
82797>>>>>>>
82797>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
82799>>>>>>>        
82799>>>>>>>        Local String  sServerList
82799>>>>>>>        Local Integer iNumServers
82799>>>>>>>        Local Integer iDriver
82799>>>>>>>        Local Integer iClientVersion
82799>>>>>>>        Local String  sDriver
82799>>>>>>>        
82799>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
82800>>>>>>>
82800>>>>>>>        If (iDriver) Begin
82802>>>>>>>                
82802>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
82805>>>>>>>            
82805>>>>>>>            Case Begin
82805>>>>>>>    
82805>>>>>>>                Case (iClientVersion = SQLSERVER2016CLIENT)
82807>>>>>>>                    Move SQLSERVER2016DRVRSTR to sDriver
82808>>>>>>>                    Case Break
82809>>>>>>>    
82809>>>>>>>                Case (iClientVersion = SQLSERVER2014CLIENT)
82812>>>>>>>                    Move SQLSERVER2014DRVRSTR to sDriver
82813>>>>>>>                    Case Break
82814>>>>>>>            
82814>>>>>>>                Case (iClientVersion = SQLSERVER2012CLIENT)
82817>>>>>>>                    Move SQLSERVER2012DRVRSTR to sDriver
82818>>>>>>>                    Case Break
82819>>>>>>>    
82819>>>>>>>                Case (iClientVersion = SQLSERVER2008CLIENT)
82822>>>>>>>                    Move SQLSERVER2008DRVRSTR to sDriver
82823>>>>>>>                    Case Break
82824>>>>>>>    
82824>>>>>>>                Case (iClientVersion = SQLSERVER2005CLIENT)
82827>>>>>>>                    Move SQLSERVER2005DRVRSTR to sDriver
82828>>>>>>>                    Case Break
82829>>>>>>>            
82829>>>>>>>                Case (iClientVersion = SQLSERVER2000CLIENT)
82832>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
82833>>>>>>>                    Case Break
82834>>>>>>>            
82834>>>>>>>                Case Else
82834>>>>>>>                    Move SQLSERVER2000DRVRSTR to sDriver
82835>>>>>>>            
82835>>>>>>>            Case End
82835>>>>>>>    
82835>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
82836>>>>>>>            If (iNetworkLocal = 0) Begin
82838>>>>>>>                Get BrowseConnect sDriver to sServerList
82839>>>>>>>            End
82839>>>>>>>>
82839>>>>>>>            Else Begin
82840>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
82841>>>>>>>            End
82841>>>>>>>>
82841>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
82842>>>>>>>        End
82842>>>>>>>>
82842>>>>>>>        
82842>>>>>>>        Function_Return iNumServers
82843>>>>>>>        
82843>>>>>>>    End_Function
82844>>>>>>>
82844>>>>>>>    //***
82844>>>>>>>    //*** Procedure: EnumerateServers
82844>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
82844>>>>>>>    //***            This function will return all SQL Server instances on the network. 
82844>>>>>>>    //***            This may take a long time. 
82844>>>>>>>    //***            To enumerate only local SQL Server instances use EnumerateServersLocal 
82844>>>>>>>    Function EnumerateServers Returns Integer
82846>>>>>>>
82846>>>>>>>        Local Integer iNumServers
82846>>>>>>>        Local Integer iNetworkLocal
82846>>>>>>>        
82846>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
82847>>>>>>>        
82847>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
82848>>>>>>>        
82848>>>>>>>        Function_Return iNumServers
82849>>>>>>>        
82849>>>>>>>    End_Function
82850>>>>>>>
82850>>>>>>>
82850>>>>>>>    //***
82850>>>>>>>    //*** Procedure: EnumerateServersLocal
82850>>>>>>>    //*** Purpose  : Enumerate the available SQL Server database servers
82850>>>>>>>    //***            This function will return only return SQL Server instance on the local machine
82850>>>>>>>    //***            To enumerate all SQL Server instances in a network use EnumerateServers
82850>>>>>>>    Function EnumerateServersLocal Returns Integer
82852>>>>>>>
82852>>>>>>>        Local Integer iNumServers
82852>>>>>>>        Local Integer iNetworkLocal
82852>>>>>>>        
82852>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
82853>>>>>>>        
82853>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
82854>>>>>>>        
82854>>>>>>>        Function_Return iNumServers
82855>>>>>>>        
82855>>>>>>>    End_Function
82856>>>>>>>
82856>>>>>>>    
82856>>>>>>>
82856>>>>>>>    //***
82856>>>>>>>    //*** Function: EnumerateDatabases
82856>>>>>>>    //*** Purpose : Enumerate database in a given server.
82856>>>>>>>    //***
82856>>>>>>>
82856>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
82858>>>>>>>        Local Integer hoSQL
82858>>>>>>>        Local String  sConnect
82858>>>>>>>        Local String  sDatabase
82858>>>>>>>        Local Integer hdbc
82858>>>>>>>        Local Integer hstmt
82858>>>>>>>        Local Integer iFetchResult
82858>>>>>>>
82858>>>>>>>        If (Num_Arguments < 3) ;            Move "" To sPassWord
82861>>>>>>>        If (Num_Arguments < 2) ;            Move "" To sUser
82864>>>>>>>
82864>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") To sConnect
82867>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") To sConnect
82869>>>>>>>
82869>>>>>>>        Object oEnumDBSQLmanager Is A cSQLHandleManager
82871>>>>>>>            Move Current_Object To hoSQL
82872>>>>>>>        End_Object // oEnumDBSQLManager
82873>>>>>>>
82873>>>>>>>        If (hoSQL <> 0) Begin
82875>>>>>>>            Get SQLConnect Of hoSQL "MSSQLDRV" sConnect To hdbc
82876>>>>>>>            If (hdbc <> 0) Begin
82878>>>>>>>                Get SQLOpen Of hdbc To hstmt
82879>>>>>>>                If (hstmt <> 0) Begin
82881>>>>>>>                    //*** We could do a direct select on the sysdatabases table but we use
82881>>>>>>>                    //*** the stored procedure sp_database instead. SQL Server recommends this
82881>>>>>>>                    //*** approach in case meta data might change, the stored procedure will
82881>>>>>>>                    //*** stay the same.
82881>>>>>>>                    Send SQLSetProcedureName To hstmt "sp_databases"
82882>>>>>>>                    Send SQLCall To hstmt
82883>>>>>>>                    Repeat
82883>>>>>>>>
82883>>>>>>>                        Get SQLFetch Of hstmt To iFetchResult
82884>>>>>>>                        If (iFetchResult <> 0) Begin
82886>>>>>>>                            Get SQLColumnValue Of hstmt 1 To sDatabase
82887>>>>>>>                            Set Value Item (Item_Count(Current_Object)) To sDatabase
82888>>>>>>>                        End
82888>>>>>>>>
82888>>>>>>>                    Until (iFetchResult = 0)
82890>>>>>>>
82890>>>>>>>                    Send SQLClose To hstmt
82891>>>>>>>                End
82891>>>>>>>>
82891>>>>>>>                Send SQLDisconnect To hdbc
82892>>>>>>>            End
82892>>>>>>>>
82892>>>>>>>        End
82892>>>>>>>>
82892>>>>>>>        Send Destroy_Object To hoSQL
82893>>>>>>>
82893>>>>>>>        Function_return (Item_Count(Current_Object))
82894>>>>>>>    End_Function // EnumerateDatabases
82895>>>>>>>
82895>>>>>>>
82895>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
82897>>>>>>>        
82897>>>>>>>        Local String  sSqlServerClientVersionName
82897>>>>>>>        
82897>>>>>>>            
82897>>>>>>>        Case Begin
82897>>>>>>>
82897>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
82899>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
82900>>>>>>>                Case Break
82901>>>>>>>
82901>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
82904>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
82905>>>>>>>                Case Break
82906>>>>>>>        
82906>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
82909>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
82910>>>>>>>                Case Break
82911>>>>>>>
82911>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
82914>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
82915>>>>>>>                Case Break
82916>>>>>>>
82916>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
82919>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
82920>>>>>>>                Case Break
82921>>>>>>>        
82921>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
82924>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
82925>>>>>>>                Case Break
82926>>>>>>>        
82926>>>>>>>            Case Else
82926>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
82927>>>>>>>        
82927>>>>>>>        Case End
82927>>>>>>>    
82927>>>>>>>        
82927>>>>>>>        Function_Return sSqlServerClientVersionName
82928>>>>>>>        
82928>>>>>>>    End_Function
82929>>>>>>>
82929>>>>>>>
82929>>>>>>>End_Class // cMSSQLHandler
82930>>>>>>>
82930>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\db2_drv.pkg)
82930>>>>>>>//*****************************************************************************
82930>>>>>>>//*** DB2_DRV.PKG                                                           ***
82930>>>>>>>//***                                                                       ***
82930>>>>>>>//*** Author: Ben Weijers                                                   ***
82930>>>>>>>//***         Data Access Nederland                                         ***
82930>>>>>>>//***         30 July 1998                                                  ***
82930>>>>>>>//***                                                                       ***
82930>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
82930>>>>>>>//***                                                                       ***
82930>>>>>>>//*** Purpose:                                                              ***
82930>>>>>>>//***   Package that declares DB2 driver constants and functions.           ***
82930>>>>>>>//****                                                                      ***
82930>>>>>>>//***   This package can be used by developers who want to add DB2 driver   ***
82930>>>>>>>//***   specific code to a DataFlex application.                            ***
82930>>>>>>>//*****************************************************************************
82930>>>>>>>
82930>>>>>>>Use Cli.pkg
82930>>>>>>>
82930>>>>>>>//*** Driver attributes
82930>>>>>>>
82930>>>>>>>
82930>>>>>>>//*** Driver Indentification
82930>>>>>>>
82930>>>>>>>//*** Error number constants
82930>>>>>>>
82930>>>>>>>//*** Call driver function identifiers
82930>>>>>>>
82930>>>>>>>// DB2 specific data types
82930>>>>>>>Define SQL_CLOB           for   (-99)  
82930>>>>>>>Define SQL_BLOB           for   (-98)  
82930>>>>>>>Define SQL_XML            for   (-370) 
82930>>>>>>>// DB2 Graphic types are Unicode types
82930>>>>>>>Define SQL_GRAPHIC        for   (-95)  
82930>>>>>>>Define SQL_VARGRAPHIC     for   (-96)  
82930>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)  
82930>>>>>>>Define SQL_DBCLOB         for   (-350) 
82930>>>>>>>
82930>>>>>>>
82930>>>>>>>//*** Extra DB2 commands
82930>>>>>>>
82930>>>>>>>
82930>>>>>>>//*****************************************************************************
82930>>>>>>>//*** DB2_CheckTrigger <NewState>                                           ***
82930>>>>>>>//***                                                                       ***
82930>>>>>>>//*** This command will set the trigger check at open on or off.            ***
82930>>>>>>>//*****************************************************************************
82930>>>>>>>
82930>>>>>>>
82930>>>>>>>
82930>>>>>>>//*****************************************************************************
82930>>>>>>>//*** DB2_SetConstraint <FileNum> <ConstraintText>                          ***
82930>>>>>>>//***                                                                       ***
82930>>>>>>>//***   Setup a constraint for a file.                                      ***
82930>>>>>>>//*****************************************************************************
82930>>>>>>>
82930>>>>>>>
82930>>>>>>>
82930>>>>>>>Class cDB2Handler Is A cCLIHandler
82931>>>>>>>
82931>>>>>>>    Procedure Construct_Object
82933>>>>>>>        Forward Send Construct_Object
82935>>>>>>>
82935>>>>>>>        Set psDriverID To DB2_DRV_ID
82936>>>>>>>    End_Procedure // Construct_Object
82937>>>>>>>
82937>>>>>>>
82937>>>>>>>
82937>>>>>>>    //***
82937>>>>>>>    //*** Procedure: SeedDataSources
82937>>>>>>>    //*** Purpose  : Reset the datasource list to the beginning
82937>>>>>>>    //***
82937>>>>>>>
82937>>>>>>>    Procedure SeedDataSources
82939>>>>>>>        Local String  sDriver
82939>>>>>>>        Local String  sVoid
82939>>>>>>>        Local Integer iRetval
82939>>>>>>>
82939>>>>>>>        Get psDriverID To sDriver
82940>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
82947>>>>>>>    End_Procedure // SeedDataSources
82948>>>>>>>
82948>>>>>>>
82948>>>>>>>
82948>>>>>>>    //***
82948>>>>>>>    //*** Function: DataSources
82948>>>>>>>    //*** Purpose : Call the driver's data sources function
82948>>>>>>>    //***
82948>>>>>>>
82948>>>>>>>    Function DataSources Returns String
82950>>>>>>>        Local String  sDriver
82950>>>>>>>        Local String  sDataSource
82950>>>>>>>        Local String  sDescription
82950>>>>>>>        Local Integer iLength
82950>>>>>>>        Local Integer iRetval
82950>>>>>>>
82950>>>>>>>        Get psDriverID To sDriver
82951>>>>>>>        If (sDriver <> "") Begin
82953>>>>>>>            Move 8192 To iLength
82954>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
82955>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
82956>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
82961>>>>>>>        End
82961>>>>>>>>
82961>>>>>>>
82961>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
82964>>>>>>>        Else ;            Function_Return ""
82966>>>>>>>    End_Function// DataSources
82967>>>>>>>
82967>>>>>>>End_Class // cODBCHandler
82968>>>>>>>
82968>>>>>>>
82968>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\odbc_drv.pkg)
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBC_DRV.PKG                                                          ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Author: Ben Weijers                                                   ***
82968>>>>>>>//***         Data Access Nederland                                         ***
82968>>>>>>>//***         3 February 1998                                               ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Last updated: May 2, 2007                                                                      ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Purpose:                                                              ***
82968>>>>>>>//***   Package that declares ODBC driver constants and functions.          ***
82968>>>>>>>//****                                                                      ***
82968>>>>>>>//***   This package can be used by developers who want to add Data Access  ***
82968>>>>>>>//***   ODBC Client specific code to a DataFlex application.                ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>Use Cli.pkg
82968>>>>>>>
82968>>>>>>>//*** Driver Indentification
82968>>>>>>>
82968>>>>>>>//*** Error number constants
82968>>>>>>>
82968>>>>>>>//*** Call driver function identifiers
82968>>>>>>>
82968>>>>>>>//*** Extra ODBC commands
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBCManage                                                            ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Start the ODBC manager.                                               ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBCNumberOfDataSources To <NumDSN>                                   ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Returns the number of data sources.                                   ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBCDSNName <DSNNumber> To <DSNName>                                  ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Returns the name of the data source.                                  ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBCEnumerateTables <DSNName> To <TableNum>                           ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Builds internal table array and returns the number of tables in the   ***
82968>>>>>>>//*** DSN.                                                                  ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBCTableName <TableNum> To <TableName>                               ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Returns the name of the table.                                        ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBCSchemaName <TableNum> To <SchemaName>                             ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Returns the schema name of the table.                                 ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBCNumberOfFields <DSNName> <TableName> To <NumDSN>                  ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Returns the number of fields.                                         ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBCFieldName <FieldNumber> To <FieldName>                            ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//*** Returns the name of the field.                                  ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>//*****************************************************************************
82968>>>>>>>//*** ODBC_SetConstraint <FileNum> <ConstraintText>                         ***
82968>>>>>>>//***                                                                       ***
82968>>>>>>>//***   Setup a constraint for a file.                                      ***
82968>>>>>>>//*****************************************************************************
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>
82968>>>>>>>Class cODBCHandler Is A cCLIHandler
82969>>>>>>>
82969>>>>>>>    Procedure Construct_Object
82971>>>>>>>        Forward Send Construct_Object
82973>>>>>>>
82973>>>>>>>        Set psDriverID To ODBC_DRV_ID
82974>>>>>>>    End_Procedure // Construct_Object
82975>>>>>>>
82975>>>>>>>
82975>>>>>>>
82975>>>>>>>    //***
82975>>>>>>>    //*** Procedure Set: DataSourceType
82975>>>>>>>    //*** Purpose      : Setup the type of data sources returned by the datasources function
82975>>>>>>>    //***
82975>>>>>>>
82975>>>>>>>    Procedure Set DataSourceType Integer iNewType
82977>>>>>>>        Local String  sDriver
82977>>>>>>>        Local String  sVoid
82977>>>>>>>        Local Integer iRetval
82977>>>>>>>
82977>>>>>>>        Get psDriverID To sDriver
82978>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
82985>>>>>>>    End_Procedure // Set DataSourceType
82986>>>>>>>
82986>>>>>>>
82986>>>>>>>
82986>>>>>>>    //***
82986>>>>>>>    //*** Function: DataSources
82986>>>>>>>    //*** Purpose : Call the driver's data sources function
82986>>>>>>>    //***
82986>>>>>>>
82986>>>>>>>    Function DataSources Returns String
82988>>>>>>>        Local String  sDriver
82988>>>>>>>        Local String  sDataSource
82988>>>>>>>        Local String  sDescription
82988>>>>>>>        Local Integer iLength
82988>>>>>>>        Local Integer iRetval
82988>>>>>>>
82988>>>>>>>        Get psDriverID To sDriver
82989>>>>>>>        If (sDriver <> "") Begin
82991>>>>>>>            Move 8192 To iLength
82992>>>>>>>            Move (Repeat(" ", iLength)) To sDataSource
82993>>>>>>>            Move (Repeat(" ", iLength)) To sDescription
82994>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
82999>>>>>>>        End
82999>>>>>>>>
82999>>>>>>>
82999>>>>>>>        If (sDataSource <> "" Or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
83002>>>>>>>        Else ;            Function_Return ""
83004>>>>>>>    End_Function// DataSources
83005>>>>>>>
83005>>>>>>>End_Class // cODBCHandler
83006>>>>>Use seq_chnl.pkg
83006>>>>>Use Std_help.pkg
Including file: Std_help.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Std_help.pkg)
83006>>>>>>>// STD_HELP.PKG
83006>>>>>>>//
83006>>>>>>>// Global Help Object
83006>>>>>>>//
83006>>>>>>>//  Creates all Help Support required to access WINDOWs help system
83006>>>>>>>//  with DataFlex. Creates a global object named Help_Object.
83006>>>>>>>//
83006>>>>>>>//  9/19/97 JJT - Modified to define stadnard help Ids if they are undefined
83006>>>>>>>
83006>>>>>>>use DFHlpSys.pkg // Context Sensitive Help Support for Windows and HTML
Including file: Dfhlpsys.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfhlpsys.pkg)
83006>>>>>>>>>//************************************************************************
83006>>>>>>>>>//
83006>>>>>>>>>// Confidential Trade Secret.
83006>>>>>>>>>// Copyright (c) 1997-2002 Data Access Corporation, Miami Florida
83006>>>>>>>>>// as an unpublished work.  All rights reserved.
83006>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
83006>>>>>>>>>//
83006>>>>>>>>>//***********************************************************************/
83006>>>>>>>>>
83006>>>>>>>>>//************************************************************************
83006>>>>>>>>>// DFHlpSys.pkg
83006>>>>>>>>>//  12-07-1994 : Created
83006>>>>>>>>>//  8/29/2002  : major changes
83006>>>>>>>>>//
83006>>>>>>>>>// Author: John J. Tuohy
83006>>>>>>>>>//
83006>>>>>>>>>// This package loads support the windows help and html help. It used to define
83006>>>>>>>>>// a bunch of desktop help messages, but as of 8.3 those have been moved into
83006>>>>>>>>>// objects via a dfbase mixin. The only reason this package remains here is that
83006>>>>>>>>>// std_help.pkg calls it.
83006>>>>>>>>>//************************************************************************
83006>>>>>>>>>
83006>>>>>>>>>use DFHlpCl.pkg    // Define the Help_System Class for windows
Including file: Dfhlpcl.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\Dfhlpcl.pkg)
83006>>>>>>>>>>>//************************************************************************
83006>>>>>>>>>>>//
83006>>>>>>>>>>>// Confidential Trade Secret.
83006>>>>>>>>>>>// Copyright 1997-2001 Data Access Corporation, Miami FL, USA
83006>>>>>>>>>>>// All Rights reserved
83006>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//************************************************************************
83006>>>>>>>>>>>//
83006>>>>>>>>>>>// $File name  : DFHlpCl.pkg
83006>>>>>>>>>>>// $File title : HelpSystem class support
83006>>>>>>>>>>>// Notice      :
83006>>>>>>>>>>>// $Author(s)  : John Tuohy
83006>>>>>>>>>>>//
83006>>>>>>>>>>>// $Rev History
83006>>>>>>>>>>>//
83006>>>>>>>>>>>// 07/19/01 SWB - added support for the Application object's psHelpFile
83006>>>>>>>>>>>//                to override any value in the global Workspace object
83006>>>>>>>>>>>// 11/17/97 JJT - added missing set help_filename method.
83006>>>>>>>>>>>// 10/15/97 JJT - changed define_symbol to define
83006>>>>>>>>>>>// 6/27/97  JJT - Modified low level help calls to work better in 95 help.
83006>>>>>>>>>>>// 07/23/96 JJT - New Class names
83006>>>>>>>>>>>// 01/27/96 JJT - Changed to from DAF to DF
83006>>>>>>>>>>>// 02/14/95 JJT - Added DFGSINI for 3.01/3.05 dual support of .ini name
83006>>>>>>>>>>>//                and section name.
83006>>>>>>>>>>>//************************************************************************
83006>>>>>>>>>>>// VDF8 changes
83006>>>>>>>>>>>// 10/23/2001 JJT - use ReadString instead of System_profile_string
83006>>>>>>>>>>>//************************************************************************
83006>>>>>>>>>>>
83006>>>>>>>>>>>// Help System Package
83006>>>>>>>>>>>//
83006>>>>>>>>>>>// Public Properties that should be set:
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//     Property String  Help_Filename   (Help_File_Default(self))
83006>>>>>>>>>>>//     Property Integer Help_Id_General 0
83006>>>>>>>>>>>//     Property Integer Help_Id_Index   0
83006>>>>>>>>>>>//     Property Integer Help_Id_Keys    0
83006>>>>>>>>>>>//     Property Integer Help_Id_Files   0
83006>>>>>>>>>>>//     Property Integer Help_Id_Errors  0
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//
83006>>>>>>>>>>>// Public messsages which are sent to this object:
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//    procedure View_Context_KeyWord_Help integer Obj
83006>>>>>>>>>>>//    procedure View_Context_ID_Help      integer Obj
83006>>>>>>>>>>>//    procedure View_Context_Help         integer Obj
83006>>>>>>>>>>>//    procedure View_Help_for_help        integer Obj
83006>>>>>>>>>>>//    procedure View_help_index           integer Obj
83006>>>>>>>>>>>//    procedure View_Keys_Help            integer Obj
83006>>>>>>>>>>>//    procedure View_File_Help            integer Obj
83006>>>>>>>>>>>//    procedure View_Error_Help           integer Obj
83006>>>>>>>>>>>//    procedure View_Help_on_Topic        integer Obj
83006>>>>>>>>>>>//
83006>>>>>>>>>>>// Protected Messages:
83006>>>>>>>>>>>//        These messages invoke the Window's help system and are not
83006>>>>>>>>>>>//        directly sent by outside objects. They are sent by public
83006>>>>>>>>>>>//        "view_xxx" messages and might be used if you are creating
83006>>>>>>>>>>>//        a sub-class of an object-class.
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//    Procedure Exec_System_Context_Help  integer Context_id
83006>>>>>>>>>>>//    Procedure Exec_System_Help          string  Keyword
83006>>>>>>>>>>>//    Procedure Exec_Context_Help         string  Context
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//    Functions for converting DF help IDs to windows Help Ids
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//        Any of these can return either a string or an integer.
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//    Function System_Help_Context_id Integer ID Returns String
83006>>>>>>>>>>>//           Convert a DF help context id into a windows id. By default,
83006>>>>>>>>>>>//           just return the same value (a one to one match). This is called
83006>>>>>>>>>>>//           by View_Context_id_help and View_Context_Help
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//    Function System_Help_File_Id Integer File# Integer Field# Returns String
83006>>>>>>>>>>>//           Convert file and field into a help id. By default it returns the
83006>>>>>>>>>>>//           file#. Called by View_File_Help.
83006>>>>>>>>>>>//
83006>>>>>>>>>>>//    Function System_Help_Error_id Integer Id Returns String
83006>>>>>>>>>>>//           Convert an error message into an ID. Right now it returns the
83006>>>>>>>>>>>//           the general error context id property, Help_id_errors. This
83006>>>>>>>>>>>//           will invoke general error help. If you want error support at the
83006>>>>>>>>>>>//           error# level you will have to determine the program to help
83006>>>>>>>>>>>//           interface yourself. Errors have a very large range and it is
83006>>>>>>>>>>>//           therefore hard to come up with an automatic numbering scheme.
83006>>>>>>>>>>>//           Called by View_Error_Help.
83006>>>>>>>>>>>
83006>>>>>>>>>>>
83006>>>>>>>>>>>Use Windows.pkg
83006>>>>>>>>>>>Use WinHlp.pkg // low level help call to windows API provides global message gDoWinHelp
83006>>>>>>>>>>>Use HelpSystemConstants.pkg // constants used by help system
83006>>>>>>>>>>>
83006>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
83006>>>>>>>>>>>Register_function peHelpType  returns integer
83006>>>>>>>>>>>
83006>>>>>>>>>>>class HelpSystem is an cObject
83007>>>>>>>>>>>
83007>>>>>>>>>>>    register_function Help_File_Default returns string
83007>>>>>>>>>>>
83007>>>>>>>>>>>    procedure Construct_Object
83009>>>>>>>>>>>       Forward send Construct_Object
83011>>>>>>>>>>>
83011>>>>>>>>>>>       // Help file name only. If set, this overrides all other settings.
83011>>>>>>>>>>>       Property String psHelpFile
83012>>>>>>>>>>>
83012>>>>>>>>>>>       // Help_FileName
83012>>>>>>>>>>>       //   full path name of Help file. The default value grabs its value
83012>>>>>>>>>>>       //   from .ini or environment settings. See functiob Help_file_Default
83012>>>>>>>>>>>       //
83012>>>>>>>>>>>       Property String  Private.Help_Filename (Help_File_Default(self))
83013>>>>>>>>>>>
83013>>>>>>>>>>>       // The following properties are the default values for the help files
83013>>>>>>>>>>>       // IDs for the various subjects. Setting these requires an agreement
83013>>>>>>>>>>>       // between the DF help system and the help file.
83013>>>>>>>>>>>       //
83013>>>>>>>>>>>       Property Integer Help_Id_General  0
83014>>>>>>>>>>>       Property Integer Help_Id_Index    0
83015>>>>>>>>>>>       Property Integer Help_Id_Keys     0
83016>>>>>>>>>>>       Property Integer Help_Id_Files    0
83017>>>>>>>>>>>       Property Integer Help_Id_Errors   0
83018>>>>>>>>>>>
83018>>>>>>>>>>>       // this is now the default help object
83018>>>>>>>>>>>       Move self to Help_Object_id
83019>>>>>>>>>>>    End_Procedure
83020>>>>>>>>>>>
83020>>>>>>>>>>>   // New rules for VDF8:
83020>>>>>>>>>>>   // 1. If psHelpFile exists, find the file in the file path and use it
83020>>>>>>>>>>>   // 2. If application object exists and help type is windows, use psHelpFile from there, find in file path and use it.
83020>>>>>>>>>>>   // 3. If no help file exists, use thge old private help name (which gets the full name from the registry -only if no app object)
83020>>>>>>>>>>>   //    Last method is deprecated and only used for old applications
83020>>>>>>>>>>>   //
83020>>>>>>>>>>>   Function Help_filename returns string
83022>>>>>>>>>>>        string sHelpName
83022>>>>>>>>>>>        // If ghoWorkSpace Get Help_FileName of ghoWorkSpace to sHelpName // removed for VDF8
83022>>>>>>>>>>>
83022>>>>>>>>>>>        // If an Application object is used, take the name from there.
83022>>>>>>>>>>>        Get psHelpFile to sHelpName
83023>>>>>>>>>>>        If (sHelpName="" AND ghoApplication AND peHelpType(ghoApplication)=htWinHelp) Begin
83025>>>>>>>>>>>            Get psHelpFile of ghoApplication To sHelpName
83026>>>>>>>>>>>            //Move (psHelpPath(phoWorkspace(ghoApplication)) -"\" -sHelpName) To sHelpName
83026>>>>>>>>>>>        End
83026>>>>>>>>>>>>
83026>>>>>>>>>>>        If (sHelpName<>"") begin
83028>>>>>>>>>>>            Get_File_Path sHelpName To sHelpName
83029>>>>>>>>>>>            Function_Return sHelpName
83030>>>>>>>>>>>        end
83030>>>>>>>>>>>>
83030>>>>>>>>>>>        // if not set anywhere (and ideally it is) we use this.
83030>>>>>>>>>>>        Get Private.Help_FileName to sHelpName
83031>>>>>>>>>>>        Function_Return sHelpName
83032>>>>>>>>>>>    End_Function
83033>>>>>>>>>>>
83033>>>>>>>>>>>    Procedure Set Help_FileName string sName
83035>>>>>>>>>>>        Set Private.Help_FileName to sName
83036>>>>>>>>>>>    End_Procedure
83037>>>>>>>>>>>
83037>>>>>>>>>>>
83037>>>>>>>>>>>
83037>>>>>>>>>>>    // Consider this message PRIVATE in that it should only be changed
83037>>>>>>>>>>>    // by a sub-class and not an object. It is called in construct_object
83037>>>>>>>>>>>    // before it knows about object augmentations!!!!
83037>>>>>>>>>>>    //
83037>>>>>>>>>>>    //  Sets the Help_file_name by looking at the .INI file for:
83037>>>>>>>>>>>    //        HELP_DIR    - help directory (will check environment variable
83037>>>>>>>>>>>    //                      windir if not found - avoid this usage). If not
83037>>>>>>>>>>>    //                      blank append "\" as required.
83037>>>>>>>>>>>    //
83037>>>>>>>>>>>    //        HELP_FILE   - help file name. If blank uses the default help
83037>>>>>>>>>>>    //                      file name
83037>>>>>>>>>>>    //
83037>>>>>>>>>>>    Function Help_File_Default Returns String
83039>>>>>>>>>>>       String HelpFileDir HelpFileName sSubKey
83039>>>>>>>>>>>       // if using the application object we expect the help name to be
83039>>>>>>>>>>>       // defined in the application object or directly in the help object. No Exceptions
83039>>>>>>>>>>>       If (ghoApplication) function_return ""
83042>>>>>>>>>>>
83042>>>>>>>>>>>       // else if no application (and hence no WS) use an old deprecated method of checking
83042>>>>>>>>>>>       // for the module name in local_machine.
83042>>>>>>>>>>>       Get Module_name of Desktop to sSubKey
83043>>>>>>>>>>>       Get_Profile_String sSubKey HELP_DIR to HelpFileDir
83046>>>>>>>>>>>       Get_Profile_String sSubKey HELP_FILE to HelpFileName
83049>>>>>>>>>>>       // if dir exists, sure it has a "\" at the end. If no directory the
83049>>>>>>>>>>>       // dir must be blank so current directory is searched
83049>>>>>>>>>>>       If ( (HelpFileDir<>'') AND (Right(HelpFileDir,1)<>"\") ) ;          Move (HelpFileDir - '\') to HelpFileDir
83052>>>>>>>>>>>       If HelpFileName eq '' Move DEFAULT_HELP_FILENAME to HelpFileName
83055>>>>>>>>>>>       Function_Return (HelpFileDir - HelpFileName)
83056>>>>>>>>>>>    End_Function
83057>>>>>>>>>>>
83057>>>>>>>>>>>    // The System_Help_xxxx messages convert a DF help integer ID into
83057>>>>>>>>>>>    // a context value that can be used by the windows help system. If
83057>>>>>>>>>>>    // you return a number or a string. Numbers will get used for context ID
83057>>>>>>>>>>>    // help, non-numbers get used for keyword context help
83057>>>>>>>>>>>
83057>>>>>>>>>>>    // By default return ID passed. This creates a direct mapping between
83057>>>>>>>>>>>    // context IDs in your object and the context IDs in windows help.
83057>>>>>>>>>>>    //
83057>>>>>>>>>>>    Function System_Help_Context_id Integer ID Returns String
83059>>>>>>>>>>>       Function_Return ID
83060>>>>>>>>>>>    End_Function // System_Help_Context_id
83061>>>>>>>>>>>
83061>>>>>>>>>>>    // Returns the file# which assumes that we have a direct mapping between
83061>>>>>>>>>>>    // the file number and a window's help context_id. We are ignoring field#
83061>>>>>>>>>>>    // in this case (although your augmentation would not have to). If the
83061>>>>>>>>>>>    // file# is 0, return a the HELP_ID context id.
83061>>>>>>>>>>>    //
83061>>>>>>>>>>>    Function System_Help_File_Id Integer File# Integer Field# Returns String
83063>>>>>>>>>>>       String rVal
83063>>>>>>>>>>>       if File# eq 0 Move (Help_id_files(self)) to rVal
83066>>>>>>>>>>>       Else Move File# to rVal
83068>>>>>>>>>>>       Function_Return Rval
83069>>>>>>>>>>>    End_Function // System_Help_File_id
83070>>>>>>>>>>>
83070>>>>>>>>>>>    // Convert an error id into a help context id. Return the general
83070>>>>>>>>>>>    // Help id property value. We do this because error number have
83070>>>>>>>>>>>    // a rather large range (1-9000) and just using the number would consume
83070>>>>>>>>>>>    // too much of the context id space.
83070>>>>>>>>>>>    //
83070>>>>>>>>>>>    Function System_Help_Error_id Integer Id Returns String
83072>>>>>>>>>>>       Function_Return (Help_Id_Errors(self))
83073>>>>>>>>>>>    End_Function // System_Help_Error_id
83074>>>>>>>>>>>
83074>>>>>>>>>>>    // Use this if you want your help context to be keyword based
83074>>>>>>>>>>>    //
83074>>>>>>>>>>>    procedure View_Context_KeyWord_Help integer Obj
83076>>>>>>>>>>>       String Context
83076>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of obj HELP_CONTEXT_KEYWORD to Context
83079>>>>>>>>>>>       Send Exec_System_Help Context
83080>>>>>>>>>>>    end_procedure
83081>>>>>>>>>>>
83081>>>>>>>>>>>    // Use this if you want your help context to be ID based
83081>>>>>>>>>>>    //
83081>>>>>>>>>>>    procedure View_Context_ID_Help integer Obj
83083>>>>>>>>>>>       Integer Context_ID
83083>>>>>>>>>>>       String Context
83083>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of Obj HELP_CONTEXT_ID to Context_ID
83086>>>>>>>>>>>       Get System_Help_Context_id Context_Id to Context
83087>>>>>>>>>>>       Send Exec_Context_Help Context
83088>>>>>>>>>>>    end_procedure
83089>>>>>>>>>>>
83089>>>>>>>>>>>    // Use this is you want the object requesting help to support either
83089>>>>>>>>>>>    // keyword or context ID help (it will use whatever it finds first).
83089>>>>>>>>>>>    //
83089>>>>>>>>>>>    procedure View_Context_Help integer Obj
83091>>>>>>>>>>>       String Context
83091>>>>>>>>>>>       If Obj gt 0 ;          Get Help_Context of obj HELP_CONTEXT_ID_OR_KEY to Context
83094>>>>>>>>>>>       if (left(context,1)) in '0123456789' ;          Get System_Help_Context_id Context to Context
83097>>>>>>>>>>>       Send Exec_Context_Help Context
83098>>>>>>>>>>>    end_procedure
83099>>>>>>>>>>>
83099>>>>>>>>>>>    Procedure View_Help_for_Help Integer obj
83101>>>>>>>>>>>        Send Exec_System_Help HELP_FOR_HELP_STRING
83102>>>>>>>>>>>    end_procedure
83103>>>>>>>>>>>
83103>>>>>>>>>>>    Procedure View_Help_Index integer obj
83105>>>>>>>>>>>       Send Exec_Context_Help (Help_id_index(self))
83106>>>>>>>>>>>    End_Procedure // View_help_index
83107>>>>>>>>>>>
83107>>>>>>>>>>>    procedure View_Keys_Help Integer Obj
83109>>>>>>>>>>>        Send Exec_Context_Help (Help_id_keys(self))
83110>>>>>>>>>>>    end_procedure
83111>>>>>>>>>>>
83111>>>>>>>>>>>    Procedure View_File_Help Integer Obj
83113>>>>>>>>>>>       String Context FilFld
83113>>>>>>>>>>>       Integer File# Field# Dot
83113>>>>>>>>>>>       If Obj gt 0 Begin
83115>>>>>>>>>>>          // This should return the file and field as a string in
83115>>>>>>>>>>>          // FFF.fff format (F=File, f=format).
83115>>>>>>>>>>>          Get Help_Context of Obj HELP_CONTEXT_DATAFILE to FilFld
83116>>>>>>>>>>>          // Parse FilFld into File# and Field#.
83116>>>>>>>>>>>          Pos '.' in FilFld to Dot
83118>>>>>>>>>>>>
83118>>>>>>>>>>>          if Dot ne 0 begin
83120>>>>>>>>>>>             Left FilFld to File#  (dot-1)
83122>>>>>>>>>>>>
83122>>>>>>>>>>>             Mid  FilFld to Field# 255 (dot+1)
83125>>>>>>>>>>>>
83125>>>>>>>>>>>          End
83125>>>>>>>>>>>>
83125>>>>>>>>>>>       End
83125>>>>>>>>>>>>
83125>>>>>>>>>>>       Get System_Help_File_id File# Field# to Context
83126>>>>>>>>>>>       Send Exec_Context_Help Context
83127>>>>>>>>>>>    End_Procedure // View_File_Help
83128>>>>>>>>>>>
83128>>>>>>>>>>>    //  View help on an error. Current version uses context id help.
83128>>>>>>>>>>>    //  The error number should be in global integer last_err
83128>>>>>>>>>>>    //
83128>>>>>>>>>>>    procedure View_Error_Help Integer Obj
83130>>>>>>>>>>>        String Context
83130>>>>>>>>>>>        If Obj gt 0 ;           Get Help_Context of obj HELP_CONTEXT_ERROR to Context
83133>>>>>>>>>>>        if (left(context,1)) in '0123456789' ;           Get System_Help_Error_id Context to Context
83136>>>>>>>>>>>        Send Exec_Context_Help Context
83137>>>>>>>>>>>    end_procedure
83138>>>>>>>>>>>
83138>>>>>>>>>>>    // View list of help topics.
83138>>>>>>>>>>>    //
83138>>>>>>>>>>>    Procedure View_Help_on_Topic Integer obj
83140>>>>>>>>>>>        Send Exec_System_Help HELP_ON_TOPIC_STRING
83141>>>>>>>>>>>    end_procedure
83142>>>>>>>>>>>
83142>>>>>>>>>>>    // Request context help. If context is a number assume that it is
83142>>>>>>>>>>>    // context id help, else assume it is keyword help.
83142>>>>>>>>>>>    //
83142>>>>>>>>>>>    Procedure Exec_Context_Help string Context
83144>>>>>>>>>>>       if (left(context,1)) in '0123456789' ;    // if first character is a          Send Exec_System_Context_Help Context  // numeric we assume ID help
83147>>>>>>>>>>>       else ;                                    // otherwise we assume key-          Send Exec_System_Help Context          // word help.
83149>>>>>>>>>>>    End_Procedure // Exec_Context_Help
83150>>>>>>>>>>>
83150>>>>>>>>>>>    // NOTE: the following two messages are the only messages that directly make calls
83150>>>>>>>>>>>    //       to the windows API. This is important. These two messages could be changed
83150>>>>>>>>>>>    //       to call other help systems (e.g. HTML help) and the rest of the high level
83150>>>>>>>>>>>    //       program remains the same. These are the only two messages that are
83150>>>>>>>>>>>    //       expected to be windows help centric.
83150>>>>>>>>>>>
83150>>>>>>>>>>>    // Get Context Id help for passed ID. Use help file as defined
83150>>>>>>>>>>>    // in Help_filename. If id is 0 use general help id (which must be
83150>>>>>>>>>>>    // defined.
83150>>>>>>>>>>>    //
83150>>>>>>>>>>>    Procedure Exec_System_Context_Help integer Context_id
83152>>>>>>>>>>>        If Context_Id eq 0 ; // if zero, see if we have a contents page            Move (Help_Id_General(self)) to Context_id
83155>>>>>>>>>>>        If Context_Id eq 0 ; // if still zero, jump to the topics popup dialog            Send Exec_System_Help HELP_ON_TOPIC_STRING
83158>>>>>>>>>>>        Else ;            Send gDoWinHelp WH_INTCONTEXT (Help_Filename(self)) Context_Id
83160>>>>>>>>>>>    end_procedure
83161>>>>>>>>>>>
83161>>>>>>>>>>>    // Get keyword help for passed keyword. Use help file as defined
83161>>>>>>>>>>>    // in help_filename.
83161>>>>>>>>>>>    //
83161>>>>>>>>>>>    procedure Exec_System_Help string Keyword
83163>>>>>>>>>>>        If Keyword eq HELP_FOR_HELP_STRING ;            Send gDoWinHelp WH_HELPONHELP
83166>>>>>>>>>>>        else if (Keyword eq HELP_ON_TOPIC_STRING OR KeyWord="");            Send gDoWinHelp WH_FINDER (Help_Filename(self))
83170>>>>>>>>>>>        else ;            Send gDoWinHelp WH_STRINGCONTEXT (Help_Filename(self)) KeyWord
83172>>>>>>>>>>>    end_procedure
83173>>>>>>>>>>>
83173>>>>>>>>>>>end_class
83174>>>>>>>>>use cHtmlHelp.pkg //  Define the help class for Html
83174>>>>>>>
83174>>>>>>>
83174>>>>>>>// This file needs to be provided by the developer. It will contain
83174>>>>>>>// symbolic replacements for the ID integer values used to access the
83174>>>>>>>// the windows help file's topics.
83174>>>>>>>//
83174>>>>>>>use Help_ids.inc
Including file: Help_ids.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Help_ids.inc)
83174>>>>>>>>>// Help_ids.inc
83174>>>>>>>>>//
83174>>>>>>>>>// Context ids. This uses help file Developer5.chm.
83174>>>>>>>>>//
83174>>>>>>>>>// This is a sample version. YOU must supply
83174>>>>>>>>>// the ID values
83174>>>>>>>>>
83174>>>>>>>>>//  Generic Context Ids
83174>>>>>>>>>//
83174>>>>>>>>>Define SQLConnectionsProgram for 0
83174>>>>>>>>>
83174>>>>>>>>>// It is expected that file-names ids will be the same as their
83174>>>>>>>>>// filenumber.
83174>>>>>>>>>
83174>>>>>>>>>
83174>>>>>>>>>//  View and selection-list specific context ids
83174>>>>>>>>>//
83174>>>>>>>>>//..........add view, object, selection-list ids here....
83174>>>>>>>
83174>>>>>>>// If the following are not defined in help_ids.inc,
83174>>>>>>>//  create default 0 values for them
83174>>>>>>>Define GeneralHelpId    for    0
83174>>>>>>>Define KeysHelpId       for    0
83174>>>>>>>Define FileHelpId       for    0
83174>>>>>>>Define ErrorHelpId      for    0  // probably not used in VDF
83174>>>>>>>Define IndexHelpId      for    0  // probably not used in VDF
83174>>>>>>>
83174>>>>>>>object Help_Object is a HelpSystem // global windows HLP help object
83176>>>>>>>
83176>>>>>>>   Set Help_Id_General to GeneralHelpId    // these should all be defined
83177>>>>>>>   Set Help_Id_Index   to IndexHelpId      // in help_ids.inc.
83178>>>>>>>   Set Help_Id_Keys    to KeysHelpId       //
83179>>>>>>>   Set Help_Id_Files   to FileHelpId       //
83180>>>>>>>   Set Help_Id_Errors  to ErrorHelpId      //
83181>>>>>>>
83181>>>>>>>end_object
83182>>>>>>>
83182>>>>>>>Object oHtmlHelp is a cHtmlHelp // this also defines ghoHtmlHelp
83184>>>>>>>End_Object
83185>>>>>
83185>>>>>Register_Function phoWorkspace Returns Handle
83185>>>>>Register_Function Help_filename Returns String
83185>>>>>Register_Function GetHelpFile Returns String
83185>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
83185>>>>>
83185>>>>>// Use of Mertech drivers:
83185>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
83185>>>>>    Use mertech.inc
Including file: mertech.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\mertech.inc)
83185>>>>>>>//*************************************************************************
83185>>>>>>>//*                                                                       *
83185>>>>>>>//*  Confidential Trade Secret.                                           *
83185>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
83185>>>>>>>//*  All rights reserved.                                                 *
83185>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
83185>>>>>>>//*                                                                       *
83185>>>>>>>//*************************************************************************
83185>>>>>>>Use UI
83185>>>>>>>Use SEQ_CHNL.PKG
83185>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 3.1.1
#REM -----------------------------------------------
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>// #DEFINE's
83185>>>>>>>//=============================================================================
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_FILE_PRIMARY_KEY                          For (DF_FILE_RECORD_REREAD+1)
83185>>>>>>>
83185>>>>>>>// TODO: This is probably deprecated. Investigate.
83185>>>>>>>Define DF_FILE_NUMBER_INVERSE_KEYS                  For (DF_FILE_RECORD_REREAD+3)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_SET_MODE
83185>>>>>>>/// @Description Allows switching between set-oriented and record oriented fetch modes.
83185>>>>>>>///
83185>>>>>>>/// If DF_FILE_SET_MODE is set to True, the driver will fetch a set of records
83185>>>>>>>/// for each find. If DF_FILE_SET_MODE is False, the driver will fetch only one
83185>>>>>>>/// record at a time. This attribute can also be specified in the .INT file during
83185>>>>>>>/// migration through Flex2SQL. This settings is normally used alongside
83185>>>>>>>/// DF_FILE_MAX_ROWS to set the number of rows to return and DF_FILE_CACHE_MODE
83185>>>>>>>/// to turn on local caching.
83185>>>>>>>///
83185>>>>>>>/// Note: Turning off set-mode can have a detrimental impact on performance. Unless
83185>>>>>>>/// there is a specific reason to do otherwise, this option should be left on.
83185>>>>>>>///
83185>>>>>>>/// Default value: True
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
83185>>>>>>>/// @See DF_FILE_MAX_ROWS DF_FILE_CACHE_MODE
83185>>>>>>>/// @INTOPT OPTIMIZE {FOR_SET | ONE_ROW}
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Mode for the FileNumber. True for set-mode, False for one-row mode.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Orderhea
83185>>>>>>>/// Set_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to True
83185>>>>>>>/// Get_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to boolVar
83185>>>>>>>///
83185>>>>>>>Define DF_FILE_SET_MODE                             For (DF_FILE_RECORD_REREAD+5)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_DATABASENAME
83185>>>>>>>/// @Description Returns a string containing the name of the database where the
83185>>>>>>>/// table referenced by the passed File Number resides. This is a READ ONLY
83185>>>>>>>/// attribute. Note that because Oracle doesn't support the concept of multiple
83185>>>>>>>/// databases on one server, this attribute is not valid for Oracle.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     SQLFlex, MySQLFlex, PGFlex
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
83185>>>>>>>/// @See
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Name of the Database
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Orderhea
83185>>>>>>>/// Get_Attribute DF_FILE_DATABASENAME of Orderhea.File_Number to strVal
83185>>>>>>>Define DF_FILE_DATABASENAME                         For (DF_FILE_RECORD_REREAD+6)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_MAX_ROWS
83185>>>>>>>/// @Description Controls the maximum number of rows retrieved by a Find GT/LT
83185>>>>>>>/// operation. The driver will automatically retrieve and cache this many rows
83185>>>>>>>/// for future find GT/LT operations. Setting this property to a very high
83185>>>>>>>/// value can be inefficient from a UI perspective but may be advisable for
83185>>>>>>>/// local processing of rows (such as in a batch process).
83185>>>>>>>///
83185>>>>>>>/// Default value: 10
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
83185>>>>>>>/// @See DF_FILE_SET_MODE DF_FILE_CACHE_MODE
83185>>>>>>>/// @INTOPT MAX_ROWS_TO_QUERY {integer}
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Attribute Value
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Orderhea
83185>>>>>>>/// Set_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to 10
83185>>>>>>>/// Get_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to intVal
83185>>>>>>>Define DF_FILE_MAX_ROWS                             For (DF_FILE_RECORD_REREAD+7)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_TABLE_NAME
83185>>>>>>>/// @Description Use this attribute to set or get the name of the SQL table
83185>>>>>>>/// corresponding to the specified file number. In a restructure operation
83185>>>>>>>/// this attribute may be used to permanently change the table that a filelist
83185>>>>>>>/// entry is pointing to.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT DATABASE_NAME {string}
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Name of the SQL Table.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Orderhea
83185>>>>>>>/// Get_Attribute DF_FILE_TABLE_NAME of Orderhea.File_Number to strVal
83185>>>>>>>Define DF_FILE_TABLE_NAME                           For (DF_FILE_RECORD_REREAD+8)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_CACHE_MODE
83185>>>>>>>/// @Description Activates or deactivates the local cache for set-oriented searches.
83185>>>>>>>///
83185>>>>>>>/// Through the DF_FILE_CACHE_MODE attribute, we can activate or deactivate the
83185>>>>>>>/// local cache. When the cache is active in a set-oriented search, a fixed
83185>>>>>>>/// number of records are pre-fetched and kept in the local cache. If a record
83185>>>>>>>/// is not found in the local cache, a new set is fetched. The number of records
83185>>>>>>>/// fetched is controlled via the DF_FILE_MAX_ROWS attribute. Set-mode vs. one-row
83185>>>>>>>/// mode is controlled via the DF_FILE_SET_MODE attribute.
83185>>>>>>>///
83185>>>>>>>/// Note: Turning off the cache can have significant detrimental effects on performance.
83185>>>>>>>///
83185>>>>>>>/// Default value: True
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
83185>>>>>>>/// @See         DF_FILE_MAX_ROWS DF_FILE_SET_MODE
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Mode for FileNumber. True for active. False for inactive.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Orderhea
83185>>>>>>>/// Set_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to True
83185>>>>>>>/// Get_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to boolVal
83185>>>>>>>Define DF_FILE_CACHE_MODE                           For (DF_FILE_RECORD_REREAD+9)
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_FILE_STORAGE_BASE                         For (DF_FILE_RECORD_REREAD+10)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_STATIC
83185>>>>>>>/// @Description Activates or deactivates a special table mode where all rows
83185>>>>>>>/// from the table are loaded into a local cache. When active, all searches are
83185>>>>>>>/// done in memory and the actual table is not accessed.  The driver does not allow
83185>>>>>>>/// editing of a table in static mode.  This is a very useful feature especially
83185>>>>>>>/// when a table contains configuration or static information used in
83185>>>>>>>/// calculations, (i.e., Tax Rate tables, etc.) By keeping this table locally
83185>>>>>>>/// in memory, network round trips are saved resulting in significant
83185>>>>>>>/// performance improvements. This attribute is also useful for batch
83185>>>>>>>/// processes that make extensive table IO requests for reading static information.
83185>>>>>>>///
83185>>>>>>>/// Note: Because the entire table is loaded into memory, it is inadvisable to use
83185>>>>>>>/// this on very large tables.
83185>>>>>>>///
83185>>>>>>>/// Default value: False
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
83185>>>>>>>/// @See
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_STATIC of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Static Mode for FileNumber. True for static. False for dynamic.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Orderhea
83185>>>>>>>/// Set_Attribute DF_FILE_STATIC of Orderhea.File_Number to True
83185>>>>>>>/// Get_Attribute DF_FILE_STATIC of Orderhea.File_Number to boolVal
83185>>>>>>>Define DF_FILE_STATIC                               For (DF_FILE_RECORD_REREAD+11)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_SERVER_NAME
83185>>>>>>>/// @Description Use this attribute to set or get the name of the database server
83185>>>>>>>/// corresponding to the specified file number. In a restructure operation
83185>>>>>>>/// this attribute may be used to permanently change the server that a filelist
83185>>>>>>>/// entry is pointing to.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT SERVER_NAME {string}
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Name of the database server.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Orderhea
83185>>>>>>>/// Set_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to "(localdb)\v11.0"
83185>>>>>>>/// Get_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to strVal
83185>>>>>>>Define DF_FILE_SERVER_NAME                          For (DF_FILE_RECORD_REREAD+12)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FETCH_FIELD_COUNT
83185>>>>>>>/// @Description This attribute is used to get the number of fields or columns
83185>>>>>>>/// in the given table. Note that this is referring to the columns in the SQL
83185>>>>>>>/// backend and may not necessarily reflect the number of columns in DataFlex.
83185>>>>>>>///
83185>>>>>>>/// This is a readonly attribute.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     MsSQLFlex MySQLFlex
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FETCH_FIELD_COUNT of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Name of the Tablespace.
83185>>>>>>>/// @Example
83185>>>>>>>
83185>>>>>>>/// Get_Attribute DF_FETCH_FIELD_COUNT of hFile To "INDXS"
83185>>>>>>>Define DF_FETCH_FIELD_COUNT                         For (DF_FILE_RECORD_REREAD+13)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_TABLESPACE_NAME
83185>>>>>>>/// @Description A tablespace is a container of segments (objects that have an
83185>>>>>>>/// allotted amount of space), i.e. tables and indexes. This attribute is
83185>>>>>>>/// used to get or set the name of the tablespace being used for the data tables.
83185>>>>>>>/// To set or get the tablespace name for indexes, use the DF_FILE_INDEXTABLESPACE_NAME
83185>>>>>>>/// attribute. Setting the tablespace name can only be done during a Structure_Start
83185>>>>>>>/// (during table creation).  Getting the name, however can be done at
83185>>>>>>>/// anytime.  Note that when setting the tablespace name, it must be set to an
83185>>>>>>>/// already existing tablespace, this attribute does not create the tablespace itself.
83185>>>>>>>/// Even though MYSQL uses tablespaces, this this attribute is only supported
83185>>>>>>>/// in Oracle and PostgreSQL.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     ORAFlex PGFlex
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
83185>>>>>>>/// @See         DF_FILE_INDEXTABLESPACE_NAME
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Name of the Tablespace.
83185>>>>>>>/// @Example
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// move 0 to hFile
83185>>>>>>>/// Structure_Start hFile "ORA_DRV"
83185>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
83185>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
83185>>>>>>>///
83185>>>>>>>///             // More table creation here
83185>>>>>>>///
83185>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
83185>>>>>>>Define DF_FILE_TABLESPACE_NAME                      For (DF_FILE_RECORD_REREAD+14)
83185>>>>>>>
83185>>>>>>>// TODO: This is probably deprecated. Investigate.
83185>>>>>>>Define DF_FETCH_FIELDNUMBER                         For (DF_FILE_RECORD_REREAD+15)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_INDEXTABLESPACE_NAME
83185>>>>>>>/// @Description This attribute is used to get or set the name of the tablespace
83185>>>>>>>/// being used for the index segment of a database. For a description of tablespaces,
83185>>>>>>>/// see the description above for DF_FILE_TABLESPACE_NAME. Similar to the Tablespace
83185>>>>>>>/// name attribute, setting the index tablespace name can only be done during creation
83185>>>>>>>/// and must use an already existing tablespace as the variable. This attribute is
83185>>>>>>>/// only available for Oracle and Postgre.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     ORAFlex PGFlex
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
83185>>>>>>>/// @See         DF_FILE_TABLESPACE_NAME
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Name of the Tablespace
83185>>>>>>>/// @Example
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// move 0 to hFile
83185>>>>>>>/// Structure_Start hFile "ORA_DRV"
83185>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
83185>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
83185>>>>>>>///
83185>>>>>>>///             // More table creation here
83185>>>>>>>///             //
83185>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
83185>>>>>>>Define DF_FILE_INDEXTABLESPACE_NAME                 For (DF_FILE_RECORD_REREAD+16)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_RETRIEVE_RECNUM
83185>>>>>>>/// @Description When creating records on a table with RECNUM support, the
83185>>>>>>>/// record number is returned after creation. When this attribute is false, the newly
83185>>>>>>>/// created record's RECNUM is not returned from the server. This could result in a
83185>>>>>>>/// slight performance improvement when many records are being created in a loop.
83185>>>>>>>/// The optimization, however, is negligible.  Having this attribute set to false can
83185>>>>>>>/// have detrimental effects if used improperly; i.e. DD-based saves or UI-based
83185>>>>>>>/// operations. Thus, this should almost always be set to true unless there is a
83185>>>>>>>/// compelling reason to do otherwise.
83185>>>>>>>///
83185>>>>>>>/// Default Value: True
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-31 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable. false to not retrieve record number, true otherwise.
83185>>>>>>>
83185>>>>>>>/// @Example
83185>>>>>>>/// open ORDERHEA
83185>>>>>>>/// Handle  hFile
83185>>>>>>>/// Boolean bRetrieve
83185>>>>>>>///
83185>>>>>>>/// Set_Attribute DF_FILE_RETRIEVE_RECNUM of hFile to false
83185>>>>>>>/// Get_Attribute DF_FILE_RETRIEVE_RECNUM of hFile To bRetrieve
83185>>>>>>>Define DF_FILE_RETRIEVE_RECNUM                      For (DF_FILE_RECORD_REREAD+17)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_NAME_SPACE
83185>>>>>>>/// @Description In Postgres, schemas are objects where all the tables,views and indexes
83185>>>>>>>/// are stored. Separate schemas are used to specify relational data. This attribute is
83185>>>>>>>/// used to set the name of the schema where a table is created. Schema's do not account
83185>>>>>>>/// for any physical space but are merely used as theory to explain the order of a database.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     PGFlex
83185>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Name of the Schema
83185>>>>>>>/// @Example
83185>>>>>>>/// open ORDERHEA
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// String sSchemaName
83185>>>>>>>///
83185>>>>>>>/// Set_Attribute DF_FILE_NAME_SPACE of hFile to "ORDERHEA"
83185>>>>>>>/// Get_Attribute DF_FILE_NAME_SPACE of hFile To sSchemaName
83185>>>>>>>Define DF_FILE_NAME_SPACE                           For (DF_FILE_RECORD_REREAD+18)
83185>>>>>>>
83185>>>>>>>// Currently does not serve any function. May be included in future versions.
83185>>>>>>>Define DF_FILE_STORAGE_PCTFREE                      For (DF_FILE_RECORD_REREAD+19)
83185>>>>>>>
83185>>>>>>>// Currently does not serve any function. May be included in future versions.
83185>>>>>>>Define DF_FILE_STORAGE_PCTUSED                      For (DF_FILE_RECORD_REREAD+21)
83185>>>>>>>
83185>>>>>>>// Currently does not serve any function. May be included in future versions.
83185>>>>>>>Define DF_FILE_STORAGE_INITIAL                      For (DF_FILE_RECORD_REREAD+23)
83185>>>>>>>
83185>>>>>>>// Currently does not serve any function. May be included in future versions.
83185>>>>>>>Define DF_FILE_STORAGE_NEXT                         For (DF_FILE_RECORD_REREAD+25)
83185>>>>>>>
83185>>>>>>>// Currently does not serve any function. May be included in future versions.
83185>>>>>>>Define DF_FILE_ALLOW_NULL                           For (DF_FILE_RECORD_REREAD+27)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_GET_SERVERNAME_FROM_LOGIN
83185>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will
83185>>>>>>>/// be included in the INT file.  If set to True, the SERVER_NAME option will not
83185>>>>>>>/// be included in the INT file, if set to false, the SERVER_NAME option will be
83185>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
83185>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
83185>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
83185>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
83185>>>>>>>/// setting it to true will NOT include the SERVER_NAME in the INT file.
83185>>>>>>>///
83185>>>>>>>/// Default Value: False
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Deprecated
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
83185>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
83185>>>>>>>/// @INTOPT              SERVER_NAME
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>///     Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of Customer.File_Number to True
83185>>>>>>>///
83185>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
83185>>>>>>>///
83185>>>>>>>/// Close Customer
83185>>>>>>>Define DF_FILE_GET_SERVERNAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+29)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
83185>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will be included
83185>>>>>>>/// in the INT file.  If set to True, the server name will not be included in the INT file,
83185>>>>>>>/// if set to false, the server name will be included in the INT file. This has two uses.
83185>>>>>>>/// The first is during a Structure_Start i.e. table creation/modification. The other is
83185>>>>>>>/// when using the OUTPUT_INT_FILE command. Set this attribute before the OUTPUT_INT_FILE
83185>>>>>>>/// to indicate how the INT file will be written.
83185>>>>>>>///
83185>>>>>>>/// Default Value: False
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
83185>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
83185>>>>>>>/// @INTOPT              SERVER_NAME
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>///   Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of Customer.File_Number to True
83185>>>>>>>///
83185>>>>>>>///   OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
83185>>>>>>>///
83185>>>>>>>/// Close Customer
83185>>>>>>>Define DF_FILE_SUPPRESS_SERVERNAME_OUTPUT                       For DF_FILE_GET_SERVERNAME_FROM_LOGIN
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_GET_DATABASENAME_FROM_LOGIN
83185>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
83185>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
83185>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
83185>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
83185>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
83185>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
83185>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
83185>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
83185>>>>>>>///
83185>>>>>>>/// Default Value: False
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Deprecated
83185>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
83185>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
83185>>>>>>>/// @INTOPT              DATABASE_NAME
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>///     Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of Customer.File_Number to True
83185>>>>>>>///
83185>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
83185>>>>>>>///
83185>>>>>>>/// Close Customer
83185>>>>>>>Define DF_FILE_GET_DATABASENAME_FROM_LOGIN          For (DF_FILE_RECORD_REREAD+31)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
83185>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
83185>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
83185>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
83185>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
83185>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
83185>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
83185>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
83185>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
83185>>>>>>>///
83185>>>>>>>/// Default Value: False
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
83185>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
83185>>>>>>>/// @INTOPT              DATABASE_NAME
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of Customer.File_Number to True
83185>>>>>>>///
83185>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
83185>>>>>>>///
83185>>>>>>>/// Close Customer
83185>>>>>>>Define DF_FILE_SUPPRESS_DATABASENAME_OUTPUT                     For DF_FILE_GET_DATABASENAME_FROM_LOGIN
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_GET_SCHEMANAME_FROM_LOGIN
83185>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
83185>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
83185>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
83185>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
83185>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
83185>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
83185>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
83185>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
83185>>>>>>>///
83185>>>>>>>/// Default Value: False
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Deprecated
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
83185>>>>>>>/// @See         DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
83185>>>>>>>/// @INTOPT              SCHEMA_NAME
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>///     Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of Customer.File_Number to True
83185>>>>>>>///
83185>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
83185>>>>>>>///
83185>>>>>>>/// Close Customer
83185>>>>>>>Define DF_FILE_GET_SCHEMANAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+33)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
83185>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
83185>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
83185>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
83185>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
83185>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
83185>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
83185>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
83185>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
83185>>>>>>>///
83185>>>>>>>/// Default Value: False
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
83185>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
83185>>>>>>>/// @INTOPT              SCHEMA_NAME
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of Customer.File_Number to True
83185>>>>>>>///
83185>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
83185>>>>>>>///
83185>>>>>>>/// Close Customer
83185>>>>>>>Define DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT           For DF_FILE_GET_SCHEMANAME_FROM_LOGIN
83185>>>>>>>
83185>>>>>>>//TODO
83185>>>>>>>Define DF_FILE_PRESERVE_RECNUM                      For 184
83185>>>>>>>
83185>>>>>>>// Currently Unsupported Attribute
83185>>>>>>>Define DF_FILE_NATIVE_RECORD_LENGTH                 For 194
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_OEM_TRANSLATION
83185>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
83185>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
83185>>>>>>>/// code pages. When migrating data, this attribute is used to determine whether
83185>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
83185>>>>>>>/// migrating passwords with special characters may call for different code pages.
83185>>>>>>>/// Setting this attribute to true will convert the OEM data to ANSI, setting it
83185>>>>>>>/// to false will not.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Indicates if OEM data will be converted to ANSI. True converts it, false does not.
83185>>>>>>>/// @Example
83185>>>>>>>/// open Customer
83185>>>>>>>///
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// Boolean bTranslate
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile
83185>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
83185>>>>>>>///     Get_Attribute DF_FILE_OEM_TRANSLATION of hFile to bTranslate
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>Define DF_FILE_OEM_TRANSLATION                      For (DF_FILE_RECORD_REREAD+51)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_EPOCH_YEAR
83185>>>>>>>/// @Description When dealing with two-digit years, an epoch year must be used
83185>>>>>>>/// to determine which century the date is referring to. For example if the
83185>>>>>>>/// epoch year is set to 30, then any two digit year greater than 30 will be
83185>>>>>>>/// considered in the 20th Century, anything less than or equal to 30 will be
83185>>>>>>>/// considered in the 21st Century.  This attribute is used to turn on or off
83185>>>>>>>/// this feature. To use this feature, set this attribute to whatever the epoch
83185>>>>>>>/// year is expected to be. To disable this feature, set this attribute to 0
83185>>>>>>>/// or false. Note that setting this attribute must be done at table creation
83185>>>>>>>/// or inside of a Structure_Start.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT      EPOCH_YEAR
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Indicates what the epoch year is. 0 to disable
83185>>>>>>>/// @Example
83185>>>>>>>/// open Customer
83185>>>>>>>///
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// Boolean bEpoch
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile
83185>>>>>>>///     Set_Attribute DF_FILE_EPOCH_YEAR of hFile to 30
83185>>>>>>>///     Get_Attribute DF_FILE_EPOCH_YEAR of hFile to bEpoch
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>Define DF_FILE_EPOCH_YEAR                           For (DF_FILE_RECORD_REREAD+53)
83185>>>>>>>
83185>>>>>>>Define DF_FILE_USE_ROWCOUNT_IN_TRANSACTIONS         For 628
83185>>>>>>>Define DF_FILE_ICF_STATUS                           For 630
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_LOCK_RECORD_STATUS
83185>>>>>>>/// @Description Table locking is done during transactions to maintain atomicity.
83185>>>>>>>/// In DataFlex, this is usually done with the REREAD/UNLOCK commands. This
83185>>>>>>>/// attribute is used to get the status of a table lock. If a table is currently
83185>>>>>>>/// in a REREAD, or locked, then the attribute will return true. Otherwise, it
83185>>>>>>>/// returns false. It is a read-only attribute so no setting can be done.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_LOCK_RECORD_STATUS of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Indicates the status of the file lock
83185>>>>>>>/// @Example
83185>>>>>>>/// open Customer
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// Integer bLocked
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_FILE_LOCK_RECORD_STATUS of hFile to bLocked
83185>>>>>>>Define DF_FILE_LOCK_RECORD_STATUS                   For 632
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_CASING
83185>>>>>>>/// @Description Controls the filename and column name casing.
83185>>>>>>>/// You can set this to either keep the file case, force to lower case or force
83185>>>>>>>/// to uppercase.
83185>>>>>>>///
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_CASING of {FileNumber} to {FILE_CASING_KEEP|FILE_CASING_LOWER|FILE_CASING_UPPER}
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_CASING of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber          Number of the file
83185>>>>>>>/// @Param  variable              integer set to one of the above values.
83185>>>>>>>/// @Example
83185>>>>>>>/// open Customer
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// Integer eCasing
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile "ORA_DRV"
83185>>>>>>>///    Set_Attribute DF_FILE_CASING of hFile to FILE_CASING_KEEP
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>///
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_FILE_CASING of hFile to eCasing
83185>>>>>>>
83185>>>>>>>
83185>>>>>>>Define DF_FILE_CASING                               For 634
83185>>>>>>>
83185>>>>>>>Define DF_FIELD_INVERSE_KEY_NAME                    For (DF_FIELD_NATIVE_LENGTH+1)
83185>>>>>>>Define DF_FIELD_INVERSE_KEY_TYPE                    For (DF_FIELD_NATIVE_LENGTH+2)
83185>>>>>>>
83185>>>>>>>//TODO
83185>>>>>>>Define DF_FIELD_TEXT_SEGMENT_NAME                   For (DF_FIELD_NATIVE_LENGTH+3)
83185>>>>>>>
83185>>>>>>>//TODO
83185>>>>>>>Define DF_FIELD_TEXT_NUM_SEGMENTS                   For (DF_FIELD_NATIVE_LENGTH+4)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FIELD_DEFAULT_VALUE
83185>>>>>>>/// @Description Use this attribute to get or set the default value for a given column.
83185>>>>>>>/// Setting the default value can only be done during a structure_start or during table
83185>>>>>>>/// creation. If this attribute is not set, it is defaulted to the driver default.
83185>>>>>>>/// See Mertech.cfg
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Syntax Get_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  FieldNumber           Number of the field
83185>>>>>>>/// @Param  variable              Variable for the default value of the field
83185>>>>>>>/// @Example
83185>>>>>>>/// open Customer
83185>>>>>>>/// String sDefault
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// Integer iColumn
83185>>>>>>>///
83185>>>>>>>/// Move "California" to sDefault
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>/// Move 3 to iColumn
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile "ORA_DRV"
83185>>>>>>>///    Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
83185>>>>>>>Define DF_FIELD_DEFAULT_VALUE                       For (DF_FIELD_NATIVE_LENGTH+5)
83185>>>>>>>
83185>>>>>>>// Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_TEXT_LENGTH_SEGMENT                 For (DF_FIELD_NATIVE_LENGTH+6)
83185>>>>>>>
83185>>>>>>>//TODO
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FIELD_TIME_ON
83185>>>>>>>/// @Description Assign a field to retrieve Time Stamp value from a DATETIME
83185>>>>>>>/// column in a table.
83185>>>>>>>///
83185>>>>>>>/// This option was implemented because some versions of DataFlex do not support
83185>>>>>>>/// DATETIME fields normally supported by SQL databases.
83185>>>>>>>///
83185>>>>>>>/// To use this: Change the type of a date field in your FD to string type,
83185>>>>>>>/// Set the attribute DF_FIELD_TIME_ON of this field to TRUE and
83185>>>>>>>/// recompile your program.
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote
83185>>>>>>>/// @See
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FIELD_TIME_ON of <FileNumber|FileName FieldNumber> to DFTRUE | DFFALSE
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  FileName              Name of the file
83185>>>>>>>/// @Param  FieldNumber           Number of the field
83185>>>>>>>/// @Example
83185>>>>>>>/// #INCLUDE MERTECH.INC
83185>>>>>>>/// string sDateTime sDatabaseName
83185>>>>>>>/// open ORDERHEA
83185>>>>>>>/// Set_Attribute DF_FIELD_TIME_ON of 30 3 to dfTrue
83185>>>>>>>/// find GE ORDERHEA by recnum
83185>>>>>>>/// move ORDERHEA.ORDER_DATE to sDateTime
83185>>>>>>>/// showln "sDateTime: " sDateTime
83185>>>>>>>Define DF_FIELD_TIME_ON                             For (DF_FIELD_NATIVE_LENGTH+8)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FIELD_NATIVE_NAME
83185>>>>>>>/// @Description This attribute is used to get the name of the desired column
83185>>>>>>>/// on the SQL backend. Currently this attribute is ReadOnly and so setting
83185>>>>>>>/// or modifying a column name cannot be done using this attribute.  In most
83185>>>>>>>/// cases, the field name on the SQL backend will be the same as the Dataflex name.
83185>>>>>>>///
83185>>>>>>>/// This is a ReadOnly attribute.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_NAME of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber          Number of the file
83185>>>>>>>/// @Param  FieldNumber                 Number of the Field
83185>>>>>>>/// @Param  variable                    String containing the name of the field
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// String sName
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_FIELD_NATIVE_NAME of Customer.File_Number 3 to sName
83185>>>>>>>Define DF_FIELD_NATIVE_NAME                         For (DF_FIELD_NATIVE_LENGTH+9)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FIELD_NULL
83185>>>>>>>/// @Description Use this attribute to get or set whether a column in a table will
83185>>>>>>>/// allow null values. When set to true, the column accepts null values. Setting
83185>>>>>>>/// this attribute to false will keep it from accepting null values. Although,
83185>>>>>>>/// getting the value of this attribute can be done at anytime, setting it must
83185>>>>>>>/// be done in a Structure_Start or during table creation.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber          Number of the file
83185>>>>>>>/// @Param  FieldNumber                 Number of the Field
83185>>>>>>>/// @Param  variable                    Boolean variable
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>/// Handle hFile
83185>>>>>>>/// Integer iColumn
83185>>>>>>>/// Boolean bAllowNull
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>/// Move 3 to iColumn
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile "ORA_DRV"
83185>>>>>>>///    Set_Attribute DF_FIELD_NULL of hFile iColumn to True
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_FIELD_NULL of hFile iColumn to bAllowNull
83185>>>>>>>Define DF_FIELD_NULL                                For (DF_FIELD_NATIVE_LENGTH+10)
83185>>>>>>>
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FIELD_NATIVE_TYPE
83185>>>>>>>/// @Description Use this attribute to get or set the Native type for a specific
83185>>>>>>>/// field in a table.  The native type refers to the data type of the field on the
83185>>>>>>>/// SQL backend. Setting this attribute can only be done during table creation or
83185>>>>>>>/// inside of a Structure_Start. When setting this attribute, it is good practice
83185>>>>>>>/// to use the constants mentioned below instead of the integers. For a list of
83185>>>>>>>/// these constants, refer to the sections: "Oracle Data Types", "MySQL Data Types",
83185>>>>>>>/// "PostgreSQL Data Types", and "SQL Server Data Types" included in this document.
83185>>>>>>>/// Note that when getting the value for this attribute, an integer will be returned
83185>>>>>>>/// so these lists of constants can again prove useful.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT      FIELD_TYPE
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber          Number of the file
83185>>>>>>>/// @Param  FieldNumber         Number of the field
83185>>>>>>>/// @Param  variable                    variable for the native data type
83185>>>>>>>/// @Example
83185>>>>>>>/// open Customer
83185>>>>>>>///
83185>>>>>>>/// Integer iColumn iType
83185>>>>>>>/// Handle hFile
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>/// Structure_Start hFile
83185>>>>>>>///     Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to "eSQLServer_DATE"
83185>>>>>>>///     Get_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
83185>>>>>>>///     Structure_End hFile
83185>>>>>>>Define DF_FIELD_NATIVE_TYPE                         For (DF_FIELD_NATIVE_LENGTH+12)
83185>>>>>>>
83185>>>>>>>// Currently Unsupported Attribute (readOnly used by DataFlex 18.0 Studio)
83185>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME                    For 711
83185>>>>>>>
83185>>>>>>>// Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_NATIVE_OFFSET                       For (DF_FIELD_NATIVE_LENGTH+14)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FIELD_AUTO_INCREMENT
83185>>>>>>>/// @Description Auto incrementing is a technique used in Dataflex usually for
83185>>>>>>>/// fields that are set as the unique identifier. Instead of generating a value
83185>>>>>>>/// or manually inserting data into the column, when a field auto increments,
83185>>>>>>>/// the value of the field increases by one (usually) with each record.  This
83185>>>>>>>/// field is used to get or set whether the field uses this technique or not.
83185>>>>>>>/// The attribute, however, can only be set inside of a Structure_Start or during
83185>>>>>>>/// table creation. Getting the attribute's value can be done at anytime. The
83185>>>>>>>/// value is stored as a boolean, either true or false.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT      FIELD_AUTOINCREMENT_TYPE
83185>>>>>>>///
83185>>>>>>>/// @Syntax Set_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Syntax Get_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber          Number of the file
83185>>>>>>>/// @Param  FieldNumber         Number of the field
83185>>>>>>>/// @Param  variable                    Boolean variable indicating if the field auto increments.
83185>>>>>>>/// @Example
83185>>>>>>>/// open Customer
83185>>>>>>>///
83185>>>>>>>/// Integer iColumn
83185>>>>>>>/// Boolean bIncrement
83185>>>>>>>/// Handle hFile
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile
83185>>>>>>>///     Set_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to True
83185>>>>>>>///     Get_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to bIncrement
83185>>>>>>>///     Structure_End hFile
83185>>>>>>>Define DF_FIELD_AUTO_INCREMENT                      For (DF_FIELD_NATIVE_LENGTH+16)
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_GENERATE_ALWAYS                     For (DF_FIELD_NATIVE_LENGTH+18)
83185>>>>>>>
83185>>>>>>>// Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_SEND_LONG_DATA                      For 702
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_INDEX_NATIVE_CREATED
83185>>>>>>>/// @Description Use this attribute to verify if the index that maps to the DataFlex
83185>>>>>>>/// index was created correctly at the SQL backend
83185>>>>>>>///
83185>>>>>>>/// This is a ReadOnly attribute
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Wil van Antwerpen
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NATIVE_CREATED of {FileNumber} {IndexNumber} to variable
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  IndexNumber           Number of the index
83185>>>>>>>/// @Param  variable              True if created, false if not
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// Handle  hFile
83185>>>>>>>/// Integer iIndex
83185>>>>>>>/// Boolean bCreated
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>/// Move 1 To iIndex
83185>>>>>>>/// Get_Attribute DF_INDEX_NATIVE_CREATED of hFile iIndex to bCreated
83185>>>>>>>Define DF_INDEX_NATIVE_CREATED                      For (DF_INDEX_KEY_LENGTH+1)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_INDEX_NAME
83185>>>>>>>/// @Description Use this attribute to get the name of the index on the SQL backend
83185>>>>>>>/// that maps to the numbered index in Dataflex.  This is because, unlike Dataflex,
83185>>>>>>>/// all indexes in SQL are stored as names, not numbers. Since this attribute is
83185>>>>>>>/// currently only a ReadOnly attribute, it can not be used to set or modify a named
83185>>>>>>>/// index.
83185>>>>>>>///
83185>>>>>>>/// This is a ReadOnly attribute
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NAME of {FileNumber} {IndexNumber} to variable
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  IndexNumber           Number of the index
83185>>>>>>>/// @Param  variable              Name of the index
83185>>>>>>>/// @Example
83185>>>>>>>///
83185>>>>>>>/// Integer iFile iIndex iIndexes
83185>>>>>>>///
83185>>>>>>>/// Open Orderhea
83185>>>>>>>/// Move Orderhea.File_Number to iFile
83185>>>>>>>/// Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
83185>>>>>>>///
83185>>>>>>>/// For iIndex From 0 to iIndexes
83185>>>>>>>///     Get_Attribute DF_INDEX_NAME of iFile iIndex to sIndexName
83185>>>>>>>///     Showln "Orderhea.Index." iIndex " : " sIndexName
83185>>>>>>>/// Loop
83185>>>>>>>Define DF_INDEX_NAME                                For (DF_INDEX_KEY_LENGTH+2)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_PRIMARY_KEY
83185>>>>>>>/// @Description This attribute is used to get or set the index number
83185>>>>>>>/// being used for the primary key. Getting the index number can be
83185>>>>>>>/// done at any time, but setting the index must be during a
83185>>>>>>>/// Structure_Start or during table creation.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Deprecated
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
83185>>>>>>>/// @See                 DF_INDEX_PRIMARY_KEY
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Index number being used with primary key
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// Integer iKey
83185>>>>>>>/// Handle hFile
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile
83185>>>>>>>///     Set_Attribute DF_PRIMARY_KEY of hFile to 2
83185>>>>>>>///     Get_Attribute DF_PRIMARY_KEY of hFile to iKey
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>Define DF_PRIMARY_KEY                               For (DF_INDEX_KEY_LENGTH+3)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_INDEX_PRIMARY_KEY
83185>>>>>>>/// @Description This attribute is used to get or set the index number
83185>>>>>>>/// being used for the primary key. Getting the index number can be
83185>>>>>>>/// done at any time, but setting the index must be during a
83185>>>>>>>/// Structure_Start or during table creation.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT              PRIMARY_KEY
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Index number being used with primary key
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// Integer iKey
83185>>>>>>>/// Handle hFile
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile
83185>>>>>>>///     Set_Attribute DF_INDEX_PRIMARY_KEY of hFile to 2
83185>>>>>>>///     Get_Attribute DF_INDEX_PRIMARY_KEY of hFile to iKey
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>Define DF_INDEX_PRIMARY_KEY                         For (DF_INDEX_KEY_LENGTH+3)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_INDEX_STATUS
83185>>>>>>>/// @Description Oracle has an attribute for indexes called "STATUS" which indicates
83185>>>>>>>/// whether or not an index is valid for use. This attribute can only be used to get
83185>>>>>>>/// the value of the "STATUS" property in Oracle. It currently does not support setting
83185>>>>>>>/// the attribute. The two values for this attribute are "VALID" or "UNUSABLE".
83185>>>>>>>///
83185>>>>>>>/// This is a ReadOnly attribute
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     ORAFlex
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_INDEX_STATUS of {FileNumber} {IndexNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  FieldNumber           Number of the index
83185>>>>>>>/// @Param  variable              String indicating validity
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// String sIndexStatus
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_INDEX_STATUS of Customer.File_Number 1 to sIndexStatus
83185>>>>>>>Define DF_INDEX_STATUS                              For (DF_INDEX_KEY_LENGTH+4)
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_INDEX_STORAGE_PCTFREE                     For (DF_INDEX_KEY_LENGTH+5)
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_INDEX_UNIQUE
83185>>>>>>>/// @Description An index on a column that is unique is considered so if it
83185>>>>>>>/// does not have two equal values in that column in two different rows. This
83185>>>>>>>/// attribute is used to find out whether or not the specified index is unique.
83185>>>>>>>/// If it is, this attribute will return "U" indicating that it is indeed unique.
83185>>>>>>>/// This is important to note because when getting the value of this attribute,
83185>>>>>>>/// a string variable must be used. Since this is a ReadOnly attribute, setting
83185>>>>>>>/// an idex to unique cannot be done with this attribute.
83185>>>>>>>///
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_INDEX_UNIQUE of {FileNumber} {IndexNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  FieldNumber           Number of the index
83185>>>>>>>/// @Param  variable              String indicating if unique
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// String sIndexUnique
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_INDEX_UNIQUE of Customer.File_Number 1 to sIndexUnique
83185>>>>>>>Define DF_INDEX_UNIQUE                              For (DF_INDEX_KEY_LENGTH+6)
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_INDEX_STORAGE_BASE                        For (DF_INDEX_KEY_LENGTH+7)
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_INDEX_STORAGE_INITIAL                     For (DF_INDEX_KEY_LENGTH+8)
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_INDEX_STORAGE_NEXT                        For (DF_INDEX_KEY_LENGTH+10)
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_INDEX_NATIVE_TYPE                         For (DF_INDEX_KEY_LENGTH+13)
83185>>>>>>>
83185>>>>>>>//TODO
83185>>>>>>>Define DF_INDEX_TABLESPACE                          For (DF_INDEX_KEY_LENGTH+14)
83185>>>>>>>
83185>>>>>>>//TODO
83185>>>>>>>Define DF_FIELD_PROGRAMMATIC_DEFAULT                For 701
83185>>>>>>>Define DF_FIELD_TIME                                For 703
83185>>>>>>>Define DF_FIELD_IS_NULL                             For 704
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FIELD_IS_LOB
83185>>>>>>>/// @Description In databases a LOB data type is any type that is considered
83185>>>>>>>/// a "Large Object" i.e. XML types, Binary types etc.  This attribute is a
83185>>>>>>>/// ReadOnly attribute used to indicate whether the given field is considered
83185>>>>>>>/// a LOB data type. Since it is ReadOnly, this attribute cannot set a field
83185>>>>>>>/// to a LOB data type.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FIELD_IS_LOB of {FileNumber} {FieldNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param      FieldNumber                       Number of the field
83185>>>>>>>/// @Param  variable              Boolean variable indicating if LOB
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// Boolean bIsLOB
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_FIELD_IS_LOB of Customer.File_Number 6 to bIsLOB
83185>>>>>>>Define DF_FIELD_IS_LOB                              For 706
83185>>>>>>>Define DF_FIELD_DEFAULT_FUNCTION                    For 707
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_HANDLE_AS_LOB                       For 708
83185>>>>>>>
83185>>>>>>>//TODO
83185>>>>>>>Define DF_FIELD_PARTIAL_OVERLAP                     For 710
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_NUMBER_SQL_RELATIONS
83185>>>>>>>/// @Description This attribute is used to get the number of foreign keys
83185>>>>>>>/// for a given table on the SQL backend. Foreign keys are used to specify
83185>>>>>>>/// relationships between tables. Since this attribute is ReadOnly, it cannot
83185>>>>>>>/// be used to set the number of foreign keys in a table.  Note that this
83185>>>>>>>/// attribute returns only the number of foreign keys, no other information
83185>>>>>>>/// is provided with this attribute.
83185>>>>>>>///
83185>>>>>>>/// This is a ReadOnly attribute
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
83185>>>>>>>/// @See
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Integer variable showing number of relationships
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// Integer iRelations
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of Customer.File_Number to iRelations
83185>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS                 For 626
83185>>>>>>>
83185>>>>>>>//TODO
83185>>>>>>>Define DF_SQL_RELATION_COLUMN                       For 716
83185>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA               For 717
83185>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE                For 719
83185>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN               For 721
83185>>>>>>>Define DF_SQL_RELATION_NAME                         For 723
83185>>>>>>>Define DF_SQL_RELATION_STATUS                       For 724
83185>>>>>>>Define DF_SQL_RELATION_DELETE_REF_ACTION            For 726
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_OVERLAP_START                       For 728
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_OVERLAP_END                         For 730
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_START                For 732
83185>>>>>>>
83185>>>>>>>//Currently Unsupported Attribute
83185>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_END                  For 734
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_RECNUM_TABLE
83185>>>>>>>/// @Description Dataflex's embedded database, by default, uses a Recnum column
83185>>>>>>>/// as the unique identifier for a table instead of a primary key. A table can
83185>>>>>>>/// easily be changed to use another column though and this attribute gets or
83185>>>>>>>/// sets whether the Recnum is being used for a table. Getting the value of this
83185>>>>>>>/// attribute can be done at any time for any driver. The setting of this attribute,
83185>>>>>>>/// however, can only be done in certain situations. Only if an alternative primary
83185>>>>>>>/// key is set up already can this attribute be set to false and only during a
83185>>>>>>>/// Structure_Start. Also, the attribute can only be turned off (set to false),
83185>>>>>>>/// it can not be turned back on (set to True).
83185>>>>>>>///
83185>>>>>>>/// Note: In Postgres, this attribute is a ReadOnly attribute and can not be set.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public (PGFlex ReadOnly)
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
83185>>>>>>>/// @See                 DF_FILE_RECNUM_NAME DF_FILE_PRIMARY_INDEX
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable indicating if recnum is used
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// Boolean bRecnum
83185>>>>>>>/// Handle hFile
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile
83185>>>>>>>///     Set_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to False
83185>>>>>>>///     Get_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to bRecnum
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>Define DF_FILE_RECNUM_TABLE                         For 1401
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_PRIMARY_INDEX
83185>>>>>>>/// @Description This attribute gets or sets the index which is used as the
83185>>>>>>>/// primary key for a table. The variable used for this attribute is an integer
83185>>>>>>>/// containing the numbered index used. Getting the value of this attribute can
83185>>>>>>>/// be done at any time, whereas setting can only be done at table creation or
83185>>>>>>>/// during a Structure_Start. If a RECNUM is used as the unique identifier then
83185>>>>>>>/// 0 is returned.
83185>>>>>>>///
83185>>>>>>>/// Note: In Postgres this attribute is ReadOnly, so it can only be used to get
83185>>>>>>>/// the index used as the primary key.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public (PGFlex ReadOnly)
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
83185>>>>>>>/// @See                 DF_FILE_RECNUM_NAME
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
83185>>>>>>>/// @Syntax Set_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              Boolean variable indicating if a primary key is used
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// Boolean bPrimary
83185>>>>>>>/// Handle hFile
83185>>>>>>>///
83185>>>>>>>/// Move Customer.File_Number to hFile
83185>>>>>>>///
83185>>>>>>>/// Structure_Start hFile
83185>>>>>>>///     Set_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to False
83185>>>>>>>///     Get_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to bPrimary
83185>>>>>>>/// Structure_End hFile
83185>>>>>>>Define DF_FILE_PRIMARY_INDEX                        For 1402
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>/// @Name        DF_FILE_RECNUM_NAME
83185>>>>>>>/// @Description This attribute is used to get the name of the Recnum field
83185>>>>>>>/// in the table, if one exists. It is a ReadOnly attribute so it can only
83185>>>>>>>/// be used in getting the name of the recnum field to a string variable.
83185>>>>>>>///
83185>>>>>>>/// @Assumptions
83185>>>>>>>/// @Status      Public
83185>>>>>>>/// @Drivers     All
83185>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
83185>>>>>>>/// @See                 DF_FILE_RECNUM_TABLE
83185>>>>>>>/// @INTOPT
83185>>>>>>>///
83185>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_NAME of {FileNumber} to {variable}
83185>>>>>>>/// @Param  FileNumber            Number of the file
83185>>>>>>>/// @Param  variable              String name of recnum field
83185>>>>>>>/// @Example
83185>>>>>>>/// Open Customer
83185>>>>>>>///
83185>>>>>>>/// String sRecnum
83185>>>>>>>///
83185>>>>>>>/// Get_Attribute DF_FILE_RECNUM_NAME of Customer.File_Number to sRecnum
83185>>>>>>>Define DF_FILE_RECNUM_NAME                          For 1403
83185>>>>>>>
83185>>>>>>>Define DF_FETCH_ALL                                 For -1
83185>>>>>>>Define DF_FETCH_TRUE                                For "TRUE"
83185>>>>>>>Define DF_FETCH_FALSE                               For "FALSE"
83185>>>>>>>Define DF_BIND_ALL_COLUMNS                          For -1
83185>>>>>>>
83185>>>>>>>// SQLFlex Lock Type
83185>>>>>>>Define DF_LOCK_TYPE_PAGE                            For 3
83185>>>>>>>
83185>>>>>>>// Extended Callback Types
83185>>>>>>>Define DF_MESSAGE_ERROR                             For 9
83185>>>>>>>Define DF_MESSAGE_PROGRESS_STATUS                   For 20
83185>>>>>>>Define DF_MESSAGE_PROGRESS_CONTINUE                 For 21
83185>>>>>>>
83185>>>>>>>//Drivers
83185>>>>>>>Define ORAFLEX                                      For "ORA_DRV"
83185>>>>>>>Define SQLFLEX                                      For "SQL_DRV"
83185>>>>>>>Define MDSDB2                                       For "MDS_DB2"
83185>>>>>>>Define MDSPgSQL                                     For "MDSPGSQL"
83185>>>>>>>Define PgFlex                                       For "MDSPGSQL"
83185>>>>>>>Define MDSMySQL                                     For "MDSMYSQL"
83185>>>>>>>Define MySQLFlex                                    For "MDSMYSQL"
83185>>>>>>>
83185>>>>>>>// Delimiter for SQL ID objects
83185>>>>>>>Define DB2_ID_DELIM                                 For '"'
83185>>>>>>>Define MYSQL_ID_DELIM                               For "`"
83185>>>>>>>Define ORACLE_ID_DELIM                              For '"'
83185>>>>>>>Define PGSQL_ID_DELIM                               For '"'
83185>>>>>>>Define SQLSERVER_ID_DELIM                           For '"'
83185>>>>>>>
83185>>>>>>>// dfStructureEnd Option bits
83185>>>>>>>Define DF_STRUCTEND_OPT_INDEX_ONLY                  For 16    // Internal Use Only
83185>>>>>>>Define DF_STRUCTEND_OPT_FORCE_INVK                  For 32
83185>>>>>>>Define DF_STRUCTEND_OPT_OLD_INVK_NAME               For 64
83185>>>>>>>Define DF_STRUCTEND_OPT_FORCE_NOT_NULL              For 128
83185>>>>>>>Define DF_STRUCTEND_OPT_CREATE_ROWID_TABLE          For 256
83185>>>>>>>
83185>>>>>>>//Additional Data Types
83185>>>>>>>Define DF_DATETIME                                  For 7
83185>>>>>>>
83185>>>>>>>//Call_Driver Functions
83185>>>>>>>Define CALLDRV_LICENSE_ENVIRONMENT_SET              For 0
83185>>>>>>>Define CALLDRV_ORA_CURRENT_SQL_SERVER               For 6
83185>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE                    For 14
83185>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER                   for 19
83185>>>>>>>Define CALLDRV_SQL_NEXT_RESULTSET                                       for 22
83185>>>>>>>Define CALLDRV_BIND_PARAMETER                       for 23
83185>>>>>>>Define CALLDRV_SQL_MAX_CURSORS                      For 26
83185>>>>>>>Define CALLDRV_SQLLOADER_FIELDS_TERM                For 30
83185>>>>>>>Define CALLDRV_CREATE_TABLE_FROM_DAT                For 30
83185>>>>>>>Define CALLDRV_SQLLOADER_DECIMAL_SEP                For 31
83185>>>>>>>Define CALLDRV_CONVERT_DAT_FILE                     For 32
83185>>>>>>>Define CALLDRV_SQLFLEX_MAX_CURSORS                  For 37
83185>>>>>>>Define CALLDRV_NATIVE_OPTIMIZATION                  For 38
83185>>>>>>>Define CALLDRV_GET_RETURNED_COLUMNS                 For 39
83185>>>>>>>Define CALLDRV_GET_RETURNED_ROWS                    For 40
83185>>>>>>>Define CALLDRV_GET_COLUMN_ATTRIBUTE                 For 41
83185>>>>>>>Define CALLDRV_START_TXTGEN_AFTER_RECNUM            For 42
83185>>>>>>>Define CALLDRV_FINISH_TXTGEN_AFTER_RECNUM           For 43
83185>>>>>>>Define CALLDRV_SET_ISOLATION_LEVEL                  For 44
83185>>>>>>>Define CALLDRV_GET_SERVER_CFG                       For 45
83185>>>>>>>Define CALLDRV_SET_SQL_LOCK_TIMEOUT                 For 46
83185>>>>>>>Define CALLDRV_GET_SQL_LOCK_TIMEOUT                 For 47
83185>>>>>>>Define CALLDRV_GET_RESULTS                          For 48
83185>>>>>>>Define CALLDRV_GET_MORE_RESULTS                     For 49
83185>>>>>>>Define CALLDRV_GET_CURRENT_USER_NAME                For 50
83185>>>>>>>Define CALLDRV_OPEN_EMBEDDED_CURSOR                 For 51
83185>>>>>>>Define CALLDRV_CLOSE_EMBEDDED_CURSOR                For 52
83185>>>>>>>Define CALLDRV_SET_CURRENT_EMBEDDED_CURSOR          For 53
83185>>>>>>>Define CALLDRV_GET_CURRENT_EMBEDDED_CURSOR          For 54
83185>>>>>>>Define CALLDRV_SET_MAX_EMBEDDED_CURSOR              For 55
83185>>>>>>>Define CALLDRV_GET_MAX_EMBEDDED_CURSOR              For 56
83185>>>>>>>Define CALLDRV_SQL_TRANSACTION                      For 57
83185>>>>>>>Define CALLDRV_LOCAL_TD_PATH                        For 58
83185>>>>>>>Define CALLDRV_CREATE_DB                            For 59
83185>>>>>>>Define CALLDRV_ESCAPE_STRING                        For 60
83185>>>>>>>Define CALLDRV_SET_PROC_ATTRIBUTE_TYPE              For 61
83185>>>>>>>Define CALLDRV_SQL_REFRESH_CACHE                    For 62
83185>>>>>>>Define CALLDRV_GET_SQL_STMT                         For 63
83185>>>>>>>Define CALLDRV_DIRECT_PATH_LOAD                     For 64
83185>>>>>>>
83185>>>>>>>Define CALLDRV_READ_LOB                             For 65
83185>>>>>>>Define CALLDRV_WRITE_LOB                            For 66
83185>>>>>>>Define CALLDRV_APPEND_LOB                           For 67
83185>>>>>>>Define CALLDRV_LENGTH_LOB                           For 68
83185>>>>>>>Define CALLDRV_LOADFROMFILE_LOB                     For 69
83185>>>>>>>Define CALLDRV_ERASE_LOB                            For 70
83185>>>>>>>Define CALLDRV_TRUNCATE_LOB                         For 71
83185>>>>>>>Define CALLDRV_INITIALIZE_SEQUENCE                  For 72
83185>>>>>>>Define CALLDRV_CLIENT_CFG                           For 73
83185>>>>>>>Define CALLDRV_END_SAVERECORD                       For 74
83185>>>>>>>Define CALLDRV_ENABLE_RECONNECT                     For 75
83185>>>>>>>Define CALLDRV_ENUMERATE_SERVER                     For 76
83185>>>>>>>Define CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS         For 77
83185>>>>>>>Define CALLDRV_USE_DFLEX_DATE_FORMAT                For 78
83185>>>>>>>Define CALLDRV_FORCE_FIELDS_NOT_NULL                For 79
83185>>>>>>>Define CALLDRV_ORA_CREATE_TABLE_FROM_DAT            For 80
83185>>>>>>>Define CALLDRV_MAX_DATA_SIZE                        For 81
83185>>>>>>>Define CALLDRV_CHUNK_SIZE                           For 82
83185>>>>>>>Define CALLDRV_GET_DATA_CHUNK                       For 83
83185>>>>>>>Define CALLDRV_MIRROR_SERVER                        For 84
83185>>>>>>>Define CALLDRV_COPY_DATA                            For 85
83185>>>>>>>Define CALLDRV_SET_SQL_CURSOR_TYPE                  For 86
83185>>>>>>>Define CALLDRV_ICF                                  For 87
83185>>>>>>>Define CALLDRV_CLEAR_INT_CACHE                      For 88
83185>>>>>>>Define CALLDRV_GET_CURRENT_USER_PASSWORD            For 89
83185>>>>>>>Define CALLDRV_FORCE_FIELDS_NULL                    For 90
83185>>>>>>>Define CALLDRV_TRANSACTIONS_ALLOWED                 For 91
83185>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE2                   For 92
83185>>>>>>>Define CALLDRV_PGSQL_NAME_SPACE                     For 93
83185>>>>>>>Define CALLDRV_EMBEDDED_SQL_TYPE                    For 94
83185>>>>>>>Define CALLDRV_CREATE_INVK_FUNCTIONS                For 95
83185>>>>>>>Define CALLDRV_DEFAULT_FILE_CASING                  For 96
83185>>>>>>>Define CALLDRV_GLOBAL_SETTING                       For 97
83185>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT                   For 98
83185>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER_CONNECTION        For 99
83185>>>>>>>Define CALLDRV_100                                  For 100
83185>>>>>>>Define CALLDRV_FILE_STRUCT_DYNAMIC_ONLINE           For 101
83185>>>>>>>Define CALLDRV_SET_FIXED_FILE_RECORDS_USED          For 102
83185>>>>>>>Define CALLDRV_GET_FIXED_FILE_RECORDS_USED          For 103
83185>>>>>>>Define CALLDRV_LOB_EX_WRITE                         For 104
83185>>>>>>>Define CALLDRV_LOB_EX_APPEND                        For 105
83185>>>>>>>Define CALLDRV_LOB_EX_READ                          For 106
83185>>>>>>>Define CALLDRV_LOB_EX_GET_LENGTH                    For 107
83185>>>>>>>Define CALLDRV_LOB_EX_SET_LENGTH                    For 108
83185>>>>>>>Define CALLDRV_LOB_EX_TEST                          For 109
83185>>>>>>>Define CALLDRV_LOB_EX_SET_NULL                      For 110
83185>>>>>>>
83185>>>>>>>// License and environment settings
83185>>>>>>>Define CALLDRV_DRIVER_REVISION                      For 0
83185>>>>>>>Define CALLDRV_COMPANY_NAME                         For 1
83185>>>>>>>Define CALLDRV_SERIAL_NUMBER                        For 2
83185>>>>>>>Define CALLDRV_LICENSED_USERS                       For 3
83185>>>>>>>Define CALLDRV_MAJOR_REVISION                       For 4
83185>>>>>>>Define CALLDRV_VERSION_COMMENTS                     For 5
83185>>>>>>>Define CALLDRV_OLEDB_OEM_TRANSLATION                For 6
83185>>>>>>>Define CALLDRV_SET_DB_PORT                          For 7
83185>>>>>>>Define CALLDRV_GET_DB_PORT                          For 8
83185>>>>>>>Define CALLDRV_SET_DB_SOCKET                        For 9
83185>>>>>>>Define CALLDRV_GET_DB_SOCKET                        For 10
83185>>>>>>>Define CALLDRV_SET_AS_SYSDBA                        For 11
83185>>>>>>>Define CALLDRV_OEM_TRANSLATION_STATE                For 12
83185>>>>>>>Define CALLDRV_TIME_TO_LIC_EXPIRATION               For 13
83185>>>>>>>Define CALLDRV_LICENSE_EXPIRATION_WARN              For 14
83185>>>>>>>Define CALLDRV_LICENSE_PATH                         For 15
83185>>>>>>>Define CALLDRV_AUTO_NUMERIC_REMAPPING               For 16
83185>>>>>>>Define CALLDRV_FORCE_DATE_FORMAT_INIT               For 17
83185>>>>>>>Define CALLDRV_STATIC_TABLE_OPT                     For 18
83185>>>>>>>Define CALLDRV_MAX_OBJECT_NAME_LENGTH               For 19
83185>>>>>>>Define CALLDRV_USE_LAZY_OPEN_MODE                   For 20
83185>>>>>>>Define CALLDRV_SET_CUSTOM_OEM_TO_ANSI               For 21
83185>>>>>>>Define CALLDRV_GET_CUSTOM_OEM_TO_ANSI               For 22
83185>>>>>>>
83185>>>>>>>//CALLDRV_ENUMERATE_SERVER_OPTION
83185>>>>>>>Define CALLDRV_ENUMERATE_SERVER_COUNT               For 0
83185>>>>>>>Define CALLDRV_ENUMERATE_SERVER_SERVER              For 1
83185>>>>>>>
83185>>>>>>>//CALLDRV_DEFAULT_FILE_CASING
83185>>>>>>>Define FILE_CASING_UPPER                            For 0
83185>>>>>>>Define FILE_CASING_LOWER                            For 1
83185>>>>>>>Define FILE_CASING_KEEP                             For 2
83185>>>>>>>
83185>>>>>>>// CALLDRV_GLOBAL_SETTING
83185>>>>>>>Define GLOBAL_SETTING_TABLESPACE_SET                For 0
83185>>>>>>>Define GLOBAL_SETTING_TABLESPACE_GET                For 1
83185>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_SET          For 2
83185>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_GET          For 3
83185>>>>>>>
83185>>>>>>>// CALLDRV_RESTRUCTURE_SCRIPT
83185>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_ENABLE            For 0
83185>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_DISABLE           For 1
83185>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_SQL     For 2
83185>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_INT     For 3
83185>>>>>>>
83185>>>>>>>// DF_SQL_RELATION_STATUS attributes
83185>>>>>>>Define FOREIGN_KEY_NONE                             For -1
83185>>>>>>>Define FOREIGN_KEY_CREATE                           For  0
83185>>>>>>>Define FOREIGN_KEY_ENABLE                           For  1
83185>>>>>>>Define FOREIGN_KEY_DISABLE                          For  2
83185>>>>>>>Define FOREIGN_KEY_DROP                             For  3
83185>>>>>>>
83185>>>>>>>// DF_SQL_RELATION_DELETE_REF_ACTION attributes
83185>>>>>>>Define DELETE_REF_NONE                              For 0
83185>>>>>>>Define DELETE_REF_CASCADE                           For 1
83185>>>>>>>Define DELETE_REF_SET_NULL                          For 2
83185>>>>>>>Define DELETE_REF_SET_DEFAULT                       For 3
83185>>>>>>>Define DELETE_REF_RESTRICT                          For 4
83185>>>>>>>
83185>>>>>>>//Embedded SQL Cursor Types
83185>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_NONE           For 0
83185>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_CLIENT         For 1
83185>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_SERVER         For 2
83185>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_PARAMETERIZED  For 3
83185>>>>>>>
83185>>>>>>>//Driver Call Direction
83185>>>>>>>Define CALLDRV_VALUE_GET                            For 0
83185>>>>>>>Define CALLDRV_VALUE_SET                            For 1
83185>>>>>>>
83185>>>>>>>//Inverse Key types
83185>>>>>>>Define REGULAR_SEG                                  For -1
83185>>>>>>>Define INVK_CASE_SEG                                For 0
83185>>>>>>>Define INVK_DESC_SEG                                For 1
83185>>>>>>>Define INVK_DESC_AND_CASE_SEG                       For 2
83185>>>>>>>
83185>>>>>>>//DB2 Index Types
83185>>>>>>>Define REG_INDEX                                    For 0
83185>>>>>>>Define REV_INDEX                                    For 1
83185>>>>>>>Define CLUST_INDEX                                  For 2
83185>>>>>>>Define REV_CLUST_INDEX                              For 3
83185>>>>>>>
83185>>>>>>>//Oracle Procedure Arguments type
83185>>>>>>>Define IS_NONE                                      For 0
83185>>>>>>>Define IS_IN                                        For 1
83185>>>>>>>Define IS_OUT                                       For 2
83185>>>>>>>Define IS_IN_OUT                                    For 3
83185>>>>>>>Define IS_RSET                                      For 4
83185>>>>>>>
83185>>>>>>>// SQL_GET_COL Attributes
83185>>>>>>>Define SQL_GET_COL_ATTRIB_SIZE                      For 1
83185>>>>>>>Define SQL_GET_COL_ATTRIB_DECIMALS                  For 2
83185>>>>>>>Define SQL_GET_COL_ATTRIB_LABEL                     For 3
83185>>>>>>>Define SQL_GET_COL_ATTRIB_COLUMN_NAME               For 4
83185>>>>>>>Define SQL_GET_COL_ATTRIB_TABLE_NAME                For 5
83185>>>>>>>Define SQL_GET_COL_ATTRIB_SQLTYPE                   For 6
83185>>>>>>>Define SQL_GET_COL_ATTRIB_NULLABLE                  For 7
83185>>>>>>>Define SQL_GET_COL_ATTRIB_DFTYPE                    For 8
83185>>>>>>>Define SQL_GET_COL_ATTRIB_DATA_LENGTH               For 9
83185>>>>>>>
83185>>>>>>>// MySQL Data Types
83185>>>>>>>Define eMySQL_DECIMAL                               For 0
83185>>>>>>>Define eMySQL_TINY                                  For 1
83185>>>>>>>Define eMySQL_SHORT                                 For 2
83185>>>>>>>Define eMySQL_LONG                                  For 3
83185>>>>>>>Define eMySQL_FLOAT                                 For 4
83185>>>>>>>Define eMySQL_DOUBLE                                For 5
83185>>>>>>>Define eMySQL_NULL                                  For 6
83185>>>>>>>Define eMySQL_TIMESTAMP                             For 7
83185>>>>>>>Define eMySQL_LONGLONG                              For 8
83185>>>>>>>Define eMySQL_INT24                                 For 9
83185>>>>>>>Define eMySQL_DATE                                  For 10
83185>>>>>>>Define eMySQL_TIME                                  For 11
83185>>>>>>>Define eMySQL_DATETIME                              For 12
83185>>>>>>>Define eMySQL_YEAR                                  For 13
83185>>>>>>>Define eMySQL_NEWDATE                               For 14
83185>>>>>>>Define eMySQL_BIT                                   For 16
83185>>>>>>>Define eMySQL_NEWDECIMAL                            For 246
83185>>>>>>>Define eMySQL_ENUM                                  For 247
83185>>>>>>>Define eMySQL_SET                                   For 248
83185>>>>>>>Define eMySQL_TINY_BLOB                             For 249
83185>>>>>>>Define eMySQL_MEDIUM_BLOB                           For 250
83185>>>>>>>Define eMySQL_LONG_BLOB                             For 251
83185>>>>>>>Define eMySQL_BLOB                                  For 252
83185>>>>>>>Define eMySQL_VAR_STRING                            For 253
83185>>>>>>>Define eMySQL_STRING                                For 254
83185>>>>>>>Define eMySQL_TINY_TEXT                             For -249
83185>>>>>>>Define eMySQL_MEDIUM_TEXT                           For -250
83185>>>>>>>Define eMySQL_LONG_TEXT                             For -251
83185>>>>>>>Define eMySQL_TEXT                                  For -252
83185>>>>>>>
83185>>>>>>>// Oracle Data Types
83185>>>>>>>Define eOracle_VARCHAR2                             For   1
83185>>>>>>>Define eOracle_NUMBER                               For   2
83185>>>>>>>Define eOracle_INT                                  For   3
83185>>>>>>>Define eOracle_FLOAT                                For   4
83185>>>>>>>Define eOracle_STRING                               For   5
83185>>>>>>>Define eOracle_LONG                                 For   8
83185>>>>>>>Define eOracle_ROWID                                For  11
83185>>>>>>>Define eOracle_DATE                                 For  12
83185>>>>>>>Define eOracle_RAW                                  For  23
83185>>>>>>>Define eOracle_LONGRAW                              For  24
83185>>>>>>>Define eOracle_CHAR                                 For  96
83185>>>>>>>Define eOracle_MSLABEL                              For 106
83185>>>>>>>Define eOracle_CLOB                                 For 112
83185>>>>>>>Define eOracle_BLOB                                 For 113
83185>>>>>>>Define eOracle_TIMESTAMP                            For 187
83185>>>>>>>Define eOracle_TIMESTAMPTZ                          For 188
83185>>>>>>>Define eOracle_INTERVALYM                           For 189
83185>>>>>>>Define eOracle_INTERVALDS                           For 190
83185>>>>>>>Define eOracle_TIMESTAMPLTZ                         For 232
83185>>>>>>>Define eOracle_NCHAR                                For 286
83185>>>>>>>Define eOracle_NVARCHAR2                            For 287
83185>>>>>>>Define eOracle_NCLOB                                For 288
83185>>>>>>>
83185>>>>>>>// PostgreSQL Data Types
83185>>>>>>>Define ePgSQL_CIRCLE                                For  718
83185>>>>>>>Define ePgSQL_MONEY                                 For  790
83185>>>>>>>Define ePgSQL_BOOL                                  For   16
83185>>>>>>>Define ePgSQL_BYTEA                                 For   17
83185>>>>>>>Define ePgSQL_CHAR                                  For   18
83185>>>>>>>Define ePgSQL_INT2                                  For   21
83185>>>>>>>Define ePgSQL_INT4                                  For   23
83185>>>>>>>Define ePgSQL_REGPROC                               For   24
83185>>>>>>>Define ePgSQL_REGPROCEDURE                          For 2202
83185>>>>>>>Define ePgSQL_REGOPER                               For 2203
83185>>>>>>>Define ePgSQL_REGOPERATOR                           For 2204
83185>>>>>>>Define ePgSQL_REGCLASS                              For 2205
83185>>>>>>>Define ePgSQL_REGTYPE                               For 2206
83185>>>>>>>Define ePgSQL_TEXT                                  For   25
83185>>>>>>>Define ePgSQL_CITEXT                                For  -25
83185>>>>>>>Define ePgSQL_OID                                   For   26
83185>>>>>>>Define ePgSQL_TID                                   For   27
83185>>>>>>>Define ePgSQL_XID                                   For   28
83185>>>>>>>Define ePgSQL_CID                                   For   29
83185>>>>>>>Define ePgSQL_XML                                   For  142
83185>>>>>>>Define ePgSQL_BPCHAR                                For 1042
83185>>>>>>>Define ePgSQL_VARCHAR                               For 1043
83185>>>>>>>Define ePgSQL_INT8                                  For   20
83185>>>>>>>Define ePgSQL_PATH                                  For  602
83185>>>>>>>Define ePgSQL_FLOAT4                                For  700
83185>>>>>>>Define ePgSQL_FLOAT8                                For  701
83185>>>>>>>Define ePgSQL_ABSTIME                               For  702
83185>>>>>>>Define ePgSQL_RELTIME                               For  703
83185>>>>>>>Define ePgSQL_TINTERVAL                             For  704
83185>>>>>>>Define ePgSQL_POINT                                 For  600
83185>>>>>>>Define ePgSQL_LINE                                  For  628
83185>>>>>>>Define ePgSQL_LSEG                                  For  601
83185>>>>>>>Define ePgSQL_BOX                                   For  603
83185>>>>>>>Define ePgSQL_POLYGON                               For  604
83185>>>>>>>Define ePgSQL_ACLITEM                               For 1033
83185>>>>>>>Define ePgSQL_MACADDR                               For  829
83185>>>>>>>Define ePgSQL_INET                                  For  869
83185>>>>>>>Define ePgSQL_CIDR                                  For  650
83185>>>>>>>Define ePgSQL_TIMESTAMP                             For 1114
83185>>>>>>>Define ePgSQL_DATE                                  For 1082
83185>>>>>>>Define ePgSQL_TIME                                  For 1083
83185>>>>>>>Define ePgSQL_TIMESTAMPTZ                           For 1184
83185>>>>>>>Define ePgSQL_INTERVAL                              For 1186
83185>>>>>>>Define ePgSQL_NUMERIC                               For 1700
83185>>>>>>>Define ePgSQL_TIMETZ                                For 1266
83185>>>>>>>Define ePgSQL_BIT                                   For 1560
83185>>>>>>>Define ePgSQL_VARBIT                                For 1562
83185>>>>>>>Define ePgSQL_UUID                                  For 2950
83185>>>>>>>
83185>>>>>>>// SQL Server Data Types
83185>>>>>>>Define eSQLServer_NA                                For    0
83185>>>>>>>Define eSQLServer_CHAR                              For    1
83185>>>>>>>Define eSQLServer_NUMERIC                           For    2
83185>>>>>>>Define eSQLServer_DECIMAL                           For    3
83185>>>>>>>Define eSQLServer_INT                               For    4
83185>>>>>>>Define eSQLServer_SMALLINT                          For    5
83185>>>>>>>Define eSQLServer_FLOAT                             For    6
83185>>>>>>>Define eSQLServer_REAL                              For    7
83185>>>>>>>Define eSQLServer_DOUBLE                            For    8
83185>>>>>>>Define eSQLServer_DATETIME                          For   11
83185>>>>>>>Define eSQLServer_VARCHAR                           For   12
83185>>>>>>>Define eSQLServer_DATE                              For   40
83185>>>>>>>Define eSQLServer_TIME                              For   41
83185>>>>>>>Define eSQLServer_DATETIME2                         For   42
83185>>>>>>>Define eSQLServer_DATETIMEOFFSET                    For   43
83185>>>>>>>Define eSQLServer_SMALLDATETIME                     For   58
83185>>>>>>>Define eSQLServer_TIMESTAMP                         For   93
83185>>>>>>>Define eSQLServer_HIERARCHYID                       For  128
83185>>>>>>>Define eSQLServer_GEOMETRY                          For  129
83185>>>>>>>Define eSQLServer_GEOGRAPHY                         For  130
83185>>>>>>>Define eSQLServer_TEXT                              For   -1
83185>>>>>>>Define eSQLServer_BINARY                            For   -2
83185>>>>>>>Define eSQLServer_VARBINARY                         For   -3
83185>>>>>>>Define eSQLServer_IMAGE                             For   -4
83185>>>>>>>Define eSQLServer_BIGINT                            For   -5
83185>>>>>>>Define eSQLServer_TINYINT                           For   -6
83185>>>>>>>Define eSQLServer_BIT                               For   -7
83185>>>>>>>Define eSQLServer_NCHAR                             For   -8
83185>>>>>>>Define eSQLServer_NVARCHAR                          For   -9
83185>>>>>>>Define eSQLServer_NTEXT                             For  -10
83185>>>>>>>Define eSQLServer_GUID                              For  -11
83185>>>>>>>Define eSQLServer_VARBINARYMAX                      For  -98
83185>>>>>>>Define eSQLServer_VARCHARMAX                        For  -99
83185>>>>>>>Define eSQLServer_NVARCHARMAX                       For -100
83185>>>>>>>Define eSQLServer_SQLVARIANT                        For -150
83185>>>>>>>Define eSQLServer_XML                               For -370
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>//Error Text
83185>>>>>>>//==========
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>//Define Self if needed
83185>>>>>>>//=====================
83185>>>>>>>
83185>>>>>>>
83185>>>>>>>//=============================================================================
83185>>>>>>>//Define varibles we need
83185>>>>>>>//=======================
83185>>>>>>>
83185>>>>>>>    Define MertechInc_Variables_Defined
83185>>>>>>>
83185>>>>>>>    Indicator MertechInc_bThereIsBinding
83185>>>>>>>
83185>>>>>>>    Integer MertechInc_FileNumber      //Replaces _SAVEFILENUMBER# and FILENUMBER
83185>>>>>>>    Integer MertechInc_iArg            //Replaces _LLONG#
83185>>>>>>>    Integer MertechInc_iCallBack       //Replaces _CALLBACK#
83185>>>>>>>    Integer MertechInc_iCount          //General loop limit integer
83185>>>>>>>    Integer MertechInc_iDecSep         //Holds the decimal seperator
83185>>>>>>>    Integer MertechInc_iFunction       //Replaces _FID#    ??? check is this is need when tidy is complete
83185>>>>>>>    Integer MertechInc_iLoop           //General loop integer
83185>>>>>>>    Integer Mertech_iMySQLParam        //Replaces _ALL_PAR_POS#
83185>>>>>>>    Integer MertechInc_iParamCount     //Replaces _NPAR#
83185>>>>>>>    Integer MertechInc_iRet            //Replaces _RET#
83185>>>>>>>    Integer MertechInc_iSaveCount      //Replaces _NPOS#
83185>>>>>>>    Integer MertechInc_iWork           //General work integer
83185>>>>>>>    Integer MertechInc_iWork2
83185>>>>>>>
83185>>>>>>>    String MertechInc_Blank            //Replaces _BLANK#
83185>>>>>>>    String MertechInc_DriverName       //Replaces _DRIVERNAME#
83185>>>>>>>    String MertechInc_sArg1 255        //Replaces _ARG1#
83185>>>>>>>    String MertechInc_sArg2 255        //Replaces _ARG2#
83185>>>>>>>    String MertechInc_sWork 255        //General work string
83185>>>>>>>
83185>>>>>>>    String MertechInc_CurrentDriver    //Keep the current driver name
83185>>>>>>>    //Global string are created pre-filled with spaces. We need an empty string
83185>>>>>>>    Move "" to MertechInc_Blank
83186>>>>>>>    Move "" to MertechInc_CurrentDriver
83187>>>>>>>
83187>>>>>>>
83187>>>>>>>//=============================================================================
83187>>>>>>>//Use Obsolete Code
83187>>>>>>>//=================
83187>>>>>>>
83187>>>>>>>
83187>>>>>>>
83187>>>>>>>//=============================================================================
83187>>>>>>>//Comment Block Template
83187>>>>>>>//======================
83187>>>>>>>
83187>>>>>>>/// @Name {Name of the command for indexing} (used for documentation)
83187>>>>>>>/// @Description {Short Command Description} (used for documentation)
83187>>>>>>>///     The description can be multiple lines, and contain HTML tags.
83187>>>>>>>///     The other tokens will have HTML encoded so we can show stuff
83187>>>>>>>///     like <param1> properly. A blank line will automatically be
83187>>>>>>>///         translated into a paragraph break in the documentation, so
83187>>>>>>>///     no need for <br> or <p> tags.
83187>>>>>>>///
83187>>>>>>>/// @Assumptions {Assumptions made in order for the command to work}
83187>>>>>>>/// @Status {Obsolete, Internal, or Public} (used for documentation)
83187>>>>>>>/// @Drivers {DB2Flex, MySQLFlex, ORAFlex, PgFlex, SQLFlex or All} (used for documentation)
83187>>>>>>>/// @VersionNote {Date and author of the last revision}
83187>>>>>>>/// @See {list of related commands}
83187>>>>>>>///
83187>>>>>>>/// @Syntax {Syntax of use} (used for documentation)
83187>>>>>>>/// @Param {Each parameter with a brief description} (used for documentation)
83187>>>>>>>/// @DBMS {List of supported databases}
83187>>>>>>>/// @DataFlex {List of supported DataFlex versions}
83187>>>>>>>/// @Usage {Different uses command can have multiple syntaxes} (used for documentation)
83187>>>>>>>///
83187>>>>>>>/// @Example {An example of the command being used} (used for documentation)
83187>>>>>>>
83187>>>>>>>//=============================================================================
83187>>>>>>>/// @Name        DO_GETFILENUMBER_DRIVERNAME
83187>>>>>>>/// @Description Retrieves the current driver name and or the file number
83187>>>>>>>/// that will be used by the macro commands.
83187>>>>>>>///
83187>>>>>>>/// @Assumptions
83187>>>>>>>/// @Status      Internal Use Only
83187>>>>>>>/// @Drivers     All
83187>>>>>>>/// @VersionNote Last Revised: 2009-07-14 By Ian Smith
83187>>>>>>>/// @See
83187>>>>>>>
83187>>>>>>>//Most commands use DO_GETFILENUMBER_DRIVERNAME so this code was being duplicated
83187>>>>>>>//all the time. It has been moved to this method to remove that duplication.
83187>>>>>>>Procedure MertechInc_Get_Driver_name Global
83189>>>>>>>    //If we have a file number get its driver, else find first loaded Mertech driver
83189>>>>>>>    If MertechInc_FileNumber GT 0 ;        Get_Attribute DF_FILE_DRIVER of MertechInc_FileNumber to MertechInc_DriverName
83194>>>>>>>    Else Begin
83195>>>>>>>        If (MertechInc_CurrentDriver > "") Move MertechInc_CurrentDriver to MertechInc_DriverName
83198>>>>>>>        Else Begin
83199>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to MertechInc_iCount
83202>>>>>>>            For MertechInc_iLoop from 1 to MertechInc_iCount
83208>>>>>>>>
83208>>>>>>>                Get_Attribute DF_DRIVER_NAME of MertechInc_iLoop to MertechInc_DriverName
83211>>>>>>>                Move (UPPERCASE(MertechInc_DriverName)) to MertechInc_DriverName
83212>>>>>>>                If (MertechInc_DriverName EQ ORAFLEX  or MertechInc_DriverName EQ SQLFLEX or MertechInc_DriverName EQ MDSDB2 or ;                    MertechInc_DriverName EQ MDSPgSQL or MertechInc_DriverName EQ MDSMySQL) Move MertechInc_iCount to MertechInc_iLoop
83215>>>>>>>                Else Move "" to MertechInc_DriverName
83217>>>>>>>            Loop
83218>>>>>>>>
83218>>>>>>>        End
83218>>>>>>>>
83218>>>>>>>    End
83218>>>>>>>>
83218>>>>>>>
83218>>>>>>>    //Ensure that we return a valid Mertech driver.
83218>>>>>>>    If (MertechInc_DriverName NE ORAFLEX  and ;        MertechInc_DriverName NE SQLFLEX  and ;        MertechInc_DriverName NE MDSDB2   and ;        MertechInc_DriverName NE MDSPgSQL and ;        MertechInc_DriverName NE MDSMySQL     ) ;        Begin
83220>>>>>>>
83220>>>>>>>        //Report invalid driver
83220>>>>>>>//        Error 25100 ("Invalid Driver - file" * String(MertechInc_FileNumber))
83220>>>>>>>//        Error 25100 ("Mertech.inc - Not a Mertech driver (file number " * String(MertechInc_FileNumber) * ")")
83220>>>>>>>        Error 25100 ("Mertech.inc - Not a Mertech driver. File" * String(MertechInc_FileNumber) * "Driver" * Trim(MertechInc_DriverName) )
83221>>>>>>>>
83221>>>>>>>
83221>>>>>>>        //Set MertechInc_FileNumber to MertechInc_Invalid_Driver so that the commands can
83221>>>>>>>        //determine if the driver is valid. MertechInc_FileNumber is use instead of
83221>>>>>>>        //MertechInc_DriverName as integer conparisons are quicker than string conparisons
83221>>>>>>>        Move MertechInc_Invalid_Driver to MertechInc_FileNumber
83222>>>>>>>    End
83222>>>>>>>>
83222>>>>>>>End_Procedure
83223>>>>>>>
83223>>>>>>>//=============================================================================
83223>>>>>>>/// @Name        MertechInc_Pre_Size_String
83223>>>>>>>/// @Description Returns a string full of spaces.
83223>>>>>>>///
83223>>>>>>>/// @Assumptions
83223>>>>>>>/// @Status      Internal
83223>>>>>>>/// @Drivers     n/a
83223>>>>>>>/// @VersionNote Last Revised: 2009-12-02 By Gandalf Hernandez
83223>>>>>>>/// @See
83223>>>>>>>Function MertechInc_Pre_Size_String Global Integer iSize Returns String
83225>>>>>>>   Local String sWork
83225>>>>>>>   Local Integer iBlocks iRemainder
83225>>>>>>>
83225>>>>>>>   If (iSize <= 1) Begin
83227>>>>>>>      // marcelo 06/28/2000 implemented logic to avoid VDF 7 crashing problems
83227>>>>>>>          If FMAC_VERSION eq 7 Move 1000 to iSize
83230>>>>>>>          Else Move 16384 to iSize
83232>>>>>>>   End
83232>>>>>>>>
83232>>>>>>>
83232>>>>>>>   // Build the string in blocks of 32, to speed things up
83232>>>>>>>   // If the string is less than 32 bytes, just fill it up regularly
83232>>>>>>>   Move (iSize / 32) to iBlocks
83233>>>>>>>   Move (Mod(iSize, 32)) to iRemainder
83234>>>>>>>
83234>>>>>>>   If (iBlocks > 0) Begin
83236>>>>>>>      Move (Repeat("                                ", iBlocks)) to sWork
83237>>>>>>>      Move (Append (sWork, (Repeat(" ", iRemainder)))) to sWork
83238>>>>>>>   End
83238>>>>>>>>
83238>>>>>>>   Else Move (Repeat(" ", iSize)) to sWork
83240>>>>>>>
83240>>>>>>>   Function_Return sWork
83241>>>>>>>End_Function
83242>>>>>>>
83242>>>>>>>//=============================================================================
83242>>>>>>>/// @Name        MertechInc_Set_DecSep
83242>>>>>>>/// @Description Saves the current decimal separator and sets the decimal
83242>>>>>>>/// separator to '.'.
83242>>>>>>>///
83242>>>>>>>/// @Assumptions
83242>>>>>>>/// @Status      Internal
83242>>>>>>>/// @Drivers     n/a
83242>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
83242>>>>>>>Procedure MertechInc_Set_DecSep Global
83244>>>>>>>    Get_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
83247>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to 46 // (.) WILL BE DECIMAL SEPARATOR
83252>>>>>>>End_Procedure
83253>>>>>>>
83253>>>>>>>//=============================================================================
83253>>>>>>>/// @Name        MertechInc_Reset_DecSep
83253>>>>>>>/// @Description Sets the decimal separator to the saved value.
83253>>>>>>>///
83253>>>>>>>/// @Status      Internal
83253>>>>>>>/// @Drivers     n/a
83253>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
83253>>>>>>>///
83253>>>>>>>Procedure MertechInc_Reset_DecSep Global
83255>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
83260>>>>>>>End_Procedure
83261>>>>>>>
83261>>>>>>>//=============================================================================
83261>>>>>>>/// @Name        FETCH_FIELD
83261>>>>>>>/// @Description Selects or de-selects the fields to be fetched during the
83261>>>>>>>/// next FIND (query).
83261>>>>>>>///
83261>>>>>>>/// @Status      Internal
83261>>>>>>>/// @Drivers     All
83261>>>>>>>/// @VersionNote Last Revised: 2009-07-16 By Ian Smith
83261>>>>>>>///
83261>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <FieldStart> THRU <FieldEnd> TO DF_FETCH_TRUE
83261>>>>>>>/// @Param  FileNum    is the File Number
83261>>>>>>>/// @Param  FieldStart is the Field Name or Number that will start the selection range
83261>>>>>>>/// @Param  FieldEnd   is the Field Name or Number that will finish the selection range
83261>>>>>>>///
83261>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <Field1> TO DF_FETCH_TRUE
83261>>>>>>>/// @Param  FileNum  is the File Number
83261>>>>>>>/// @Param  Field1 Fields Name or Number to be selected
83261>>>>>>>///
83261>>>>>>>
83261>>>>>>>//=============================================================================
83261>>>>>>>/// @Name        SQL_TEXT_MESSAGE
83261>>>>>>>/// @Description Use this command to manually insert a string into a trace
83261>>>>>>>/// file. This can be useful for readability within the trace file to log
83261>>>>>>>/// what is actually happening at certain points.
83261>>>>>>>///
83261>>>>>>>/// @Assumptions The text string is less than 80 characters long.
83261>>>>>>>/// @Status      Public
83261>>>>>>>/// @Drivers     All
83261>>>>>>>/// @VersionNote Last Revised: 20013-08-19 by Aaron Gulack
83261>>>>>>>/// @See         ENABLE_TRACE_ON DISABLE_TRACE_ON
83261>>>>>>>///
83261>>>>>>>/// @Syntax SQL_TEXT_MESSAGE {variable}
83261>>>>>>>/// @Param  {variable}          The string to insert into the trace file.
83261>>>>>>>///
83261>>>>>>>/// @Example
83261>>>>>>>/// Login "localhost" "mds" "mertech" "ora_drv"
83261>>>>>>>///
83261>>>>>>>/// ENABLE_TRACE_ON to "c:\trace.txt" DEBUG_LEVEL
83261>>>>>>>/// open Customer
83261>>>>>>>/// SQL_TEXT_MESSAGE "The table has been opened"
83261>>>>>>>
83261>>>>>>>//=============================================================================
83261>>>>>>>/// @Name       SELECT_COLUMNS_FIND
83261>>>>>>>/// @Description This command is used to fetch only a certain number of fields
83261>>>>>>>/// while doing a "find". When specifying the field number to start from and
83261>>>>>>>/// field number to end on, the find will only fetch the given fields from the
83261>>>>>>>/// record. It is important to always use this command after first deselecting
83261>>>>>>>/// all columns i.e. setting RESET_FETCH_FIELDS to DF_FETCH_FALSE. Also, after
83261>>>>>>>/// using this command, all columns need to be reselected i.e. setting
83261>>>>>>>/// RESET_FETCH_FIELDS to DF_FETCH_TRUE. Note that fields used as a part the
83261>>>>>>>/// index segment associated with the find will always be fetched regardless.
83261>>>>>>>///
83261>>>>>>>/// @Assumptions
83261>>>>>>>/// @Status      Public
83261>>>>>>>/// @Drivers     All
83261>>>>>>>/// @VersionNote Last Revised: 20014-04-30 by Marcello Yo
83261>>>>>>>/// @See         RESET_FETCH_FIELDS DISABLE_SELECT_COLUMNS_ERRORS
83261>>>>>>>///
83261>>>>>>>/// @Syntax SELECT_COLUMNS_FIND {FileNumber} {fieldStart} THRU {fieldEnd}
83261>>>>>>>/// @Param  FileNumber          The number of the file
83261>>>>>>>/// @Param  fieldStart          The field number to start the fetch from
83261>>>>>>>/// @Param  FieldEnd            The field number to end the fetch at
83261>>>>>>>///
83261>>>>>>>/// @Example
83261>>>>>>>/// Open Customer
83261>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
83261>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
83261>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
83261>>>>>>>///
83261>>>>>>>/// Clear Customer
83261>>>>>>>/// Repeat
83261>>>>>>>///    Find Gt Customer by Index.1
83261>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
83261>>>>>>>/// Until (Not(Found))
83261>>>>>>>///
83261>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
83261>>>>>>>
83261>>>>>>>
83261>>>>>>>//=============================================================================
83261>>>>>>>/// @Name        RESET_FETCH_FIELDS
83261>>>>>>>/// @Description This command is used to specify whether to retrieve all columns
83261>>>>>>>/// or no columns when performing a find. It is usually used with the command
83261>>>>>>>/// SELECT_COLUMNS_FIND to reset the column fetching. This command can either be
83261>>>>>>>/// set to DF_FETCH_TRUE, which will fetch all columns or set to DF_FETCH_FALSE,
83261>>>>>>>/// which will fetch no columns.
83261>>>>>>>/// @Assumptions
83261>>>>>>>/// @Status      Public
83261>>>>>>>/// @Drivers     All
83261>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Marcello Yo
83261>>>>>>>/// @See         SELECT_COLUMNS_FIND DISABLE_SELECT_COLUMNS_ERRORS
83261>>>>>>>///
83261>>>>>>>/// @Syntax RESET_FETCH_FIELDS {FileNumber} {DF_FETCH_TRUE/DF_FETCH_FALSE}
83261>>>>>>>/// @Param  FileNumber                  The number of the file
83261>>>>>>>/// @Param  DF_FETCH_TRUE               fetch all columns
83261>>>>>>>/// @Param  DF_FETCH_FALSE              fetch no columns
83261>>>>>>>///
83261>>>>>>>/// @Example
83261>>>>>>>/// Open Customer
83261>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
83261>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
83261>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
83261>>>>>>>///
83261>>>>>>>/// Clear Customer
83261>>>>>>>/// Repeat
83261>>>>>>>///    Find Gt Customer by Index.1
83261>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
83261>>>>>>>/// Until (Not(Found))
83261>>>>>>>///
83261>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
83261>>>>>>>
83261>>>>>>>//=============================================================================
83261>>>>>>>/// @Name        SQL_FOR_ONEROW
83261>>>>>>>/// @Description This command will instruct the driver to fetch one row
83261>>>>>>>/// per query
83261>>>>>>>///
83261>>>>>>>/// @Assumptions
83261>>>>>>>/// @Status      Deprecated
83261>>>>>>>/// @Drivers     All
83261>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
83261>>>>>>>/// @See
83261>>>>>>>///
83261>>>>>>>/// @Syntax SQL_FOR_ONEROW {FileNumber}
83261>>>>>>>/// @Param  FileNumber          The number of the file
83261>>>>>>>/// @Example
83261>>>>>>>///     open Customer
83261>>>>>>>///     SQL_FOR_ONEROW Customer.File_Number
83261>>>>>>>///     Repeat
83261>>>>>>>///             find gt Customer by Recnum
83261>>>>>>>///         If (Found) Begin
83261>>>>>>>///             showln "Sales name is " Customer.FirstName
83261>>>>>>>///         end
83261>>>>>>>///     until (Customer.ID = 10)
83261>>>>>>>
83261>>>>>>>//=============================================================================
83261>>>>>>>/// @Name        SQL_REFRESH_CACHE
83261>>>>>>>/// @Description For optimization during record retrieval, a set number of
83261>>>>>>>/// records are stored in a local cache. This command forces a refresh, by
83261>>>>>>>/// making the next find retrieve the record from the database instead of
83261>>>>>>>/// the cache.
83261>>>>>>>///
83261>>>>>>>/// @Assumptions
83261>>>>>>>/// @Status      Public
83261>>>>>>>/// @Drivers     All
83261>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
83261>>>>>>>/// @See
83261>>>>>>>///
83261>>>>>>>/// @Syntax SQL_REFRESH_CACHE OF {FileNumber}
83261>>>>>>>/// @Param  FileNumber          The number of the file
83261>>>>>>>/// @Example
83261>>>>>>>/// Open Customer
83261>>>>>>>///
83261>>>>>>>/// Find gt Customer by Index.1
83261>>>>>>>/// While (Found) Begin
83261>>>>>>>///     showln "Customer name is " CUSTOMER.CUSTOMER
83261>>>>>>>/// Loop
83261>>>>>>>///
83261>>>>>>>/// SQL_REFRESH_CACHE of CUSTOMER
83261>>>>>>>
83261>>>>>>>//=============================================================================
83261>>>>>>>/// @Name        SQL_FOR_SET
83261>>>>>>>/// @Description Use this command during LT or GT finds to only fetch a set
83261>>>>>>>/// number of rows. An option is also available for this command to disable
83261>>>>>>>/// the local cash by passing NOCACHE at the end of the command call. Note
83261>>>>>>>/// that if the rowcount is set low, too many round-trips to the server may
83261>>>>>>>/// result, effecting performance significantly. Also, if the rowcount is set
83261>>>>>>>/// too high a large number of records can be pre-fetched and end up not being
83261>>>>>>>/// used by the application. Because of this, the default of 10 rows and a cache
83261>>>>>>>/// will be adequate for most situations.
83261>>>>>>>///
83261>>>>>>>/// @Assumptions
83261>>>>>>>/// @Status      Public
83261>>>>>>>/// @Drivers     All
83261>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83261>>>>>>>/// @See
83261>>>>>>>///
83261>>>>>>>/// @Syntax SQL_FOR_SET {FileNumber} MAXROWS {variable} {CACHE/NOCACHE}
83261>>>>>>>/// @Param  FileNumber          The number of the file
83261>>>>>>>/// @Param  variable            The maximum number of rows to retrieve
83261>>>>>>>/// @Param  CACHE               fetched rows will be kept at the local cache
83261>>>>>>>/// @Param  NOCACHE             fetched rows will not be kept at the local cache
83261>>>>>>>/// @Example
83261>>>>>>>/// Open Customer
83261>>>>>>>///
83261>>>>>>>/// SQL_FOR_SET Customer MAXROWS 15 CACHE
83261>>>>>>>/// find gt Customer by Index.1
83261>>>>>>>
83261>>>>>>>//=============================================================================
83261>>>>>>>/// @Name        SQL_SET
83261>>>>>>>/// @Description Initializes and sets an initial statement for embedded
83261>>>>>>>/// sql execution.
83261>>>>>>>///
83261>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
83261>>>>>>>/// @Status      Deprecated
83261>>>>>>>/// @Drivers     All
83261>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83261>>>>>>>/// @See         SQL_SET_STMT
83261>>>>>>>///
83261>>>>>>>/// @Syntax SQL_SET {FileNumber}
83261>>>>>>>/// @Param  FileNumber          The number of the file
83261>>>>>>>
83261>>>>>>>Procedure MertechInc_SQL_SET Global String sStatement
83263>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 1 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
83268>>>>>>>End_Procedure
83269>>>>>>>
83269>>>>>>>//=============================================================================
83269>>>>>>>/// @Name        SQL_APPEND
83269>>>>>>>/// @Description Appends a string value to the current embedded sql statement
83269>>>>>>>/// already set.
83269>>>>>>>///
83269>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
83269>>>>>>>/// @Status      Deprecated
83269>>>>>>>/// @Drivers     All
83269>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83269>>>>>>>/// @See                 SQL_APPEND_STMT
83269>>>>>>>
83269>>>>>>>Procedure MertechInc_SQL_APPEND Global String sStatement
83271>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 2 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
83276>>>>>>>End_Procedure
83277>>>>>>>
83277>>>>>>>//=============================================================================
83277>>>>>>>/// @Name        SQL_EXECUTE
83277>>>>>>>/// @Description Executes the current embedded SQL statement set and commits
83277>>>>>>>/// finishing any pending transaction.
83277>>>>>>>///
83277>>>>>>>/// @Assumptions
83277>>>>>>>/// @Status      Deprecated
83277>>>>>>>/// @Drivers     All
83277>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83277>>>>>>>/// @See                 SQL_EXECUTE_STMT
83277>>>>>>>
83277>>>>>>>//=============================================================================
83277>>>>>>>/// @Name        LOCK_TABLE
83277>>>>>>>/// @Description Locks a table. This is equivalent to locking a DAT file.
83277>>>>>>>///
83277>>>>>>>/// @Assumptions
83277>>>>>>>/// @Status      Deprecated
83277>>>>>>>/// @Drivers     DB2Flex, and ORAFlex 3.x
83277>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83277>>>>>>>/// @See
83277>>>>>>>///
83277>>>>>>>/// @Syntax LOCK_TABLE {FileName} {FileName1} {FileName2} {FileName3}...
83277>>>>>>>/// @Param  FileName            The name of file to be locked. Can be more than one
83277>>>>>>>
83277>>>>>>>//=============================================================================
83277>>>>>>>/// @Name        SQL_CHECK_TABLE
83277>>>>>>>/// @Description Use this command to verify that a given table exists on the
83277>>>>>>>/// SQL backend. This command takes three arguments, a string containing the
83277>>>>>>>/// name of the database, a string containing the name of the user and finally
83277>>>>>>>/// a string containing the name of the table being checked. If the table exists,
83277>>>>>>>/// the program proceeds normally. If the table does not exist then the flag
83277>>>>>>>/// "finderr" is set to true. Note that in order to handle the error a check must
83277>>>>>>>/// be done on the "finderr" variable.
83277>>>>>>>///
83277>>>>>>>/// @Assumptions All three parameters are less than 256 characters long.
83277>>>>>>>/// @Status      Public
83277>>>>>>>/// @Drivers     All
83277>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83277>>>>>>>/// @See
83277>>>>>>>///
83277>>>>>>>/// @Syntax SQL_CHECK_TABLE {database} {username} {table}
83277>>>>>>>/// @Param  database            Name of the database
83277>>>>>>>/// @Param  username            Name of the user
83277>>>>>>>/// @Param  table                       Name of the table being checked
83277>>>>>>>///
83277>>>>>>>/// @Example
83277>>>>>>>/// SQL_CHECK_TABLE "testDB" "user" "Customer"
83277>>>>>>>/// If (finderr) Begin
83277>>>>>>>///     Showln "This table does not exist"
83277>>>>>>>/// End
83277>>>>>>>
83277>>>>>>>//=============================================================================
83277>>>>>>>/// @Name        SET_SQL_CONSTRAINT
83277>>>>>>>/// @Description This command allows you to put an additional constraint on
83277>>>>>>>/// your finds, moving filtering to the SQL backend. Using this command can
83277>>>>>>>/// result in significantly improved performance, since the server network traffic
83277>>>>>>>/// reduced. Note that the SQL statement passed for this command is added onto
83277>>>>>>>/// the predefined Database SQL statement so treat it as such. Because of this,
83277>>>>>>>/// it will almost always begin with "AND" followed by the desired constraint.
83277>>>>>>>///
83277>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
83277>>>>>>>/// @Status      Public
83277>>>>>>>/// @Drivers     All
83277>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83277>>>>>>>/// @See         SQL_CONSTRAINT GET_SQL_CONSTRAINT DF_FIELD_PROGRAMMATIC_DEFAULT
83277>>>>>>>///
83277>>>>>>>/// @Syntax SET_SQL_CONSTRAINT of {file} to {variable}
83277>>>>>>>/// @Param  file                        Name or Number of the file.
83277>>>>>>>/// @Param  variable            A SQL expression that constrains the data
83277>>>>>>>///
83277>>>>>>>/// @Example
83277>>>>>>>/// Open Customer
83277>>>>>>>///
83277>>>>>>>/// SET_SQL_CONSTRAINT of 1 to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
83277>>>>>>>///
83277>>>>>>>/// For_All Customer by Index.1 do
83277>>>>>>>///     Showln Customer.FirstName
83277>>>>>>>/// End_For_All
83277>>>>>>>
83277>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT Global Integer iFunction String sConstraint
83279>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 0 RESULT MertechInc_iRet
83284>>>>>>>End_Procedure
83285>>>>>>>
83285>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT_PROGRAMMATIC Global Integer iFunction
83287>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 4 RESULT MertechInc_iRet
83292>>>>>>>End_Procedure
83293>>>>>>>
83293>>>>>>>//=============================================================================
83293>>>>>>>/// @Name        GET_SQL_CONSTRAINT
83293>>>>>>>/// @Description This command returns the current SQL constraint for the given
83293>>>>>>>/// table.  If there is no current constraint, then a blank string is returned.
83293>>>>>>>///
83293>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
83293>>>>>>>/// @Status      Public
83293>>>>>>>/// @Drivers     All
83293>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83293>>>>>>>/// @See         SQL_CONSTRAINT SET_SQL_CONSTRAINT
83293>>>>>>>///
83293>>>>>>>/// @Syntax GET_SQL_CONSTRAINT of {File} to {variable}
83293>>>>>>>/// @Param  File                        Name or number of the file
83293>>>>>>>/// @Param  variable            The string containing the constraining SQL expression
83293>>>>>>>///
83293>>>>>>>/// @Example
83293>>>>>>>/// Open Customer
83293>>>>>>>///
83293>>>>>>>/// String sCon
83293>>>>>>>///
83293>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
83293>>>>>>>/// GET_SQL_CONSTRAINT of Customer to sCon
83293>>>>>>>///
83293>>>>>>>/// For_All Customer by Index.1 do
83293>>>>>>>///     Showln Customer.FirstName
83293>>>>>>>///     Showln sCon
83293>>>>>>>/// End_For_All
83293>>>>>>>
83293>>>>>>>Function MertechInc_GET_SQL_CONSTRAINT Global Integer iFunction Returns String
83295>>>>>>>    Local String sConstraint
83295>>>>>>>    Get MertechInc_Pre_Size_String 0 to sConstraint
83296>>>>>>>
83296>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 3 RESULT MertechInc_iRet
83301>>>>>>>    Function_Return sConstraint
83302>>>>>>>End_Function
83303>>>>>>>
83303>>>>>>>//=============================================================================
83303>>>>>>>/// @Name        SQL_CONSTRAINT
83303>>>>>>>/// @Description This command is used to toggle on or off the current SQL
83303>>>>>>>/// constraint that is set for a table. To deactivate the current constraint,
83303>>>>>>>/// pass the constant DEACTIVATE to this command. to reactivate the constraint,
83303>>>>>>>/// pass ACTIVATE to this command.
83303>>>>>>>///
83303>>>>>>>/// @Status      Public
83303>>>>>>>/// @Drivers     All
83303>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83303>>>>>>>/// @See         SET_SQL_CONSTRAINT GET_SQL_CONSTRAINT
83303>>>>>>>///
83303>>>>>>>/// @Syntax SQL_CONSTRAINT of {File} to {Activate|Deactivate}
83303>>>>>>>/// @Param  File                        Name or Number of the file
83303>>>>>>>/// @Param  Activate            Activates the constraint
83303>>>>>>>/// @Param  Deactivate          Deactivates the constraint
83303>>>>>>>///
83303>>>>>>>/// @Example
83303>>>>>>>/// Open Customer
83303>>>>>>>///
83303>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "FirstName", "Aaron"))
83303>>>>>>>/// SQL_CONSTRAINT of Customer to Deactivate
83303>>>>>>>///
83303>>>>>>>/// For_All Customer by Index.1 do
83303>>>>>>>///     Showln Customer.FirstName
83303>>>>>>>/// End_For_All
83303>>>>>>>
83303>>>>>>>//=============================================================================
83303>>>>>>>/// @Name        CREATE_TD_FILE
83303>>>>>>>/// @Description A .TD file is created when the attribute is set to True.
83303>>>>>>>///
83303>>>>>>>/// @Assumptions
83303>>>>>>>/// @Status      Deprecated
83303>>>>>>>/// @Drivers     All
83303>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
83303>>>>>>>/// @See
83303>>>>>>>///
83303>>>>>>>/// @Syntax CREATE_TD_FILE {variable}
83303>>>>>>>/// @Param  variable            True to create the .TD file, false doesn't create it.
83303>>>>>>>
83303>>>>>>>//=============================================================================
83303>>>>>>>/// @Name        OPEN_INT
83303>>>>>>>/// @Description This command is used to replace the OPEN command in DataFlex.
83303>>>>>>>/// It can be useful when accessing tables that are not in the current filelist.
83303>>>>>>>/// To access these tables, the INT and FD files must be in the directory. From
83303>>>>>>>/// there, all that is needed is to open the table using this command under an
83303>>>>>>>/// alias name. If the command is executed successfully then the table can be
83303>>>>>>>/// queried normally as if it were a standard table. Note that if the desired
83303>>>>>>>/// table is already in the filelist or doesn't have an INT file then this
83303>>>>>>>/// command will act as a normal open command.
83303>>>>>>>///
83303>>>>>>>/// @Assumptions
83303>>>>>>>/// @Status      Public
83303>>>>>>>/// @Drivers     All
83303>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
83303>>>>>>>/// @See
83303>>>>>>>///
83303>>>>>>>/// @Syntax OPEN_INT {variable} as {aliasName}
83303>>>>>>>/// @Param  variable            The name of the int file without the extension.
83303>>>>>>>/// @Param  aliasName           The alias name being used to query this table.
83303>>>>>>>/// @Example
83303>>>>>>>/// OPEN_INT "customer" as Customer
83303>>>>>>>///
83303>>>>>>>/// For_All Customer by Index.1 do
83303>>>>>>>///     Showln Customer.FirstName
83303>>>>>>>/// End_For_All
83303>>>>>>>
83303>>>>>>>//=============================================================================
83303>>>>>>>/// @Name        SET_OPEN_MODE
83303>>>>>>>/// @Description This command is used to enable an option known as "Lazy Open
83303>>>>>>>/// Mode". When turned on the table's metadata i.e. table, columns, index
83303>>>>>>>/// descriptions, is deferred until a field is accessed, even if a OPEN has
83303>>>>>>>/// already been done. This can significantly improve an application's initial
83303>>>>>>>/// performance, especially when a large number of files are opened when the
83303>>>>>>>/// program is launched. By default, tables are set to open normally, but by
83303>>>>>>>/// passing the constant LAZY_MODE to this command, it can be altered to use
83303>>>>>>>/// this mode. Note that when this mode is activated, it effects all tables
83303>>>>>>>/// that are opened. To deactivate this feature, pass the constant "DEFAULT"
83303>>>>>>>/// to this command at any time. This is the preferred method to activate or
83303>>>>>>>/// deactive this feature but it can also be set globally in the .INI file.
83303>>>>>>>///
83303>>>>>>>/// Default Value: DEFAULT (Off)
83303>>>>>>>///
83303>>>>>>>/// @Assumptions
83303>>>>>>>/// @Status      Public
83303>>>>>>>/// @Drivers     All
83303>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
83303>>>>>>>/// @See
83303>>>>>>>///
83303>>>>>>>/// @Syntax SET_OPEN_MODE to {DEFAULT/LAZY_MODE}
83303>>>>>>>/// @Param  DEFAULT                     Used to turn of the lazy mode feature.
83303>>>>>>>/// @Param  LAZY_MODE           Turns on the lazy mode feature
83303>>>>>>>///
83303>>>>>>>/// @Example
83303>>>>>>>/// SET_OPEN_MODE TO LAZY_MODE
83303>>>>>>>/// Open "customer.int" as Customer
83303>>>>>>>/// ...
83303>>>>>>>/// ...
83303>>>>>>>/// Find gt Customer by Index.1
83303>>>>>>>
83303>>>>>>>//=============================================================================
83303>>>>>>>/// @Name        SQL_SET_STMT
83303>>>>>>>/// @Description Use this command to set an SQL statement to be executed on the
83303>>>>>>>/// desired table. The string passed to this command must be a valid SQL
83303>>>>>>>/// expression and must be on a table that has already been opened. Note that
83303>>>>>>>/// when using this command, the SQL_PREPARE_STMT and SQL_EXECUTE_STMT must be
83303>>>>>>>/// used in addition to carry out the expression. The option to pass the file
83303>>>>>>>/// name as an extra parameter is used in cases where the data needs to be
83303>>>>>>>/// fetched directly into the record buffer of the specified file.
83303>>>>>>>///
83303>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
83303>>>>>>>/// @Status      Public
83303>>>>>>>/// @Drivers     All
83303>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
83303>>>>>>>/// @See                 SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
83303>>>>>>>///
83303>>>>>>>/// @Syntax SQL_SET_STMT [of {file}] to {variable}
83303>>>>>>>/// @Param file                         Name or number of the file (optional)
83303>>>>>>>/// @Param variable                     String containing the SQL statement
83303>>>>>>>///
83303>>>>>>>/// @Usage SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
83303>>>>>>>/// @Usage SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
83303>>>>>>>///
83303>>>>>>>/// @Example
83303>>>>>>>/// Open Customer
83303>>>>>>>///
83303>>>>>>>/// String sID sFirstName sLastName sDOB
83303>>>>>>>///
83303>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
83303>>>>>>>/// SQL_PREPARE_STMT
83303>>>>>>>/// SQL_EXECUTE_STMT
83303>>>>>>>/// While (Found)
83303>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
83303>>>>>>>///     Showln sID
83303>>>>>>>///     Showln sFirstName
83303>>>>>>>///     Showln sLastName
83303>>>>>>>///     Showln sDOB
83303>>>>>>>/// Loop
83303>>>>>>>/// SQL_CANCEL_QUERY_STMT
83303>>>>>>>
83303>>>>>>>Procedure MertechInc_SQL_SET_STMT Global String sStatment
83305>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatment 0 RESULT MertechInc_iRet
83310>>>>>>>End_Procedure
83311>>>>>>>
83311>>>>>>>//=============================================================================
83311>>>>>>>/// @Name        SQL_APPEND_STMT
83311>>>>>>>/// @Description This command is used to append a command string to the
83311>>>>>>>/// command buffer initialized by SQL_SET_STMT. SQL_APPEND_STMT was added
83311>>>>>>>/// so that long SQL expressions could be broken into smaller strings and
83311>>>>>>>/// appended to a dynamic command buffer, which is then passed to the server.
83311>>>>>>>/// The SQL_APPEND_STMT will concatenate a string to the command buffer
83311>>>>>>>/// initialized by the SQL_SET_STMT command. SQL_APPEND_STMT can be called as
83311>>>>>>>/// many times as necessary to complete the SQL expression. Subsequently, the
83311>>>>>>>/// SQL_EXECUTE_STMT command executes the completed command.  The option to
83311>>>>>>>/// pass the file name as an extra parameter is used in cases where the data
83311>>>>>>>/// needs to be fetched directly into the record buffer of the specified file.
83311>>>>>>>///
83311>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
83311>>>>>>>/// @Status      Public
83311>>>>>>>/// @Drivers     All
83311>>>>>>>/// @VersionNote Last Revised: 2013-08-22 by Aaron Gulack
83311>>>>>>>/// @See                 SQL_SET_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
83311>>>>>>>///
83311>>>>>>>/// @Syntax SQL_APPEND_STMT [of {file}] to {variable}
83311>>>>>>>/// @Param file                         The name or number of the file (optional)
83311>>>>>>>/// @Param variable                     The string to be appended to the current SQL expression
83311>>>>>>>///
83311>>>>>>>/// @Usage SQL_APPEND_STMT to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
83311>>>>>>>/// @Usage SQL_APPEND_STMT of Customer to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
83311>>>>>>>///
83311>>>>>>>/// @Example
83311>>>>>>>/// Open Customer
83311>>>>>>>///
83311>>>>>>>/// String sID sFirstName sLastName sDOB
83311>>>>>>>///
83311>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
83311>>>>>>>/// SQL_PREPARE_STMT
83311>>>>>>>/// SQL_EXECUTE_STMT
83311>>>>>>>/// While (Found)
83311>>>>>>>///     SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
83311>>>>>>>///     Showln sID
83311>>>>>>>///     Showln sFirstName
83311>>>>>>>///     Showln sLastName
83311>>>>>>>///     Showln sDOB
83311>>>>>>>/// Loop
83311>>>>>>>/// SQL_CANCEL_QUERY_STMT
83311>>>>>>>
83311>>>>>>>Procedure MertechInc_SQL_APPEND_STMT Global String sStatement
83313>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
83318>>>>>>>End_Procedure
83319>>>>>>>
83319>>>>>>>//=============================================================================
83319>>>>>>>/// @Name        APPEND_UPDATE_COLUMN
83319>>>>>>>/// @Description Append a given string to the existing SQL statement
83319>>>>>>>/// already set.
83319>>>>>>>///
83319>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method
83319>>>>>>>/// @Status      Internal
83319>>>>>>>/// @Drivers     All
83319>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
83319>>>>>>>/// @See
83319>>>>>>>///
83319>>>>>>>/// @Syntax APPEND_UPDCOL_STMT {variable} for {fileName}.{fieldName} {fields...}
83319>>>>>>>/// @Param variable                             SQL expression to be appended
83319>>>>>>>/// @Param fileName                             Name of the file
83319>>>>>>>/// @Param fieldName                    Name of the field
83319>>>>>>>/// @Param fields...                    Any additional fields, use the file.field format
83319>>>>>>>
83319>>>>>>>Procedure MertechInc_APPEND_UPDATE_COLUMN Global String sStatement
83321>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
83326>>>>>>>End_Procedure
83327>>>>>>>
83327>>>>>>>//=============================================================================
83327>>>>>>>/// @Name        SQL_APPEND_UPDCOL_STMT
83327>>>>>>>/// @Description Used to optimize the update process of columns being loaded
83327>>>>>>>/// with the same value.
83327>>>>>>>///
83327>>>>>>>/// @Assumptions
83327>>>>>>>/// @Status      Deprecated
83327>>>>>>>/// @Drivers     All
83327>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
83327>>>>>>>/// @See
83327>>>>>>>///
83327>>>>>>>/// @Syntax SQL_APPEND_UPDCOL_STMT [of {file}] Value {variable} for {fileName}.{fieldName} {fields...}
83327>>>>>>>/// @Param file                         The name or number of the file (optional)
83327>>>>>>>/// @Param variable                     The value being uploaded
83327>>>>>>>/// @Param fileName                     The name of the file
83327>>>>>>>/// @Param fieldName            The name of the field
83327>>>>>>>/// @Param fields...            Any additional fields, use the file.field format
83327>>>>>>>///
83327>>>>>>>/// @Example
83327>>>>>>>/// Open Customer
83327>>>>>>>///
83327>>>>>>>/// SQL_SET_STMT    of Customer to "UPDATE CUSTOMER SET"
83327>>>>>>>/// SQL_APPEND_STMT of Customer to " ASC11='x', ASC12='y', ASC13='z'"
83327>>>>>>>///
83327>>>>>>>/// SQL_APPEND_UPDCOL_STMT of Customer value 0 ;
83327>>>>>>>///     for Customer.ID Customer.Purchases Customer.Credit ;
83327>>>>>>>///
83327>>>>>>>/// SQL_APPEND_STMT of Customer to " WHERE RECNUM=1"
83327>>>>>>>///
83327>>>>>>>/// SQL_PREPARE_STMT of Customer
83327>>>>>>>/// SQL_EXECUTE_STMT of Customer
83327>>>>>>>
83327>>>>>>>//=============================================================================
83327>>>>>>>/// @Name        SQL_SET_CURSOR_TYPE
83327>>>>>>>/// @Description Specify the SQL cursor type to be used during the next
83327>>>>>>>/// embedded SQL statement execution.
83327>>>>>>>///
83327>>>>>>>/// @Assumptions
83327>>>>>>>/// @Status      Internal
83327>>>>>>>/// @Drivers     SQLFlex
83327>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
83327>>>>>>>/// @See
83327>>>>>>>///
83327>>>>>>>/// @Syntax SQL_SET_CURSOR_TYPE to {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
83327>>>>>>>/// @Param TYPE_NONE                    the default cursor type should be used
83327>>>>>>>/// @Param TYPE_CLIENT                  a client side cursor should be used
83327>>>>>>>/// @Param TYPE_SERVER                  a server side cursor should be used
83327>>>>>>>
83327>>>>>>>//=============================================================================
83327>>>>>>>/// @Name        CLEAR_INT_CACHE
83327>>>>>>>/// @Description Clears all memory-cached INT info. This is used in the
83327>>>>>>>/// test framework to force a "reload" of int info which the framework
83327>>>>>>>/// modifies for its tests. This is a different cache than the TD files
83327>>>>>>>/// which are a file based cache of the structure for use at file open.
83327>>>>>>>///
83327>>>>>>>/// @Assumptions
83327>>>>>>>/// @Status      Internal
83327>>>>>>>/// @Drivers     All
83327>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
83327>>>>>>>/// @See
83327>>>>>>>///
83327>>>>>>>/// @Syntax CLEAR_INT_CACHE
83327>>>>>>>
83327>>>>>>>//=============================================================================
83327>>>>>>>/// @Name        CREATE_INVERSE_KEY_FUNCTIONS
83327>>>>>>>/// @Description Create SQL Functions to handle Inverse Key columns.
83327>>>>>>>///
83327>>>>>>>/// @Assumptions
83327>>>>>>>/// @Status      Internal
83327>>>>>>>/// @Drivers     All (v10.1 and above)
83327>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
83327>>>>>>>/// @See
83327>>>>>>>///
83327>>>>>>>/// @Syntax CREATE_INVERSE_KEY_FUNCTIONS
83327>>>>>>>
83327>>>>>>>//=============================================================================
83327>>>>>>>/// @Name        SQL_PREPARE_STMT
83327>>>>>>>/// @Description Prepares a statement and opens a cursor to be executed by
83327>>>>>>>/// SQL_EXECUTE_STMT. This command tells the server to parse the SQL statement
83327>>>>>>>/// created by the respective SQL_SET_STMT and all subsequent SQL_APPEND_STMT
83327>>>>>>>/// statements and to allocate cursor handles to be used to fetch the data.
83327>>>>>>>/// A cursor can be thought of as a pointer to a record set. The CURSOR_TYPE
83327>>>>>>>/// argument is only supported by SQLFlex and by default SQLFLex is using a
83327>>>>>>>/// TYPE_SERVER cursor type to all embedded SQL. TYPE_CLIENT should be used only
83327>>>>>>>/// for the statements that are querying LOB columns i.e. TEXT, NVARCHAR(MAX),
83327>>>>>>>/// VARCHAR(MAX), IMAGE, VARBINARY(MAX), XML. If the cursor type is
83327>>>>>>>/// TYPE_SERVER and a LOB type column is selected, MS SQL Server will not be
83327>>>>>>>/// able to get into a transaction, either explicitly or implicitly through a
83327>>>>>>>/// REREAD, LOCK, SAVERECORD, etc.
83327>>>>>>>///
83327>>>>>>>/// @Assumptions
83327>>>>>>>/// @Status      Public
83327>>>>>>>/// @Drivers     All
83327>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
83327>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
83327>>>>>>>///
83327>>>>>>>/// @Syntax SQL_PREPARE_STMT [of {file}] CURSOR_TYPE {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
83327>>>>>>>/// @Param file                         The name or number of the file (optional)
83327>>>>>>>/// @Param CURSOR_TYPE          Used if the cursor type is being set, do not include otherwise
83327>>>>>>>/// @Param TYPE_NONE            Default cursor will be used
83327>>>>>>>/// @Param TYPE_CLIENT          A client side cursor should be used
83327>>>>>>>/// @Param TYPE_SERVER          A server side cursor should be used (Default)
83327>>>>>>>///
83327>>>>>>>/// @Usage SQL_PREPARE_STMT
83327>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer
83327>>>>>>>/// @Usage SQL_PREPARE_STMT CURSOR_TYPE TYPE_SERVER
83327>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer CURSOR_TYPE TYPE_CLIENT
83327>>>>>>>///
83327>>>>>>>/// @Example
83327>>>>>>>/// Open Customer
83327>>>>>>>///
83327>>>>>>>/// String sID sFirstName
83327>>>>>>>///
83327>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
83327>>>>>>>/// SQL_PREPARE_STMT
83327>>>>>>>/// SQL_EXECUTE_STMT
83327>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName
83327>>>>>>>
83327>>>>>>>//=============================================================================
83327>>>>>>>/// @Name        SQL_BIND_COLUMN
83327>>>>>>>/// @Description Clears all cached INT info. This should be merged with
83327>>>>>>>/// SQL_BINDCOLUMNS_STMT, but has to remain as a separate command for
83327>>>>>>>/// compatibility.
83327>>>>>>>///
83327>>>>>>>/// @Assumptions
83327>>>>>>>/// @Status      Internal
83327>>>>>>>/// @Drivers     All
83327>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
83327>>>>>>>/// @See
83327>>>>>>>///
83327>>>>>>>/// @Syntax SQL_BIND_COLUMN FileNumber FieldNumber | DF_BIND_ALL_COLUMNS
83327>>>>>>>/// @Param FileNumber                   The number of the file
83327>>>>>>>/// @Param FieldNumber                  The number of the field
83327>>>>>>>
83327>>>>>>>//=============================================================================
83327>>>>>>>/// @Name        SQL_BINDCOLUMNS_STMT
83327>>>>>>>/// @Description This command is used to fetch the returned data of a
83327>>>>>>>/// specified SQL expression into the given field in the record buffer. By
83327>>>>>>>/// passing any number of fields to this command, the fetched record will then
83327>>>>>>>/// be put into the subsequent fields in the record buffer. The order of the
83327>>>>>>>/// fields must be the same as the order of the columns being retrieved from
83327>>>>>>>/// the SQL expression. SQL_FETCH_NEXT_ROW can then be called to take the data
83327>>>>>>>/// retrieved from the server and place it into the corresponding fields in the
83327>>>>>>>/// buffer. Instead of specifying each field, DF_BIND_ALL_COLUMNS can be passed,
83327>>>>>>>/// which will retrieve every column in the table.
83327>>>>>>>///
83327>>>>>>>/// @Assumptions
83327>>>>>>>/// @Status      Public
83327>>>>>>>/// @Drivers     All
83327>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
83327>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW
83327>>>>>>>///
83327>>>>>>>/// @Syntax SQL_BINDCOLUMNS_STMT of {file} to {field/DF_BIND_ALL_COLUMNS}
83327>>>>>>>///
83327>>>>>>>/// @Param file                 Name or number of the file
83327>>>>>>>/// @Param field                        Name or number of the field (can be multiple)
83327>>>>>>>/// @Param DF_BIND_ALL_COLUMNS  Used instead of the field to retrieve all columns in the file
83327>>>>>>>///
83327>>>>>>>/// @Example
83327>>>>>>>/// Open Customer
83327>>>>>>>///
83327>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83327>>>>>>>/// SQL_PREPARE_STMT
83327>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
83327>>>>>>>/// SQL_EXECUTE_STMT of Customer
83327>>>>>>>/// While (Found)
83327>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
83327>>>>>>>///     Showln Customer.ID
83327>>>>>>>///     Showln Customer.FirstName
83327>>>>>>>///     Showln Customer.LastName
83327>>>>>>>///     Showln Customer.DOB
83327>>>>>>>/// Loop
83327>>>>>>>/// SQL_CANCEL_QUERY_STMT
83327>>>>>>>
83327>>>>>>>//=============================================================================
83327>>>>>>>/// @Name        SQL_EXECUTE_STMT
83327>>>>>>>/// @Description This command is used to execute the SQL expression created
83327>>>>>>>/// by the SQL_SET_STMT and any subsequent SQL_APPEND_STMT commands issued
83327>>>>>>>/// after a SQL_PREPARE_STMT. If the results will be sent to the record
83327>>>>>>>/// buffer directly, then the file must be specified. An optional parameter
83327>>>>>>>/// can also be passed, indicating the maximum number of rows to be sent to
83327>>>>>>>/// the local cache. This is done by adding the constant ROWCOUNT followed
83327>>>>>>>/// by the maximun number.
83327>>>>>>>///
83327>>>>>>>/// @Assumptions
83327>>>>>>>/// @Status      Public
83327>>>>>>>/// @Drivers     All
83327>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
83327>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
83327>>>>>>>///
83327>>>>>>>/// @Syntax SQL_EXECUTE_STMT [of {file} ROWCOUNT {variable}]
83327>>>>>>>/// @Param file                         Name or number of the file (optional)
83327>>>>>>>/// @Param variable                     Maximum number of rows to send to the local cache (optional)
83327>>>>>>>///
83327>>>>>>>/// @Usage SQL_EXECUTE_STMT
83327>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer
83327>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer ROWCOUNT 10
83327>>>>>>>///
83327>>>>>>>/// @Example
83327>>>>>>>/// Open Customer
83327>>>>>>>///
83327>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83327>>>>>>>/// SQL_PREPARE_STMT
83327>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
83327>>>>>>>/// SQL_EXECUTE_STMT of Customer
83327>>>>>>>/// While (Found)
83327>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
83327>>>>>>>///     Showln Customer.ID
83327>>>>>>>///     Showln Customer.FirstName
83327>>>>>>>///     Showln Customer.LastName
83327>>>>>>>///     Showln Customer.DOB
83327>>>>>>>/// Loop
83327>>>>>>>/// SQL_CANCEL_QUERY_STMT
83327>>>>>>>
83327>>>>>>>
83327>>>>>>>//This alias may be redundant. Is was only called from MertechInc_SQL_FUNCTION_EXECUTE
83327>>>>>>>//which has been recoded to directly call SQL_EXECUTE_STMT - I.S. 2009-09-19
83327>>>>>>>Procedure MertechInc_SQL_PROCEDURE_EXECUTE Global
83329>>>>>>>    SQL_EXECUTE_STMT
83344>>>>>>>End_Procedure
83345>>>>>>>
83345>>>>>>>//=============================================================================
83345>>>>>>>/// @Name        SQL_START_TRANSACTION_STMT
83345>>>>>>>/// @Description Transactions in SQL are used to maintain atomicity within
83345>>>>>>>/// an process. If one procedure in the transaction fails, then they all
83345>>>>>>>/// will fail. This command is used to start an SQL transaction. Inside of
83345>>>>>>>/// a transaction, there can be any number of SQL statements, none of which
83345>>>>>>>/// will be executed until SQL_COMMIT_STMT is called. Note that transactions
83345>>>>>>>/// are generally only needed when a table is being altered.
83345>>>>>>>///
83345>>>>>>>/// @Assumptions
83345>>>>>>>/// @Status      Public
83345>>>>>>>/// @Drivers     All
83345>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
83345>>>>>>>/// @See         SQL_COMMIT_STMT SQL_ROLLBACK_STMT
83345>>>>>>>///
83345>>>>>>>/// @Syntax SQL_START_TRANSACTION_STMT
83345>>>>>>>///
83345>>>>>>>/// @Example
83345>>>>>>>/// SQL_START_TRANSACTION_STMT
83345>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
83345>>>>>>>/// SQL_PREPARE_STMT
83345>>>>>>>/// SQL_EXECUTE_STMT
83345>>>>>>>/// SQL_COMMIT_STMT
83345>>>>>>>
83345>>>>>>>//=============================================================================
83345>>>>>>>/// @Name        SQL_COMMIT_STMT
83345>>>>>>>/// @Description Just as the SQL_EXECUTE_STMT is used to execute the SQL
83345>>>>>>>/// statement in the block, this command is used to commit the transaction
83345>>>>>>>/// started by SQL_START_TRANSACTION_STMT. When this command is called, any
83345>>>>>>>/// preceding statements or procedures that are apart of the transaction will
83345>>>>>>>/// be committed. If one or more of these statements fail, then none of them
83345>>>>>>>/// will be successful, thus maintaining atomicity.
83345>>>>>>>///
83345>>>>>>>/// @Assumptions
83345>>>>>>>/// @Status      Public
83345>>>>>>>/// @Drivers     All
83345>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
83345>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_ROLLBACK_STMT
83345>>>>>>>///
83345>>>>>>>/// @Syntax SQL_COMMIT_STMT
83345>>>>>>>///
83345>>>>>>>/// @Example
83345>>>>>>>/// SQL_START_TRANSACTION_STMT
83345>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
83345>>>>>>>/// SQL_PREPARE_STMT
83345>>>>>>>/// SQL_EXECUTE_STMT
83345>>>>>>>/// SQL_COMMIT_STMT
83345>>>>>>>
83345>>>>>>>//=============================================================================
83345>>>>>>>/// @Name        SQL_ROLLBACK_STMT
83345>>>>>>>/// @Description Rolls back an SQL transaction, any data changes inside the
83345>>>>>>>/// transaction will not be committed by the server.
83345>>>>>>>///
83345>>>>>>>/// @Assumptions
83345>>>>>>>/// @Status      Public
83345>>>>>>>/// @Drivers     All
83345>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
83345>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_COMMIT_STMT
83345>>>>>>>///
83345>>>>>>>/// @Syntax SQL_ROLLBACK_STMT
83345>>>>>>>///
83345>>>>>>>/// @Example
83345>>>>>>>/// SQL_START_TRANSACTION_STMT
83345>>>>>>>/// SQL_SET_STMT to "DELETE FROM CUSTOMER WHERE ID = 2145"
83345>>>>>>>/// SQL_PREPARE_STMT
83345>>>>>>>/// SQL_EXECUTE_STMT
83345>>>>>>>/// If (Err) Begin
83345>>>>>>>///             SQL_ERROR_MESSAGE errorString
83345>>>>>>>///     Showln errorString
83345>>>>>>>///     SQL_ROLLBACK_STMT
83345>>>>>>>/// End
83345>>>>>>>/// Else
83345>>>>>>>///     Showln "SQL Statement successful - committing"
83345>>>>>>>///     SQL_COMMIT_STMT
83345>>>>>>>
83345>>>>>>>//=============================================================================
83345>>>>>>>/// @Name        SET_TRANSACTIONS_ALLOWED
83345>>>>>>>/// @Description This command is used to toggle on or off the ability to
83345>>>>>>>/// complete transaction to the server. Passing false to this command will
83345>>>>>>>/// not allow transactions to be made, passing true will allow the transactions.
83345>>>>>>>///
83345>>>>>>>/// @Assumptions
83345>>>>>>>/// @Status      Internal
83345>>>>>>>/// @Drivers     All
83345>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
83345>>>>>>>/// @See
83345>>>>>>>///
83345>>>>>>>/// @Syntax SET_TRANSACTIONS_ALLOWED of {server} to {variable}
83345>>>>>>>/// @Param server                               The name of the server being used
83345>>>>>>>/// @Param variable                     Boolean to enable or disable transactions
83345>>>>>>>///
83345>>>>>>>/// @Example
83345>>>>>>>/// SET_TRANSACTIONS_ALLOWED of "localhost" to True
83345>>>>>>>
83345>>>>>>>//=============================================================================
83345>>>>>>>/// @Name        SQL_FETCH_NEXT_ROW
83345>>>>>>>/// @Description This command is used to fetch the next row returned by the
83345>>>>>>>/// associated SQL statement. The SQL statement is created from the
83345>>>>>>>/// SQL_SET_STMT and executed with the SQL_EXECUTE_STMT. This command can be
83345>>>>>>>/// used in two ways. If the results are to be attached to variables, then no
83345>>>>>>>/// file needs to be specified, just the variables for each column in the row.
83345>>>>>>>/// If the results are to be inserted into the record buffer directly, then the
83345>>>>>>>/// file must be specified. From there, a SQL_BINDCOLUMNS_STMT can be used to
83345>>>>>>>/// bind the fetched row to the specific fields in the file. Note that the
83345>>>>>>>/// columns are fecthed in the order that the SQL statement generates them, so
83345>>>>>>>/// the variables must follow the same order. The two constants, "found" and
83345>>>>>>>/// "finderr" are set depending on whether the next row was found.
83345>>>>>>>///
83345>>>>>>>/// @Assumptions
83345>>>>>>>/// @Status      Public
83345>>>>>>>/// @Drivers     All
83345>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
83345>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_BINDCOLUMNS_STMT
83345>>>>>>>///
83345>>>>>>>/// @Syntax SQL_FETCH_NEXT_ROW [of {file}] into {variable}
83345>>>>>>>/// @Param  file                                The name or number of the file
83345>>>>>>>/// @Param  variable                    The variable that the next column in the fetched row will be put into (can be multiple)
83345>>>>>>>///
83345>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW of Customer
83345>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW into sRecnum sID
83345>>>>>>>///
83345>>>>>>>/// @Example
83345>>>>>>>/// String sID sRecnum
83345>>>>>>>///
83345>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER ID"
83345>>>>>>>/// SQL_APPEND_STMT to " BY NAME DESC"
83345>>>>>>>/// SQL_PREPARE_STMT
83345>>>>>>>/// SQL_EXECUTE_STMT
83345>>>>>>>/// While (found)
83345>>>>>>>///     SQL_FETCH_NEXT_ROW into sRecnum sID
83345>>>>>>>///     If (found) Begin
83345>>>>>>>///             Showln sID
83345>>>>>>>///    End
83345>>>>>>>/// Loop
83345>>>>>>>/// SQL_CANCEL_QUERY_STMT
83345>>>>>>>///
83345>>>>>>>/// @Example
83345>>>>>>>/// Open Customer
83345>>>>>>>///
83345>>>>>>>/// SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
83345>>>>>>>/// SQL_PREPARE_STMT of Customer
83345>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
83345>>>>>>>/// SQL_EXECUTE_STMT of Customer
83345>>>>>>>/// While (Found)
83345>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
83345>>>>>>>///     Showln Customer.ID
83345>>>>>>>///     Showln Customer.FirstName
83345>>>>>>>///             Showln Customer.LastName
83345>>>>>>>/// Loop
83345>>>>>>>/// SQL_CANCEL_QUERY_STMT
83345>>>>>>>
83345>>>>>>>
83345>>>>>>>//=============================================================================
83345>>>>>>>/// @Name        GET_RESULT_SET
83345>>>>>>>/// @Description Fetches the next row in the result set returned by a
83345>>>>>>>/// query or stored procedure.
83345>>>>>>>///
83345>>>>>>>/// @Assumptions
83345>>>>>>>/// @Status      Deprecated
83345>>>>>>>/// @Drivers     All
83345>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
83345>>>>>>>/// @See
83345>>>>>>>///
83345>>>>>>>/// @Syntax GET_RESULT_SET into {variable}
83345>>>>>>>/// @Param variable                     The variable receiving the result (can be multiple)
83345>>>>>>>
83345>>>>>>>//=============================================================================
83345>>>>>>>/// @Name        SQL_GET_DATA_CHUNK
83345>>>>>>>/// @Description This command is used to get a chunk of data from a column
83345>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
83345>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
83345>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
83345>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
83345>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
83345>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
83345>>>>>>>///
83345>>>>>>>/// @Assumptions
83345>>>>>>>/// @Status      Public
83345>>>>>>>/// @Drivers     SQLFlex
83345>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83345>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
83345>>>>>>>///
83345>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
83345>>>>>>>/// @Param column                               Column number to get chunk from
83345>>>>>>>/// @Param offset                       Offset to start at for the chunk
83345>>>>>>>/// @Param variable                     Variable to hold the returned chunk
83345>>>>>>>/// @Param length                       Variable to hold the chunk length
83345>>>>>>>///
83345>>>>>>>/// @Example
83345>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83345>>>>>>>/// SQL_PREPARE_STMT
83345>>>>>>>/// SQL_EXECUTE_STMT
83345>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
83345>>>>>>>/// If (Found) Begin
83345>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
83345>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
83345>>>>>>>///     Showln sChunk
83345>>>>>>>///     Showln iLength
83345>>>>>>>/// End
83345>>>>>>>
83345>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK Global Integer iColumn Integer iOffset Returns String
83347>>>>>>>    Local Integer iChuck_Size
83347>>>>>>>    Local String sChunk
83347>>>>>>>
83347>>>>>>>    //Get current Chuck size and pre size string
83347>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
83352>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
83353>>>>>>>
83353>>>>>>>    //Get data
83353>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK CALLBACK 0 PASSING iColumn sChunk iOffset RESULT MertechInc_iRet
83358>>>>>>>
83358>>>>>>>    //sArg1 (iColumn) contains the number of bytes returned, so move it to
83358>>>>>>>    //MertechInc_Arg1 to pass the value back
83358>>>>>>>    Move iColumn to MertechInc_sArg1
83359>>>>>>>
83359>>>>>>>    Function_Return sChunk
83360>>>>>>>End_Function
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        SQL_SET_CHUNK_SIZE
83361>>>>>>>/// @Description This command sets the size of the chunk to retrieve when
83361>>>>>>>/// using SQL_GET_DATA_CHUNK. Whatever number is set here will be the
83361>>>>>>>/// length of the chunk that is retrieved, as long as it does not exceed
83361>>>>>>>/// the maximum chunk size.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Public
83361>>>>>>>/// @Drivers     SQLFlex
83361>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_GET_DATA_CHUNK SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
83361>>>>>>>///
83361>>>>>>>/// @Syntax SQL_SET_CHUNK_SIZE to {variable}
83361>>>>>>>/// @Param variable                     Length of chunk to retrive
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83361>>>>>>>/// SQL_PREPARE_STMT
83361>>>>>>>/// SQL_EXECUTE_STMT
83361>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
83361>>>>>>>/// If (Found) Begin
83361>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
83361>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
83361>>>>>>>///     Showln sChunk
83361>>>>>>>///     Showln iLength
83361>>>>>>>/// End
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        SQL_GET_CHUNK_SIZE
83361>>>>>>>/// @Description This command gets the size of the chunk being retrieved
83361>>>>>>>/// from SQL_GET_DATA_CHUNK and puts it into the specified variable.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Public
83361>>>>>>>/// @Drivers     SQLFlex
83361>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
83361>>>>>>>///
83361>>>>>>>/// @Syntax SQL_GET_CHUNK_SIZE to {variable}
83361>>>>>>>/// @Param variable             Variable to hold the chunk size
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// SQL_GET_CHUNK_SIZE to iLength
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        SQL_SET_MAX_DATA_SIZE
83361>>>>>>>/// @Description This command sets the maximum size for data chunks
83361>>>>>>>/// retrieved through SQL_GET_DATA_CHUNK. If SQL_SET_CHUNK_SIZE is higher
83361>>>>>>>/// than the maximum size set with this command, then this will override
83361>>>>>>>/// it and the chunk will be no longer than the maximum size set here.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Public
83361>>>>>>>/// @Drivers     SQLFlex
83361>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_GET_MAX_DATA_SIZE
83361>>>>>>>///
83361>>>>>>>/// @Syntax SQL_SET_MAX_DATA_SIZE to {variable}
83361>>>>>>>/// @Param variable                     Max length to allow for chunks
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// SQL_SET_MAX_DATA_SIZE to 1000
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        SQL_GET_MAX_DATA_SIZE
83361>>>>>>>/// @Description This command returns the maximum chunk size allowed
83361>>>>>>>/// for SQL_GET_DATA_CHUNK.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Public
83361>>>>>>>/// @Drivers     SQLFlex
83361>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE
83361>>>>>>>///
83361>>>>>>>/// @Syntax SQL_GET_MAX_DATA_SIZE to {variable}
83361>>>>>>>/// @Param variable             Variable to hold the maximum chunk size
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// SQL_GET_MAX_DATA_SIZE to iLength
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        SQL_GET_NUM_COLS
83361>>>>>>>/// @Description This command is used to get the number of columns retrieved
83361>>>>>>>/// from an SQL expression result set. Since the column number is based on
83361>>>>>>>/// the result set, this command cannot be used when the results are being
83361>>>>>>>/// bound to the record buffer.  If this command is used with the record
83361>>>>>>>/// buffer or if no columns are found, -1 is returned.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Public
83361>>>>>>>/// @Drivers     All
83361>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_SET_STMT
83361>>>>>>>///
83361>>>>>>>/// @Syntax SQL_GET_NUM_COLS to {variable}
83361>>>>>>>/// @Param variable                     Variable to hold the number of columns.
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
83361>>>>>>>/// SQL_PREPARE_STMT
83361>>>>>>>/// SQL_EXECUTE_STMT
83361>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
83361>>>>>>>/// Showln iNumCols
83361>>>>>>>
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        GET_RESULT_SET_NUM_COLS
83361>>>>>>>/// @Description Returns the number of columns in the result set.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Deprecated
83361>>>>>>>/// @Drivers     All
83361>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_GET_NUM_COLS
83361>>>>>>>///
83361>>>>>>>/// @Syntax GET_RESULT_SET_NUM_COLS to {variable}
83361>>>>>>>/// @Param variable                     Variable to hold the number of columns
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// Integer iNumCols
83361>>>>>>>///
83361>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
83361>>>>>>>/// SQL_PREPARE_STMT
83361>>>>>>>/// SQL_EXECUTE_STMT
83361>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
83361>>>>>>>/// Showln iNumCols
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        SQL_GET_NUM_ROWS
83361>>>>>>>/// @Description This command is used to get the number of rows retrieved
83361>>>>>>>/// from a result set of an SQL expression. It cannot be used when binding
83361>>>>>>>/// the result set to the record buffer.
83361>>>>>>>///
83361>>>>>>>/// Note: The number of rows may not always be available, depending
83361>>>>>>>/// on server and cursor types.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Public
83361>>>>>>>/// @Drivers     All
83361>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT
83361>>>>>>>///
83361>>>>>>>/// @Syntax SQL_GET_NUM_ROWS to {variable}
83361>>>>>>>/// @Param variable                     Variable to hold the number of rows
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// Integer iNumRows
83361>>>>>>>///
83361>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
83361>>>>>>>/// SQL_PREPARE_STMT
83361>>>>>>>/// SQL_EXECUTE_STMT
83361>>>>>>>/// SQL_GET_NUM_ROWS to iNumRows
83361>>>>>>>/// Showln iNumRows
83361>>>>>>>
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        SQL_GET_COL_NAME
83361>>>>>>>/// @Description This command is used to retrieve the name of a specified
83361>>>>>>>/// column within an SQL result set. An optional second variable can be used
83361>>>>>>>/// to retrieve the size of the specified column. Note that this command
83361>>>>>>>/// cannot be used when the results are being directly binded to the record
83361>>>>>>>/// buffer, it can only be used for the results of an SQL statement.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Public
83361>>>>>>>/// @Drivers     All
83361>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_GET_NUM_COLS
83361>>>>>>>///
83361>>>>>>>/// @Syntax SQL_GET_COL_NAME {columnNumber} to {variable} [{length}]
83361>>>>>>>/// @Param columnNumber                 The column number being used
83361>>>>>>>/// @Param variable                             String variable for the column name
83361>>>>>>>/// @Param length                       Variable to hold the column length (optional)
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// Open Customer
83361>>>>>>>///
83361>>>>>>>/// String sColumnName
83361>>>>>>>/// Integer iLength
83361>>>>>>>///
83361>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
83361>>>>>>>/// SQL_PREPARE_STMT
83361>>>>>>>/// SQL_EXECUTE_STMT
83361>>>>>>>/// SQL_GET_COL_NAME 1 to sColumnName iLength
83361>>>>>>>/// showln sColumnName
83361>>>>>>>/// showln iLength
83361>>>>>>>
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        GET_RESULT_SET_COL_NAME
83361>>>>>>>/// @Description Returns the column name being populated from the result set.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Deprecated
83361>>>>>>>/// @Drivers     All
83361>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
83361>>>>>>>/// @See                 SQL_GET_COL_NAME
83361>>>>>>>///
83361>>>>>>>/// @Syntax GET_RESULT_SET_COL_NAME {columnNumber} to {variable} [{length}]
83361>>>>>>>/// @Param columnNumber                 The column number being used
83361>>>>>>>/// @Param variable                             String variable for the column name
83361>>>>>>>/// @Param length                       Variable receiving the column length (optional)
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        SQL_GET_COL_ATTRIBUTE
83361>>>>>>>/// @Description This command is used to get specific column information from
83361>>>>>>>/// the columns in a result set of an SQL statement. By passing one of the
83361>>>>>>>/// supported attributes below, the command will return the desired information.
83361>>>>>>>/// Note that some attributes only work with specific drivers. See the list
83361>>>>>>>/// below for more information.
83361>>>>>>>///
83361>>>>>>>/// Supported attributes are:
83361>>>>>>>/// <dl>
83361>>>>>>>/// <dt>SIZE        </dt><dd>The maximum length of the column</dd>
83361>>>>>>>/// <dt>DATA_LENGTH </dt><dd>Length of data currently in the column</dd>
83361>>>>>>>/// <dt>DECIMALS    </dt><dd>If numeric, shows number of decimal places</dd>
83361>>>>>>>/// <dt>LABEL       </dt><dd>Returns the column name in ORAFlex and MySQLFlex</dd>
83361>>>>>>>/// <dt>COLUMN_NAME </dt><dd>Returns the name of the column</dd>
83361>>>>>>>/// <dt>TABLE_NAME  </dt><dd>Returns the name of the table (MySQLFlex only)</dd>
83361>>>>>>>/// <dt>SQLTYPE     </dt><dd>Returns the number representing the SQL data type</dd>
83361>>>>>>>/// <dt>NULLABLE    </dt><dd>Returns true if null is allowed, false otherwise (doesn't work in PostgreSQL)</dd>
83361>>>>>>>/// <dt>DFTYPE      </dt><dd>Dataflex type column is mapped to</dd>
83361>>>>>>>/// </dl>
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Public
83361>>>>>>>/// @Drivers     All
83361>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83361>>>>>>>/// @See
83361>>>>>>>///
83361>>>>>>>/// @Syntax SQL_GET_COL_ATTRIBUTE of {columnNumber} {attribute} to {variable}
83361>>>>>>>/// @Param columnNumber                 The number of the column that is being examined
83361>>>>>>>/// @Param attribute                    The attribute being checked (see list)
83361>>>>>>>/// @Param variable                             Variable to hold the attribute value
83361>>>>>>>///
83361>>>>>>>/// @Example
83361>>>>>>>/// String sFirstName sLastName sColumn1Name sColumn2Name
83361>>>>>>>///
83361>>>>>>>/// Open Customer
83361>>>>>>>///
83361>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83361>>>>>>>/// SQL_PREPARE_STMT
83361>>>>>>>/// SQL_EXECUTE_STMT
83361>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
83361>>>>>>>/// If (Found) Begin
83361>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 1 COLUMN_NAME to sColumn1Name
83361>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 2 COLUMN_NAME to sColumn2Name
83361>>>>>>>///     Showln (sColumn1Name + " = " + sFirstName)
83361>>>>>>>///     Showln (sColumn2Name + " = " + sLastName)
83361>>>>>>>/// End
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        DDO_GET_BIND_RSPARAMETERS
83361>>>>>>>/// @Description Recursively calls DO_GET_BIND_RSPARAMETERS.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Internal
83361>>>>>>>/// @Drivers     All
83361>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
83361>>>>>>>/// @See
83361>>>>>>>
83361>>>>>>>//=============================================================================
83361>>>>>>>/// @Name        DO_GET_BIND_RSPARAMETERS
83361>>>>>>>/// @Description Gets bound parameters values for result set call.
83361>>>>>>>///
83361>>>>>>>/// @Assumptions
83361>>>>>>>/// @Status      Internal
83361>>>>>>>/// @Drivers     All
83361>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
83361>>>>>>>/// @See
83361>>>>>>>
83361>>>>>>>Function MertechInc_DO_GET_BIND_RSPARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
83363>>>>>>>    Local String sReturnValue
83363>>>>>>>    Local Integer iSize
83363>>>>>>>
83363>>>>>>>    move 0 to iSize
83364>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
83381>>>>>>>>
83381>>>>>>>
83381>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
83382>>>>>>>    Move (|CI$10000 * iArg) To iArg // Shift column number 16 bits to the left
83383>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
83388>>>>>>>
83388>>>>>>>    Function_Return sReturnValue
83389>>>>>>>End_Function
83390>>>>>>>
83390>>>>>>>
83390>>>>>>>//=============================================================================
83390>>>>>>>/// @Name        SQL_NEXT_RESULT_SET
83390>>>>>>>/// @Description This command is used when working with SQL statements that
83390>>>>>>>/// return multiple result sets. In that scenario, calling this command will
83390>>>>>>>/// move to the next result set. That set can now be fetched or binded to
83390>>>>>>>/// columns on a table.
83390>>>>>>>///
83390>>>>>>>/// @See
83390>>>>>>>/// @Status      Public
83390>>>>>>>/// @Drivers     All
83390>>>>>>>/// @VersionNote Last Revised: 2013-09-02 by Aaron Gulack
83390>>>>>>>/// @See
83390>>>>>>>///
83390>>>>>>>/// @Syntax SQL_NEXT_RESULT_SET [of {file}]
83390>>>>>>>/// @Param file                 Name or number of the file (optional)
83390>>>>>>>///
83390>>>>>>>/// @Example
83390>>>>>>>/// SQL_SET_STMT to "SP_HELP CUSTOMER"
83390>>>>>>>/// SQL_PREPARE_STMT
83390>>>>>>>/// SQL_EXECUTE_STMT
83390>>>>>>>/// SQL_FETCH_NEXT_ROW into sTable sOwner sTableType dtCreated
83390>>>>>>>/// If (Found) Begin
83390>>>>>>>///     Showln sTable
83390>>>>>>>///     Showln sOwner
83390>>>>>>>///     Showln sTableType
83390>>>>>>>///     Showln dtCreated
83390>>>>>>>/// End
83390>>>>>>>/// SQL_NEXT_RESULT_SET
83390>>>>>>>/// SQL_FETCH_NEXT_ROW into sColumnName sColumnType sComputed sLength
83390>>>>>>>/// If (Found) Begin
83390>>>>>>>///     Showln sColumnName
83390>>>>>>>///     Showln sColumnType
83390>>>>>>>///     Showln sComputed
83390>>>>>>>///     Showln sLength
83390>>>>>>>/// End
83390>>>>>>>
83390>>>>>>>//=============================================================================
83390>>>>>>>/// @Name        DDO_PASS_ARGUMENTS
83390>>>>>>>/// @Description Calls DO_PASS_ARGUMENTS until the argument is "BINDING" and
83390>>>>>>>/// then stops.
83390>>>>>>>///
83390>>>>>>>/// @Assumptions
83390>>>>>>>/// @Status      Internal
83390>>>>>>>/// @Drivers     All
83390>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83390>>>>>>>/// @See
83390>>>>>>>
83390>>>>>>>//=============================================================================
83390>>>>>>>/// @Name        DO_PASS_ARGUMENTS
83390>>>>>>>/// @Description Builds parameter statements for stored procedures and adds
83390>>>>>>>/// them to the current query.
83390>>>>>>>///
83390>>>>>>>/// @Assumptions
83390>>>>>>>/// @Status      internal
83390>>>>>>>/// @Drivers     All
83390>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83390>>>>>>>/// @See
83390>>>>>>>
83390>>>>>>>//=============================================================================
83390>>>>>>>/// @Name        DDO_BIND_PARAMETERS
83390>>>>>>>/// @Description Recursively calls DO_BIND_PARAMETERS until the keyword
83390>>>>>>>/// "BINDING" is encountered.
83390>>>>>>>///
83390>>>>>>>/// @Assumptions
83390>>>>>>>/// @Status      Internal
83390>>>>>>>/// @Drivers     All
83390>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83390>>>>>>>/// @See
83390>>>>>>>
83390>>>>>>>//=============================================================================
83390>>>>>>>/// @Name        DO_BIND_PARAMETERS
83390>>>>>>>/// @Description Binds parameters for a stored procedure call.
83390>>>>>>>///
83390>>>>>>>/// @Assumptions
83390>>>>>>>/// @Status      Internal
83390>>>>>>>/// @Drivers     All
83390>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83390>>>>>>>/// @See
83390>>>>>>>
83390>>>>>>>Procedure MertechInc_DO_BIND_PARAMETERS Global String sValue String sName Integer iLength
83392>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sValue sName iLength RESULT MertechInc_iRet
83397>>>>>>>End_Procedure
83398>>>>>>>
83398>>>>>>>//=============================================================================
83398>>>>>>>/// @Name        DO_BIND_PAR_RET
83398>>>>>>>/// @Description Binds parameters for a stored procedure call.
83398>>>>>>>///
83398>>>>>>>/// @Assumptions
83398>>>>>>>/// @Status      Internal
83398>>>>>>>/// @Drivers     OraFlex
83398>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83398>>>>>>>/// @See
83398>>>>>>>
83398>>>>>>>//=============================================================================
83398>>>>>>>/// @Name        DDO_GET_BIND_PARAMETERS
83398>>>>>>>/// @Description Recursively calls DO_GET_BIND_PARAMETERS.
83398>>>>>>>///
83398>>>>>>>/// @Assumptions
83398>>>>>>>/// @Status      Internal
83398>>>>>>>/// @Drivers     All
83398>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83398>>>>>>>/// @See
83398>>>>>>>
83398>>>>>>>//=============================================================================
83398>>>>>>>/// @Name        DO_GET_BIND_PARAMETERS
83398>>>>>>>/// @Description Gets bound parameter values for a stored procedure call.
83398>>>>>>>///
83398>>>>>>>/// @Assumptions
83398>>>>>>>/// @Status      Internal
83398>>>>>>>/// @Drivers     All
83398>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83398>>>>>>>/// @See
83398>>>>>>>
83398>>>>>>>Function MertechInc_DO_GET_BIND_PARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
83400>>>>>>>    Local String sReturnValue
83400>>>>>>>    Local Integer iSize
83400>>>>>>>
83400>>>>>>>    if (MertechInc_DriverName = SQLFLEX) ;                move (iArg+1) to iArg
83403>>>>>>>//        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
83403>>>>>>>
83403>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
83404>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
83409>>>>>>>
83409>>>>>>>    Function_Return sReturnValue
83410>>>>>>>End_Function
83411>>>>>>>
83411>>>>>>>//=============================================================================
83411>>>>>>>/// @Name        SQL_GET_OUTPUT_VALUE
83411>>>>>>>/// @Description This command is used to get the value of a specific
83411>>>>>>>/// parameter associated with a stored procedure.  Although this
83411>>>>>>>/// command will work with any parameter, it is mostly used with
83411>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
83411>>>>>>>/// once returned. When multiple values are returned, this command can be
83411>>>>>>>/// more efficient than other options. Note that the specified parameter
83411>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
83411>>>>>>>/// in order to work properly.
83411>>>>>>>///
83411>>>>>>>/// @Assumptions
83411>>>>>>>/// @Status      Deprecated
83411>>>>>>>/// @Drivers     All
83411>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83411>>>>>>>/// @See                 SQL_GET_PROCEDURE_PARAMETER
83411>>>>>>>///
83411>>>>>>>/// @Syntax SQL_GET_OUTPUT_VALUE {parameter} to {variable}
83411>>>>>>>/// @Param parameter            Number of the parameter
83411>>>>>>>/// @Param variable                     Variable to hold the parameter's value
83411>>>>>>>///
83411>>>>>>>/// @Example
83411>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
83411>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
83411>>>>>>>/// SQL_PROCEDURE_EXECUTE
83411>>>>>>>/// SQL_GET_OUTPUT_VALUE 1 to sStatus
83411>>>>>>>///
83411>>>>>>>/// Showln sStatus
83411>>>>>>>///
83411>>>>>>>/// @Example
83411>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
83411>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
83411>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
83411>>>>>>>/// SQL_PROCEDURE_EXECUTE
83411>>>>>>>/// SQL_GET_OUTPUT_VALUE 2 to sStatus
83411>>>>>>>///
83411>>>>>>>/// Showln sStatus
83411>>>>>>>// OLI:
83411>>>>>>>// This function is identical in operation to SQL_GET_PROCEDURE_PARAMETER, so just do a replace
83411>>>>>>>
83411>>>>>>>//=============================================================================
83411>>>>>>>/// @Name        SQL_FETCH_COLUMN
83411>>>>>>>/// @Description This command is used to retrieve a specified column from a
83411>>>>>>>/// result set of an SQL statement. Note that this command cannot be used to
83411>>>>>>>/// replace SQL_FETCH_NEXT_ROW but is used in addition to it when only one
83411>>>>>>>/// column is needed. For most cases, SQL_FETCH_NEXT_ROW can be used alone
83411>>>>>>>/// to retrieve the columns desired so this should only be used if there is
83411>>>>>>>/// a specific reason to do so.
83411>>>>>>>///
83411>>>>>>>/// @Assumptions
83411>>>>>>>/// @Status      Public
83411>>>>>>>/// @Drivers     All
83411>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
83411>>>>>>>/// @See                 SQL_FETCH_NEXT_ROW
83411>>>>>>>///
83411>>>>>>>/// @Syntax SQL_FETCH_COLUMN {columnNumber} into {variable}
83411>>>>>>>/// @Param columnNumber    Number of the column to fetch
83411>>>>>>>/// @Param variable        Variable to hold the fetched value
83411>>>>>>>///
83411>>>>>>>/// @Example
83411>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83411>>>>>>>/// SQL_PREPARE_STMT
83411>>>>>>>/// SQL_EXECUTE_STMT
83411>>>>>>>/// SQL_FETCH_NEXT_ROW
83411>>>>>>>/// SQL_GET_NUM_COLS to iCols
83411>>>>>>>/// For fieldIndex from 1 to iCols
83411>>>>>>>///     SQL_FETCH_COLUMN fieldIndex into sValue
83411>>>>>>>///     Showln sValue
83411>>>>>>>/// Loop
83411>>>>>>>
83411>>>>>>>Function MertechInc_SQL_FETCH_COLUMN Global String sArg1 String sArg2 Integer iArg Returns String
83413>>>>>>>    Local String sReturnValue
83413>>>>>>>    Local Integer iSize
83413>>>>>>>
83413>>>>>>>    Move 0 to iSize
83414>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
83431>>>>>>>>
83431>>>>>>>
83431>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
83432>>>>>>>    Move (|CI$10000 * iArg) to iArg // Shift column number 16 bits to the left
83433>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
83438>>>>>>>
83438>>>>>>>    Function_Return sReturnValue
83439>>>>>>>End_Function
83440>>>>>>>
83440>>>>>>>//=============================================================================
83440>>>>>>>/// @Name        SET_SCHEMA_NAME
83440>>>>>>>/// @Description This command is used to set the schema name to be used when
83440>>>>>>>/// opening tables. Note that this command will override the schema name that
83440>>>>>>>/// is set in the INT file.  The default schema for the current user is used
83440>>>>>>>/// when no name is set.
83440>>>>>>>///
83440>>>>>>>/// @Assumptions
83440>>>>>>>/// @Status      Public
83440>>>>>>>/// @Drivers     SQLFlex and ORAFlex
83440>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
83440>>>>>>>/// @See                 GET_SCHEMA_NAME
83440>>>>>>>///
83440>>>>>>>/// @Syntax SET_SCHEMA_NAME to {schema}
83440>>>>>>>/// @Param variable                     Name of the schema
83440>>>>>>>///
83440>>>>>>>/// @Example
83440>>>>>>>/// SET_SCHEMA_NAME to 'CustomerSchema'
83440>>>>>>>/// OPEN "CUSTOMER.INT" as CUSTOMER
83440>>>>>>>/// SET_SCHEMA_NAME to 'SalesSchema'
83440>>>>>>>/// OPEN "SALESP.INT" as SALESP
83440>>>>>>>
83440>>>>>>>//=============================================================================
83440>>>>>>>/// @Name        GET_SCHEMA_NAME
83440>>>>>>>/// @Description This command is used to get the name of the schema being
83440>>>>>>>/// used to open tables.
83440>>>>>>>///
83440>>>>>>>/// @Assumptions
83440>>>>>>>/// @Status      Public
83440>>>>>>>/// @Drivers     SQLFlex and ORAFlex
83440>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
83440>>>>>>>/// @See                 SET_SCHEMA_NAME
83440>>>>>>>///
83440>>>>>>>/// @Syntax GET_SCHEMA_NAME to {variable}
83440>>>>>>>/// @Param variable                     variable to hold the schema name
83440>>>>>>>///
83440>>>>>>>/// @Example
83440>>>>>>>/// GET_SCHEMA_NAME to sName
83440>>>>>>>/// Showln sName
83440>>>>>>>
83440>>>>>>>//=============================================================================
83440>>>>>>>/// @Name        CALL_ORACLE_STORED_PROCEDURE
83440>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
83440>>>>>>>/// backend. To successfully call a procedure with this command, a string
83440>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
83440>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
83440>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
83440>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
83440>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
83440>>>>>>>/// is set to true.
83440>>>>>>>///
83440>>>>>>>/// @Assumptions
83440>>>>>>>/// @Status      Deprecated
83440>>>>>>>/// @Drivers     ORAFLex
83440>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
83440>>>>>>>/// @See                 CALL_STORED_PROCEDURE
83440>>>>>>>///
83440>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
83440>>>>>>>/// @Param procedure            Full name of the procedure
83440>>>>>>>/// @Param variable                     Argument being passed to procedure (can be multiple)
83440>>>>>>>///
83440>>>>>>>/// @Example
83440>>>>>>>/// CALL_ORACLE_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
83440>>>>>>>
83440>>>>>>>//=============================================================================
83440>>>>>>>/// @Name        SQL_SET_PROCEDURE_NAME
83440>>>>>>>/// @Description This command is used to set the procedure to be executed.
83440>>>>>>>/// This is used when the procedure is being split up into multiple lines
83440>>>>>>>/// as shown below. When using this command, SQL_PROCEDURE_EXECUTE must be
83440>>>>>>>/// called after all parameters have been set to successfully execute the
83440>>>>>>>/// procedure. The constant "NUMPAR" is used to indicate how many parameters
83440>>>>>>>/// will be passed.
83440>>>>>>>///
83440>>>>>>>/// @Assumptions The procedure is a valid procedure in the SQL database
83440>>>>>>>/// @Status      Public
83440>>>>>>>/// @Drivers     All
83440>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
83440>>>>>>>/// @See                 SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
83440>>>>>>>///
83440>>>>>>>/// @Syntax SQL_SET_PROCEDURE_NAME {procedure} NUMPAR {variable}
83440>>>>>>>/// @Param procedure            Full name of the procedure
83440>>>>>>>/// @Param variable                     Number of parameters to be passed
83440>>>>>>>///
83440>>>>>>>/// @Example
83440>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
83440>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
83440>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
83440>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
83440>>>>>>>/// SQL_PROCEDURE_EXECUTE
83440>>>>>>>
83440>>>>>>>
83440>>>>>>>Procedure MertechInc_SQL_SET_ORAPROCEDURE_NAME Global String strProcName Integer iNumpar
83442>>>>>>>    Local Integer iParam
83442>>>>>>>
83442>>>>>>>    Move 0 to MertechInc_iParamCount       //Redundant, but left in incase called
83443>>>>>>>    INDICATE ERR False              //directly and not via SQL_SET_PROCEDURE_NAME
83444>>>>>>>    Move ORAFlex to MertechInc_DriverName  //
83445>>>>>>>
83445>>>>>>>    SQL_SET_STMT to "BEGIN "
83453>>>>>>>    SQL_APPEND_STMT to strProcName
83461>>>>>>>    SQL_APPEND_STMT to "( "
83469>>>>>>>    For iParam from 1 to iNumpar
83475>>>>>>>>
83475>>>>>>>        DO_PASS_ARGUMENTS iParam
83507>>>>>>>    Loop
83508>>>>>>>>
83508>>>>>>>    SQL_APPEND_STMT to  " ); END;"
83516>>>>>>>    SQL_PREPARE_STMT
83528>>>>>>> End_Procedure
83529>>>>>>>
83529>>>>>>>Procedure MertechInc_SQL_SET_MYPROCEDURE_NAME Global String strProcName Integer iNumpar
83531>>>>>>>    Local Integer iParam
83531>>>>>>>
83531>>>>>>>    Move 0 to MertechInc_iParamCount           //Redundant, but left in incase called
83532>>>>>>>    INDICATE ERR False                  //directly and not via SQL_SET_PROCEDURE_NAME
83533>>>>>>>    Move MySQLFlex to MertechInc_DriverName    //
83534>>>>>>>
83534>>>>>>>    SQL_SET_STMT to "CALL "
83542>>>>>>>    SQL_APPEND_STMT to strProcName
83550>>>>>>>    SQL_APPEND_STMT to "("
83558>>>>>>>    For iParam from 1 to iNumpar
83564>>>>>>>>
83564>>>>>>>        DO_PASS_ARGUMENTS iParam
83596>>>>>>>    Loop
83597>>>>>>>>
83597>>>>>>>    SQL_APPEND_STMT to ")"
83605>>>>>>>    SQL_PREPARE_STMT
83617>>>>>>>End_Procedure
83618>>>>>>>
83618>>>>>>>Procedure MertechInc_SQL_SET_MSPROCEDURE_NAME Global String strProcName Integer iNumpar
83620>>>>>>>    local Integer iParam
83620>>>>>>>    local String  sParam
83620>>>>>>>
83620>>>>>>>    Move SQLFlex to MertechInc_DriverName
83621>>>>>>>
83621>>>>>>>    // This calling syntax is referred to as the "ODBC CALL escape sequence".  This syntax is
83621>>>>>>>    // advised over the execute command since CALL allows for the retrieval of the return codes
83621>>>>>>>    // from the call.
83621>>>>>>>    SQL_SET_STMT to "{? = CALL "
83629>>>>>>>    SQL_APPEND_STMT to strProcName
83637>>>>>>>
83637>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
83637>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
83637>>>>>>>    // the open and close parens ourself to make things more clear.
83637>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to " ("
83647>>>>>>>
83647>>>>>>>    For iParam from 1 to iNumpar
83653>>>>>>>>
83653>>>>>>>        DO_PASS_ARGUMENTS iParam
83685>>>>>>>    Loop
83686>>>>>>>>
83686>>>>>>>
83686>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to ")"
83696>>>>>>>    SQL_APPEND_STMT to  " };"
83704>>>>>>>
83704>>>>>>>    SQL_PREPARE_STMT
83716>>>>>>>
83716>>>>>>>    // This bind parameter is for the "{? = " which is technically the first parameter even though
83716>>>>>>>    // it is the return value.  The driver will bind MertechInc_iWork to it.
83716>>>>>>>    DO_BIND_PARAMETERS MertechInc_iWork
83739>>>>>>>End_Procedure
83740>>>>>>>
83740>>>>>>>Procedure MertechInc_SQL_SET_PGPROCEDURE_NAME Global String strProcName Integer iNumpar
83742>>>>>>>    local Integer iParam
83742>>>>>>>    local String  sParam
83742>>>>>>>
83742>>>>>>>    Move PgFlex to MertechInc_DriverName
83743>>>>>>>
83743>>>>>>>    // For Postgres, you can call a function just by passing the function name and
83743>>>>>>>    // open/close parens
83743>>>>>>>    SQL_SET_STMT to strProcName
83751>>>>>>>
83751>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
83751>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
83751>>>>>>>    // the open and close parens ourself to make things more clear.
83751>>>>>>>    SQL_APPEND_STMT to "( "
83759>>>>>>>
83759>>>>>>>    For iParam from 1 to iNumpar
83765>>>>>>>>
83765>>>>>>>        DO_PASS_ARGUMENTS iParam
83797>>>>>>>    Loop
83798>>>>>>>>
83798>>>>>>>
83798>>>>>>>    SQL_APPEND_STMT to ")"
83806>>>>>>>
83806>>>>>>>    SQL_PREPARE_STMT
83818>>>>>>>    // Indicate that a stored function will be executed - Query = 0, Procedure = 1, Function = 2
83818>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_EMBEDDED_SQL_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 1 RESULT MertechInc_iRet
83823>>>>>>>End_Procedure
83824>>>>>>>
83824>>>>>>>//=============================================================================
83824>>>>>>>/// @Name        SQL_GET_STMT
83824>>>>>>>/// @Description This command returns the last embedded SQL statement that
83824>>>>>>>/// was executed into a string. Optional parameters can be passed to specify
83824>>>>>>>/// what character to start the string at and also the maximum number of
83824>>>>>>>/// characters to allow for the string.
83824>>>>>>>///
83824>>>>>>>/// @Assumptions
83824>>>>>>>/// @Status      Public
83824>>>>>>>/// @Drivers     All
83824>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
83824>>>>>>>/// @See                 SQL_GET_STATEMENT
83824>>>>>>>///
83824>>>>>>>/// @Syntax SQL_GET_STMT to {variable} [{max} {start}]
83824>>>>>>>/// @Param variable                     SQL statement to be executed
83824>>>>>>>/// @Param max                          Indicates the maximum number of characters to get (optional)
83824>>>>>>>/// @Param start                        Indicates what character to start at for the returned string (optional)
83824>>>>>>>///
83824>>>>>>>/// @Example
83824>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
83824>>>>>>>/// SQL_PREPARE_STMT
83824>>>>>>>/// SQL_EXECUTE_STMT
83824>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
83824>>>>>>>/// If (Found) Begin
83824>>>>>>>///     Showln sFirstName
83824>>>>>>>///     Showln sLastName
83824>>>>>>>/// End
83824>>>>>>>///
83824>>>>>>>/// SQL_GET_STATEMENT to sValue
83824>>>>>>>/// Showln sValue
83824>>>>>>>
83824>>>>>>>
83824>>>>>>>Function MertechInc_SQL_GET_STATEMENT Global Integer iLength Integer iStart Returns String
83826>>>>>>>    Local String sStatement
83826>>>>>>>
83826>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
83828>>>>>>>
83828>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
83830>>>>>>>        Get MertechInc_Pre_Size_String 0 to sStatement
83831>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SQL_STMT CALLBACK 0 PASSING sStatement iStart iLength RESULT MertechInc_iRet
83836>>>>>>>    End
83836>>>>>>>>
83836>>>>>>>    Function_Return sStatement
83837>>>>>>>End_Function
83838>>>>>>>
83838>>>>>>>//=============================================================================
83838>>>>>>>/// @Name        SQL_SET_FUNCTION_NAME
83838>>>>>>>/// @Description This command is used in the same way as SQL_SET_PROCEDURE_NAME
83838>>>>>>>/// and SQL_SET_STMT to set the name of the function to be executed. When
83838>>>>>>>/// calling SQL functions in this fashion, this command must be used along with
83838>>>>>>>/// SQL_FUNCTION_EXECUTE (to execute the function), SQL_SET_FUNCTION_PARAMETER
83838>>>>>>>/// (to set the needed parameters) and SQL_GET_FUNCTION_RETURN (to get any
83838>>>>>>>/// returned value). The number of parameters must be set using the constant,
83838>>>>>>>/// NUMPAR, followed by the number of parameters. Note that when setting the
83838>>>>>>>/// name of the function, the user can be specified or, if left blank, the
83838>>>>>>>/// current user will be inserted before the function name.
83838>>>>>>>///
83838>>>>>>>/// @Assumptions
83838>>>>>>>/// @Status      Public
83838>>>>>>>/// @Drivers     All
83838>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
83838>>>>>>>/// @See                 SQL_FUNCTION_EXECUTE SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
83838>>>>>>>///
83838>>>>>>>/// @Syntax SQL_SET_FUNCTION_NAME {function} NUMPAR {parameters}
83838>>>>>>>/// @Param function                     Full name of the function
83838>>>>>>>/// @Param parameters           Number of parameters to pass
83838>>>>>>>///
83838>>>>>>>/// @Example
83838>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
83838>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
83838>>>>>>>/// SQL_FUNCTION_EXECUTE
83838>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
83838>>>>>>>/// Showln dDOB
83838>>>>>>>
83838>>>>>>>Procedure MertechInc_SQL_SET_ORAFUNCTION_NAME Global String strProcName Integer iNumpar
83840>>>>>>>    Local Integer iParam
83840>>>>>>>
83840>>>>>>>    SQL_SET_STMT to "BEGIN "
83848>>>>>>>    SQL_APPEND_STMT to ":PAR_RET := "
83856>>>>>>>    SQL_APPEND_STMT to strProcName
83864>>>>>>>    SQL_APPEND_STMT to "( "
83872>>>>>>>    For iParam from 1 to iNumpar
83878>>>>>>>>
83878>>>>>>>        DO_PASS_ARGUMENTS iParam
83910>>>>>>>    Loop
83911>>>>>>>>
83911>>>>>>>    SQL_APPEND_STMT to  " ); END;"
83919>>>>>>>    SQL_PREPARE_STMT
83931>>>>>>>
83931>>>>>>>    Move IS_OUT to MertechInc_iArg
83932>>>>>>>    Call_Driver 0 ORAFLEX Function CALLDRV_SET_PROC_ATTRIBUTE_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank MertechInc_iArg RESULT MertechInc_iRet
83937>>>>>>>
83937>>>>>>>    Increment MertechInc_iParamCount
83938>>>>>>>    Move ":PAR_RET" to MertechInc_sArg2
83939>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING MertechInc_Blank MertechInc_sArg2 16384 RESULT MertechInc_iRet
83944>>>>>>>End_Procedure
83945>>>>>>>
83945>>>>>>>Procedure MertechInc_SQL_SET_MYFUNCTION_NAME Global String strProcName Integer iNumpar
83947>>>>>>>    Local Integer iParam
83947>>>>>>>
83947>>>>>>>    Move MySQLFlex to MertechInc_DriverName
83948>>>>>>>
83948>>>>>>>    SQL_SET_STMT to "SELECT "
83956>>>>>>>    SQL_APPEND_STMT to strProcName
83964>>>>>>>    SQL_APPEND_STMT to "("
83972>>>>>>>    For iParam from 1 to iNumpar
83978>>>>>>>>
83978>>>>>>>        DO_PASS_ARGUMENTS iParam
84010>>>>>>>    Loop
84011>>>>>>>>
84011>>>>>>>    SQL_APPEND_STMT to ")"
84019>>>>>>>    SQL_PREPARE_STMT
84031>>>>>>>End_Procedure
84032>>>>>>>
84032>>>>>>>Procedure MertechInc_SQL_SET_SQLFUNCTION_NAME Global String strProcName Integer iNumpar
84034>>>>>>>    Local Integer iParam
84034>>>>>>>
84034>>>>>>>    Move SQLFlex to MertechInc_DriverName
84035>>>>>>>
84035>>>>>>>    If (not(strProcName contains ".")) Begin
84037>>>>>>>        String schema
84037>>>>>>>        GET_SCHEMA_NAME to schema
84059>>>>>>>        Move (schema + "." + strProcName) to strProcName
84060>>>>>>>    End
84060>>>>>>>>
84060>>>>>>>
84060>>>>>>>    SQL_SET_STMT    to "SELECT "
84068>>>>>>>    SQL_APPEND_STMT to strProcName
84076>>>>>>>    SQL_APPEND_STMT to "("
84084>>>>>>>End_Procedure
84085>>>>>>>
84085>>>>>>>Procedure MertechInc_SQL_SET_PGFUNCTION_NAME Global String strProcName Integer iNumpar
84087>>>>>>>    Local Integer iParam
84087>>>>>>>
84087>>>>>>>    Move PgFlex to MertechInc_DriverName
84088>>>>>>>
84088>>>>>>>    SQL_SET_STMT    to "SELECT "
84096>>>>>>>    SQL_APPEND_STMT to strProcName
84104>>>>>>>    SQL_APPEND_STMT to "("
84112>>>>>>>End_Procedure
84113>>>>>>>
84113>>>>>>>//=============================================================================
84113>>>>>>>/// @Name        SQL_SET_PROCEDURE_PARAMETER
84113>>>>>>>/// @Description
84113>>>>>>>/// With this command you can pass one or more parameters to predefined
84113>>>>>>>/// stored procedures on a MySQL or Oracle server. The SQL_SET_PROCEDURE_PARAMETER
84113>>>>>>>/// command enables you to add a parameter to a stored procedure which you are
84113>>>>>>>/// planning to call. You can pass multiple parameters by calling the command
84113>>>>>>>/// for each parameter.
84113>>>>>>>///
84113>>>>>>>/// When passing parameters you'll have to inform the driver which variable
84113>>>>>>>/// you are passing, starting with 1 from left-to-right in the parameter list.
84113>>>>>>>///
84113>>>>>>>/// For each parameter you'll have to indicate if the variable is to be
84113>>>>>>>/// regarded as input, output or both.
84113>>>>>>>///
84113>>>>>>>///@Assumptions
84113>>>>>>>/// @Status      Public
84113>>>>>>>/// @Drivers     All
84113>>>>>>>/// @VersionNote Last Revised: 2013-09-27 by Aaron Gulack
84113>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_PROCEDURE_EXECUTE
84113>>>>>>>///
84113>>>>>>>/// @Syntax SQL_SET_PROCEDURE_PARAMETER {number} to {variable} {direction}
84113>>>>>>>/// @Param number                       Index number of the parameter being defined.
84113>>>>>>>/// @Param variable                     Variable holding the parameter to be passed.
84113>>>>>>>/// @Param direction            IN, OUT, IN_OUT, RSET, or leave blank
84113>>>>>>>///
84113>>>>>>>/// @Example
84113>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
84113>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
84113>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
84113>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
84113>>>>>>>/// SQL_PROCEDURE_EXECUTE
84113>>>>>>>
84113>>>>>>>
84113>>>>>>>
84113>>>>>>>//=============================================================================
84113>>>>>>>/// @Name        SQL_GET_PROCEDURE_PARAMETER
84113>>>>>>>/// @Description This command is used to get the value of a specific
84113>>>>>>>/// parameter associated with a stored procedure.  Although this
84113>>>>>>>/// command will work with any parameter, it is mostly be used with
84113>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
84113>>>>>>>/// once returned. When multiple values are returned, this command can be
84113>>>>>>>/// more efficient than other options. Note that the specified parameter
84113>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
84113>>>>>>>/// in order to work properly.
84113>>>>>>>///
84113>>>>>>>/// @Assumptions
84113>>>>>>>/// @Status      Public
84113>>>>>>>/// @Drivers     All
84113>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84113>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
84113>>>>>>>///
84113>>>>>>>/// @Syntax SQL_GET_PROCEDURE_PARAMETER {parameter} to {variable}
84113>>>>>>>/// @Param parameter            Number of paramater to return
84113>>>>>>>/// @Param variable                     Variable to hold the value of the parameter
84113>>>>>>>///
84113>>>>>>>/// @Example
84113>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
84113>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
84113>>>>>>>/// SQL_PROCEDURE_EXECUTE
84113>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 1 to sStatus
84113>>>>>>>///
84113>>>>>>>/// Showln sStatus
84113>>>>>>>///
84113>>>>>>>/// @Example
84113>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
84113>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
84113>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
84113>>>>>>>/// SQL_PROCEDURE_EXECUTE
84113>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
84113>>>>>>>///
84113>>>>>>>/// Showln sStatus
84113>>>>>>>
84113>>>>>>>
84113>>>>>>>
84113>>>>>>>//=============================================================================
84113>>>>>>>/// @Name        SQL_GET_FUNCTION_RETURN
84113>>>>>>>/// @Description This variable is used to get the value returned from a SQL
84113>>>>>>>/// function call. After the function has been successfully called, this
84113>>>>>>>/// command takes the returned value and inserts it the given variable.
84113>>>>>>>///
84113>>>>>>>/// @Assumptions
84113>>>>>>>/// @Status      Public
84113>>>>>>>/// @Drivers     All
84113>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84113>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_FUNCTION_EXECUTE
84113>>>>>>>///
84113>>>>>>>/// @Syntax SQL_GET_FUNCTION_RETURN to {variable}
84113>>>>>>>/// @Param variable                     Variable to hold the returned value
84113>>>>>>>///
84113>>>>>>>/// @Example
84113>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
84113>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
84113>>>>>>>/// SQL_FUNCTION_EXECUTE
84113>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
84113>>>>>>>/// Showln dDOB
84113>>>>>>>
84113>>>>>>>//=============================================================================
84113>>>>>>>/// @Name        SQL_FUNCTION_EXECUTE
84113>>>>>>>/// @Description This command is used to execute the function statement
84113>>>>>>>/// that was built by the SQL_SET_FUNCTION_NAME and subsequent
84113>>>>>>>/// SQL_SET_FUNCTION_PARAMETER commands. This works similarly to the
84113>>>>>>>/// SQL_EXECUTE_STMT command. Note that executing the function with this
84113>>>>>>>/// command will not get any returned values but will simply execute the
84113>>>>>>>/// function.
84113>>>>>>>///
84113>>>>>>>/// @Assumptions
84113>>>>>>>/// @Status      Public
84113>>>>>>>/// @Drivers     All
84113>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84113>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
84113>>>>>>>///
84113>>>>>>>/// @Syntax SQL_FUNCTION_EXECUTE
84113>>>>>>>///
84113>>>>>>>/// @Example
84113>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
84113>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
84113>>>>>>>/// SQL_FUNCTION_EXECUTE
84113>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
84113>>>>>>>/// Showln dDOB
84113>>>>>>>
84113>>>>>>>Procedure MertechInc_SQL_FUNCTION_EXECUTE Global String sDriverName
84115>>>>>>>    Local Integer iParam
84115>>>>>>>    Local String  sParam
84115>>>>>>>
84115>>>>>>>    If (sDriverName = SQLFLEX or sDriverName = PgFlex) Begin
84117>>>>>>>       SQL_APPEND_STMT to ')'
84125>>>>>>>       SQL_PREPARE_STMT
84137>>>>>>>    End
84137>>>>>>>>
84137>>>>>>>
84137>>>>>>>    SQL_EXECUTE_STMT
84152>>>>>>>    If (sDriverName <> ORAFLEX) Begin
84154>>>>>>>        SQL_FETCH_NEXT_ROW
84169>>>>>>>>
84169>>>>>>>    End
84169>>>>>>>>
84169>>>>>>>End_Procedure
84170>>>>>>>
84170>>>>>>>//=============================================================================
84170>>>>>>>/// @Name        REEXEC_ORACLE_STORED_PROCEDURE
84170>>>>>>>/// @Description This command is used to re-execute a stored procedure
84170>>>>>>>/// when using Oracle. Although it follows the same format as
84170>>>>>>>/// CALL_STORED_PROCEDURE, it can be useful because it does not need to
84170>>>>>>>/// prepare the procedure again before executing. This can cause speed
84170>>>>>>>/// improvements when calling a stored procedure multiple times.
84170>>>>>>>///
84170>>>>>>>/// @Assumptions A procedure has already been created through CALL_STORED_PROCEDURE
84170>>>>>>>/// @Status      Public
84170>>>>>>>/// @Drivers     ORAFLex
84170>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84170>>>>>>>/// @See                 CALL_STORED_PROCEDURE
84170>>>>>>>///
84170>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
84170>>>>>>>/// @Param procedure            Full name of the procedure
84170>>>>>>>/// @Param variable                     Parameter to pass (optional and can be multiple)
84170>>>>>>>///
84170>>>>>>>/// @Example
84170>>>>>>>/// CALL_STORED_PROCEDURE "user.getCustomerStatus" Passing sCustomerID sStatus
84170>>>>>>>/// Showln sStatus
84170>>>>>>>///
84170>>>>>>>/// Move (sCustomerID + 1) to sCustomerID
84170>>>>>>>///
84170>>>>>>>/// REEXEC_ORACLE_STORED_PROCEDURE "user.getCustomerStatus" passing sCustomerID sStatus
84170>>>>>>>/// Showln sStatus
84170>>>>>>>
84170>>>>>>>
84170>>>>>>>//=============================================================================
84170>>>>>>>/// @Name        CALL_STORED_FUNCTION
84170>>>>>>>/// @Description This command is used to execute a function stored in the
84170>>>>>>>/// SQL backend. This is an alternative to building a function with the
84170>>>>>>>/// SQL_SET_FUNCTION_NAME, SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE
84170>>>>>>>/// commands. This command builds and executes the function by setting the full
84170>>>>>>>/// function name, the parameter(s) to pass and the variable to hold the
84170>>>>>>>/// returned value. Note that this command can only return a single value
84170>>>>>>>/// so SQL_SET_FUNCTION_PARAMETER and SQL_SET_FUNCTION_NAME must be used when
84170>>>>>>>/// dealing with multiple return values.
84170>>>>>>>///
84170>>>>>>>/// Assumptions
84170>>>>>>>/// @Status      Public
84170>>>>>>>/// @Drivers     ORAFLex MySQLFlex PgFlex
84170>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84170>>>>>>>/// @See
84170>>>>>>>///
84170>>>>>>>/// @Syntax CALL_STORED_FUNCTION {function} Returns {variable} Passing {parameters}
84170>>>>>>>/// @Param function                     Full name of the function
84170>>>>>>>/// @Param variable                     Variable to hold the returned value
84170>>>>>>>/// @Param parameters           Parameter to pass to the function (can be multiple)
84170>>>>>>>///
84170>>>>>>>/// @Example
84170>>>>>>>/// Move 5 to sCustomerID
84170>>>>>>>/// CALL_STORED_FUNCTION "getCustomerStatus" Returns sStatus Passing sCustomerID
84170>>>>>>>/// Showln sStatus
84170>>>>>>>
84170>>>>>>>//=============================================================================
84170>>>>>>>/// @Name        OUTPUT_INT_FILE
84170>>>>>>>/// @Description This command is used to output the int file of an opened
84170>>>>>>>/// table. If the file to be output to does not exist, it will be created
84170>>>>>>>/// upon execution of this command. Note that the INT file can be output
84170>>>>>>>/// into multiple types of files i.e. .doc, .txt, .int.
84170>>>>>>>///
84170>>>>>>>/// @Assumptions
84170>>>>>>>/// @Status      Public
84170>>>>>>>/// @Drivers     All
84170>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84170>>>>>>>/// @See
84170>>>>>>>///
84170>>>>>>>/// @Syntax OUTPUT_INT_FILE for {FileNumber} to {variable}
84170>>>>>>>/// @Param FileNumber           The file number
84170>>>>>>>/// @Param variable                     Path of the file being output to
84170>>>>>>>///
84170>>>>>>>///@Example
84170>>>>>>>/// OUTPUT_INT_FILE for Customer.File_Number to "C:\Temp\Customer.int"
84170>>>>>>>
84170>>>>>>>//=============================================================================
84170>>>>>>>/// @Name        SQL_ERROR_MESSAGE
84170>>>>>>>/// @Description This command is used to get an error message
84170>>>>>>>/// from a given SQL statement. If the given statement is executed with
84170>>>>>>>/// no errors, the variable specified with this command will be blank.
84170>>>>>>>/// Otherwise the message will be stored in the given variable. Note that
84170>>>>>>>/// unless specified, strings have a size limit of 80 characters, so using
84170>>>>>>>/// a variant can ensure the full message is retrieved.
84170>>>>>>>///
84170>>>>>>>/// @Assumptions
84170>>>>>>>/// @Status      Public
84170>>>>>>>/// @Drivers     All
84170>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84170>>>>>>>/// @See         SQL_ERROR_MESSAGE2
84170>>>>>>>///
84170>>>>>>>/// @Syntax SQL_ERROR_MESSAGE {variable}
84170>>>>>>>/// @Param variable                     Variable to hold the error message
84170>>>>>>>///
84170>>>>>>>/// @Example
84170>>>>>>>/// SQL_ERROR_MESSAGE sError
84170>>>>>>>
84170>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE Global Returns String
84172>>>>>>>    Local String sMessage
84172>>>>>>>
84172>>>>>>>    Get MertechInc_Pre_Size_String 0 to sMessage
84173>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE CALLBACK 0 PASSING MertechInc_Blank sMessage 0 RESULT MertechInc_iRet
84178>>>>>>>
84178>>>>>>>    Function_Return sMessage
84179>>>>>>>End_Function
84180>>>>>>>
84180>>>>>>>//=============================================================================
84180>>>>>>>/// @Name        SQL_ERROR_MESSAGE2
84180>>>>>>>/// @Description This command is used to get the last error message used
84180>>>>>>>/// for the specified server. This can be useful once a transaction has
84180>>>>>>>/// already been completed and any error messages need to be retrieved.
84180>>>>>>>///
84180>>>>>>>/// @Assumptions
84180>>>>>>>/// @Status      Public
84180>>>>>>>/// @Drivers     All
84180>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84180>>>>>>>/// @See         SQL_ERROR_MESSAGE SQL_ERROR_MESSAGE2
84180>>>>>>>///
84180>>>>>>>/// @Syntax SQL_ERROR_MESSAGE2 of {server} to {variable}
84180>>>>>>>/// @Param server                       Name of the server
84180>>>>>>>/// @Param variable                     Variable to hold the error message
84180>>>>>>>///
84180>>>>>>>/// @Example
84180>>>>>>>/// SQL_ERROR_MESSAGE2 of "localhost" to sError
84180>>>>>>>
84180>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE2 Global String sServer Returns String
84182>>>>>>>    Local String sMessage
84182>>>>>>>
84182>>>>>>>    Get MertechInc_Pre_Size_String 800 to sMessage
84183>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE2 CALLBACK 0 PASSING sServer sMessage 0 RESULT MertechInc_iRet
84188>>>>>>>
84188>>>>>>>    Function_Return sMessage
84189>>>>>>>End_Function
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        MERTECH_WARNING_MESSAGE
84190>>>>>>>/// @Description When restructuring a table, i.e. Structure_Start, a warning
84190>>>>>>>/// message will appear to confirm the restructure before it is executed.
84190>>>>>>>/// This command is used to disable or enable that warning message. All that
84190>>>>>>>/// is passed is either the constant "Enabled" or "Disabled". By default,
84190>>>>>>>/// this message is enabled.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84190>>>>>>>///
84190>>>>>>>/// @Syntax MERTECH_WARNING_MESSAGE {Enabled|Disabled}
84190>>>>>>>/// @Param Enabled                      Enables the restructure warning
84190>>>>>>>/// @Param Disabled                     Disables the restructure warning
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// Move Customer.File_Number to hFile
84190>>>>>>>/// MERTECH_WARNING_MESSAGE Disabled
84190>>>>>>>///
84190>>>>>>>/// Structure_Start hFile
84190>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
84190>>>>>>>/// Structure_End hFile
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        DISABLE_SELECT_COLUMNS_ERRORS
84190>>>>>>>/// @Description When using SELECT_COLUMNS_FIND to limit the number of columns
84190>>>>>>>/// to fetch, the framework might still ask for columns that you do not need.
84190>>>>>>>/// As a result you'll end up getting runtime errors you do not want to see.
84190>>>>>>>/// This command gives you the ability to stop reporting errors for querying
84190>>>>>>>/// for data from columns that are not part of the query.
84190>>>>>>>///
84190>>>>>>>/// DISABLED_SELECT_COLUMNS_ERRORS DISABLED will disable the errors, use
84190>>>>>>>/// ENABLED to turn the error messages back on.
84190>>>>>>>///
84190>>>>>>>/// By default triggering error messages on unknown columns is ENABLED
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
84190>>>>>>>/// @See         SELECT_COLUMNS_FIND RESET_FETCH_FIELDS
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// Open Customer
84190>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
84190>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
84190>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
84190>>>>>>>///
84190>>>>>>>/// Clear Customer
84190>>>>>>>/// Repeat
84190>>>>>>>///    Find Gt Customer by Index.1
84190>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
84190>>>>>>>/// Until (Not(Found))
84190>>>>>>>///
84190>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
84190>>>>>>>///
84190>>>>>>>/// @Syntax DISABLE_SELECT_COLUMNS_ERRORS {ENABLED|DISABLED}
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SQLFlex_REVISION
84190>>>>>>>/// @Description This command will put the current version (decimals included)
84190>>>>>>>/// of the MSSQL driver associated with the current workspace into the
84190>>>>>>>/// specified variable.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Deprecated
84190>>>>>>>/// @Drivers     SQLFlex
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84190>>>>>>>/// @See                 GET_DRIVER_REVISION
84190>>>>>>>///
84190>>>>>>>/// @Syntax SQLFlex_REVISION {variable}
84190>>>>>>>/// @Param variable                     String variable to hold the returned version
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// SQLFlex_REVISION sVersion
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SQLFlex_MAJOR_REVISION
84190>>>>>>>/// @Description This command will put the major version (no decimals) of
84190>>>>>>>/// the the MSSQL driver associated with the current workspace into the
84190>>>>>>>/// specified variable.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Deprecated
84190>>>>>>>/// @Drivers     SQLFlex
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84190>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
84190>>>>>>>///
84190>>>>>>>/// @Syntax SQLFlex_MAJOR_REVISION {variable}
84190>>>>>>>/// @Param variable                     String variable to hold the returned version
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// SQLFlex_MAJOR_REVISION sVersion
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        LOGGED_USERS
84190>>>>>>>/// @Description This command returns the number of native users that are
84190>>>>>>>/// using the driver currently. This number is stored in the variable that
84190>>>>>>>/// is passed with the command.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84190>>>>>>>/// @See                 MAXIMUM_NUMBER_OF_USERS
84190>>>>>>>///
84190>>>>>>>/// @Syntax LOGGED_USERS {variable}
84190>>>>>>>/// @Param variable                     Variable to hold the number of users
84190>>>>>>>///
84190>>>>>>>/// @Example LOGGED_USERS sUsers
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_USERS
84190>>>>>>>/// @Description This command returns the maximum number of user allowed by
84190>>>>>>>/// the current license.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84190>>>>>>>/// @See                 LOGGED_USERS
84190>>>>>>>///
84190>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_USERS {variable}
84190>>>>>>>/// @Param variable                     Variable to hold the maximum number of users
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// MAXIMUM_NUMBER_OF_USERS sMax
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SET_DATABASE_NAME
84190>>>>>>>/// @Description This command overrides the database set in the INT file
84190>>>>>>>/// under DATABASE_SPACE_NAME. Any opens or finds will use the database
84190>>>>>>>/// specified here. This can be used when the database is not stated in
84190>>>>>>>/// the INT file or if the database needs to be dynamically changed for
84190>>>>>>>/// a certain query. If the database is not specified with this command
84190>>>>>>>/// or in the INT file, then the default database for the server will be
84190>>>>>>>/// used. To set the database to be used for embedded SQL statements,
84190>>>>>>>/// use SQL_USE_DATABASE.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PGFlex
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84190>>>>>>>/// @See                 GET_DATABASE_NAME SQL_USE_DATABASE
84190>>>>>>>/// @INTOPT              DATABASE_SPACE_NAME
84190>>>>>>>///
84190>>>>>>>/// @Syntax SET_DATABASE_NAME to {database}
84190>>>>>>>/// @Param database                     Name of the database
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// Login "localhost" "user" "pas123" "sql_drv"
84190>>>>>>>/// SET_DATABASE_NAME to "TestDB"
84190>>>>>>>/// Open Customer
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        GET_DATABASE_NAME
84190>>>>>>>/// @Description This command is used to get the name of the database
84190>>>>>>>/// currently being used. The name of the database is returned into the
84190>>>>>>>/// specified string. Even though this command works either way, it is
84190>>>>>>>/// typically used when the INT file does not contain the DATABASE_SPACE_NAME.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PgFlex
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84190>>>>>>>/// @See SET_DATABASE_NAME SQL_USE_DATABASE
84190>>>>>>>///
84190>>>>>>>/// @Syntax GET_DATABASE_NAME to {variable}
84190>>>>>>>/// @Param variable                     Variable to hold the database name
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// GET_DATABASE_NAME to sDbName
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        GET_NAME_SPACE
84190>>>>>>>/// @Description This command returns the name space, or schema, being
84190>>>>>>>/// used with the current application.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     PgFlex
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84190>>>>>>>/// @See                 SET_NAME_SPACE
84190>>>>>>>///
84190>>>>>>>/// @Syntax GET_NAME_SPACE to {variable}
84190>>>>>>>/// @Param variable                     Variable to hold the returned name space.
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// GET_NAME_SPACE to sNameSpace
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SET_NAME_SPACE
84190>>>>>>>/// @Description This command sets the name space, or schema, to be used
84190>>>>>>>/// for the application. In Postgres, schemas are objects where all the
84190>>>>>>>/// tables,views and indexes are stored. Separate schemas are used to
84190>>>>>>>/// specify relational data. Note that this command will override the
84190>>>>>>>/// NAME_SPACE value in the INT file.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     PgFlex
84190>>>>>>>/// @VersionNote Last Revised: 2009-08-14 By Ian Smith
84190>>>>>>>/// @See                 GET_NAME_SPACE
84190>>>>>>>/// @INTOPT              NAME_SPACE
84190>>>>>>>///
84190>>>>>>>/// @Syntax SET_NAME_SPACE to {variable}
84190>>>>>>>/// @Param variable                     Name of the name space
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// SET_NAME_SPACE to "public"
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SQL_USE_DATABASE
84190>>>>>>>/// @Description This command is used to specify which database is used
84190>>>>>>>/// for SQL statements only. Any normal table queries or changes will
84190>>>>>>>/// still use the default database, this only effects SQL statements.
84190>>>>>>>/// If none is specified then the default database is used. This can
84190>>>>>>>/// be useful if a certain SQL statement needs to query data from a
84190>>>>>>>/// database not currently being used. Note that this only works if
84190>>>>>>>/// the table name is not fully qualified in the SQl statement, i.e.
84190>>>>>>>/// "TestDB.Customer".
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     SQLFlex MySQLFLex PgSQL
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84190>>>>>>>/// @See                 SET_DATABASE_NAME GET_DATABASE_NAME
84190>>>>>>>///
84190>>>>>>>/// @Syntax SQL_USE_DATABASE of {server} to {database}
84190>>>>>>>/// @Param server                       Name of the server (Postgre only)
84190>>>>>>>/// @Param database                     Name of the database
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// SQL_USE_DATABASE "testDB"
84190>>>>>>>///
84190>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
84190>>>>>>>/// SQL_PREPARE_STMT
84190>>>>>>>/// SQL_EXECUTE_STMT
84190>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName
84190>>>>>>>/// If (Found) Begin
84190>>>>>>>///     Showln sFirstName
84190>>>>>>>///     Showln sLastName
84190>>>>>>>/// End
84190>>>>>>>/// SQL_CANCEL_QUERY_STMT
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER
84190>>>>>>>/// @Description This command is used to set the server to be used when
84190>>>>>>>/// opening tables. It will override the SERVER_NAME token in the INT file.
84190>>>>>>>/// If the server is not specified in the INT file or with this command,
84190>>>>>>>/// then the server used during login will be used. This command is only
84190>>>>>>>/// needed when connecting to multiple SQL servers. To set the server to
84190>>>>>>>/// use for embedded SQL statements, use SET_CURRENT_SQL_SERVER_CONNECTION.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84190>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER  SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
84190>>>>>>>/// @INTOPT              SERVER_NAME
84190>>>>>>>///
84190>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER to {server}
84190>>>>>>>/// @Param server                       Name of the server
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// SET_CURRENT_SQL_SERVER to "localhost"
84190>>>>>>>
84190>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
84190>>>>>>>//               replace conflicts with the property SET message.
84190>>>>>>>//#Replace SET_CURRENT_SERVER SET_CURRENT_SQL_SERVER
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER
84190>>>>>>>/// @Description This command returns the name of the server to be used
84190>>>>>>>/// for opening and querying tables.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84190>>>>>>>/// @See SET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
84190>>>>>>>///
84190>>>>>>>/// @Syntax GET_CURRENT_SERVER to {variable}
84190>>>>>>>/// @Param variable                     Variable to hold the server name
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// GET_CURRENT_SQL_SERVER to sServer
84190>>>>>>>
84190>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
84190>>>>>>>//               replace conflicts with the property GET message.
84190>>>>>>>//#Replace GET_CURRENT_SERVER GET_CURRENT_SQL_SERVER
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER_CONNECTION
84190>>>>>>>/// @Description This command is used to specify which server to use for
84190>>>>>>>/// embedded SQL statements. By default, the last logged in server will
84190>>>>>>>/// be used. Note that in addition to setting the server, this command
84190>>>>>>>/// also sets the driver to be used. This command is only needed when
84190>>>>>>>/// connecting to multiple servers. To set the server for opening tables,
84190>>>>>>>/// use SET_CURRENT_SQL_SERVER.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84190>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
84190>>>>>>>///
84190>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {server}
84190>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
84190>>>>>>>/// @Param server               Name of the server
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to "(localdb)\v11.0"
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER_CONNECTION
84190>>>>>>>/// @Description This command returns the server currently being used for
84190>>>>>>>/// embedded SQL statements.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84190>>>>>>>/// @See                 SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
84190>>>>>>>///
84190>>>>>>>/// @Syntax GET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {variable}
84190>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
84190>>>>>>>/// @Param variable             Variable to hold the name of the server
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// GET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        LOGIN_SQLFLEX
84190>>>>>>>/// @Description This command allows the user to login with a specified
84190>>>>>>>/// hostname. The default hostname that is passed is the path of the
84190>>>>>>>/// executable. Passing a custom hostname can be very useful for tracking
84190>>>>>>>/// a specific user for different situations. For example, if a company
84190>>>>>>>/// is using a terminal server and a whole sales team logs in under the
84190>>>>>>>/// same username and hostname, locating a specific user could otherwise
84190>>>>>>>/// be difficult. With this command, each user can pass a custom hostname,
84190>>>>>>>/// easily distinguishing themselves from other users.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     SQLFlex
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84190>>>>>>>/// @See
84190>>>>>>>///
84190>>>>>>>/// @Syntax LOGIN_SQLFLEX {server} {username} {password} {hostname}
84190>>>>>>>/// @Param server               Server to use for login
84190>>>>>>>/// @Param username     Username to use for login
84190>>>>>>>/// @Param password     Password to use for login
84190>>>>>>>/// @Param hostname     Hostname to use for login
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// LOGIN_SQLFLEX "localhost" "guestUser" "pas123" "WIN-MM7PQS5CP6C"
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SQL_CANCEL_QUERY_STMT
84190>>>>>>>/// @Description This command is used to close any open cursors related to
84190>>>>>>>/// an SQL_EXECUTE_STMT. This should be used once the SQL statement has
84190>>>>>>>/// been executed and all rows have been fetched.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-03 by Aaron Gulack
84190>>>>>>>/// @See                 SQL_SET_STMT SQL_EXECUTE_STMT SQL_FETCH_NEXT_ROW SQL_APPEND_STMT SQL_PREPARE_STMT
84190>>>>>>>///
84190>>>>>>>/// @Syntax SQL_CANCEL_QUERY_STMT [of {FileName}]
84190>>>>>>>/// @Param FileName             Name of the file (optional)
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
84190>>>>>>>/// SQL_PREPARE_STMT
84190>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
84190>>>>>>>/// SQL_EXECUTE_STMT of Customer
84190>>>>>>>/// SQL_FETCH_NEXT_ROW of Customer
84190>>>>>>>/// If (Found) Begin
84190>>>>>>>///     Showln Customer.FirstName
84190>>>>>>>///     Showln Customer.LastName
84190>>>>>>>/// End
84190>>>>>>>/// SQL_CANCEL_QUERY_STMT of Customer
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        NATIVE_OPTIMIZATION
84190>>>>>>>/// @Description Allows user to turn off the use of index hints on the native
84190>>>>>>>/// server. Setting this command to DEFAULT will cause the server to use the
84190>>>>>>>/// default settings for hints. Hints are off by default in Microsoft SQL
84190>>>>>>>/// Server but are on in Oracle. Care should be taken with changing the
84190>>>>>>>/// default, and should only be used if the diagnostics tool for your server
84190>>>>>>>/// indicates performance problems with the type of queries that are being
84190>>>>>>>/// generated. Note that this can be turned off or on for the whole server
84190>>>>>>>/// or just for a specific table.
84190>>>>>>>///
84190>>>>>>>/// DEFAULT             - The specified server's default settings
84190>>>>>>>/// USE_INDEXHINT       - All Index hints will be used
84190>>>>>>>/// NO_INDEXHINT        - No index hints will be used
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     SQLFlex, ORAFlex
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84190>>>>>>>/// @See
84190>>>>>>>///
84190>>>>>>>/// @Syntax NATIVE_OPTIMIZATION of {scopeLevel} {variable} to {constant}
84190>>>>>>>/// @Param scopeLevel           TABLE or SERVER. Indicates the scope of the setting
84190>>>>>>>/// @Param variable                     Either the name of the server or of the table
84190>>>>>>>/// @Param constant                     DEFAULT, USE_INDEXHINT, or NO_INDEXHINT
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// NATIVE_OPTIMIZATION of SERVER "localhost" to USE_INDEXHINT
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SET_ISOLATION_LEVEL
84190>>>>>>>/// @Description This command sets the locking and row versioning behavior
84190>>>>>>>/// for SQL statements. See the options below for information on the various
84190>>>>>>>/// effects they can have on transactions.
84190>>>>>>>///
84190>>>>>>>/// DEFAULT  - The default isolation level for the server (READ_COMMITTED
84190>>>>>>>/// for MSSQL).
84190>>>>>>>///
84190>>>>>>>/// READ_COMMITTED - This option is used to prevent dirty reads. A dirty
84190>>>>>>>/// read is when one transaction reads data from another transaction that
84190>>>>>>>/// has yet to be committed. If one transaction fails, the other now is
84190>>>>>>>/// dealing with invalid data. By setting the isolation level to
84190>>>>>>>/// READ_COMMITTED, dirty reads will be avoided by not allowing transactions
84190>>>>>>>/// to deal with any other data that has not been committed yet. However,
84190>>>>>>>/// in between statements within the current transaction, data can be changed
84190>>>>>>>/// by other transactions. This can result in phantom data or non-repeatable
84190>>>>>>>/// reads. Note that this can slow down performance speeds but is usually
84190>>>>>>>/// good practice.
84190>>>>>>>///
84190>>>>>>>/// READ_UNCOMMITTED - This option is the least restrictive isolation level.
84190>>>>>>>/// With this option, dirty reads are allowed, thus no exclusive locks are
84190>>>>>>>/// honored and modified data from one uncommitted transaction can be read
84190>>>>>>>/// by other transactions.
84190>>>>>>>///
84190>>>>>>>/// REPEATABLE_READ - This option is similar to the READ_COMMITTED option
84190>>>>>>>/// in that locks all placed on all transactions and uncommitted data from
84190>>>>>>>///     other transactions cannot be read, preventing dirty reads. However, unlike
84190>>>>>>>/// READ_COMMITTED, new rows that are added by other transactions can be read
84190>>>>>>>/// by the current transaction if it is retried, possibly resulting in phantom
84190>>>>>>>/// reads. This option should not be used unless there is a specific reason to
84190>>>>>>>/// do so.
84190>>>>>>>///
84190>>>>>>>/// SERIALIZABLE - This option is the most restrictive isolation level. With
84190>>>>>>>/// this option, no interaction is allowed between transactions until they
84190>>>>>>>/// have been committed. Similar to READ_COMMITTED, no transaction can deal
84190>>>>>>>/// with any uncommitted data. On top of that though, range locks are placed on
84190>>>>>>>/// all rows being modified until the current transaction is complete. Because
84190>>>>>>>/// concurrency is so low with this option, performance speeds can be much lower
84190>>>>>>>/// and so this should only be used when there is a specific reason to do so.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84190>>>>>>>/// @See
84190>>>>>>>///
84190>>>>>>>/// @Syntax SET_ISOLATION_LEVEL of {server} to {constant}
84190>>>>>>>/// @Param server                       Name of the server
84190>>>>>>>/// @Param constant                     DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, or SERIALIZABLE
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// LOGIN "localhost" "user" "pass123" "SQL_DRV"
84190>>>>>>>/// SET_ISOLATION_LEVEL of "localhost" to READ_COMMITTED
84190>>>>>>>
84190>>>>>>>//=============================================================================
84190>>>>>>>/// @Name        SET_SESSION_PARAMETER
84190>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
84190>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
84190>>>>>>>/// code pages. When migrating data, this command is used to determine whether
84190>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
84190>>>>>>>/// migrating passwords with special characters may call for different code
84190>>>>>>>/// pages. Sending true will convert the OEM data to ANSI, sending false will
84190>>>>>>>/// not. Both OEM_TO_ANSI and OEM_TRANSLATION_STATE do essentially the same
84190>>>>>>>/// thing, however since MSSQL has the functionality built in, OEM_TO_ANSI
84190>>>>>>>/// will use MSSQL's built in translation and thus only works with SQLFlex.
84190>>>>>>>/// OEM_TRANSLATION_STATE is internal and built into the driver so it works
84190>>>>>>>/// for all drivers. Note that if using custom entries with
84190>>>>>>>/// SET_CUSTOM_OEM_TO_ANSI then OEM_TRANSLATION_STATE must be used. Also, if
84190>>>>>>>/// there are already custom entries set then turning OEM_TRANSLATION_STATE
84190>>>>>>>/// on will automatically enable those custom translations.
84190>>>>>>>///
84190>>>>>>>/// @Assumptions
84190>>>>>>>/// @Status      Public
84190>>>>>>>/// @Drivers     All
84190>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84190>>>>>>>/// @See                 SET_CUSTOM_OEM_TO_ANSI GET_CUSTOM_OEM_TO_ANSI
84190>>>>>>>///
84190>>>>>>>/// @Syntax SET_SESSION_PARAMETER {OEM_TO_ANSI/OEM_TRANSLATION_STATE} to {variable}
84190>>>>>>>/// @Param variable                     Boolean variable enabling or disabling translation
84190>>>>>>>///
84190>>>>>>>/// @Example
84190>>>>>>>/// SET_SESSION_PARAMETER OEM_TO_ANSI to True
84190>>>>>>>
84190>>>>>>>Procedure MertechInc_SET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
84192>>>>>>>    Move iChar to MertechInc_sArg1
84193>>>>>>>    move (String(iOem) + "," + String(iAnsi)) to MertechInc_sArg2
84194>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_SET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
84199>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
84202>>>>>>>End_Procedure
84203>>>>>>>
84203>>>>>>>//=============================================================================
84203>>>>>>>/// @Name        SET_CUSTOM_OEM_TO_ANSI
84203>>>>>>>/// @Description In very rare situations, a custom OEM to ANSI translation
84203>>>>>>>/// is needed. When that is the case, this command can be used to create
84203>>>>>>>/// those custom entries. This is done by passing the character numbered
84203>>>>>>>/// position, the OEM value and the ANSI value. Note that
84203>>>>>>>/// OEM_TRANSLATION_STATE must be set to true for these custom entries to
84203>>>>>>>/// work.
84203>>>>>>>///
84203>>>>>>>/// @Assumptions
84203>>>>>>>/// @Status      Public
84203>>>>>>>/// @Drivers     All
84203>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84203>>>>>>>/// @See                 GET_CUSTOM_OEM_TO_ANSI SET_SESSION_PARAMETER
84203>>>>>>>///
84203>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
84203>>>>>>>/// @Param character            Numbered position (0-255) of the character
84203>>>>>>>/// @Param value1                       Character number for the OEM value
84203>>>>>>>/// @Param value2                       Character number for the ANSI value
84203>>>>>>>
84203>>>>>>>Procedure MertechInc_GET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
84205>>>>>>>    Move iChar to MertechInc_sArg1
84206>>>>>>>    Move (Repeat(" ", 255)) to MertechInc_sArg2
84207>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_GET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
84212>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
84215>>>>>>>End_Function
84216>>>>>>>
84216>>>>>>>//=============================================================================
84216>>>>>>>/// @Name        GET_CUSTOM_OEM_TO_ANSI
84216>>>>>>>/// @Description This command returns the custom OEM and ANSI values
84216>>>>>>>/// respectively for a given character. If there is no custom translation
84216>>>>>>>/// for the specified character then no error will be raised, but nothing
84216>>>>>>>/// will be returned.
84216>>>>>>>///
84216>>>>>>>/// @Assumptions There exists a custom translation for the specified character
84216>>>>>>>/// @Status      Public
84216>>>>>>>/// @Drivers     All
84216>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84216>>>>>>>/// @See
84216>>>>>>>///
84216>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
84216>>>>>>>/// @Param character            Numbered position (0-255) of the character
84216>>>>>>>/// @Param value1                       Variable to hold the OEM value
84216>>>>>>>/// @Param value2                       Variable to hold the ANSI value
84216>>>>>>>
84216>>>>>>>//=============================================================================
84216>>>>>>>/// @Name        SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING
84216>>>>>>>/// @Description This command toggles off and on the automatic numeric
84216>>>>>>>/// data type remapping built into SQLFlex. When adding or creating
84216>>>>>>>/// smaller numeric columns during a restructure, SQLFlex will change
84216>>>>>>>/// the type to a more specific data type i.e. smallint or tinyint since
84216>>>>>>>/// they are handled more efficiently by the server. Sending false to this
84216>>>>>>>/// command will force SQl to keep the column as a numeric field, preserving
84216>>>>>>>/// the length and precision. Passing true will leave the remapping up to the
84216>>>>>>>/// driver.
84216>>>>>>>///
84216>>>>>>>/// @Assumptions
84216>>>>>>>/// @Status      Public
84216>>>>>>>/// @Drivers     SQLFlex
84216>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84216>>>>>>>/// @See
84216>>>>>>>///
84216>>>>>>>/// @Syntax SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to {variable}
84216>>>>>>>/// @Param variable                     Boolean variable enabling or disabling remapping
84216>>>>>>>///
84216>>>>>>>/// @Example
84216>>>>>>>/// Structure_Start hFile
84216>>>>>>>///
84216>>>>>>>///     Create_Field hFile
84216>>>>>>>///
84216>>>>>>>///     SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to False
84216>>>>>>>///
84216>>>>>>>///     Set_Attribute DF_FIELD_NAME   of hFile iColumn to "Transaction_Count"
84216>>>>>>>///     Set_Attribute DF_FIELD_TYPE   of hFile iColumn to DF_BCD
84216>>>>>>>///     Set_Attribute DF_FIELD_LENGTH of hFile iColumn to 1
84216>>>>>>>///
84216>>>>>>>/// Structure_End hFile
84216>>>>>>>
84216>>>>>>>//=============================================================================
84216>>>>>>>/// @Name        SET_FORCE_DATE_FORMAT_INIT
84216>>>>>>>/// @Description At times, a stored procedure, function or trigger may
84216>>>>>>>/// alter the default format for dates. This could cause problems because,
84216>>>>>>>/// for example, if a trigger on a table does this, then every time a save
84216>>>>>>>/// takes place on that table, the format for dates will be changed. By
84216>>>>>>>/// sending true to this command, the date formats will reset to their
84216>>>>>>>/// default format. Note that this is essentially the same thing as running
84216>>>>>>>/// the SQL statement: "ALTER SESSION SET NLS_DATE_FORMAT='MM/DD/YYYY'", so
84216>>>>>>>/// in most situations, that should be used instead of this command.
84216>>>>>>>///
84216>>>>>>>/// @Assumptions
84216>>>>>>>/// @Status      Deprecated
84216>>>>>>>/// @Drivers     ORAFlex
84216>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84216>>>>>>>/// @See
84216>>>>>>>///
84216>>>>>>>/// @Syntax SET_FORCE_DATE_FORMAT_INIT to {variable}
84216>>>>>>>/// @Param variable             Boolean variable enabling or disabling format reset
84216>>>>>>>
84216>>>>>>>//=============================================================================
84216>>>>>>>/// @Name        SET_STATIC_TABLE_OPTIMIZATION
84216>>>>>>>/// @Description At this time, this command no longer serves any function.
84216>>>>>>>///
84216>>>>>>>/// @Assumptions
84216>>>>>>>/// @Status      Deprecated
84216>>>>>>>/// @Drivers     SQLFlex
84216>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84216>>>>>>>/// @See
84216>>>>>>>///
84216>>>>>>>/// @Syntax SET_STATIC_TABLE_OPTIMIZATION to {ENABLED/DISABLED}
84216>>>>>>>
84216>>>>>>>//=============================================================================
84216>>>>>>>/// @Name        GET_MAX_OBJECT_NAME_LENGTH
84216>>>>>>>/// @Description This command returns the maximum length allowed for object
84216>>>>>>>/// names in the SQl backend. This includes table names, column names,
84216>>>>>>>/// database names etc. The maximum length in put into the specified variable.
84216>>>>>>>///
84216>>>>>>>/// @Assumptions
84216>>>>>>>/// @Status      Public
84216>>>>>>>/// @Drivers     All
84216>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84216>>>>>>>/// @See
84216>>>>>>>///
84216>>>>>>>/// @Syntax GET_MAX_OBJECT_NAME_LENGTH to {variable}
84216>>>>>>>/// @Param variable                     Variable to hold the maximum length
84216>>>>>>>///
84216>>>>>>>/// @Example
84216>>>>>>>/// GET_MAX_OBJECT_NAME_LENGTH to iMaxLength
84216>>>>>>>
84216>>>>>>>//=============================================================================
84216>>>>>>>/// @Name        SET_SQL_LOCK_TIMEOUT
84216>>>>>>>/// @Description This command is used to set the number of milliseconds
84216>>>>>>>/// an SQL statement waits for a database lock to be released before timing
84216>>>>>>>/// out. Locks are used with transactions to maintain atomicity. If a lock is
84216>>>>>>>/// not released before the timeout, then the statement will fail and an error
84216>>>>>>>/// will be raised. By default, the timeout is set to -1, indicating that
84216>>>>>>>/// statements will wait indefinitely before timing out.
84216>>>>>>>///
84216>>>>>>>/// @Assumptions
84216>>>>>>>/// @Status      Public
84216>>>>>>>/// @Drivers     SQLFlex
84216>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84216>>>>>>>/// @See                 GET_SQL_LOCK_TIMEOUT
84216>>>>>>>///
84216>>>>>>>/// @Syntax SET_SQL_LOCAL_TIMEOUT of {server} to {variable}
84216>>>>>>>/// @Param server                       Name of the server
84216>>>>>>>/// @Param variable                     Number of milliseconds to wait until timeout
84216>>>>>>>///
84216>>>>>>>/// @Example
84216>>>>>>>/// SET_SQL_LOCK_TIMEOUT of "localhost" to 6000
84216>>>>>>>
84216>>>>>>>//=============================================================================
84216>>>>>>>/// @Name        GET_SQL_LOCK_TIMEOUT
84216>>>>>>>/// @Description This command returns the number of milliseconds an SQL
84216>>>>>>>/// statement will wait for a database lock to be released. If the lock
84216>>>>>>>/// is not released before the timeout, then the statement will fail and
84216>>>>>>>/// an error will be raised. Note that the default value is -1, indicating
84216>>>>>>>/// that the statement will wait indefinitely.
84216>>>>>>>///
84216>>>>>>>/// @Assumptions
84216>>>>>>>/// @Status      Public
84216>>>>>>>/// @Drivers     SQLFlex
84216>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84216>>>>>>>/// @See                 SET_SQL_LOCK_TIMEOUT
84216>>>>>>>///
84216>>>>>>>/// @Syntax GET_SQL_LOCAL_TIMEOUT of {server} to {variable}
84216>>>>>>>/// @Param server                       Name of the server
84216>>>>>>>/// @Param variable                     Variable to hold the number of milliseconds
84216>>>>>>>///
84216>>>>>>>/// @Example
84216>>>>>>>/// GET_SQL_LOCK_TIMEOUT of "localhost" to iTimeout
84216>>>>>>>
84216>>>>>>>//=============================================================================
84216>>>>>>>/// @Name        DO_GET_SQLSERVER_PARAMETERS
84216>>>>>>>/// @Description Retrieves stored procedure parameter values.
84216>>>>>>>///
84216>>>>>>>/// @Assumptions
84216>>>>>>>/// @Status      Internal
84216>>>>>>>/// @Drivers     All
84216>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
84216>>>>>>>/// @See
84216>>>>>>>
84216>>>>>>>Function MertechInc_DO_GET_SQLSERVER_PARAMETERS Global Integer iParameter Returns String
84218>>>>>>>    Local String sValue
84218>>>>>>>
84218>>>>>>>    Get MertechInc_Pre_Size_String 0 to sValue //Need to check if Call_Driver needs pre sized strings. Until then assume it does
84219>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 24 CALLBACK 0 PASSING sValue MertechInc_Blank iParameter RESULT MertechInc_iRet
84224>>>>>>>
84224>>>>>>>    Function_Return sValue
84225>>>>>>>End_Function
84226>>>>>>>
84226>>>>>>>//=============================================================================
84226>>>>>>>/// @Name        DO_BIND_SQLSERVER_PARAMETERS
84226>>>>>>>/// @Description Binds parameters for stored procedure call.
84226>>>>>>>///
84226>>>>>>>/// @Assumptions
84226>>>>>>>/// @Status      Internal
84226>>>>>>>/// @Drivers     All
84226>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
84226>>>>>>>/// @See
84226>>>>>>>
84226>>>>>>>Procedure MertechInc_DO_BIND_SQLSERVER_PARAMETERS Global String sDirection String sParameter Integer iSize
84228>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sDirection sParameter iSize RESULT MertechInc_iRet
84233>>>>>>>End_Procedure
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        DO_CHECK_BINDING
84234>>>>>>>/// @Description Sets MertechInc_bThereIsBinding True if any of the
84234>>>>>>>/// parameters is the keyword BINDING.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Internal
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
84234>>>>>>>/// @See
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        DO_FETCH_FIRST_ROW
84234>>>>>>>/// @Description Recursive - drops first parameter until the first parameter
84234>>>>>>>/// is BINDING and then calls SQL_FETCH_NEXT_ROW passing remaining parameters.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Internal
84234>>>>>>>/// @Drivers     SQLFlex
84234>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
84234>>>>>>>/// @See
84234>>>>>>>
84234>>>>>>>
84234>>>>>>>
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        CALL_STORED_PROCEDURE
84234>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
84234>>>>>>>/// backend. To successfully call a procedure with this command, a string
84234>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
84234>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
84234>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
84234>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
84234>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
84234>>>>>>>/// is set to true.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
84234>>>>>>>/// @See
84234>>>>>>>///
84234>>>>>>>/// @Syntax CALL_STORED_PROCEDURE {procedure} Passing {variable}
84234>>>>>>>/// @Param procedure            Full name of the procedure
84234>>>>>>>/// @Param variable                     Argument being passed (can be multiple)
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        CALL_SQLSERVER_PROCEDURE
84234>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
84234>>>>>>>/// backend. To successfully call a procedure with this command, a string
84234>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
84234>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
84234>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
84234>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN, SQL_FETCH_NEXT_ROW or
84234>>>>>>>/// GET_PROCEDURE_RETURN can be used to get the value(s). If an error is found
84234>>>>>>>/// then the indicator "Err" is set to true.
84234>>>>>>>///
84234>>>>>>>/// @Status      Deprecated
84234>>>>>>>/// @Drivers     SQLFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See                 CALL_STORED_PROCEDURE
84234>>>>>>>///
84234>>>>>>>/// @Syntax CALL_SQLSERVER_PROCEDURE {procedure} Passing {variable}
84234>>>>>>>/// @Param procedure            Full name of the procedure
84234>>>>>>>/// @Param variable                     Argument to be passed (can be multiple)
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// CALL_SQLSERVER_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        END_CALL_PROCEDURE
84234>>>>>>>/// @Description This command is used to close any open cursors created
84234>>>>>>>/// by the respective stored procedure. Cursors are used in MSSQL to make
84234>>>>>>>/// the results from one procedure temporarily available to other procedures
84234>>>>>>>/// or triggers. To avoid causing unwanted results, it is good practice to
84234>>>>>>>/// use this command once a procedure call is completed.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     SQLFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See                 CALL_STORED_PROCEDURE
84234>>>>>>>///
84234>>>>>>>/// @Syntax END_CALL_PROCEDURE
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_spaceused" Passing "Customer"
84234>>>>>>>/// GET_PROCEDURE_RETURN to sValue
84234>>>>>>>/// END_CALL_PROCEDURE
84234>>>>>>>/// Showln sValue
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        GET_PROCEDURE_RETURN
84234>>>>>>>/// @Description This command is used to get a returned value from a stored
84234>>>>>>>/// procedure using MSSQL. Note that this command can only handle one
84234>>>>>>>/// returned value and must be used after the procedure has already been
84234>>>>>>>/// built and executed.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     SQLFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See
84234>>>>>>>///
84234>>>>>>>/// @Syntax GET_PROCEDURE_RETURN to {variable}
84234>>>>>>>/// @Param variable             Variable to hold the returned value
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_spaceused" NUMPAR 1
84234>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to "Customer" IN
84234>>>>>>>/// SQL_PROCEDURE_EXECUTE
84234>>>>>>>/// GET_PROCEDURE_RETURN to sSpaceUsed
84234>>>>>>>/// Showln sSpaceUsed
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SET_MIRROR_SERVER
84234>>>>>>>/// @Description This command is used to programmatically set the mirror
84234>>>>>>>/// server for the database. This is to be used along with SQl server
84234>>>>>>>/// failover mirroring. Note that this simply sets the server and database
84234>>>>>>>/// to be used for mirroring. All set up for the servers must already be
84234>>>>>>>/// working properly through SQL Server.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions A compatible version of SQL Server is being used
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     SQLFlex v9.2 and above
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See                 GET_MIRROR_SERVER
84234>>>>>>>///
84234>>>>>>>/// @Syntax SET_MIRROR_SERVER to {server} {database}
84234>>>>>>>/// @Param server                       The name of the mirror server
84234>>>>>>>/// @Param database                     The database acting as a mirror
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// SET_MIRROR_SERVER to "(localdb)\v11.0" "MirrorDB"
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        GET_MIRROR_SERVER
84234>>>>>>>/// @Description This command is used to get the name of the server
84234>>>>>>>/// and database being used for failover mirroring. Mirroring must
84234>>>>>>>/// be properly set up in SQL Server for this command to return the
84234>>>>>>>/// correct values.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     SQLFlex v9.2 and above
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See                 SET_MIRROR_SERVER
84234>>>>>>>///
84234>>>>>>>/// @Syntax GET_MIRROR_SERVER to {server} {database}
84234>>>>>>>/// @Param server                       Variable to hold the name of the mirrored server
84234>>>>>>>/// @Param database                     Variable to hold the name of the mirrored database
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// GET_MIRROR_SERVER to sServer sDatabase
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        COPY_DATA
84234>>>>>>>/// @Description This command is used to copy data from a DAT file to an
84234>>>>>>>/// SQL table. Both the source and the destination files are opened, the
84234>>>>>>>/// data is copied and then the files are closed. This is usually used
84234>>>>>>>/// along with CREATE_TABLE_FROM_DAT_FILE, which creates the structure
84234>>>>>>>/// and then this command will insert the data. If needed, this command
84234>>>>>>>/// can also work backwards, copying data from an SQL table to a DAT file.
84234>>>>>>>/// This is an alternative to using the Flex2SQL Migration Tool and can
84234>>>>>>>/// improve performance when used in the right situations. Note that in
84234>>>>>>>/// order for this process to work properly the table being copied can not
84234>>>>>>>/// be opened. Because of this, a manual login must take place, using
84234>>>>>>>/// something like LOGIN_SQLFLEX or LOGIN. Since this only copies the data,
84234>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE can be used to create the table structure.
84234>>>>>>>///
84234>>>>>>>/// Because COPY_DATA requires no user interaction, an optional callback
84234>>>>>>>/// function can be passed for tracing purposes. By passing the constant
84234>>>>>>>/// "CALLBACK" followed by the object name, a function can be used to set
84234>>>>>>>/// up messages for tracking and error handling. Below is more information
84234>>>>>>>/// regarding this callback object.
84234>>>>>>>///
84234>>>>>>>/// This function should follow this pattern:
84234>>>>>>>///
84234>>>>>>>/// Function Callback String sText Integer iStatusID Returns Integer
84234>>>>>>>///
84234>>>>>>>/// sText - Message corresponding to the current status ID
84234>>>>>>>///
84234>>>>>>>/// iStatusID - Integer value mapping to the current status constant:
84234>>>>>>>///                     DF_MESSAGE_PROGRESS_TITLE    Sent when SQLFlex starts the
84234>>>>>>>///                                                                              process
84234>>>>>>>///
84234>>>>>>>///             DF_MESSAGE_HEADING_1         Sent when SQLFlex is about to
84234>>>>>>>///                                                                              copy the source data
84234>>>>>>>///
84234>>>>>>>///             DF_MESSAGE_ERROR             Sent when an error occurs
84234>>>>>>>///
84234>>>>>>>///             DF_MESSAGE_PROGRESS_STATUS   Sent each time an additional
84234>>>>>>>///                                                                              10% of the data is copied
84234>>>>>>>///
84234>>>>>>>/// NOTE: Returning false each time the function is called will continue
84234>>>>>>>/// copying process. Returning true will end it.
84234>>>>>>>///
84234>>>>>>>/// Another optional parameter that can be used is a constrain on the data
84234>>>>>>>/// being copied. This is done by passing the constant "CONSTRAIN" followed
84234>>>>>>>/// by an SQL constrain statement. When passing a constrain but not a callback
84234>>>>>>>/// object, pass 0 for the callback before passsing the constrain.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84234>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE CONVERT_DAT_FILE
84234>>>>>>>///
84234>>>>>>>/// @Syntax COPY_DATA {from} to {destination} [CALLBACK {function}] [CONSTRAIN {variable}]
84234>>>>>>>/// @Param from                         Table to copy from.
84234>>>>>>>/// @Param destination          Table to copy to.
84234>>>>>>>/// @Param function             Object with callback function (optional)
84234>>>>>>>/// @Param variable                     SQL contraint to use when copying (optional)
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// Object CallBackObj is a Array
84234>>>>>>>///     Function Callback String sText Integer iLogicalID Returns Integer
84234>>>>>>>///         If (iLogicalID = DF_MESSAGE_ERROR) Begin
84234>>>>>>>///             Showln "Error"
84234>>>>>>>///                             Showln sText
84234>>>>>>>///                             Function_Return True
84234>>>>>>>///         End
84234>>>>>>>///
84234>>>>>>>///         Else Showln sText
84234>>>>>>>///
84234>>>>>>>///                     Function_Return False
84234>>>>>>>///
84234>>>>>>>///     End_Function
84234>>>>>>>/// End_Object
84234>>>>>>>///
84234>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
84234>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
84234>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        ORAFlex_REVISION
84234>>>>>>>/// @Description This command will put the current version (decimals included)
84234>>>>>>>/// of the Oracle driver associated with the current workspace into the specified
84234>>>>>>>/// variable.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Deprecated
84234>>>>>>>/// @Drivers     ORAFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84234>>>>>>>/// @See                 GET_DRIVER_REVISION
84234>>>>>>>///
84234>>>>>>>/// @Syntax ORAFlex_REVISION {variable}
84234>>>>>>>/// @Param variable                     String variable to hold the returned version
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// ORAFlex_REVISION sVersion
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        KEEP_FILES_OPEN
84234>>>>>>>/// @Description Keep the files, currently in use, open after the server is
84234>>>>>>>/// logged out. Sometimes an application needs to login to the same server
84234>>>>>>>/// with a different user id. When logging out, however, the drivers
84234>>>>>>>/// automatically close all opened files. The overhead of opening these files
84234>>>>>>>/// should be avoided if the user will work with the same files that were
84234>>>>>>>/// closed. KEEP_FILES_OPEN keeps all files opened after a user logs out
84234>>>>>>>/// from the server.
84234>>>>>>>///
84234>>>>>>>/// @Status      Deprecated
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>///
84234>>>>>>>/// @Syntax KEEP_FILES_OPEN of {server}
84234>>>>>>>/// @Param server               Name of the server
84234>>>>>>>
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SET_MAX_OPEN_CURSORS
84234>>>>>>>/// @Description Set the maximum number of cursors you want the driver to use.
84234>>>>>>>///
84234>>>>>>>/// The driver will recycle the least used cursors if this limit is hit.
84234>>>>>>>/// The trade off is between increased resources on the server and
84234>>>>>>>/// re-preparing of cursors.
84234>>>>>>>///
84234>>>>>>>/// For a program that keeps 40+ files opened at the same time, 255 is a good
84234>>>>>>>/// number for the open cursors parameter. For programs that open less than
84234>>>>>>>/// 40 files, any number between 100-255 is sufficient. These numbers can be
84234>>>>>>>/// changed based on available server resources.
84234>>>>>>>///
84234>>>>>>>/// On Oracle this value should not exceed the value of open_cursors in
84234>>>>>>>/// init.ora
84234>>>>>>>///
84234>>>>>>>/// Note: Only change this setting if you are having performance issues
84234>>>>>>>/// and the server is indicating you are using up too many cursors or too
84234>>>>>>>/// much memory. GET_OPENED_CURSORS can be used to check the number of
84234>>>>>>>/// cursors the server has opened. If this number is hitting the limit,
84234>>>>>>>/// it is worth increasing the number, as long as the server has enough
84234>>>>>>>/// resources.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84234>>>>>>>/// @See         GET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
84234>>>>>>>///
84234>>>>>>>/// @Syntax SET_MAX_OPEN_CURSORS of {server} to {variable}
84234>>>>>>>/// @Param server                       The name of the server
84234>>>>>>>/// @Param variable                     Maximum number of cursors
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        GET_MAX_OPEN_CURSORS
84234>>>>>>>/// @Description This command will return the maximum number of open
84234>>>>>>>/// cursors allowed by the server.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84234>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
84234>>>>>>>///
84234>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
84234>>>>>>>/// @Param server                       Name of the server
84234>>>>>>>/// @Param variable                     Variable to hold the maximum number of open cursors
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        GET_OPENED_CURSORS
84234>>>>>>>/// @Description This command returns the number of cursors currently
84234>>>>>>>/// open on the server.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84234>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_MAX_OPEN_CURSORS
84234>>>>>>>///
84234>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
84234>>>>>>>/// @Param server                       Name of the server
84234>>>>>>>/// @Param variable                     Variable to hold the number of cursors currently open
84234>>>>>>>///
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        ACTIVATE_TIME_STAMP
84234>>>>>>>/// @Description This command will specify whether or not to show the time
84234>>>>>>>/// portion of a date field. When set to ON, the time portion will be
84234>>>>>>>/// included, OFF will just show the date. This is the same as changing
84234>>>>>>>/// the date format with "ALTER SESSION SET nls_timestamp_format". Note that
84234>>>>>>>/// this will only take effect if the date is put into a string variable.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Deprecated
84234>>>>>>>/// @Drivers     OraFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84234>>>>>>>/// @See
84234>>>>>>>///
84234>>>>>>>/// @Syntax ACTIVATE_TIME_STAMP of {server} to {ON/OFF}
84234>>>>>>>/// @Param server                       Name of the server
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// ACTIVATE_TIME_STAMP of "localhost/orcl.localdomain" to OFF
84234>>>>>>>///
84234>>>>>>>/// SQL_SET_STMT to 'SELECT * from USER."Customer" '
84234>>>>>>>/// SQL_PREPARE_STMT
84234>>>>>>>/// SQL_EXECUTE_STMT
84234>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
84234>>>>>>>/// If (Found) Begin
84234>>>>>>>///     Showln sDOB
84234>>>>>>>/// End
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        CALL_ORACLE_STORED_FUNCTION
84234>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
84234>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
84234>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
84234>>>>>>>/// builds and executes the function by setting the full function name, the
84234>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
84234>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
84234>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
84234>>>>>>>/// values.
84234>>>>>>>///
84234>>>>>>>/// @Status      Deprecated
84234>>>>>>>/// @Drivers     ORAFLex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See                 CALL_STORED_FUNCTION
84234>>>>>>>///
84234>>>>>>>/// @Syntax CALL_ORACLE_STORED_FUNCTION {function} Returns {variable} Passing {argument}
84234>>>>>>>/// @Param function                     Full name of the function
84234>>>>>>>/// @Param variable                     Variable to hold the returned value
84234>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// CALL_ORACLE_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
84234>>>>>>>/// Showln sStatus
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        CALL_PGSQL_STORED_FUNCTION
84234>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
84234>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
84234>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
84234>>>>>>>/// builds and executes the function by setting the full function name, the
84234>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
84234>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
84234>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
84234>>>>>>>/// values.
84234>>>>>>>///
84234>>>>>>>/// @Status      Deprecated
84234>>>>>>>/// @Drivers     PGFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See                 CALL_STORED_FUNCTION
84234>>>>>>>///
84234>>>>>>>/// @Syntax CALL_PGSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
84234>>>>>>>/// @Param function                     Full name of the function
84234>>>>>>>/// @Param variable                     Variable to hold the returned value
84234>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// CALL_PGSQL_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
84234>>>>>>>/// Showln sStatus
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        MERTECH_LANGUAGE_SUPPORT
84234>>>>>>>/// @Description Sets the support language for the driver.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Internal
84234>>>>>>>/// @Drivers     ORAFLex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See
84234>>>>>>>///
84234>>>>>>>/// @Syntax MERTECH_LANGUAGE_SUPPORT of {server} to {language}
84234>>>>>>>/// @Param server               The name of the server being used
84234>>>>>>>/// @Param language             The language to set support to
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SQL_SAVE_BUFFER_BEGIN
84234>>>>>>>/// @Description This command is used to initialize a SAVE_BUFFER
84234>>>>>>>/// statement. Doing this will allow a specified set of records to be
84234>>>>>>>/// stored in the buffer before a save takes place. Once the buffer is
84234>>>>>>>/// filled, it will be saved automatically. This set of commands can be
84234>>>>>>>/// used to efficiently save a large number of records. Once the buffer
84234>>>>>>>/// is full, the save occurs automatically and the buffer will be emptied
84234>>>>>>>/// out. It is good practice to use this method inside of a transaction to
84234>>>>>>>/// maintain atomicity. Note that these commands should not be used in
84234>>>>>>>/// conjuction with finds.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84234>>>>>>>/// @See         SQL_SAVE_BUFFER_END SQL_SAVE_BUFFER
84234>>>>>>>///
84234>>>>>>>/// @Syntax SQL_SAVE_BUFFER_BEGIN of {FileName} to {variable}
84234>>>>>>>/// @Param FileName                     Name of the file
84234>>>>>>>/// @Param variable                     Number of records to store in the buffer
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// Open Customer
84234>>>>>>>///
84234>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
84234>>>>>>>///
84234>>>>>>>/// For i from 0 to 1000
84234>>>>>>>///     Move i to Transactions.ID
84234>>>>>>>///     SQL_SAVE_BUFFER of Transactions
84234>>>>>>>/// Loop
84234>>>>>>>///
84234>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SQL_SAVE_BUFFER
84234>>>>>>>/// @Description This command is used to send a record to the "Save
84234>>>>>>>/// Record" buffer. It must be used along with SQL_SAVE_BUFFER_BEGIN
84234>>>>>>>/// and SQL_SAVE_BUFFER_END. SQL_SAVE_BUFFER_BEGIN sets the number of
84234>>>>>>>/// records to store in the buffer before a save is done on all the records
84234>>>>>>>/// at once. Each time a record is created, this command should be called
84234>>>>>>>/// to insert it into the buffer. Using this set of commands can be useful
84234>>>>>>>/// to efficiently save a large number of records. Once the buffer is full,
84234>>>>>>>/// the save occurs automatically and the buffer will be emptied out. It is
84234>>>>>>>/// good practice to use this method inside of a transaction to maintain
84234>>>>>>>/// atomicity.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84234>>>>>>>/// @See                 SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER_END
84234>>>>>>>///
84234>>>>>>>/// @Syntax SQL_SAVE_BUFFER of {FileName}
84234>>>>>>>/// @Param FileName                     Name of the file
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// Open Customer
84234>>>>>>>///
84234>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
84234>>>>>>>///
84234>>>>>>>/// For i from 0 to 1000
84234>>>>>>>///     Move i to Transactions.ID
84234>>>>>>>///     SQL_SAVE_BUFFER of Transactions
84234>>>>>>>/// Loop
84234>>>>>>>///
84234>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SQL_SAVE_BUFFER_END
84234>>>>>>>/// @Description This command indicates the end of the extended record
84234>>>>>>>/// buffer and forces a save of any data currently in the buffer.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
84234>>>>>>>/// @See         SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER
84234>>>>>>>///
84234>>>>>>>/// @Syntax SQL_SAVE_BUFFER_END of {FileName}
84234>>>>>>>/// @Param FileName                     Name of the file
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// Open Customer
84234>>>>>>>///
84234>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
84234>>>>>>>///
84234>>>>>>>/// For i from 0 to 1000
84234>>>>>>>///     Move i to Transactions.ID
84234>>>>>>>///     SQL_SAVE_BUFFER of Transactions
84234>>>>>>>/// Loop
84234>>>>>>>///
84234>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SQL_SAVE_SET_ATTRIBUTES
84234>>>>>>>/// @Description Unknown - Not in help - Not call by any other macros
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Internal
84234>>>>>>>/// @Drivers     SQLFlex
84234>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
84234>>>>>>>/// @See
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        ENABLE_TRACE_ON
84234>>>>>>>/// @Description This command enables driver level tracing to the
84234>>>>>>>/// specified file. Enabling trace on an application and using it
84234>>>>>>>/// in conjunction with SQL_TEXT_MESSAGE is a good way to study
84234>>>>>>>/// particular problems you encounter in the driver. SQL_TEXT_MESSAGE
84234>>>>>>>/// allows you to insert sections of your code into the trace file.
84234>>>>>>>/// This command can also set the trace to three different levels,
84234>>>>>>>/// allowing different amounts of information to be logged. Note that
84234>>>>>>>/// trace files can become very large so it is good practice to only
84234>>>>>>>/// turn them on when specifically needed.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See                 DISABLE_TRACE_ON SQL_TEXT_MESSAGE
84234>>>>>>>///
84234>>>>>>>/// @Syntax ENABLE_TRACE_ON to {fileName} Debug_Level [{constant}]
84234>>>>>>>/// @Param fileName                     The path of the file to send the trace to
84234>>>>>>>/// @Param constant             DETAIL_LEVEL1, DETAIL_LEVEL2, DETAIL_LEVEL3 (optional)
84234>>>>>>>///
84234>>>>>>>/// @Example ENABLE_TRACE_ON TO "C:\Temp\trace_file.txt" Debug_Level DETAIL_LEVEL3
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        DISABLE_TRACE_ON
84234>>>>>>>/// @Description This command disables the current trace taking
84234>>>>>>>/// place on a driver.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84234>>>>>>>/// @See ENABLE_TRACE_ON SQL_TEXT_MESSAGE
84234>>>>>>>///
84234>>>>>>>/// @Syntax DISABLE_TRACE_ON
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        CREATE_TABLE_FROM_DAT_FILE
84234>>>>>>>/// @Description This command is used to create a SQL table from a .DAT
84234>>>>>>>/// file. The table being copied must be not be opened in order for this
84234>>>>>>>/// command to work properly. This is the programmatic equivalent to
84234>>>>>>>/// using the Flex2SQL Migration Tool. Optional restructuring options
84234>>>>>>>/// can be specified here (see below) as well as an alternative table
84234>>>>>>>/// name than the physical name of the .DAT file. Note that this only
84234>>>>>>>/// creates the  table structure, no data will be copied here. To copy
84234>>>>>>>/// the data, use COPY_DATA after the table has been created.
84234>>>>>>>///
84234>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
84234>>>>>>>///
84234>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
84234>>>>>>>///
84234>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84234>>>>>>>/// @See                 COPY_DATA CONVERT_DAT_FILE
84234>>>>>>>///
84234>>>>>>>/// @Syntax CREATE_TABLE_FROM_DAT_FILE {FileNumber} [{options} {table}]
84234>>>>>>>/// @Param FileNumber           Number of the file
84234>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
84234>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
84234>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
84234>>>>>>>/// @Param table            name of table to use instead of physical name (optional)
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
84234>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
84234>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        CONVERT_DAT_FILE
84234>>>>>>>/// @Description This command is the programmatic equivalent to the
84234>>>>>>>/// Flex2SQL Migration Tool. With this command, a SQL table can be
84234>>>>>>>/// created from a .DAT table. This combines the COPY_DATA and
84234>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE, creating the table structure and
84234>>>>>>>/// copying all the data into the new table with one command. The
84234>>>>>>>/// table being converted cannot be opened and so a manual login is
84234>>>>>>>/// needed. Note that to specify the database to copy the table to,
84234>>>>>>>/// use SET_DATABASE_NAME. Below is a list of the optional restructure
84234>>>>>>>/// options to use when creating the table.
84234>>>>>>>///
84234>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
84234>>>>>>>///
84234>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
84234>>>>>>>///
84234>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84234>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE COPY_DATA
84234>>>>>>>///
84234>>>>>>>/// @Syntax CONVERT_DAT_FILE {FileNumber} [{options} {table}]
84234>>>>>>>/// @Param FileNumber           Number of the file
84234>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
84234>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
84234>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
84234>>>>>>>/// @Param table            Name of table to use instead of physical name (optional)
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
84234>>>>>>>/// CONVERT_DAT_FILE Customer.File_Number DF_STRUCTEND_OPT_FORCE_NOT_NULL "Customer"
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SET_DEFAULT_FILE_CASING
84234>>>>>>>/// @Description This command is used to set the file casing standard when
84234>>>>>>>/// creating or restructuring tables. By default, all table and column names
84234>>>>>>>/// are created using the specified casing. Passing FILE_CASING_UPPER or
84234>>>>>>>/// FILE_CASING_LOWER will allow the names to be saved in uppercase or
84234>>>>>>>/// lowercase respectively. This can be useful for backwards compatibility
84234>>>>>>>/// where casing was important. Note that the casing standard for a file can
84234>>>>>>>/// also be changed through mertech.ini. Below is a description of the constants
84234>>>>>>>/// that can be passed to this command.
84234>>>>>>>///
84234>>>>>>>/// FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
84234>>>>>>>/// FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
84234>>>>>>>/// FILE_CASING_KEEP (default) : All created or edited object names will maintain their inputed casing.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84234>>>>>>>/// @See                 GET_DEFAULT_FILE_CASING
84234>>>>>>>///
84234>>>>>>>/// @Syntax SET_DEFAULT_FILE_CASING to {constant}
84234>>>>>>>/// @Param constant                     FILE_CASING_UPPER, FILE_CASING_LOWER, FILE_CASING_KEEP
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// SET_DEFAULT_FILE_CASING to FILE_CASING_UPPER
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        GET_DEFAULT_FILE_CASING
84234>>>>>>>/// @Description This command returns the file casing standard used
84234>>>>>>>/// when creating or restructuring tables. Note that an integer is returned,
84234>>>>>>>/// mapping to a casing method. Below are the meanings of the possible
84234>>>>>>>/// returned integers.
84234>>>>>>>///
84234>>>>>>>/// 0 - FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
84234>>>>>>>/// 1 - FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
84234>>>>>>>/// 2 - FILE_CASING_KEEP : All created or edited object names will maintain their inputed casing.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84234>>>>>>>/// @See                 SET_DEFAULT_FILE_CASING
84234>>>>>>>///
84234>>>>>>>/// @Syntax GET_DEFAULT_FILE_CASING to {variable}
84234>>>>>>>/// @Param variable                     Variable to hold the returned casing
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// GET_DEFAULT_FILE_CASING TO iCasing
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SET_DEFAULT_TABLESPACE
84234>>>>>>>/// @Description This command sets the default table space to use when
84234>>>>>>>/// creating tables through Dataflex. A tablespace is a container of
84234>>>>>>>/// segments (objects that have an allotted amount of space), i.e. tables
84234>>>>>>>/// and indexes.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     ORAFlex, PgFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84234>>>>>>>/// @See                 GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
84234>>>>>>>///
84234>>>>>>>/// @Syntax SET_DEFAULT_TABLESPACE to {variable}
84234>>>>>>>/// @Param variable                     Name of the default table space
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// SET_DEFAULT_TABLESPACE to "Users"
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        GET_DEFAULT_TABLESPACE
84234>>>>>>>/// @Description This command returns the default table space name for
84234>>>>>>>/// the current database.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     ORAFlex, PgFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84234>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
84234>>>>>>>///
84234>>>>>>>/// @Syntax GET_DEFAULT_TABLESPACE to {variable}
84234>>>>>>>/// @Param variable                     Variable to hold the default table space name.
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// GET_DEFAULT_TABLESPACE to sTableSpace
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        SET_DEFAULT_INDEX_TABLESPACE
84234>>>>>>>/// @Description This command sets the default table space for indexes
84234>>>>>>>/// when creating tables through the DataFlex API. A tablespace is a
84234>>>>>>>/// container of segments (objects that have an allotted amount of space),
84234>>>>>>>/// i.e. tables and indexes.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     ORAFlex, PgFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-09-2013 by Aaron Gulack
84234>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
84234>>>>>>>///
84234>>>>>>>/// @Syntax SET_DEFAULT_INDEX_TABLESPACE to {variable}
84234>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// SET_DEFAULT_INDEX_TABLESPACE to "Users"
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        GET_DEFAULT_INDEX_TABLESPACE
84234>>>>>>>/// @Description This command returns the default table space name for
84234>>>>>>>/// indexes in the current database.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     ORAFlex, PgFlex
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84234>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE
84234>>>>>>>///
84234>>>>>>>/// @Syntax GET_DEFAULT_INDEX_TABLESPACE to {variable}
84234>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// GET_DEFAULT_INDEX_TABLESPACE to sTableSpace
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        ENABLE_SCRIPTING
84234>>>>>>>/// @Description Scripting is used for testing and preparation. This
84234>>>>>>>/// command allows structural changes to be compiled and tested without
84234>>>>>>>/// actually making any of the changes. Any table restructuring done
84234>>>>>>>/// between this command and DISABLE_SCRIPTING will not actually be
84234>>>>>>>/// committed but will instead create a mock INT file. The script and
84234>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84234>>>>>>>/// @See                 DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
84234>>>>>>>///
84234>>>>>>>/// @Syntax ENABLE_SCRIPTING
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// ENABLE_SCRIPTING
84234>>>>>>>///     //Table restructuring would go here
84234>>>>>>>/// DISABLE_SCRIPTING
84234>>>>>>>///
84234>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
84234>>>>>>>/// Showln sChunk
84234>>>>>>>
84234>>>>>>>//=============================================================================
84234>>>>>>>/// @Name        DISABLE_SCRIPTING
84234>>>>>>>/// @Description This command ends any scripting started by ENABLE_SCRIPTING.
84234>>>>>>>/// The mock INT file and script can then be retrieved and examined.
84234>>>>>>>///
84234>>>>>>>/// @Assumptions
84234>>>>>>>/// @Status      Public
84234>>>>>>>/// @Drivers     All
84234>>>>>>>/// @VersionNote Last Revised: 2010-12-13 By Marcelo Nachbar
84234>>>>>>>/// @See                 ENABLE_SCRIPTING  GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
84234>>>>>>>///
84234>>>>>>>/// @Syntax DISABLE_SCRIPTING
84234>>>>>>>///
84234>>>>>>>/// @Example
84234>>>>>>>/// ENABLE_SCRIPTING
84234>>>>>>>///     //Table restructuring would go here
84234>>>>>>>/// DISABLE_SCRIPTING
84234>>>>>>>///
84234>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
84234>>>>>>>/// Showln sChunk
84234>>>>>>>
84234>>>>>>>Function MertechInc_GET_RESTRUCTURE_SCRIPT Global Integer iLong Integer iOffset Returns String
84236>>>>>>>    Local Integer iChuck_Size
84236>>>>>>>    Local String sChunk
84236>>>>>>>
84236>>>>>>>    //Get current Chuck size and pre size string
84236>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
84241>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
84242>>>>>>>
84242>>>>>>>    //Get data
84242>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_RESTRUCTURE_SCRIPT CALLBACK 0 PASSING sChunk iOffset iLong RESULT MertechInc_iRet
84247>>>>>>>
84247>>>>>>>    // Replace insert a CR before any LF character
84247>>>>>>>    Move (Replaces(Character(10), sChunk, Character(13)+Character(10))) to sChunk
84248>>>>>>>
84248>>>>>>>    Function_Return sChunk
84249>>>>>>>End_Function
84250>>>>>>>
84250>>>>>>>
84250>>>>>>>//=============================================================================
84250>>>>>>>/// @Name        GET_SQL_SCRIPT_CHUNK
84250>>>>>>>/// @Description This command returns a chunk of the script generated
84250>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
84250>>>>>>>/// DISABLE_SCRIPTING. Since some scripts can be very large, the script
84250>>>>>>>/// can be looped through, grabbing chunks at a time.
84250>>>>>>>///
84250>>>>>>>/// @Assumptions
84250>>>>>>>/// @Status      Public
84250>>>>>>>/// @Drivers     All
84250>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84250>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_INT_CHUNK
84250>>>>>>>///
84250>>>>>>>/// @Syntax GET_SQL_SCRIPT_CHUNK OFFSET {offset} to {variable} [{length}]
84250>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
84250>>>>>>>/// @Param variable                     Variable to hold the chunk
84250>>>>>>>/// @Param length                       Length of chunk returned (optional)
84250>>>>>>>///
84250>>>>>>>/// @Example
84250>>>>>>>/// ENABLE_SCRIPTING
84250>>>>>>>///     //Table restructuring would go here
84250>>>>>>>/// DISABLE_SCRIPTING
84250>>>>>>>///
84250>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
84250>>>>>>>/// Showln sChunk
84250>>>>>>>
84250>>>>>>>//=============================================================================
84250>>>>>>>/// @Name        GET_INT_CHUNK
84250>>>>>>>/// @Description This command returns a chunk of the INT file generated
84250>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
84250>>>>>>>/// DISABLE_SCRIPTING. Since some INT files can be very large, the file
84250>>>>>>>/// can be looped through, grabbing chunks at a time.
84250>>>>>>>///
84250>>>>>>>/// @Assumptions
84250>>>>>>>/// @Status      Public
84250>>>>>>>/// @Drivers     All
84250>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84250>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK
84250>>>>>>>///
84250>>>>>>>/// @Syntax GET_INT_CHUNK OFFSET {offset} to {variable} [{length}]
84250>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
84250>>>>>>>/// @Param variable                     Variable to hold the chunk
84250>>>>>>>/// @Param length                       Length of chunk returned (optional)
84250>>>>>>>///
84250>>>>>>>/// @Example
84250>>>>>>>/// ENABLE_SCRIPTING
84250>>>>>>>///     //Table restructuring would go here
84250>>>>>>>/// DISABLE_SCRIPTING
84250>>>>>>>///
84250>>>>>>>/// GET_INT_CHUNK OFFSET 0 to sChunk sLength
84250>>>>>>>/// Showln sChunk
84250>>>>>>>
84250>>>>>>>//=============================================================================
84250>>>>>>>/// @Name        REPORT_STMT
84250>>>>>>>/// @Description This command is an alternative to DataFlex's "Report"
84250>>>>>>>/// command. This allows embedded SQL to be used to fetch data instead of
84250>>>>>>>/// standard table queries.. All of the finds, for example, normally found
84250>>>>>>>/// in "Report" are replaced by SQL_FETCH_NEXT_ROW.
84250>>>>>>>///
84250>>>>>>>/// @Assumptions
84250>>>>>>>/// @Status      Public
84250>>>>>>>/// @Drivers     n/a
84250>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84250>>>>>>>/// @See
84250>>>>>>>///
84250>>>>>>>/// @Syntax See DataFlex / Visual DataFlex documentation
84250>>>>>>>///
84250>>>>>>>/// @Example
84250>>>>>>>/// /Header
84250>>>>>>>/// __/__/____                                                        Page ___.
84250>>>>>>>///                 MERTECH DATA SYSTEMS, INC. - NOT FOR RESALE
84250>>>>>>>///
84250>>>>>>>/// ID   NAME
84250>>>>>>>///
84250>>>>>>>/// /Body
84250>>>>>>>/// ____ _________________________
84250>>>>>>>/// /Total
84250>>>>>>>/// Records printed = _______.
84250>>>>>>>/// /*
84250>>>>>>>///
84250>>>>>>>///
84250>>>>>>>/// OPEN SALESP
84250>>>>>>>/// direct_output "con:"
84250>>>>>>>/// // Write the complete SELECT statement to retrieve the expected records from your REPORT
84250>>>>>>>/// // Must include the expression to qualify the required records and specify the order by as well
84250>>>>>>>///
84250>>>>>>>/// sql_set_stmt of salesp to "select recnum, id, name from SALESP where recnum > 5 order by id"
84250>>>>>>>/// sql_prepare_stmt of salesp
84250>>>>>>>/// sql_bindcolumns_stmt of salesp to salesp.recnum salesp.id salesp.name
84250>>>>>>>/// sql_execute_stmt of salesp
84250>>>>>>>///
84250>>>>>>>/// Report_stmt SALESP By Index.1
84250>>>>>>>///
84250>>>>>>>/// Section Header
84250>>>>>>>///     Sysdate Header.1
84250>>>>>>>///     Move PageCount to Header.2
84250>>>>>>>///     output header
84250>>>>>>>///
84250>>>>>>>/// Section Body
84250>>>>>>>///     Print Salesp.id   to Body.1
84250>>>>>>>///     Print Salesp.name to Body.2
84250>>>>>>>///     output body
84250>>>>>>>/// Section Total
84250>>>>>>>///
84250>>>>>>>/// Return
84250>>>>>>>/// ReportEnd
84250>>>>>>>
84250>>>>>>>//=============================================================================
84250>>>>>>>/// @Name        GET_SERVER_CFG
84250>>>>>>>/// @Description This command, when passed a valid server name, returns
84250>>>>>>>/// the a value for the specified attribute. See the list below for an
84250>>>>>>>/// explanation of each attribute.
84250>>>>>>>///
84250>>>>>>>/// SERVER_REVISION    Returns the major version, to the left of the decimal, of the server
84250>>>>>>>/// SUPPORT_DESC       Returns 1 if Server supports descending index segments
84250>>>>>>>/// SUPPORT_CASE       Returns 1 if Server supports case insensitive index segments
84250>>>>>>>/// SERVER_VERSION     Returns the full version of the server
84250>>>>>>>/// SERVER_ENCODING    Returns the Server Encoding
84250>>>>>>>/// CONNECTION_ACTIVE  Returns 1 if the connection to the server is active
84250>>>>>>>/// CITEXT_SUPPORT     Returns 1 if Server supports citext, a PostgreSQL data type
84250>>>>>>>///
84250>>>>>>>/// @Assumptions
84250>>>>>>>/// @Status      Internal
84250>>>>>>>/// @Drivers     All
84250>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84250>>>>>>>/// @See
84250>>>>>>>///
84250>>>>>>>/// @Syntax GET_SERVER_CFG {constant} of {server} to {variable}
84250>>>>>>>/// @Param constant                     SERVER_REVISION,SERVER_MIN_REVISION,SUPPORT_DESC,SUPPORT_CASE,SERVER_VERSION,SERVER_ENCODING,CONNECTION_ACTIVE
84250>>>>>>>/// @Param server                       Name of the server being checked
84250>>>>>>>/// @Param variable                     Variable to hold the returned value
84250>>>>>>>///
84250>>>>>>>/// @Example
84250>>>>>>>/// GET_SERVER_CFG SERVER_VERSION of "localhost" to sVersion
84250>>>>>>>
84250>>>>>>>Function MertechInc_GET_SERVER_CFG Global String sServer Integer iAttribute Returns String
84252>>>>>>>    Local String sReturnValue
84252>>>>>>>
84252>>>>>>>    Get MertechInc_Pre_Size_String 512 to sReturnValue
84253>>>>>>>
84253>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SERVER_CFG CALLBACK 0 PASSING sServer sReturnValue iAttribute RESULT MertechInc_iRet
84258>>>>>>>
84258>>>>>>>    //If iAttribute = SERVER_VERSION or SERVER_ENCODING then return sReturnValue
84258>>>>>>>    //else we need to return MertechInc_iRet
84258>>>>>>>    If ((iAttribute = 4) or (iAttribute = 5)) Function_Return sReturnValue
84261>>>>>>>    Else                                      Function_Return MertechInc_iRet
84263>>>>>>>End_Function
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_CONNECTION_STATUS
84264>>>>>>>/// @Description Retrieve the connection status for the specified server.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Internal
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
84264>>>>>>>/// @See
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_CONNECTION_STATUS of <serverName> [<databaseName>] to <variable>
84264>>>>>>>/// @Param serverName    Server Name
84264>>>>>>>/// @Param databaseName  Database Name
84264>>>>>>>/// @Param variable      DFTRUE means connection is active
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_CLIENT_CFG
84264>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Internal
84264>>>>>>>/// @Drivers     MySQLFlex and PgFlex
84264>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
84264>>>>>>>/// @See
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_CLIENT_CFG [ENCODING | ENCODING_ID] of <Server> [<MySQL_Database>] to <Var>
84264>>>>>>>/// @Param Server           Server name to get encoding of
84264>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
84264>>>>>>>/// @Param Var              Variable to hold returned value
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SET_CLIENT_CFG
84264>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Internal
84264>>>>>>>/// @Drivers     MySQLFlex and PgFlex
84264>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
84264>>>>>>>/// @See
84264>>>>>>>///
84264>>>>>>>/// @Syntax SET_CLIENT_CFG [ENCODING | UNIQUE_CHECKS] of <Server> [<MySQL_Database>] to <Value>
84264>>>>>>>/// @Param Server           Server name to get encoding of
84264>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
84264>>>>>>>/// @Param Value            Value to set
84264>>>>>>>///
84264>>>>>>>/// @Comment ENCODING - Set the Client Encoding
84264>>>>>>>/// @Comment UNIQUE_CHECKS {DFTRUE/DFFALSE} - enable/disable uniqueness checks for secondary indexes in InnoDB tables
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        CALL_DB2_PROCEDURE
84264>>>>>>>/// @Description Executes a DB2 Server stored procedure.
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     DB2Flex
84264>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
84264>>>>>>>///
84264>>>>>>>/// @Syntax CALL_DB2_PROCEDURE <OWNER> <STORED_PROC> {PASSING <ARG1> {. <ARGn>}}
84264>>>>>>>/// @Param Owner        Name of the Procedure's Owner.
84264>>>>>>>/// @Param Stored_Proc  Full name of the stored procedure being called.
84264>>>>>>>/// @Param Arg1..Argn   Arguments passed to the procedure.
84264>>>>>>>///
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_RESULTS
84264>>>>>>>/// @Description Returns the initial result set.
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     DB2Flex
84264>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_RESULTS
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_MORE_RESULTS
84264>>>>>>>/// @Description Returns remaining values not retrieved with GET_RESULT.
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     DB2Flex
84264>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_MORE_RESULTS
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_CURRENT_USER_NAME
84264>>>>>>>/// @Description This command is used to get the name of the user currently
84264>>>>>>>/// logged into the server.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84264>>>>>>>/// @See                 GET_CURRENT_USER_PASSWORD
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_CURRENT_USER_NAME of {server} to {variable}
84264>>>>>>>/// @Param server               The name of the server the user is in
84264>>>>>>>/// @Param variable             Variable to hold the username
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// GET_CURRENT_USER_NAME of "localhost" to sUserName
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_CURRENT_USER_PASSWORD
84264>>>>>>>/// @Description This command is used to get the password associated with
84264>>>>>>>/// the user currently logged into the server.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84264>>>>>>>/// @See                 GET_CURRENT_USER_NAME
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_CURRENT_USER_PASSWORD of {server} to {variable}
84264>>>>>>>/// @Param server               The name of the server the user is in
84264>>>>>>>/// @Param variable             Variable to hold the password
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// GET_CURRENT_USER_PASSWORD of "localhost" to sPassword
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        CREATE_DB2_DATABASE
84264>>>>>>>/// @Description Creates a DB2 database with the same DataFlex collating sequence.
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2009-08-12 By Ian Smith
84264>>>>>>>///
84264>>>>>>>/// @Syntax CREATE_DB2_DATABASE <DB Name> <DB Alias> <Code Set> <Territory> [<Path> <Node Name> <User ID><Password>]
84264>>>>>>>/// @Param DB Name     Name of the database being created
84264>>>>>>>/// @Param DB Alias    Alias Name applied to the database being created
84264>>>>>>>/// @Param Code Set    Code Set used by the database being created
84264>>>>>>>/// @Param Territory   Territory associated to the database being created
84264>>>>>>>/// @Param Path        Location of the database                                    - Optional
84264>>>>>>>/// @Param Node Name   Name of the machine (node) where the database is to reside  - Optional
84264>>>>>>>/// @Param User ID     User ID owning the database                                 - Optional
84264>>>>>>>/// @Param Password    Password of the User owning the database                    - Optional
84264>>>>>>>///
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SQL_OPEN_CURSOR_STMT
84264>>>>>>>/// @Description This command is used to create a new SQl Cursor. Once
84264>>>>>>>/// created, SQL_SET_CURRENT_CURSOR_STMT can be called to specify which
84264>>>>>>>/// cursor is to be used for a given SQL statement. Creating multiple
84264>>>>>>>/// cursors using this command allows multiple SQL statements to be
84264>>>>>>>/// opened at once. Optionally a different server can be specified for each
84264>>>>>>>/// cursor by passing the server name to this command as well. If no
84264>>>>>>>/// server is specified, the current server will be used. Note that it
84264>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84264>>>>>>>/// @See                 SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
84264>>>>>>>///
84264>>>>>>>/// @Syntax SQL_OPEN_CURSOR_STMT [of {server}] to {variable}
84264>>>>>>>/// @Param server                       Name of the server (optional)
84264>>>>>>>/// @Param variable                     Variable to hold the returned cursor handle
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>///
84264>>>>>>>/// Integer iCursor1 iCursor2 iCustomer
84264>>>>>>>/// String  sName
84264>>>>>>>/// Number  nOrderTotal
84264>>>>>>>///
84264>>>>>>>/// SQL_OPEN_CURSOR_STMT to iCursor1
84264>>>>>>>/// SQL_SET_STMT         to "SELECT CUSTOMER_NUMBER,NAME FROM CUSTOMER "
84264>>>>>>>/// SQL_APPEND_STMT      to "ORDER BY NAME "
84264>>>>>>>/// SQL_PREPARE_STMT
84264>>>>>>>/// SQL_EXECUTE_STMT
84264>>>>>>>/// Repeat
84264>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT TO iCursor1
84264>>>>>>>///     SQL_FETCH_NEXT_ROW INTO iCustomer sName
84264>>>>>>>///     If (Found) Begin
84264>>>>>>>///        SQL_OPEN_CURSOR_STMT to iCursor2
84264>>>>>>>///        SQL_SET_STMT         to "SELECT SUM(ORDER_TOTAL) FROM ORDERHEA "
84264>>>>>>>///        SQL_APPEND_STMT      to ("WHERE CUSTOMER_NUMBER = " + Trim(iCustomer))
84264>>>>>>>///        SQL_PREPARE_STMT
84264>>>>>>>///        SQL_EXECUTE_STMT
84264>>>>>>>///        SQL_FETCH_NEXT_ROW INTO nOrderTotal
84264>>>>>>>///        If (Found and nOrderTotal > 0) Begin
84264>>>>>>>///            Showln "Customer : " iCustomer "-" sName " - Total: " nOrderTotal
84264>>>>>>>///        End
84264>>>>>>>///        SQL_CLOSE_CURSOR_STMT to Cursor2
84264>>>>>>>///
84264>>>>>>>///        Indicate Found True
84264>>>>>>>///     End
84264>>>>>>>/// Until (Not(Found))
84264>>>>>>>///
84264>>>>>>>/// SQL_CLOSE_CURSOR_STMT to Cursor1
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SQL_CLOSE_CURSOR_STMT
84264>>>>>>>/// @Description This command closes the specified cursor that was created
84264>>>>>>>/// from SQL_OPEN_CURSOR_STMT. It is good practice to close all cursors
84264>>>>>>>/// once the statements associated with them are complete.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84264>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
84264>>>>>>>///
84264>>>>>>>/// @Syntax SQL_CLOSE_CURSOR_STMT [of {server}] to {variable}
84264>>>>>>>/// @Param server                       Name of the server (optional)
84264>>>>>>>/// @Param variable                     Cursor handle to close
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>///
84264>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
84264>>>>>>>///
84264>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
84264>>>>>>>/// SQL_PREPARE_STMT
84264>>>>>>>/// SQL_EXECUTE_STMT
84264>>>>>>>///
84264>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
84264>>>>>>>///
84264>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
84264>>>>>>>/// SQL_PREPARE_STMT
84264>>>>>>>/// SQL_EXECUTE_STMT
84264>>>>>>>///
84264>>>>>>>/// Repeat
84264>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
84264>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
84264>>>>>>>///     If (Found) Begin
84264>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
84264>>>>>>>///     End
84264>>>>>>>///
84264>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
84264>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
84264>>>>>>>///     If (Found) Begin
84264>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
84264>>>>>>>///     End
84264>>>>>>>/// Until (FindErr)
84264>>>>>>>///
84264>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
84264>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SQL_SET_CURRENT_CURSOR_STMT
84264>>>>>>>/// @Description This command is used to open a cursor to be used for an
84264>>>>>>>/// SQl statement. The cursor must be created using the SQL_OPEN_CURSOR_STMT,
84264>>>>>>>/// but once it has been created, this command can easily switch between
84264>>>>>>>/// cursors as desired. Optionally a different server can be specified for each
84264>>>>>>>/// cursor by passing the server name to this command as well. If no
84264>>>>>>>/// server is specified, the current server will be used. Note that it
84264>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84264>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
84264>>>>>>>///
84264>>>>>>>/// @Syntax SQL_SET_CURRENT_CURSOR_STMT [of {server}] to {variable}
84264>>>>>>>/// @Param server                       Name of the server (optional)
84264>>>>>>>/// @Param variable                     Cursor handle to use
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>///
84264>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
84264>>>>>>>///
84264>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
84264>>>>>>>/// SQL_PREPARE_STMT
84264>>>>>>>/// SQL_EXECUTE_STMT
84264>>>>>>>///
84264>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
84264>>>>>>>///
84264>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
84264>>>>>>>/// SQL_PREPARE_STMT
84264>>>>>>>/// SQL_EXECUTE_STMT
84264>>>>>>>///
84264>>>>>>>/// Repeat
84264>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
84264>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
84264>>>>>>>///     If (Found) Begin
84264>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
84264>>>>>>>///     End
84264>>>>>>>///
84264>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
84264>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
84264>>>>>>>///     If (Found) Begin
84264>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
84264>>>>>>>///     End
84264>>>>>>>/// Until (FindErr)
84264>>>>>>>///
84264>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
84264>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SQL_GET_CURRENT_CURSOR_STMT
84264>>>>>>>/// @Description This command returns the current active cursor being
84264>>>>>>>/// used. The cursor is returned to the specified variable.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84264>>>>>>>/// @See SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT
84264>>>>>>>///
84264>>>>>>>/// @Syntax SQL_GET_CURRENT_CURSOR_STMT [of {server}] to {variable}
84264>>>>>>>/// @Param server                       Name of the server (optional)
84264>>>>>>>/// @Param variable         Variable to hold the current cursor handle
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// SQL_GET_CURRENT_CURSOR_STMT to hCursor
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SQL_SET_MAX_CURSORS_STMT
84264>>>>>>>/// @Description Sets the maximum number of simultaneous cursors allowed.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Deprecated
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84264>>>>>>>/// @See
84264>>>>>>>///
84264>>>>>>>/// @Syntax SQL_SET_MAX_CURSORS_STMT [of {server}] to {variable}
84264>>>>>>>/// @Param server                       Name of the server (optional)
84264>>>>>>>/// @Param variable                     Maximum number of cursors allowed
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// SQL_SET_MAX_CURSORS_STMT to 50
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SQL_GET_MAX_CURSORS_STMT
84264>>>>>>>/// @Description Retrieves the maximum number of cursors allowed.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Deprecated
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84264>>>>>>>/// @See
84264>>>>>>>///
84264>>>>>>>/// @Syntax SQL_GET_MAX_CURSORS_STMT [of {server}] to {variable}
84264>>>>>>>/// @Param server                       Name of the server (optional)
84264>>>>>>>/// @Param variable                     Maximum number of cursors allowed
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// SQL_GET_MAX_CURSORS_STMT to iCursors
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SQL_SET_LOCAL_TD_PATH
84264>>>>>>>/// @Description Sets the directory where the driver will find the LOCAL TD files.
84264>>>>>>>/// @Status      Deprecated
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
84264>>>>>>>///
84264>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
84264>>>>>>>/// @Param DirectoryPath   Directory path were the TD files are to be located.
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SQL_GET_LOCAL_TD_PATH
84264>>>>>>>/// @Description Gets the directory where the driver is looking for the LOCAL TD files.
84264>>>>>>>/// @Status      Deprecated
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
84264>>>>>>>///
84264>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
84264>>>>>>>/// @Param DirectoryPath   Directory path were the driver is looking
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_DRIVER_REVISION
84264>>>>>>>/// @Description This command will put the current version (decimals included)
84264>>>>>>>/// of the driver associated with the current workspace into the specified
84264>>>>>>>/// variable.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84264>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_DRIVER_REVISION to {variable}
84264>>>>>>>/// @Param variable                     String variable to hold the returned version
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// GET_DRIVER_REVISION to sVersion
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_DRIVER_MAJOR_REVISION
84264>>>>>>>/// @Description This command will put the current version (no decimals)
84264>>>>>>>/// of the driver associated with the current workspace into the specified
84264>>>>>>>/// variable.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84264>>>>>>>/// @See                 GET_DRIVER_REVISION
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_DRIVER_MAJOR_REVISION to {variable}
84264>>>>>>>/// @Param variable                     String variable to hold the returned version
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// GET_DRIVER_MAJOR_REVISION to sVersion
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_DRIVER_LICENSE_EXPIRATION_TIME
84264>>>>>>>/// @Description This command is used to find out how long until a
84264>>>>>>>/// specific temporary license for a driver expires. If 0 is returned,
84264>>>>>>>/// then the license is not a temporary license. If -1 is returned, then
84264>>>>>>>/// the license has already expired. Otherwise, the number returned
84264>>>>>>>/// is the number of days until the license will expire.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-02 Aaron Gulack
84264>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH SET_DRIVER_LICENSE_EXPIRATION_WARNING
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_DRIVER_LICENSE_EXPIRATION_TIME to {variable}
84264>>>>>>>/// @Param variable                     Variable to hold the days until expiration
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// GET_DRIVER_LICENSE_EXPIRATION_TIME to iExpire
84264>>>>>>>/// Showln iExpire
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        SET_DRIVER_LICENSE_EXPIRATION_WARNING
84264>>>>>>>/// @Description This command is used to set a custom warning message to
84264>>>>>>>/// be displayed when a temporary license for a driver is close to expiring.
84264>>>>>>>/// Note that since the license evaluation is done during Login and before
84264>>>>>>>/// any open calls, this command should be called before either of those.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Public
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84264>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH GET_DRIVER_LICENSE_EXPIRATION_TIME
84264>>>>>>>///
84264>>>>>>>/// @Syntax SET_DRIVER_LICENSE_EXPIRATION_WARNING to {variable}
84264>>>>>>>/// @Param variable                     New warning message for expiring license
84264>>>>>>>///
84264>>>>>>>/// @Example
84264>>>>>>>/// SET_DRIVER_LICENSE_EXPIRATION_WARNING to "Your license is about to expire."
84264>>>>>>>/// Login "localhost" "" "" "sql_drv"
84264>>>>>>>
84264>>>>>>>//=============================================================================
84264>>>>>>>/// @Name        GET_DRIVER_LICENSE_PATH
84264>>>>>>>/// @Description This command will return the current path of the license
84264>>>>>>>/// associated with the driver.
84264>>>>>>>///
84264>>>>>>>/// @Assumptions
84264>>>>>>>/// @Status      Internal
84264>>>>>>>/// @Drivers     All
84264>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
84264>>>>>>>/// @See                 SET_DRIVER_LICENSE_EXPIRATION_WARNING GET_DRIVER_LICENSE_EXPIRATION_TIME
84264>>>>>>>///
84264>>>>>>>/// @Syntax GET_DRIVER_LICENSE_PATH to {variable}
84264>>>>>>>/// @Param variable                     Variable to hold the path of the license
84264>>>>>>>
84264>>>>>>>Function MertechInc_GET_DRIVER_LICENSE_PATH Global Returns String
84266>>>>>>>    Local String sReturnValue
84266>>>>>>>
84266>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
84268>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
84270>>>>>>>        Get MertechInc_Pre_Size_String 4096 to sReturnValue
84271>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING sReturnValue MertechInc_Blank CALLDRV_LICENSE_PATH RESULT MertechInc_iRet
84276>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
84279>>>>>>>    End
84279>>>>>>>>
84279>>>>>>>
84279>>>>>>>    Function_Return sReturnValue
84280>>>>>>>End_Function
84281>>>>>>>
84281>>>>>>>//=============================================================================
84281>>>>>>>/// @Name        SET_DATABASE_PORT
84281>>>>>>>/// @Description This command is used to dynamically change the port
84281>>>>>>>/// number to use for all TCP/IP connections to the server. Note that
84281>>>>>>>/// the port is used for the current session only.
84281>>>>>>>///
84281>>>>>>>/// @Assumptions The port is valid and available
84281>>>>>>>/// @Status      Public
84281>>>>>>>/// @Drivers     MySQLFlex PgFlex
84281>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84281>>>>>>>/// @See                 GET_DATABASE_PORT
84281>>>>>>>///
84281>>>>>>>/// @Syntax SET_DATABASE_PORT of {constant} to {variable}
84281>>>>>>>/// @Param constant                     MYSQL or PGSQL
84281>>>>>>>/// @Param variable                     Port number to use to connect to server
84281>>>>>>>///
84281>>>>>>>/// @Example
84281>>>>>>>/// GET_DATABASE_PORT of MYSQL to 1433
84281>>>>>>>
84281>>>>>>>//=============================================================================
84281>>>>>>>/// @Name        GET_DATABASE_PORT
84281>>>>>>>/// @Description This command returns the TCP/IP port used to connect
84281>>>>>>>/// to the server.
84281>>>>>>>///
84281>>>>>>>/// @Assumptions
84281>>>>>>>/// @Status      Public
84281>>>>>>>/// @Drivers     MySQLFlex PgFlex
84281>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84281>>>>>>>/// @See                 SET_DATABASE_PORT
84281>>>>>>>///
84281>>>>>>>/// @Syntax GET_DATABASE_PORT of {MYSQL/PGSQL} to {variable}
84281>>>>>>>/// @Param variable                     Variable to hold the TCP/IP port number
84281>>>>>>>///
84281>>>>>>>/// @Example
84281>>>>>>>/// GET_DATABASE_PORT of MYSQL to iPort
84281>>>>>>>
84281>>>>>>>//=============================================================================
84281>>>>>>>/// @Name        GET_SERIAL_NUMBER
84281>>>>>>>/// @Description This command returns the serial number associated with
84281>>>>>>>/// the current driver's license.
84281>>>>>>>///
84281>>>>>>>/// @Assumptions
84281>>>>>>>/// @Status      Public
84281>>>>>>>/// @Drivers     All
84281>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84281>>>>>>>/// @See
84281>>>>>>>///
84281>>>>>>>/// @Syntax GET_SERIAL_NUMBER to {variable}
84281>>>>>>>/// @Param variable                     Variable to hold the driver's serial number
84281>>>>>>>///
84281>>>>>>>/// @Example
84281>>>>>>>/// GET_SERIAL_NUMBER to iSerial
84281>>>>>>>
84281>>>>>>>//=============================================================================
84281>>>>>>>/// @Name        SET_DATABASE_SOCKET
84281>>>>>>>/// @Description This command is used to set the socket used to connect
84281>>>>>>>/// to the server when running an application under Linux/Unix.
84281>>>>>>>///
84281>>>>>>>/// @Assumptions
84281>>>>>>>/// @Status      Public
84281>>>>>>>/// @Drivers     MySQLFlex
84281>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84281>>>>>>>/// @See                 GET_DATABASE_SOCKET
84281>>>>>>>///
84281>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
84281>>>>>>>/// @Param variable                     Full name of the socket
84281>>>>>>>
84281>>>>>>>//=============================================================================
84281>>>>>>>/// @Name        GET_DATABASE_SOCKET
84281>>>>>>>/// @Description This command returns the name of the socket used to
84281>>>>>>>/// connect to the server when running an application under Linux/Unix.
84281>>>>>>>///
84281>>>>>>>/// @Assumptions
84281>>>>>>>/// @Status      Public
84281>>>>>>>/// @Drivers     MySQLFlex
84281>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84281>>>>>>>/// @See                 SET_DATABASE_SOCKET
84281>>>>>>>///
84281>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
84281>>>>>>>/// @Param variable                     Variable to hold the full socket name
84281>>>>>>>
84281>>>>>>>//=============================================================================
84281>>>>>>>/// @Name        SET_AUTHENTICATION_MODE
84281>>>>>>>/// @Description This command is used to control what mode the user logs
84281>>>>>>>/// in as. When DEFAULT is passed, the user will be logged in with the
84281>>>>>>>/// default privileges given to it. When SYSDBA is passed, the user will
84281>>>>>>>/// be logged in with the roles assigned to the sysdba user, most likely
84281>>>>>>>/// full control over the database.
84281>>>>>>>///
84281>>>>>>>/// @Assumptions
84281>>>>>>>/// @Status      Public
84281>>>>>>>/// @Drivers     OraFlex
84281>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
84281>>>>>>>/// @See
84281>>>>>>>///
84281>>>>>>>/// @Syntax SET_AUTHENTICATION_MODE of Oracle to {SYSDBA/DEFAULT}
84281>>>>>>>///
84281>>>>>>>/// @Example
84281>>>>>>>/// SET_AUTHENTICATION_MODE of Oracle to DEFAULT
84281>>>>>>>
84281>>>>>>>//=============================================================================
84281>>>>>>>/// @Name        SQL_ESCAPE_STRING
84281>>>>>>>/// @Description This command is used to properly escape strings before
84281>>>>>>>/// they are used in embedded SQL statements. This can be extremely
84281>>>>>>>/// important when you do not have full control of the strings being passed
84281>>>>>>>/// to the SQL statement as this will ensure that the strings are properly
84281>>>>>>>/// quoted.
84281>>>>>>>///
84281>>>>>>>/// @Assumptions
84281>>>>>>>/// @Status      Public
84281>>>>>>>/// @Drivers     All
84281>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84281>>>>>>>/// @See
84281>>>>>>>///
84281>>>>>>>/// @Syntax SQL_ESCAPE_STRING of {string} to {variable}
84281>>>>>>>/// @Param string               The string to be escaped.
84281>>>>>>>/// @Param variable     Variable to hold the newly escaped string
84281>>>>>>>///
84281>>>>>>>/// @Example
84281>>>>>>>/// SQL_ESCAPE_STRING of "They said to me, 'hello'." to sEscaped
84281>>>>>>>
84281>>>>>>>Function SQLESCAPESTRING Global String sData Returns String
84283>>>>>>>    String sReturnData
84283>>>>>>>
84283>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
84285>>>>>>>
84285>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
84287>>>>>>>        Get MertechInc_Pre_Size_String 0 to sReturnData
84288>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_ESCAPE_STRING CALLBACK 0 PASSING sData sReturnData 0 RESULT MertechInc_iRet
84293>>>>>>>    End
84293>>>>>>>>
84293>>>>>>>
84293>>>>>>>    Function_Return sReturnData
84294>>>>>>>End_Function
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        DIRECT_PATH_LOAD
84295>>>>>>>/// @Description
84295>>>>>>>///
84295>>>>>>>/// @Assumptions
84295>>>>>>>/// @Status      Internal
84295>>>>>>>/// @Drivers     OraFlex
84295>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
84295>>>>>>>/// @See
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        SQL_INITIALIZE_SEQUENCE
84295>>>>>>>/// @Description This command is used to initialize all auto increment
84295>>>>>>>/// columns, or sequences in Oracle, of the specified table to be the
84295>>>>>>>/// highest number plus one. This is useful when inserting a large amount
84295>>>>>>>/// of records in the table and the sequence is not being updated because
84295>>>>>>>/// the auto incremented column is being manually filled.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions
84295>>>>>>>/// @Status      Public
84295>>>>>>>/// @Drivers     OraFlex PgFlex
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84295>>>>>>>/// @See
84295>>>>>>>///
84295>>>>>>>/// SQL_INITIALIZE_SEQUENCE of {FileNumber}
84295>>>>>>>/// @Param FileNumber                   The file number
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        LOB_APPEND
84295>>>>>>>/// @Description This command is used to append data to an existing LOB
84295>>>>>>>/// column in the database. When called, the data corresponding field
84295>>>>>>>/// in the buffer is appended to the respective column in the database.
84295>>>>>>>/// This can be very useful when saving data that exceeds VDF size limits
84295>>>>>>>/// but falls within the limits of the SQL database. Note that this command
84295>>>>>>>/// must write to a file that is active and locked. Also the save is handled
84295>>>>>>>/// within the command so no extra calls are needed to save the changes made.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions The field being used is a LOB field
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     All
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 SQL_LOB_ADD_CHUNK
84295>>>>>>>///
84295>>>>>>>/// @Syntax LOB_APPEND of {FileName} {FieldNumber}
84295>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
84295>>>>>>>/// @Param FieldNumber          Number of the field being appended to
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// Clear Customer
84295>>>>>>>/// Find Gt Customer By Index.1
84295>>>>>>>///
84295>>>>>>>/// Direct_Input 'C:\Mertech.xml'
84295>>>>>>>/// Lock
84295>>>>>>>///    Find Eq Customer by Recnum
84295>>>>>>>///
84295>>>>>>>///    Read_Block Customer.Comments 16384
84295>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
84295>>>>>>>///    Repeat
84295>>>>>>>///        Read_Block Customer.Comments 16384
84295>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
84295>>>>>>>///    Until (SeqEOF)
84295>>>>>>>/// Unlock
84295>>>>>>>///
84295>>>>>>>/// Close_Input
84295>>>>>>>/// Find Eq Customer By Recnum
84295>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
84295>>>>>>>/// Showln 'Length: ' iLength
84295>>>>>>>
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        LOB_LENGTH
84295>>>>>>>/// @Description This command returns the length of the data in the
84295>>>>>>>/// specified column. This command must be used after a proper FIND to
84295>>>>>>>/// ensure that a valid record is in the buffer. This can be a useful
84295>>>>>>>/// command for checking if uploaded data exceeds size limits.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions The field being used is a LOB field
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     All
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 SQL_GET_LOB_LENGTH
84295>>>>>>>///
84295>>>>>>>/// @Syntax LOB_LENGTH of {FileName} {FieldNumber} to {variable}
84295>>>>>>>/// @Param FileName                     Name of the file
84295>>>>>>>/// @Param FieldNumber          Number of the LOB field
84295>>>>>>>/// @Param variable                     Variable to hold the length
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// Clear Customer
84295>>>>>>>/// Find Gt Customer By Index.1
84295>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
84295>>>>>>>/// Showln 'Length: ' iLength
84295>>>>>>>
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        LOB_READ
84295>>>>>>>/// @Description This command reads a chunk of data from a specified LOB
84295>>>>>>>/// column, moving it into its corresponding field buffer. Because the
84295>>>>>>>/// chunk will be moved into the field buffer, it can only be as large as
84295>>>>>>>/// the buffer allows. To account for this, the constants FIRST or NEXT
84295>>>>>>>/// are passed as well indicating whether to grab the first chunk for
84295>>>>>>>/// the buffer or the next. Each chunk grabbed will be as large as allowed.
84295>>>>>>>/// All these things considered, when reading data larger than the field
84295>>>>>>>/// buffer, it is good practice to perform the read in a loop, adding the
84295>>>>>>>/// length each time. Another optional parameter that can be passed is a
84295>>>>>>>/// variable that will store the length of the chunk. Note that a LOB read
84295>>>>>>>/// must be done after a successful find on the record.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions The field being used is a LOB field
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     All
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 SQL_GET_LOB SQL_GET_LOB_CHUNK
84295>>>>>>>///
84295>>>>>>>/// @Syntax LOB_READ of {FileName} {FieldNumber} {FIRST/NEXT} [{length}]
84295>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
84295>>>>>>>/// @Param FieldNumber          Number of the field being read from
84295>>>>>>>/// @Param FIRST                        Reads the first chunk of data
84295>>>>>>>/// @Param NEXT                         Reads the next chuck of data (if larger than buffer limit)
84295>>>>>>>/// @Param length                       Variable to hold the chunk length (optional)
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// Direct_Output ('binary:Mertech.pdf')
84295>>>>>>>///
84295>>>>>>>/// Clear customer
84295>>>>>>>/// Find Gt customer by Index.1
84295>>>>>>>/// SQL_LOB_LENGTH of customer 13 to liLength
84295>>>>>>>///
84295>>>>>>>/// While (liLength > 0)
84295>>>>>>>///     Write customer.comments
84295>>>>>>>///     SQL_LOB_READ of customer 13 Next liLength
84295>>>>>>>/// Loop
84295>>>>>>>///
84295>>>>>>>/// Close_Output
84295>>>>>>>
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        LOB_WRITE
84295>>>>>>>/// @Description This command is used to write data to a LOB column.
84295>>>>>>>/// By passing the file name and field number of the LOB column, this
84295>>>>>>>/// command will take the current value of the respective field in
84295>>>>>>>/// the field buffer, write it to the database and save it. Any data
84295>>>>>>>/// currently in that field will be overridden by the data from the
84295>>>>>>>/// buffer. Note that this command must write to a file that is active
84295>>>>>>>/// and locked. Also this command handles the save so no extra calls
84295>>>>>>>/// are needed to save the changes.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions The field being used is a LOB field
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     All
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK
84295>>>>>>>///
84295>>>>>>>/// @Syntax LOB_WRITE of {FileName} {FieldNumber}
84295>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
84295>>>>>>>/// @Param FieldNumber          Number of the field being written to
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// Clear Customer
84295>>>>>>>/// Find Gt Customer By Index.1
84295>>>>>>>///
84295>>>>>>>/// Direct_Input 'C:\Mertech.xml'
84295>>>>>>>/// Lock
84295>>>>>>>///    Find Eq Customer by Recnum
84295>>>>>>>///
84295>>>>>>>///    Read_Block Customer.Comments 16384
84295>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
84295>>>>>>>///    Repeat
84295>>>>>>>///        Read_Block Customer.Comments 16384
84295>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
84295>>>>>>>///    Until (SeqEOF)
84295>>>>>>>/// Unlock
84295>>>>>>>/// Close_Input
84295>>>>>>>///
84295>>>>>>>/// Find Eq Customer By Recnum
84295>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
84295>>>>>>>/// Showln 'Length: ' iLength
84295>>>>>>>
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        LOB_LOADFROMFILE
84295>>>>>>>/// @Description This command loads an external file into a specified LOB
84295>>>>>>>/// column. After specifying the file name and field number, the path and
84295>>>>>>>/// file must then be passed respectively. When using Oracle, instead of
84295>>>>>>>/// passing the directory, a directory alias must be passed. This alias
84295>>>>>>>/// can be created using a "CREATE DIRECTORY" statement in SQL. For more
84295>>>>>>>/// information on setting this directory alias, see the Oracle help.
84295>>>>>>>/// For other servers, the file must be a local file available to the
84295>>>>>>>/// application that is calling the command. Note that this command must
84295>>>>>>>/// write to a file that is active and locked. Also this command handles
84295>>>>>>>/// the save so no extra calls are needed to save the changes.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions The field being used is a LOB field
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     All
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
84295>>>>>>>///
84295>>>>>>>/// @Syntax LOB_LOADFROMFILE of {FileName} {FieldNumber} From {path} {file}
84295>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
84295>>>>>>>/// @Param FieldNumber          Number of the LOB column being used
84295>>>>>>>/// @Param path                         The path of the file, excluding the file name
84295>>>>>>>/// @Param file                         The name of the file, including the extension
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// Clear Customer
84295>>>>>>>/// Find Gt Customer By Index.1
84295>>>>>>>/// Lock
84295>>>>>>>///    Find Eq Customer by Recnum
84295>>>>>>>///    LOB_TRUNCATE OF customel 13 to 0 // Customer.Comments
84295>>>>>>>///    Saverecord Customer
84295>>>>>>>///    // Directory name is case sensitive.
84295>>>>>>>///    // Make sure the name case matches
84295>>>>>>>///    LOB_LOADFROMFILE OF customel 13 FROM "C:\Mertech\FilesToLoad" "Mertech.XML"
84295>>>>>>>/// Unlock
84295>>>>>>>
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        LOB_ERASE
84295>>>>>>>/// @Description This command is used to erase a portion of data from a
84295>>>>>>>/// LOB column. For text fields, the portion of data to be erased is
84295>>>>>>>/// replaced with white space, and in binary fields, with 0X0. To erase
84295>>>>>>>/// a portion of the data, pass the length to erase as well as the number
84295>>>>>>>/// to offset from. For this command to work properly, it must be done
84295>>>>>>>/// after a valid find. Note that the save is handled inside this command
84295>>>>>>>/// so no extra commands are needed to save the changes.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions The field being used is a LOB field
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     All
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
84295>>>>>>>///
84295>>>>>>>/// @Syntax LOB_ERASE OF {FileName} {FieldNumber} {length} {offset}
84295>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
84295>>>>>>>/// @Param FieldNumber          Number of the LOB column being erased
84295>>>>>>>/// @Param Length                       Length of chunk to erase from column
84295>>>>>>>/// @Param offset                       Starting position for erase
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// Clear customer
84295>>>>>>>/// Find Gt customer by Recnum
84295>>>>>>>/// Lock
84295>>>>>>>/// Find Eq customer by Recnum
84295>>>>>>>/// LOB_LENGTH OF customer 13 to liTotalLength
84295>>>>>>>/// LOB_ERASE  OF customer 13    liTotalLength 1
84295>>>>>>>/// Unlock
84295>>>>>>>
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        LOB_TRUNCATE
84295>>>>>>>/// @Description This command is used to trim a LOB column down to a
84295>>>>>>>/// specified length. By passing the table name and column number, the
84295>>>>>>>/// value in the column can then be trimmed down the specified length.
84295>>>>>>>/// This can be a useful command for clearing out a column before entering
84295>>>>>>>/// new data into it. Note that this command must write to a file that is active
84295>>>>>>>/// and locked. Also this command handles the save so no extra calls
84295>>>>>>>/// are needed to save the changes. This command can be used to clear out a field before adding new data
84295>>>>>>>///
84295>>>>>>>/// @Assumptions The field being used is a LOB field
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     All
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE FLUSH_LOB_BUFFER
84295>>>>>>>///
84295>>>>>>>/// @Syntax LOB_TRUNCATE of {FileName} {FieldNumber} to {variable}
84295>>>>>>>/// @Param FileName                     Name of the file
84295>>>>>>>/// @Param FieldNumber          The field number
84295>>>>>>>/// @Param length                       New length to truncate to
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// Clear Customer
84295>>>>>>>/// Find Gt Customer By Index.1
84295>>>>>>>/// Lock
84295>>>>>>>///    Find Eq Customer by Recnum
84295>>>>>>>///    SQL_LOB_TRUNCATE of Customer 13 to 0 // Customer.Comments
84295>>>>>>>///    Saverecord Customer
84295>>>>>>>/// Unlock
84295>>>>>>>
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        FLUSH_LOB_BUFFER
84295>>>>>>>/// @Description This command currently serves no function.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     MySQLFlex
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84295>>>>>>>/// @See
84295>>>>>>>///
84295>>>>>>>/// @Syntax FLUSH_LOB_BUFFER of {FileName}
84295>>>>>>>/// @Param FileName                     Name of the file
84295>>>>>>>
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        SQL_ENABLE_RECONNECT
84295>>>>>>>/// @Description Allow MySql Driver to auto reconnect after a time-out.
84295>>>>>>>///
84295>>>>>>>/// Driver auto-reconnect feature handles the issue where MySQL
84295>>>>>>>/// will kick off a user after inactivity.
84295>>>>>>>///
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     MySQL
84295>>>>>>>/// @VersionNote Last Revised: 2009-09-11 By Ian Smith
84295>>>>>>>///
84295>>>>>>>/// @Syntax SQL_ENABLE_RECONNECT of <ServerName> to dftrue/dffalse
84295>>>>>>>/// @Param ServerName  Server Name.
84295>>>>>>>///
84295>>>>>>>/// @Usage SQL_ENABLE_RECONNECT Of sServerID To dftrue
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        CALL_MYSQL_STORED_PROCEDURE
84295>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
84295>>>>>>>/// backend. To successfully call a procedure with this command, a string
84295>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
84295>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
84295>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
84295>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
84295>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
84295>>>>>>>/// is set to true.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     MySQLFlex
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 CALL_STORED_PROCEDURE
84295>>>>>>>///
84295>>>>>>>/// @Syntax CALL_MYSQL_STORED_PROCEDURE {procedure} Passing {argument}
84295>>>>>>>/// @Param procedure            Full name of the procedure
84295>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// CALL_MYSQL_STORED_PROCEDURE "getCustomerStatus" passing sCustomerID sStatus
84295>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
84295>>>>>>>/// Showln sStatus
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        CALL_MYSQL_STORED_FUNCTION
84295>>>>>>>/// @Description This command is used to execute a function stored in MySQL.
84295>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
84295>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
84295>>>>>>>/// builds and executes the function by setting the full function name, the
84295>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
84295>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
84295>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
84295>>>>>>>/// values.
84295>>>>>>>///
84295>>>>>>>/// @Status      Deprecated
84295>>>>>>>/// @Drivers     MySQLFlex
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 CALL_STORED_FUNCTION
84295>>>>>>>///
84295>>>>>>>/// @Syntax CALL_MYSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
84295>>>>>>>/// @Param function                     Full name of the function
84295>>>>>>>/// @Param variable                     Variable to hold the returned value
84295>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// CALL_MYSQL_STORED_FUNCTION "getCustomerStatus" Returns sStatus passing sCustomerID
84295>>>>>>>/// Showln sStatus
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        DO_SET_ALL_FUNCTION_PARAMETERS
84295>>>>>>>/// @Description Sets the parameters for a MySQL stored function call.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions
84295>>>>>>>/// @Status      Internal
84295>>>>>>>/// @Drivers     MySQLFlex
84295>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
84295>>>>>>>/// @See
84295>>>>>>>///
84295>>>>>>>/// @Syntax DO_SET_ALL_FUNCTION_PARAMETERS [sParam1 [sParam2 . sParamn]]
84295>>>>>>>/// @Param sParam1.n    Parameters for the stored function
84295>>>>>>>
84295>>>>>>>//=============================================================================
84295>>>>>>>/// @Name        GET_NO_AVAILABLE_SQLSERVERS
84295>>>>>>>/// @Description This command is used to get the number of available MSSQL
84295>>>>>>>/// servers detected in the network. When used with GET_SQLSERVER_NAME,
84295>>>>>>>/// all the available server names can be easily retrieved.
84295>>>>>>>///
84295>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
84295>>>>>>>/// @Status      Public
84295>>>>>>>/// @Drivers     SQLFlex
84295>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84295>>>>>>>/// @See                 GET_SQLSERVER_NAME
84295>>>>>>>///
84295>>>>>>>/// @Syntax GET_NO_AVAILABLE_SQLSERVERS to {variable}
84295>>>>>>>/// @Param variable                     Variable to hold number of servers
84295>>>>>>>///
84295>>>>>>>/// @Example
84295>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
84295>>>>>>>///
84295>>>>>>>/// While (i <= iServers)
84295>>>>>>>///     GET_SQLSERVER_NAME i to sServer
84295>>>>>>>///     Showln sServer
84295>>>>>>>///     Increment i
84295>>>>>>>/// Loop
84295>>>>>>>
84295>>>>>>>Function SQL_AVAILABLE_SQL_SERVERS Global Returns Integer
84297>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_ENUMERATE_SERVER_COUNT RESULT MertechInc_iRet
84302>>>>>>>
84302>>>>>>>    Function_Return MertechInc_iRet
84303>>>>>>>End_Function
84304>>>>>>>
84304>>>>>>>
84304>>>>>>>//=============================================================================
84304>>>>>>>/// @Name        GET_SQLSERVER_NAME
84304>>>>>>>/// @Description This command returns the name of the server based on the
84304>>>>>>>/// specified index number. The number of servers can be retrieved from
84304>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS and the names can be indexed from that
84304>>>>>>>/// number.
84304>>>>>>>///
84304>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
84304>>>>>>>/// @Status      Public
84304>>>>>>>/// @Drivers     SQLFlex
84304>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84304>>>>>>>/// @See                 GET_NO_AVAILABLE_SQLSERVERS
84304>>>>>>>///
84304>>>>>>>/// @Syntax SQL_AVAILABLE_SQL_SERVER_NAME {index} to {variable}
84304>>>>>>>/// @Param index                The numbered index name to retrieve
84304>>>>>>>/// @Param variable             Variable to hold the server name
84304>>>>>>>///
84304>>>>>>>/// @Example
84304>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
84304>>>>>>>///
84304>>>>>>>/// While (i <= iServers)
84304>>>>>>>///     GET_SQLSERVER_NAME i to sServer
84304>>>>>>>///     Showln sServer
84304>>>>>>>///     Increment i
84304>>>>>>>/// Loop
84304>>>>>>>
84304>>>>>>>Function SQL_AVAILABLE_SQL_SERVER_NAME Global Integer iIndex Returns String
84306>>>>>>>    Local String sName
84306>>>>>>>
84306>>>>>>>    Get MertechInc_Pre_Size_String 80 to sName
84307>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING sName iIndex CALLDRV_ENUMERATE_SERVER_SERVER RESULT MertechInc_iRet
84312>>>>>>>
84312>>>>>>>    Function_Return sName
84313>>>>>>>End_Function
84314>>>>>>>
84314>>>>>>>
84314>>>>>>>//=============================================================================
84314>>>>>>>/// @Name        SET_USE_ROWCOUNT_IN_TRANSACTION
84314>>>>>>>/// @Description Turn on / off Row_Count for specified server.
84314>>>>>>>/// @Status      Deprecated
84314>>>>>>>/// @Drivers     All
84314>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
84314>>>>>>>///
84314>>>>>>>/// @Syntax SET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
84314>>>>>>>/// @Param Server      Name of server to turn On / Off Row_Count
84314>>>>>>>/// @Param State       TRUE = turn on Row_Count  FALSE = turn off Row_Count
84314>>>>>>>///
84314>>>>>>>/// @Comment This SHOULD ALWAYS BE TURNED ON
84314>>>>>>>
84314>>>>>>>Procedure Set SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Integer iState
84316>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
84318>>>>>>>
84318>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer iState CALLDRV_VALUE_SET RESULT MertechInc_iRet
84323>>>>>>>    If MertechInc_iRet EQ -1 INDICATE ERR True
84326>>>>>>>End_Procedure
84327>>>>>>>
84327>>>>>>>//IGS - commented out by a.n. Other
84327>>>>>>>//#REPLACE UseRowCountInTransactions SQL_USE_ROWCOUNT_IN_TRANSACTIONS
84327>>>>>>>
84327>>>>>>>//=============================================================================
84327>>>>>>>/// @Name        GET_USE_ROWCOUNT_IN_TRANSACTION
84327>>>>>>>/// @Description Gets the Row_Count setting for specified server.
84327>>>>>>>/// @Status      Deprecated
84327>>>>>>>/// @Drivers     All
84327>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
84327>>>>>>>///
84327>>>>>>>/// @Syntax GET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
84327>>>>>>>/// @Param Server      Name of server to get Row_Count state of
84327>>>>>>>/// @Param State       Variable to hold returned value
84327>>>>>>>
84327>>>>>>>Function SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Returns Integer
84329>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
84331>>>>>>>
84331>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
84336>>>>>>>
84336>>>>>>>    Function_Return MertechInc_iRet
84337>>>>>>>End_Function
84338>>>>>>>
84338>>>>>>>
84338>>>>>>>//=============================================================================
84338>>>>>>>/// @Name        SQL_SET_DATE_FORMAT
84338>>>>>>>/// @Description This command controls the date format of data returned
84338>>>>>>>/// through embedded SQL. If set to DATAFLEX, then the dates will be
84338>>>>>>>/// returned in whatever format is set in DF_DATE_FORMAT. When set to
84338>>>>>>>/// NATIVE, this command will force dates to return dates in the format
84338>>>>>>>/// specified on the SQL server. Note that in order for the variables to
84338>>>>>>>/// be in the right form, they need to be string variables.
84338>>>>>>>///
84338>>>>>>>/// @Assumptions
84338>>>>>>>/// @Status      Public
84338>>>>>>>/// @Drivers     SQLFlex
84338>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
84338>>>>>>>/// @See
84338>>>>>>>///
84338>>>>>>>/// @Syntax SQL_SET_DATE_FORMAT to {DATAFLEX/NATIVE}
84338>>>>>>>///
84338>>>>>>>/// @Example
84338>>>>>>>/// SQL_SET_DATE_FORMAT to NATIVE
84338>>>>>>>
84338>>>>>>>Procedure Set SQL_USE_DATAFLEX_DATEFORMAT Global Integer iState
84340>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
84342>>>>>>>
84342>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
84344>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
84349>>>>>>>        IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
84352>>>>>>>    End
84352>>>>>>>>
84352>>>>>>>End_Procedure
84353>>>>>>>
84353>>>>>>>Function SQL_USE_DATAFLEX_DATEFORMAT Global Returns Integer
84355>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
84357>>>>>>>
84357>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
84359>>>>>>>        CALL_DRIVER 0 MertechInc_DriverName FUNCTION CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
84364>>>>>>>    End
84364>>>>>>>>
84364>>>>>>>    Else Move DFFALSE to MertechInc_iRet
84366>>>>>>>
84366>>>>>>>    function_return MertechInc_iRet
84367>>>>>>>End_Function
84368>>>>>>>
84368>>>>>>>
84368>>>>>>>//=============================================================================
84368>>>>>>>/// @Name        SET_FIELDS_NOT_NULL
84368>>>>>>>/// @Description This command is used to specify how to handle blank
84368>>>>>>>/// and zero values on the SQL backend. Since blank or zero values can
84368>>>>>>>/// often be stored as null in the server database, this command allows
84368>>>>>>>/// that to be altered if needed. When set to true, a value will be
84368>>>>>>>/// inserted into blank records to keep them from being null. See the
84368>>>>>>>/// list below for what value will be stored instead of null. If set to
84368>>>>>>>/// false, values will be stored normally in the database. Note that this
84368>>>>>>>/// command effects all data types.
84368>>>>>>>///
84368>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
84368>>>>>>>///
84368>>>>>>>/// DF_BCD -                                    0 (zero)
84368>>>>>>>///
84368>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
84368>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
84368>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
84368>>>>>>>///
84368>>>>>>>/// DF_BINARY -                                 0X0
84368>>>>>>>///
84368>>>>>>>/// @Assumptions
84368>>>>>>>/// @Status      Public
84368>>>>>>>/// @Drivers     All
84368>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84368>>>>>>>/// @See                 SET_FIELDS_NULL GET_FIELDS_NULL
84368>>>>>>>///
84368>>>>>>>/// @Syntax SET_FIELDS_NOT_NULL to {variable}
84368>>>>>>>/// @Param variable             Boolean variable to indicate how to handle null values
84368>>>>>>>///
84368>>>>>>>
84368>>>>>>>Procedure Set SQL_FORCE_FIELDS_NOT_NULL Global Integer iState
84370>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
84372>>>>>>>
84372>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
84374>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
84379>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
84382>>>>>>>    End
84382>>>>>>>>
84382>>>>>>>End_Procedure
84383>>>>>>>
84383>>>>>>>
84383>>>>>>>
84383>>>>>>>
84383>>>>>>>Function SQL_FORCE_FIELDS_NOT_NULL Global Returns Integer
84385>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
84387>>>>>>>
84387>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
84389>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
84394>>>>>>>    End
84394>>>>>>>>
84394>>>>>>>    Else Move DFFALSE to MertechInc_iRet
84396>>>>>>>
84396>>>>>>>    Function_Return MertechInc_iRet
84397>>>>>>>End_Function
84398>>>>>>>
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        SET_FIELDS_NULL
84398>>>>>>>/// @Description This command is used to specify how to store blank or zero
84398>>>>>>>/// values in the database. Since database can sometimes store these value,
84398>>>>>>>/// i.e. '' or 0, as null, using this command can be useful in managing that.
84398>>>>>>>/// When set to true, any value in a column of the given type considered blank
84398>>>>>>>/// or 0 will be stored as null in the database. Setting it to false will cause
84398>>>>>>>/// the server to save as it normally would. Note that this command is used to
84398>>>>>>>/// set specific data types only, it can not effect all types at once. Below is
84398>>>>>>>/// a list of value that would be considered blank/zero values.
84398>>>>>>>///
84398>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
84398>>>>>>>///
84398>>>>>>>/// DF_BCD -                                    0 (zero)
84398>>>>>>>///
84398>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
84398>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
84398>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
84398>>>>>>>///
84398>>>>>>>/// DF_BINARY -                                 0X0
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status      Public
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84398>>>>>>>/// @See                 GET_FIELDS_NULL SET_FIELDS_NOT_NULL
84398>>>>>>>///
84398>>>>>>>/// @Syntax SET_FIELDS_NULL {datatype} to {variable}
84398>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
84398>>>>>>>/// @Param variable             Boolean to indicate how to handle blank data
84398>>>>>>>
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        GET_FIELDS_NULL
84398>>>>>>>/// @Description This command will return the value of SET_FIELDS_NULL for
84398>>>>>>>/// the specified data type.
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status      Public
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
84398>>>>>>>/// @See                 SET_FIELDS_NULL SET_FIELDS_NOT_NULL
84398>>>>>>>///
84398>>>>>>>/// @Syntax GET_FIELDS_NULL {datatype} to {variable}
84398>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
84398>>>>>>>/// @Param variable             Variable to hold the value of SET_FIELDS_NULL
84398>>>>>>>
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        STRUCTURE_START_DYNAMIC
84398>>>>>>>/// @Description This command is used when scripting structural changes.
84398>>>>>>>/// It is the same as using ENABLE_SCRIPTING and Structure_Start separately.
84398>>>>>>>/// It allows structural changes to be compiled and tested without
84398>>>>>>>/// actually making any of the changes. Any table restructuring done
84398>>>>>>>/// between this command and STRUCTURE_END_DYNAMIC will not actually be
84398>>>>>>>/// committed but will instead create a mock INT file. The script and
84398>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status      Deprecated
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84398>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
84398>>>>>>>///
84398>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
84398>>>>>>>/// @Param FileNumber                   The number of the file
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        STRUCTURE_END_DYNAMIC
84398>>>>>>>/// @Description This command ends the scripting started by
84398>>>>>>>/// STRUCTURE_START_DYNAMIC. It is the same as calling Structure_End
84398>>>>>>>/// and DISABLE_SCRIPTING separately.
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status      Deprecated
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84398>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
84398>>>>>>>///
84398>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
84398>>>>>>>/// @Param FileNumber                   The number of the file
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        SQLSERVER_ATTACH_DB
84398>>>>>>>/// @Description Attachs an MS SQL mdf to the current server instance. If
84398>>>>>>>/// the passed database is already attached, no error is generated.
84398>>>>>>>///
84398>>>>>>>/// The SQLSERVER_ATTACH_DB command is intended for use with our new support
84398>>>>>>>/// of Microsoft LocalDB's.  When using LocalDB's a common use case might be
84398>>>>>>>/// to attach to a customer DB, do some work on it, and then detach this DB
84398>>>>>>>/// and attach to a different DB.  This was possible using stored procedures,
84398>>>>>>>/// but the code had some complexities that a developer need not worry about.
84398>>>>>>>/// When you attach a database, you must pass the database name, along with
84398>>>>>>>/// the path to an MDF file which contains the database.  Any associated LDF's
84398>>>>>>>/// (log files) and NDF's (secondary data files) must be in the same folder.
84398>>>>>>>///
84398>>>>>>>/// If you call SQLSERVER_ATTACH_DB on a database that is already attached,
84398>>>>>>>/// no error will be generated.  After you call SQLSERVER_ATTACH_DB, you
84398>>>>>>>/// should call SET_DATABASE_NAME if you wish to make the attached database
84398>>>>>>>/// the currently selected database.
84398>>>>>>>///
84398>>>>>>>/// SQLSERVER_ATTACH_DB will work on all supported version of SQL server.
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status      Public
84398>>>>>>>/// @Drivers     SQLFlex
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-09 Aaron Gulack
84398>>>>>>>/// @See
84398>>>>>>>///
84398>>>>>>>/// @Syntax SQLSERVER_ATTACH_DB {database} on {filePath}
84398>>>>>>>/// @Param database                     Name of the database
84398>>>>>>>/// @Param filePath                     Path of the MDF file
84398>>>>>>>///
84398>>>>>>>/// @Example
84398>>>>>>>/// SQLSERVER_ATTACH_DB "MTSample" ON "C:\Mertech\Data\SampleDb.mdf"
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        SQLSERVER_DETACH_DB
84398>>>>>>>/// @Description The SQLSERVER_DETACH_DB command is intended for use with our
84398>>>>>>>/// new support of Microsoft LocalDB's.  When using LocalDB's a common use
84398>>>>>>>/// case might be to attach to a customer DB, do some work on it, and then
84398>>>>>>>/// detach this DB and attach to a different DB.  This was possible using
84398>>>>>>>/// stored procedures, but the code had some complexities that a developer
84398>>>>>>>/// need not worry about.  A detach can only be done if the database passed
84398>>>>>>>/// has no open connections.  As part of the detach process, the command
84398>>>>>>>/// closes ALL open files (even those not associated with this database or
84398>>>>>>>/// driver).
84398>>>>>>>///
84398>>>>>>>/// NOTE: SQLSERVER_DETACH_DB will often fail to execute if you are testing
84398>>>>>>>/// your application from the studio.  This is because the studio itself
84398>>>>>>>/// normally has open connections to the database.  If you test your
84398>>>>>>>/// application outside of the studio and the studio is closed (and any
84398>>>>>>>/// other application or tools that access this database are closed) you
84398>>>>>>>/// can successfully detach the database.
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status      Public
84398>>>>>>>/// @Drivers     SQLFlex
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84398>>>>>>>/// @See
84398>>>>>>>///
84398>>>>>>>/// @Syntax SQLSERVER_DETACH_DB {database}
84398>>>>>>>/// @Param database                     Name of the database
84398>>>>>>>///
84398>>>>>>>/// @Example
84398>>>>>>>/// SQLSERVER_DETACH_DB "TestDB"
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        SET_FIXED_FILE_RECORDS_USED
84398>>>>>>>/// @Description This command is used to set DF_FILE_RECORDS_USED to a
84398>>>>>>>/// fixed value. This can be useful because doing a SELECT COUNT(*) is
84398>>>>>>>/// a very expensive process to the server. Many applications do counts
84398>>>>>>>/// often and using this command can help cut down the server traffic.
84398>>>>>>>/// Sometimes when counts are used, an exact number is not necessary so
84398>>>>>>>/// a fixed value, updated occasionally can be used. By setting this
84398>>>>>>>/// command to 0 or greater, the value of DF_FILE_RECORDS_USED will be
84398>>>>>>>/// set to that specified value and the internal SELECT COUNT(*) will be
84398>>>>>>>/// suppressed. If this command is set to something less that zero,
84398>>>>>>>/// DF_FILE_RECORDS_USED will be dynamically calculated whenever it is
84398>>>>>>>/// called.
84398>>>>>>>///
84398>>>>>>>/// The default value for this command is -1
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status              Public
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84398>>>>>>>/// @See                 GET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
84398>>>>>>>///
84398>>>>>>>/// @Syntax SET_FIXED_FILE_RECORDS_USED to {variable}
84398>>>>>>>/// @Param variable                     Fixed value for DF_FILE_RECORDS_USED
84398>>>>>>>///
84398>>>>>>>/// @Example
84398>>>>>>>/// SET_FIXED_FILE_RECORDS_USED to 10000
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        GET_FIXED_FILE_RECORDS_USED
84398>>>>>>>/// @Description This command returns the value of DF_FILE_RECORDS_USED
84398>>>>>>>/// if it has been set to a fixed value by SET_FIXED_FILE_RECORDS_USED.
84398>>>>>>>/// If anything greater than or equal to 0 is returned then that is the
84398>>>>>>>/// fixed value returned by any SELECT COUNT(*) statements, internal or
84398>>>>>>>/// not. If something less than zero is returned, then DF_FILE_RECORDS_USED
84398>>>>>>>/// returns a dynamic count whenever it is called.
84398>>>>>>>///
84398>>>>>>>/// By default the value of this is -1
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status              Public
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84398>>>>>>>/// @See                 SET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
84398>>>>>>>///
84398>>>>>>>/// @Syntax GET_FILE_RECORDS_USED to {variable}
84398>>>>>>>/// @Param variable                     Variable to hold the fixed value
84398>>>>>>>///
84398>>>>>>>/// @Example
84398>>>>>>>/// GET_FIXED_FILE_RECORDS_USED to iRecords
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        SUPPRESS_SELECT_COUNT
84398>>>>>>>/// @Description This command sets the value of DF_FILE_RECORDS_USED to
84398>>>>>>>/// a fixed value of zero. That way anytime a SELECT COUNT(*) is done,
84398>>>>>>>/// zero is returned, cutting down on server traffic. This is the same
84398>>>>>>>/// as setting SET_FIXED_FILE_RECORDS_USED to 0.
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status      Public
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84398>>>>>>>/// @See                 UNSUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
84398>>>>>>>///
84398>>>>>>>/// @Syntax SUPPRESS_SELECT_COUNT
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        UNSUPPRESS_SELECT_COUNT
84398>>>>>>>/// @Description This command resets the value of DF_FILE_RECORDS_USED to
84398>>>>>>>/// -1. That way anytime a SELECT COUNT(*) is done, it returns the actual
84398>>>>>>>/// count of records. This is the same as setting SET_FIXED_FILE_RECORDS_USED
84398>>>>>>>/// to -1.
84398>>>>>>>///
84398>>>>>>>/// @Assumptions
84398>>>>>>>/// @Status      Public
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
84398>>>>>>>/// @See                 SUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
84398>>>>>>>///
84398>>>>>>>/// @Syntax UNSUPPRESS_SELECT_COUNT
84398>>>>>>>
84398>>>>>>>
84398>>>>>>>///
84398>>>>>>>// Private:
84398>>>>>>>// Get the filenumber of a file.field parameter
84398>>>>>>>//
84398>>>>>>>
84398>>>>>>>///
84398>>>>>>>// Private:
84398>>>>>>>// Get the fieldnumber of a file.field parameter
84398>>>>>>>//
84398>>>>>>>
84398>>>>>>>
84398>>>>>>>
84398>>>>>>>
84398>>>>>>>//
84398>>>>>>>// Minimum required DataFlex version for new LOB support below is VDF 4
84398>>>>>>>//
84398>>>>>>>
84398>>>>>>>TYPE tMertechLOB_Args
84398>>>>>>>    FIELD tMertechLOB_Args.cbSize       AS WORD          // always the size of the structure (verification + versioning)
84398>>>>>>>    FIELD tMertechLOB_Args.nField       AS DWORD         // always the field number
84398>>>>>>>    FIELD tMertechLOB_Args.pszData      AS POINTER
84398>>>>>>>    FIELD tMertechLOB_Args.nSize        AS DWORD
84398>>>>>>>    FIELD tMertechLOB_Args.nOffset      AS POINTER
84398>>>>>>>END_TYPE
84398>>>>>>>
84398>>>>>>>//=============================================================================
84398>>>>>>>/// @Name        SQL_SET_LOB
84398>>>>>>>/// @Description This command replaces whatever is currently in a LOB Field
84398>>>>>>>/// with the data passed. It writes to a client side buffer. It can be used
84398>>>>>>>/// to Write an arbitrary amount of data into a LOB.
84398>>>>>>>/// If passed an empty String, it will remove all the contents of the LOB.
84398>>>>>>>/// If you wish to Set a LOB back to NULL, please use the SQL_SET_LOB_NULL
84398>>>>>>>/// command.
84398>>>>>>>/// NOTE: Unlike the previous call LOB_WRITE, this call does not
84398>>>>>>>/// perform the Save. This must be done separately.
84398>>>>>>>///
84398>>>>>>>/// @Assumptions The field being used is a LOB field
84398>>>>>>>/// @Status      Public
84398>>>>>>>/// @Drivers     All
84398>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84398>>>>>>>/// @See                 SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
84398>>>>>>>///
84398>>>>>>>/// @Syntax             SQL_SET_LOB {FileName.FieldName} to {variable}
84398>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
84398>>>>>>>/// @Param              FieldName               The name of the LOB field being set
84398>>>>>>>/// @Param              variable                The variable to use to set the field's value
84398>>>>>>>///
84398>>>>>>>/// @Example
84398>>>>>>>/// Set_Argument_Size 262144
84398>>>>>>>/// String sLine
84398>>>>>>>///
84398>>>>>>>/// Clear Customer
84398>>>>>>>///    Move iID to Customer.ID
84398>>>>>>>/// Find Eq Customer by Index.1
84398>>>>>>>/// If (Found) Begin
84398>>>>>>>///    Direct_Input "C:\bigFile.xml"
84398>>>>>>>///    Reread Customer
84398>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
84398>>>>>>>///       Read_Block sLine 262144
84398>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
84398>>>>>>>///       While (not(SeqEof))
84398>>>>>>>///          Read_Block sLine 262144
84398>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
84398>>>>>>>///       Loop
84398>>>>>>>///    Saverecord Customer
84398>>>>>>>///    Unlock
84398>>>>>>>///    Close_Input
84398>>>>>>>/// End
84398>>>>>>>
84398>>>>>>>Procedure MertechInc_SQL_SET_LOB String sDriver Integer iFile Integer iField String sData
84401>>>>>>>    Local String sLOB_Args       // can drop local command if minimum vdf version is 6
84401>>>>>>>
84401>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
84402>>>>>>>    // First move the size of the structure to the Structure
84402>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84403>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84404>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
84405>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
84406>>>>>>>
84406>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_WRITE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84411>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB
84412>>>>>>>
84412>>>>>>>//=============================================================================
84412>>>>>>>/// @Name        SQL_ADD_LOB_CHUNK
84412>>>>>>>/// @Description This command is used to add additional chunks to the buffer
84412>>>>>>>/// before saving the record. After SQL_SET_LOB has been called
84412>>>>>>>/// SQL_ADD_LOB_CHUNK can be called as many times as needed to add additional
84412>>>>>>>/// chunks of data before a save. It can also be called independent of
84412>>>>>>>/// SQL_SET_LOB to append data to an existing LOB column.
84412>>>>>>>/// NOTE: Unlike the previous call LOB_APPEND, this call does not perform
84412>>>>>>>/// the save. This must be done separately.
84412>>>>>>>///
84412>>>>>>>/// @Assumptions The field being used is a LOB field
84412>>>>>>>/// @Status      Public
84412>>>>>>>/// @Drivers     All
84412>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84412>>>>>>>/// @See                 SQL_SET_LOB SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
84412>>>>>>>///
84412>>>>>>>/// @Syntax             SQL_ADD_LOB_CHUNK {FileName.FieldName} to {variable}
84412>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
84412>>>>>>>/// @Param              FieldName               The name of the LOB field being set
84412>>>>>>>/// @Param              variable                The variable to add as the LOB chunk
84412>>>>>>>///
84412>>>>>>>/// @Example
84412>>>>>>>/// Set_Argument_Size 262144
84412>>>>>>>/// String sLine
84412>>>>>>>///
84412>>>>>>>/// Clear Customer
84412>>>>>>>///    Move iID to Customer.ID
84412>>>>>>>/// Find Eq Customer by Index.1
84412>>>>>>>/// If (Found) Begin
84412>>>>>>>///    Direct_Input "C:\bigFile.xml"
84412>>>>>>>///    Reread Customer
84412>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
84412>>>>>>>///       Read_Block sLine 262144
84412>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
84412>>>>>>>///       While (not(SeqEof))
84412>>>>>>>///          Read_Block sLine 262144
84412>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
84412>>>>>>>///       Loop
84412>>>>>>>///    Saverecord Customer
84412>>>>>>>///    Unlock
84412>>>>>>>///    Close_Input
84412>>>>>>>/// End
84412>>>>>>>
84412>>>>>>>Procedure MertechInc_SQL_ADD_LOB_CHUNK String sDriver Integer iFile Integer iField String sData
84415>>>>>>>    Local String sLOB_Args
84415>>>>>>>
84415>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
84416>>>>>>>    // First move the size of the structure to the Structure
84416>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84417>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84418>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
84419>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
84420>>>>>>>
84420>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_APPEND CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84425>>>>>>>end_procedure // MertechInc_SQL_ADD_LOB_CHUNK
84426>>>>>>>
84426>>>>>>>//=============================================================================
84426>>>>>>>/// @Name        SQL_GET_LOB
84426>>>>>>>/// @Description This command is used for getting the value of a specified LOB
84426>>>>>>>/// field. Two optional parameters can be passed specifying the offset and
84426>>>>>>>/// length of the chunk to get. Passing these parameters essentially makes this
84426>>>>>>>/// call the same as SQL_GET_LOB_CHUNK.
84426>>>>>>>/// Depending on the situation, the two calls can be interchanged for improved
84426>>>>>>>/// code readability. Excluding these additional parameters will get the whole
84426>>>>>>>/// field value within DataFlex variable size limits.
84426>>>>>>>///
84426>>>>>>>/// @Assumptions The field being used is a LOB field
84426>>>>>>>/// @Status      Public
84426>>>>>>>/// @Drivers     All
84426>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84426>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
84426>>>>>>>///
84426>>>>>>>/// @Syntax     SQL_GET_LOB {FileName.FieldName} TO {variable} [ OFFSET {offset} LENGTH {length} ]
84426>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
84426>>>>>>>/// @Param              FieldName                       The name of the LOB field
84426>>>>>>>/// @Param              variable                        The variable to hold the LOB value
84426>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB value (optional)
84426>>>>>>>/// @Param              length                          Length of value to get from the LOB field (optional)
84426>>>>>>>///
84426>>>>>>>/// @Example
84426>>>>>>>/// Set_Argument_Size 262144
84426>>>>>>>/// String sResult
84426>>>>>>>///
84426>>>>>>>/// Move 262144 to iChunkSize
84426>>>>>>>/// Move 0      to iChunk
84426>>>>>>>///
84426>>>>>>>/// Clear Customer
84426>>>>>>>///    Move iID to Customer.ID
84426>>>>>>>/// Find Eq Customer by Index.1
84426>>>>>>>/// If (Found) Begin
84426>>>>>>>///    Direct_Output ('Binary:' + sDestFileName)
84426>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
84426>>>>>>>///    While (iChunk*iChunkSize < iLength)
84426>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
84426>>>>>>>///       Write sResult
84426>>>>>>>///       Increment iChunk
84426>>>>>>>///    Loop
84426>>>>>>>///    Close_Output
84426>>>>>>>/// End
84426>>>>>>>
84426>>>>>>>
84426>>>>>>>Function MertechInc_SQL_GET_LOB String sDriver Integer iFile Integer iField Integer iOffset Integer iLength Returns String
84429>>>>>>>    Local String sLOB_Args
84429>>>>>>>    Local String sData
84429>>>>>>>    Local DWord  nSize
84429>>>>>>>
84429>>>>>>>    Move "" To sData
84430>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
84431>>>>>>>    // First move the size of the structure to the Structure
84431>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84432>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84433>>>>>>>
84433>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84438>>>>>>>
84438>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
84439>>>>>>>    If nSize GT 0 Begin
84441>>>>>>>      If (iOffset=0 and iLength=0) Begin
84443>>>>>>>        ZeroString nSize to sData
84444>>>>>>>            //Send Assert (AddressOf(sData) <> 0) ("AddressOf(sData) is NULL") DFTrue
84444>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
84445>>>>>>>      End
84445>>>>>>>>
84445>>>>>>>      Else Begin
84446>>>>>>>        ZeroString iLength to sData
84447>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
84448>>>>>>>        Put iLength            to sLOB_Args at tMertechLOB_Args.nSize
84449>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
84450>>>>>>>      End
84450>>>>>>>>
84450>>>>>>>      Call_Driver iFile sDriver Function CALLDRV_LOB_EX_READ CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84455>>>>>>>    End
84455>>>>>>>>
84455>>>>>>>    Else Begin
84456>>>>>>>        Move "" to sData
84457>>>>>>>    End
84457>>>>>>>>
84457>>>>>>>    Function_Return sData
84458>>>>>>>End_Function // MertechInc_SQL_GET_LOB
84459>>>>>>>
84459>>>>>>>//=============================================================================
84459>>>>>>>/// @Name        SQL_GET_LOB_CHUNK
84459>>>>>>>/// @Description This command is used for getting a chunk of data from a specified
84459>>>>>>>/// LOB field. The difference between this command and SQL_GET_LOB is only that
84459>>>>>>>/// the parameters OFFSET and LENGTH are not optional when using this command.
84459>>>>>>>/// You may consider using this command to retrieve small portions of a very
84459>>>>>>>/// large BLOB so as to reduce memory usage.
84459>>>>>>>///
84459>>>>>>>/// @Assumptions The field being used is a LOB field
84459>>>>>>>/// @Status      Public
84459>>>>>>>/// @Drivers     All
84459>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84459>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
84459>>>>>>>///
84459>>>>>>>/// @Syntax     SQL_GET_LOB_CHUNK {FileName.FieldName} TO {variable} OFFSET {offset} LENGTH {length}
84459>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
84459>>>>>>>/// @Param              FieldName                       The name of the LOB field
84459>>>>>>>/// @Param              variable                        The variable to hold the LOB chunk
84459>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB chunk
84459>>>>>>>/// @Param              length                          Length of chunk to get from the LOB field
84459>>>>>>>///
84459>>>>>>>/// @Example
84459>>>>>>>/// Set_Argument_Size 262144
84459>>>>>>>/// String sResult
84459>>>>>>>///
84459>>>>>>>/// Move 262144 to iChunkSize
84459>>>>>>>/// Move 0      to iChunk
84459>>>>>>>///
84459>>>>>>>/// Clear Customer
84459>>>>>>>///    Move iID to Customer.ID
84459>>>>>>>/// Find Eq Customer by Index.1
84459>>>>>>>/// If (Found) Begin
84459>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
84459>>>>>>>///    While (iChunk*iChunkSize < iLength)
84459>>>>>>>///       SQL_GET_LOB_CHUNK Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
84459>>>>>>>///       // Do something with the LOB data
84459>>>>>>>///       Increment iChunk
84459>>>>>>>///    Loop
84459>>>>>>>/// End
84459>>>>>>>
84459>>>>>>>//=============================================================================
84459>>>>>>>/// @Name        SQL_GET_LOB_LENGTH
84459>>>>>>>/// @Description This command is used to get the length of a specified LOB field.
84459>>>>>>>/// It is useful, for example, in determining the number of iterations to
84459>>>>>>>/// perform while reading from a LOB field using chunking.
84459>>>>>>>///
84459>>>>>>>/// @Assumptions The field being used is a LOB field
84459>>>>>>>/// @Status      Public
84459>>>>>>>/// @Drivers     All
84459>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84459>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
84459>>>>>>>///
84459>>>>>>>/// @Syntax             SQL_GET_LOB_LENGTH {FileName.FieldName} to {variable}
84459>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
84459>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
84459>>>>>>>/// @Param              variable                        The variable to hold the length of the field
84459>>>>>>>///
84459>>>>>>>/// @Example
84459>>>>>>>/// Set_Argument_Size 262144
84459>>>>>>>/// String sResult
84459>>>>>>>///
84459>>>>>>>/// Move 16384 to iChunkSize
84459>>>>>>>/// Move 0     to iChunk
84459>>>>>>>///
84459>>>>>>>/// Clear Customer
84459>>>>>>>///    Move iID to Customer.ID
84459>>>>>>>/// Find Eq Customer by Index.1
84459>>>>>>>/// If (Found) Begin
84459>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
84459>>>>>>>///    While (iChunk*iChunkSize < iLength)
84459>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
84459>>>>>>>///       // Do something with the LOB data
84459>>>>>>>///       Increment iChunk
84459>>>>>>>///    Loop
84459>>>>>>>/// End
84459>>>>>>>
84459>>>>>>>
84459>>>>>>>Function MertechInc_SQL_GET_LOB_LENGTH String sDriver Integer iFile Integer iField Returns Integer
84462>>>>>>>    Local String sLOB_Args
84462>>>>>>>    Local DWord  nSize
84462>>>>>>>
84462>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
84463>>>>>>>    // First move the size of the structure to the Structure
84463>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84464>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84465>>>>>>>
84465>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84470>>>>>>>
84470>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
84471>>>>>>>    Function_Return nSize
84472>>>>>>>End_Function // MertechInc_SQL_GET_LOB_LENGTH
84473>>>>>>>
84473>>>>>>>//=============================================================================
84473>>>>>>>/// @Name        SQL_SET_LOB_NULL
84473>>>>>>>/// @Description This command is used to set a LOB column to null. Often
84473>>>>>>>/// LOB columns should either contain data or be null. A "blank" LOB column
84473>>>>>>>/// often doesn't appear empty in other environments, so settings it back to
84473>>>>>>>/// null is best.
84473>>>>>>>///
84473>>>>>>>/// @Assumptions The field being used is a LOB field
84473>>>>>>>/// @Status      Public
84473>>>>>>>/// @Drivers     All
84473>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
84473>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
84473>>>>>>>///
84473>>>>>>>/// @Syntax             SQL_SET_LOB_NULL    {FileName.FieldName}
84473>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
84473>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
84473>>>>>>>///
84473>>>>>>>/// @Example
84473>>>>>>>////
84473>>>>>>>/// Clear Customer
84473>>>>>>>/// Move iID to Customer.ID
84473>>>>>>>/// Find Eq Customer by Index.1
84473>>>>>>>/// If (Found) Begin
84473>>>>>>>///    Reread Customer
84473>>>>>>>///        SQL_SET_LOB_NULL Customer.Comments
84473>>>>>>>///        Saverecord Customer
84473>>>>>>>///    Unlock
84473>>>>>>>/// End
84473>>>>>>>
84473>>>>>>>
84473>>>>>>>Procedure MertechInc_SQL_SET_LOB_NULL String sDriver Integer iFile Integer iField
84476>>>>>>>    Local String sLOB_Args
84476>>>>>>>
84476>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
84477>>>>>>>    // First move the size of the structure to the Structure
84477>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
84478>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
84479>>>>>>>
84479>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_SET_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
84484>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB_NULL
84485>>>>>>>
84485>>>>>>>
84485>>>>>>>
84485>>>>>>>//=============================================================================
84485>>>>>>>// End of Mertech.inc
84485>>>>>>>//=============================================================================
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>// *** Constant Declarations: ***
84485>>>>>//
84485>>>>>
84485>>>>>// NOTE: These text constants should be added to the various "Language_xxx.inc" files:
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>
84485>>>>>    Define DATAFLEX_ID for "DATAFLEX"
84485>>>>>
84485>>>>>// System icon menu constants. If the upper left hand
84485>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
84485>>>>>    Define SC_RESTORE  for |CI$F120
84485>>>>>    Define SC_MOVE     for |CI$F010
84485>>>>>    Define SC_SIZE     for |CI$F000
84485>>>>>    Define SC_MINIMIZE for |CI$F020
84485>>>>>    Define SC_MAXIMIZE for |CI$F030
84485>>>>>    Define SC_CLOSE    for |CI$F060
84485>>>>>    Define SC_KEYMENU  for |CI$F100
84485>>>>>    Define SC_NEXTWINDOW for |CI$F040
84485>>>>>    Define SC_PREVWINDOW for |CI$F050
84485>>>>>
84485>>>>>// *** Struct Declarations: ***
84485>>>>>Struct tWinMemoryStatusEx
84485>>>>>    UInteger dwLength
84485>>>>>    UInteger dwMemoryLoad
84485>>>>>    UBigInt ullTotalPhys
84485>>>>>    UBigInt ullAvailPhys
84485>>>>>    UBigInt ullTotalPageFile
84485>>>>>    UBigInt ullAvailPageFile
84485>>>>>    UBigInt ullTotalVirtual
84485>>>>>    UBigInt ullAvailVirtual
84485>>>>>    UBigInt ullAvailExtendedVirtual
84485>>>>>End_Struct
84485>>>>>
84485>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
84485>>>>>Type MEMORYSTATUS
84485>>>>>   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
84485>>>>>   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
84485>>>>>   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
84485>>>>>   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
84485>>>>>   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
84485>>>>>   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
84485>>>>>   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
84485>>>>>   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
84485>>>>>End_Type
84485>>>>>
84485>>>>>// *** External Function calls: ***
84485>>>>>//
84485>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
84486>>>>>
84486>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
84487>>>>>
84487>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
84488>>>>>
84488>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
84489>>>>>
84489>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
84490>>>>>
84490>>>>>// *** Global/Desktop Function Declarations: ***
84490>>>>>
84490>>>>>Function ComputerName for Desktop Returns String
84492>>>>>    String sName
84492>>>>>    Get_Environment "COMPUTERNAME" to sName
84493>>>>>>
84493>>>>>    Function_Return sName
84494>>>>>End_Function
84495>>>>>
84495>>>>>Function Network_User_Name for cDesktop Returns String
84497>>>>>    String sName
84497>>>>>    Get_Environment "USERNAME" to sName
84498>>>>>>
84498>>>>>    Function_Return sName
84499>>>>>End_Function
84500>>>>>
84500>>>>>// *** Class Declarations: ***
84500>>>>>//
84500>>>>>Class cBitmapContainerVDFLink is a BitmapContainer
84501>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
84503>>>>>        Send Mouse_Up iWindowNumber iPosition
84504>>>>>    End_Procedure
84505>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
84507>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
84509>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
84510>>>>>    End_Procedure
84511>>>>>End_Class
84512>>>>>
84512>>>>>Class cCopyEditorContentButton is a Button
84513>>>>>    Procedure Construct_Object
84515>>>>>        Forward Send Construct_Object
84517>>>>>        Property Handle phoEditorHandle
84518>>>>>        Set psToolTip to C_$DescCopy
84519>>>>>    End_Procedure
84520>>>>>
84520>>>>>    Procedure CopyToWindowsClipboard
84522>>>>>        String sValue
84522>>>>>        Handle hoEditor
84522>>>>>        Boolean bCanCopy
84522>>>>>        Address aEditorAddress
84522>>>>>
84522>>>>>        Get phoEditorHandle to hoEditor
84523>>>>>        Send Select_All of hoEditor
84524>>>>>        Get CanCopy of hoEditor to bCanCopy
84525>>>>>        If (bCanCopy = True) Begin
84527>>>>>            Get paValue of hoEditor to aEditorAddress
84528>>>>>            Move aEditorAddress to sValue
84529>>>>>            Send Copy   of hoEditor
84530>>>>>            // Remove the selection after text is copied to the clipboard.
84530>>>>>            Send Beginning_of_Data of hoEditor
84531>>>>>            Send Info_Box C_$CopyToClipboard_Text
84532>>>>>        End
84532>>>>>>
84532>>>>>    End_Procedure
84533>>>>>End_Class
84534>>>>>
84534>>>>>Class SysinfoDisplay is a cTextEdit
84535>>>>>    Procedure Construct_Object
84537>>>>>        Forward Send Construct_Object
84539>>>>>
84539>>>>>        Set Size to 104 247
84540>>>>>        Set Location to 4 6
84541>>>>>        Set Border_Style to Border_None
84542>>>>>        Set peAnchors to anAll
84543>>>>>        Set Read_Only_State to True
84544>>>>>        Set pbWrap to True
84545>>>>>    End_Procedure
84546>>>>>
84546>>>>>    // Augmented class message to adjust certain text strings that are wrong...
84546>>>>>
84546>>>>>    Procedure AppendTextLn String sText
84548>>>>>        String sWorkspaceWSFile
84548>>>>>
84548>>>>>        // Only works for English:
84548>>>>>        If (ghoApplication > 0) Begin
84550>>>>>            If (sText contains "Workspace Name") Begin
84552>>>>>                Move "Workspace Config Filename:" to sText
84553>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
84554>>>>>                Move (sText * sWorkspaceWSFile) to sText
84555>>>>>            End
84555>>>>>>
84555>>>>>        End
84555>>>>>>
84555>>>>>        Send AppendText sText
84556>>>>>        Send AppendText (character(10))
84557>>>>>    End_Procedure
84558>>>>>
84558>>>>>    //****************************************************************************
84558>>>>>    // $Module type: PROCEDURE
84558>>>>>    // $Module name: Show_Current_Directory
84558>>>>>    // $Author     : VOO
84558>>>>>    // Created     : 06-10-96 @ 15:24
84558>>>>>    //
84558>>>>>    // Description
84558>>>>>    //    This method will show the name Of the current directory in the system
84558>>>>>    //    information box
84558>>>>>    //
84558>>>>>    // $Rev History
84558>>>>>    //    06-10-96  Module header created
84558>>>>>    //****************************************************************************
84558>>>>>    Procedure Show_Current_Directory
84560>>>>>        String sDir
84560>>>>>
84560>>>>>        Get_Current_Directory To sDir
84561>>>>>
84561>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
84562>>>>>    End_Procedure
84563>>>>>
84563>>>>>    Procedure Show_Windows_Directory
84565>>>>>        String sWindir
84565>>>>>
84565>>>>>        Get_Windows_Directory To sWindir
84566>>>>>
84566>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
84567>>>>>    End_Procedure
84568>>>>>
84568>>>>>    Procedure Show_Current_User
84570>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
84571>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
84572>>>>>    End_Procedure
84573>>>>>
84573>>>>>    Procedure Show_Number_Format
84575>>>>>        Integer iFormat
84575>>>>>        String sFormatText
84575>>>>>
84575>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
84578>>>>>        Move (Character (iFormat)) To sFormatText
84579>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
84580>>>>>
84580>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
84583>>>>>        Move (Character (iFormat)) to sFormatText
84584>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
84585>>>>>    End_Procedure
84586>>>>>
84586>>>>>    Procedure Show_Filelist_Name
84588>>>>>        String sFilename
84588>>>>>
84588>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
84591>>>>>
84591>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
84592>>>>>    End_Procedure
84593>>>>>
84593>>>>>    Procedure Show_Lock_Delay
84595>>>>>        Integer iLockdelay
84595>>>>>
84595>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
84598>>>>>
84598>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
84599>>>>>    End_Procedure
84600>>>>>
84600>>>>>    Procedure Show_Lock_Timeout
84602>>>>>        Integer iLockTimeout
84602>>>>>
84602>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
84605>>>>>
84605>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
84606>>>>>    End_Procedure
84607>>>>>
84607>>>>>    Procedure Show_Screen_Size
84609>>>>>        Integer iYscreensize iXscreensize
84609>>>>>
84609>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
84610>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
84611>>>>>
84611>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
84612>>>>>    End_Procedure
84613>>>>>
84613>>>>>    Procedure Show_Page_Size
84615>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
84616>>>>>    End_procedure
84617>>>>>
84617>>>>>    Procedure Show_Date
84619>>>>>        Date dToday
84619>>>>>
84619>>>>>        Sysdate dToday
84620>>>>>
84620>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
84621>>>>>    End_procedure
84622>>>>>
84622>>>>>    Procedure Show_Date_Format
84624>>>>>        Integer iDateFormat
84624>>>>>        String sDateFormat
84624>>>>>
84624>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
84627>>>>>        Case Begin
84627>>>>>            Case (iDateFormat = DF_DATE_USA)
84629>>>>>                Move C_$USA To sDateFormat
84630>>>>>                Case Break
84631>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
84634>>>>>                Move C_$European To sDateFormat
84635>>>>>                Case Break
84636>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
84639>>>>>                Move C_$Military To sDateFormat
84640>>>>>                Case Break
84641>>>>>            Case Else
84641>>>>>                Move C_$UnknownDateType To sDateFormat
84642>>>>>                Case Break
84643>>>>>        Case End
84643>>>>>
84643>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
84644>>>>>    End_Procedure
84645>>>>>
84645>>>>>    // 2013-08-14 NGS
84645>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
84645>>>>>    Procedure Show_Systemresources
84647>>>>>        tWinMemoryStatusEx MemoryStatusInfo
84647>>>>>        tWinMemoryStatusEx MemoryStatusInfo
84647>>>>>        Integer iRetval
84647>>>>>        Number nValue
84647>>>>>        String sValue
84647>>>>>
84647>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
84648>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
84649>>>>>        If (iRetval = 0) Begin
84651>>>>>            Move (ShowLastError ()) to iRetval
84652>>>>>            Procedure_Return
84653>>>>>        End
84653>>>>>>
84653>>>>>
84653>>>>>        Send AppendTextLn ""
84654>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
84655>>>>>
84655>>>>>        // Show memory in Gigabytes:
84655>>>>>        Move (nValue/1024/1024/1024) to nValue
84656>>>>>        Move (Round(nValue)) to nValue
84657>>>>>        Get FormatNumber nValue 2 to sValue
84658>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
84659>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
84660>>>>>
84660>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
84660>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
84661>>>>>        Move (Round(nValue)) to nValue
84662>>>>>        Get FormatNumber nValue 0 to sValue
84663>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
84664>>>>>
84664>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
84664>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
84665>>>>>        Move (Round(nValue)) to nValue
84666>>>>>        Get FormatNumber nValue 0 to sValue
84667>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
84668>>>>>
84668>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
84668>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
84669>>>>>        Move (Round(nValue)) to nValue
84670>>>>>        Get FormatNumber nValue 0 to sValue
84671>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
84672>>>>>
84672>>>>>        // Add an empty row after the memory information:
84672>>>>>        Send AppendTextLn ""
84673>>>>>    End_Procedure
84674>>>>>
84674>>>>>    Procedure Show_Registration
84676>>>>>        String sRegName
84676>>>>>        Integer iSN iUsersMax iUserCount
84676>>>>>
84676>>>>>        Registration sRegName iSN
84677>>>>>>
84677>>>>>        Get_Licensed_Max_Users to iUsersMax
84678>>>>>        Get_Current_User_Count to iUserCount
84679>>>>>
84679>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
84680>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
84681>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
84682>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
84683>>>>>    End_Procedure
84684>>>>>
84684>>>>>    //****************************************************************************
84684>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
84684>>>>>    // To the workspace object passing the an object and message To send back
84684>>>>>    // To this object. It is expected that the workspace object will send this
84684>>>>>    // message for every line Of information it wants displayed (passing the
84684>>>>>    // information To be displayed
84684>>>>>    //****************************************************************************
84684>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
84684>>>>>
84684>>>>>    Procedure Show_ServicePack
84686>>>>>        String sKey sVersion sDataFlex
84686>>>>>        Handle hoRegistry
84686>>>>>        Boolean bExists bOpened
84686>>>>>
84686>>>>>        Move "DataFlex"        to sDataFlex
84687>>>>>
84687>>>>>        Get Create U_cRegistry to hoRegistry
84688>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
84689>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
84690>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
84691>>>>>
84691>>>>>        If (bExists) Begin
84693>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
84694>>>>>        End
84694>>>>>>
84694>>>>>        Else Begin
84695>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
84696>>>>>        End
84696>>>>>>
84696>>>>>        Get KeyExists of hoRegistry sKey to bExists
84697>>>>>        If (bExists) Begin
84699>>>>>            Get OpenKey of hoRegistry sKey to bOpened
84700>>>>>            If (bOpened) Begin
84702>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
84703>>>>>                If (bExists) Begin
84705>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
84706>>>>>                End
84706>>>>>>
84706>>>>>                Send CloseKey of hoRegistry
84707>>>>>            End
84707>>>>>>
84707>>>>>        End
84707>>>>>>
84707>>>>>        Send Destroy of hoRegistry
84708>>>>>
84708>>>>>        If (sVersion <> "") Begin
84710>>>>>           Send AppendTextLn sVersion
84711>>>>>           Send AppendTextLn ""
84712>>>>>        End
84712>>>>>>
84712>>>>>    End_Procedure
84713>>>>>
84713>>>>>    Procedure Show_WorkspaceInformation
84715>>>>>        Integer hoWorkspace
84715>>>>>
84715>>>>>        If (ghoApplication <> 0) Begin
84717>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
84718>>>>>            If (hoWorkspace <> 0) Begin
84720>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
84721>>>>>            End
84721>>>>>>
84721>>>>>        End
84721>>>>>>
84721>>>>>    End_Procedure
84722>>>>>
84722>>>>>    //****************************************************************************
84722>>>>>    // If connection ids are used, we will send the message EnumerateConnections
84722>>>>>    // to the connection manager object passing the an object and message to send
84722>>>>>    // back to this object. It is expected that the connection manager object will
84722>>>>>    // send this message for every line Of information it wants displayed (passing
84722>>>>>    // the information To be displayed
84722>>>>>    //****************************************************************************
84722>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
84722>>>>>
84722>>>>>    Procedure Show_ConnectionIdInformation
84724>>>>>        If (ghoConnection > 0) Begin
84726>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
84727>>>>>            Send AppendTextLn ""
84728>>>>>        End
84728>>>>>>
84728>>>>>    End_Procedure
84729>>>>>
84729>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
84731>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
84732>>>>>    End_Function
84733>>>>>
84733>>>>>    Procedure Show_Versions
84735>>>>>        Integer iVersion iRevision iBuild
84735>>>>>
84735>>>>>        Version_information iVersion iRevision iBuild
84737>>>>>
84737>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
84738>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
84739>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
84740>>>>>    End_Procedure
84741>>>>>
84741>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84743>>>>>        Boolean bOK
84743>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
84744>>>>>        Function_Return bOK
84745>>>>>    End_Function
84746>>>>>
84746>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
84748>>>>>        Boolean bOK
84748>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MySQLFlex) to bOK
84749>>>>>        Function_Return bOK
84750>>>>>    End_Function
84751>>>>>
84751>>>>>    //***
84751>>>>>    //*** BW
84751>>>>>    //*** Procedure: Show_Drivers
84751>>>>>    //*** Purpose  : Show loaded database drivers
84751>>>>>    //***
84751>>>>>
84751>>>>>    Procedure Show_Drivers
84753>>>>>        String sDriverID sVersion sClient sMertechSQLFlexVersion sValue
84753>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
84753>>>>>        Handle hoCLIHandler hoBtrvHandler
84753>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
84753>>>>>
84753>>>>>        Move False to bStudioLicense
84754>>>>>
84754>>>>>        Get Create U_cCLIHandler      to hoCLIHandler
84755>>>>>        Get Create U_cDFBtrDrvHandler to hoBtrvHandler
84756>>>>>
84756>>>>>        // For testing purposes:
84756>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
84756>>>>>//        Load_Driver MSSQLDRV_ID
84756>>>>>//        Load_Driver ODBC_DRV_ID
84756>>>>>//        Load_Driver DB2_DRV_ID
84756>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
84756>>>>>//
84756>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
84756>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
84756>>>>>//            Load_Driver SQLFLEX
84756>>>>>//            Load_Driver MDSPgSQL
84756>>>>>//            Load_Driver MDSMySQL
84756>>>>>//            Load_Driver ORAFLEX
84756>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
84756>>>>>//        #ENDIF
84756>>>>>        Move False to Err
84757>>>>>
84757>>>>>        // Loop through all loaded drivers.
84757>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
84760>>>>>        If (iNumberOfDrivers > 1) Begin
84762>>>>>            Send AppendTextLn ""
84763>>>>>        End
84763>>>>>>
84763>>>>>        For iDriver from 1 to iNumberOfDrivers
84769>>>>>>
84769>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
84769>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
84769>>>>>            // would be thrown, so we safeguard from that here.
84769>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
84770>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
84773>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
84774>>>>>            Get IsDAWSQLDriver sDriverID to bIsDAWDriver
84775>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
84776>>>>>
84776>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
84778>>>>>
84778>>>>>                // Pervasive/Btrieve database
84778>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
84780>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
84781>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
84782>>>>>                    If (sClient <> "0.0.0") Begin
84784>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
84785>>>>>                    End
84785>>>>>>
84785>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
84786>>>>>                    If (sClient <> "0.0.0") Begin
84788>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
84789>>>>>                    End
84789>>>>>>
84789>>>>>                End
84789>>>>>>
84789>>>>>
84789>>>>>                Else Begin
84790>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
84791>>>>>                    Move 0 to iNumServers
84792>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
84794>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
84797>>>>>                    End
84797>>>>>>
84797>>>>>
84797>>>>>                    If (bIsDAWDriver = True) Begin
84799>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
84801>>>>>                            // This info is only available for the MS SQL driver:
84801>>>>>                            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient
84804>>>>>                            If (iClient = 13) Move C_$SQLSERVER2016DRVRSTR              to sClient
84807>>>>>                            If (iClient = 12) Move C_$SQLSERVER2014DRVRSTR              to sClient
84810>>>>>                            If (iClient = 11) Move C_$SQL_Server_Native_Client_11_0     to sClient
84813>>>>>                            If (iClient = 10) Move C_$SQL_Server_Native_Client_10_0     to sClient
84816>>>>>                            If (iClient = 9)  Move C_$SQL_Native_Client                 to sClient
84819>>>>>                            If (iClient = 8)  Move C_$SQL_Server_SQL_Server_2000_client to sClient
84822>>>>>                            If (sClient <> "") Begin
84824>>>>>                                Move ("    " + sClient) to sClient
84825>>>>>                            End
84825>>>>>>
84825>>>>>                        End
84825>>>>>>
84825>>>>>
84825>>>>>                        Get CKRevision of hoCLIHandler to sVersion
84826>>>>>                    End
84826>>>>>>
84826>>>>>
84826>>>>>                    If (bIsMertechDriver = True) Begin
84828>>>>>                        GET_DRIVER_REVISION to sVersion
84841>>>>>>
84841>>>>>                    End
84841>>>>>>
84841>>>>>
84841>>>>>                    // If the serialnumber is = 0, it means that the
84841>>>>>                    // Studio licens is in use and there is no
84841>>>>>                    // number of max users defined because the driver is
84841>>>>>                    // relying on the info from the VDF license.
84841>>>>>                    If (bStudioLicense = False) Begin
84843>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
84844>>>>>                        Move (iSerialNo = 0) to bStudioLicense
84845>>>>>                    End
84845>>>>>>
84845>>>>>                End
84845>>>>>>
84845>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
84846>>>>>                If (iNumServers <> 0) Begin
84848>>>>>                    For iCount from 1 to iNumServers
84854>>>>>>
84854>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
84857>>>>>                        Send AppendTextLn ("    " + "Server/DSN:" * sValue)
84858>>>>>                    Loop
84859>>>>>>
84859>>>>>                End
84859>>>>>>
84859>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
84861>>>>>                    Send AppendTextLn sClient
84862>>>>>                End
84862>>>>>>
84862>>>>>            End
84862>>>>>>
84862>>>>>        Loop
84863>>>>>>
84863>>>>>
84863>>>>>        Send AppendTextLn ""
84864>>>>>        If (bStudioLicense = False) Begin
84866>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
84867>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
84868>>>>>        End
84868>>>>>>
84868>>>>>        Else Begin
84869>>>>>            Send AppendTextLn C_$VDF_Studio_License_Text
84870>>>>>        End
84870>>>>>>
84870>>>>>        Send Destroy of hoCLIHandler
84871>>>>>        Send Destroy of hoBtrvHandler
84872>>>>>    End_Procedure
84873>>>>>
84873>>>>>    Procedure Show_HelpFile
84875>>>>>        String sHelpFile
84875>>>>>        Integer eHelpType
84875>>>>>
84875>>>>>        If (ghoApplication <> 0) Begin
84877>>>>>            Get peHelpType Of ghoApplication To eHelpType
84878>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
84880>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
84881>>>>>            End
84881>>>>>>
84881>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
84884>>>>>                Get Help_filename Of Help_object_id To sHelpFile
84885>>>>>            End
84885>>>>>>
84885>>>>>            Else Begin
84886>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
84887>>>>>            End
84887>>>>>>
84887>>>>>
84887>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
84888>>>>>        End
84888>>>>>>
84888>>>>>    End_Procedure
84889>>>>>
84889>>>>>    Procedure Show_EnterAsTab
84891>>>>>        Boolean bEnterKeyAsTabKey
84891>>>>>        String sText
84891>>>>>
84891>>>>>        If (ghoApplication <> 0) Begin
84893>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
84894>>>>>            If (bEnterKeyAsTabKey) Begin
84896>>>>>                Move "True" To sText
84897>>>>>            End
84897>>>>>>
84897>>>>>            Else Begin
84898>>>>>                Move "False" To sText
84899>>>>>            End
84899>>>>>>
84899>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
84900>>>>>        End
84900>>>>>>
84900>>>>>    End_Procedure
84901>>>>>
84901>>>>>    //****************************************************************************
84901>>>>>    // $Module type: PROCEDURE
84901>>>>>    // $Module name: Add_Focus
84901>>>>>    // $Author     : VOO
84901>>>>>    // Created     : 24-09-96 @ 19:43
84901>>>>>    //
84901>>>>>    // Description
84901>>>>>    //    During activation we will remove the old information and add the newly
84901>>>>>    //    found systeminformation
84901>>>>>    //
84901>>>>>    // $Rev History
84901>>>>>    //    24-09-96  Module header created
84901>>>>>    //****************************************************************************
84901>>>>>    Procedure Add_Focus Integer hoRoot
84903>>>>>        Forward Send Add_Focus hoRoot
84905>>>>>
84905>>>>>        Send Delete_Data
84906>>>>>
84906>>>>>        Set Changed_State To False
84907>>>>>        Set Read_Only_State To True
84908>>>>>
84908>>>>>        Send Show_Registration
84909>>>>>        Send Show_Drivers
84910>>>>>        Send AppendTextLn ""
84911>>>>>
84911>>>>>        Send Show_ServicePack
84912>>>>>        If (ghoApplication <> 0) Begin
84914>>>>>            Send Show_WorkSpaceInformation
84915>>>>>            Send Show_HelpFile
84916>>>>>            Send AppendTextLn ""
84917>>>>>        End
84917>>>>>>
84917>>>>>        Else Begin
84918>>>>>            Send AppendTextLn ""
84919>>>>>        End
84919>>>>>>
84919>>>>>
84919>>>>>        If (ghoConnection <> 0) Begin
84921>>>>>            Send Show_ConnectionIdInformation
84922>>>>>        End
84922>>>>>>
84922>>>>>
84922>>>>>        Send Show_Current_User
84923>>>>>        Send Show_Windows_Directory
84924>>>>>        Send Show_Current_Directory
84925>>>>>
84925>>>>>        // This is already shown in the workspace details,
84925>>>>>        // unless no workspace object is present:
84925>>>>>        If (ghoApplication = 0) Begin
84927>>>>>            Send Show_Filelist_Name
84928>>>>>        End
84928>>>>>>
84928>>>>>
84928>>>>>        If (ghoApplication <> 0) Begin
84930>>>>>            Send AppendTextLn ""
84931>>>>>            Send Show_EnterAsTab
84932>>>>>        End
84932>>>>>>
84932>>>>>
84932>>>>>        Send Show_Versions
84933>>>>>        Send Show_Screen_Size
84934>>>>>        Send Show_Page_Size
84935>>>>>        Send Show_Number_Format
84936>>>>>        Send Show_Date_Format
84937>>>>>        Send Show_Lock_Delay
84938>>>>>        Send Show_Lock_Timeout
84939>>>>>        Send Show_Date
84940>>>>>        Send Show_Systemresources
84941>>>>>        Send Beginning_of_Data
84942>>>>>
84942>>>>>        Set Icon to 'default.ico'
84943>>>>>    End_Procedure
84944>>>>>End_Class
84945>>>>>
84945>>>>>//****************************************************************************
84945>>>>>// $Module type: OBJECT
84945>>>>>// $Module name: Sysinfo_Dialog
84945>>>>>// $Author     : VOO
84945>>>>>// Created     : 24-09-96 @ 18:47
84945>>>>>//
84945>>>>>// Description
84945>>>>>//    This object shows the systeminformation on the screen
84945>>>>>//
84945>>>>>// $Rev History
84945>>>>>//    24-09-96  Module header created
84945>>>>>//****************************************************************************
84945>>>>>Class SysInfoDialog is a ModalPanel
84946>>>>>    Procedure Construct_Object
84948>>>>>        Forward Send Construct_Object
84950>>>>>
84950>>>>>        Set Label to C_$SystemInformation
84951>>>>>        Set Size to 140 267
84952>>>>>        Set Locate_Mode to CENTER_ON_PARENT
84953>>>>>        Set Border_Style to Border_Thick
84954>>>>>        Set Sysmenu_Icon to False
84955>>>>>
84955>>>>>        // "+1" will make the panel to paint correctly.
84955>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
84956>>>>>
84956>>>>>        // 2014-09-14 NGS
84956>>>>>        // Added a container object around the cTexteditor
84956>>>>>        // object to get a border around the text.
84956>>>>>        Object oSysinfoDisplayContainer is a Container3d
84958>>>>>            Set Location to 2 4
84959>>>>>            Set Size to 110 255
84960>>>>>            Set Border_Style to Border_ClientEdge
84961>>>>>            Set Color to clWhite
84962>>>>>            Set peAnchors to anAll
84963>>>>>
84963>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
84965>>>>>            End_Object
84966>>>>>
84966>>>>>        End_Object
84967>>>>>
84967>>>>>        Object oCloseButton is a Button
84969>>>>>            Set Label to C_$Close
84970>>>>>            Set Location to 120 210
84971>>>>>            Set Message item 0 to msg_Close_Panel
84972>>>>>            Set Default_State To True
84973>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
84973>>>>>            // and changes its peAnchors, we might as well prepare this object
84973>>>>>            // for that situation.
84973>>>>>            Set peAnchors to anBottomRight
84974>>>>>        End_Object
84975>>>>>
84975>>>>>        Object oCopyButton is a cCopyEditorContentButton
84977>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
84978>>>>>            Set Size to 14 50
84979>>>>>            Set Location to 120 158
84980>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
84980>>>>>            // we might as well prepare the object for it.
84980>>>>>            Set peAnchors to anBottomRight
84981>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
84982>>>>>        End_Object
84983>>>>>
84983>>>>>        On_Key kCancel Send Close_Panel
84984>>>>>    End_Procedure
84985>>>>>
84985>>>>>    Procedure Page Integer iPageObject
84987>>>>>        Handle hMenu
84987>>>>>        Integer iPrevState
84987>>>>>
84987>>>>>        Forward Send Page iPageObject
84989>>>>>
84989>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
84989>>>>>        //
84989>>>>>    End_Procedure
84990>>>>>
84990>>>>>End_Class
84991>>>>>
84991>>>>>Class cAboutEdit is an cRichEdit
84992>>>>>    Procedure Construct_Object
84994>>>>>        Forward Send Construct_Object
84996>>>>>
84996>>>>>        Set Size to 57 153
84997>>>>>        Set Location to 8 60
84998>>>>>
84998>>>>>        Set Read_Only_State to True
84999>>>>>        Set Skip_State to True
85000>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
85000>>>>>        // or 1/20 of a printer's point.
85000>>>>>//        Set piFontSize    to (9 * 20)
85000>>>>>        Set piRightMargin to (0.1 * 1440)
85001>>>>>        Set Border_Style  to Border_None
85002>>>>>    End_Procedure
85003>>>>>
85003>>>>>    // Adds a line of text to the edit object
85003>>>>>    Procedure Add_Line String sVal
85005>>>>>        String sText
85005>>>>>        Address aAddress
85005>>>>>        Get paValue to aAddress
85006>>>>>        Move aAddress to sText
85007>>>>>        Move (sText + String(sVal)) to sVal
85008>>>>>        GetAddress of sVal to aAddress
85009>>>>>        Set paValue to aAddress
85010>>>>>    End_Procedure
85011>>>>>
85011>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
85011>>>>>    // Note that we use the paValue interface,
85011>>>>>    // because the object isn't paged yet when we add the
85011>>>>>    // values and the COM edit object needs to be paged
85011>>>>>    // for the "Set Value" interface to be used.
85011>>>>>    Procedure Add_LineLn String sVal
85013>>>>>        String sText
85013>>>>>        Address aAddress
85013>>>>>        Get paValue to aAddress
85014>>>>>        Move aAddress to sText
85015>>>>>        Move (sText + String(sVal) + Character(10) + Character(13)) to sVal
85016>>>>>        GetAddress of sVal to aAddress
85017>>>>>        Set paValue to aAddress
85018>>>>>    End_Procedure
85019>>>>>
85019>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
85021>>>>>        String sLinkText
85021>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
85022>>>>>        Send Show_HomePage sLinkText
85023>>>>>    End_Procedure
85024>>>>>
85024>>>>>End_Class
85025>>>>>
85025>>>>>// Purpose:
85025>>>>>//
85025>>>>>// Ken Ross 12/17/96 5:16PM
85025>>>>>//
85025>>>>>Class AboutDialog is a ModalPanel
85026>>>>>    Procedure Construct_Object
85028>>>>>
85028>>>>>        Forward Send Construct_Object
85030>>>>>
85030>>>>>        Set Label to C_$About
85031>>>>>        Set Size to 96 230
85032>>>>>        Set Locate_Mode To CENTER_ON_PARENT
85033>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
85034>>>>>//        Set Sysmenu_Icon to True
85034>>>>>
85034>>>>>        Object oSysInfoDialog is a SysInfoDialog
85036>>>>>        End_Object
85037>>>>>
85037>>>>>        Object oBox is a Container3d
85039>>>>>            Set Border_Style to Border_Normal
85040>>>>>            Set Size to 70 220
85041>>>>>            Set Location to 4 5
85042>>>>>            Set Color to clWhite
85043>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
85043>>>>>            // we might as well prepare the object for it.
85043>>>>>            Set peAnchors to anAll
85044>>>>>
85044>>>>>            Object oAboutGraphic is a BitmapContainer
85046>>>>>                Set Border_Style To Border_None
85047>>>>>                Set Bitmap_Style to Bitmap_Center
85048>>>>>                Set Color to clWhite
85049>>>>>                Set Size to 45 50
85050>>>>>                Set Location to 0 3
85051>>>>>            End_Object
85052>>>>>
85052>>>>>            Object oPoweredByVDFGraphic is a cBitmapContainerVDFLink
85054>>>>>                Set Border_Style to Border_None
85055>>>>>                Set Bitmap_Style to Bitmap_Center
85056>>>>>                Set Color to clWhite
85057>>>>>                Set Size to 30 55 //28 50
85058>>>>>                Set Location to 44 3
85059>>>>>            End_Object
85060>>>>>
85060>>>>>            Object oInfoList_Editor is an cAboutEdit
85062>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
85062>>>>>                // we might as well prepare the object for it.
85062>>>>>                Set peAnchors to anAll
85063>>>>>            End_Object
85064>>>>>
85064>>>>>            // These objects are here for backwards compatability only.
85064>>>>>            // They are not used.
85064>>>>>            Object oProductName is a TextBox
85066>>>>>                Set Label To C_$ProductName
85067>>>>>                Set Size To 10 45
85068>>>>>                Set Location To 8 53
85069>>>>>                Set Visible_State to False
85070>>>>>                Set Focus_Mode to NonFocusable
85071>>>>>            End_Object
85072>>>>>
85072>>>>>            Object oVersion is a TextBox
85074>>>>>                Set Label To C_$Version
85075>>>>>                Set Size To 10 25
85076>>>>>                Set Location To 21 53
85077>>>>>                Set Visible_State to False
85078>>>>>                Set Focus_Mode to NonFocusable
85079>>>>>            End_Object
85080>>>>>
85080>>>>>            Object oCopyright is a TextBox
85082>>>>>                Set Label To C_$Copyright
85083>>>>>                Set Size To 10 31
85084>>>>>                Set Location To 34 53
85085>>>>>                Set Visible_State to False
85086>>>>>                Set Focus_Mode to NonFocusable
85087>>>>>            End_Object
85088>>>>>
85088>>>>>            Object oAuthor is a TextBox
85090>>>>>                Set Label To C_$Author
85091>>>>>                Set Size To 10 22
85092>>>>>                Set Location To 46 53
85093>>>>>                Set Visible_State to False
85094>>>>>                Set Focus_Mode to NonFocusable
85095>>>>>            End_Object
85096>>>>>
85096>>>>>        End_Object
85097>>>>>
85097>>>>>        Object oOKButton Is A Button
85099>>>>>            On_Item C_$Close Send Close_Panel
85100>>>>>            Set Location to 78 176
85101>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
85101>>>>>            // we might as well prepare the object for it.
85101>>>>>            Set peAnchors to anBottomRight
85102>>>>>        End_Object
85103>>>>>
85103>>>>>        Object oSysInfoButton Is A Button
85105>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
85106>>>>>            Set Location to 78 123
85107>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
85107>>>>>            // we might as well prepare the object for it.
85107>>>>>            Set peAnchors to anBottomRight
85108>>>>>        End_Object
85109>>>>>
85109>>>>>        Object oCopyButton is a cCopyEditorContentButton
85111>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
85112>>>>>            Set Size to 14 50
85113>>>>>            Set Location to 78 70
85114>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
85114>>>>>            // we might as well prepare the object for it.
85114>>>>>            Set peAnchors to anBottomRight
85115>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
85116>>>>>        End_Object
85117>>>>>
85117>>>>>        On_Key Kcancel Send KeyAction of oOKButton
85118>>>>>        Set Logo    to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
85119>>>>>//        Set LogoVDF to "PoweredByDataFlex.bmp"
85119>>>>>        Set LogoVDF to "PoweredByOrange.bmp"
85120>>>>>    End_Procedure
85121>>>>>
85121>>>>>    Procedure Page Integer iPageObject
85123>>>>>        Handle hMenu
85123>>>>>        Integer iPrevState
85123>>>>>
85123>>>>>        Forward Send Page iPageObject
85125>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
85125>>>>>//        Set Icon to "ActionAbout.ico"
85125>>>>>
85125>>>>>        // Shadow upper left corner menu items: (icon menu items)
85125>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
85126>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
85127>>>>>        // The "Move" menu command may come in handy to have.
85127>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
85127>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
85128>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
85129>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
85130>>>>>        // The "Close" menu command may be good to have.
85130>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
85130>>>>>    End_Procedure
85131>>>>>
85131>>>>>    Procedure Set ProductName String sText
85133>>>>>        Set Value of oProductName to sText
85134>>>>>    End_Procedure
85135>>>>>
85135>>>>>    Procedure Set Copyright String sText
85137>>>>>        Set Value of oCopyright to sText
85138>>>>>    End_Procedure
85139>>>>>
85139>>>>>    Procedure Set Author String sText
85141>>>>>        Set Value of oAuthor to sText
85142>>>>>    End_Procedure
85143>>>>>
85143>>>>>    Procedure Set Version String sVersion
85145>>>>>        Handle hoVersionInfo
85145>>>>>        Boolean bIncluded
85145>>>>>        Integer iMajor iMinor iRelease iBuild
85145>>>>>        Date dCompileDate
85145>>>>>
85145>>>>>        If (sVersion = "") Begin
85147>>>>>            // This automatically shows the program version of the program, if available.
85147>>>>>            // It will be displayed as the second item in the edit object.
85147>>>>>            If (ghoApplication <> 0) Begin
85149>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
85150>>>>>                If (hoVersionInfo <> 0) Begin
85152>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
85153>>>>>                    If (bIncluded) Begin
85155>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
85156>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
85157>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
85158>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
85159>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
85160>>>>>                    End
85160>>>>>>
85160>>>>>                End
85160>>>>>>
85160>>>>>            End
85160>>>>>>
85160>>>>>        End
85160>>>>>>
85160>>>>>
85160>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
85160>>>>>        Get GetCompileDate to dCompileDate
85161>>>>>        If (sVersion <> "") Begin
85163>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
85164>>>>>        End
85164>>>>>>
85164>>>>>    End_Procedure
85165>>>>>
85165>>>>>    Function GetCompileDate Returns Date
85167>>>>>        Date dCompileDate
85167>>>>>        String sAppFilename sData sCompileDate
85167>>>>>        Integer iChannel iPos iDateFormat
85167>>>>>
85167>>>>>        // Get full path to the current running executable
85167>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
85168>>>>>
85168>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
85168>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
85169>>>>>        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
85171>>>>>        Read_Block channel iChannel sData 75            // The compile information we're interested in
85173>>>>>        Send Seq_Close_Channel iChannel
85174>>>>>
85174>>>>>        // The data is padded with Character(0)s. Strip them out
85174>>>>>        Move (CString(sData)) to sData
85175>>>>>
85175>>>>>        // The compile date is after the first ", ", so string parsing is required
85175>>>>>        Move (Pos(", ", sData)) to iPos
85176>>>>>        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
85177>>>>>        // If the current date format is non US, we need to temporary
85177>>>>>        // change the format and then move the string to the date variable.
85177>>>>>        Get_Attribute DF_DATE_FORMAT        to iDateFormat
85180>>>>>        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
85183>>>>>        Move (Date(sCompileDate))           to dCompileDate
85184>>>>>        Set_Attribute DF_DATE_FORMAT        to iDateFormat // Reset date format
85187>>>>>
85187>>>>>        Function_Return dCompileDate
85188>>>>>    End_Function
85189>>>>>
85189>>>>>    Procedure Add_LineLn String sValue
85191>>>>>        Send Add_LineLn of oInfoList_Editor sValue
85192>>>>>    End_Procedure
85193>>>>>
85193>>>>>    Procedure Add_Line String sValue
85195>>>>>        Send Add_Line of oInfoList_Editor sValue
85196>>>>>    End_Procedure
85197>>>>>
85197>>>>>    Procedure Set Logo string sLogo
85199>>>>>        // Square bitmaps of 80x80 work best
85199>>>>>        Set Bitmap of oAboutGraphic to sLogo
85200>>>>>    End_Procedure
85201>>>>>
85201>>>>>    Procedure Set LogoVDF String sLogo
85203>>>>>        Set Bitmap of oPoweredByVDFGraphic to sLogo
85204>>>>>    End_Procedure
85205>>>>>
85205>>>>>    Procedure Show_Sysinfo
85207>>>>>        Send Popup_Modal of oSysinfoDialog
85208>>>>>    End_Procedure
85209>>>>>
85209>>>>>    Procedure Show_HomePage String sWebpage
85211>>>>>        Handle hWnd hInstance
85211>>>>>        Get Window_Handle to hWnd
85212>>>>>        Move (ShellExecute(hWnd, "open", (Trim(sWebpage)), "", "", 1)) to hInstance
85213>>>>>    End_Procedure
85214>>>>>
85214>>>>>//    Procedure End_Construct_Object
85214>>>>>//        Handle hoVersionInfo
85214>>>>>//        Boolean bIncluded
85214>>>>>//        Integer iMajor iMinor iRelease iBuild
85214>>>>>//        String sLabel sVersion
85214>>>>>//
85214>>>>>//        If (sVersion = "") Begin
85214>>>>>//            // This automatically shows the program version of the program, if available.
85214>>>>>//            // It will be displayed as the last item in the edit object.
85214>>>>>//            If (ghoApplication <> 0) Begin
85214>>>>>//                Get phoVersionInfo of ghoApplication to hoVersionInfo
85214>>>>>//                If (hoVersionInfo <> 0) Begin
85214>>>>>//                    Get pbIncluded of hoVersionInfo to bIncluded
85214>>>>>//                    If (bIncluded) Begin
85214>>>>>//                        Get piVersionMajor of hoVersionInfo to iMajor
85214>>>>>//                        Get piVersionMinor of hoVersionInfo to iMinor
85214>>>>>//                        Get piVersionRelease of hoVersionInfo to iRelease
85214>>>>>//                        Get piVersionBuild of hoVersionInfo to iBuild
85214>>>>>//                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
85214>>>>>//                        Set Version to sLabel
85214>>>>>//                    End
85214>>>>>//                End
85214>>>>>//            End
85214>>>>>//        End
85214>>>>>//
85214>>>>>//        Forward Send End_Construct_Object
85214>>>>>//    End_Procedure
85214>>>>>
85214>>>>>End_Class
85215>>>
85215>>>// *************************************************************************
85215>>>//  Public message. This is the default message. It is expected that you will
85215>>>//   create your own message to override this
85215>>>// *************************************************************************
85215>>>
85215>>>Procedure Activate_About
85218>>>   Send DoAbout "" "" "" "" ""
85219>>>End_Procedure
85220>>>
85220>>>// *************************************************************************
85220>>>//  Public message. It is expected that you will send this message (most
85220>>>//  likely from Activate_About. This creates an about object, activates it
85220>>>//  and destroys it when done. It is not exepected that you will augment this.
85220>>>// *************************************************************************
85220>>>// Sample usage:
85220>>>//   The first two params will automatically be filled from the application settings if not provided.
85220>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
85220>>>
85220>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;                  String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
85223>>>        Integer hoObj hoMain iArgs
85223>>>        String sValue
85223>>>
85223>>>        // Create object
85223>>>        Object About is an AboutDialog
85225>>>            // Uncomment these two lines if you would like to have a resizable About object.
85225>>>//            Set Border_Style to Border_Thick
85225>>>//            Set peAnchors to anAll
85225>>>
85225>>>            // Add checking for the number of arguments passed to avoid runtime errors
85225>>>            // if one of them is not passed. This makes the interface
85225>>>            // more flexible.
85225>>>            Move num_arguments to iArgs
85226>>>
85226>>>            // If no title is passed use the label of the main panel (if a main panel exists).
85226>>>            If (iArgs > 0 and sTitle = "") Begin
85228>>>                Get Main_Window of Desktop to hoMain
85229>>>                If hoMain Get Label of hoMain to sValue
85232>>>            End
85232>>>>
85232>>>            Else If (iArgs > 0 and sTitle <> "") Begin
85235>>>                Move sTitle to sValue
85236>>>            End
85236>>>>
85236>>>            Else If (iArgs = 0) Begin
85239>>>                Get Main_Window of Desktop to hoMain
85240>>>                If hoMain Get Label of hoMain to sValue
85243>>>            End
85243>>>>
85243>>>
85243>>>            If (sValue <> "") Send Add_LineLn sValue
85246>>>            Move "" to sValue
85247>>>
85247>>>            // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
85247>>>            // For this to work the Project Properties Version must have been set in the Studio.
85247>>>            If (iArgs < 2) Begin
85249>>>                Move "" to sValue
85250>>>            End
85250>>>>
85250>>>            Else Begin
85251>>>                Move sVersion to sValue
85252>>>            End
85252>>>>
85252>>>            Set Version to sValue
85253>>>
85253>>>            If (iArgs > 2 and sCopyRight <> "") Send Add_LineLn sCopyRight
85256>>>
85256>>>            // If only the five "standard" params were passed we don't add an extra linefeed;
85256>>>            // else we do.
85256>>>            If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
85258>>>                Send Add_Line sAuthor
85259>>>            End
85259>>>>
85259>>>            Else If (iArgs > 5 and sAuthor <> "") Begin
85262>>>                Send Add_LineLn sAuthor
85263>>>            End
85263>>>>
85263>>>
85263>>>            // Square bitmaps of 80x80 works best
85263>>>            If (iArgs > 4 and sBitmap <> "") Begin
85265>>>               Set Logo to sBitMap
85266>>>            End
85266>>>>
85266>>>
85266>>>            // Here starts handling of the five optional params:
85266>>>            If (iArgs = 6 and sParam6  <> "") Begin
85268>>>                Send Add_Line sParam6
85269>>>            End
85269>>>>
85269>>>            Else If (iArgs > 6 and sParam6  <> "") Begin
85272>>>                Send Add_LineLn sParam6
85273>>>            End
85273>>>>
85273>>>
85273>>>            If (iArgs = 7 and sParam7  <> "") Begin
85275>>>                Send Add_Line sParam7
85276>>>            End
85276>>>>
85276>>>            Else If (iArgs > 7 and sParam7  <> "") Begin
85279>>>                Send Add_LineLn sParam7
85280>>>            End
85280>>>>
85280>>>
85280>>>            If (iArgs = 8 and sParam8  <> "") Begin
85282>>>                Send Add_Line sParam8
85283>>>            End
85283>>>>
85283>>>            Else If (iArgs > 8 and sParam8  <> "") Begin
85286>>>                Send Add_LineLn sParam8
85287>>>            End
85287>>>>
85287>>>
85287>>>            If (iArgs = 9 and sParam9  <> "") Begin
85289>>>                Send Add_Line sParam9
85290>>>            End
85290>>>>
85290>>>            Else If (iArgs > 9 and sParam9  <> "") Begin
85293>>>                Send Add_LineLn sParam9
85294>>>            End
85294>>>>
85294>>>
85294>>>            If (iArgs = 10 and sParam10 <> "") Begin
85296>>>                Send Add_Line sParam10
85297>>>            End
85297>>>>
85297>>>
85297>>>            Move Self to hoObj
85298>>>        End_Object
85299>>>
85299>>>        Send Popup   of hoObj // Popup the about object
85300>>>        Send Destroy of hoObj // When done, it will be destroyed
85301>>>End_Procedure
85302>        Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
85302>>>Use Windows.pkg
85302>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCJGridPromptList.pkg)
85302>>>>>Use Windows.pkg
85302>>>>>Use cCJGrid.pkg
85302>>>>>
85302>>>>>
85302>>>>>
85302>>>>>Class cCJGridPromptList is a cCJGrid
85303>>>>>
85303>>>>>    Procedure Construct_Object
85305>>>>>        Forward Send Construct_Object
85307>>>>>
85307>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
85308>>>>>        Property Boolean Private_pbAutoOrdering True
85309>>>>>        Property Boolean pbAutoSearch True  // pops up search window
85310>>>>>        Property Integer peUpdateMode umPromptValue
85311>>>>>        Property Integer piUpdateColumn 0
85312>>>>>        Property Integer piInitialColumn -1
85313>>>>>        Property String  psSeedValue ''
85314>>>>>        Property Handle phmPromptUpdateCallback 0
85315>>>>>        Property Integer phoInvokingObject
85316>>>>>        
85316>>>>>        Property Boolean pbStoredAutoSeed
85317>>>>>        Property Boolean pbStoredAutoOrdering
85318>>>>>        Property Boolean pbStoredAutoSearch
85319>>>>>        Property Integer peStoredUpdateMode
85320>>>>>        Property Integer piStoredUpdateColumn
85321>>>>>        Property Integer piStoredInitialColumn
85322>>>>>        Property Handle  phmStoredPromptUpdateCallback
85323>>>>>        Property Boolean pbStoredSelectionEnable
85324>>>>>        Property Boolean pbStoredMultipleSelection
85325>>>>>
85325>>>>>        // internally set by list
85325>>>>>        // these must be set upon closing the list and can be used for manual list updates
85325>>>>>        Property Boolean pbCanceled
85326>>>>>        Property Integer[] pSelectedRows
85327>>>>>
85327>>>>>        Property Boolean pbNeedsNewOrdering
85328>>>>>        Property Boolean pbRequestSearch
85329>>>>>        Property tGridKeyPair[] pSearchKeys
85330>>>>>        
85330>>>>>        // these properties makes a prompt list a prompt list
85330>>>>>        // and should not be changed.
85330>>>>>        Set pbEditOnKeyNavigation to False
85331>>>>>        Set pbEditOnClick to False
85332>>>>>        Set pbReadOnly to True
85333>>>>>        Set pbFocusSubItems to True
85334>>>>>        
85334>>>>>        // these could maybe be changed
85334>>>>>        Set pbShadeSortColumn to True
85335>>>>>        Set pbHeaderReorders to True
85336>>>>>        Set pbHeaderTogglesDirection to True
85337>>>>>        Set pbHeaderSelectsColumn to True
85338>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
85339>>>>>        Set piFocusCellBackColor to clNone
85340>>>>>        Set piFocusCellForeColor to clNone
85341>>>>>        Set piFocusCellRectangleColor to clBlack
85342>>>>>        Set pbUseFocusCellRectangle to False
85343>>>>>        Set pbSelectionEnable to True
85344>>>>>        
85344>>>>>        On_Key kEnter Send Ok
85345>>>>>        On_Key kCancel Send Cancel
85346>>>>>
85346>>>>>    End_Procedure
85347>>>>>    
85347>>>>>    // reorder list automatically on column change
85347>>>>>    // this also set pbFocusSubItems which is required to make the two states work
85347>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
85349>>>>>        Set Private_pbAutoOrdering to bAutoOrder
85350>>>>>        Set pbFocusSubItems to bAutoOrder
85351>>>>>    End_Procedure
85352>>>>>    
85352>>>>>    Function pbAutoOrdering Returns Boolean
85354>>>>>        Boolean bAutoOrder
85354>>>>>        Get Private_pbAutoOrdering to bAutoOrder
85355>>>>>        Function_Return bAutoOrder
85356>>>>>    End_Function
85357>>>>>
85357>>>>>    // augmented to handle auto-ordering and invoking the search popup list
85357>>>>>    Procedure OnIdle
85359>>>>>        Boolean bNeedsReorder bSearch bOldToggle
85359>>>>>        Handle hoCol
85359>>>>>        Integer iKy1 iKy2 iCol
85359>>>>>
85359>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
85360>>>>>        If bNeedsReorder Begin
85362>>>>>            Get SelectedColumn to iCol
85363>>>>>            If (iCol<>-1) Begin
85365>>>>>                
85365>>>>>                Get pbHeaderTogglesDirection to bOldToggle
85366>>>>>                Set pbHeaderTogglesDirection to False
85367>>>>>                Send HeaderReorder iCol
85368>>>>>                Set pbHeaderTogglesDirection to bOldToggle
85369>>>>>                
85369>>>>>                Set pbNeedsNewOrdering to False
85370>>>>>            End
85370>>>>>>
85370>>>>>        End
85370>>>>>>
85370>>>>>        
85370>>>>>        Get pbRequestSearch to bSearch
85371>>>>>        If bSearch Begin
85373>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
85374>>>>>        End
85374>>>>>>
85374>>>>>        
85374>>>>>        Forward Send OnIdle
85376>>>>>    End_Procedure
85377>>>>>    
85377>>>>>    Procedure OnStoreDefaults
85379>>>>>        Integer iVal
85379>>>>>        Boolean bVal
85379>>>>>
85379>>>>>        Get pbAutoSeed to bVal           
85380>>>>>        Set pbStoredAutoSeed to bVal           
85381>>>>>        
85381>>>>>        Get pbAutoOrdering to bVal        
85382>>>>>        Set pbStoredAutoOrdering to bVal      
85383>>>>>        
85383>>>>>        Get pbAutoSearch to bVal         
85384>>>>>        Set pbStoredAutoSearch to bVal         
85385>>>>>        
85385>>>>>        Get peUpdateMode to iVal
85386>>>>>        Set peStoredUpdateMode to iVal
85387>>>>>        
85387>>>>>        Get piUpdateColumn to iVal       
85388>>>>>        Set piStoredUpdateColumn to iVal       
85389>>>>>
85389>>>>>        Get piInitialColumn to iVal       
85390>>>>>        Set piStoredInitialColumn to iVal       
85391>>>>>
85391>>>>>        Get phmPromptUpdateCallback to iVal       
85392>>>>>        Set phmStoredPromptUpdateCallback to iVal       
85393>>>>>
85393>>>>>        Get pbSelectionEnable to bVal
85394>>>>>        Set pbStoredSelectionEnable to bVal
85395>>>>>        
85395>>>>>        Get pbMultipleSelection to bVal
85396>>>>>        Set pbStoredMultipleSelection to bVal
85397>>>>>        
85397>>>>>    End_Procedure
85398>>>>>
85398>>>>>    Procedure OnRestoreDefaults
85400>>>>>        Integer iVal
85400>>>>>        Boolean bVal
85400>>>>>
85400>>>>>        Get pbStoredAutoSeed to bVal           
85401>>>>>        Set pbAutoSeed to bVal           
85402>>>>>        
85402>>>>>        Get pbStoredAutoOrdering to bVal        
85403>>>>>        Set pbAutoOrdering to bVal      
85404>>>>>        
85404>>>>>        Get pbStoredAutoSearch to bVal         
85405>>>>>        Set pbAutoSearch to bVal         
85406>>>>>        
85406>>>>>        Get peStoredUpdateMode to iVal
85407>>>>>        Set peUpdateMode to iVal
85408>>>>>        
85408>>>>>        Get piStoredInitialColumn to iVal       
85409>>>>>        Set piInitialColumn to iVal       
85410>>>>>        
85410>>>>>        Get phmStoredPromptUpdateCallback to iVal       
85411>>>>>        Set phmPromptUpdateCallback to iVal       
85412>>>>>
85412>>>>>        Get pbStoredSelectionEnable to bVal
85413>>>>>        Set pbSelectionEnable to bVal
85414>>>>>        
85414>>>>>        Get pbStoredMultipleSelection to bVal
85415>>>>>        Set pbMultipleSelection to bVal
85416>>>>>
85416>>>>>    End_Procedure
85417>>>>>    
85417>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
85417>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
85417>>>>>    // Suitable for augmentation
85417>>>>>    Procedure OnSeedData
85419>>>>>        Integer iUpdateColumn iSortColumn
85419>>>>>        Boolean bSeed bAuto
85419>>>>>        String sValue
85419>>>>>        Handle hoCol
85419>>>>>
85419>>>>>        Get piUpdateColumn to iUpdateColumn
85420>>>>>        Get psSeedValue to sValue
85421>>>>>        Get pbAutoSeed to bSeed
85422>>>>>        Get piSortColumn to iSortColumn
85423>>>>>        Get pbAutoOrdering to bAuto
85424>>>>>        // if not yet sorted and this is auto ordering we will
85424>>>>>        // sort the data for the search column. We do this to make the
85424>>>>>        // column search GE logic work properly. 
85424>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
85426>>>>>            Get ColumnObject iUpdateColumn to hoCol
85427>>>>>            Send SortGridByColumn hoCol False
85428>>>>>        End
85428>>>>>>
85428>>>>>
85428>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
85430>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0  
85431>>>>>        End
85431>>>>>>
85431>>>>>        Else Begin
85432>>>>>            Send MovetoFirstRow
85433>>>>>        End
85433>>>>>>
85433>>>>>
85433>>>>>    End_Function
85434>>>>>
85434>>>>>    Procedure OnMoveValueOutByValue
85436>>>>>        String sValue
85436>>>>>        Handle hoInvokingObject hoCol  hoDataSource
85436>>>>>        Integer iRow iCol
85436>>>>>        Integer[] SelRowsIndexes
85437>>>>>
85437>>>>>        Get phoInvokingObject to hoInvokingObject
85438>>>>>        Get pSelectedRows to SelRowsIndexes
85439>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
85441>>>>>            Get piUpdateColumn to iCol
85442>>>>>            Get ColumnObject iCol to hoCol
85443>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
85444>>>>>            Set Value of hoInvokingObject to sValue
85445>>>>>            Set Item_Changed_State of hoInvokingObject to True
85446>>>>>        End
85446>>>>>>
85446>>>>>    End_Procedure
85447>>>>>
85447>>>>>    Procedure OnMoveValueOutByCustom
85449>>>>>    End_Procedure
85450>>>>>
85450>>>>>    // augment to popup a search window when allowed
85450>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
85452>>>>>        Boolean bSubFocus bAutoSearch bChar
85452>>>>>        Integer iVal
85452>>>>>        
85452>>>>>        Get pbFocusSubItems to bSubFocus
85453>>>>>        Get pbAutoSearch to bAutoSearch
85454>>>>>        Forward Send OnComKeyDown llKeyCode llShift
85456>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
85458>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
85460>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
85461>>>>>                Move (iVal<>0) to bChar
85462>>>>>            End
85462>>>>>>
85462>>>>>            If bChar Begin
85464>>>>>                // this can get called multiple times before a search dialog pops up
85464>>>>>                Send AddToSearchKeys llKeyCode llShift
85465>>>>>            End
85465>>>>>>
85465>>>>>        End
85465>>>>>>
85465>>>>>    End_Procedure
85466>>>>>    
85466>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
85468>>>>>        Boolean bAutoSearch
85468>>>>>        Integer iKeyCode iShiftCode
85468>>>>>        Get pbAutoSearch to bAutoSearch
85469>>>>>        If bAutoSearch Begin
85471>>>>>            // this can get called multiple times before a search dialog pops up
85471>>>>>            Get piLastKey to iKeyCode
85472>>>>>            Get piLastKey2 to iShiftCode
85473>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
85474>>>>>        End
85474>>>>>>
85474>>>>>        Move True to llCancel
85475>>>>>    End_Procedure  // OnComRequestEdit
85476>>>>>    
85476>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
85478>>>>>        Send ClearSearchRequest // kill any deferred search popup
85479>>>>>        Forward Send OnComRowDblClick llRow llItem
85481>>>>>    End_Procedure
85482>>>>>    
85482>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
85484>>>>>        Send Ok
85485>>>>>    End_Procedure
85486>>>>>    
85486>>>>>    
85486>>>>>    // we don't want a menu for prompt lists
85486>>>>>    Function CreateContextMenu Returns Handle
85488>>>>>        Function_Return 0
85489>>>>>    End_Function
85490>>>>>
85490>>>>>    // if we use auto-ordering, change the order when the column changes
85490>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
85492>>>>>        Boolean bAutoOrder
85492>>>>>        Forward Send ColumnChanged iOld iNew
85494>>>>>        Get pbAutoOrdering to bAutoOrder
85495>>>>>        If bAutoOrder Begin
85497>>>>>            // will be reordered in idle event
85497>>>>>            Set pbNeedsNewOrdering to True
85498>>>>>        End
85498>>>>>>
85498>>>>>    End_Procedure
85499>>>>>    
85499>>>>>
85499>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
85501>>>>>        Integer eMode
85501>>>>>        Integer[] SelRowsIndexes
85502>>>>>        Set pbCanceled to True // assume cancel unless changed
85503>>>>>        Set pSelectedRows to SelRowsIndexes // empty
85504>>>>>        Get peUpdateMode to eMode
85505>>>>>        If (eMode<>umPromptNonInvoking) Begin
85507>>>>>            Send OnStoreDefaults
85508>>>>>        End
85508>>>>>>
85508>>>>>        Send InitializePromptList
85509>>>>>        Forward Send Add_Focus hoParent
85511>>>>>        Send LoadData
85512>>>>>        Set psSeedValue to ""
85513>>>>>    End_Procedure
85514>>>>>    
85514>>>>>    // called before the list is activated. 
85514>>>>>    Procedure InitializePromptList
85516>>>>>        Integer hoInvokingObject
85516>>>>>        Boolean bAutoColumn bAutoSeed 
85516>>>>>        Integer i iOldMode eUpdateMode
85516>>>>>        String sValue
85516>>>>>        
85516>>>>>        Get peUpdateMode to eUpdateMode
85517>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
85519>>>>>            Get Focus of Desktop to hoInvokingObject
85520>>>>>            If (hoInvokingObject<=Desktop) Begin
85522>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
85523>>>>>>
85523>>>>>                Procedure_Return
85524>>>>>            End
85524>>>>>>
85524>>>>>
85524>>>>>            Set phoInvokingObject to hoInvokingObject
85525>>>>>
85525>>>>>            Send Prompt_Callback to hoInvokingObject Self
85526>>>>>            Get peUpdateMode to eUpdateMode
85527>>>>>        End
85527>>>>>>
85527>>>>>
85527>>>>>        Send ClearSearchRequest // clear the search keys
85528>>>>>        Set pbNeedsNewOrdering to False
85529>>>>>
85529>>>>>        Get pbAutoSeed to bAutoSeed
85530>>>>>
85530>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
85532>>>>>            Get Value of hoInvokingObject to sValue
85533>>>>>            Set psSeedValue to sValue
85534>>>>>        End
85534>>>>>>
85534>>>>>        
85534>>>>>    End_Procedure
85535>>>>>    
85535>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
85535>>>>>    Procedure LoadData
85537>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
85537>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
85537>>>>>        Integer eUpdateMode
85537>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder 
85537>>>>>        
85537>>>>>        Get phoDataSource to hoDataSource
85538>>>>>        Get peUpdateMode to eUpdateMode
85539>>>>>        Get phoInvokingObject to hoInvokingObject
85540>>>>>        Get pbAutoSeed to bAutoSeed
85541>>>>>        Get piInitialColumn to iInitialColumn
85542>>>>>        Get piUpdateColumn to iUpdateColumn
85543>>>>>        Get RowCount of hoDataSource to iRows
85544>>>>>        
85544>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
85544>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
85544>>>>>        If (iInitialColumn=-1) Begin
85546>>>>>            Move iUpdateColumn to iInitialColumn
85547>>>>>        End
85547>>>>>>
85547>>>>>        If (iInitialColumn>=0) Begin
85549>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
85550>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
85551>>>>>        End
85551>>>>>>
85551>>>>>        Send OnSeedData // find a good starting place for the row
85552>>>>>        Get pbFocusSubItems to bSubFocus
85553>>>>>        If bSubFocus Begin
85555>>>>>            // if column focus, which is normal, go to initialcolumn       
85555>>>>>            If hoInitialColumn Begin
85557>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
85558>>>>>            End
85558>>>>>>
85558>>>>>            Else Begin
85559>>>>>                Send MoveToFirstEnterableColumn
85560>>>>>            End
85560>>>>>>
85560>>>>>        End
85560>>>>>>
85560>>>>>
85560>>>>>    End_Procedure
85561>>>>>    
85561>>>>>    // This is only called in a successful close
85561>>>>>    Procedure ClosePromptList
85563>>>>>        Handle hoDataSource hoInvokingObject
85563>>>>>        Handle hmCallBack
85563>>>>>        Integer iRow eUpdateMode
85563>>>>>        Integer[] SelRowsIndexes
85564>>>>>        
85564>>>>>        Get phoDataSource to hoDataSource
85565>>>>>        Get phoInvokingObject to hoInvokingObject
85566>>>>>        
85566>>>>>        If (pbMultipleSelection(Self)) Begin
85568>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
85569>>>>>        End
85569>>>>>>
85569>>>>>        Else Begin
85570>>>>>            Get SelectedRow of hoDataSource to iRow
85571>>>>>            If (iRow<>-1) Begin
85573>>>>>                Move iRow to SelRowsIndexes[0]
85574>>>>>            End
85574>>>>>>
85574>>>>>        End
85574>>>>>>
85574>>>>>        
85574>>>>>        Set pbCanceled to False
85575>>>>>        Set pSelectedRows to SelRowsIndexes
85576>>>>>        
85576>>>>>        Get peUpdateMode to eUpdateMode
85577>>>>>        // if non-invoking there is by definition, no move value out
85577>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
85579>>>>>            
85579>>>>>            If (eUpdateMode=umPromptValue) Begin
85581>>>>>                Send OnMoveValueOutByValue
85582>>>>>            End
85582>>>>>>
85582>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
85585>>>>>                Send OnMoveValueOutByCustom
85586>>>>>            End
85586>>>>>>
85586>>>>>                Get phmPromptUpdateCallback to hmCallBack
85587>>>>>                If hmCallBack Begin
85589>>>>>                    Send hmCallBack of hoInvokingObject Self
85590>>>>>                End
85590>>>>>>
85590>>>>>        End
85590>>>>>>
85590>>>>>
85590>>>>>        Send Close_Panel
85591>>>>>    End_Procedure
85592>>>>>
85592>>>>>    // augment to send OnRestoreDefaults.
85592>>>>>    Procedure Release_Focus
85594>>>>>        Integer eUpdateMode
85594>>>>>        Get peUpdateMode to eUpdateMode
85595>>>>>        Forward Send Release_Focus
85597>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
85599>>>>>            Send OnRestoreDefaults
85600>>>>>        End
85600>>>>>>
85600>>>>>    End_Procedure
85601>>>>>    
85601>>>>>    Function SelectedRowIds Returns RowID[]
85603>>>>>        RowID[] SelectedRowids
85604>>>>>        Integer[] SelectedRows
85605>>>>>        Integer i iRows
85605>>>>>        Handle hoDataSource
85605>>>>>        Get phoDataSource to hoDataSource
85606>>>>>        Get pSelectedRows to SelectedRows
85607>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
85608>>>>>        For i from 0 to (iRows-1)
85614>>>>>>
85614>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
85615>>>>>        Loop
85616>>>>>>
85616>>>>>        Function_Return SelectedRowids
85617>>>>>    End_Function
85618>>>>>
85618>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
85620>>>>>        String[] SelectedValues
85621>>>>>        Integer[] SelectedRows
85622>>>>>        Integer i iRows
85622>>>>>        Handle hoCol
85622>>>>>        Get ColumnObject iCol to hoCol
85623>>>>>        Get pSelectedRows to SelectedRows
85624>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
85625>>>>>        For i from 0 to (iRows-1)
85631>>>>>>
85631>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
85632>>>>>        Loop
85633>>>>>>
85633>>>>>        Function_Return SelectedValues
85634>>>>>    End_Function
85635>>>>>
85635>>>>>    Procedure Ok Returns Integer
85637>>>>>        Send ClosePromptList
85638>>>>>    End_Procedure
85639>>>>>
85639>>>>>    Procedure Cancel Returns Integer
85641>>>>>        Send Close_Panel
85642>>>>>    End_Procedure
85643>>>>>        
85643>>>>>    Procedure Search
85645>>>>>        Send Activate // give focus back to list so focus things are correct
85646>>>>>        Send Request_Search 0 0
85647>>>>>    End_Procedure
85648>>>>>    
85648>>>>>    // do a search using the current keys in the search key buffer for the sort column.
85648>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
85648>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
85648>>>>>    Procedure Request_SearchEx
85650>>>>>        tGridKeyPair[] Keys
85650>>>>>        tGridKeyPair[] Keys
85651>>>>>        Integer iCol
85651>>>>>        Handle hoCol hoSearchDialog 
85651>>>>>        Boolean bOk
85651>>>>>        String sValue
85651>>>>>
85651>>>>>        Get piSortColumn to iCol
85652>>>>>        If (iCol<>-1) Begin
85654>>>>>            Get ColumnObject iCol to hoCol
85655>>>>>                Get pSearchKeys to Keys
85656>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
85657>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
85658>>>>>            If bOk Begin
85660>>>>>               Send RequestFindColumnValue iCol sValue True 0  
85661>>>>>            End
85661>>>>>>
85661>>>>>            Send Destroy of hoSearchDialog
85662>>>>>        End
85662>>>>>>
85662>>>>>        Send ClearSearchRequest // clear the search keys
85663>>>>>    End_Procedure
85664>>>>>    
85664>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
85664>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
85666>>>>>        tGridKeyPair[] Keys
85666>>>>>        tGridKeyPair[] Keys
85667>>>>>        tGridKeyPair KeyPair
85667>>>>>        tGridKeyPair KeyPair
85667>>>>>        Set pbRequestSearch to True
85668>>>>>        Move iKeyCode to KeyPair.KeyCode
85669>>>>>        Move iShiftCode to KeyPair.ShiftCode
85670>>>>>        Get pSearchKeys to Keys                
85671>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
85672>>>>>        Set pSearchKeys to Keys                
85673>>>>>    End_Procedure
85674>>>>>
85674>>>>>    Procedure ClearSearchRequest
85676>>>>>        tGridKeyPair[] SearchKeys
85676>>>>>        tGridKeyPair[] SearchKeys
85677>>>>>        Set pSearchKeys to SearchKeys
85678>>>>>        Set pbRequestSearch to False
85679>>>>>    End_Procedure
85680>>>>>    
85680>>>>>End_Class
85681>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
85681>>>>>//****************************************************************************
85681>>>>>// $Module type: Class
85681>>>>>// $Module name: cDbUpdateFunctionLibrary
85681>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
85681>>>>>// Web-site    : http://www.rdctools.com
85681>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
85681>>>>>//
85681>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
85681>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
85681>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
85681>>>>>//               with the help of Sql-scripts.
85681>>>>>//
85681>>>>>// $Rev History:
85681>>>>>//    2014-09-05  Module header created
85681>>>>>//
85681>>>>>//****************************************************************************
85681>>>>>Use cApplication.pkg
85681>>>>>Use seq_chnl.pkg
85681>>>>>Use GlobalFunctionsProcedures.pkg
85681>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
85681>>>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
85681>>>>>>>// StatPnl.pkg - creates the standard status_panel object.
85681>>>>>>>//
85681>>>>>>>//
85681>>>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
85681>>>>>>>// invoke the standard status panel. The standard has always been that the package name
85681>>>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
85681>>>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
85681>>>>>>>// prior revisions has been replace with status panel that is part of the application.
85681>>>>>>>// This should work much better and faster than the old sentinel based solution.
85681>>>>>>>// While the way this operates has changed, the interface has not and therefore this should work
85681>>>>>>>// with most applications.
85681>>>>>>>//
85681>>>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
85681>>>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
85681>>>>>>>// a cleaner more robust interface.
85681>>>>>>>//
85681>>>>>>>//
85681>>>>>>>// Compatibility Note:
85681>>>>>>>//
85681>>>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
85681>>>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
85681>>>>>>>//
85681>>>>>>>// If for some reason you application will not work using this as a replacement for the old status
85681>>>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
85681>>>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
85681>>>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
85681>>>>>>>//
85681>>>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
85681>>>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
85681>>>>>>>//
85681>>>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
85681>>>>>>>// can still access the new object via the ghoStatusPanel handle.
85681>>>>>>>//
85681>>>>>>>//
85681>>>>>>>// Creating your own Status Panel objects
85681>>>>>>>//
85681>>>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
85681>>>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
85681>>>>>>>// with a different file and object name and direct your status panel request to the new object.
85681>>>>>>>//
85681>>>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
85681>>>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
85681>>>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
85681>>>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
85681>>>>>>>// e.g.
85681>>>>>>>//       Procedure UpdateStatusBar
85681>>>>>>>//           Send DoAdvance of oProgressBar
85681>>>>>>>//           Send ProcessEvents
85681>>>>>>>//       End_Procedure
85681>>>>>>>//
85681>>>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
85681>>>>>>>// messages this will be done for you.
85681>>>>>>>//
85681>>>>>>>// the standard Interface for status panels are:
85681>>>>>>>//
85681>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
85681>>>>>>>// Send Start_StatusPanel      - start the status panel
85681>>>>>>>// Send Stop_StatusPanel       - stop the status panel
85681>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
85681>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
85681>>>>>>>//
85681>>>>>>>// Get/Set Caption_Text - updates the caption bar
85681>>>>>>>// Get/Set Title_Text   - updates the title area
85681>>>>>>>// Get/Set Message_Text - updates the Message area
85681>>>>>>>// Get/Set Action_Text  - updates the action area
85681>>>>>>>// Get/Set Button_Text  - updates the button area
85681>>>>>>>//
85681>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
85681>>>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
85681>>>>>>>//
85681>>>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
85681>>>>>>>Use cProcessStatusPanel.pkg
85681>>>>>>>Use cCJSkinFramework.pkg
85681>>>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cProgressBar.pkg)
85681>>>>>>>>>Use Windows.pkg
85681>>>>>>>>>Use cWinControl.pkg
85681>>>>>>>>>Use CommCtrl.pkg
85681>>>>>>>>>
85681>>>>>>>>>Type tPbRange
85681>>>>>>>>>    Field tPbRange.iLow  as DWord
85681>>>>>>>>>    Field tPbRange.iHigh as DWord
85681>>>>>>>>>End_Type
85681>>>>>>>>>
85681>>>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
85681>>>>>>>>>Class cProgressBar is a cWinControl
85682>>>>>>>>>
85682>>>>>>>>>    Procedure Construct_Object
85684>>>>>>>>>        Forward Send Construct_Object
85686>>>>>>>>>        Property Integer private_piMinimum
85687>>>>>>>>>        Property Integer private_piMaximum   100
85688>>>>>>>>>        Property Integer private_piAdvanceBy 10
85689>>>>>>>>>        Property Integer private_piPosition
85690>>>>>>>>>        Property Integer private_pbVertical  False
85691>>>>>>>>>        Property Integer private_pbSmooth    False
85692>>>>>>>>>        Property Integer private_piBackColor clDefault
85693>>>>>>>>>        Property Integer private_piBarColor  clDefault
85694>>>>>>>>>
85694>>>>>>>>>        Send Define_ToolTip_Support_Mixin
85695>>>>>>>>>
85695>>>>>>>>>        Set External_Class_Name 'cVdfProgressBar' To 'msctls_progress32'
85696>>>>>>>>>        Set Focus_Mode to NonFocusable
85697>>>>>>>>>        Set Skip_State to True
85698>>>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
85699>>>>>>>>>    End_Procedure
85700>>>>>>>>>
85700>>>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
85701>>>>>>>>>
85701>>>>>>>>>    Procedure Set piMinimum Integer iMin
85703>>>>>>>>>        Integer iMax
85703>>>>>>>>>
85703>>>>>>>>>        Set private_piMinimum to iMin
85704>>>>>>>>>        Get private_piMaximum To iMax
85705>>>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
85706>>>>>>>>>    End_Procedure
85707>>>>>>>>>    Function piMinimum Returns Integer
85709>>>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
85712>>>>>>>>>        Else Function_Return (private_piMinimum(self))
85714>>>>>>>>>    End_Function
85715>>>>>>>>>
85715>>>>>>>>>    Procedure Set piMaximum Integer iMax
85717>>>>>>>>>        Integer iMin
85717>>>>>>>>>
85717>>>>>>>>>        Set private_piMaximum to iMax
85718>>>>>>>>>        Get private_piMinimum To iMin
85719>>>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
85720>>>>>>>>>    End_Procedure
85721>>>>>>>>>    Function piMaximum Returns Integer
85723>>>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
85726>>>>>>>>>        Else Function_Return (private_piMaximum(self))
85728>>>>>>>>>    End_Function
85729>>>>>>>>>
85729>>>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
85731>>>>>>>>>        Set private_piAdvanceBy To iAdvanceBy
85732>>>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
85733>>>>>>>>>    End_Procedure
85734>>>>>>>>>    Function piAdvanceBy Returns Integer
85736>>>>>>>>>        Function_Return (private_piAdvanceBy(self))
85737>>>>>>>>>    End_Function
85738>>>>>>>>>
85738>>>>>>>>>    Procedure Set piPosition Integer iPos
85740>>>>>>>>>        Set private_piPosition To iPos
85741>>>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
85742>>>>>>>>>    End_Procedure
85743>>>>>>>>>
85743>>>>>>>>>    Function piPosition Returns Integer
85745>>>>>>>>>        If (Window_Handle(self)) Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
85748>>>>>>>>>        Else Function_Return (private_piPosition(self))
85750>>>>>>>>>    End_Function
85751>>>>>>>>>
85751>>>>>>>>>    Procedure Set pbVertical Boolean bVertical
85753>>>>>>>>>        If (private_pbVertical(self) <> bVertical) Begin
85755>>>>>>>>>            Set private_pbVertical To bVertical
85756>>>>>>>>>           Send DoRecreateWindow
85757>>>>>>>>>        End
85757>>>>>>>>>>
85757>>>>>>>>>    End_Procedure
85758>>>>>>>>>
85758>>>>>>>>>    Function pbVertical Returns Boolean
85760>>>>>>>>>        Function_Return (private_pbVertical(self))
85761>>>>>>>>>    End_Function
85762>>>>>>>>>
85762>>>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
85764>>>>>>>>>        If (private_pbSmooth(self) <> bSmooth) Begin
85766>>>>>>>>>           Set private_pbSmooth To bSmooth
85767>>>>>>>>>           Send DoRecreateWindow
85768>>>>>>>>>        End
85768>>>>>>>>>>
85768>>>>>>>>>    End_Procedure
85769>>>>>>>>>    Function pbSmooth Returns Boolean
85771>>>>>>>>>        Function_Return (private_pbSmooth(self))
85772>>>>>>>>>    End_Function
85773>>>>>>>>>
85773>>>>>>>>>    Procedure Set piBackColor Integer rgbColor
85775>>>>>>>>>        Set private_piBackColor To rgbColor
85776>>>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
85777>>>>>>>>>    End_Procedure
85778>>>>>>>>>    Function piBackColor Returns Integer
85780>>>>>>>>>        Function_Return (private_piBackColor(self))
85781>>>>>>>>>    End_Function
85782>>>>>>>>>
85782>>>>>>>>>    Procedure Set piBarColor Integer rgbColor
85784>>>>>>>>>        Set private_piBarColor To rgbColor
85785>>>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
85786>>>>>>>>>    End_Procedure
85787>>>>>>>>>    Function piBarColor Returns Integer
85789>>>>>>>>>        Function_Return (private_piBarColor(self))
85790>>>>>>>>>    End_Function
85791>>>>>>>>>
85791>>>>>>>>>    Procedure DoAdvance
85793>>>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
85794>>>>>>>>>    End_procedure
85795>>>>>>>>>
85795>>>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
85797>>>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
85798>>>>>>>>>    End_procedure
85799>>>>>>>>>
85799>>>>>>>>>    Procedure private_DoInitWindow
85801>>>>>>>>>        Set piBarColor  To (private_piBarColor(self))
85802>>>>>>>>>        Set piBackColor To (private_piBackColor(self))
85803>>>>>>>>>        Set piAdvanceBy To (private_piAdvanceBy(self))
85804>>>>>>>>>        Set piMinimum   To (private_piMinimum(self))
85805>>>>>>>>>        Set piMaximum   To (private_piMaximum(self))
85806>>>>>>>>>        Set piPosition  To (private_piPosition(self))
85807>>>>>>>>>    End_Procedure
85808>>>>>>>>>
85808>>>>>>>>>    Procedure Page_Object Integer iState
85810>>>>>>>>>        Handle hWnd
85810>>>>>>>>>
85810>>>>>>>>>        Get Window_Handle To hWnd
85811>>>>>>>>>        If (hWnd=0 and iState) Begin
85813>>>>>>>>>            Set Window_Style To PBS_VERTICAL (private_pbVertical(self))
85814>>>>>>>>>            Set Window_Style To PBS_SMOOTH   (private_pbSmooth(self))
85815>>>>>>>>>            Forward Send Page_Object True
85817>>>>>>>>>        End
85817>>>>>>>>>>
85817>>>>>>>>>        Else Forward Send Page_Object iState
85820>>>>>>>>>     
85820>>>>>>>>>        // Handle tooltip support....
85820>>>>>>>>>        If (iState = 0) Begin
85822>>>>>>>>>            Send RequestDeleteToolTip
85823>>>>>>>>>        End 
85823>>>>>>>>>>
85823>>>>>>>>>        Else Begin
85824>>>>>>>>>            Send RequestAddToolTip
85825>>>>>>>>>        End
85825>>>>>>>>>>
85825>>>>>>>>>    End_Procedure
85826>>>>>>>>>
85826>>>>>>>>>    Procedure Page Integer iState
85828>>>>>>>>>        Forward Send Page iState
85830>>>>>>>>>        If (iState =1) Send private_DoInitWindow
85833>>>>>>>>>    End_Procedure
85834>>>>>>>>>
85834>>>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
85834>>>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
85834>>>>>>>>>    // is implemented in a mixin class.
85834>>>>>>>>>    Procedure RequestAddToolTip
85836>>>>>>>>>        Send AddToolTip
85837>>>>>>>>>    End_Procedure  // RequestAddToolTip
85838>>>>>>>>>
85838>>>>>>>>>
85838>>>>>>>>>    // Called by Page_Object. Handles tooltip removal. 
85838>>>>>>>>>    Procedure RequestDeleteToolTip
85840>>>>>>>>>        Send DeleteToolTip
85841>>>>>>>>>    End_Procedure // RequestDeleteToolTip
85842>>>>>>>>>End_Class
85843>>>>>>>
85843>>>>>>>
85843>>>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
85843>>>>>>>
85843>>>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
85843>>>>>>>
85843>>>>>>>Object Status_Panel is a cProcessStatusPanel
85845>>>>>>>    Set Size to 140 222
85846>>>>>>>    Set Border_Style to Border_Dialog
85847>>>>>>>//    Set Sysmenu_Icon to False  
85847>>>>>>>    Set Icon to "DbUpdateFrameworkdf19.ico"
85848>>>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
85849>>>>>>>
85849>>>>>>>    Property Boolean Cancel_Button_Visible_State True
85851>>>>>>>
85851>>>>>>>    Procedure Activate
85854>>>>>>>        Integer iSizeBefore iSizeAfter
85854>>>>>>>        Get GuiSize to iSizeBefore
85855>>>>>>>        Forward Send Activate
85857>>>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))  
85858>>>>>>>    End_Procedure  
85859>>>>>>>    
85859>>>>>>>    Procedure End_Construct_Object
85862>>>>>>>        Forward Send End_Construct_Object
85864>>>>>>>        Set Label of oTitleTxt      to ""
85865>>>>>>>        Set Label of oTableNameTxt  to ""
85866>>>>>>>        Set Label of oMessageTxt    to ""
85867>>>>>>>        Set Label of oActionTxt     to ""
85868>>>>>>>    End_Procedure
85869>>>>>>>
85869>>>>>>>    Object oTitleTxt is a TextBox
85871>>>>>>>        Set Location to 5 21
85872>>>>>>>        Set Size to 8 179
85873>>>>>>>        Set Auto_Size_State to False
85874>>>>>>>        Set Justification_Mode  to jMode_Center
85875>>>>>>>        Set Label to "This is the Title Text"
85876>>>>>>>    End_Object
85877>>>>>>>
85877>>>>>>>    Object oTableNameTxt is a TextBox
85879>>>>>>>        Set Size to 19 204
85880>>>>>>>        Set Location to 18 9
85881>>>>>>>        Set Auto_Size_State to False
85882>>>>>>>        Set Justification_Mode to JMode_Left
85883>>>>>>>        Set Label to "This is the TableName Text"
85884>>>>>>>    End_Object
85885>>>>>>>
85885>>>>>>>    Object oMessageTxt is a TextBox
85887>>>>>>>        Set Location to 39 9
85888>>>>>>>        Set Size to 19 204
85889>>>>>>>        Set Auto_Size_State to False
85890>>>>>>>        Set Justification_Mode to JMode_Left
85891>>>>>>>        Set Label to "This is the Message text"
85892>>>>>>>    End_Object
85893>>>>>>>
85893>>>>>>>    Object oActionTxt is a TextBox
85895>>>>>>>        Set Size to 19 204
85896>>>>>>>        Set Location to 60 9
85897>>>>>>>        Set Auto_Size_State to False
85898>>>>>>>        Set Justification_Mode to JMode_Left
85899>>>>>>>        Set Label to "This is the Action Text"
85900>>>>>>>    End_Object
85901>>>>>>>
85901>>>>>>>    Object oStopButton is a Button
85903>>>>>>>        Set Location to 112 82
85904>>>>>>>        Set Label to C_$Cancel
85905>>>>>>>
85905>>>>>>>        Procedure OnClick
85908>>>>>>>            Send Close_panel
85909>>>>>>>        End_Procedure
85910>>>>>>>
85910>>>>>>>    End_Object
85911>>>>>>>
85911>>>>>>>    Object oPercentage_tb is a TextBox
85913>>>>>>>        Set Location to 74 196
85914>>>>>>>        Set Size to 10 25
85915>>>>>>>//        Set Label to "% Done"
85915>>>>>>>    End_Object
85916>>>>>>>
85916>>>>>>>    Object oCopyRight is a TextBox
85918>>>>>>>        Set Location to 129 21
85919>>>>>>>        Set Size to 9 197
85920>>>>>>>        Set FontPointHeight to 8
85921>>>>>>>        Set Auto_Size_State to False
85922>>>>>>>        Set Justification_Mode  to jMode_Center
85923>>>>>>>        Set Label to "Copyright 2001-2018 RDC Tools International"
85924>>>>>>>    End_Object
85925>>>>>>>
85925>>>>>>>    Object oProgressBar is a cProgressBar
85927>>>>>>>        Set Size to 10 179
85928>>>>>>>        Set Location to 86 22
85929>>>>>>>        Set pbVisible to True // default
85930>>>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
85931>>>>>>>    End_Object
85932>>>>>>>
85932>>>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
85935>>>>>>>        Set pbVisible of ghoProgressBar to bVisible
85936>>>>>>>    End_Procedure
85937>>>>>>>
85937>>>>>>>    Function Progress_Bar_Visible_State Returns Boolean
85940>>>>>>>        Boolean bVisible
85940>>>>>>>        Get pbVisible of ghoProgressBar to bVisible
85941>>>>>>>        Function_Return (bVisible)
85942>>>>>>>    End_Function
85943>>>>>>>
85943>>>>>>>    Object oProgressBarOverall is a cProgressBar
85945>>>>>>>        Set Size to 10 179
85946>>>>>>>        Set Location to 99 22
85947>>>>>>>        Set pbVisible to True // default
85948>>>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
85949>>>>>>>    End_Object
85950>>>>>>>
85950>>>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
85953>>>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
85954>>>>>>>    End_Procedure
85955>>>>>>>
85955>>>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
85958>>>>>>>        Boolean bVisible
85958>>>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
85959>>>>>>>        Function_Return (bVisible)
85960>>>>>>>    End_Function
85961>>>>>>>
85961>>>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
85961>>>>>>>    // objects defined within this instance of the status panel.
85961>>>>>>>
85961>>>>>>>    // note: all of the messages that change text should be forwarded
85961>>>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
85961>>>>>>>
85961>>>>>>>    Procedure Set Message_Text String sText
85964>>>>>>>        Set Label of oMessageTxt to sText
85965>>>>>>>        Forward Set Message_Text to sText
85967>>>>>>>    End_Procedure
85968>>>>>>>
85968>>>>>>>    Function Message_Text Returns String
85971>>>>>>>        Function_Return (Label(oMessageTxt))
85972>>>>>>>    End_Function
85973>>>>>>>
85973>>>>>>>    Procedure Set Action_Text String sText
85976>>>>>>>        Set Label of oActionTxt to sText
85977>>>>>>>        Forward Set Action_Text to sText
85979>>>>>>>    End_Procedure
85980>>>>>>>
85980>>>>>>>    Function Action_Text Returns String
85983>>>>>>>        Function_Return (Label(oActionTxt))
85984>>>>>>>    End_Function
85985>>>>>>>
85985>>>>>>>    Procedure Set Button_Text String sText
85988>>>>>>>        Set Label of oStopButton to sText
85989>>>>>>>        Forward Set Button_Text to sText
85991>>>>>>>    End_Procedure
85992>>>>>>>
85992>>>>>>>    Function Button_Text Returns String
85995>>>>>>>        Function_Return (Label(oStopButton))
85996>>>>>>>    End_Function
85997>>>>>>>
85997>>>>>>>    Procedure Set Title_Text String sText
86000>>>>>>>        Set Label of oTitleTxt to sText
86001>>>>>>>        Forward Set Title_Text to sText
86003>>>>>>>    End_Procedure
86004>>>>>>>
86004>>>>>>>    Function Title_Text Returns String
86007>>>>>>>        Function_Return (Label(oTitleTxt))
86008>>>>>>>    End_Function
86009>>>>>>>
86009>>>>>>>    Procedure Set TableName_Text String sText
86012>>>>>>>        Set Label of oTableNameTxt to sText
86013>>>>>>>    End_Procedure
86014>>>>>>>
86014>>>>>>>    Function TableName_Text Returns String
86017>>>>>>>        Function_Return (Label(oTableNameTxt))
86018>>>>>>>    End_Function
86019>>>>>>>
86019>>>>>>>    Procedure Set License_Text String sText
86022>>>>>>>//        Set Label of oLicense_txt to sText
86022>>>>>>>    End_Procedure
86023>>>>>>>
86023>>>>>>>    // gets called when status panel is activated passing whether a button
86023>>>>>>>    // should appear
86023>>>>>>>    Procedure EnableCancelButton Boolean bEnable
86026>>>>>>>        Boolean bVisible
86026>>>>>>>        Get Cancel_Button_Visible_State to bVisible
86027>>>>>>>        If (bEnable = False) Begin
86029>>>>>>>            Set Visible_State of oStopButton to bVisible
86030>>>>>>>        End
86030>>>>>>>>
86030>>>>>>>        Set Enabled_State of oStopButton to bEnable
86031>>>>>>>    End_Procedure
86032>>>>>>>
86032>>>>>>>    Procedure Reset_StatusPanel
86035>>>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
86036>>>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
86037>>>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
86038>>>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
86039>>>>>>>    End_Procedure
86040>>>>>>>
86040>>>>>>>//    Object oProgressBar is a cProgressBar
86040>>>>>>>//        Move Self to ghoProgressBar
86040>>>>>>>//        Set Location to 1 25
86040>>>>>>>//        Set Size to 9 173
86040>>>>>>>//        Set piMinimum        to 0
86040>>>>>>>//        Set piMaximum        to 2000
86040>>>>>>>//        Set piAdvanceBy      to 100
86040>>>>>>>//        Set pbSmooth to True
86040>>>>>>>//
86040>>>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
86040>>>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
86040>>>>>>>//        // color will show correctly.
86040>>>>>>>//        Procedure Page Integer iPageObject
86040>>>>>>>//            Handle hWin
86040>>>>>>>//            Forward Send Page iPageObject
86040>>>>>>>//            If (ghoSkinFramework <> 0) Begin
86040>>>>>>>//                Get Window_Handle to hWin
86040>>>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
86040>>>>>>>//            End
86040>>>>>>>//        End_Procedure
86040>>>>>>>//    End_Object
86040>>>>>>>
86040>>>>>>>End_Object
86041>>>>>>>
86041>>>>>Use cDbUpdateFunctionLibrary.inc        // Various constant definitions, structs etc.
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
86041>>>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
86041>>>>>>>>>//
86041>>>>>>>>>// *** The Database Update Framework Include file ***
86041>>>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
86041>>>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
86041>>>>>>>>>//
86041>>>>>>>>>//
86041>>>>>>>>>Use LanguageText.Pkg
86041>>>>>>>>>
86041>>>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
86041>>>>>>>>>//
86041>>>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
86041>>>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
86041>>>>>>>>>//
86041>>>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
86041>>>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
86041>>>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
86041>>>>>>>>>//
86041>>>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
86041>>>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
86041>>>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
86041>>>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
86041>>>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
86041>>>>>>>>>//
86041>>>>>>>>>    Define CS_UpdateVersion     for "Updating database"
86041>>>>>>>>>    Define CS_UpdateFromVersion for "from version"
86041>>>>>>>>>    Define CS_UpdateToVersion   for "to version:"
86041>>>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
86041>>>>>>>>>//
86041>>>>>>>>>    Define CS_DatabaseInUseShort  for "There are others using the application/database. Are you sure you still want to update the database?"
86041>>>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
86041>>>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
86041>>>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
86041>>>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
86041>>>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
86041>>>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
86041>>>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
86041>>>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
86041>>>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>>>
86041>>>>>>>
86041>>>>>>>Register_Function paSQLQueryMessages Returns String[]
86041>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
86041>>>>>>>
86041>>>>>>>// Global handle to a cDatabaseUpdateHandler object
86041>>>>>>>    Global_Variable Handle ghoDbUpdateHandler
86041>>>>>>>
86041>>>>>>>
86041>>>>>>>    Define CS_OEM_Txt for "OEM"
86041>>>>>>>
86041>>>>>>>    Define CS_ANSI_Txt for "ANSI"
86041>>>>>>>
86041>>>>>>>    Define CS_DFCONNID for "DFCONNID"
86041>>>>>>>
86041>>>>>>>    Define CS_SERVER for "SERVER"
86041>>>>>>>
86041>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
86041>>>>>>>
86041>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
86041>>>>>>>
86041>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
86041>>>>>>>
86041>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
86041>>>>>>>
86041>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
86041>>>>>>>
86041>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
86041>>>>>>>
86041>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
86041>>>>>>>
86041>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
86041>>>>>>>
86041>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
86041>>>>>>>
86041>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
86041>>>>>>>
86041>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
86041>>>>>>>
86041>>>>>>>
86041>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
86041>>>>>>>
86041>>>>>>>Struct tSQLScriptArray
86041>>>>>>>    Boolean bError
86041>>>>>>>    Boolean bArgumentSizeChanged
86041>>>>>>>    Integer iOrgArgumentSize
86041>>>>>>>    String[] sSQLScriptArray
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tSqlErrorArray
86041>>>>>>>    String[]  sSqlErrorArray
86041>>>>>>>    String[]  sSqlStatementArray
86041>>>>>>>    Integer[] iSqlErrorArray
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tSqlColumnNew
86041>>>>>>>    String  sBaseColumnName
86041>>>>>>>    String  sBaseTableName
86041>>>>>>>    String  sLabel
86041>>>>>>>    Integer iSqlType
86041>>>>>>>    Integer iSize
86041>>>>>>>    Integer iPrecision
86041>>>>>>>    Integer iDFType
86041>>>>>>>    Integer iDFNativeType
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tColumnType
86041>>>>>>>    String  sType
86041>>>>>>>    Integer iType
86041>>>>>>>    String  sDataFlexType
86041>>>>>>>    Integer iDataFlexType
86041>>>>>>>    String  sPrecision
86041>>>>>>>    Boolean bFixedSize 
86041>>>>>>>    Boolean bNativeDataType
86041>>>>>>>    Integer iDefaultSize
86041>>>>>>>    Integer iMinSize
86041>>>>>>>    Number  nMaxSize
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>// Used to store/retreive SQL keywords in a struct array.
86041>>>>>>>// Various SQL back-ends can have slightly different
86041>>>>>>>// keywords.
86041>>>>>>>Struct tSQLKeyWords
86041>>>>>>>    Integer iSQLWord
86041>>>>>>>    Integer iSQLDbType
86041>>>>>>>    String  sSQLPhrase // Can be more than one word.
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tSQLRelation
86041>>>>>>>    Integer iFileNumber
86041>>>>>>>    Integer iFieldNumber
86041>>>>>>>    String  sFileName
86041>>>>>>>    String  sFieldName
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tSQLLoggedInUser
86041>>>>>>>    String sUser
86041>>>>>>>    String sProgram
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
86041>>>>>>>Enumeration_List
86041>>>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
86041>>>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
86041>>>>>>>End_Enumeration_List
86041>>>>>>>
86041>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
86041>>>>>>>// They can have slightly different SQL keywords.
86041>>>>>>>// Note: If a new type is added to the list,
86041>>>>>>>//       the struct array xxx must be adjusted
86041>>>>>>>//       so that it is filled with all SQL
86041>>>>>>>//       keywords for that new type.
86041>>>>>>>Enum_List
86041>>>>>>>    Define EN_DbTypeMSSQL
86041>>>>>>>    Define EN_DbTypeMySQL
86041>>>>>>>    Define EN_DbTypeOracle
86041>>>>>>>    Define EN_DbTypeDB2
86041>>>>>>>    Define EN_DbTypePostgre
86041>>>>>>>    Define EN_DbTypeDataFlex // Embedded database.
86041>>>>>>>End_Enum_List
86041>>>>>>>
86041>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
86041>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
86041>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
86041>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
86041>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
86041>>>>>>>Define CS_DbTypeOracle      for "Oracle"
86041>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
86041>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
86041>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
86041>>>>>>>
86041>>>>>>>// We need to re-define the standard constants because several driver constants
86041>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
86041>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
86041>>>>>>>Enum_List
86041>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
86041>>>>>>>    Define DF_BCD_DUF       for -1499
86041>>>>>>>    Define DF_DATE_DUF      for -1498
86041>>>>>>>    Define DF_TEXT_DUF      for -1495
86041>>>>>>>    Define DF_BINARY_DUF    for -1494
86041>>>>>>>    Define DF_DATETIME_DUF  for -1493
86041>>>>>>>End_Enum_List
86041>>>>>>>
86041>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
86041>>>>>>>
86041>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
86041>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
86041>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
86041>>>>>>>
86041>>>>>>>// These are not defined pre DF 18:
86041>>>>>>>
86041>>>>>>>Struct tSQLIntTableInfo
86041>>>>>>>    String sDriverName
86041>>>>>>>    String sServerName
86041>>>>>>>    String sDatabaseName
86041>>>>>>>    String sSchemaName
86041>>>>>>>    Boolean bRecnumTable
86041>>>>>>>    Integer iPrimaryIndex
86041>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
86041>>>>>>>    String sTableCharacterFormat
86041>>>>>>>    Boolean bUseDummyZeroDate
86041>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
86041>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
86041>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
86041>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
86041>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
86041>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
86041>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
86041>>>>>>>    String sFileIndexTablespace
86041>>>>>>>    String sFileLongTablespace
86041>>>>>>>    String sTableTablespace
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tSQLIntColumnInfo
86041>>>>>>>    Integer iFieldNumber
86041>>>>>>>    Integer iFieldIndex
86041>>>>>>>    Integer iFieldRelatedFile
86041>>>>>>>    Integer iFieldRelatedField
86041>>>>>>>    Integer iIndexNumber
86041>>>>>>>    Integer iIndexNumberSegments      
86041>>>>>>>    Integer iIndexSegmentField1
86041>>>>>>>    Integer iIndexSegmentField2
86041>>>>>>>    Integer iIndexSegmentFieldn
86041>>>>>>>    String  sIndexName
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tAPIColumn 
86041>>>>>>>    String  sFieldName 
86041>>>>>>>    Integer iFieldNumber
86041>>>>>>>    Integer iType  
86041>>>>>>>    String  sType
86041>>>>>>>    Integer iLength 
86041>>>>>>>    Integer iPrecision 
86041>>>>>>>    Integer iOptions  
86041>>>>>>>    Boolean bIsSQLType
86041>>>>>>>    Boolean bShouldChange
86041>>>>>>>End_Struct  
86041>>>>>>>
86041>>>>>>>Struct tAPIRelation
86041>>>>>>>    Handle  hTableFrom
86041>>>>>>>    String  sLogicalNameFrom
86041>>>>>>>    Handle  hTableTo 
86041>>>>>>>    String  sLogicalNameTo
86041>>>>>>>    Integer iColumnFrom
86041>>>>>>>    String  sFieldNameFrom
86041>>>>>>>    Integer iColumnTo 
86041>>>>>>>    String  sFieldNameTo
86041>>>>>>>    Boolean bShouldChange
86041>>>>>>>End_Struct 
86041>>>>>>>
86041>>>>>>>Struct tAPIIndexSegment
86041>>>>>>>    Integer iFieldNumber
86041>>>>>>>    String  sFieldName 
86041>>>>>>>    Boolean bUppercase
86041>>>>>>>    Boolean bAscending
86041>>>>>>>    Boolean bShouldChange
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tAPIIndex
86041>>>>>>>    Integer iIndexNumber
86041>>>>>>>    String  sSQLIndexName
86041>>>>>>>    Integer iSQLIndexType
86041>>>>>>>    tAPIIndexSegment[] IndexSegmentArray 
86041>>>>>>>    tAPIIndexSegment[] IndexSegmentArray 
86041>>>>>>>    Boolean bIsPrimaryKey
86041>>>>>>>    Boolean bShouldChange
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Struct tAPITableNameInfo
86041>>>>>>>    Integer iTableNumber 
86041>>>>>>>    String  sRootName
86041>>>>>>>    String  sLogicalName
86041>>>>>>>    String  sDisplayName  
86041>>>>>>>    String  sDriverID
86041>>>>>>>    Boolean bIsAlias
86041>>>>>>>    Boolean bIsSQL
86041>>>>>>>    Boolean bShouldChange
86041>>>>>>>End_Struct
86041>>>>>>>    
86041>>>>>>>Struct tAPITable
86041>>>>>>>    tAPITableNameInfo ApiTableInfo
86041>>>>>>>    tAPITableNameInfo ApiTableInfo
86041>>>>>>>    tAPIColumn[]      aApiColumns
86041>>>>>>>    tAPIColumn[]      aApiColumns
86041>>>>>>>    tAPIIndex[]       aApiIndexes
86041>>>>>>>    tAPIIndex[]       aApiIndexes
86041>>>>>>>    tAPIRelation[]    aApiRelations
86041>>>>>>>    tAPIRelation[]    aApiRelations
86041>>>>>>>    Boolean bShouldChange
86041>>>>>>>End_Struct 
86041>>>>>>>
86041>>>>>>>Struct tAPITableBooleans
86041>>>>>>>    Boolean bCompareDate_DateTime
86041>>>>>>>    Boolean bCompareIndexAscending
86041>>>>>>>    Boolean bCompareIndexUppercase
86041>>>>>>>    Boolean bCompareFilelistUppercase
86041>>>>>>>End_Struct
86041>>>>>>>
86041>>>>>>>Define C_tAPIColumn_None for 0
86041>>>>>>>Define C_tAPIColumn_Identity for 1 
86041>>>>>>>
86041>>>>>>>// SQL Key-Word Constants:
86041>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
86041>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
86041>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
86041>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
86041>>>>>>>Enum_List
86041>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
86041>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
86041>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
86041>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
86041>>>>>>>    Define CI_SQLSelect                //for "SELECT"
86041>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
86041>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
86041>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
86041>>>>>>>    Define CI_SQLTable                 //for "TABLE"
86041>>>>>>>    Define CI_SQLSys                   //for "SYS"
86041>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
86041>>>>>>>    Define CI_SQLFrom                  //for "FROM"
86041>>>>>>>    Define CI_SQLAdd                   //for "ADD"
86041>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
86041>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
86041>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
86041>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
86041>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
86041>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
86041>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
86041>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
86041>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
86041>>>>>>>    Define CI_SQLTo                    //for "TO"
86041>>>>>>>    Define CI_SQLGO                    //for "GO"
86041>>>>>>>    Define CI_SQLUse                   //for "USE"
86041>>>>>>>    Define CI_SQLDBO                   //for "DBO"
86041>>>>>>>
86041>>>>>>>    Define CI_SQLName                  //for "NAME"
86041>>>>>>>    Define CI_SQLMaster                //for "MASTER"
86041>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
86041>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
86041>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
86041>>>>>>>    Define CI_SQLID                    //for "ID"
86041>>>>>>>    Define CI_SQLAND                   //for "AND"
86041>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
86041>>>>>>>    Define CI_SQLSet                   //for "SET"
86041>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
86041>>>>>>>End_Enum_List
86041>>>>>>>
86041>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
86041>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
86041>>>>>>>//
86041>>>>>>>// We need to create a mixin class for the library.
86041>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
86041>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
86041>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
86041>>>>>>>// Note: This class should _not_ have a construct_object defined.
86041>>>>>>>//
86041>>>>>>>Use VdfBase.pkg
86041>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\WinUuid.pkg)
86041>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
86042>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
86043>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
86044>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
86045>>>>>>>>>
86045>>>>>>>>>// RandomHexUUID:
86045>>>>>>>>>
86045>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
86045>>>>>>>>>Function RandomHexUUID Global Returns String
86047>>>>>>>>>    Address pUUID pUUIDStr
86047>>>>>>>>>    Integer iRetval iOffset iChar
86047>>>>>>>>>    String sUUID sKey
86047>>>>>>>>>    
86047>>>>>>>>>    Move (Alloc(16)) to pUUID
86048>>>>>>>>>    
86048>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
86049>>>>>>>>>    
86049>>>>>>>>>    If (iRetval = 0) Begin
86051>>>>>>>>>        Move 0 to pUUIDStr
86052>>>>>>>>>        
86052>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
86053>>>>>>>>>        If (iRetval = 0) Begin
86055>>>>>>>>>            Move pUUIDStr to sUUID
86056>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
86057>>>>>>>>> 
86057>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
86058>>>>>>>>>        End
86058>>>>>>>>>>
86058>>>>>>>>>    End
86058>>>>>>>>>>
86058>>>>>>>>>    
86058>>>>>>>>>    Move (Free(pUUID)) to iRetval 
86059>>>>>>>>>    
86059>>>>>>>>>    Function_Return sUUID
86060>>>>>>>>>End_Function
86061>>>>>>>>>
86061>>>>>>>>>
86061>>>>>>>>>// SeqHexUUID:
86061>>>>>>>>>
86061>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
86061>>>>>>>>>Function SeqHexUUID Global Returns String    
86063>>>>>>>>>    Address pUUID pUUIDStr
86063>>>>>>>>>    Integer iRetval iOffset iChar
86063>>>>>>>>>    String sUUID sKey
86063>>>>>>>>>    
86063>>>>>>>>>    Move (Alloc(16)) to pUUID
86064>>>>>>>>>    
86064>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
86065>>>>>>>>>    
86065>>>>>>>>>    If (iRetval = 0) Begin
86067>>>>>>>>>        Move 0 to pUUIDStr
86068>>>>>>>>>        
86068>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
86069>>>>>>>>>        If (iRetval = 0) Begin
86071>>>>>>>>>            Move pUUIDStr to sUUID
86072>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
86073>>>>>>>>> 
86073>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
86074>>>>>>>>>        End
86074>>>>>>>>>>
86074>>>>>>>>>    End
86074>>>>>>>>>>
86074>>>>>>>>>    
86074>>>>>>>>>    Move (Free(pUUID)) to iRetval 
86075>>>>>>>>>    
86075>>>>>>>>>    Function_Return sUUID
86076>>>>>>>>>End_Function
86077>>>>>>>Use cli.pkg
86077>>>>>>>Use sql.pkg
86077>>>>>>>Use MSSqldrv.pkg
86077>>>>>>>Use db2_drv.pkg
86077>>>>>>>Use odbc_drv.pkg
86077>>>>>>>Use DFBTRDRV.PKG
86077>>>>>>>Use cDbUpdateFunctionLibrary.inc
86077>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
86077>>>>>>>>>//****************************************************************************
86077>>>>>>>>>// $Module type: Include file
86077>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
86077>>>>>>>>>//
86077>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
86077>>>>>>>>>// Copyright (c) 2012 RDC Tools International
86077>>>>>>>>>// E-mail      : support@rdctools.com
86077>>>>>>>>>// Web-site    : http://www.rdctools.com
86077>>>>>>>>>//
86077>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
86077>>>>>>>>>//
86077>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
86077>>>>>>>>>//
86077>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
86077>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
86077>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
86077>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
86077>>>>>>>>>// in the help folder for more details.
86077>>>>>>>>>//
86077>>>>>>>>>Use Winkern.pkg
86077>>>>>>>>>Use cIniFile.pkg
86077>>>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cCryptographer.pkg)
86077>>>>>>>>>>>Use VdfBase.pkg
86077>>>>>>>>>>>
86077>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\CryptographerConstants.pkg)
86077>>>>>>>>>>>>>//                                      
86077>>>>>>>>>>>>>// File    : CryptographerConstants.pkg
86077>>>>>>>>>>>>>//
86077>>>>>>>>>>>>>//   Author  : Ulbe Stellema
86077>>>>>>>>>>>>>//             Data Access Worldwide
86077>>>>>>>>>>>>>//
86077>>>>>>>>>>>>>//   Date    : October 4, 2009
86077>>>>>>>>>>>>>//
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Algorithm classes
86077>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
86077>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
86077>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
86077>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
86077>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
86077>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
86077>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Algorithm types
86077>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
86077>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
86077>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
86077>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
86077>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
86077>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
86077>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Generic sub-ids
86077>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// RSA sub-ids
86077>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
86077>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
86077>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
86077>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
86077>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// DSS sub-ids
86077>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
86077>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
86077>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// DES sub_ids
86077>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
86077>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
86077>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
86077>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
86077>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
86077>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
86077>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
86077>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
86077>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
86077>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
86077>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
86077>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
86077>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
86077>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Fortezza sub-ids
86077>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
86077>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// RC2 sub-ids
86077>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Stream cipher sub-ids
86077>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
86077>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Diffie-Hellman sub-ids
86077>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
86077>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
86077>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
86077>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Hash sub ids
86077>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
86077>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
86077>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
86077>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
86077>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
86077>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
86077>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
86077>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
86077>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
86077>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
86077>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
86077>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
86077>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
86077>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
86077>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// secure channel sub ids
86077>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
86077>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
86077>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
86077>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
86077>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
86077>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
86077>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// algorithm identifier definitions
86077>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
86077>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
86077>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
86077>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
86077>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
86077>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
86077>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
86077>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
86077>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
86077>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
86077>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
86077>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
86077>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
86077>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
86077>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
86077>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
86077>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
86077>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
86077>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
86077>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
86077>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
86077>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
86077>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
86077>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
86077>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
86077>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
86077>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
86077>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
86077>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
86077>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
86077>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
86077>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
86077>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
86077>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
86077>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
86077>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
86077>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
86077>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
86077>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
86077>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
86077>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
86077>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
86077>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
86077>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Providers
86077>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
86077>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
86077>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
86077>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
86077>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
86077>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
86077>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
86077>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
86077>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
86077>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
86077>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
86077>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
86077>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
86077>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
86077>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
86077>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
86077>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
86077>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
86077>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
86077>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
86077>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
86077>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
86077>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
86077>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
86077>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
86077>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
86077>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
86077>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
86077>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
86077>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
86077>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
86077>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// Provider types
86077>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
86077>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
86077>>>>>>>>>>>>>Define PROV_DSS                         for 3
86077>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
86077>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
86077>>>>>>>>>>>>>Define PROV_SSL                         for 6
86077>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
86077>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
86077>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
86077>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
86077>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
86077>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
86077>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
86077>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
86077>>>>>>>>>>>>>Define PROV_RNG                         for 21
86077>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
86077>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
86077>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// KP_MODE
86077>>>>>>>>>>>>>// KP_MODE
86077>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
86077>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
86077>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
86077>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
86077>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
86077>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
86077>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
86077>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
86077>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
86077>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
86077>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
86077>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
86077>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
86077>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
86077>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
86077>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
86077>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
86077>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
86077>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
86077>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
86077>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
86077>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
86077>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
86077>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
86077>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
86077>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
86077>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
86077>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
86077>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
86077>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
86077>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
86077>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
86077>>>>>>>>>>>>>Define KP_RP                            for 23
86077>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
86077>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
86077>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
86077>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
86077>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
86077>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
86077>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
86077>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
86077>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
86077>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
86077>>>>>>>>>>>>>Define KP_PREHASH                       for 34
86077>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
86077>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
86077>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
86077>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
86077>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
86077>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
86077>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
86077>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
86077>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
86077>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
86077>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
86077>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>// key BLOB types
86077>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
86077>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
86077>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
86077>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
86077>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
86077>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
86077>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
86077>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>//  Structure cryptimportkey
86077>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
86077>>>>>>>>>>>>>    UChar    bType
86077>>>>>>>>>>>>>    UChar    bVersion
86077>>>>>>>>>>>>>    UShort   reserved
86077>>>>>>>>>>>>>    UInteger aiKeyAlg
86077>>>>>>>>>>>>>End_Struct
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
86077>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
86077>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
86077>>>>>>>>>>>>>    UInteger       dwKeySize
86077>>>>>>>>>>>>>//    UChar[]        rgbKeyData
86077>>>>>>>>>>>>>End_Struct
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
86077>>>>>>>>>>>>>Struct HMAC_INFO
86077>>>>>>>>>>>>>    UInteger HashAlgid
86077>>>>>>>>>>>>>    Pointer pbInnerString
86077>>>>>>>>>>>>>    DWord cbInnerString
86077>>>>>>>>>>>>>    Pointer pbOuterString
86077>>>>>>>>>>>>>    DWord cbOuterString
86077>>>>>>>>>>>>>End_Struct
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>
86077>>>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
86078>>>>>>>>>>>>>
86078>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
86079>>>>>>>>>>>>>
86079>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
86080>>>>>>>>>>>>>
86080>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
86081>>>>>>>>>>>>>
86081>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
86082>>>>>>>>>>>>>
86082>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
86083>>>>>>>>>>>>>
86083>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
86084>>>>>>>>>>>>>
86084>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
86085>>>>>>>>>>>>>
86085>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
86086>>>>>>>>>>>>>
86086>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
86087>>>>>>>>>>>>>    
86087>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
86088>>>>>>>>>>>>>
86088>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
86089>>>>>>>>>>>>>
86089>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
86090>>>>>>>>>>>>>
86090>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
86091>>>>>>>>>>>>>    
86091>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
86092>>>>>>>>>>>>>    
86092>>>>>>>>>>>
86092>>>>>>>>>>>Class cCryptographer is a cObject
86093>>>>>>>>>>>    
86093>>>>>>>>>>>    // Procedure : Construct_Object
86093>>>>>>>>>>>    // Purpose   : Object constructor
86093>>>>>>>>>>>    Procedure Construct_Object
86095>>>>>>>>>>>        Forward Send Construct_Object
86097>>>>>>>>>>>
86097>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
86098>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
86099>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
86100>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
86101>>>>>>>>>>>        
86101>>>>>>>>>>>        // Private properties
86101>>>>>>>>>>>        Property Handle     Private_phProv
86102>>>>>>>>>>>    End_Procedure
86103>>>>>>>>>>>    
86103>>>>>>>>>>>    
86103>>>>>>>>>>>    // Function : AcquireContext
86103>>>>>>>>>>>    // Purpose  : Acquire key container handle
86103>>>>>>>>>>>    Function AcquireContext Returns Handle
86105>>>>>>>>>>>        Integer iProvider
86105>>>>>>>>>>>        String sProvider
86105>>>>>>>>>>>        Handle hProv
86105>>>>>>>>>>>        Boolean bOk
86105>>>>>>>>>>>        Address addrProv
86105>>>>>>>>>>>        
86105>>>>>>>>>>>        Move 0 to hProv
86106>>>>>>>>>>>        Get piProvider to iProvider
86107>>>>>>>>>>>        Get psProvider to sProvider
86108>>>>>>>>>>>        
86108>>>>>>>>>>>        //  Determine address to be passed as provider
86108>>>>>>>>>>>        If (Trim(sProvider) <> "") Begin
86110>>>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
86111>>>>>>>>>>>        End
86111>>>>>>>>>>>>
86111>>>>>>>>>>>        Else Begin
86112>>>>>>>>>>>            Move 0 to addrProv
86113>>>>>>>>>>>        End
86113>>>>>>>>>>>>
86113>>>>>>>>>>>        
86113>>>>>>>>>>>        //  Acquire Crypto Context
86113>>>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
86114>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
86116>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
86117>>>>>>>>>>>        End
86117>>>>>>>>>>>>
86117>>>>>>>>>>>        
86117>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
86119>>>>>>>>>>>            // Fallback to original
86119>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
86120>>>>>>>>>>>            
86120>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
86122>>>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
86123>>>>>>>>>>>            End
86123>>>>>>>>>>>>
86123>>>>>>>>>>>        End
86123>>>>>>>>>>>>
86123>>>>>>>>>>>        Set Private_phProv to hProv
86124>>>>>>>>>>>        
86124>>>>>>>>>>>        Function_Return hProv
86125>>>>>>>>>>>    End_Function
86126>>>>>>>>>>>    
86126>>>>>>>>>>>    // Function : ReleaseContext
86126>>>>>>>>>>>    // Purpose  : Releases key container handle
86126>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
86128>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
86129>>>>>>>>>>>    End_Function
86130>>>>>>>>>>>    
86130>>>>>>>>>>>    // Function : CreateHash
86130>>>>>>>>>>>    // Purpose  : Creates hash object
86130>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
86132>>>>>>>>>>>        Integer iAlgorithm
86132>>>>>>>>>>>        Handle hHash
86132>>>>>>>>>>>        Boolean bOk
86132>>>>>>>>>>>        
86132>>>>>>>>>>>        Move 0 to hHash
86133>>>>>>>>>>>        Get piHash to iAlgorithm
86134>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
86135>>>>>>>>>>>        
86135>>>>>>>>>>>        Function_Return hHash
86136>>>>>>>>>>>    End_Function
86137>>>>>>>>>>>    
86137>>>>>>>>>>>    // Function : DestroyHash
86137>>>>>>>>>>>    // Purpose  : Destroys the hash object
86137>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
86139>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
86140>>>>>>>>>>>    End_Function
86141>>>>>>>>>>>    
86141>>>>>>>>>>>    // Function : HashData
86141>>>>>>>>>>>    // Purpose  : Adds data to hash object
86141>>>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
86143>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
86144>>>>>>>>>>>    End_Function
86145>>>>>>>>>>>    
86145>>>>>>>>>>>    // Function : DeriveKey
86145>>>>>>>>>>>    // Purpose  : Generates session key
86145>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
86147>>>>>>>>>>>        Integer iAlgorithm
86147>>>>>>>>>>>        Handle hKey
86147>>>>>>>>>>>        Boolean bOk
86147>>>>>>>>>>>        
86147>>>>>>>>>>>        Move 0 to hKey
86148>>>>>>>>>>>        Get piCipher to iAlgorithm
86149>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
86150>>>>>>>>>>>        
86150>>>>>>>>>>>        Function_Return hKey
86151>>>>>>>>>>>    End_Function
86152>>>>>>>>>>>    
86152>>>>>>>>>>>    // Function : ImportPlainTextKey
86152>>>>>>>>>>>    // Purpose  : Imports a plain text key
86152>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
86154>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
86154>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
86154>>>>>>>>>>>        Boolean   bSuccess
86154>>>>>>>>>>>        Handle    hKey
86154>>>>>>>>>>>        Integer   iHeadSize iKeySize
86154>>>>>>>>>>>        UChar[]   ucaKeyblob
86155>>>>>>>>>>>        Integer iVoid
86155>>>>>>>>>>>    
86155>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
86156>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
86157>>>>>>>>>>>    
86157>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
86158>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
86159>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
86160>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
86161>>>>>>>>>>>    
86161>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
86162>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
86163>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
86164>>>>>>>>>>>    
86164>>>>>>>>>>>        Move 0 to hKey
86165>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
86166>>>>>>>>>>>        If (not(bSuccess)) Begin 
86168>>>>>>>>>>>            Move (ShowLastError()) to iVoid
86169>>>>>>>>>>>        End
86169>>>>>>>>>>>>
86169>>>>>>>>>>>    
86169>>>>>>>>>>>        Function_Return hKey
86170>>>>>>>>>>>    End_Function
86171>>>>>>>>>>>
86171>>>>>>>>>>>    // Function : DestroyKey
86171>>>>>>>>>>>    // Purpose  : Destroys the key
86171>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
86173>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
86174>>>>>>>>>>>    End_Function
86175>>>>>>>>>>>    
86175>>>>>>>>>>>    // Function : KeyParameter
86175>>>>>>>>>>>    // Purpose  : Retrieves key data
86175>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
86177>>>>>>>>>>>        Integer iBuffer iLen
86177>>>>>>>>>>>        Boolean bOk
86177>>>>>>>>>>>        
86177>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
86178>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
86179>>>>>>>>>>>        Function_Return iBuffer
86180>>>>>>>>>>>    End_Function
86181>>>>>>>>>>>    
86181>>>>>>>>>>>    // Function : HashValue
86181>>>>>>>>>>>    // Purpose  : Retrieves a hash value
86181>>>>>>>>>>>    Function HashValue Handle lhHash Returns String
86183>>>>>>>>>>>        Pointer lpSize
86183>>>>>>>>>>>        Pointer lpHash
86183>>>>>>>>>>>        String  lsSize
86183>>>>>>>>>>>        String  lsHash
86183>>>>>>>>>>>        Integer liResult
86183>>>>>>>>>>>
86183>>>>>>>>>>>        Move (Repeat(Character(0),4)) to lsSize
86184>>>>>>>>>>>        GetAddress of lsSize to lpSize
86185>>>>>>>>>>>
86185>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,lpSize,0)) to liResult
86186>>>>>>>>>>>        If (liResult = 0) Function_Return ""
86189>>>>>>>>>>>
86189>>>>>>>>>>>        Move (Repeat(Character(0),BytesTodWord(lsSize,1))) to lsHash
86190>>>>>>>>>>>        GetAddress of lsHash to lpHash
86191>>>>>>>>>>>
86191>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,lpHash,lpSize,0)) to liResult
86192>>>>>>>>>>>        If (liResult = 0) Function_Return ""
86195>>>>>>>>>>>
86195>>>>>>>>>>>        Function_Return lsHash
86196>>>>>>>>>>>    End_Function  // HashValue
86197>>>>>>>>>>>    
86197>>>>>>>>>>>            
86197>>>>>>>>>>>    // Function : Encrypt
86197>>>>>>>>>>>    // Purpose  : Encrypts data
86197>>>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
86199>>>>>>>>>>>        Handle hProv hHash hKey
86199>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
86199>>>>>>>>>>>        Boolean bOk
86199>>>>>>>>>>>        
86199>>>>>>>>>>>        Get AcquireContext to hProv
86200>>>>>>>>>>>        If (hProv) Begin
86202>>>>>>>>>>>            Get CreateHash hProv to hHash
86203>>>>>>>>>>>            If (hHash) Begin
86205>>>>>>>>>>>                Get HashData hHash sPassword to bOk
86206>>>>>>>>>>>                If (bOk) Begin
86208>>>>>>>>>>>                    Get piCipher to iAlgorithm
86209>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
86210>>>>>>>>>>>                End // If (bOk) Begin            
86210>>>>>>>>>>>>
86210>>>>>>>>>>>                Get DestroyHash hHash to bOk
86211>>>>>>>>>>>            End // If (hHash) Begin
86211>>>>>>>>>>>>
86211>>>>>>>>>>>            
86211>>>>>>>>>>>            If (hKey) Begin
86213>>>>>>>>>>>                //  First call to determine resulting data size
86213>>>>>>>>>>>                Move (Length(sData)) to iDataLen
86214>>>>>>>>>>>                Move (Length(sData)) to iCipherLen
86215>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
86216>>>>>>>>>>>                
86216>>>>>>>>>>>                //  Reserve space in string
86216>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
86218>>>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
86219>>>>>>>>>>>                End
86219>>>>>>>>>>>>
86219>>>>>>>>>>>                
86219>>>>>>>>>>>                //  Call to really decrypt
86219>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
86220>>>>>>>>>>>                //If (not(bOk)) Begin
86220>>>>>>>>>>>                    //Move "" to sData
86220>>>>>>>>>>>                    //Move (GetLastError()) to iErr
86220>>>>>>>>>>>                //End
86220>>>>>>>>>>>                
86220>>>>>>>>>>>                Get DestroyKey hKey to bOk
86221>>>>>>>>>>>            End // If (hKey) Begin
86221>>>>>>>>>>>>
86221>>>>>>>>>>>            Get ReleaseContext hProv to bOk
86222>>>>>>>>>>>        End // If (hProv) Begin
86222>>>>>>>>>>>>
86222>>>>>>>>>>>        Function_Return sData
86223>>>>>>>>>>>    End_Function
86224>>>>>>>>>>>    
86224>>>>>>>>>>>    // Function : Decrypt
86224>>>>>>>>>>>    // Purpose  : Decrypts data
86224>>>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
86226>>>>>>>>>>>        Handle hProv hHash hKey
86226>>>>>>>>>>>        Integer iAlgorithm iDataLen
86226>>>>>>>>>>>        Boolean bOk
86226>>>>>>>>>>>        
86226>>>>>>>>>>>        Get AcquireContext to hProv
86227>>>>>>>>>>>        If (hProv) Begin
86229>>>>>>>>>>>            Get CreateHash hProv to hHash
86230>>>>>>>>>>>            If (hHash) Begin
86232>>>>>>>>>>>                Get HashData hHash sPassword to bOk
86233>>>>>>>>>>>                If (bOk) Begin
86235>>>>>>>>>>>                    Get piCipher to iAlgorithm
86236>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
86237>>>>>>>>>>>                End // If (bOk) Begin            
86237>>>>>>>>>>>>
86237>>>>>>>>>>>                Get DestroyHash hHash to bOk
86238>>>>>>>>>>>            End // If (hHash) Begin
86238>>>>>>>>>>>>
86238>>>>>>>>>>>            
86238>>>>>>>>>>>            If (hKey) Begin
86240>>>>>>>>>>>                Move (Length(sData)) to iDataLen
86241>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
86242>>>>>>>>>>>                //If (bOk = False) Move "" to sData
86242>>>>>>>>>>>                
86242>>>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
86242>>>>>>>>>>>                If (Length(sData) > iDataLen) Begin
86244>>>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
86245>>>>>>>>>>>                End
86245>>>>>>>>>>>>
86245>>>>>>>>>>>                
86245>>>>>>>>>>>                Get DestroyKey hKey to bOk
86246>>>>>>>>>>>            End // If (hKey) Begin
86246>>>>>>>>>>>>
86246>>>>>>>>>>>            Get ReleaseContext hProv to bOk
86247>>>>>>>>>>>        End // If (hProv) Begin
86247>>>>>>>>>>>>
86247>>>>>>>>>>>        Function_Return sData
86248>>>>>>>>>>>    End_Function
86249>>>>>>>>>>>    
86249>>>>>>>>>>>    //  Function : GenerateRandom
86249>>>>>>>>>>>    //  Purpose  : Generates random data.
86249>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
86251>>>>>>>>>>>        Handle hProv
86251>>>>>>>>>>>        UChar[] uaResult
86252>>>>>>>>>>>        Boolean bRes
86252>>>>>>>>>>>        
86252>>>>>>>>>>>        Get AcquireContext to hProv
86253>>>>>>>>>>>        
86253>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
86254>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
86255>>>>>>>>>>>        
86255>>>>>>>>>>>        Get ReleaseContext hProv to bRes
86256>>>>>>>>>>>        
86256>>>>>>>>>>>        Function_Return uaResult
86257>>>>>>>>>>>    End_Function
86258>>>>>>>>>>>    
86258>>>>>>>>>>>    //  Function : GenerateRandomString
86258>>>>>>>>>>>    //  Purpose  : Generates random data and does a base64 encoding to properly present it as a string.
86258>>>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
86260>>>>>>>>>>>        String sResult
86260>>>>>>>>>>>        UChar[] aData
86261>>>>>>>>>>>        Address pBase64
86261>>>>>>>>>>>        Integer iVoid
86261>>>>>>>>>>>
86261>>>>>>>>>>>        Get GenerateRandom iLenght to aData
86262>>>>>>>>>>>        
86262>>>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
86263>>>>>>>>>>>        Move pBase64 to sResult
86264>>>>>>>>>>>        Move (Free(pBase64)) to iVoid    
86265>>>>>>>>>>>        
86265>>>>>>>>>>>        Function_Return (Left(sResult, iLenght))
86266>>>>>>>>>>>    End_Function
86267>>>>>>>>>>>
86267>>>>>>>>>>>End_Class
86268>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Base64Functions.pkg)
86268>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
86268>>>>>>>>>>>//>
86268>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
86268>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
86268>>>>>>>>>>>//>
86268>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
86268>>>>>>>>>>>//> strings.
86268>>>>>>>>>>>//>
86268>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
86268>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
86268>>>>>>>>>>>//>
86268>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
86268>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
86268>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
86268>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
86268>>>>>>>>>>>
86268>>>>>>>>>>>Use VdfBase.pkg
86268>>>>>>>>>>>
86268>>>>>>>>>>>// Functions in vdfBase64.dll
86268>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
86269>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
86270>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
86271>>>>>>>>>>>
86271>>>>>>>>>>>// Structure
86271>>>>>>>>>>>Struct txxfBase64Buffer
86271>>>>>>>>>>>    Pointer pData
86271>>>>>>>>>>>    Integer iLength
86271>>>>>>>>>>>End_Struct
86271>>>>>>>>>>>
86271>>>>>>>>>>>Global_Variable Integer oBase64Functions
86271>>>>>>>>>>>
86271>>>>>>>>>>>Object _oBase64Functions is a cObject
86273>>>>>>>>>>>    Move Self to oBase64Functions
86274>>>>>>>>>>>
86274>>>>>>>>>>>
86274>>>>>>>>>>>    Function EncodeString String sValue Returns String
86277>>>>>>>>>>>        Address pBase64
86277>>>>>>>>>>>        String sResult
86277>>>>>>>>>>>        Integer iVoid
86277>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
86278>>>>>>>>>>>        Move pBase64 to sResult
86279>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
86280>>>>>>>>>>>        Function_Return sResult
86281>>>>>>>>>>>    End_Function
86282>>>>>>>>>>>
86282>>>>>>>>>>>    Function DecodeString String sValue Returns String
86285>>>>>>>>>>>        Address pBinary
86285>>>>>>>>>>>        String sBinary
86285>>>>>>>>>>>        Integer iVoid iLen
86285>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
86286>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
86287>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
86288>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
86289>>>>>>>>>>>        Function_Return sBinary
86290>>>>>>>>>>>    End_Function
86291>>>>>>>>>>>
86291>>>>>>>>>>>End_Object
86292>>>>>>>>>Use MSSqldrv.pkg
86292>>>>>>>>>Use db2_drv.pkg
86292>>>>>>>>>Use odbc_drv.pkg
86292>>>>>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vWin32fh.pkg)
86292>>>>>>>>>>>// This code is part of VDF GUIdance
86292>>>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
86292>>>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
86292>>>>>>>>>>>// VDF GUIdance is a mutual project of
86292>>>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
86292>>>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
86292>>>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
86292>>>>>>>>>>>//
86292>>>>>>>>>>>//
86292>>>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
86292>>>>>>>>>>>//
86292>>>>>>>>>>>
86292>>>>>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
86292>>>>>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
86292>>>>>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
86292>>>>>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
86292>>>>>>>>>>>//
86292>>>>>>>>>>>// The used naming-convention is:
86292>>>>>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
86292>>>>>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
86292>>>>>>>>>>>//
86292>>>>>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
86292>>>>>>>>>>>// of DataAccess in the future.
86292>>>>>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
86292>>>>>>>>>>>//
86292>>>>>>>>>>>// mm-dd-yyyy Author Description
86292>>>>>>>>>>>//
86292>>>>>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
86292>>>>>>>>>>>//                   vGetWindowsDirectory
86292>>>>>>>>>>>//
86292>>>>>>>>>>>//                   vGetTempFileName
86292>>>>>>>>>>>//                   vGetTempPath
86292>>>>>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
86292>>>>>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
86292>>>>>>>>>>>//                   error in your application anyways. Changed this for:
86292>>>>>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
86292>>>>>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
86292>>>>>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
86292>>>>>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
86292>>>>>>>>>>>//                   It is renamed too avoid this.
86292>>>>>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
86292>>>>>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
86292>>>>>>>>>>>//                   Removed the local keyword in the variable declarations
86292>>>>>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
86292>>>>>>>>>>>//                   created file-open dialog
86292>>>>>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
86292>>>>>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
86292>>>>>>>>>>>//                   This has now been taken care of.
86292>>>>>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
86292>>>>>>>>>>>//                   These declarations are now included from the vWin32fh header file.
86292>>>>>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
86292>>>>>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
86292>>>>>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
86292>>>>>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
86292>>>>>>>>>>>//                   One can however restore to the old way of handling by simply calling the
86292>>>>>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
86292>>>>>>>>>>>//                   filehandling operations
86292>>>>>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
86292>>>>>>>>>>>//                   as well as the StringFromRightOfChar function.
86292>>>>>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
86292>>>>>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
86292>>>>>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
86292>>>>>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
86292>>>>>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
86292>>>>>>>>>>>//                   extended characters are treated ok too.
86292>>>>>>>>>>>//                   Reported by Flemming from
86292>>>>>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
86292>>>>>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
86292>>>>>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
86292>>>>>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
86292>>>>>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
86292>>>>>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
86292>>>>>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
86292>>>>>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
86292>>>>>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
86292>>>>>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
86292>>>>>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
86292>>>>>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
86292>>>>>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
86292>>>>>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
86292>>>>>>>>>>>
86292>>>>>>>>>>>Use Case.mac
86292>>>>>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
86292>>>>>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cvFileDialogs.pkg)
86292>>>>>>>>>>>>>//***************************************************************************
86292>>>>>>>>>>>>>//*
86292>>>>>>>>>>>>>//* Class:        cvSaveAsDialog
86292>>>>>>>>>>>>>//* Package Name: cvFileDialogs.pkg
86292>>>>>>>>>>>>>//*
86292>>>>>>>>>>>>>//***************************************************************************
86292>>>>>>>>>>>>>
86292>>>>>>>>>>>>>Use File_dlg.pkg
86292>>>>>>>>>>>>>
86292>>>>>>>>>>>>>// *WvA: 13-01-1999 Created
86292>>>>>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
86292>>>>>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
86292>>>>>>>>>>>>>// file_name.
86292>>>>>>>>>>>>>Class cvSelectFile_Dialog Is An OpenDialog
86293>>>>>>>>>>>>>
86293>>>>>>>>>>>>>  Procedure Construct_Object Integer iImage_Id
86295>>>>>>>>>>>>>    Forward Send Construct_Object iImage_Id
86297>>>>>>>>>>>>>    Set HideReadOnly_State To True
86298>>>>>>>>>>>>>  End_Procedure // Construct_Object
86299>>>>>>>>>>>>>
86299>>>>>>>>>>>>>  Function SelectedFileName Returns String
86301>>>>>>>>>>>>>    String sFileName
86301>>>>>>>>>>>>>    Move "" To sFileName
86302>>>>>>>>>>>>>    If (Show_Dialog(Self)) Begin
86304>>>>>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
86305>>>>>>>>>>>>>    End
86305>>>>>>>>>>>>>>
86305>>>>>>>>>>>>>    Function_Return sFileName
86306>>>>>>>>>>>>>  End_Function // SelectedFileName
86307>>>>>>>>>>>>>End_Class // cvSelectFile_Dialog
86308>>>>>>>>>>>>>
86308>>>>>>>>>>>>>
86308>>>>>>>>>>>>>// *WvA: 13-01-1999 Created
86308>>>>>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
86308>>>>>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
86308>>>>>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
86308>>>>>>>>>>>>>//                   file-open dialog
86308>>>>>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
86310>>>>>>>>>>>>>  String sSelectedFile
86310>>>>>>>>>>>>>  Integer hoOpenFileDialog
86310>>>>>>>>>>>>>
86310>>>>>>>>>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
86312>>>>>>>>>>>>>
86312>>>>>>>>>>>>>    Set Dialog_Caption    To sCaptionText
86313>>>>>>>>>>>>>    Set Filter_String     To sSupportedFileTypes
86314>>>>>>>>>>>>>    Set Initial_Folder    To sInitialFolder
86315>>>>>>>>>>>>>
86315>>>>>>>>>>>>>    Move Self       To hoOpenFileDialog
86316>>>>>>>>>>>>>  End_Object // oOpenFileDialog
86317>>>>>>>>>>>>>
86317>>>>>>>>>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
86318>>>>>>>>>>>>>  Send Destroy_Object To hoOpenFileDialog
86319>>>>>>>>>>>>>  Function_Return sSelectedFile
86320>>>>>>>>>>>>>End_Function // vSelect_File
86321>>>>>>>>>>>>>
86321>>>>>>>>>>>>>
86321>>>>>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
86322>>>>>>>>>>>>>
86322>>>>>>>>>>>>>  Procedure Construct_Object
86324>>>>>>>>>>>>>    Forward Send Construct_Object
86326>>>>>>>>>>>>>    Set HideReadOnly_State To True
86327>>>>>>>>>>>>>  End_Procedure // Construct_Object
86328>>>>>>>>>>>>>
86328>>>>>>>>>>>>>  Function SelectedFileName Returns String
86330>>>>>>>>>>>>>    String sFileName
86330>>>>>>>>>>>>>    Move "" To sFileName
86331>>>>>>>>>>>>>    If (Show_Dialog(Self)) Begin
86333>>>>>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
86334>>>>>>>>>>>>>    End
86334>>>>>>>>>>>>>>
86334>>>>>>>>>>>>>    Function_Return sFileName
86335>>>>>>>>>>>>>  End_Function // SelectedFileName
86336>>>>>>>>>>>>>
86336>>>>>>>>>>>>>End_Class // cvSaveAsDialog
86337>>>>>>>>>>>>>
86337>>>>>>>>>>>>>// Added optional default filename as suggested by Nils
86337>>>>>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
86339>>>>>>>>>>>>>  String sSelectedFile
86339>>>>>>>>>>>>>  Integer hoDialog
86339>>>>>>>>>>>>>
86339>>>>>>>>>>>>>  Move "" To sSelectedFile
86340>>>>>>>>>>>>>  Get Create U_cvSaveAsDialog To hoDialog
86341>>>>>>>>>>>>>  If (hoDialog) Begin
86343>>>>>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
86343>>>>>>>>>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
86344>>>>>>>>>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
86345>>>>>>>>>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
86346>>>>>>>>>>>>>    If (Num_Arguments = 4) Begin
86348>>>>>>>>>>>>>      Set File_Title        of hoDialog to sDefaultFileName
86349>>>>>>>>>>>>>    End
86349>>>>>>>>>>>>>>
86349>>>>>>>>>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
86350>>>>>>>>>>>>>    Send Destroy Of hoDialog
86351>>>>>>>>>>>>>  End
86351>>>>>>>>>>>>>>
86351>>>>>>>>>>>>>  Function_Return sSelectedFile
86352>>>>>>>>>>>>>End_Function // vSelectSaveFile
86353>>>>>>>>>>>Use Seq_chnl.pkg
86353>>>>>>>>>>>
86353>>>>>>>>>>>Use windows
86353>>>>>>>>>>>//Use Dferror
86353>>>>>>>>>>>Use Dll
86353>>>>>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework\AppSrc\vwin32fh.h)
86353>>>>>>>>>>>>>//TH-Header
86353>>>>>>>>>>>>>//*****************************************************************************************
86353>>>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
86353>>>>>>>>>>>>>// All rights reserved.
86353>>>>>>>>>>>>>//
86353>>>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
86353>>>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
86353>>>>>>>>>>>>>// $Authors     : Wil van Antwerpen
86353>>>>>>>>>>>>>// $Created     : 19.02.2004  19:25
86353>>>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
86353>>>>>>>>>>>>>//
86353>>>>>>>>>>>>>// Contents:
86353>>>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
86353>>>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
86353>>>>>>>>>>>>>//*****************************************************************************************
86353>>>>>>>>>>>>>//TH-RevisionStart
86353>>>>>>>>>>>>>//TH-RevisionEnd
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
86353>>>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>Define vMax_Path     For |CI260
86353>>>>>>>>>>>>>Define vMinChar      For |CI$80
86353>>>>>>>>>>>>>Define vMaxChar      For |CI$7F
86353>>>>>>>>>>>>>Define vMinShort     For |CI$8000
86353>>>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
86353>>>>>>>>>>>>>Define vMinLong      For |CI$80000000
86353>>>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
86353>>>>>>>>>>>>>Define vMaxByte      For |CI$FF
86353>>>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
86353>>>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>// For FindFirstFile
86353>>>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
86353>>>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
86353>>>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
86353>>>>>>>>>>>>>// the API-call ShellExecute is used.
86353>>>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
86353>>>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
86353>>>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
86353>>>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
86353>>>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
86353>>>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
86353>>>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
86353>>>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
86353>>>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
86353>>>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
86353>>>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
86353>>>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
86353>>>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
86353>>>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>// C-Structure
86353>>>>>>>>>>>>>//typedef struct _browseinfo {
86353>>>>>>>>>>>>>//    HWND hwndOwner;
86353>>>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
86353>>>>>>>>>>>>>//    LPSTR pszDisplayName;
86353>>>>>>>>>>>>>//    LPCSTR lpszTitle;
86353>>>>>>>>>>>>>//    UINT ulFlags;
86353>>>>>>>>>>>>>//    BFFCALLBACK lpfn;
86353>>>>>>>>>>>>>//    LPARAM lParam;
86353>>>>>>>>>>>>>//    int iImage;
86353>>>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>//declare C structure struct_browseinfo
86353>>>>>>>>>>>>>//as documented in MSDN under Windows Shell API
86353>>>>>>>>>>>>>Type vtBrowseInfo
86353>>>>>>>>>>>>>  Field vtBrowseInfo.hWndOwner      as Handle
86353>>>>>>>>>>>>>  Field vtBrowseInfo.pIDLRoot       as Pointer
86353>>>>>>>>>>>>>  Field vtBrowseInfo.pszDisplayName as Pointer
86353>>>>>>>>>>>>>  Field vtBrowseInfo.lpszTitle      as Pointer
86353>>>>>>>>>>>>>  Field vtBrowseInfo.ulFlags        as dWord
86353>>>>>>>>>>>>>  Field vtBrowseInfo.lpfnCallback   as Pointer
86353>>>>>>>>>>>>>  Field vtBrowseInfo.lParam         as dWord
86353>>>>>>>>>>>>>  Field vtBrowseInfo.iImage         as dWord
86353>>>>>>>>>>>>>End_Type // tBrowseInfo
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>// Browsing for directory.
86353>>>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
86353>>>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
86353>>>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
86353>>>>>>>>>>>>>                                            // The callback function can set the status text by
86353>>>>>>>>>>>>>                                            // sending messages to the dialog box.
86353>>>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
86353>>>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>// message from browser
86353>>>>>>>>>>>>>//Define BFFM_INITIALIZED        1
86353>>>>>>>>>>>>>//Define BFFM_SELCHANGED         2
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>// messages to browser
86353>>>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
86353>>>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
86353>>>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>
86353>>>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
86354>>>>>>>>>>>>>
86354>>>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
86355>>>>>>>>>>>>>
86355>>>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
86356>>>>>>>>>>>>>
86356>>>>>>>>>>>>>
86356>>>>>>>>>>>>>
86356>>>>>>>>>>>>>
86356>>>>>>>>>>>>>Type vtSecurity_attributes
86356>>>>>>>>>>>>>  Field vtSecurity_attributes.nLength        as dWord
86356>>>>>>>>>>>>>  Field vtSecurity_attributes.lpDescriptor   as Pointer
86356>>>>>>>>>>>>>  Field vtSecurity_attributes.bInheritHandle as Integer
86356>>>>>>>>>>>>>End_Type // vtSecurity_attributes
86356>>>>>>>>>>>>>
86356>>>>>>>>>>>>>//nLength:
86356>>>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
86356>>>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
86356>>>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
86356>>>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
86356>>>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
86356>>>>>>>>>>>>>//
86356>>>>>>>>>>>>>//lpSecurityDescriptor:
86356>>>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
86356>>>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
86356>>>>>>>>>>>>>// descriptor of the calling process.
86356>>>>>>>>>>>>>//
86356>>>>>>>>>>>>>//bInheritHandle:
86356>>>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
86356>>>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
86356>>>>>>>>>>>>>
86356>>>>>>>>>>>>>
86356>>>>>>>>>>>>>// BOOL CreateDirectory(
86356>>>>>>>>>>>>>//    LPCTSTR lpPathName,
86356>>>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
86356>>>>>>>>>>>>>//   );
86356>>>>>>>>>>>>>//
86356>>>>>>>>>>>>>// lpPathName
86356>>>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
86356>>>>>>>>>>>>>//  to be created.
86356>>>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
86356>>>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
86356>>>>>>>>>>>>>// lpSecurityAttributes
86356>>>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
86356>>>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
86356>>>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
86356>>>>>>>>>>>>>// Returns:
86356>>>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
86356>>>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
86356>>>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
86357>>>>>>>>>>>>>
86357>>>>>>>>>>>>>
86357>>>>>>>>>>>>>// lpPathName
86357>>>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
86357>>>>>>>>>>>>>//  to be removed.
86357>>>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
86357>>>>>>>>>>>>>// Returns:
86357>>>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
86357>>>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
86357>>>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
86358>>>>>>>>>>>>>
86358>>>>>>>>>>>>>
86358>>>>>>>>>>>>>
86358>>>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
86358>>>>>>>>>>>>>// executable file or a document file.
86358>>>>>>>>>>>>>//
86358>>>>>>>>>>>>>// Operation can be one of the following:
86358>>>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
86358>>>>>>>>>>>>>//            The file can be an executable file or a document file.
86358>>>>>>>>>>>>>//            The file can be a folder to open.
86358>>>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
86358>>>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
86358>>>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
86358>>>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
86358>>>>>>>>>>>>>//
86358>>>>>>>>>>>>>// Return Values:
86358>>>>>>>>>>>>>//
86358>>>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
86358>>>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
86358>>>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
86358>>>>>>>>>>>>>//
86358>>>>>>>>>>>>>// The following table lists these error values:
86358>>>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
86358>>>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
86358>>>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
86358>>>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
86358>>>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
86358>>>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
86358>>>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
86358>>>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
86358>>>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
86358>>>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
86358>>>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
86358>>>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
86358>>>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
86358>>>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
86358>>>>>>>>>>>>>
86358>>>>>>>>>>>>>
86358>>>>>>>>>>>>>
86358>>>>>>>>>>>>>// Code to open the program that is associated with the selected file.
86358>>>>>>>>>>>>>//
86358>>>>>>>>>>>>>// External function call used in Procedure DoStartDocument
86358>>>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>Type vtShFileOpStruct
86359>>>>>>>>>>>>>  Field vtShFileOpStruct.hWnd                   as Handle
86359>>>>>>>>>>>>>  Field vtShFileOpStruct.wFunc                  as Integer
86359>>>>>>>>>>>>>  Field vtShFileOpStruct.pFrom                  as Pointer
86359>>>>>>>>>>>>>  Field vtShFileOpStruct.pTo                    as Pointer
86359>>>>>>>>>>>>>  Field vtShFileOpStruct.fFlags                 as Short
86359>>>>>>>>>>>>>  Field vtShFileOpStruct.fAnyOperationsAborted  as Short
86359>>>>>>>>>>>>>  Field vtShFileOpStruct.hNameMappings          as Pointer
86359>>>>>>>>>>>>>  Field vtShFileOpStruct.lpszProgressTitle      as Pointer // only used if FOF_SIMPLEPROGRESS
86359>>>>>>>>>>>>>End_Type // tShFileOpStruct
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>// hwnd
86359>>>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>// wFunc
86359>>>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
86359>>>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
86359>>>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
86359>>>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
86359>>>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>// pFrom
86359>>>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
86359>>>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>// pTo
86359>>>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
86359>>>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
86359>>>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
86359>>>>>>>>>>>>>//   double null-terminated.
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>// fAnyOperationsAborted
86359>>>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
86359>>>>>>>>>>>>>//   were completed or FALSE otherwise.
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>
86359>>>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
86359>>>>>>>>>>>>>// This can be a file or a folder.
86359>>>>>>>>>>>>>// With thanks to Andrew S Kaplan
86359>>>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
86360>>>>>>>>>>>>>
86360>>>>>>>>>>>>>
86360>>>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
86360>>>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
86361>>>>>>>>>>>>>
86361>>>>>>>>>>>>>
86361>>>>>>>>>>>>>
86361>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86361>>>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
86361>>>>>>>>>>>>>//   Pointer lpPathName ;
86361>>>>>>>>>>>>>//   Pointer lpPrefixString ;
86361>>>>>>>>>>>>>//   Integer uUnique ;
86361>>>>>>>>>>>>>//   Pointer lpTempFileName ;
86361>>>>>>>>>>>>>//   Returns Integer
86361>>>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
86361>>>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
86362>>>>>>>>>>>>>
86362>>>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
86363>>>>>>>>>>>>>
86363>>>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
86364>>>>>>>>>>>>>                  
86364>>>>>>>>>>>>>// from:
86364>>>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
86364>>>>>>>>>>>>>//
86364>>>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
86364>>>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
86364>>>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
86364>>>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
86364>>>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
86364>>>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
86364>>>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
86364>>>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
86364>>>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
86364>>>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
86364>>>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
86364>>>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
86364>>>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
86364>>>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
86364>>>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
86364>>>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
86364>>>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
86364>>>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
86364>>>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
86364>>>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
86364>>>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
86364>>>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
86364>>>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
86364>>>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
86364>>>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
86364>>>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
86364>>>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
86364>>>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
86364>>>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
86364>>>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
86364>>>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
86364>>>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
86364>>>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
86364>>>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
86364>>>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
86364>>>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
86364>>>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
86364>>>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
86364>>>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
86364>>>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
86364>>>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
86364>>>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
86364>>>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
86364>>>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
86364>>>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
86364>>>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
86364>>>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
86364>>>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
86364>>>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
86364>>>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
86364>>>>>>>>>>>>>
86364>>>>>>>>>>>>>
86364>>>>>>>>>>>>>//HRESULT SHGetFolderPath(
86364>>>>>>>>>>>>>//    HWND hwndOwner,
86364>>>>>>>>>>>>>//    int nFolder,
86364>>>>>>>>>>>>>//    HANDLE hToken,
86364>>>>>>>>>>>>>//    DWORD dwFlags,
86364>>>>>>>>>>>>>//    LPTSTR pszPath
86364>>>>>>>>>>>>>//);
86364>>>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
86364>>>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
86364>>>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
86364>>>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
86364>>>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
86364>>>>>>>>>>>>>//
86364>>>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
86365>>>>>>>>>>>>>
86365>>>>>>>>>>>>>
86365>>>>>>>>>>>>>
86365>>>>>>>>>>>>>Type vWin32_Find_Data
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.dwFileAttributes As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.ftCreationLowDateTime As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.ftCreationHighDateTime As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.ftLastAccessLowDateTime As dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.ftLastAccessHighDateTime As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.ftLastWriteLowDateTime As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.ftLastWriteHighDateTime As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.nFileSizeHigh As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.nFileSizeLow As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.dwReserved0 As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.dwReserved1 As Dword
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.cFileName As Char vMax_Path
86365>>>>>>>>>>>>>  Field vWin32_Find_Data.cAlternateFileName As Char 14
86365>>>>>>>>>>>>>End_Type // vWin32_Find_Data
86365>>>>>>>>>>>>>
86365>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86365>>>>>>>>>>>>>// lpFileName      : address of name of file to search for
86365>>>>>>>>>>>>>// lpFindFileData  : address of returned information
86365>>>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
86366>>>>>>>>>>>>>
86366>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86366>>>>>>>>>>>>>// hFindFile       : handle of search
86366>>>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
86366>>>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
86367>>>>>>>>>>>>>
86367>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86367>>>>>>>>>>>>>//  hFindFile      : file search handle
86367>>>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
86368>>>>>>>>>>>>>
86368>>>>>>>>>>>>>
86368>>>>>>>>>>>>>
86368>>>>>>>>>>>>>Type vFileTime
86368>>>>>>>>>>>>>  Field vFileTime.dwLowDateTime As Dword
86368>>>>>>>>>>>>>  Field vFileTime.dwHighDateTime As Dword
86368>>>>>>>>>>>>>End_Type // vFileTime
86368>>>>>>>>>>>>>
86368>>>>>>>>>>>>>
86368>>>>>>>>>>>>>Type vSystemTime
86368>>>>>>>>>>>>>  Field vSystemTime.wYear As Word
86368>>>>>>>>>>>>>  Field vSystemTime.wMonth As Word
86368>>>>>>>>>>>>>  Field vSystemTime.wDayOfWeek As Word
86368>>>>>>>>>>>>>  Field vSystemTime.wDay As Word
86368>>>>>>>>>>>>>  Field vSystemTime.wHour As Word
86368>>>>>>>>>>>>>  Field vSystemTime.wMinute As Word
86368>>>>>>>>>>>>>  Field vSystemTime.wSecond As Word
86368>>>>>>>>>>>>>  Field vSystemTime.wMilliSeconds As Word
86368>>>>>>>>>>>>>End_Type // vSystemTime
86368>>>>>>>>>>>>>
86368>>>>>>>>>>>>>
86368>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86368>>>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
86368>>>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
86368>>>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
86369>>>>>>>>>>>>>
86369>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86369>>>>>>>>>>>>>// This function formats the time in a picture-string passed
86369>>>>>>>>>>>>>//
86369>>>>>>>>>>>>>// Picture      Meaning
86369>>>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
86369>>>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
86369>>>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
86369>>>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
86369>>>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
86369>>>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
86369>>>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
86369>>>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
86369>>>>>>>>>>>>>//    t         One character time marker string, such as A or P
86369>>>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
86369>>>>>>>>>>>>>//
86369>>>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
86369>>>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
86369>>>>>>>>>>>>>
86369>>>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
86370>>>>>>>>>>>>>
86370>>>>>>>>>>>>>
86370>>>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86370>>>>>>>>>>>>>// This function formats the date in a picture-string passed
86370>>>>>>>>>>>>>//
86370>>>>>>>>>>>>>// Picture      Meaning
86370>>>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
86370>>>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
86370>>>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
86370>>>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
86370>>>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
86370>>>>>>>>>>>>>//              value associated with the specified locale.
86370>>>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
86370>>>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
86370>>>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
86370>>>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
86370>>>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
86370>>>>>>>>>>>>>//              associated with the specified locale.
86370>>>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
86370>>>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
86370>>>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
86370>>>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
86370>>>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
86370>>>>>>>>>>>>>//              does not have an associated era or period string.
86370>>>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
86370>>>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
86370>>>>>>>>>>>>>
86370>>>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
86371>>>>>>>>>>>>>
86371>>>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
86371>>>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$0000000l  //  do not use minutes or seconds
86371>>>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
86371>>>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
86371>>>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
86371>>>>>>>>>>>>>
86371>>>>>>>>>>>>>//  Date Flags for GetDateFormatW.
86371>>>>>>>>>>>>>//
86371>>>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$0000000l  //  use short date picture
86371>>>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
86371>>>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
86371>>>>>>>>>>>>>
86371>>>>>>>>>>>>>
86371>>>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
86372>>>>>>>>>>>>>
86372>>>>>>>>>>>>>
86372>>>>>>>>>>>>>// **WvA: 20-02-2004
86372>>>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
86372>>>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
86372>>>>>>>>>>>>>// incorrectly into an unsigned integer.
86372>>>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
86372>>>>>>>>>>>>>// It does smell a bit fishy though
86372>>>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
86372>>>>>>>>>>>>>
86372>>>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
86372>>>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
86372>>>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
86372>>>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
86372>>>>>>>>>>>>>
86372>>>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
86372>>>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
86372>>>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
86372>>>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
86372>>>>>>>>>>>>>                                                
86372>>>>>>>>>>>>>
86372>>>>>>>>>>>>> // Courtesy Of Steve Walter,
86372>>>>>>>>>>>>> // USA Software, Inc
86372>>>>>>>>>>>>> // Format a disk
86372>>>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
86372>>>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
86373>>>>>>>>>>>>>
86373>>>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
86373>>>>>>>>>>>>>
86373>>>>>>>>>>>>>// SHCreateDirectoryEx
86373>>>>>>>>>>>>>
86373>>>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
86373>>>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
86373>>>>>>>>>>>>>//
86373>>>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
86373>>>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
86373>>>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
86373>>>>>>>>>>>>>//
86373>>>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
86373>>>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
86373>>>>>>>>>>>>>//        ERROR_CANCELLED.
86373>>>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
86373>>>>>>>>>>>>>
86373>>>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
86373>>>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
86373>>>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
86373>>>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
86373>>>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
86373>>>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
86373>>>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
86373>>>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
86373>>>>>>>>>>>>>
86373>>>>>>>>>>>>>//        int SHCreateDirectoryEx(
86373>>>>>>>>>>>>>//            HWND hwnd,
86373>>>>>>>>>>>>>//            LPCTSTR pszPath,
86373>>>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
86373>>>>>>>>>>>>>//        );
86373>>>>>>>>>>>>>
86373>>>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
86374>>>>>>>>>>>
86374>>>>>>>>>>>
86374>>>>>>>>>>>
86374>>>>>>>>>>>
86374>>>>>>>>>>>
86374>>>>>>>>>>>//
86374>>>>>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
86374>>>>>>>>>>>// If sStopChar has no occurences in the string an empty string is
86374>>>>>>>>>>>// returned.
86374>>>>>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
86376>>>>>>>>>>>  String  sRetVal
86376>>>>>>>>>>>  String  sChar
86376>>>>>>>>>>>  Integer iLength
86376>>>>>>>>>>>  Integer iPos
86376>>>>>>>>>>>  Boolean bStopChar
86376>>>>>>>>>>>  Move "" To sRetval
86377>>>>>>>>>>>  Move (Length(sFrom)) To iLength
86378>>>>>>>>>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
86380>>>>>>>>>>>    Move iLength   To iPos
86381>>>>>>>>>>>    Move (False)   To bStopChar
86382>>>>>>>>>>>    While Not bStopChar
86386>>>>>>>>>>>      Move (Mid(sFrom,1,iPos)) To sChar
86387>>>>>>>>>>>      Decrement iPos
86388>>>>>>>>>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
86390>>>>>>>>>>>        Move (True) To bStopChar
86391>>>>>>>>>>>      End
86391>>>>>>>>>>>>
86391>>>>>>>>>>>      Else Begin
86392>>>>>>>>>>>        Move (sChar+sRetVal) To sRetVal
86393>>>>>>>>>>>      End
86393>>>>>>>>>>>>
86393>>>>>>>>>>>    Loop
86394>>>>>>>>>>>>
86394>>>>>>>>>>>  End
86394>>>>>>>>>>>>
86394>>>>>>>>>>>  Function_Return sRetVal
86395>>>>>>>>>>>End_Function // StringFromRightOfChar
86396>>>>>>>>>>>
86396>>>>>>>>>>>
86396>>>>>>>>>>>// Pre:  sFileName contains the complete path of the file.
86396>>>>>>>>>>>// Post: returns the complete path of the file.
86396>>>>>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
86396>>>>>>>>>>>Function ParseFolderName Global String sFileName Returns String
86398>>>>>>>>>>>  String sFile
86398>>>>>>>>>>>  String sFolderName
86398>>>>>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
86398>>>>>>>>>>>  MOve "" To sFolderName
86399>>>>>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
86400>>>>>>>>>>>  If sDirSep In sFileName Begin
86402>>>>>>>>>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
86403>>>>>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
86404>>>>>>>>>>>  End
86404>>>>>>>>>>>>
86404>>>>>>>>>>>  Else If ":" In sFileName Begin
86407>>>>>>>>>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
86408>>>>>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
86409>>>>>>>>>>>  End
86409>>>>>>>>>>>>
86409>>>>>>>>>>>  Function_Return sFolderName
86410>>>>>>>>>>>End_Function // ParseFolderName
86411>>>>>>>>>>>
86411>>>>>>>>>>>
86411>>>>>>>>>>>// Pre:  sFileName contains the complete path of the file.
86411>>>>>>>>>>>// post: The returned filename has it's path removed, but will have a extension
86411>>>>>>>>>>>Function ParseFileName Global String sFileName Returns String
86413>>>>>>>>>>>  String sFolderName
86413>>>>>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
86413>>>>>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
86414>>>>>>>>>>>  Get ParseFolderName sFileName To sFolderName
86415>>>>>>>>>>>  If (sFolderName <> "") Move (Replace(sFolderName,sFileName,"")) To sFileName
86418>>>>>>>>>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
86419>>>>>>>>>>>  Function_Return sFilename
86420>>>>>>>>>>>End_Function // ParseFileName
86421>>>>>>>>>>>
86421>>>>>>>>>>>
86421>>>>>>>>>>>// Pre:  sFileName may contain the complete path of the file.
86421>>>>>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
86421>>>>>>>>>>>//       return "bak" as the extension and not "gif"
86421>>>>>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
86421>>>>>>>>>>>//       such as "html" or "java"
86421>>>>>>>>>>>Function ParseFileExtension Global String sFileName Returns String
86423>>>>>>>>>>>  String  sFileExtension
86423>>>>>>>>>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
86424>>>>>>>>>>>  Function_Return sFileExtension
86425>>>>>>>>>>>End_Function // ParseFileExtension
86426>>>>>>>>>>>
86426>>>>>>>>>>>
86426>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
86426>>>>>>>>>>>
86426>>>>>>>>>>>
86426>>>>>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
86429>>>>>>>>>>>  String sMessage
86429>>>>>>>>>>>  Case Begin
86429>>>>>>>>>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
86431>>>>>>>>>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
86432>>>>>>>>>>>      Case Break
86433>>>>>>>>>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
86436>>>>>>>>>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
86437>>>>>>>>>>>      Case Break
86438>>>>>>>>>>>    Case (iErrorID = vERROR_BAD_FORMAT)
86441>>>>>>>>>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
86442>>>>>>>>>>>      Case Break
86443>>>>>>>>>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
86446>>>>>>>>>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
86447>>>>>>>>>>>      Case Break
86448>>>>>>>>>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
86451>>>>>>>>>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
86452>>>>>>>>>>>      Case Break
86453>>>>>>>>>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
86456>>>>>>>>>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
86457>>>>>>>>>>>      Case Break
86458>>>>>>>>>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
86461>>>>>>>>>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
86462>>>>>>>>>>>      Case Break
86463>>>>>>>>>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
86466>>>>>>>>>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
86467>>>>>>>>>>>      Case Break
86468>>>>>>>>>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
86471>>>>>>>>>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
86472>>>>>>>>>>>      Case Break
86473>>>>>>>>>>>    Case (iErrorID = vSE_ERR_NOASSOC)
86476>>>>>>>>>>>      Move CS_DDE_ERR_NOASSOC To sMessage
86477>>>>>>>>>>>      Case Break
86478>>>>>>>>>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
86481>>>>>>>>>>>      Move CS_DDE_ERR_OOM To sMessage
86482>>>>>>>>>>>      Case Break
86483>>>>>>>>>>>    Case (iErrorID = vSE_ERR_PNF)
86486>>>>>>>>>>>      Move CS_DDE_ERR_PNF To sMessage
86487>>>>>>>>>>>      Case Break
86488>>>>>>>>>>>    Case (iErrorID = vSE_ERR_SHARE)
86491>>>>>>>>>>>      Move CS_DDE_ERR_SHARE To sMessage
86492>>>>>>>>>>>      Case Break
86493>>>>>>>>>>>    Case Else
86493>>>>>>>>>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
86494>>>>>>>>>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
86495>>>>>>>>>>>      Case Break
86496>>>>>>>>>>>  Case End
86496>>>>>>>>>>>  Function_Return sMessage
86497>>>>>>>>>>>End_Function // DDE_Error_To_String
86498>>>>>>>>>>>
86498>>>>>>>>>>>
86498>>>>>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
86501>>>>>>>>>>>  String sMessage
86501>>>>>>>>>>>  Get DDE_Error_To_String iErrorID To sMessage
86502>>>>>>>>>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
86503>>>>>>>>>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
86504>>>>>>>>>>>End_Procedure // vDDE_Error_Handler hInstance
86505>>>>>>>>>>>
86505>>>>>>>>>>>
86505>>>>>>>>>>>// Does the directory exist? - No = 0, Yes = 1
86505>>>>>>>>>>>// This also works with UNC path encoding and wildcards
86505>>>>>>>>>>>Function vFolderExists Global String sFolderName Returns Integer
86507>>>>>>>>>>>  String  sFolder sTmp
86507>>>>>>>>>>>  Integer bFolderExists iCh
86507>>>>>>>>>>>
86507>>>>>>>>>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
86507>>>>>>>>>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
86508>>>>>>>>>>>  If (sFolderName = "") Begin
86510>>>>>>>>>>>    Function_Return False
86511>>>>>>>>>>>  End
86511>>>>>>>>>>>>
86511>>>>>>>>>>>
86511>>>>>>>>>>>  Move dfTrue To bFolderExists
86512>>>>>>>>>>>  Move "dir:" To sFolder
86513>>>>>>>>>>>  Append sFolder sFolderName
86514>>>>>>>>>>>  Get Seq_New_Channel To iCh  // get free channel for input
86515>>>>>>>>>>>  Direct_Input Channel iCh sFolder
86517>>>>>>>>>>>    Repeat
86517>>>>>>>>>>>>
86517>>>>>>>>>>>      Readln Channel iCh sTmp
86519>>>>>>>>>>>      If (Trim(sTmp)="") Move dfFalse To bFolderExists
86522>>>>>>>>>>>      Else Begin
86523>>>>>>>>>>>        Move dfTrue To bFolderExists
86524>>>>>>>>>>>        Indicate seqeof True  // end loop
86525>>>>>>>>>>>        End
86525>>>>>>>>>>>>
86525>>>>>>>>>>>    Until (seqeof)
86527>>>>>>>>>>>  Close_Input Channel iCh
86529>>>>>>>>>>>  Send Seq_Release_Channel iCh
86530>>>>>>>>>>>  Function_Return bFolderExists
86531>>>>>>>>>>>End_Function  // vFolderExists
86532>>>>>>>>>>>
86532>>>>>>>>>>>
86532>>>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
86532>>>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
86534>>>>>>>>>>>  String sFolder sBrowseInfo sTitle
86534>>>>>>>>>>>  Pointer lpItemIdList lpsFolder lpsBrowseInfo lpsTitle
86534>>>>>>>>>>>  Integer iFolderSelected iRetval
86534>>>>>>>>>>>
86534>>>>>>>>>>>  // fill string variable with null characters
86534>>>>>>>>>>>  ZeroType vtBrowseInfo To sBrowseInfo
86535>>>>>>>>>>>
86535>>>>>>>>>>>  If (sDialogTitle<>"") Begin
86537>>>>>>>>>>>    Move sDialogTitle To sTitle
86538>>>>>>>>>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
86538>>>>>>>>>>>    // disables showing some commonly used ascii characters like ascii 137 ()
86538>>>>>>>>>>>    // These chars are correctly shown if no toansi is used.
86538>>>>>>>>>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
86538>>>>>>>>>>>    // selected it will always be valid.
86538>>>>>>>>>>>    GetAddress Of sTitle To lpsTitle
86539>>>>>>>>>>>    Put lpsTitle To sBrowseInfo At vtBrowseInfo.lpszTitle
86540>>>>>>>>>>>  End
86540>>>>>>>>>>>>
86540>>>>>>>>>>>
86540>>>>>>>>>>>  Put vBIF_RETURNONLYFSDIRS To sBrowseInfo At vtBrowseInfo.ulFlags
86541>>>>>>>>>>>
86541>>>>>>>>>>>  // Torben Lund added line below. Move handle of focus object to structure before
86541>>>>>>>>>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
86541>>>>>>>>>>>  Put (window_handle(focus(desktop))) To sBrowseInfo At vtBrowseInfo.hWndOwner
86542>>>>>>>>>>>
86542>>>>>>>>>>>  GetAddress Of sBrowseInfo To lpsBrowseInfo
86543>>>>>>>>>>>
86543>>>>>>>>>>>  // null 128 chars into var (make space)
86543>>>>>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
86544>>>>>>>>>>>  GetAddress Of sFolder To lpsFolder
86545>>>>>>>>>>>
86545>>>>>>>>>>>  // select folder
86545>>>>>>>>>>>  Move (vWin32_SHBrowseForFolder(lpsBrowseInfo)) To lpItemIdList
86546>>>>>>>>>>>  // get selected folder name
86546>>>>>>>>>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, lpsFolder)) To iFolderSelected
86547>>>>>>>>>>>
86547>>>>>>>>>>>  // release memory resources that are used by the ItemIdList
86547>>>>>>>>>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
86548>>>>>>>>>>>
86548>>>>>>>>>>>  If (iFolderSelected<>0) Function_Return (CString(sFolder))
86551>>>>>>>>>>>  Else Function_Return ""
86553>>>>>>>>>>>End_Function // vSHBrowseForFolder
86554>>>>>>>>>>>
86554>>>>>>>>>>>
86554>>>>>>>>>>>// returns 0 if the folder is created.
86554>>>>>>>>>>>//         1 if the API-call returned an error.
86554>>>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
86556>>>>>>>>>>>  String  sFolder sSA
86556>>>>>>>>>>>  Pointer lpsFolder lpsSecurity_Attributes lpDescriptor
86556>>>>>>>>>>>  Integer iRetval bFolderCreated bInheritHandle
86556>>>>>>>>>>>
86556>>>>>>>>>>>  Move (False) To bFolderCreated
86557>>>>>>>>>>>  // fill string variable with null characters
86557>>>>>>>>>>>  ZeroType vtSecurity_attributes To sSA
86558>>>>>>>>>>>
86558>>>>>>>>>>>  // null MAX_PATH chars into var (make space)
86558>>>>>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
86559>>>>>>>>>>>
86559>>>>>>>>>>>  If (sNewFolder <> "") Begin
86561>>>>>>>>>>>
86561>>>>>>>>>>>    Move dfTrue To  bInheritHandle
86562>>>>>>>>>>>    // Setting this to NULL is already done by the zerotype command
86562>>>>>>>>>>>    // Move NULL   To  lpDescriptor
86562>>>>>>>>>>>    Put (length(sSA))   To sSA At vtSecurity_attributes.nLength
86563>>>>>>>>>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
86563>>>>>>>>>>>    Put bInheritHandle To sSA At vtSecurity_attributes.bInheritHandle
86564>>>>>>>>>>>
86564>>>>>>>>>>>    GetAddress Of sSA To lpsSecurity_Attributes
86565>>>>>>>>>>>
86565>>>>>>>>>>>    //
86565>>>>>>>>>>>    Move sNewFolder To sFolder
86566>>>>>>>>>>>    GetAddress Of sFolder To lpsFolder
86567>>>>>>>>>>>    Move (vWin32_CreateDirectory(lpsFolder, lpsSecurity_Attributes)) To bFolderCreated
86568>>>>>>>>>>>  End
86568>>>>>>>>>>>>
86568>>>>>>>>>>>
86568>>>>>>>>>>>  Ifnot bFolderCreated Move 1 To iRetVal
86571>>>>>>>>>>>  Function_Return iRetVal
86572>>>>>>>>>>>End_Function // vCreateDirectory
86573>>>>>>>>>>>
86573>>>>>>>>>>>
86573>>>>>>>>>>>// **WvA: 03-02-2002 Function created.
86573>>>>>>>>>>>// With this function one can remove a directory.
86573>>>>>>>>>>>// returns 0 if the folder is removed.
86573>>>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
86573>>>>>>>>>>>//         2 if the folder did not exist
86573>>>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
86573>>>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
86575>>>>>>>>>>>  String  sPath
86575>>>>>>>>>>>  Pointer lpsPath
86575>>>>>>>>>>>  Integer iRetval bRemoved bExists
86575>>>>>>>>>>>
86575>>>>>>>>>>>  Move (False) To bRemoved
86576>>>>>>>>>>>  Move 0 To iRetVal
86577>>>>>>>>>>>  Move (Trim(sFolder)) To sFolder
86578>>>>>>>>>>>  If (sFolder="") Begin
86580>>>>>>>>>>>    Move 3 To iRetVal
86581>>>>>>>>>>>  End
86581>>>>>>>>>>>>
86581>>>>>>>>>>>  If (vFolderExists(sFolder)=False) Begin
86583>>>>>>>>>>>    Move 2 To iRetVal
86584>>>>>>>>>>>  End
86584>>>>>>>>>>>>
86584>>>>>>>>>>>  If (iRetVal=0) Begin
86586>>>>>>>>>>>    // null MAX_PATH chars into var (make space)
86586>>>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
86587>>>>>>>>>>>    //
86587>>>>>>>>>>>    Move (Insert(sFolder,sPath,1)) To sPath
86588>>>>>>>>>>>    GetAddress Of sPath To lpsPath
86589>>>>>>>>>>>    Move (vWin32_RemoveDirectory(lpsPath)) To bRemoved
86590>>>>>>>>>>>  End
86590>>>>>>>>>>>>
86590>>>>>>>>>>>
86590>>>>>>>>>>>  If ((iRetVal=0) And (bRemoved=False)) Begin
86592>>>>>>>>>>>    Move 1 To iRetVal
86593>>>>>>>>>>>  End
86593>>>>>>>>>>>>
86593>>>>>>>>>>>  Function_Return iRetVal
86594>>>>>>>>>>>End_Function // vRemoveDirectory
86595>>>>>>>>>>>
86595>>>>>>>>>>>
86595>>>>>>>>>>>
86595>>>>>>>>>>>// This function informs the user that he entered a yet unknown folder and
86595>>>>>>>>>>>// asks if he/she wants to create the folder (Yes/No)
86595>>>>>>>>>>>// Choice: "Yes" - this creates the folder
86595>>>>>>>>>>>//                 if successful, the function returns false
86595>>>>>>>>>>>//                 else it will be true.
86595>>>>>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
86595>>>>>>>>>>>//                 For example: to stop a save
86595>>>>>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
86595>>>>>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
86595>>>>>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
86597>>>>>>>>>>>  Integer bIsNotValid
86597>>>>>>>>>>>  Integer iUsers_Choice
86597>>>>>>>>>>>  String  sMessage
86597>>>>>>>>>>>
86597>>>>>>>>>>>  If (vFolderExists(sFolderName) Eq 0) Begin
86599>>>>>>>>>>>    Move "The folder '" To sMessage
86600>>>>>>>>>>>    Append sMessage sFolderName
86601>>>>>>>>>>>    Append sMessage "' does not yet exist,\n"
86602>>>>>>>>>>>    Append sMessage "Do you want to create it now?"
86603>>>>>>>>>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
86604>>>>>>>>>>>    Case Begin
86604>>>>>>>>>>>      Case (iUsers_Choice = MBR_Yes)
86606>>>>>>>>>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
86607>>>>>>>>>>>        If bIsNotValid Begin
86609>>>>>>>>>>>          Move "An error occurred while trying to create folder '" To sMessage
86610>>>>>>>>>>>          Append sMessage sFolderName "'.\n\n"
86612>>>>>>>>>>>          Send Info_Box sMessage "Info"
86613>>>>>>>>>>>          End
86613>>>>>>>>>>>>
86613>>>>>>>>>>>        Case Break
86614>>>>>>>>>>>      Case (iUsers_Choice = MBR_No)
86617>>>>>>>>>>>        Move dfTrue To bIsNotValid // Cancel the save
86618>>>>>>>>>>>        Case Break
86619>>>>>>>>>>>    Case End
86619>>>>>>>>>>>  End
86619>>>>>>>>>>>>
86619>>>>>>>>>>>  Function_Return bIsNotValid
86620>>>>>>>>>>>End_Function // vVerifyNewFolder
86621>>>>>>>>>>>
86621>>>>>>>>>>>
86621>>>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
86621>>>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
86621>>>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
86621>>>>>>>>>>>Procedure vShellExecute global String sOperation String sDocument String sParameters String sPath
86623>>>>>>>>>>>  Handle  hInstance hWnd
86623>>>>>>>>>>>  Pointer lpsOperation
86623>>>>>>>>>>>  Pointer lpsDocument
86623>>>>>>>>>>>  Pointer lpsParameters
86623>>>>>>>>>>>  Pointer lpsPath
86623>>>>>>>>>>>  // remove any leading/trailing spaces in the string
86623>>>>>>>>>>>  Move (Trim(sDocument)) To sDocument
86624>>>>>>>>>>>  Move (Trim(sPath))     To sPath
86625>>>>>>>>>>>  // Make the strings readable for windows API, by converting them to null-terminated
86625>>>>>>>>>>>  Append sOperation   (Character(0))
86626>>>>>>>>>>>  Append sDocument    (Character(0))
86627>>>>>>>>>>>  Append sParameters  (Character(0))
86628>>>>>>>>>>>  Append sPath        (Character(0))
86629>>>>>>>>>>>  // Connect the corresponding pointers to the strings
86629>>>>>>>>>>>  GetAddress Of sOperation  To lpsOperation
86630>>>>>>>>>>>  GetAddress Of sDocument   To lpsDocument
86631>>>>>>>>>>>  GetAddress Of sParameters To lpsParameters
86632>>>>>>>>>>>  GetAddress Of sPath       To lpsPath
86633>>>>>>>>>>>
86633>>>>>>>>>>>  Get Window_Handle To hWnd
86634>>>>>>>>>>>  Move (vWin32_ShellExecute (hWnd, lpsOperation, lpsDocument, lpsParameters, lpsPath, 1)) To hInstance
86635>>>>>>>>>>>  If (hInstance <= 32) Begin
86637>>>>>>>>>>>    Send vDDE_Error_Handler hInstance
86638>>>>>>>>>>>  End
86638>>>>>>>>>>>>
86638>>>>>>>>>>>End_Procedure // vShellExecute
86639>>>>>>>>>>>
86639>>>>>>>>>>>
86639>>>>>>>>>>>Class cShellFileOperations Is a Array
86640>>>>>>>>>>>
86640>>>>>>>>>>>  Procedure Construct_Object
86642>>>>>>>>>>>    Forward Send Construct_Object
86644>>>>>>>>>>>    Property Integer piDeleteFlags        Public 0
86645>>>>>>>>>>>    Property Integer piCopyFlags          Public 0
86646>>>>>>>>>>>    Property Integer piMoveFlags          Public 0
86647>>>>>>>>>>>    Property Integer piRenameFlags        Public 0
86648>>>>>>>>>>>
86648>>>>>>>>>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
86649>>>>>>>>>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
86650>>>>>>>>>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
86651>>>>>>>>>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
86652>>>>>>>>>>>  End_Procedure // Construct_Object
86653>>>>>>>>>>>
86653>>>>>>>>>>>
86653>>>>>>>>>>>  // This function uses the shell API to perform a file operation on the
86653>>>>>>>>>>>  // files supplied.
86653>>>>>>>>>>>  //
86653>>>>>>>>>>>  Function FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
86655>>>>>>>>>>>    String   sShFileOp
86655>>>>>>>>>>>    Pointer  lpShFileOp
86655>>>>>>>>>>>    Pointer  lpsSource
86655>>>>>>>>>>>    Pointer  lpsDestination
86655>>>>>>>>>>>    Integer  iRetVal
86655>>>>>>>>>>>    Integer  bUserAbort
86655>>>>>>>>>>>
86655>>>>>>>>>>>    ZeroType vtShFileOpStruct To sShFileOp
86656>>>>>>>>>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
86657>>>>>>>>>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
86658>>>>>>>>>>>    GetAddress Of sSource    To lpsSource
86659>>>>>>>>>>>    If iOperation Ne vFO_DELETE Begin
86661>>>>>>>>>>>      GetAddress Of sDestination      To lpsDestination
86662>>>>>>>>>>>      Put lpsDestination To sShFileOp At vtShFileOpStruct.pTo
86663>>>>>>>>>>>    End
86663>>>>>>>>>>>>
86663>>>>>>>>>>>
86663>>>>>>>>>>>    Put iOperation     To sShFileOp At vtShFileOpStruct.wFunc
86664>>>>>>>>>>>    Put lpsSource      To sShFileOp At vtShFileOpStruct.pFrom
86665>>>>>>>>>>>    Put iFlags         To sShFileOp At vtShFileOpStruct.fFlags
86666>>>>>>>>>>>
86666>>>>>>>>>>>    GetAddress Of sShFileOp To lpShFileOp
86667>>>>>>>>>>>
86667>>>>>>>>>>>    Move (vWin32_SHFileOperation(lpShFileOp)) To iRetVal
86668>>>>>>>>>>>    GetBuff From sShFileOp At vtShFileOpStruct.fAnyOperationsAborted To bUserAbort
86669>>>>>>>>>>>    If (bUserAbort <> 0) Begin
86671>>>>>>>>>>>      Move 80 To iRetVal  // file Operation Aborted by USER
86672>>>>>>>>>>>    End
86672>>>>>>>>>>>>
86672>>>>>>>>>>>    Function_Return (iRetVal)
86673>>>>>>>>>>>  End_Function // FileOperation
86674>>>>>>>>>>>
86674>>>>>>>>>>>
86674>>>>>>>>>>>  Function sfoDeleteFile String sFileName Returns Integer
86676>>>>>>>>>>>    Integer  iRetVal
86676>>>>>>>>>>>    Integer  iFlags
86676>>>>>>>>>>>
86676>>>>>>>>>>>    Get piDeleteFlags To iFlags
86677>>>>>>>>>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
86678>>>>>>>>>>>    Function_Return iRetVal
86679>>>>>>>>>>>  End_Function // sfoDeleteFile
86680>>>>>>>>>>>
86680>>>>>>>>>>>
86680>>>>>>>>>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
86682>>>>>>>>>>>    Integer  iRetVal
86682>>>>>>>>>>>    Integer  iFlags
86682>>>>>>>>>>>
86682>>>>>>>>>>>    Get piCopyFlags To iFlags
86683>>>>>>>>>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
86684>>>>>>>>>>>    Function_Return iRetVal
86685>>>>>>>>>>>  End_Function // sfoCopyFile
86686>>>>>>>>>>>
86686>>>>>>>>>>>
86686>>>>>>>>>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
86688>>>>>>>>>>>    Integer  iRetVal
86688>>>>>>>>>>>    Integer  iFlags
86688>>>>>>>>>>>
86688>>>>>>>>>>>    Get piMoveFlags To iFlags
86689>>>>>>>>>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
86690>>>>>>>>>>>    Function_Return iRetVal
86691>>>>>>>>>>>  End_Function // sfoMoveFile
86692>>>>>>>>>>>
86692>>>>>>>>>>>
86692>>>>>>>>>>>  // Rename a file or folder
86692>>>>>>>>>>>  // Returns a nonzero value if the operation failed.
86692>>>>>>>>>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
86694>>>>>>>>>>>    Integer  iRetVal
86694>>>>>>>>>>>    Integer  iFlags
86694>>>>>>>>>>>
86694>>>>>>>>>>>    Get piRenameFlags To iFlags
86695>>>>>>>>>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
86696>>>>>>>>>>>    Function_Return iRetVal
86697>>>>>>>>>>>  End_Function // sfoRenameFile
86698>>>>>>>>>>>
86698>>>>>>>>>>>  // Courtesy Of Steve Walter
86698>>>>>>>>>>>  // Requires Windows 2000 and up according to msdn but it was
86698>>>>>>>>>>>  //  in fact available before that as an unpublished API call
86698>>>>>>>>>>>  //  a little google search shows that this was already available
86698>>>>>>>>>>>  //  in windows 95 and NT
86698>>>>>>>>>>>  //
86698>>>>>>>>>>>  // The format is controlled by the dialog interface.
86698>>>>>>>>>>>  // That is, the user must click the OK button To actually Begin the format
86698>>>>>>>>>>>  // the format cannot be started programmatically.
86698>>>>>>>>>>>  // An alternative to this functionality would be to use a controlpanel
86698>>>>>>>>>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
86698>>>>>>>>>>>  //
86698>>>>>>>>>>>  // hWnd = The windows handle of the object from which the format Function
86698>>>>>>>>>>>  //        is called.
86698>>>>>>>>>>>  // To Get this,
86698>>>>>>>>>>>  //          use:  Get Window_Handle Of <object>
86698>>>>>>>>>>>  //          For instance, in this app, we're going to use the Report_Panel:
86698>>>>>>>>>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
86698>>>>>>>>>>>  //
86698>>>>>>>>>>>  // sDrive = The drive letter. At this moment only A and B are valid
86698>>>>>>>>>>>  //
86698>>>>>>>>>>>  // iOptions = Format options.
86698>>>>>>>>>>>  //  SHFMT_OPT_DEFAULT = Quick format
86698>>>>>>>>>>>  //  SHFMT_OPT_FULL    = Full Format
86698>>>>>>>>>>>  //  SHFMT_OPT_SYSONLY = System only
86698>>>>>>>>>>>  //  3                 = Full format with system. (unsupported)
86698>>>>>>>>>>>  //
86698>>>>>>>>>>>  // Return Values:
86698>>>>>>>>>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
86698>>>>>>>>>>>  //  SHFMT_CANCEL   = Format cancelled by user.
86698>>>>>>>>>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
86698>>>>>>>>>>>  //
86698>>>>>>>>>>>  //
86698>>>>>>>>>>>  // *** ATTENTION: This function has been disabled as it doesn't
86698>>>>>>>>>>>  //                seem to work, i must have made a silly mistake
86698>>>>>>>>>>>  //                somewhere.
86698>>>>>>>>>>>  //
86698>>>>>>>>>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
86700>>>>>>>>>>>    Handle   hWnd
86700>>>>>>>>>>>    Integer  iObj
86700>>>>>>>>>>>    DWORD    dwReturnVal
86700>>>>>>>>>>>    Integer iDrive
86700>>>>>>>>>>>
86700>>>>>>>>>>>    Function_Return (1) // STOP HERE
86701>>>>>>>>>>>
86701>>>>>>>>>>>    Move (Trim(sDrive)) To sDrive
86702>>>>>>>>>>>    If ( sDrive <> '' ) Begin
86704>>>>>>>>>>>      If ( sDrive Contains ':' ) Move (Replace(':',sDrive,'')) To sDrive
86707>>>>>>>>>>>      If (Not( 'AB' Contains sDrive )) Function_Return (SHFMT_NOFORMAT)
86710>>>>>>>>>>>      If ( sDrive = 'A' ) Move 0 To iDrive
86713>>>>>>>>>>>      Else If ( sDrive = 'B' ) Move 1 To iDrive
86717>>>>>>>>>>>      // Window_Handle Of Desktop equals to 0
86717>>>>>>>>>>>
86717>>>>>>>>>>>      Get focus Of desktop To iObj
86718>>>>>>>>>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
86721>>>>>>>>>>>      While (hWnd=0 And iObj<>Desktop)
86725>>>>>>>>>>>          Get Parent Of iObj To iObj
86726>>>>>>>>>>>          Get Container_Handle Of iObj To hWnd
86727>>>>>>>>>>>      End
86728>>>>>>>>>>>>
86728>>>>>>>>>>>
86728>>>>>>>>>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
86728>>>>>>>>>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
86729>>>>>>>>>>>    End
86729>>>>>>>>>>>>
86729>>>>>>>>>>>    Else Begin
86730>>>>>>>>>>>      Move (SHFMT_ERROR) To dwReturnVal
86731>>>>>>>>>>>    End
86731>>>>>>>>>>>>
86731>>>>>>>>>>>    Function_Return dwReturnVal
86732>>>>>>>>>>>  End_Function // sfoFormatDisk
86733>>>>>>>>>>>
86733>>>>>>>>>>>  //Example:
86733>>>>>>>>>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
86733>>>>>>>>>>>  //                                          mode.
86733>>>>>>>>>>>
86733>>>>>>>>>>>End_Class // cShellFileOperations
86734>>>>>>>>>>>
86734>>>>>>>>>>>
86734>>>>>>>>>>>Object oShellFileOperations Is a cShellFileOperations
86736>>>>>>>>>>>End_Object // oShellFileOperations
86737>>>>>>>>>>>
86737>>>>>>>>>>>
86737>>>>>>>>>>>// Restore to the old way of working with the shell file operations.
86737>>>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
86737>>>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
86737>>>>>>>>>>>Procedure vWin32fhCompatibilityMode
86740>>>>>>>>>>>  Integer hoSFO
86740>>>>>>>>>>>  Integer iFlags
86740>>>>>>>>>>>
86740>>>>>>>>>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
86741>>>>>>>>>>>  Move (oShellFileOperations(Self)) To hoSFO
86742>>>>>>>>>>>
86742>>>>>>>>>>>  Set piDeleteFlags Of hoSFO To iFlags
86743>>>>>>>>>>>  Set piCopyFlags   Of hoSFO To iFlags
86744>>>>>>>>>>>  Set piMoveFlags   Of hoSFO To iFlags
86745>>>>>>>>>>>  Set piRenameFlags Of hoSFO To iFlags
86746>>>>>>>>>>>End_Procedure // vWin32fhCompatibilityMode
86747>>>>>>>>>>>
86747>>>>>>>>>>>
86747>>>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
86749>>>>>>>>>>>  Integer  iRetVal
86749>>>>>>>>>>>
86749>>>>>>>>>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
86750>>>>>>>>>>>  Function_Return iRetVal
86751>>>>>>>>>>>End_Function // vDeleteFile
86752>>>>>>>>>>>
86752>>>>>>>>>>>
86752>>>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
86754>>>>>>>>>>>  Integer  iRetVal
86754>>>>>>>>>>>
86754>>>>>>>>>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
86755>>>>>>>>>>>  Function_Return iRetVal
86756>>>>>>>>>>>End_Function // vCopyFile
86757>>>>>>>>>>>
86757>>>>>>>>>>>
86757>>>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
86759>>>>>>>>>>>  Integer  iRetVal
86759>>>>>>>>>>>
86759>>>>>>>>>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
86760>>>>>>>>>>>  Function_Return iRetVal
86761>>>>>>>>>>>End_Function // vMoveFile
86762>>>>>>>>>>>
86762>>>>>>>>>>>
86762>>>>>>>>>>>// Rename a file or folder
86762>>>>>>>>>>>// Returns a nonzero value if the operation failed.
86762>>>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
86764>>>>>>>>>>>  Integer  iRetVal
86764>>>>>>>>>>>
86764>>>>>>>>>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
86765>>>>>>>>>>>  Function_Return iRetVal
86766>>>>>>>>>>>End_Function // vRenameFile
86767>>>>>>>>>>>
86767>>>>>>>>>>>
86767>>>>>>>>>>>
86767>>>>>>>>>>>Function vGetWindowsDirectory Returns String
86770>>>>>>>>>>>  String  sDirectory
86770>>>>>>>>>>>  Pointer lpDirectory
86770>>>>>>>>>>>  Integer iVoid
86770>>>>>>>>>>>
86770>>>>>>>>>>>  ZeroString vMAX_PATH To sDirectory
86771>>>>>>>>>>>  GetAddress Of sDirectory To lpDirectory
86772>>>>>>>>>>>
86772>>>>>>>>>>>  Move (vWin32_GetWindowsDirectory(lpDirectory, vMAX_PATH)) To iVoid
86773>>>>>>>>>>>  Function_Return (CString(sDirectory))  // **WvA: Changed to CString()
86774>>>>>>>>>>>End_Function // vGetWindowsDirectory
86775>>>>>>>>>>>
86775>>>>>>>>>>>
86775>>>>>>>>>>>
86775>>>>>>>>>>>
86775>>>>>>>>>>>// Courtesy of Marco Kuipers
86775>>>>>>>>>>>Function vMakeTempFile Returns String
86778>>>>>>>>>>>    Integer iRetval
86778>>>>>>>>>>>    String  sTempPath sTempFileName sPrefixString
86778>>>>>>>>>>>    Pointer lpTempPath lpTempFileName lpPrefixString
86778>>>>>>>>>>>
86778>>>>>>>>>>>    Move (Repeat (Character (0), 255)) To sTempPath
86779>>>>>>>>>>>    GetAddress Of sTempPath To lpTempPath
86780>>>>>>>>>>>    Move (vWin32_GetTempPath (255, lpTempPath)) To iRetVal
86781>>>>>>>>>>>
86781>>>>>>>>>>>    If (sTempPath = "") Begin
86783>>>>>>>>>>>       Get_Current_Directory To sTempPath
86784>>>>>>>>>>>    End
86784>>>>>>>>>>>>
86784>>>>>>>>>>>    Move (pad(sTempPath,vMax_Path-14)) To sTempPath // *WvA: 28-04-2005 Quote from msdn: The string cannot be longer than MAX_PATH-14 characters.
86785>>>>>>>>>>>    Move (Repeat (Character (0), 255)) To sTempFileName
86786>>>>>>>>>>>    GetAddress Of sTempFileName To lpTempFileName
86787>>>>>>>>>>>    Move ("tmp"+character(0)) To sPrefixString // **WvA: 28-04-2005 Added a null
86788>>>>>>>>>>>    GetAddress Of sPrefixString To lpPrefixString
86789>>>>>>>>>>>    GetAddress Of sTempPath To lpTempPath
86790>>>>>>>>>>>    Move (vWin32_GetTempFileName (lpTempPath, lpPrefixString, 0, lpTempFileName)) To iRetval
86791>>>>>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
86793>>>>>>>>>>>        Move "" To sTempFileName
86794>>>>>>>>>>>    End
86794>>>>>>>>>>>>
86794>>>>>>>>>>>
86794>>>>>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
86795>>>>>>>>>>>End_Function // vMakeTempFile
86796>>>>>>>>>>>
86796>>>>>>>>>>>
86796>>>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
86796>>>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
86796>>>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
86796>>>>>>>>>>>// does not take care of that.
86796>>>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
86799>>>>>>>>>>>    String sTempFileName
86799>>>>>>>>>>>    Integer iCnt iRetVal
86799>>>>>>>>>>>    Pointer lpTempFileName
86799>>>>>>>>>>>    Pointer lpPath
86799>>>>>>>>>>>    Pointer lpPrefix
86799>>>>>>>>>>>
86799>>>>>>>>>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
86800>>>>>>>>>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
86801>>>>>>>>>>>    Move (pad("", vMAX_PATH)) To sTempFileName
86802>>>>>>>>>>>    GetAddress Of sTempFileName To lpTempFileName
86803>>>>>>>>>>>    GetAddress Of sPath         To lpPath
86804>>>>>>>>>>>    GetAddress Of sPrefix       To lpPrefix
86805>>>>>>>>>>>
86805>>>>>>>>>>>    Move (vWin32_GetTempFileName(lpPath, lpPrefix, 0, lpTempFileName)) To iRetVal
86806>>>>>>>>>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
86807>>>>>>>>>>>    Function_Return sTempFileName
86808>>>>>>>>>>>End_Function // vCreateTempFileInPath
86809>>>>>>>>>>>
86809>>>>>>>>>>>//
86809>>>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
86809>>>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
86809>>>>>>>>>>>//
86809>>>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
86812>>>>>>>>>>>  String  sFolder
86812>>>>>>>>>>>  Integer iVoid
86812>>>>>>>>>>>  Pointer lpsFolder
86812>>>>>>>>>>>  Handle  hWnd
86812>>>>>>>>>>>  Move (Window_Handle(focus(desktop))) To hWnd
86813>>>>>>>>>>>
86813>>>>>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
86814>>>>>>>>>>>  GetAddress Of sFolder To lpsFolder
86815>>>>>>>>>>>
86815>>>>>>>>>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,lpsFolder)) To iVoid
86816>>>>>>>>>>>  Function_Return (CString(sFolder))
86817>>>>>>>>>>>End_Function // vSHGetFolderPath
86818>>>>>>>>>>>
86818>>>>>>>>>>>
86818>>>>>>>>>>>
86818>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
86818>>>>>>>>>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
86820>>>>>>>>>>>  String  sftTime sSystemTime sFormattedTime sFormattedDate
86820>>>>>>>>>>>  Pointer lpsftTime lpsSystemTime lpsFormattedTime lpsFormattedDate
86820>>>>>>>>>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
86820>>>>>>>>>>>
86820>>>>>>>>>>>  ZeroType vFileTime  To sftTime
86821>>>>>>>>>>>  Put dwLowDateTime  To sftTime At vFileTime.dwLowDateTime
86822>>>>>>>>>>>  Put dwHighDateTime To sftTime At vFileTime.dwHighDateTime
86823>>>>>>>>>>>  GetAddress Of sftTime To lpsftTime
86824>>>>>>>>>>>
86824>>>>>>>>>>>  ZeroType vSystemTime To sSystemTime
86825>>>>>>>>>>>  GetAddress Of sSystemTime To lpsSystemTime
86826>>>>>>>>>>>
86826>>>>>>>>>>>  Moveint (vWin32_FileTimeToSystemTime (lpsftTime, lpsSystemTime)) To iSuccess
86827>>>>>>>>>>>>
86827>>>>>>>>>>>  If iSuccess Eq DfTrue Begin
86829>>>>>>>>>>>    ZeroString 255 To sFormattedTime
86830>>>>>>>>>>>    GetAddress Of sFormattedTime To lpsFormattedTime
86831>>>>>>>>>>>    Length sFormattedTime To iLenCcTime
86832>>>>>>>>>>>>
86832>>>>>>>>>>>    Moveint (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedTime, iLenCcTime)) To iDataLength
86833>>>>>>>>>>>>
86833>>>>>>>>>>>    ZeroString 255 To sFormattedDate
86834>>>>>>>>>>>    GetAddress Of sFormattedDate To lpsFormattedDate
86835>>>>>>>>>>>    Length sFormattedDate To iLenCcDate
86836>>>>>>>>>>>>
86836>>>>>>>>>>>    Moveint (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, lpsSystemTime, 0, ;                             lpsFormattedDate, iLenCcDate)) To iDataLength
86837>>>>>>>>>>>>
86837>>>>>>>>>>>    Function_Return (Cstring (sFormattedDate)  * Cstring (sFormattedTime))
86838>>>>>>>>>>>  End // iSuccess
86838>>>>>>>>>>>>
86838>>>>>>>>>>>End_Function // vConvertFileDateTime
86839>>>>>>>>>>>
86839>>>>>>>>>>>
86839>>>>>>>>>>>// **WvA Removed, See the cFileSet class for an alternative
86839>>>>>>>>>>>//Procedure DoBrowseDir String sFilePath
86839>>>>>>>>>>>//End_Procedure // DoBrowseDir
86839>>>>>>>>>>>
86839>>>>>>>>>>>// **WvA:
86839>>>>>>>>>>>// A windows replacement for the standard function FileExists.
86839>>>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
86839>>>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
86839>>>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
86839>>>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
86839>>>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
86841>>>>>>>>>>>  String  sWin32FindData
86841>>>>>>>>>>>  String  sDirSep
86841>>>>>>>>>>>  Pointer lpsFilePathMask lpsWin32FindData
86841>>>>>>>>>>>  Handle  hFindFile
86841>>>>>>>>>>>  Integer iVoid
86841>>>>>>>>>>>
86841>>>>>>>>>>>  Move vINVALID_HANDLE_VALUE To hFindFile
86842>>>>>>>>>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
86843>>>>>>>>>>>
86843>>>>>>>>>>>  If (length(sFilePathMask)>0) Begin
86845>>>>>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
86845>>>>>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
86846>>>>>>>>>>>    While (Right(sFilePathMask, 1) = sDirSep)
86850>>>>>>>>>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
86851>>>>>>>>>>>    Loop
86852>>>>>>>>>>>>
86852>>>>>>>>>>>
86852>>>>>>>>>>>    GetAddress Of sFilePathMask To lpsFilePathMask
86853>>>>>>>>>>>    ZeroType vWin32_Find_Data To sWin32FindData
86854>>>>>>>>>>>    GetAddress Of sWin32FindData To lpswin32FindData
86855>>>>>>>>>>>    Move (vWin32_FindFirstFile (lpsFilePathMask, lpsWin32FindData)) To hFindFile
86856>>>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
86857>>>>>>>>>>>  End
86857>>>>>>>>>>>>
86857>>>>>>>>>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
86858>>>>>>>>>>>End_Function // vFilePathExists
86859>>>>>>>>>>>
86859>>>>>>>>>>>
86859>>>>>>>>>>>// **WvA
86859>>>>>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
86859>>>>>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
86859>>>>>>>>>>>// The folder may contain a drive letter or UNC encoding.
86859>>>>>>>>>>>Function vFolderFormat Global String sFolderName Returns String
86861>>>>>>>>>>>  String sDirSep
86861>>>>>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
86862>>>>>>>>>>>  Move (Trim(sFolderName)) To sFolderName
86863>>>>>>>>>>>  If (Right(sFolderName,1)<>sDirSep) Begin
86865>>>>>>>>>>>    Move (sFolderName+sDirSep) To sFolderName
86866>>>>>>>>>>>  End
86866>>>>>>>>>>>>
86866>>>>>>>>>>>  Function_Return sFolderName
86867>>>>>>>>>>>End_Function // vFolderFormat
86868>>>>>>>>>>>//
86868>>>>>>>>>>>// Returns the amount of files in the folder (if it exists)
86868>>>>>>>>>>>// Returns -1 if folder doesn't exist.
86868>>>>>>>>>>>// The files "." and ".." are not counted.
86868>>>>>>>>>>>//
86868>>>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
86870>>>>>>>>>>>  Boolean bFound
86870>>>>>>>>>>>  Handle  hFindFile
86870>>>>>>>>>>>  Integer iCount  iVoid
86870>>>>>>>>>>>  Integer iSuccess
86870>>>>>>>>>>>  Pointer lpsFolderName lpsWin32FindData
86870>>>>>>>>>>>  String  sWin32FindData
86870>>>>>>>>>>>  String  sFileName
86870>>>>>>>>>>>
86870>>>>>>>>>>>  Move -1 To iCount
86871>>>>>>>>>>>  Get vFolderFormat sFolderName To sFolderName
86872>>>>>>>>>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
86873>>>>>>>>>>>  GetAddress Of sFolderName To lpsFolderName
86874>>>>>>>>>>>  ZeroType vWin32_Find_Data To sWin32FindData
86875>>>>>>>>>>>  GetAddress Of sWin32FindData To lpswin32FindData
86876>>>>>>>>>>>  Move (vWin32_FindFirstFile (lpsFolderName, lpsWin32FindData)) To hFindFile
86877>>>>>>>>>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
86878>>>>>>>>>>>  If (bFound) Move 0 To iCount
86881>>>>>>>>>>>  While (bFound)
86885>>>>>>>>>>>    Increment iCount
86886>>>>>>>>>>>    GetBuff_String From sWin32FindData At vWin32_Find_Data.cFileName To sFileName
86887>>>>>>>>>>>    If (sFileName="." or sFileName="..") Decrement iCount
86890>>>>>>>>>>>    Move (vWin32_FindNextFile(hFindFile, lpsWin32FindData)) To iSuccess
86891>>>>>>>>>>>    Move (iSuccess<>0) To bFound
86892>>>>>>>>>>>  Loop
86893>>>>>>>>>>>>
86893>>>>>>>>>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
86894>>>>>>>>>>>  Function_Return iCount
86895>>>>>>>>>>>End_Function // vFolderFileCount
86896>>>>>>>>>>>
86896>>>>>>>>>>>
86896>>>>>>>>>>>//
86896>>>>>>>>>>>// Gets the parent path of the currently supplied path
86896>>>>>>>>>>>// Returns "" when we are at the root folder.
86896>>>>>>>>>>>//
86896>>>>>>>>>>>Function vParentPath Global String sPath Returns String
86898>>>>>>>>>>>  String sStrip
86898>>>>>>>>>>>  Integer iLength
86898>>>>>>>>>>>  
86898>>>>>>>>>>>  If (Right(sPath,1)="\") Begin
86900>>>>>>>>>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
86901>>>>>>>>>>>  End
86901>>>>>>>>>>>>
86901>>>>>>>>>>>  If (Pos("\",sPath)) Begin
86903>>>>>>>>>>>    Move (StringFromRightOfChar(sPath,"\")) to sStrip
86904>>>>>>>>>>>    Move (Length(sStrip)) to iLength
86905>>>>>>>>>>>    Move (Left(sPath, (Length(sPath) - iLength -1))) to sPath
86906>>>>>>>>>>>//    Move (Replace(sStrip,sPath,"")) To sPath
86906>>>>>>>>>>>  End
86906>>>>>>>>>>>>
86906>>>>>>>>>>>  Else Begin
86907>>>>>>>>>>>    Move "" To sPath
86908>>>>>>>>>>>  End
86908>>>>>>>>>>>>
86908>>>>>>>>>>>  Function_Return sPath
86909>>>>>>>>>>>End_Function // vParentPath
86910>>>>>>>>>>>
86910>>>>>>>>>>>// Create the folder, including intermediate directories.
86910>>>>>>>>>>>// Don't panic if the folder already exists.
86910>>>>>>>>>>>// Michael Mullan June 2009.
86910>>>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
86912>>>>>>>>>>>  String  sFolder sSA
86912>>>>>>>>>>>  Pointer lpsFolder lpsSecurity_Attributes
86912>>>>>>>>>>>  Integer iRetval bFolderCreated bInheritHandle
86912>>>>>>>>>>>  Move (False) to bFolderCreated
86913>>>>>>>>>>>  // fill string variable with null characters
86913>>>>>>>>>>>  ZeroType vtSecurity_attributes to sSA
86914>>>>>>>>>>>  // null MAX_PATH chars into var (make space)
86914>>>>>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
86915>>>>>>>>>>>  If (sNewFolder <> "") Begin
86917>>>>>>>>>>>    Move dfTrue to  bInheritHandle
86918>>>>>>>>>>>    // Setting this to NULL is already done by the zerotype command
86918>>>>>>>>>>>    // Move NULL   To  lpDescriptor
86918>>>>>>>>>>>    Put (length(sSA))   to sSA At vtSecurity_attributes.nLength
86919>>>>>>>>>>>    //Put lpDescriptor To sSA at vtSecurity_attributes.lpDescriptor
86919>>>>>>>>>>>    Put bInheritHandle to sSA At vtSecurity_attributes.bInheritHandle
86920>>>>>>>>>>>    GetAddress of sSA to lpsSecurity_Attributes
86921>>>>>>>>>>>    //
86921>>>>>>>>>>>    Move sNewFolder to sFolder
86922>>>>>>>>>>>    GetAddress of sFolder to lpsFolder
86923>>>>>>>>>>>    Move (vWin32_SHCreateDirectoryEx(0,lpsFolder, lpsSecurity_Attributes)) to bFolderCreated
86924>>>>>>>>>>>  End
86924>>>>>>>>>>>>
86924>>>>>>>>>>>
86924>>>>>>>>>>>  If (bFolderCreated <> 0) Begin
86926>>>>>>>>>>>    Move 1 to iRetVal
86927>>>>>>>>>>>
86927>>>>>>>>>>>    If (bFolderCreated = 161 ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
86930>>>>>>>>>>>    Else If (bFolderCreated = 206 ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
86934>>>>>>>>>>>    Else If (bFolderCreated = 3   ) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
86938>>>>>>>>>>>    Else If (bFolderCreated = 80  ) Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
86942>>>>>>>>>>>    Else If (bFolderCreated = 183 ) Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
86946>>>>>>>>>>>    Else If (bFolderCreated = 1223) Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
86950>>>>>>>>>>>    Else Error DFERR_OPERATOR ("Folder Creation Error # " + String(bfoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
86952>>>>>>>>>>>  End
86952>>>>>>>>>>>>
86952>>>>>>>>>>>  Function_Return iRetVal
86953>>>>>>>>>>>End_Function // vshCreateDirectoryEX
86954>>>>>>>>>>>
86954>>>>>>>>>>>
86954>>>>>>>>>>>Function vWin32_APIFileSize Global string sFileName returns integer
86956>>>>>>>>>>>     dWord dwFileSizeHigh dwFileSizeLow
86956>>>>>>>>>>>     integer iFileSize iVoid
86956>>>>>>>>>>>     handle hFindFile
86956>>>>>>>>>>>     pointer lpsFilePath lpsWin32FindData
86956>>>>>>>>>>>     string sWin32FindData
86956>>>>>>>>>>>
86956>>>>>>>>>>>     GetAddress of sFileName to lpsFilePath
86957>>>>>>>>>>>
86957>>>>>>>>>>>     ZeroType vWin32_Find_Data to sWin32FindData
86958>>>>>>>>>>>     GetAddress of sWin32FindData to lpsWin32FindData
86959>>>>>>>>>>>
86959>>>>>>>>>>>     move (vWin32_FindFirstFile (lpsFilePath, lpsWin32FindData)) to hFindFile
86960>>>>>>>>>>>     if (hFindFile<>vINVALID_HANDLE_VALUE) begin
86962>>>>>>>>>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeHigh To dwFileSizeHigh
86963>>>>>>>>>>>         GetBuff From sWin32FindData At vWin32_Find_Data.nFileSizeLow To dwFileSizeLow
86964>>>>>>>>>>>     end
86964>>>>>>>>>>>>
86964>>>>>>>>>>>     move (vWin32_FindClose (hFindFile)) to iVoid
86965>>>>>>>>>>>
86965>>>>>>>>>>>     moveInt ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
86966>>>>>>>>>>>>
86966>>>>>>>>>>>
86966>>>>>>>>>>>     function_return iFileSize
86967>>>>>>>>>>>End_Function  // vWin32_APIFileSize
86968>>>>>>>>>>>
86968>>>>>>>>>>>
86968>>>>>>>>>
86968>>>>>>>>>Use DUFLanguageConstants.inc
86968>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\MertechDUF.pkg)
86968>>>>>>>>>>>//
86968>>>>>>>>>>>// Use of Mertech drivers:
86968>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
86968>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
86968>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
86968>>>>>>>>>>>//
#REM USE MERTECH.INC
86968>>>>>>>>>>>    Use Flex2SQLDUF.pkg
Including file: Flex2SQLDUF.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Flex2SQLDUF.pkg)
86968>>>>>>>>>>>>>//*************************************************************************
86968>>>>>>>>>>>>>//*                                                                       *
86968>>>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
86968>>>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
86968>>>>>>>>>>>>>//*  All rights reserved.                                                 *
86968>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
86968>>>>>>>>>>>>>//*                                                                       *
86968>>>>>>>>>>>>>//*  NOTE: This version of Flex2SQL is specially adapted to be used with  *
86968>>>>>>>>>>>>>// * the Database Update Framework (DUF)                                  *
86968>>>>>>>>>>>>>// *                                                                      *
86968>>>>>>>>>>>>>//*************************************************************************
86968>>>>>>>>>>>>>Use mertech.inc
86968>>>>>>>>>>>>>Use cli.pkg
86968>>>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 1.0.3 FOR DATAFLEX UPDATE FRAMEWORK
#REM -----------------------------------------------
86968>>>>>>>>>>>>>
86968>>>>>>>>>>>>>Struct tCLIHandleMap
86968>>>>>>>>>>>>>    Integer iHdbc
86968>>>>>>>>>>>>>    String sDriver
86968>>>>>>>>>>>>>    String sConnect
86968>>>>>>>>>>>>>End_Struct
86968>>>>>>>>>>>>>
86968>>>>>>>>>>>>>Struct tColumnMap
86968>>>>>>>>>>>>>    Integer iFileNum
86968>>>>>>>>>>>>>    Variant[] vResultColumn
86968>>>>>>>>>>>>>End_Struct
86968>>>>>>>>>>>>>
86968>>>>>>>>>>>>>//*** Embedded SQL statement attribute constants
86968>>>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
86968>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
86968>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
86968>>>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
86968>>>>>>>>>>>>>
86968>>>>>>>>>>>>>//*** Embedded SQL column attribute constants
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
86968>>>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
86968>>>>>>>>>>>>>
86968>>>>>>>>>>>>>
86968>>>>>>>>>>>>>//*** Enforced DAC SQL.PKG Compatibility
86968>>>>>>>>>>>>>Define SQL_DAC_HIGH_COMPATABILITY for 1
86968>>>>>>>>>>>>>Define SQL_DAC_NORMAL_COMPATIBILITY  for 0
86968>>>>>>>>>>>>>
86968>>>>>>>>>>>>>Global_Variable Integer giSQLCompatibilityMode
86968>>>>>>>>>>>>>Move SQL_DAC_NORMAL_COMPATIBILITY to giSQLCompatibilityMode
86969>>>>>>>>>>>>>
86969>>>>>>>>>>>>>//*** Global object handle for the manager
86969>>>>>>>>>>>>>Handle _embsqlghoSQLHandleMngr
86969>>>>>>>>>>>>>Register_Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
86969>>>>>>>>>>>>>
86969>>>>>>>>>>>>>Class cSQLStatementDUF is a cObject
86970>>>>>>>>>>>>>    Procedure Construct_Object
86972>>>>>>>>>>>>>        Forward Send Construct_Object
86974>>>>>>>>>>>>>
86974>>>>>>>>>>>>>        Property Integer phCLIHandle      0
86975>>>>>>>>>>>>>        Property Integer piLastColumn     0
86976>>>>>>>>>>>>>        Property Integer piLastArgument   0
86977>>>>>>>>>>>>>        Property Integer piBindFile       0
86978>>>>>>>>>>>>>        Property Integer piCursorNum      0
86979>>>>>>>>>>>>>        Property Boolean pisBeforeFetch   True
86980>>>>>>>>>>>>>        Property Integer piParameterCount 0
86981>>>>>>>>>>>>>
86981>>>>>>>>>>>>>        Property Integer piDataChunkOffset 0
86982>>>>>>>>>>>>>        Property String psProcName ""
86983>>>>>>>>>>>>>        Property String psSchemaName ""
86984>>>>>>>>>>>>>        Property Variant[] pvParams
86985>>>>>>>>>>>>>        Property tColumnMap ptColumnMap
86986>>>>>>>>>>>>>    End_Procedure
86987>>>>>>>>>>>>>
86987>>>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns String
86989>>>>>>>>>>>>>        Integer hoCLIHandler
86989>>>>>>>>>>>>>        Date dDFDate
86989>>>>>>>>>>>>>
86989>>>>>>>>>>>>>        //*** Create a CLI handler object
86989>>>>>>>>>>>>>        Object oSQLDFCLIHandler is a cCLIHandler
86991>>>>>>>>>>>>>            Move Current_Object to hoCLIHandler
86992>>>>>>>>>>>>>        End_Object // oCLIHandler
86993>>>>>>>>>>>>>
86993>>>>>>>>>>>>>        //*** Convert the date
86993>>>>>>>>>>>>>        Get CLISQLDateToDFDate of hoCLIHandler (psDRiverID(Current_Object)) sSQLDate to dDFDate
86994>>>>>>>>>>>>>
86994>>>>>>>>>>>>>        //*** Destroy the object
86994>>>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
86995>>>>>>>>>>>>>
86995>>>>>>>>>>>>>        Function_Return dDFDate
86996>>>>>>>>>>>>>    End_Function // SQLDateToDFDate
86997>>>>>>>>>>>>>
86997>>>>>>>>>>>>>    Function DFDateToSQLDate for cSQLStatementDUF Date dDFDate Returns String
86999>>>>>>>>>>>>>        Integer hoCLIHandler
86999>>>>>>>>>>>>>        String sSQLDate
86999>>>>>>>>>>>>>
86999>>>>>>>>>>>>>        //*** Create a CLI handler object
86999>>>>>>>>>>>>>        Object oDFSQLCLIHandler is a cCLIHandler
87001>>>>>>>>>>>>>            Move Current_Object to hoCLIHandler
87002>>>>>>>>>>>>>        End_Object // oCLIHandler
87003>>>>>>>>>>>>>
87003>>>>>>>>>>>>>        //*** Convert the date
87003>>>>>>>>>>>>>        Get CLIDFDateToSQLDate of hoCLIHandler (psDRiverID(Current_Object)) dDFDate to sSQLDate
87004>>>>>>>>>>>>>
87004>>>>>>>>>>>>>        //*** Destroy the object
87004>>>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
87005>>>>>>>>>>>>>
87005>>>>>>>>>>>>>        Function_Return sSQLDate
87006>>>>>>>>>>>>>    End_Function // DFDateToSQLDate
87007>>>>>>>>>>>>>
87007>>>>>>>>>>>>>
87007>>>>>>>>>>>>>    Function IsProcedure String sFunctionName Returns Boolean
87009>>>>>>>>>>>>>        String sRoutineType
87009>>>>>>>>>>>>>
87009>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87023>>>>>>>>>>>>>>
87023>>>>>>>>>>>>>
87023>>>>>>>>>>>>>        Case Begin
87023>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
87025>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select type from master.sys.sysobjects where name = '%1' union all select type from sys.sysobjects where name = '%1'", sFunctionName))
87033>>>>>>>>>>>>>                sql_prepare_stmt
87045>>>>>>>>>>>>>                sql_execute_stmt
87060>>>>>>>>>>>>>
87060>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
87084>>>>>>>>>>>>>>
87084>>>>>>>>>>>>>                If (sRoutineType = "P") Move "PROCEDURE" to sRoutineType
87087>>>>>>>>>>>>>                Else Move "FUNCTION" to sRoutineType
87089>>>>>>>>>>>>>                Case Break
87090>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
87093>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select routine_type from information_schema.routines where routine_name = '%1'", sFunctionName))
87101>>>>>>>>>>>>>                sql_prepare_stmt
87113>>>>>>>>>>>>>                sql_execute_stmt
87128>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
87152>>>>>>>>>>>>>>
87152>>>>>>>>>>>>>
87152>>>>>>>>>>>>>                Case Break
87153>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
87156>>>>>>>>>>>>>                sql_set_stmt  to (SFormat("SELECT object_type from all_objects where object_name = '%1'", sFunctionName))
87164>>>>>>>>>>>>>                sql_prepare_stmt
87176>>>>>>>>>>>>>                sql_execute_stmt
87191>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
87215>>>>>>>>>>>>>>
87215>>>>>>>>>>>>>
87215>>>>>>>>>>>>>                Case Break
87216>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
87219>>>>>>>>>>>>>                // Postgres doesn't differentiate between procedures and functions, so treat everything as procedures
87219>>>>>>>>>>>>>                // because that is better tested.
87219>>>>>>>>>>>>>                Move "PROCEDURE" to sRoutineType
87220>>>>>>>>>>>>>                Case Break
87221>>>>>>>>>>>>>        Case End
87221>>>>>>>>>>>>>
87221>>>>>>>>>>>>>        Function_Return (sRoutineType = "PROCEDURE")
87222>>>>>>>>>>>>>    End_Function
87223>>>>>>>>>>>>>
87223>>>>>>>>>>>>>    Function ProcParams String sFunctionName Returns Variant[]
87225>>>>>>>>>>>>>        Variant[] vFuncParams
87226>>>>>>>>>>>>>        Integer i iParamType
87226>>>>>>>>>>>>>
87226>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87240>>>>>>>>>>>>>>
87240>>>>>>>>>>>>>
87240>>>>>>>>>>>>>        Case Begin
87240>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
87242>>>>>>>>>>>>>                sql_set_stmt to (SFormat("sys.sp_procedure_params_managed @procedure_name = '%1'", sFunctionName))
87250>>>>>>>>>>>>>                sql_prepare_stmt
87262>>>>>>>>>>>>>                sql_execute_stmt
87277>>>>>>>>>>>>>
87277>>>>>>>>>>>>>                Repeat
87277>>>>>>>>>>>>>>
87277>>>>>>>>>>>>>                    sql_fetch_next_row
87292>>>>>>>>>>>>>>
87292>>>>>>>>>>>>>                    If (Found) Begin
87294>>>>>>>>>>>>>                        sql_fetch_column 6 into iParamType
87299>>>>>>>>>>>>>
87299>>>>>>>>>>>>>                        If (iParamType = 1) Move "IN" to vFuncParams[i]
87302>>>>>>>>>>>>>                        If (iParamType = 2) Move "INOUT" to vFuncParams[i]
87305>>>>>>>>>>>>>                        If (iParamType = 3) Move "OUT" to vFuncParams[i]
87308>>>>>>>>>>>>>                        If (iParamType <> 4) Increment i
87311>>>>>>>>>>>>>                    End
87311>>>>>>>>>>>>>>
87311>>>>>>>>>>>>>                Until (not(Found))
87313>>>>>>>>>>>>>
87313>>>>>>>>>>>>>                Function_Return vFuncParams
87314>>>>>>>>>>>>>
87314>>>>>>>>>>>>>                Case Break
87315>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
87318>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select parameter_mode from INFORMATION_SCHEMA.PARAMETERS where SPECIFIC_NAME = '%1' order by ordinal_position", sFunctionName))
87326>>>>>>>>>>>>>                sql_prepare_stmt
87338>>>>>>>>>>>>>                sql_execute_stmt
87353>>>>>>>>>>>>>
87353>>>>>>>>>>>>>                Case Break
87354>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
87357>>>>>>>>>>>>>                sql_set_stmt to    "SELECT all_arguments.in_out as parameter_mode "
87365>>>>>>>>>>>>>                sql_append_stmt to "FROM all_objects inner join all_arguments on all_objects.object_id = all_arguments.object_id "
87373>>>>>>>>>>>>>                sql_append_stmt to (SFormat("WHERE all_objects.object_name = '%1' order by all_arguments.position", sFunctionName))
87381>>>>>>>>>>>>>                sql_prepare_stmt
87393>>>>>>>>>>>>>                sql_execute_stmt
87408>>>>>>>>>>>>>
87408>>>>>>>>>>>>>                Case Break
87409>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
87412>>>>>>>>>>>>>                sql_set_stmt    to "select information_schema.parameters.parameter_mode "
87420>>>>>>>>>>>>>                sql_append_stmt to "from information_schema.routines inner join information_schema.parameters "
87428>>>>>>>>>>>>>                sql_append_stmt to "on information_schema.routines.specific_name=information_schema.parameters.specific_name "
87436>>>>>>>>>>>>>                sql_append_stmt to (SFormat("where information_schema.routines.routine_name = '%1' ", sFunctionName))
87444>>>>>>>>>>>>>                sql_append_stmt to "order by information_schema.parameters.ordinal_position"
87452>>>>>>>>>>>>>                sql_prepare_stmt
87464>>>>>>>>>>>>>                sql_execute_stmt
87479>>>>>>>>>>>>>
87479>>>>>>>>>>>>>                Case Break
87480>>>>>>>>>>>>>        Case End
87480>>>>>>>>>>>>>
87480>>>>>>>>>>>>>        Repeat
87480>>>>>>>>>>>>>>
87480>>>>>>>>>>>>>            sql_fetch_next_row into vFuncParams[i]
87504>>>>>>>>>>>>>>
87504>>>>>>>>>>>>>            Increment i
87505>>>>>>>>>>>>>        Until (not(Found))
87507>>>>>>>>>>>>>
87507>>>>>>>>>>>>>        Function_Return vFuncParams
87508>>>>>>>>>>>>>    End_Function
87509>>>>>>>>>>>>>
87509>>>>>>>>>>>>>    Procedure Set StoreHandleInfo Handle hConn
87511>>>>>>>>>>>>>        Set phCLIHandle to hConn
87512>>>>>>>>>>>>>    End_Procedure
87513>>>>>>>>>>>>>
87513>>>>>>>>>>>>>    Procedure FreeHandle
87515>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87529>>>>>>>>>>>>>>
87529>>>>>>>>>>>>>
87529>>>>>>>>>>>>>                                 Case Begin
87529>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
87531>>>>>>>>>>>>>                                END_CALL_PROCEDURE
87536>>>>>>>>>>>>>                Case Break
87537>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
87540>>>>>>>>>>>>>                Case Break
87541>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
87544>>>>>>>>>>>>>                Case Break
87545>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
87548>>>>>>>>>>>>>                Case Break
87549>>>>>>>>>>>>>        Case End
87549>>>>>>>>>>>>>
87549>>>>>>>>>>>>>
87549>>>>>>>>>>>>>        SQL_CLOSE_CURSOR_STMT to (piCursorNum(Self))
87563>>>>>>>>>>>>>>
87563>>>>>>>>>>>>>        Send Destroy_Object
87564>>>>>>>>>>>>>    End_Procedure // FreeHandle
87565>>>>>>>>>>>>>
87565>>>>>>>>>>>>>    Procedure SQLClose
87567>>>>>>>>>>>>>        Send FreeHandle
87568>>>>>>>>>>>>>    End_Procedure // SQLClose
87569>>>>>>>>>>>>>
87569>>>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
87571>>>>>>>>>>>>>        Integer iErrHandle
87571>>>>>>>>>>>>>        Integer iErrNum
87571>>>>>>>>>>>>>        String  sLocationInfo
87571>>>>>>>>>>>>>
87571>>>>>>>>>>>>>        //*** Get the DataFlex statement identifier
87571>>>>>>>>>>>>>        Move Current_object to iErrHandle
87572>>>>>>>>>>>>>
87572>>>>>>>>>>>>>        //*** Determine error number
87572>>>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
87575>>>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
87579>>>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
87583>>>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
87585>>>>>>>>>>>>>
87585>>>>>>>>>>>>>        //*** Create location information
87585>>>>>>>>>>>>>        Move "[" to sLocationInfo
87586>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
87588>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
87589>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
87590>>>>>>>>>>>>>        End
87590>>>>>>>>>>>>>>
87590>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
87591>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
87592>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
87593>>>>>>>>>>>>>
87593>>>>>>>>>>>>>        //*** Generate the error
87593>>>>>>>>>>>>>        Error iErrNum sLocationInfo
87594>>>>>>>>>>>>>>
87594>>>>>>>>>>>>>    End_Procedure
87595>>>>>>>>>>>>>
87595>>>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
87597>>>>>>>>>>>>>        Local Integer iErrHandle
87597>>>>>>>>>>>>>        Local String  sLocationInfo
87597>>>>>>>>>>>>>
87597>>>>>>>>>>>>>        //*** Get the DataFlex statement identifier
87597>>>>>>>>>>>>>        Move Current_object to iErrHandle
87598>>>>>>>>>>>>>
87598>>>>>>>>>>>>>
87598>>>>>>>>>>>>>        //*** Create location information
87598>>>>>>>>>>>>>        Move "[" to sLocationInfo
87599>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
87601>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
87602>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
87603>>>>>>>>>>>>>        End
87603>>>>>>>>>>>>>>
87603>>>>>>>>>>>>>        If (sErrtext <> "") Begin
87605>>>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
87606>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
87607>>>>>>>>>>>>>        End
87607>>>>>>>>>>>>>>
87607>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
87608>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
87609>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
87610>>>>>>>>>>>>>
87610>>>>>>>>>>>>>        //*** Generate the error
87610>>>>>>>>>>>>>        Error iErrNum sLocationInfo
87611>>>>>>>>>>>>>>
87611>>>>>>>>>>>>>    End_Procedure
87612>>>>>>>>>>>>>
87612>>>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
87614>>>>>>>>>>>>>        Local Integer bReport
87614>>>>>>>>>>>>>
87614>>>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
87617>>>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
87620>>>>>>>>>>>>>    End_Procedure // SQLIllegalAttribute
87621>>>>>>>>>>>>>
87621>>>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
87623>>>>>>>>>>>>>        String sResult
87623>>>>>>>>>>>>>        Integer iCols
87623>>>>>>>>>>>>>        Integer iOrgDateFmt
87623>>>>>>>>>>>>>        Integer iOrgDateSep
87623>>>>>>>>>>>>>        String sType
87623>>>>>>>>>>>>>
87623>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87637>>>>>>>>>>>>>>
87637>>>>>>>>>>>>>
87637>>>>>>>>>>>>>        SQL_GET_NUM_COLS to iCols
87647>>>>>>>>>>>>>>
87647>>>>>>>>>>>>>        If (iCol <= iCols) Begin
87649>>>>>>>>>>>>>            //DAC SQL Driver currently uses military format for the SQL getting of dates.
87649>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87651>>>>>>>>>>>>>                Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
87654>>>>>>>>>>>>>                Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
87657>>>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
87660>>>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
87663>>>>>>>>>>>>>            End
87663>>>>>>>>>>>>>>
87663>>>>>>>>>>>>>
87663>>>>>>>>>>>>>            //DAC SQL Driver cannot directly get TEXT fields into a result.
87663>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87665>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sType
87682>>>>>>>>>>>>>>
87682>>>>>>>>>>>>>                If (sType=5) Move "" to sResult
87685>>>>>>>>>>>>>                Else Begin
87686>>>>>>>>>>>>>                    SQL_FETCH_COLUMN iCol into sResult
87691>>>>>>>>>>>>>                End
87691>>>>>>>>>>>>>>
87691>>>>>>>>>>>>>            End
87691>>>>>>>>>>>>>>
87691>>>>>>>>>>>>>            Else Begin
87692>>>>>>>>>>>>>               SQL_FETCH_COLUMN iCol into sResult
87697>>>>>>>>>>>>>            End
87697>>>>>>>>>>>>>>
87697>>>>>>>>>>>>>
87697>>>>>>>>>>>>>
87697>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
87699>>>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
87702>>>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
87705>>>>>>>>>>>>>            End
87705>>>>>>>>>>>>>>
87705>>>>>>>>>>>>>
87705>>>>>>>>>>>>>            Function_Return sResult
87706>>>>>>>>>>>>>        End
87706>>>>>>>>>>>>>>
87706>>>>>>>>>>>>>        Else Send HandleError (phCLIHandle(Self)) (phCLIHandle(Parent(Self))) (psDriverID(Self)) "SQLColumnValue"
87708>>>>>>>>>>>>>    End_Function // SQLColumnValue
87709>>>>>>>>>>>>>
87709>>>>>>>>>>>>>    Function SQLNextColumn Returns String
87711>>>>>>>>>>>>>        Integer iCol
87711>>>>>>>>>>>>>        String  sResult
87711>>>>>>>>>>>>>
87711>>>>>>>>>>>>>        Get piLastColumn to iCol
87712>>>>>>>>>>>>>        Increment iCol
87713>>>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
87714>>>>>>>>>>>>>        Set piLastColumn to iCol
87715>>>>>>>>>>>>>
87715>>>>>>>>>>>>>        Function_Return sResult
87716>>>>>>>>>>>>>    End_Function // SQLNextColumn
87717>>>>>>>>>>>>>
87717>>>>>>>>>>>>>    Procedure SQLPrepare String sStatement
87719>>>>>>>>>>>>>        tColumnMap tColumnMap
87719>>>>>>>>>>>>>        tColumnMap tColumnMap
87719>>>>>>>>>>>>>        Set ptColumnMap to tColumnMap
87720>>>>>>>>>>>>>        Set pisBeforeFetch to True
87721>>>>>>>>>>>>>
87721>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87735>>>>>>>>>>>>>>
87735>>>>>>>>>>>>>        SQL_SET_STMT to sStatement
87743>>>>>>>>>>>>>
87743>>>>>>>>>>>>>        SQL_PREPARE_STMT
87755>>>>>>>>>>>>>    End_Procedure // SQLPrepare
87756>>>>>>>>>>>>>
87756>>>>>>>>>>>>>    Procedure SQLExecute
87758>>>>>>>>>>>>>        SQL_EXECUTE_STMT
87773>>>>>>>>>>>>>    End_Procedure
87774>>>>>>>>>>>>>
87774>>>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
87776>>>>>>>>>>>>>        tColumnMap tColumnMap
87776>>>>>>>>>>>>>        tColumnMap tColumnMap
87776>>>>>>>>>>>>>        Set ptColumnMap to tColumnMap
87777>>>>>>>>>>>>>        Set pisBeforeFetch to True
87778>>>>>>>>>>>>>
87778>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87792>>>>>>>>>>>>>>
87792>>>>>>>>>>>>>
87792>>>>>>>>>>>>>        SQL_SET_STMT to sStatement
87800>>>>>>>>>>>>>        SQL_PREPARE_STMT
87812>>>>>>>>>>>>>        SQL_EXECUTE_STMT
87827>>>>>>>>>>>>>    End_Procedure
87828>>>>>>>>>>>>>
87828>>>>>>>>>>>>>    Function SQLFetch Returns Integer
87830>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87844>>>>>>>>>>>>>>
87844>>>>>>>>>>>>>        Set pisBeforeFetch to False
87845>>>>>>>>>>>>>
87845>>>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
87860>>>>>>>>>>>>>>
87860>>>>>>>>>>>>>        Function_Return (Found)
87861>>>>>>>>>>>>>    End_Function
87862>>>>>>>>>>>>>
87862>>>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
87864>>>>>>>>>>>>>        tColumnMap tColumnMap
87864>>>>>>>>>>>>>        tColumnMap tColumnMap
87864>>>>>>>>>>>>>        String[] sBindFileColumns
87865>>>>>>>>>>>>>        Integer[] iBufferColumn
87866>>>>>>>>>>>>>        Integer iColCnt i iDateFormat iResultColumnType iBindFileColumnType
87866>>>>>>>>>>>>>        String sColumnName
87866>>>>>>>>>>>>>        Variant vFieldValue
87866>>>>>>>>>>>>>        Boolean isRecnumTable
87866>>>>>>>>>>>>>
87866>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
87880>>>>>>>>>>>>>>
87880>>>>>>>>>>>>>
87880>>>>>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFileNum to isRecnumTable
87883>>>>>>>>>>>>>        Get ptColumnMap to tColumnMap
87884>>>>>>>>>>>>>
87884>>>>>>>>>>>>>        If (tColumnMap.iFileNum <> iFileNum) Begin
87886>>>>>>>>>>>>>            Move iFileNum to tColumnMap.iFileNum
87887>>>>>>>>>>>>>
87887>>>>>>>>>>>>>            // First we build an array of the column names (in order) from the file buffer to bind to
87887>>>>>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNum to iColCnt
87890>>>>>>>>>>>>>            For i from 0 to iColCnt
87896>>>>>>>>>>>>>>
87896>>>>>>>>>>>>>                If (isRecnumTable) Get_Attribute DF_FIELD_NAME of iFileNum i to sColumnName
87901>>>>>>>>>>>>>                Else Move "" to sColumnName
87903>>>>>>>>>>>>>
87903>>>>>>>>>>>>>                Move (Uppercase(sColumnName)) to sBindFileColumns[i]
87904>>>>>>>>>>>>>            Loop
87905>>>>>>>>>>>>>>
87905>>>>>>>>>>>>>
87905>>>>>>>>>>>>>            // Next we iterate over the columns in the resultset.  Any column names that match we
87905>>>>>>>>>>>>>            // set its match location into an array that maps each resultset column to its matching
87905>>>>>>>>>>>>>            // column number in the file buffer.  If there is no match, we set that resultset
87905>>>>>>>>>>>>>            // column mappped column to -1.
87905>>>>>>>>>>>>>            //
87905>>>>>>>>>>>>>            // Since Arrays are zero based and columns are numbered from 1, when we actually map
87905>>>>>>>>>>>>>            // to set the value, we need to add 1 to array indexer to get the proper resultset
87905>>>>>>>>>>>>>            // column AND we need to add 1 to the mapped-to column since it was loaded into a zero
87905>>>>>>>>>>>>>            // based array also.  (Ex: vResultColumn[0] = 2 means column 1 from the resultset maps
87905>>>>>>>>>>>>>            // to Column 3 of the file buffer)
87905>>>>>>>>>>>>>
87905>>>>>>>>>>>>>
87905>>>>>>>>>>>>>            SQL_GET_NUM_COLS to iColCnt
87915>>>>>>>>>>>>>>
87915>>>>>>>>>>>>>            For i from 1 to iColCnt
87921>>>>>>>>>>>>>>
87921>>>>>>>>>>>>>                SQL_GET_COL_NAME i to sColumnName
87937>>>>>>>>>>>>>>
87937>>>>>>>>>>>>>                // Because SearchArray returns -1 if there isn't a match, we don't need to do
87937>>>>>>>>>>>>>                // anything to make an "unmapped column" have a value of -1.
87937>>>>>>>>>>>>>                Move (SearchArray(Uppercase(sColumnName), sBindFileColumns)) to tColumnMap.vResultColumn[i-1]
87938>>>>>>>>>>>>>
87938>>>>>>>>>>>>>                // If the types don't match between the columns, then "unmap" the column.  This
87938>>>>>>>>>>>>>                // should only occur when you're not mapping to the same file as the resultset.
87938>>>>>>>>>>>>>                // In this case, sql.pkg silently does nothing, so we need to duplicate this instead
87938>>>>>>>>>>>>>                // of generating an error.  If the mapping is to a string, then any type can be
87938>>>>>>>>>>>>>                // converted to a string so its okay.
87938>>>>>>>>>>>>>                If (tColumnMap.vResultColumn[i-1] <> -1) Begin
87940>>>>>>>>>>>>>                    SQL_GET_COL_ATTRIBUTE of i DFTYPE to iResultColumnType
87957>>>>>>>>>>>>>>
87957>>>>>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFileNum (tColumnMap.vResultColumn[i-1]) to iBindFileColumnType
87960>>>>>>>>>>>>>
87960>>>>>>>>>>>>>                    // If the conversion is to string (even if the resultset column is something
87960>>>>>>>>>>>>>                    // else) its ok, so Break out of the If block before we muck things up.
87960>>>>>>>>>>>>>                    If (iBindFileColumnType = DF_ASCII) Break
87963>>>>>>>>>>>>>
87963>>>>>>>>>>>>>                    // Otherwise, break the mapping
87963>>>>>>>>>>>>>                    If (iResultColumnType <> iBindFileColumnType) Move -1 to tColumnMap.vResultColumn[i-1]
87966>>>>>>>>>>>>>                End
87966>>>>>>>>>>>>>>
87966>>>>>>>>>>>>>            Loop
87967>>>>>>>>>>>>>>
87967>>>>>>>>>>>>>
87967>>>>>>>>>>>>>            Set ptColumnMap to tColumnMap
87968>>>>>>>>>>>>>        End
87968>>>>>>>>>>>>>>
87968>>>>>>>>>>>>>
87968>>>>>>>>>>>>>        Get SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
87969>>>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to True
87970>>>>>>>>>>>>>        Clear iFileNum
87971>>>>>>>>>>>>>        For i from 0 to (SizeOfArray(tColumnMap.vResultColumn)-1)
87977>>>>>>>>>>>>>>
87977>>>>>>>>>>>>>            If (tColumnMap.vResultColumn[i] > -1) Begin
87979>>>>>>>>>>>>>                SQL_FETCH_COLUMN (i+1) into vFieldValue
87984>>>>>>>>>>>>>                Set_Field_Value iFileNum (tColumnMap.vResultColumn[i]) to vFieldValue
87987>>>>>>>>>>>>>            End
87987>>>>>>>>>>>>>>
87987>>>>>>>>>>>>>        Loop
87988>>>>>>>>>>>>>>
87988>>>>>>>>>>>>>        Set_Attribute DF_FILE_STATUS of iFileNum to DF_FILE_ACTIVE
87991>>>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
87992>>>>>>>>>>>>>    End_Procedure
87993>>>>>>>>>>>>>
87993>>>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
87995>>>>>>>>>>>>>        String data
87995>>>>>>>>>>>>>        Integer retlen
87995>>>>>>>>>>>>>
87995>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
88009>>>>>>>>>>>>>>
88009>>>>>>>>>>>>>
88009>>>>>>>>>>>>>        SQL_SET_CHUNK_SIZE to iLen
88026>>>>>>>>>>>>>>
88026>>>>>>>>>>>>>        SQL_GET_DATA_CHUNK COLUMN iCol OFFSET (piDataChunkOffset(Self)) to data retlen
88036>>>>>>>>>>>>>>
88036>>>>>>>>>>>>>        Set piDataChunkOffset to (piDataChunkOffset(Self)+retlen)
88037>>>>>>>>>>>>>
88037>>>>>>>>>>>>>        Function_Return data
88038>>>>>>>>>>>>>    End_Function
88039>>>>>>>>>>>>>
88039>>>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
88041>>>>>>>>>>>>>        Integer iNumColumns i iIndex
88041>>>>>>>>>>>>>        String[] cols
88042>>>>>>>>>>>>>
88042>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
88056>>>>>>>>>>>>>>
88056>>>>>>>>>>>>>
88056>>>>>>>>>>>>>        Get SQLStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT to iNumColumns
88057>>>>>>>>>>>>>
88057>>>>>>>>>>>>>        For i from 1 to iNumColumns
88063>>>>>>>>>>>>>>
88063>>>>>>>>>>>>>            SQL_GET_COL_NAME i to cols[i-1]
88079>>>>>>>>>>>>>>
88079>>>>>>>>>>>>>            Move (trim(Uppercase(cols[i-1]))) to cols[i-1]
88080>>>>>>>>>>>>>        Loop
88081>>>>>>>>>>>>>>
88081>>>>>>>>>>>>>
88081>>>>>>>>>>>>>        Move (trim(Uppercase(sColname))) to sColname
88082>>>>>>>>>>>>>        Move (SearchArray(sColname, cols)) to iIndex
88083>>>>>>>>>>>>>        Function_Return (iIndex+1)  // even if searcharray returns -1 (not found) this expects 0 for not found, so it's ok
88084>>>>>>>>>>>>>    End_Function
88085>>>>>>>>>>>>>
88085>>>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
88087>>>>>>>>>>>>>        Integer iCnt
88087>>>>>>>>>>>>>
88087>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
88101>>>>>>>>>>>>>>
88101>>>>>>>>>>>>>
88101>>>>>>>>>>>>>        Case Begin
88101>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
88103>>>>>>>>>>>>>                SQL_GET_NUM_COLS to iCnt
88113>>>>>>>>>>>>>>
88113>>>>>>>>>>>>>                Function_Return iCnt
88114>>>>>>>>>>>>>                Case Break
88115>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
88118>>>>>>>>>>>>>                SQL_GET_NUM_ROWS to iCnt
88128>>>>>>>>>>>>>>
88128>>>>>>>>>>>>>
88128>>>>>>>>>>>>>                //DAC Driver doesn't know the rowcount before the first fetch.
88128>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
88130>>>>>>>>>>>>>                    If (pisBeforeFetch(Self)) Function_Return -1
88133>>>>>>>>>>>>>                End
88133>>>>>>>>>>>>>>
88133>>>>>>>>>>>>>
88133>>>>>>>>>>>>>                Function_Return iCnt
88134>>>>>>>>>>>>>                Case Break
88135>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
88138>>>>>>>>>>>>>                // TODO: Need something to indicate the quality of the SQL_GET_NUM_ROWS, or fake till I make it
88138>>>>>>>>>>>>>                Case Break
88139>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
88142>>>>>>>>>>>>>                Function_Return -1
88143>>>>>>>>>>>>>                // TODO: Are the messages returned in SQLGetMessage from the driver, or from the underlying connection?
88143>>>>>>>>>>>>>                Case Break
88144>>>>>>>>>>>>>            Case Else
88144>>>>>>>>>>>>>        Case End
88144>>>>>>>>>>>>>
88144>>>>>>>>>>>>>    End_Function
88145>>>>>>>>>>>>>
88145>>>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
88147>>>>>>>>>>>>>        String sValue
88147>>>>>>>>>>>>>        Integer iSQLType
88147>>>>>>>>>>>>>        Integer iDFType
88147>>>>>>>>>>>>>
88147>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
88161>>>>>>>>>>>>>>
88161>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol SQLTYPE to iSQLType
88178>>>>>>>>>>>>>>
88178>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to iDFType
88195>>>>>>>>>>>>>>
88195>>>>>>>>>>>>>
88195>>>>>>>>>>>>>        Case Begin
88195>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SIZE)
88197>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol SIZE to sValue
88214>>>>>>>>>>>>>>
88214>>>>>>>>>>>>>
88214>>>>>>>>>>>>>                //DAC Driver uses different values.
88214>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
88216>>>>>>>>>>>>>                    If (iSQLType=12) Move (Integer(sValue-1)) to sValue
88219>>>>>>>>>>>>>                    If (iDFType=5) Move "0" to sValue
88222>>>>>>>>>>>>>                    If (iSQLType=40)  Move "10" to sValue
88225>>>>>>>>>>>>>                End
88225>>>>>>>>>>>>>>
88225>>>>>>>>>>>>>
88225>>>>>>>>>>>>>                Case Break
88226>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_PRECISION)
88229>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DECIMALS to sValue
88246>>>>>>>>>>>>>>
88246>>>>>>>>>>>>>                Case Break
88247>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_LABEL)
88250>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
88267>>>>>>>>>>>>>>
88267>>>>>>>>>>>>>                Case Break
88268>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
88271>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
88288>>>>>>>>>>>>>>
88288>>>>>>>>>>>>>
88288>>>>>>>>>>>>>                //DAC Driver doesn't use Base Column Name.
88288>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
88290>>>>>>>>>>>>>                    Move "" to sValue
88291>>>>>>>>>>>>>                End
88291>>>>>>>>>>>>>>
88291>>>>>>>>>>>>>
88291>>>>>>>>>>>>>                Case Break
88292>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
88295>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol TABLE_NAME to sValue
88312>>>>>>>>>>>>>>
88312>>>>>>>>>>>>>                Case Break
88313>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
88316>>>>>>>>>>>>>                Move iSQLType to sValue
88317>>>>>>>>>>>>>
88317>>>>>>>>>>>>>                //DAC Driver uses different values.
88317>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
88319>>>>>>>>>>>>>                    If (iSQLType=2) Move "3" to sValue
88322>>>>>>>>>>>>>                    If (iSQLType=-99) Move "12" to sValue
88325>>>>>>>>>>>>>                    If (iSQLType=40)  Move "91" to sValue
88328>>>>>>>>>>>>>                End
88328>>>>>>>>>>>>>>
88328>>>>>>>>>>>>>
88328>>>>>>>>>>>>>                Case Break
88329>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_NULLABLE)
88332>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol NULLABLE to sValue
88349>>>>>>>>>>>>>>
88349>>>>>>>>>>>>>                Case Break
88350>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_DFTYPE)
88353>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sValue
88370>>>>>>>>>>>>>>
88370>>>>>>>>>>>>>
88370>>>>>>>>>>>>>                //DAC Driver uses different values.
88370>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
88372>>>>>>>>>>>>>                    If (iDFType = 5) Move "0" to sValue
88375>>>>>>>>>>>>>                End
88375>>>>>>>>>>>>>>
88375>>>>>>>>>>>>>                Case Break
88376>>>>>>>>>>>>>        Case End
88376>>>>>>>>>>>>>
88376>>>>>>>>>>>>>        Function_Return sValue
88377>>>>>>>>>>>>>    End_Function
88378>>>>>>>>>>>>>
88378>>>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
88380>>>>>>>>>>>>>        Set psProcName to sProcName
88381>>>>>>>>>>>>>        If (Num_Arguments >= 2) ;            Set psSchemaName to sSchemaArg
88384>>>>>>>>>>>>>        Else ;            Set psSchemaName to ""
88386>>>>>>>>>>>>>    End_Procedure
88387>>>>>>>>>>>>>
88387>>>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
88389>>>>>>>>>>>>>        Integer iArgnum
88389>>>>>>>>>>>>>
88389>>>>>>>>>>>>>        Get piLastArgument to iArgnum
88390>>>>>>>>>>>>>        Increment iArgnum
88391>>>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
88392>>>>>>>>>>>>>        Set piLastArgument to iArgnum
88393>>>>>>>>>>>>>    End_Procedure // SQLSetNextArgument
88394>>>>>>>>>>>>>
88394>>>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
88396>>>>>>>>>>>>>        Variant[] vParams
88397>>>>>>>>>>>>>
88397>>>>>>>>>>>>>        Get pvParams to vParams
88398>>>>>>>>>>>>>        Move sArgument to vParams[iArgnum-1]
88399>>>>>>>>>>>>>        Set pvParams to vParams
88400>>>>>>>>>>>>>
88400>>>>>>>>>>>>>    End_Procedure // SQLSetArgument
88401>>>>>>>>>>>>>
88401>>>>>>>>>>>>>    Procedure SQLCall
88403>>>>>>>>>>>>>        Variant[] vParams
88404>>>>>>>>>>>>>        Variant[] vParamOpts
88405>>>>>>>>>>>>>        Integer i
88405>>>>>>>>>>>>>        Integer iMax
88405>>>>>>>>>>>>>        Integer iParamsIn
88405>>>>>>>>>>>>>        String sParameter
88405>>>>>>>>>>>>>        Boolean bIsProcedure
88405>>>>>>>>>>>>>
88405>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
88419>>>>>>>>>>>>>>
88419>>>>>>>>>>>>>
88419>>>>>>>>>>>>>        Get pvParams to vParams
88420>>>>>>>>>>>>>
88420>>>>>>>>>>>>>        // First, we need to figure out if this is a procedure or a function. Then if
88420>>>>>>>>>>>>>        // it's a procedure, "analyze" it to figure out which parameters are IN,
88420>>>>>>>>>>>>>        // OUT, or IN_OUT.  Then we adjust how we call SQL_SET_PROCEDURE_PARAMETER
88420>>>>>>>>>>>>>        // so that after the call you can retrieve the value.
88420>>>>>>>>>>>>>
88420>>>>>>>>>>>>>        Get IsProcedure (psProcName(Self)) to bIsProcedure
88421>>>>>>>>>>>>>
88421>>>>>>>>>>>>>        If (bIsProcedure) Begin
88423>>>>>>>>>>>>>            Get ProcParams (psProcName(Self)) to vParamOpts
88424>>>>>>>>>>>>>
88424>>>>>>>>>>>>>            Move (sizeOfArray(vParamOpts)) to iMax
88425>>>>>>>>>>>>>            Move (SizeOfArray(vParams)) to iParamsIn
88426>>>>>>>>>>>>>            Set piParameterCount to iMax
88427>>>>>>>>>>>>>
88427>>>>>>>>>>>>>            SQL_SET_PROCEDURE_NAME (psProcName(Self)) NUMPAR iMax
88447>>>>>>>>>>>>>            For i from 1 to iMax
88453>>>>>>>>>>>>>>
88453>>>>>>>>>>>>>                If ( (i-1) >= iParamsIn) Move "" to sParameter
88456>>>>>>>>>>>>>                Else Move vParams[i-1] to sParameter
88458>>>>>>>>>>>>>
88458>>>>>>>>>>>>>                Case Begin
88458>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN")
88460>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN
88501>>>>>>>>>>>>>>
88501>>>>>>>>>>>>>                        Case Break
88502>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "OUT")
88505>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter OUT
88546>>>>>>>>>>>>>>
88546>>>>>>>>>>>>>                        Case Break
88547>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN/OUT" or vParamOpts[i-1] = "INOUT")
88550>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN_OUT
88591>>>>>>>>>>>>>>
88591>>>>>>>>>>>>>                        Case Break
88592>>>>>>>>>>>>>                Case End
88592>>>>>>>>>>>>>            Loop
88593>>>>>>>>>>>>>>
88593>>>>>>>>>>>>>
88593>>>>>>>>>>>>>            SQL_PROCEDURE_EXECUTE
88608>>>>>>>>>>>>>        End
88608>>>>>>>>>>>>>>
88608>>>>>>>>>>>>>        Else Begin
88609>>>>>>>>>>>>>            SQL_SET_FUNCTION_NAME (psProcName(Self)) NUMPAR (SizeOfArray(vParams))
88633>>>>>>>>>>>>>            For i from 1 to (SizeOfArray(vParams))
88639>>>>>>>>>>>>>>
88639>>>>>>>>>>>>>                SQL_SET_FUNCTION_PARAMETER i to vParams[i-1]
88711>>>>>>>>>>>>>>
88711>>>>>>>>>>>>>            Loop
88712>>>>>>>>>>>>>>
88712>>>>>>>>>>>>>
88712>>>>>>>>>>>>>            SQL_FUNCTION_EXECUTE
88713>>>>>>>>>>>>>        End
88713>>>>>>>>>>>>>>
88713>>>>>>>>>>>>>    End_Procedure
88714>>>>>>>>>>>>>
88714>>>>>>>>>>>>>    Function SQLGetNextArgument Returns String
88716>>>>>>>>>>>>>        Local Integer iArgnum
88716>>>>>>>>>>>>>        Local String  sResult
88716>>>>>>>>>>>>>
88716>>>>>>>>>>>>>        Get piLastArgument to iArgnum
88717>>>>>>>>>>>>>        Increment iArgnum
88718>>>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
88719>>>>>>>>>>>>>        Set piLastArgument to iArgnum
88720>>>>>>>>>>>>>
88720>>>>>>>>>>>>>        Function_Return sResult
88721>>>>>>>>>>>>>    End_Function // SQLGetNextArgument
88722>>>>>>>>>>>>>
88722>>>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
88724>>>>>>>>>>>>>        String retval
88724>>>>>>>>>>>>>
88724>>>>>>>>>>>>>        If ( (piParameterCount(Self)) < iArgnum) Function_Return ""
88727>>>>>>>>>>>>>        SQL_GET_PROCEDURE_PARAMETER iArgnum to retval
88751>>>>>>>>>>>>>>
88751>>>>>>>>>>>>>
88751>>>>>>>>>>>>>        Function_Return retval
88752>>>>>>>>>>>>>    End_Function
88753>>>>>>>>>>>>>
88753>>>>>>>>>>>>>    Function SQLReturnValue Returns String
88755>>>>>>>>>>>>>        String retval
88755>>>>>>>>>>>>>
88755>>>>>>>>>>>>>        SQL_GET_FUNCTION_RETURN to retval
88787>>>>>>>>>>>>>        Function_Return retval
88788>>>>>>>>>>>>>    End_Function
88789>>>>>>>>>>>>>
88789>>>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
88791>>>>>>>>>>>>>        SQL_NEXT_RESULT_SET
88803>>>>>>>>>>>>>
88803>>>>>>>>>>>>>        Function_Return (Found)
88804>>>>>>>>>>>>>    End_Function
88805>>>>>>>>>>>>>
88805>>>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
88807>>>>>>>>>>>>>        // TODO
88807>>>>>>>>>>>>>    End_Function
88808>>>>>>>>>>>>>
88808>>>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
88810>>>>>>>>>>>>>        // TODO
88810>>>>>>>>>>>>>    End_Procedure
88811>>>>>>>>>>>>>
88811>>>>>>>>>>>>>
88811>>>>>>>>>>>>>End_Class
88812>>>>>>>>>>>>>
88812>>>>>>>>>>>>>Class cSQLConnectionDUF is a cObject
88813>>>>>>>>>>>>>    Procedure Construct_Object
88815>>>>>>>>>>>>>        Forward Send Construct_Object
88817>>>>>>>>>>>>>
88817>>>>>>>>>>>>>        Property Handle phCLIHandle 0
88818>>>>>>>>>>>>>        Property String psDriverID MertechInc_DriverName
88819>>>>>>>>>>>>>        Property Integer piBindFile 0
88820>>>>>>>>>>>>>        Property String psUsername ""
88821>>>>>>>>>>>>>        Property String psPassword ""
88822>>>>>>>>>>>>>
88822>>>>>>>>>>>>>        Property String psCurrentDatabase ""
88823>>>>>>>>>>>>>
88823>>>>>>>>>>>>>        Property tCLIHandleMap ptCLIHandleMap
88824>>>>>>>>>>>>>    End_Procedure
88825>>>>>>>>>>>>>
88825>>>>>>>>>>>>>    Procedure StoreHandleInfo Handle hCLIHandle String sDrvrId Handle iParentHandle
88827>>>>>>>>>>>>>        Set phCLIHandle      to hCLIHandle
88828>>>>>>>>>>>>>        Set psDriverID       to sDrvrId
88829>>>>>>>>>>>>>    End_Procedure // StoreHandleInfo
88830>>>>>>>>>>>>>
88830>>>>>>>>>>>>>    Procedure FreeHandle
88832>>>>>>>>>>>>>        Send Destroy
88833>>>>>>>>>>>>>    End_Procedure
88834>>>>>>>>>>>>>
88834>>>>>>>>>>>>>    Procedure Set SQLDatabase String sDatabase
88836>>>>>>>>>>>>>        tCLIHandleMap conn
88836>>>>>>>>>>>>>        tCLIHandleMap conn
88836>>>>>>>>>>>>>
88836>>>>>>>>>>>>>        Get ptCLIHandleMap to conn
88837>>>>>>>>>>>>>        Set psCurrentDatabase to sDatabase
88838>>>>>>>>>>>>>        SQL_USE_DATABASE of conn.sConnect to sDatabase
88852>>>>>>>>>>>>>>
88852>>>>>>>>>>>>>    End_Procedure
88853>>>>>>>>>>>>>
88853>>>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect Returns Handle
88855>>>>>>>>>>>>>        tCLIHandleMap[] maps
88855>>>>>>>>>>>>>        tCLIHandleMap[] maps
88856>>>>>>>>>>>>>        tCLIHandleMap conn
88856>>>>>>>>>>>>>        tCLIHandleMap conn
88856>>>>>>>>>>>>>
88856>>>>>>>>>>>>>        Get ptCLIHandleMaps to maps
88857>>>>>>>>>>>>>        Move sDriver to conn.sDriver
88858>>>>>>>>>>>>>        Move sConnect to conn.sConnect
88859>>>>>>>>>>>>>
88859>>>>>>>>>>>>>        If (SizeOfArray(maps) > 0) Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
88862>>>>>>>>>>>>>        Else Move 1 to conn.iHdbc
88864>>>>>>>>>>>>>
88864>>>>>>>>>>>>>        Set CurrentConnection to sDriver sConnect
88865>>>>>>>>>>>>>        If (not(Err)) Begin
88867>>>>>>>>>>>>>            Move conn to maps[(SizeOfArray(maps))]
88868>>>>>>>>>>>>>            Set ptCLIHandleMaps to maps
88869>>>>>>>>>>>>>            Set ptCLIHandleMap to conn
88870>>>>>>>>>>>>>        End
88870>>>>>>>>>>>>>>
88870>>>>>>>>>>>>>
88870>>>>>>>>>>>>>        Function_Return Self
88871>>>>>>>>>>>>>    End_Function
88872>>>>>>>>>>>>>
88872>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
88874>>>>>>>>>>>>>        Boolean bIsOpen
88874>>>>>>>>>>>>>        String sDriver sServer
88874>>>>>>>>>>>>>        tCLIHandleMap[] maps
88874>>>>>>>>>>>>>        tCLIHandleMap[] maps
88875>>>>>>>>>>>>>        tCLIHandleMap conn
88875>>>>>>>>>>>>>        tCLIHandleMap conn
88875>>>>>>>>>>>>>
88875>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
88878>>>>>>>>>>>>>        If (bIsOpen) Begin
88880>>>>>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
88880>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDriver
88881>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sServer
88882>>>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDriver
88885>>>>>>>>>>>>>            Get_Attribute DF_FILE_SERVER_NAME of iFileNum to sServer
88888>>>>>>>>>>>>>
88888>>>>>>>>>>>>>            Indicate Err False
88889>>>>>>>>>>>>>
88889>>>>>>>>>>>>>            Get ptCLIHandleMaps to maps
88890>>>>>>>>>>>>>            Move sDriver to conn.sDriver
88891>>>>>>>>>>>>>            Move sServer to conn.sConnect
88892>>>>>>>>>>>>>
88892>>>>>>>>>>>>>            If (SizeOfArray(maps) > 0) Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
88895>>>>>>>>>>>>>            Else Move 1 to conn.iHdbc
88897>>>>>>>>>>>>>
88897>>>>>>>>>>>>>            Set CurrentConnection to sDriver sServer
88898>>>>>>>>>>>>>            If (not(Err)) Begin
88900>>>>>>>>>>>>>                Move conn to maps[(SizeOfArray(maps))]
88901>>>>>>>>>>>>>                Set ptCLIHandleMaps to maps
88902>>>>>>>>>>>>>                Set ptCLIHandleMap to conn
88903>>>>>>>>>>>>>            End
88903>>>>>>>>>>>>>>
88903>>>>>>>>>>>>>
88903>>>>>>>>>>>>>            Send StoreHandleInfo conn.iHdbc conn.sDriver
88904>>>>>>>>>>>>>            Set piBindFile to iFileNum
88905>>>>>>>>>>>>>        End
88905>>>>>>>>>>>>>>
88905>>>>>>>>>>>>>        Else Error 4099 "File Not Open"
88907>>>>>>>>>>>>>
88907>>>>>>>>>>>>>        //*** Return success status
88907>>>>>>>>>>>>>        Function_Return (not(Err))
88908>>>>>>>>>>>>>    End_Function
88909>>>>>>>>>>>>>
88909>>>>>>>>>>>>>    Procedure SQLDisconnect
88911>>>>>>>>>>>>>        tCLIHandleMap map
88911>>>>>>>>>>>>>        tCLIHandleMap map
88911>>>>>>>>>>>>>        tCLIHandleMap[] maps
88911>>>>>>>>>>>>>        tCLIHandleMap[] maps
88912>>>>>>>>>>>>>        Integer iFound
88912>>>>>>>>>>>>>
88912>>>>>>>>>>>>>        Get ptCLIHandleMap to map
88913>>>>>>>>>>>>>        Get ptCLIHandleMaps to maps
88914>>>>>>>>>>>>>
88914>>>>>>>>>>>>>        Move (SearchArray(map, maps, Parent(Self), RefFunc(CompareMaps))) to iFound
88915>>>>>>>>>>>>>        If (iFound > -1) Begin
88917>>>>>>>>>>>>>            Send FreeHandle
88918>>>>>>>>>>>>>        End
88918>>>>>>>>>>>>>>
88918>>>>>>>>>>>>>    End_Procedure // SQLDisconnect
88919>>>>>>>>>>>>>
88919>>>>>>>>>>>>>    Function CreateHandle Returns Integer
88921>>>>>>>>>>>>>        Handle hSQL
88921>>>>>>>>>>>>>        Integer iCursor
88921>>>>>>>>>>>>>
88921>>>>>>>>>>>>>        Get Create U_cSQLStatementDUF to hSQL
88922>>>>>>>>>>>>>
88922>>>>>>>>>>>>>        Set piBindFile of hSQL to (piBindFile(Current_object))
88923>>>>>>>>>>>>>
88923>>>>>>>>>>>>>        SQL_OPEN_CURSOR_STMT to iCursor
88937>>>>>>>>>>>>>>
88937>>>>>>>>>>>>>        Set piCursorNum of hSQL to iCursor
88938>>>>>>>>>>>>>
88938>>>>>>>>>>>>>        Function_Return hSQL
88939>>>>>>>>>>>>>    End_Function // CreateHandle
88940>>>>>>>>>>>>>
88940>>>>>>>>>>>>>    Function SQLOpen Returns Integer
88942>>>>>>>>>>>>>        Handle hDFHandle
88942>>>>>>>>>>>>>
88942>>>>>>>>>>>>>        Get CreateHandle to hDFHandle
88943>>>>>>>>>>>>>
88943>>>>>>>>>>>>>        Send StoreHandleInfo to hDFHandle Self (psDriverID(Self))
88944>>>>>>>>>>>>>
88944>>>>>>>>>>>>>        Function_Return hDFHandle
88945>>>>>>>>>>>>>    End_Function // SQLOpen
88946>>>>>>>>>>>>>
88946>>>>>>>>>>>>>
88946>>>>>>>>>>>>>
88946>>>>>>>>>>>>>
88946>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
88948>>>>>>>>>>>>>        String sCurrentDriver
88948>>>>>>>>>>>>>        Integer iDriver
88948>>>>>>>>>>>>>        Integer iNumDrivers
88948>>>>>>>>>>>>>
88948>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumDrivers
88951>>>>>>>>>>>>>        For iDriver from 1 to iNumDrivers
88957>>>>>>>>>>>>>>
88957>>>>>>>>>>>>>          Get_Attribute DF_DRIVER_NAME of iDriver to sCurrentDriver
88960>>>>>>>>>>>>>          If (Uppercase(sDriver) = Uppercase(sCurrentDriver)) ;              Function_Return iDriver
88963>>>>>>>>>>>>>        Loop
88964>>>>>>>>>>>>>>
88964>>>>>>>>>>>>>        Function_Return 0
88965>>>>>>>>>>>>>    End_Function // DriverIndex
88966>>>>>>>>>>>>>
88966>>>>>>>>>>>>>    Function FirstServerForDriverNo Integer iDriver Returns String
88968>>>>>>>>>>>>>        String sServer
88968>>>>>>>>>>>>>        Integer iNumServers
88968>>>>>>>>>>>>>        Integer iServer
88968>>>>>>>>>>>>>
88968>>>>>>>>>>>>>        If (iDriver <> 0) Begin
88970>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
88973>>>>>>>>>>>>>            If (iNumServers<>0) Begin
88975>>>>>>>>>>>>>                Move 1 to iServer
88976>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iServer to sServer
88979>>>>>>>>>>>>>            End
88979>>>>>>>>>>>>>>
88979>>>>>>>>>>>>>        End
88979>>>>>>>>>>>>>>
88979>>>>>>>>>>>>>
88979>>>>>>>>>>>>>        Function_Return sServer
88980>>>>>>>>>>>>>    End_Function
88981>>>>>>>>>>>>>
88981>>>>>>>>>>>>>    Procedure Set CurrentConnection String sDriver String sServer
88983>>>>>>>>>>>>>        Integer iDriver
88983>>>>>>>>>>>>>        String sUsername
88983>>>>>>>>>>>>>        String sPassword
88983>>>>>>>>>>>>>
88983>>>>>>>>>>>>>        If (sDriver="") Begin
88985>>>>>>>>>>>>>            DO_GETFILENUMBER_DRIVERNAME 0
88987>>>>>>>>>>>>>            Move MertechInc_DriverName to sDriver
88988>>>>>>>>>>>>>        End
88988>>>>>>>>>>>>>>
88988>>>>>>>>>>>>>
88988>>>>>>>>>>>>>        If ("MDSMYSQL|ORA_DRV|MDSPGSQL|SQL_DRV|MDS_DB2" contains Uppercase(Trim(sDriver))) Begin
88990>>>>>>>>>>>>>            Move (Uppercase(Trim(sDriver))) to MertechInc_DriverName
88991>>>>>>>>>>>>>
88991>>>>>>>>>>>>>            If (Trim(sDriver) <> "") Move (Uppercase(Trim(sDriver))) to MertechInc_CurrentDriver
88994>>>>>>>>>>>>>            Else Move "" to MertechInc_CurrentDriver
88996>>>>>>>>>>>>>
88996>>>>>>>>>>>>>            Get psUsername to sUsername
88997>>>>>>>>>>>>>            Get psPassword to sPassword
88998>>>>>>>>>>>>>
88998>>>>>>>>>>>>>            Get DriverIndex MertechInc_CurrentDriver to iDriver
88999>>>>>>>>>>>>>
88999>>>>>>>>>>>>>            If (sServer="") Get FirstServerForDriverNo iDriver to sServer
89002>>>>>>>>>>>>>            If (sUsername="") GET_CURRENT_USER_NAME of sServer to sUsername
89019>>>>>>>>>>>>>            If (sPassword="") get_current_user_password of sServer to sPassword
89036>>>>>>>>>>>>>            Move False to Err
89037>>>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 25000
89038>>>>>>>>>>>>>            Login sServer sUsername sPassword sDriver
89040>>>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 25000
89041>>>>>>>>>>>>>            If (Err = False) Begin
89043>>>>>>>>>>>>>                Call_Driver 0 MertechInc_DriverName Function CALLDRV_CURRENT_SQL_SERVER_CONNECTION CALLBACK 0 PASSING sServer MertechInc_Blank 0 RESULT MertechInc_iRet
89048>>>>>>>>>>>>>            End
89048>>>>>>>>>>>>>>
89048>>>>>>>>>>>>>            Else Begin
89049>>>>>>>>>>>>>                Procedure_Return
89050>>>>>>>>>>>>>            End
89050>>>>>>>>>>>>>>
89050>>>>>>>>>>>>>
89050>>>>>>>>>>>>>            If MertechInc_iRet EQ -1 INDICATE ERR True
89053>>>>>>>>>>>>>        End
89053>>>>>>>>>>>>>>
89053>>>>>>>>>>>>>        Else Error 4099 "Invalid Driver"
89055>>>>>>>>>>>>>
89055>>>>>>>>>>>>>    End_Procedure
89056>>>>>>>>>>>>>
89056>>>>>>>>>>>>>End_Class
89057>>>>>>>>>>>>>
89057>>>>>>>>>>>>>Class cSQLHandleManagerDUF is a cObject
89058>>>>>>>>>>>>>
89058>>>>>>>>>>>>>    Procedure Construct_Object
89060>>>>>>>>>>>>>        Forward Send Construct_Object
89062>>>>>>>>>>>>>
89062>>>>>>>>>>>>>        Property String  psDefaultDriver     ""
89063>>>>>>>>>>>>>        Property String  psDefaultConnection ""
89064>>>>>>>>>>>>>        Property tCLIHandleMap[] ptCLIHandleMaps
89065>>>>>>>>>>>>>    End_Procedure
89066>>>>>>>>>>>>>
89066>>>>>>>>>>>>>    Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
89068>>>>>>>>>>>>>        If ((map1.iHdbc = map2.iHdbc) and (map1.sConnect = map2.sConnect) and (map1.sDriver = map2.sDriver)) Begin
89070>>>>>>>>>>>>>            Function_Return (EQ)
89071>>>>>>>>>>>>>        End
89071>>>>>>>>>>>>>>
89071>>>>>>>>>>>>>    End_Function
89072>>>>>>>>>>>>>
89072>>>>>>>>>>>>>    Function CreateHandle Returns Handle
89074>>>>>>>>>>>>>        Handle hSQL
89074>>>>>>>>>>>>>
89074>>>>>>>>>>>>>        Get Create U_cSQLConnectionDUF to hSQL
89075>>>>>>>>>>>>>        Function_Return hSQL
89076>>>>>>>>>>>>>    End_Function
89077>>>>>>>>>>>>>
89077>>>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
89079>>>>>>>>>>>>>        Set psDefaultDriver to sDriver
89080>>>>>>>>>>>>>        Set psDefaultConnection to sConnect
89081>>>>>>>>>>>>>    End_Procedure
89082>>>>>>>>>>>>>
89082>>>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect String sUsername String sPassword Returns Handle
89084>>>>>>>>>>>>>        Handle hSql
89084>>>>>>>>>>>>>        Boolean bOK
89084>>>>>>>>>>>>>
89084>>>>>>>>>>>>>        Get CreateHandle to hSql
89085>>>>>>>>>>>>>
89085>>>>>>>>>>>>>        If (sDriver = "" and sConnect = "") Begin
89087>>>>>>>>>>>>>            Move (psDefaultDriver(Self)) to sDriver
89088>>>>>>>>>>>>>            Move (psDefaultConnection(Self)) to sConnect
89089>>>>>>>>>>>>>        End
89089>>>>>>>>>>>>>>
89089>>>>>>>>>>>>>
89089>>>>>>>>>>>>>        If (num_arguments>2) Begin
89091>>>>>>>>>>>>>            Set psUsername of hSql to sUsername
89092>>>>>>>>>>>>>            Set psPassword of hSql to sPassword
89093>>>>>>>>>>>>>        End
89093>>>>>>>>>>>>>>
89093>>>>>>>>>>>>>
89093>>>>>>>>>>>>>        Get SQLConnect of hSql sDriver sConnect to bOK
89094>>>>>>>>>>>>>        If (not(bOK)) Begin
89096>>>>>>>>>>>>>            Send FreeHandle of hSQL
89097>>>>>>>>>>>>>            Function_Return 0
89098>>>>>>>>>>>>>        End
89098>>>>>>>>>>>>>>
89098>>>>>>>>>>>>>
89098>>>>>>>>>>>>>        Function_Return hSql
89099>>>>>>>>>>>>>    End_Function
89100>>>>>>>>>>>>>
89100>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
89102>>>>>>>>>>>>>        Handle hSql
89102>>>>>>>>>>>>>        Boolean bOK
89102>>>>>>>>>>>>>
89102>>>>>>>>>>>>>        //*** Allocate a new handle
89102>>>>>>>>>>>>>        Get CreateHandle to hSql
89103>>>>>>>>>>>>>        Get SQLFileConnect of hSql iFileNum to bOK
89104>>>>>>>>>>>>>
89104>>>>>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
89104>>>>>>>>>>>>>        If (not(bOK)) Begin
89106>>>>>>>>>>>>>            Send FreeHandle of hSql
89107>>>>>>>>>>>>>            Function_Return 0
89108>>>>>>>>>>>>>        End
89108>>>>>>>>>>>>>>
89108>>>>>>>>>>>>>
89108>>>>>>>>>>>>>        Function_Return hSql
89109>>>>>>>>>>>>>    End_Function // SQLFileConnect
89110>>>>>>>>>>>>>
89110>>>>>>>>>>>>>End_Class
89111>>>>>>>>>>>>>
89111>>>>>>>>>>>>>
89111>>>>>>>>>>>>>Function CreateSQLmanager for cDesktop Returns Integer
89113>>>>>>>>>>>>>    Handle hSqlManager
89113>>>>>>>>>>>>>
89113>>>>>>>>>>>>>    Get Create U_cSQLHandleManagerDUF to hSqlManager
89114>>>>>>>>>>>>>    Function_Return hSqlManager
89115>>>>>>>>>>>>>End_Function // CreateSQLMngr
89116>>>>>>>>>>>>>
89116>>>>>>>>>>>>>
89116>>>>>>>>>>>>>
89116>>>>>>>>>>>>>
89116>>>>>>>>>>>>>
89116>>>>>>>>>>>>>
89116>>>>>>>>>>>>>Get CreateSQLManager of Desktop to _embsqlghoSQLHandleMngr
89117>>>>>>>>>>>>>
89117>>>>>>>>>>>>>
89117>>>>>>>>>>>    Use Mertech.inc
89117>>>>>>>>>>>
89117>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
89117>>>>>>>>>
89117>>>>>>>>>// This needs to be after Mertech drivers are defined.
89117>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
89117>>>>>>>>>
89117>>>>>>>>>
89117>>>>>>>>>
89117>>>>>>>>>
89117>>>>>>>>>
89117>>>>>>>>>
89117>>>>>>>>>
89117>>>>>>>>>// SQLConnection.ini constants:
89117>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
89117>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
89117>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
89117>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
89117>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
89117>>>>>>>>>
89117>>>>>>>>>// DF 19 ini-file settings:
89117>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
89117>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
89117>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
89117>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
89117>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
89117>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
89117>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
89117>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
89117>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
89117>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection"
89117>>>>>>>>>
89117>>>>>>>>>// Database Update Framework extended settings:
89117>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
89117>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
89117>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
89117>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
89117>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
89117>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
89117>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
89117>>>>>>>>>
89117>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
89117>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
89117>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
89117>>>>>>>>>
89117>>>>>>>>>Struct tSQLConnection
89117>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
89117>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
89117>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
89117>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
89117>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
89117>>>>>>>>>    String sDatabase                // 6. SQL Database
89117>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
89117>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
89117>>>>>>>>>    String sUserID                  // 9. User ID
89117>>>>>>>>>    String sPassword                // 10. Password
89117>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
89117>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
89117>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
89117>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
89117>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
89117>>>>>>>>>    Boolean bError                  // 16. Set to true on error.    
89117>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
89117>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
89117>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
89117>>>>>>>>>End_Struct
89117>>>>>>>
89117>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
89118>>>>>>>    Procedure CreateDbUpdateLibraryProperties
89120>>>>>>>        Handle hoSQLManagerMT
89120>>>>>>>
89120>>>>>>>        // Error Reporting Related
89120>>>>>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
89120>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
89121>>>>>>>
89121>>>>>>>        Property String Private.psUseDatabase ""
89122>>>>>>>
89122>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
89123>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
89124>>>>>>>
89124>>>>>>>        Property Handle phoSQLManagerMT
89125>>>>>>>            Move (Create(Self,RefClass(cSQLHandleManagerDUF))) to hoSQLManagerMT
89126>>>>>>>            Set phoSQLManagerMT to hoSQLManagerMT
89127>>>>>>>
89127>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
89128>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
89129>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
89130>>>>>>>        Property Handle phoSQLConnectionHandler 0
89131>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
89132>>>>>>>
89132>>>>>>>        Property Boolean pbHandleQueryErrors True
89133>>>>>>>
89133>>>>>>>        Property tSqlColumnNew[] paQueryColumns
89134>>>>>>>        Property String[] paSQLFetchResults
89135>>>>>>>
89135>>>>>>>        // Error handling
89135>>>>>>>        Property Boolean pbSqlError False
89136>>>>>>>        Property tSqlErrorArray paSqlErrorArray
89137>>>>>>>        Property Boolean pbProcessingError False
89138>>>>>>>
89138>>>>>>>        // Statistics on query
89138>>>>>>>        Property TimeSpan ptsTotalQueryTime
89139>>>>>>>        Property TimeSpan ptsQueryExec
89140>>>>>>>        Property TimeSpan ptsFetchResults
89141>>>>>>>        Property Integer piColumns 0
89142>>>>>>>        Property Integer piRows 0
89143>>>>>>>        Property Integer piRowType 0
89144>>>>>>>        Property String[] paQueryMessages
89145>>>>>>>        Property String psSQLStatementString
89146>>>>>>>
89146>>>>>>>        Property Integer[] piTableConvertExceptions
89147>>>>>>>
89147>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
89147>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
89147>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
89147>>>>>>>        Property Integer piChunkMax 500
89148>>>>>>>        
89148>>>>>>>        // Fill the paSQLKeywordArray array with values;
89148>>>>>>>        Send SetupSQLKeywordArray
89149>>>>>>>    End_Procedure
89150>>>>>>>
89150>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
89150>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
89152>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
89154>>>>>>>            Function_Return (EQ)
89155>>>>>>>        End
89155>>>>>>>>
89155>>>>>>>        Function_Return (NE)
89156>>>>>>>    End_Function
89157>>>>>>>
89157>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
89157>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
89159>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) Begin
89161>>>>>>>            Function_Return (LT)
89162>>>>>>>        End
89162>>>>>>>>
89162>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) Begin
89164>>>>>>>            Function_Return (GT)
89165>>>>>>>        End
89165>>>>>>>>
89165>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) Begin
89167>>>>>>>            Function_Return (LT)
89168>>>>>>>        End
89168>>>>>>>>
89168>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) Begin
89170>>>>>>>            Function_Return (GT)
89171>>>>>>>        End
89171>>>>>>>>
89171>>>>>>>
89171>>>>>>>        Function_Return (EQ)
89172>>>>>>>    End_Function
89173>>>>>>>
89173>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
89175>>>>>>>        tSQLKeyWords[] SQLKeywordArray
89175>>>>>>>        tSQLKeyWords[] SQLKeywordArray
89176>>>>>>>        Integer iSize
89176>>>>>>>
89176>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
89177>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
89178>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
89179>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
89180>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
89181>>>>>>>
89181>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
89182>>>>>>>    End_Procedure
89183>>>>>>>
89183>>>>>>>    // Creates a struct array with all SQL keywords
89183>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
89183>>>>>>>    // have slightly different wording.
89183>>>>>>>    // If a new EN_dbTypexxx type is added; additions
89183>>>>>>>    // needs to be done for every keyword group below.
89183>>>>>>>    Procedure SetupSQLKeywordArray
89185>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
89185>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
89187>>>>>>>
89187>>>>>>>        // This should only be called once; but in case it is
89187>>>>>>>        // we delete the array first.
89187>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
89188>>>>>>>
89188>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
89188>>>>>>>        //
89188>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
89189>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
89190>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
89191>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
89192>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
89193>>>>>>>
89193>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
89194>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
89195>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
89196>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
89197>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
89198>>>>>>>
89198>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
89199>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
89200>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
89201>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
89202>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
89203>>>>>>>
89203>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
89204>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
89205>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
89206>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
89207>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
89208>>>>>>>
89208>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
89209>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
89210>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
89211>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
89212>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
89213>>>>>>>
89213>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
89214>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
89215>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
89216>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
89217>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
89218>>>>>>>
89218>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
89219>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
89220>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
89221>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
89222>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
89223>>>>>>>
89223>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
89224>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
89225>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
89226>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
89227>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
89228>>>>>>>
89228>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
89229>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
89230>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
89231>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
89232>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
89233>>>>>>>
89233>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
89234>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
89235>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
89236>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
89237>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
89238>>>>>>>
89238>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_RENAME"
89239>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
89240>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
89241>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
89242>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
89243>>>>>>>
89243>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
89244>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
89245>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
89246>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
89247>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
89248>>>>>>>
89248>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
89249>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
89250>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
89251>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
89252>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
89253>>>>>>>
89253>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
89254>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
89255>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
89256>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
89257>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
89258>>>>>>>
89258>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
89259>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
89260>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
89261>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
89262>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
89263>>>>>>>
89263>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
89264>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
89265>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
89266>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
89267>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
89268>>>>>>>
89268>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
89269>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
89270>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
89271>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
89272>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
89273>>>>>>>
89273>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
89274>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
89275>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
89276>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
89277>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
89278>>>>>>>
89278>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
89279>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
89280>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
89281>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
89282>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
89283>>>>>>>
89283>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
89284>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
89285>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
89286>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
89287>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
89288>>>>>>>
89288>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
89289>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
89290>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
89291>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
89292>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
89293>>>>>>>
89293>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
89294>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
89295>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
89296>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
89297>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
89298>>>>>>>
89298>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
89299>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
89300>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
89301>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
89302>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
89303>>>>>>>
89303>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
89304>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
89305>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
89306>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
89307>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
89308>>>>>>>
89308>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
89309>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
89310>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
89311>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
89312>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
89313>>>>>>>
89313>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
89314>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
89315>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
89316>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
89317>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
89318>>>>>>>
89318>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
89319>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
89320>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
89321>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
89322>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
89323>>>>>>>
89323>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
89324>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
89325>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
89326>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
89327>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
89328>>>>>>>
89328>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
89329>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
89330>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
89331>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
89332>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
89333>>>>>>>
89333>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
89334>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
89335>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
89336>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
89337>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
89338>>>>>>>
89338>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
89339>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
89340>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
89341>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
89342>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
89343>>>>>>>
89343>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
89344>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
89345>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
89346>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
89347>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
89348>>>>>>>
89348>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
89349>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
89350>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
89351>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
89352>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
89353>>>>>>>
89353>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
89354>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
89355>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
89356>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
89357>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
89358>>>>>>>
89358>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
89359>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
89360>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
89361>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
89362>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
89363>>>>>>>
89363>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
89363>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
89364>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
89365>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
89366>>>>>>>
89366>>>>>>>    End_Procedure
89367>>>>>>>
89367>>>>>>>End_Class
89368>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
89368>>>>>>>//****************************************************************************
89368>>>>>>>// $Module type: Class
89368>>>>>>>// $Module name: cSQLConnectionHandler.pkg
89368>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
89368>>>>>>>// Web-site    : http://www.rdctools.com
89368>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
89368>>>>>>>//
89368>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
89368>>>>>>>//
89368>>>>>>>// $Rev History:
89368>>>>>>>//    2015-08-11  Module header created
89368>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
89368>>>>>>>//                Added a new structure for passing connection data back & forth.
89368>>>>>>>//                Added better error handling.
89368>>>>>>>//                Added a decompose message for the connection string.
89368>>>>>>>//    2017-01-09  Added support for Mertech drivers
89368>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
89368>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
89368>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
89368>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
89368>>>>>>>//****************************************************************************
89368>>>>>>>Use cli.pkg
89368>>>>>>>Use MSSqldrv.pkg
89368>>>>>>>Use db2_drv.pkg
89368>>>>>>>Use odbc_drv.pkg
89368>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
89368>>>>>>>>>//****************************************************************************
89368>>>>>>>>>// $Module type: Class
89368>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
89368>>>>>>>>>//
89368>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
89368>>>>>>>>>// Copyright (c) 2012 RDC Tools International
89368>>>>>>>>>// E-mail      : support@rdctools.com
89368>>>>>>>>>// Web-site    : http://www.rdctools.com
89368>>>>>>>>>//
89368>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
89368>>>>>>>>>//
89368>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
89368>>>>>>>>>//               properties of that object.
89368>>>>>>>>>//
89368>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
89368>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
89368>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
89368>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
89368>>>>>>>>>// in the help folder for more details.
89368>>>>>>>>>//
89368>>>>>>>>>Use cSQLConnectionIniFile.inc
89368>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
89368>>>>>>>>>>>Use cSQLConnectionIniFile.inc
89368>>>>>>>>>>>
89368>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
89369>>>>>>>>>>>    Procedure Construct_Object
89371>>>>>>>>>>>        Forward Send Construct_Object
89373>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
89374>>>>>>>>>>>    End_Procedure
89375>>>>>>>>>>>
89375>>>>>>>>>>>    Function ServerKeyword Returns String
89377>>>>>>>>>>>        Function_Return CS_SQLIniDSNKeyword
89378>>>>>>>>>>>    End_Function
89379>>>>>>>>>>>
89379>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
89381>>>>>>>>>>>        String sConnect
89381>>>>>>>>>>>
89381>>>>>>>>>>>        Move (sConnect * ServerKeyword(Self) + "=" + sServer) to sConnect
89382>>>>>>>>>>>        If (sDatabase <> "") Begin
89384>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
89385>>>>>>>>>>>        End
89385>>>>>>>>>>>>
89385>>>>>>>>>>>        If (bTrusted = True) Begin
89387>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
89388>>>>>>>>>>>        End
89388>>>>>>>>>>>>
89388>>>>>>>>>>>        Else Begin
89389>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
89390>>>>>>>>>>>        End
89390>>>>>>>>>>>>
89390>>>>>>>>>>>        Function_Return sConnect
89391>>>>>>>>>>>    End_Function
89392>>>>>>>>>>>
89392>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89394>>>>>>>>>>>        Boolean bLoginSuccessful
89394>>>>>>>>>>>        String sDriverID
89394>>>>>>>>>>>
89394>>>>>>>>>>>        Get psDriverID to sDriverID
89395>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
89397>>>>>>>>>>>            Function_Return True
89398>>>>>>>>>>>        End
89398>>>>>>>>>>>>
89398>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
89399>>>>>>>>>>>        If (bTrusted = False) Begin
89401>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
89403>>>>>>>>>>>        End
89403>>>>>>>>>>>>
89403>>>>>>>>>>>        Else Begin
89404>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
89406>>>>>>>>>>>        End
89406>>>>>>>>>>>>
89406>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
89407>>>>>>>>>>>        Function_Return bLoginSuccessful
89408>>>>>>>>>>>    End_Function
89409>>>>>>>>>>>End_Class
89410>>>>>>>>>>>
89410>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
89411>>>>>>>>>>>    Function ServerKeyword Returns String
89413>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
89414>>>>>>>>>>>    End_Function
89415>>>>>>>>>>>End_Class
89416>>>>>>>>>>>
89416>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
89417>>>>>>>>>>>End_Class
89418>>>>>>>>>>>
89418>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
89419>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89421>>>>>>>>>>>        Boolean bLoginSuccessful
89421>>>>>>>>>>>        String sDriverID
89421>>>>>>>>>>>
89421>>>>>>>>>>>        Move False to Err
89422>>>>>>>>>>>        Get psDriverID to sDriverID
89423>>>>>>>>>>>        If (not(Uppercase(sServer) contains "DSN")) Begin
89425>>>>>>>>>>>            Move ("DSN=" + sServer) to sServer
89426>>>>>>>>>>>        End
89426>>>>>>>>>>>>
89426>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
89428>>>>>>>>>>>
89428>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89429>>>>>>>>>>>        Function_Return bLoginSuccessful
89430>>>>>>>>>>>    End_Function
89431>>>>>>>>>>>End_Class
89432>>>>>>>>>>>
89432>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
89433>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
89435>>>>>>>>>>>        Function_Return ""
89436>>>>>>>>>>>    End_Function
89437>>>>>>>>>>>End_Class
89438>>>>>>>>>>>
89438>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
89439>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89441>>>>>>>>>>>        Boolean bLoginSuccessful
89441>>>>>>>>>>>        String sDriverID
89441>>>>>>>>>>>
89441>>>>>>>>>>>        Get psDriverID to sDriverID
89442>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
89442>>>>>>>>>>>        Move False to Err
89443>>>>>>>>>>>        If (bTrusted = False) Begin
89445>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
89447>>>>>>>>>>>        End
89447>>>>>>>>>>>>
89447>>>>>>>>>>>        Else Begin
89448>>>>>>>>>>>            Login sServer "" "" sDriverID
89450>>>>>>>>>>>        End
89450>>>>>>>>>>>>
89450>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89451>>>>>>>>>>>
89451>>>>>>>>>>>        Function_Return bLoginSuccessful
89452>>>>>>>>>>>    End_Function
89453>>>>>>>>>>>End_Class
89454>>>>>>>>>>>
89454>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
89455>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89457>>>>>>>>>>>        Boolean bLoginSuccessful
89457>>>>>>>>>>>        String sDriverID sErrorMsg
89457>>>>>>>>>>>        String sVal
89457>>>>>>>>>>>        Integer iPos
89457>>>>>>>>>>>
89457>>>>>>>>>>>        Get psDriverID to sDriverID
89458>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
89459>>>>>>>>>>>        If (iPos = 0) Begin
89461>>>>>>>>>>>            If (sDatabase <> "") Begin
89463>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
89464>>>>>>>>>>>            End
89464>>>>>>>>>>>>
89464>>>>>>>>>>>        End
89464>>>>>>>>>>>>
89464>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
89464>>>>>>>>>>>        Move False to Err
89465>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
89465>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
89467>>>>>>>>>>>
89467>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89468>>>>>>>>>>>        Function_Return bLoginSuccessful
89469>>>>>>>>>>>    End_Function
89470>>>>>>>>>>>End_Class
89471>>>>>>>>>>>
89471>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
89472>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89474>>>>>>>>>>>        Boolean bLoginSuccessful
89474>>>>>>>>>>>        String sDriverID
89474>>>>>>>>>>>
89474>>>>>>>>>>>        Get psDriverID to sDriverID
89475>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
89475>>>>>>>>>>>        Move False to Err
89476>>>>>>>>>>>        If (bTrusted = False) Begin
89478>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
89480>>>>>>>>>>>        End
89480>>>>>>>>>>>>
89480>>>>>>>>>>>        Else Begin
89481>>>>>>>>>>>            Login sServer "" "" sDriverID
89483>>>>>>>>>>>        End
89483>>>>>>>>>>>>
89483>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89484>>>>>>>>>>>        Function_Return bLoginSuccessful
89485>>>>>>>>>>>    End_Function
89486>>>>>>>>>>>End_Class
89487>>>>>>>>>>>
89487>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
89488>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89490>>>>>>>>>>>        Boolean bLoginSuccessful
89490>>>>>>>>>>>        String sDriverID
89490>>>>>>>>>>>
89490>>>>>>>>>>>        Get psDriverID to sDriverID
89491>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
89491>>>>>>>>>>>        Move False to Err
89492>>>>>>>>>>>        If (bTrusted = False) Begin
89494>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
89496>>>>>>>>>>>        End
89496>>>>>>>>>>>>
89496>>>>>>>>>>>        Else Begin
89497>>>>>>>>>>>            Login sServer "" "" sDriverID
89499>>>>>>>>>>>        End
89499>>>>>>>>>>>>
89499>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
89500>>>>>>>>>>>        Function_Return bLoginSuccessful
89501>>>>>>>>>>>    End_Function
89502>>>>>>>>>>>End_Class
89503>>>>>>>>>>>
89503>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
89504>>>>>>>>>>>    Procedure Construct_Object
89506>>>>>>>>>>>        Forward Send Construct_Object
89508>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
89509>>>>>>>>>>>        Property Handle phoDriverSpecificObject
89510>>>>>>>>>>>    End_Procedure
89511>>>>>>>>>>>
89511>>>>>>>>>>>    Function CreateDriver Returns Handle
89513>>>>>>>>>>>        String sDriverID
89513>>>>>>>>>>>        Handle hoDriver hcDriverClass
89513>>>>>>>>>>>
89513>>>>>>>>>>>        Get psDriverID to sDriverID
89514>>>>>>>>>>>        Case Begin
89514>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
89516>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
89517>>>>>>>>>>>                Case Break
89518>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
89521>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
89522>>>>>>>>>>>                Case Break
89523>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
89526>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
89527>>>>>>>>>>>                Case Break
89528>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
89531>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
89532>>>>>>>>>>>                Case Break
89533>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
89536>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
89537>>>>>>>>>>>                Case Break
89538>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
89541>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
89542>>>>>>>>>>>                Case Break
89543>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
89546>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
89547>>>>>>>>>>>                Case Break
89548>>>>>>>>>>>            // DATAFLEX_ID = Default driver
89548>>>>>>>>>>>            Case Else  
89548>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
89549>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
89550>>>>>>>>>>>        Case End
89550>>>>>>>>>>>
89550>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
89551>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
89552>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
89553>>>>>>>>>>>
89553>>>>>>>>>>>        Function_Return hoDriver
89554>>>>>>>>>>>    End_Procedure
89555>>>>>>>>>>>
89555>>>>>>>>>>>    Procedure DestroyDriver
89557>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
89559>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
89560>>>>>>>>>>>        End
89560>>>>>>>>>>>>
89560>>>>>>>>>>>    End_Procedure
89561>>>>>>>>>>>
89561>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
89563>>>>>>>>>>>        String sConnect
89563>>>>>>>>>>>        Handle hoDriver
89563>>>>>>>>>>>
89563>>>>>>>>>>>        Get CreateDriver to hoDriver
89564>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
89565>>>>>>>>>>>        Send DestroyDriver
89566>>>>>>>>>>>        Function_Return sConnect
89567>>>>>>>>>>>    End_Function
89568>>>>>>>>>>>
89568>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
89570>>>>>>>>>>>        Boolean bLoginSuccessful
89570>>>>>>>>>>>        Handle hoDriver
89570>>>>>>>>>>>
89570>>>>>>>>>>>        Get CreateDriver to hoDriver
89571>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
89572>>>>>>>>>>>        Send DestroyDriver
89573>>>>>>>>>>>        Function_Return bLoginSuccessful
89574>>>>>>>>>>>    End_Function
89575>>>>>>>>>>>
89575>>>>>>>>>>>End_Class
89576>>>>>>>>>
89576>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
89577>>>>>>>>>    Procedure Construct_Object
89579>>>>>>>>>        Forward Send Construct_Object
89581>>>>>>>>>
89581>>>>>>>>>        Property String Private_psIniFilePath
89582>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
89583>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
89584>>>>>>>>>
89584>>>>>>>>>//        { Visibility=Private }
89584>>>>>>>>>        Property Boolean pbDFConnId False
89585>>>>>>>>>
89585>>>>>>>>>        // We use Base64 coding instead of the cCryptographer class because the
89585>>>>>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
89585>>>>>>>>>//        { Visibility=Public }
89585>>>>>>>>>//        // *** You really want to change this value! ***
89585>>>>>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
89585>>>>>>>>>
89585>>>>>>>>>    End_Procedure
89586>>>>>>>>>
89586>>>>>>>>>    Procedure End_Construct_Object
89588>>>>>>>>>        Forward Send End_Construct_Object
89590>>>>>>>>>    End_Procedure
89591>>>>>>>>>
89591>>>>>>>>>    Procedure Set psIniFilePath String sPath
89593>>>>>>>>>        String sIniFile
89593>>>>>>>>>        Get vFolderFormat sPath to sPath
89594>>>>>>>>>        Set private_psIniFilePath to sPath
89595>>>>>>>>>        Get psIniFileName to sIniFile
89596>>>>>>>>>        Set psFileName to (sPath + sIniFile)
89597>>>>>>>>>    End_Procedure
89598>>>>>>>>>
89598>>>>>>>>>    Function psIniFilePath Returns String
89600>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
89601>>>>>>>>>    End_Function
89602>>>>>>>>>
89602>>>>>>>>>    Procedure Set psIniFileName String sFileName
89604>>>>>>>>>        String sPath
89604>>>>>>>>>        Get psIniFilePath to sPath
89605>>>>>>>>>        Set psFileName to (sPath + sFileName)
89606>>>>>>>>>        Set private_psIniFileName to sFileName
89607>>>>>>>>>    End_Procedure
89608>>>>>>>>>
89608>>>>>>>>>    Function psIniFileName Returns String
89610>>>>>>>>>        Function_Return (private_psIniFileName(Self))
89611>>>>>>>>>    End_Function
89612>>>>>>>>>
89612>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
89612>>>>>>>>>    // Sets a value in the program's ini file (write)
89612>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
89612>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
89614>>>>>>>>>        String sIniFile sPath
89614>>>>>>>>>
89614>>>>>>>>>        Get psIniFilePath to sPath
89615>>>>>>>>>        Get psIniFileName to sIniFile
89616>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
89617>>>>>>>>>        Set psFileName to sIniFile
89618>>>>>>>>>        Send WriteString sSection sValueName sValue
89619>>>>>>>>>    End_Procedure
89620>>>>>>>>>
89620>>>>>>>>>    // Get a value from program's ini-file (read)
89620>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
89620>>>>>>>>>    // Returns the value
89620>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
89622>>>>>>>>>        String sValue sIniFile sPath
89622>>>>>>>>>
89622>>>>>>>>>        Get psIniFilePath to sPath
89623>>>>>>>>>        Get psIniFileName to sIniFile
89624>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
89625>>>>>>>>>        Set psFileName to sIniFile
89626>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
89627>>>>>>>>>
89627>>>>>>>>>        Function_Return sValue
89628>>>>>>>>>    End_Function
89629>>>>>>>>>
89629>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
89629>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
89631>>>>>>>>>        Integer iCheckboxCol
89631>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) Begin
89633>>>>>>>>>            Function_Return (LT)
89634>>>>>>>>>        End
89634>>>>>>>>>>
89634>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) Begin
89636>>>>>>>>>            Function_Return (GT)
89637>>>>>>>>>        End
89637>>>>>>>>>>
89637>>>>>>>>>
89637>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) Begin
89639>>>>>>>>>            Function_Return (LT)
89640>>>>>>>>>        End
89640>>>>>>>>>>
89640>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) Begin
89642>>>>>>>>>            Function_Return (GT)
89643>>>>>>>>>        End
89643>>>>>>>>>>
89643>>>>>>>>>
89643>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) Begin
89645>>>>>>>>>            Function_Return (LT)
89646>>>>>>>>>        End
89646>>>>>>>>>>
89646>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) Begin
89648>>>>>>>>>            Function_Return (GT)
89649>>>>>>>>>        End
89649>>>>>>>>>>
89649>>>>>>>>>
89649>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) Begin
89651>>>>>>>>>            Function_Return (LT)
89652>>>>>>>>>        End
89652>>>>>>>>>>
89652>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) Begin
89654>>>>>>>>>            Function_Return (GT)
89655>>>>>>>>>        End
89655>>>>>>>>>>
89655>>>>>>>>>
89655>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) Begin
89657>>>>>>>>>            Function_Return (LT)
89658>>>>>>>>>        End
89658>>>>>>>>>>
89658>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) Begin
89660>>>>>>>>>            Function_Return (GT)
89661>>>>>>>>>        End
89661>>>>>>>>>>
89661>>>>>>>>>
89661>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) Begin
89663>>>>>>>>>            Function_Return (LT)
89664>>>>>>>>>        End
89664>>>>>>>>>>
89664>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) Begin
89666>>>>>>>>>            Function_Return (GT)
89667>>>>>>>>>        End
89667>>>>>>>>>>
89667>>>>>>>>>
89667>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) Begin
89669>>>>>>>>>            Function_Return (LT)
89670>>>>>>>>>        End
89670>>>>>>>>>>
89670>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) Begin
89672>>>>>>>>>            Function_Return (GT)
89673>>>>>>>>>        End
89673>>>>>>>>>>
89673>>>>>>>>>
89673>>>>>>>>>        Function_Return (EQ)
89674>>>>>>>>>    End_Function
89675>>>>>>>>>
89675>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
89677>>>>>>>>>        Handle hoSections
89677>>>>>>>>>        Integer iItems
89677>>>>>>>>>
89677>>>>>>>>>        Send ReadSections hoSections
89678>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
89679>>>>>>>>>        Function_Return iItems
89680>>>>>>>>>    End_Function
89681>>>>>>>>>
89681>>>>>>>>>    // The normal connection string looks something like this;
89681>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
89681>>>>>>>>>    // ...but the full connection string looks like this;
89681>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
89681>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
89681>>>>>>>>>//        String sSection
89681>>>>>>>>>//        Integer iCount
89681>>>>>>>>>//
89681>>>>>>>>>//        Move False to Err
89681>>>>>>>>>//        Get psIniSectionName to sSection
89681>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
89681>>>>>>>>>//        Increment iCount
89681>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
89681>>>>>>>>>//
89681>>>>>>>>>//        Function_Return (Err = False)
89681>>>>>>>>>//    End_Function
89681>>>>>>>>>
89681>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
89683>>>>>>>>>        Integer iCount
89683>>>>>>>>>        Boolean bExists
89683>>>>>>>>>        String sSection
89683>>>>>>>>>
89683>>>>>>>>>        Move False to Err
89684>>>>>>>>>        Move 1 to iCount
89685>>>>>>>>>        Get psIniSectionName to sSection
89686>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
89687>>>>>>>>>        While (bExists = True)
89691>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
89692>>>>>>>>>            Increment iCount
89693>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
89694>>>>>>>>>        Loop
89695>>>>>>>>>>
89695>>>>>>>>>        Function_Return (Err = False)
89696>>>>>>>>>    End_Function
89697>>>>>>>>>
89697>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
89699>>>>>>>>>        Integer iCount
89699>>>>>>>>>        String sSection
89699>>>>>>>>>        Boolean bExists
89699>>>>>>>>>
89699>>>>>>>>>        Move False to Err
89700>>>>>>>>>        Move 1 to iCount
89701>>>>>>>>>        Get psIniSectionName to sSection
89702>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
89703>>>>>>>>>        While (bExists = True)
89707>>>>>>>>>            If (iCount = iItem) Begin
89709>>>>>>>>>                Send DeleteSection sSection
89710>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
89710>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
89711>>>>>>>>>            End
89711>>>>>>>>>>
89711>>>>>>>>>            Increment iCount
89712>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
89713>>>>>>>>>        Loop
89714>>>>>>>>>>
89714>>>>>>>>>
89714>>>>>>>>>        Function_Return (Err = False)
89715>>>>>>>>>    End_Function
89716>>>>>>>>>
89716>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
89716>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
89716>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
89718>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89718>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89719>>>>>>>>>        tSQLConnection   SQLConnection
89719>>>>>>>>>        tSQLConnection   SQLConnection
89719>>>>>>>>>        Integer iIndex
89719>>>>>>>>>
89719>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
89720>>>>>>>>>        If (iIndex = -1) Begin
89722>>>>>>>>>            Move True to SQLConnection.bError
89723>>>>>>>>>            Function_Return SQLConnection
89724>>>>>>>>>        End
89724>>>>>>>>>>
89724>>>>>>>>>
89724>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89725>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
89726>>>>>>>>>
89726>>>>>>>>>        Function_Return SQLConnection
89727>>>>>>>>>    End_Function
89728>>>>>>>>>
89728>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
89728>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
89730>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89730>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89731>>>>>>>>>        Integer iRetval iCount iSize
89731>>>>>>>>>        String sValue
89731>>>>>>>>>        Boolean bExists
89731>>>>>>>>>
89731>>>>>>>>>        Move -1 to iRetval
89732>>>>>>>>>
89732>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89733>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89734>>>>>>>>>        Decrement iSize
89735>>>>>>>>>        For iCount from 0 to iSize
89741>>>>>>>>>>
89741>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
89742>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
89743>>>>>>>>>            If (bExists) Begin
89745>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
89746>>>>>>>>>                Move iSize to iCount         // We're done!
89747>>>>>>>>>            End
89747>>>>>>>>>>
89747>>>>>>>>>        Loop
89748>>>>>>>>>>
89748>>>>>>>>>
89748>>>>>>>>>        Function_Return iRetval
89749>>>>>>>>>    End_Function
89750>>>>>>>>>
89750>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
89750>>>>>>>>>    // Used to check that ConnectionID's are unique.
89750>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
89752>>>>>>>>>        Integer iCount iSize iItems
89752>>>>>>>>>        String sValue
89752>>>>>>>>>        Boolean bExists
89752>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89752>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89753>>>>>>>>>
89753>>>>>>>>>        Move 0 to iItems
89754>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89755>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89756>>>>>>>>>        Decrement iSize
89757>>>>>>>>>        For iCount from 0 to iSize
89763>>>>>>>>>>
89763>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
89764>>>>>>>>>            Move (sValue = sConnectionID) to bExists
89765>>>>>>>>>            If (bExists) Begin
89767>>>>>>>>>                Increment iItems
89768>>>>>>>>>            End
89768>>>>>>>>>>
89768>>>>>>>>>        Loop
89769>>>>>>>>>>
89769>>>>>>>>>
89769>>>>>>>>>        Function_Return (iItems > 1)
89770>>>>>>>>>    End_Function
89771>>>>>>>>>
89771>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
89771>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
89773>>>>>>>>>        Boolean bRetval bOK
89773>>>>>>>>>        Integer iItem iSize iCount
89773>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89773>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89774>>>>>>>>>        tSQLConnection SQLConnection
89774>>>>>>>>>        tSQLConnection SQLConnection
89774>>>>>>>>>        String sConnectionString
89774>>>>>>>>>
89774>>>>>>>>>        Move False to Err
89775>>>>>>>>>        Get psConnectionString to sConnectionString
89776>>>>>>>>>
89776>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89777>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89778>>>>>>>>>        Decrement iSize
89779>>>>>>>>>        // Set all current connection to inactive.
89779>>>>>>>>>        For iCount from 0 to iSize
89785>>>>>>>>>>
89785>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
89786>>>>>>>>>        Loop
89787>>>>>>>>>>
89787>>>>>>>>>
89787>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
89788>>>>>>>>>        Move True              to SQLConnection.bEnabled
89789>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
89790>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
89791>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
89792>>>>>>>>>
89792>>>>>>>>>        Function_Return (bOK = True)
89793>>>>>>>>>    End_Function
89794>>>>>>>>>
89794>>>>>>>>>    // Used for updating an existing connection with new data.
89794>>>>>>>>>    // Returns True if successful.
89794>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
89796>>>>>>>>>        Boolean bRetval bOK
89796>>>>>>>>>        Integer iItem iSize iCount
89796>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89796>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89797>>>>>>>>>
89797>>>>>>>>>        Move False to Err
89798>>>>>>>>>        Move -1 to iItem
89799>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
89800>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89801>>>>>>>>>        Decrement iSize
89802>>>>>>>>>        // Set all current connection to inactive.
89802>>>>>>>>>        For iCount from 0 to iSize
89808>>>>>>>>>>
89808>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
89809>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
89811>>>>>>>>>                Move iCount to iItem
89812>>>>>>>>>            End
89812>>>>>>>>>>
89812>>>>>>>>>        Loop
89813>>>>>>>>>>
89813>>>>>>>>>
89813>>>>>>>>>        If (iItem <> -1) Begin
89815>>>>>>>>>            Move True to SQLConnection.bEnabled
89816>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
89817>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
89818>>>>>>>>>        End
89818>>>>>>>>>>
89818>>>>>>>>>
89818>>>>>>>>>        Function_Return (bOK = True)
89819>>>>>>>>>    End_Function
89820>>>>>>>>>
89820>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
89822>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89822>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
89823>>>>>>>>>        String sSection sValue
89823>>>>>>>>>        Integer iCount
89823>>>>>>>>>        Boolean bExists bEnabled
89823>>>>>>>>>
89823>>>>>>>>>        Get psIniSectionName to sSection
89824>>>>>>>>>        Get SectionExists sSection to bExists
89825>>>>>>>>>        If (bExists = False) Begin
89827>>>>>>>>>            Function_Return SQLConnectionsArray
89828>>>>>>>>>        End
89828>>>>>>>>>>
89828>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
89829>>>>>>>>>        If (bExists = True) Begin
89831>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
89832>>>>>>>>>>
89832>>>>>>>>>        End
89832>>>>>>>>>>
89832>>>>>>>>>
89832>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
89833>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
89834>>>>>>>>>
89834>>>>>>>>>        While (bExists = True)
89838>>>>>>>>>            // We always put the enabled/active connection at the top
89838>>>>>>>>>            Move (iCount = 1) to bEnabled
89839>>>>>>>>>            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
89840>>>>>>>>>
89840>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
89841>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
89842>>>>>>>>>
89842>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
89842>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
89843>>>>>>>>>            If (sValue = "99") Begin
89845>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
89846>>>>>>>>>            End
89846>>>>>>>>>>
89846>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
89847>>>>>>>>>
89847>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
89848>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
89849>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
89851>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
89852>>>>>>>>>            End
89852>>>>>>>>>>
89852>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
89853>>>>>>>>>
89853>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
89854>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
89855>>>>>>>>>
89855>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
89856>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
89857>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
89859>>>>>>>>>                Get DecryptPassword sValue to sValue
89860>>>>>>>>>            End
89860>>>>>>>>>>
89860>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
89861>>>>>>>>>
89861>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
89861>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
89862>>>>>>>>>
89862>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
89863>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
89864>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
89865>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
89866>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to SQLConnectionsArray[iCount].bSilentLogin
89867>>>>>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
89867>>>>>>>>>
89867>>>>>>>>>            Increment iCount
89868>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
89869>>>>>>>>>        Loop
89870>>>>>>>>>>
89870>>>>>>>>>
89870>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
89870>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
89872>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
89873>>>>>>>>>        End
89873>>>>>>>>>>
89873>>>>>>>>>
89873>>>>>>>>>        Function_Return SQLConnectionsArray
89874>>>>>>>>>    End_Function
89875>>>>>>>>>
89875>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
89877>>>>>>>>>        Integer iCount iSize iItem
89877>>>>>>>>>        Boolean bIsOneActive bEnabled bExists bOK
89877>>>>>>>>>        String sConnectionString sSection sValue
89877>>>>>>>>>
89877>>>>>>>>>        // First we need to _remove_ all current connections in the ini-file, we
89877>>>>>>>>>        // do that by setting their values to "".
89877>>>>>>>>>        Move 0 to iCount
89878>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
89879>>>>>>>>>        If (bOK = False) Begin
89881>>>>>>>>>            Function_Return False
89882>>>>>>>>>        End
89882>>>>>>>>>>
89882>>>>>>>>>
89882>>>>>>>>>        Move False to Err
89883>>>>>>>>>        Get psIniSectionName to sSection
89884>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
89884>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
89885>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
89886>>>>>>>>>        Decrement iSize
89887>>>>>>>>>
89887>>>>>>>>>        For iCount from 0 to iSize
89893>>>>>>>>>>
89893>>>>>>>>>            // DF 19 compatible settings:
89893>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
89894>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
89895>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
89896>>>>>>>>>
89896>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
89897>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
89899>>>>>>>>>                Get EncryptPassword sValue to sValue
89900>>>>>>>>>            End
89900>>>>>>>>>>
89900>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
89901>>>>>>>>>
89901>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
89903>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
89904>>>>>>>>>            End
89904>>>>>>>>>>
89904>>>>>>>>>
89904>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
89905>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
89906>>>>>>>>>
89906>>>>>>>>>            // The Database Update Framework extended settings:
89906>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
89907>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
89908>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
89909>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
89910>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
89911>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to SQLConnectionsArray[iCount].bSilentLogin
89912>>>>>>>>>        Loop
89913>>>>>>>>>>
89913>>>>>>>>>
89913>>>>>>>>>        Function_Return (bOK and Err = False)
89914>>>>>>>>>    End_Function
89915>>>>>>>>>
89915>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
89915>>>>>>>>>    //
89915>>>>>>>>>    // SQL utility function that returns a database type (string) constant
89915>>>>>>>>>    // corresponding to the passed iDbType.
89915>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
89917>>>>>>>>>        String sRetval
89917>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL)       Move CS_dbTypeMSSQL     to sRetval
89920>>>>>>>>>        If (iDbType = EN_dbTypeMySQL)       Move CS_dbTypeMySQL     to sRetval
89923>>>>>>>>>        If (iDbType = EN_dbTypeOracle)      Move CS_dbTypeOracle    to sRetval
89926>>>>>>>>>        If (iDbType = EN_dbTypeDB2)         Move CS_dbTypeDB2       to sRetval
89929>>>>>>>>>        If (iDbType = EN_dbTypePostgre)     Move CS_dbTypePostgre   to sRetval
89932>>>>>>>>>        Function_Return sRetval
89933>>>>>>>>>    End_Function
89934>>>>>>>>>
89934>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
89934>>>>>>>>>    // corresponding to the passed sDbType string constant.
89934>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
89936>>>>>>>>>        Integer iRetval
89936>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL)       Move EN_dbTypeMSSQL     to iRetval
89939>>>>>>>>>        If (sDbType = CS_dbTypeMySQL)       Move EN_dbTypeMySQL     to iRetval
89942>>>>>>>>>        If (sDbType = CS_dbTypeOracle)      Move EN_dbTypeOracle    to iRetval
89945>>>>>>>>>        If (sDbType = CS_dbTypeDB2)         Move EN_dbTypeDB2       to iRetval
89948>>>>>>>>>        If (sDbType = CS_dbTypePostgre)     Move EN_dbTypePostgre   to iRetval
89951>>>>>>>>>        Function_Return iRetval
89952>>>>>>>>>    End_Function
89953>>>>>>>>>
89953>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
89953>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
89953>>>>>>>>>    // the SQL Connection program's grid.
89953>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
89955>>>>>>>>>        String sRetval
89955>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL)       Move "EN_dbTypeMSSQL"   to sRetval
89958>>>>>>>>>        If (iDbType = EN_dbTypeMySQL)       Move "EN_dbTypeMySQL"   to sRetval
89961>>>>>>>>>        If (iDbType = EN_dbTypeOracle)      Move "EN_dbTypeOracle"  to sRetval
89964>>>>>>>>>        If (iDbType = EN_dbTypeDB2)         Move "EN_dbTypeDB2"     to sRetval
89967>>>>>>>>>        If (iDbType = EN_dbTypePostgre)     Move "EN_dbTypePostgre" to sRetval
89970>>>>>>>>>        Function_Return sRetval
89971>>>>>>>>>    End_Function
89972>>>>>>>>>
89972>>>>>>>>>    // Pass a driver id and the function will return
89972>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
89972>>>>>>>>>    // quite work and always returns "MS SQL Server"
89972>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
89974>>>>>>>>>        Integer iRetval
89974>>>>>>>>>        If (sDriverID = MSSQLDRV_ID)  Move EN_dbTypeMSSQL     to iRetval
89977>>>>>>>>>        If (sDriverID = SQLFLEX)      Move EN_dbTypeMSSQL     to iRetval
89980>>>>>>>>>        If (sDriverID = ODBC_DRV_ID)  Move EN_dbTypeMSSQL     to iRetval
89983>>>>>>>>>        If (sDriverID = MDSMySQL)     Move EN_dbTypeMySQL     to iRetval
89986>>>>>>>>>        If (sDriverID = ORAFLEX)      Move EN_dbTypeOracle    to iRetval
89989>>>>>>>>>        If (sDriverID = DB2_DRV_ID)   Move EN_dbTypeDB2       to iRetval
89992>>>>>>>>>        If (sDriverID = MDSPgSQL)     Move EN_dbTypePostgre   to iRetval
89995>>>>>>>>>        Function_Return iRetval
89996>>>>>>>>>    End_Function
89997>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
89997>>>>>>>>>>
89997>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
89999>>>>>>>>>>    Integer iStart iEnd
89999>>>>>>>>>>    String sRetval
89999>>>>>>>>>>
89999>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
90000>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
90001>>>>>>>>>>    If (iStart = 0) Begin
90003>>>>>>>>>>        Function_Return ""
90004>>>>>>>>>>    End
90004>>>>>>>>>>>
90004>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
90005>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
90006>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
90008>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
90009>>>>>>>>>>    End
90009>>>>>>>>>>>
90009>>>>>>>>>>    Else Begin
90010>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
90011>>>>>>>>>>    End
90011>>>>>>>>>>>
90011>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
90013>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
90014>>>>>>>>>>        Decrement iEnd
90015>>>>>>>>>>    End
90015>>>>>>>>>>>
90015>>>>>>>>>>    If (iEnd <> 0) Begin
90017>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
90018>>>>>>>>>>    End
90018>>>>>>>>>>>
90018>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
90019>>>>>>>>>>
90019>>>>>>>>>>    Function_Return (Trim(sRetval))
90020>>>>>>>>>>End_Function
90021>>>>>>>>>>
90021>>>>>>>>>>
90021>>>>>>>>>
90021>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
90023>>>>>>>>>        String sConnect
90023>>>>>>>>>        Handle hoDriver
90023>>>>>>>>>
90023>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
90024>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
90025>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
90026>>>>>>>>>        Send Destroy   of hoDriver
90027>>>>>>>>>
90027>>>>>>>>>//        Case Begin
90027>>>>>>>>>//            Case (sDriverID = MSSQLDRV_ID)
90027>>>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
90027>>>>>>>>>//                If (sDatabase <> "") Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                If (bTrusted = True) Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Else Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Case Break
90027>>>>>>>>>//
90027>>>>>>>>>//            Case (sDriverID = ODBC_DRV_ID)
90027>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90027>>>>>>>>>//                If (sDatabase <> "") Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                If (bTrusted = True) Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Else Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Case Break
90027>>>>>>>>>//
90027>>>>>>>>>//            Case (sDriverID = DB2_DRV_ID)
90027>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90027>>>>>>>>>////                If (sDatabase <> "") Begin
90027>>>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90027>>>>>>>>>////                End
90027>>>>>>>>>////                If (bTrusted = True) Begin
90027>>>>>>>>>////                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
90027>>>>>>>>>////                End
90027>>>>>>>>>////                Else Begin
90027>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
90027>>>>>>>>>////                End
90027>>>>>>>>>//                Case Break
90027>>>>>>>>>//
90027>>>>>>>>>//            Case (sDriverID = SQLFLEX)
90027>>>>>>>>>//                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
90027>>>>>>>>>//                If (sDatabase <> "") Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                If (bTrusted = True) Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Else Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Case Break
90027>>>>>>>>>//
90027>>>>>>>>>//            Case (sDriverID = ORAFLEX)
90027>>>>>>>>>//                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
90027>>>>>>>>>//                    Move (sServer + "/" + sDatabase)                  to sServer
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90027>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
90027>>>>>>>>>//                Case Break
90027>>>>>>>>>//
90027>>>>>>>>>//            Case (sDriverID = MDSPgSQL)
90027>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90027>>>>>>>>>//                If (sDatabase <> "") Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
90027>>>>>>>>>//                Case Break
90027>>>>>>>>>//
90027>>>>>>>>>//            Case (sDriverID = MDSMySQL)
90027>>>>>>>>>//                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90027>>>>>>>>>//                If (sDatabase <> "") Begin
90027>>>>>>>>>//                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90027>>>>>>>>>//                End
90027>>>>>>>>>//                Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
90027>>>>>>>>>//                Case Break
90027>>>>>>>>>//
90027>>>>>>>>>//            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
90027>>>>>>>>>//                Break
90027>>>>>>>>>//
90027>>>>>>>>>//            Case Else
90027>>>>>>>>>//                Move "" to sConnect
90027>>>>>>>>>//        Case End
90027>>>>>>>>>
90027>>>>>>>>>        Function_Return sConnect
90028>>>>>>>>>    End_Function
90029>>>>>>>>>
90029>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
90029>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
90031>>>>>>>>>        String sConnect
90031>>>>>>>>>
90031>>>>>>>>>        Case Begin
90031>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
90033>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
90034>>>>>>>>>                If (sDatabase <> "") Begin
90036>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90037>>>>>>>>>                End
90037>>>>>>>>>>
90037>>>>>>>>>                Case Break
90038>>>>>>>>>
90038>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
90041>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90042>>>>>>>>>                If (sDatabase <> "") Begin
90044>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90045>>>>>>>>>                End
90045>>>>>>>>>>
90045>>>>>>>>>                Case Break
90046>>>>>>>>>
90046>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90049>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90050>>>>>>>>>                If (sDatabase <> "") Begin
90052>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90053>>>>>>>>>                End
90053>>>>>>>>>>
90053>>>>>>>>>                Case Break
90054>>>>>>>>>
90054>>>>>>>>>            Case (sDriverID = ORAFLEX)
90057>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90058>>>>>>>>>                If (sDatabase <> "") Begin
90060>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90061>>>>>>>>>                End
90061>>>>>>>>>>
90061>>>>>>>>>                Case Break
90062>>>>>>>>>
90062>>>>>>>>>            Case (sDriverID = MDSPgSQL)
90065>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90066>>>>>>>>>                If (sDatabase <> "") Begin
90068>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90069>>>>>>>>>                End
90069>>>>>>>>>>
90069>>>>>>>>>                Case Break
90070>>>>>>>>>
90070>>>>>>>>>            Case (sDriverID = MDSMySQL)
90073>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
90074>>>>>>>>>                If (sDatabase <> "") Begin
90076>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
90077>>>>>>>>>                End
90077>>>>>>>>>>
90077>>>>>>>>>                Case Break
90078>>>>>>>>>
90078>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
90081>>>>>>>>>                Break
90082>>>>>>>>>
90082>>>>>>>>>            Case Else
90082>>>>>>>>>                Move "" to sConnect
90083>>>>>>>>>        Case End
90083>>>>>>>>>
90083>>>>>>>>>        Function_Return sConnect
90084>>>>>>>>>    End_Function
90085>>>>>>>>>
90085>>>>>>>>>    // Use Base64
90085>>>>>>>>>    Function EncryptPassword String sPassword Returns String
90087>>>>>>>>>        String sRetval sHashString
90087>>>>>>>>>//        Handle hoCryptographer
90087>>>>>>>>>//
90087>>>>>>>>>//        Get psHashString to sHashString
90087>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
90087>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
90087>>>>>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
90087>>>>>>>>>//
90087>>>>>>>>>//        Send Destroy of hoCryptographer
90087>>>>>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
90088>>>>>>>>>        Function_Return sRetval
90089>>>>>>>>>    End_Function
90090>>>>>>>>>
90090>>>>>>>>>    Function DecryptPassword String sPassword Returns String
90092>>>>>>>>>        String sRetval sHashString
90092>>>>>>>>>//        Handle hoCryptographer
90092>>>>>>>>>//
90092>>>>>>>>>//        Get psHashString to sHashString
90092>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
90092>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
90092>>>>>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
90092>>>>>>>>>//
90092>>>>>>>>>//        Send Destroy of hoCryptographer
90092>>>>>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
90093>>>>>>>>>
90093>>>>>>>>>        Function_Return sRetval
90094>>>>>>>>>    End_Function
90095>>>>>>>>>
90095>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
90095>>>>>>>>>    Function ApplicationPath Returns String
90097>>>>>>>>>        String sApplicationFileName sPath
90097>>>>>>>>>        Integer iNumChars iRetval
90097>>>>>>>>>
90097>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
90098>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
90099>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
90100>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
90101>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
90102>>>>>>>>>
90102>>>>>>>>>        Function_Return sPath
90103>>>>>>>>>    End_Function
90104>>>>>>>>>
90104>>>>>>>>>End_Class
90105>>>>>>>Use cDbUpdateDatabaseDriver.pkg
90105>>>>>>>
90105>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
90105>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
90105>>>>>>>
90105>>>>>>>// We're making references to this object handle so we need it defined
90105>>>>>>>// here as well as for the cDbUpdateHandler class
90105>>>>>>>
90105>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
90105>>>>>>>
90105>>>>>>>Class cSQLConnectionHandler is a cObject
90106>>>>>>>
90106>>>>>>>    Procedure Construct_Object
90108>>>>>>>        Forward Send Construct_Object
90110>>>>>>>        Move Self to ghoSQLConnectionHandler
90111>>>>>>>
90111>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
90112>>>>>>>
90112>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
90112>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
90112>>>>>>>        // methods to this class.
90112>>>>>>>        Property Boolean pbUseConnectionID True
90113>>>>>>>        Property Boolean pbToANSI          True
90114>>>>>>>        Property Boolean pbRecnum          True
90115>>>>>>>        Property Boolean pbCopyData        True
90116>>>>>>>        Property Boolean pbCompareDate_DateTime  False
90117>>>>>>>        Property Boolean pbCompareIndexAscending False
90118>>>>>>>        Property Boolean pbCompareIndexUppercase False
90119>>>>>>>
90119>>>>>>>        // Driver default value settings:
90119>>>>>>>        // Note: When the object is created the corresponding values
90119>>>>>>>        // from the driver .int files are read.
90119>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
90119>>>>>>>        Property String psDriverDefaultValueASCII    ""
90120>>>>>>>        Property String psDriverDefaultValueBinary   ""
90121>>>>>>>        Property String psDriverDefaultValueDate     ""
90122>>>>>>>        Property String psDriverDefaultValueDateTime ""
90123>>>>>>>        Property String psDriverDefaultValueNumeric  ""
90124>>>>>>>        Property String psDriverDefaultValueText     ""
90125>>>>>>>
90125>>>>>>>        // Driver "nullability" settings:
90125>>>>>>>        // Note: When the object is created the corresponding values
90125>>>>>>>        // from the driver .int files are read.
90125>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
90125>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
90126>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
90127>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
90128>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
90129>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
90130>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
90131>>>>>>>
90131>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
90131>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
90131>>>>>>>        //     driver interfaces.
90131>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
90131>>>>>>>        //     of the struct they are all routed throu this struct property.
90131>>>>>>>        Property tSQLConnection Private.pSQLConnection
90132>>>>>>>
90132>>>>>>>    End_Procedure
90133>>>>>>>
90133>>>>>>>    Procedure End_Construct_Object
90135>>>>>>>        Boolean bReadSettings
90135>>>>>>>        tSQLConnection SQLConnection
90135>>>>>>>        tSQLConnection SQLConnection
90135>>>>>>>
90135>>>>>>>        Forward Send End_Construct_Object
90137>>>>>>>
90137>>>>>>>        // Now is the time to read and apply SQL connection settings.
90137>>>>>>>        Get SetupSQLConnection True to SQLConnection
90138>>>>>>>        Set Private.pSQLConnection to SQLConnection
90139>>>>>>>    End_Procedure
90140>>>>>>>
90140>>>>>>>    // *** Properties ***
90140>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
90140>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
90140>>>>>>>    // merely here for conveniance.
90140>>>>>>>    //
90140>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
90140>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
90140>>>>>>>    // This struct property contains all the connection data.
90140>>>>>>>    //
90140>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
90142>>>>>>>        Boolean bIsDaw bIsMertech bOK
90142>>>>>>>
90142>>>>>>>        Set Private.pSQLConnection to SQLConnection
90143>>>>>>>
90143>>>>>>>        // When starting a program we might not have a connection id yet:
90143>>>>>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
90145>>>>>>>            Procedure_Return
90146>>>>>>>        End
90146>>>>>>>>
90146>>>>>>>        
90146>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
90146>>>>>>>        // be logged in already and don't want to do it again.
90146>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
90148>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
90148>>>>>>>            // driver interfaces about the change & make a new login.
90148>>>>>>>            Get SQLLogin SQLConnection to bOK
90149>>>>>>>            If (bOK = False) Begin
90151>>>>>>>                Error DFERR_PROGRAM "Login error."
90152>>>>>>>>
90152>>>>>>>            End
90152>>>>>>>>
90152>>>>>>>        End
90152>>>>>>>>
90152>>>>>>>
90152>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
90152>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
90153>>>>>>>
90153>>>>>>>    End_Procedure
90154>>>>>>>
90154>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
90154>>>>>>>    // attempt to load the driver.
90154>>>>>>>    // Returns true if the passed driver is SQL based.
90154>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
90156>>>>>>>        Boolean bOK
90156>>>>>>>        Integer iDriver
90156>>>>>>>
90156>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
90157>>>>>>>
90157>>>>>>>        If (bOK = False) Begin
90159>>>>>>>            Get IsMertechDriver sDriverID to bOK
90160>>>>>>>        End
90160>>>>>>>>
90160>>>>>>>
90160>>>>>>>        Function_Return bOK
90161>>>>>>>    End_Function
90162>>>>>>>
90162>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
90162>>>>>>>    Procedure SetupDriverDefaults String sDriverID
90164>>>>>>>        String sAttributeValue
90164>>>>>>>        Integer iDriverID
90164>>>>>>>        Boolean bNULL bSQLDriver
90164>>>>>>>
90164>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
90165>>>>>>>        If (bSQLDriver = False) Begin
90167>>>>>>>            Procedure_Return
90168>>>>>>>        End
90168>>>>>>>>
90168>>>>>>>
90168>>>>>>>        Get DriverIndex sDriverID to iDriverID
90169>>>>>>>
90169>>>>>>>        // Driver default values for various data types:
90169>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
90172>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
90173>>>>>>>
90173>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
90176>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
90177>>>>>>>
90177>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
90180>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
90181>>>>>>>
90181>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
90184>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
90185>>>>>>>
90185>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
90188>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
90189>>>>>>>
90189>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
90192>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
90193>>>>>>>
90193>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
90193>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
90196>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
90197>>>>>>>
90197>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
90200>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
90201>>>>>>>
90201>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
90204>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
90205>>>>>>>
90205>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
90208>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
90209>>>>>>>
90209>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
90212>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
90213>>>>>>>
90213>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
90216>>>>>>>        Set pbDriverDefaultNullableText to bNULL
90217>>>>>>>
90217>>>>>>>    End_Procedure
90218>>>>>>>
90218>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
90220>>>>>>>        Boolean bOK bIsDaw bIsMertech bTrusted
90220>>>>>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID sCheck
90220>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
90220>>>>>>>        Integer iDriverID
90220>>>>>>>
90220>>>>>>>        Move False to bOK
90221>>>>>>>
90221>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
90222>>>>>>>        If (bIsDaw = False) Begin
90224>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
90225>>>>>>>            If (bIsMertech = False) Begin
90227>>>>>>>                Function_Return False
90228>>>>>>>            End
90228>>>>>>>>
90228>>>>>>>        End
90228>>>>>>>>
90228>>>>>>>
90228>>>>>>>        Move Error_Object_Id to hoErrorObj
90229>>>>>>>        Move Self to Error_Object_Id
90230>>>>>>>
90230>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
90231>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
90232>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
90233>>>>>>>        If (iDriverID = 0) Begin
90235>>>>>>>            Move hoErrorObj to Error_Object_Id
90236>>>>>>>            Function_Return False
90237>>>>>>>        End
90237>>>>>>>>
90237>>>>>>>
90237>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
90237>>>>>>>        If (bIsMertech = False) Begin
90239>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
90242>>>>>>>        End
90242>>>>>>>>
90242>>>>>>>
90242>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
90243>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
90244>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
90245>>>>>>>        Send Destroy   of hoDriver
90246>>>>>>>        Move hoErrorObj to Error_Object_Id
90247>>>>>>>
90247>>>>>>>        Function_Return bOK
90248>>>>>>>    End_Function
90249>>>>>>>
90249>>>>>>>    Function pSQLConnection Returns tSQLConnection
90251>>>>>>>        tSQLConnection SQLConnection
90251>>>>>>>        tSQLConnection SQLConnection
90251>>>>>>>        Get Private.pSQLConnection to SQLConnection
90252>>>>>>>        Function_Return SQLConnection
90253>>>>>>>    End_Function
90254>>>>>>>
90254>>>>>>>    Procedure Set psConnectionID String sValue
90256>>>>>>>        tSQLConnection SQLConnection
90256>>>>>>>        tSQLConnection SQLConnection
90256>>>>>>>        Integer iIndex
90256>>>>>>>
90256>>>>>>>        Get Private.pSQLConnection to SQLConnection
90257>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
90259>>>>>>>            Move sValue to SQLConnection.sConnectionID
90260>>>>>>>        End
90260>>>>>>>>
90260>>>>>>>
90260>>>>>>>        // Else we might want to change the current connection ID
90260>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
90263>>>>>>>            Move False to Err
90264>>>>>>>            Logout SQLConnection.sDriverID
90265>>>>>>>            // This will also make a login to the new server.
90265>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
90266>>>>>>>        End
90266>>>>>>>>
90266>>>>>>>        Set pSQLConnection to SQLConnection
90267>>>>>>>    End_Procedure
90268>>>>>>>
90268>>>>>>>    Function psConnectionID Returns String
90270>>>>>>>        tSQLConnection SQLConnection
90270>>>>>>>        tSQLConnection SQLConnection
90270>>>>>>>        Get Private.pSQLConnection to SQLConnection
90271>>>>>>>        Function_Return SQLConnection.sConnectionID
90272>>>>>>>    End_Procedure
90273>>>>>>>
90273>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
90273>>>>>>>    //       the psDriverID *must* be the first property that is changed!
90273>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
90273>>>>>>>    //       for a connection string has the wrong format for that driver.
90273>>>>>>>    Procedure Set psDriverID String sValue
90275>>>>>>>        tSQLConnection SQLConnection
90275>>>>>>>        tSQLConnection SQLConnection
90275>>>>>>>        Get pSQLConnection to SQLConnection
90276>>>>>>>        Move sValue        to SQLConnection.sDriverID
90277>>>>>>>        Set pSQLConnection to SQLConnection
90278>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
90280>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
90281>>>>>>>        End
90281>>>>>>>>
90281>>>>>>>    End_Procedure
90282>>>>>>>
90282>>>>>>>    Function psDriverID Returns String
90284>>>>>>>        tSQLConnection SQLConnection
90284>>>>>>>        tSQLConnection SQLConnection
90284>>>>>>>        Get Private.pSQLConnection to SQLConnection
90285>>>>>>>        If (SQLConnection.sDriverID = "") Begin
90287>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
90288>>>>>>>        End
90288>>>>>>>>
90288>>>>>>>        Function_Return SQLConnection.sDriverID
90289>>>>>>>    End_Function
90290>>>>>>>
90290>>>>>>>    Procedure Set psConnectionString String sValue
90292>>>>>>>        tSQLConnection SQLConnection
90292>>>>>>>        tSQLConnection SQLConnection
90292>>>>>>>        Get Private.pSQLConnection to SQLConnection
90293>>>>>>>        Move sValue        to SQLConnection.sConnectionString
90294>>>>>>>        Set pSQLConnection to SQLConnection
90295>>>>>>>    End_Procedure
90296>>>>>>>
90296>>>>>>>    Function psConnectionString Returns String
90298>>>>>>>        tSQLConnection SQLConnection
90298>>>>>>>        tSQLConnection SQLConnection
90298>>>>>>>        Get Private.pSQLConnection to SQLConnection
90299>>>>>>>        Function_Return SQLConnection.sConnectionString
90300>>>>>>>    End_Function
90301>>>>>>>
90301>>>>>>>    Procedure Set psServer String sValue
90303>>>>>>>        tSQLConnection SQLConnection
90303>>>>>>>        tSQLConnection SQLConnection
90303>>>>>>>        Get Private.pSQLConnection to SQLConnection
90304>>>>>>>        Move sValue        to SQLConnection.sServer
90305>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
90306>>>>>>>        Set pSQLConnection to SQLConnection
90307>>>>>>>    End_Procedure
90308>>>>>>>
90308>>>>>>>    Function psServer Returns String
90310>>>>>>>        tSQLConnection SQLConnection
90310>>>>>>>        tSQLConnection SQLConnection
90310>>>>>>>        Get Private.pSQLConnection to SQLConnection
90311>>>>>>>        Function_Return SQLConnection.sServer
90312>>>>>>>    End_Function
90313>>>>>>>
90313>>>>>>>    Procedure Set psDatabase String sValue
90315>>>>>>>        tSQLConnection SQLConnection
90315>>>>>>>        tSQLConnection SQLConnection
90315>>>>>>>        Get Private.pSQLConnection to SQLConnection
90316>>>>>>>        Move sValue        to SQLConnection.sDatabase
90317>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
90318>>>>>>>        Set pSQLConnection to SQLConnection
90319>>>>>>>    End_Procedure
90320>>>>>>>
90320>>>>>>>    Function psDatabase Returns String
90322>>>>>>>        tSQLConnection SQLConnection
90322>>>>>>>        tSQLConnection SQLConnection
90322>>>>>>>        Get Private.pSQLConnection to SQLConnection
90323>>>>>>>        Function_Return SQLConnection.sDatabase
90324>>>>>>>    End_Function
90325>>>>>>>
90325>>>>>>>    Procedure Set psUserID String sValue
90327>>>>>>>        tSQLConnection SQLConnection
90327>>>>>>>        tSQLConnection SQLConnection
90327>>>>>>>        Get Private.pSQLConnection to SQLConnection
90328>>>>>>>        Move sValue        to SQLConnection.sUserID
90329>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
90330>>>>>>>        Set pSQLConnection to SQLConnection
90331>>>>>>>    End_Procedure
90332>>>>>>>
90332>>>>>>>    Function psUserID Returns String
90334>>>>>>>        tSQLConnection SQLConnection
90334>>>>>>>        tSQLConnection SQLConnection
90334>>>>>>>        Get Private.pSQLConnection to SQLConnection
90335>>>>>>>        Function_Return SQLConnection.sUserID
90336>>>>>>>    End_Function
90337>>>>>>>
90337>>>>>>>    // This is the uncrypted password
90337>>>>>>>    Procedure Set psPassword String sValue
90339>>>>>>>        tSQLConnection SQLConnection
90339>>>>>>>        tSQLConnection SQLConnection
90339>>>>>>>        Get Private.pSQLConnection to SQLConnection
90340>>>>>>>        Move sValue        to SQLConnection.sPassword
90341>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
90342>>>>>>>        Set pSQLConnection to SQLConnection
90343>>>>>>>    End_Procedure
90344>>>>>>>
90344>>>>>>>    Function psPassword Returns String
90346>>>>>>>        tSQLConnection SQLConnection
90346>>>>>>>        tSQLConnection SQLConnection
90346>>>>>>>        Get Private.pSQLConnection to SQLConnection
90347>>>>>>>        Function_Return SQLConnection.sPassword
90348>>>>>>>    End_Function
90349>>>>>>>
90349>>>>>>>    Procedure Set pbTrusted Boolean bValue
90351>>>>>>>        tSQLConnection SQLConnection
90351>>>>>>>        tSQLConnection SQLConnection
90351>>>>>>>        Get Private.pSQLConnection to SQLConnection
90352>>>>>>>        Move bValue        to SQLConnection.bTrusted
90353>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
90354>>>>>>>        Set pSQLConnection to SQLConnection
90355>>>>>>>    End_Procedure
90356>>>>>>>
90356>>>>>>>    Function pbTrusted Returns Boolean
90358>>>>>>>        tSQLConnection SQLConnection
90358>>>>>>>        tSQLConnection SQLConnection
90358>>>>>>>        Get Private.pSQLConnection to SQLConnection
90359>>>>>>>        Function_Return SQLConnection.bTrusted
90360>>>>>>>    End_Function
90361>>>>>>>
90361>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
90361>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
90361>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
90361>>>>>>>    //     the central pSQLConnection "hub".
90361>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
90363>>>>>>>        tSQLConnection SQLConnection
90363>>>>>>>        tSQLConnection SQLConnection
90363>>>>>>>        Get Private.pSQLConnection to SQLConnection
90364>>>>>>>        Move bValue to SQLConnection.bTrusted
90365>>>>>>>        Set Private.pSQLConnection to SQLConnection
90366>>>>>>>    End_Procedure
90367>>>>>>>
90367>>>>>>>    Function pbSilentLogin Returns Boolean
90369>>>>>>>        tSQLConnection SQLConnection
90369>>>>>>>        tSQLConnection SQLConnection
90369>>>>>>>        Get Private.pSQLConnection to SQLConnection
90370>>>>>>>        Function_Return SQLConnection.bSilentLogin
90371>>>>>>>    End_Function
90372>>>>>>>
90372>>>>>>>    Procedure Set piDbType Integer iValue
90374>>>>>>>        tSQLConnection SQLConnection
90374>>>>>>>        tSQLConnection SQLConnection
90374>>>>>>>        Get Private.pSQLConnection to SQLConnection
90375>>>>>>>        Move iValue to SQLConnection.iDbType
90376>>>>>>>        Set Private.pSQLConnection to SQLConnection
90377>>>>>>>    End_Procedure
90378>>>>>>>
90378>>>>>>>    Function piDbType Returns Integer
90380>>>>>>>        tSQLConnection SQLConnection
90380>>>>>>>        tSQLConnection SQLConnection
90380>>>>>>>        Get Private.pSQLConnection to SQLConnection
90381>>>>>>>        Function_Return SQLConnection.iDbType
90382>>>>>>>    End_Function
90383>>>>>>>
90383>>>>>>>    Procedure Set psBaseTableSpace String sValue
90385>>>>>>>        tSQLConnection SQLConnection
90385>>>>>>>        tSQLConnection SQLConnection
90385>>>>>>>        Get Private.pSQLConnection to SQLConnection
90386>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
90387>>>>>>>        Set Private.pSQLConnection to SQLConnection
90388>>>>>>>    End_Procedure
90389>>>>>>>
90389>>>>>>>    Function psBaseTableSpace Returns String
90391>>>>>>>        tSQLConnection SQLConnection
90391>>>>>>>        tSQLConnection SQLConnection
90391>>>>>>>        Get Private.pSQLConnection to SQLConnection
90392>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
90393>>>>>>>    End_Function
90394>>>>>>>
90394>>>>>>>    Procedure Set psIndexTableSpace String sValue
90396>>>>>>>        tSQLConnection SQLConnection
90396>>>>>>>        tSQLConnection SQLConnection
90396>>>>>>>        Get Private.pSQLConnection to SQLConnection
90397>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
90398>>>>>>>        Set Private.pSQLConnection to SQLConnection
90399>>>>>>>    End_Procedure
90400>>>>>>>
90400>>>>>>>    Function psIndexTableSpace Returns String
90402>>>>>>>        tSQLConnection SQLConnection
90402>>>>>>>        tSQLConnection SQLConnection
90402>>>>>>>        Get Private.pSQLConnection to SQLConnection
90403>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
90404>>>>>>>    End_Function
90405>>>>>>>
90405>>>>>>>    Procedure Set psLongTableSpace String sValue
90407>>>>>>>        tSQLConnection SQLConnection
90407>>>>>>>        tSQLConnection SQLConnection
90407>>>>>>>        Get Private.pSQLConnection to SQLConnection
90408>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
90409>>>>>>>        Set Private.pSQLConnection to SQLConnection
90410>>>>>>>    End_Procedure
90411>>>>>>>
90411>>>>>>>    Function psLongTableSpace Returns String
90413>>>>>>>        tSQLConnection SQLConnection
90413>>>>>>>        tSQLConnection SQLConnection
90413>>>>>>>        Get Private.pSQLConnection to SQLConnection
90414>>>>>>>        Function_Return SQLConnection.sLongTableSpace
90415>>>>>>>    End_Function
90416>>>>>>>
90416>>>>>>>    Procedure Set psSchema String sValue
90418>>>>>>>        tSQLConnection SQLConnection
90418>>>>>>>        tSQLConnection SQLConnection
90418>>>>>>>        Get Private.pSQLConnection to SQLConnection
90419>>>>>>>        Move sValue to SQLConnection.sSchema
90420>>>>>>>        Set Private.pSQLConnection to SQLConnection
90421>>>>>>>    End_Procedure
90422>>>>>>>
90422>>>>>>>    Function psSchema Returns String
90424>>>>>>>        tSQLConnection SQLConnection
90424>>>>>>>        tSQLConnection SQLConnection
90424>>>>>>>        Get Private.pSQLConnection to SQLConnection
90425>>>>>>>        Function_Return SQLConnection.sSchema
90426>>>>>>>    End_Function
90427>>>>>>>
90427>>>>>>>    Procedure Set pbEnabled Boolean bValue
90429>>>>>>>        tSQLConnection SQLConnection
90429>>>>>>>        tSQLConnection SQLConnection
90429>>>>>>>        Get Private.pSQLConnection to SQLConnection
90430>>>>>>>        Move bValue to SQLConnection.bEnabled
90431>>>>>>>        Set Private.pSQLConnection to SQLConnection
90432>>>>>>>    End_Procedure
90433>>>>>>>
90433>>>>>>>    Function pbEnabled Returns Boolean
90435>>>>>>>        tSQLConnection SQLConnection
90435>>>>>>>        tSQLConnection SQLConnection
90435>>>>>>>        Get Private.pSQLConnection to SQLConnection
90436>>>>>>>        Function_Return SQLConnection.bEnabled
90437>>>>>>>    End_Function
90438>>>>>>>
90438>>>>>>>
90438>>>>>>>    // ************************************
90438>>>>>>>    Function SetupSQLConnection Boolean bReadSettings Returns tSQLConnection
90440>>>>>>>        tSQLConnection SQLConnection
90440>>>>>>>        tSQLConnection SQLConnection
90440>>>>>>>
90440>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
90440>>>>>>>        // deferr reading SQL connection values until later.
90440>>>>>>>        If (bReadSettings = True) Begin
90442>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
90442>>>>>>>            If (ghoConnection > 0) Begin
90444>>>>>>>                Get ReadcConnections to SQLConnection
90445>>>>>>>            End
90445>>>>>>>>
90445>>>>>>>
90445>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
90445>>>>>>>            // object is used.
90445>>>>>>>            Get ReadSQLConnectionsIniSettings to SQLConnection
90446>>>>>>>        End
90446>>>>>>>>
90446>>>>>>>
90446>>>>>>>        Function_Return SQLConnection
90447>>>>>>>    End_Function
90448>>>>>>>
90448>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
90448>>>>>>>    Function ReadcConnections Returns tSQLConnection
90450>>>>>>>        tConnection Connection
90450>>>>>>>        tConnection Connection
90450>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
90450>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
90450>>>>>>>        Integer iCount iSize iRetval iDbType
90450>>>>>>>        Boolean bOK bEnabled bConnected bVal
90450>>>>>>>        String sConnectionID sSchema
90450>>>>>>>
90450>>>>>>>            tConnection[] Connections
90450>>>>>>>            tConnection[] Connections
90451>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
90451>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
90451>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
90451>>>>>>>            //   we then generate an error and abort the program...
90451>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
90452>>>>>>>            If (bOK = False) Begin
90454>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
90455>>>>>>>>
90455>>>>>>>                Abort
90456>>>>>>>>
90456>>>>>>>            End 
90456>>>>>>>>
90456>>>>>>>            If (sConnectionID = "") Begin
90458>>>>>>>                Get ConnectionIDs of ghoConnection to Connections  
90459>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
90461>>>>>>>                    Move Connections[0].sId to sConnectionID
90462>>>>>>>                End
90462>>>>>>>>
90462>>>>>>>            End
90462>>>>>>>>
90462>>>>>>>
90462>>>>>>>            Move 0 to iRetval
90463>>>>>>>            // DAW DF19 connection info:
90463>>>>>>>            // We first check that the connection is OK:
90463>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
90464>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
90464>>>>>>>            If (iRetval = -1) Begin
90466>>>>>>>                Function_Return SQLConnectionEmpty
90467>>>>>>>            End
90467>>>>>>>>
90467>>>>>>>
90467>>>>>>>            If (sConnectionID <> "") Begin
90469>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
90470>>>>>>>            End
90470>>>>>>>>
90470>>>>>>>            If (Connection.sId = "") Begin
90472>>>>>>>                Move True to SQLConnectionEmpty.bError
90473>>>>>>>                Function_Return SQLConnectionEmpty
90474>>>>>>>            End
90474>>>>>>>>
90474>>>>>>>
90474>>>>>>>            // DUF connection info struct property:
90474>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
90475>>>>>>>
90475>>>>>>>            Move Connection.sId to sConnectionID
90476>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
90477>>>>>>>
90477>>>>>>>            If (bConnected = False) Begin
90479>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
90480>>>>>>>                If (iRetval <> 0) Begin
90482>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
90483>>>>>>>                    Send Exit_Application
90484>>>>>>>                End   
90484>>>>>>>>
90484>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
90485>>>>>>>                // We need to get the DAW connection info again as it might have
90485>>>>>>>                // been changed in the DAW db login dialog.
90485>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
90486>>>>>>>            End
90486>>>>>>>>
90486>>>>>>>
90486>>>>>>>            Move True                                        to SQLConnection.bEnabled
90487>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
90488>>>>>>>
90488>>>>>>>            // Not used in DUF:
90488>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
90488>>>>>>>
90488>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
90489>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
90490>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
90491>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
90492>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
90493>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
90494>>>>>>>
90494>>>>>>>            // Not used in DUF:
90494>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
90494>>>>>>>
90494>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
90494>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
90494>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
90496>>>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniServerKeyword to SQLConnection.sServer
90497>>>>>>>            End
90497>>>>>>>>
90497>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
90499>>>>>>>                Get ParseKeyWord Connection.sString CS_SQLIniDSNKeyword    to SQLConnection.sServer
90500>>>>>>>            End
90500>>>>>>>>
90500>>>>>>>            Get ParseKeyWord Connection.sString CS_SQLIniDatabaseKeyword   to SQLConnection.sDatabase
90501>>>>>>>
90501>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
90501>>>>>>>            // the value from the driver id:
90501>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
90502>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
90502>>>>>>>            Get piDbType                                     to iDbType
90503>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
90505>>>>>>>                Move iDbType to SQLConnection.iDbType
90506>>>>>>>            End
90506>>>>>>>>
90506>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
90507>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
90508>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
90509>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
90510>>>>>>>
90510>>>>>>>            // We finally set the struct property to the newly fetched values.
90510>>>>>>>            Set pSQLConnection to SQLConnection
90511>>>>>>>
90511>>>>>>>        Function_Return SQLConnection
90512>>>>>>>    End_Function
90513>>>>>>>
90513>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
90513>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
90513>>>>>>>    // connection id for a particular driver.
90513>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
90513>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
90513>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
90513>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
90513>>>>>>>    // connections of the DAW cConnect class.
90513>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
90515>>>>>>>        tConnection[] ConnIdArray
90515>>>>>>>        tConnection[] ConnIdArray
90516>>>>>>>        Integer iCount iSize iConnectionIDCounter
90516>>>>>>>        Boolean bOK bEnabled bFound
90516>>>>>>>        String sConnectionID2 sDriverID sDriverConn
90516>>>>>>>
90516>>>>>>>        Move False to bFound
90517>>>>>>>        If (ghoConnection > 0) Begin
90519>>>>>>>
90519>>>>>>>            // The property of the cDbUpdateHandler container object
90519>>>>>>>            Get psDriverID to sDriverID
90520>>>>>>>
90520>>>>>>>            Move 0 to iConnectionIDCounter
90521>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
90521>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
90522>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
90523>>>>>>>            Decrement iSize
90524>>>>>>>            For iCount from 0 to iSize
90530>>>>>>>>
90530>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
90531>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
90532>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
90533>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
90533>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
90533>>>>>>>                If (sConnectionID = "") Begin
90535>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
90536>>>>>>>                End
90536>>>>>>>>
90536>>>>>>>                Else Begin
90537>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
90539>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
90540>>>>>>>                    End
90540>>>>>>>>
90540>>>>>>>                End
90540>>>>>>>>
90540>>>>>>>
90540>>>>>>>                If (bFound = True) Begin
90542>>>>>>>                    Increment iConnectionIDCounter
90543>>>>>>>                End
90543>>>>>>>>
90543>>>>>>>            Loop
90544>>>>>>>>
90544>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
90545>>>>>>>            If (bFound = True) Begin
90547>>>>>>>                Move sConnectionID2 to sConnectionID
90548>>>>>>>            End
90548>>>>>>>>
90548>>>>>>>        End
90548>>>>>>>>
90548>>>>>>>
90548>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
90548>>>>>>>        // but no DFConn.ini record has been created.
90548>>>>>>>        If (iSize = -1) Begin
90550>>>>>>>            Move True to bFound
90551>>>>>>>        End
90551>>>>>>>>
90551>>>>>>>
90551>>>>>>>        Function_Return bFound
90552>>>>>>>    End_Function
90553>>>>>>>
90553>>>>>>>    // Send on object creation to read the default connection string settings, and
90553>>>>>>>    // create a connection to the server.
90553>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
90555>>>>>>>        String sPath sFileName sSection sConnectionString sPassword
90555>>>>>>>        Boolean bExists
90555>>>>>>>        tSQLConnection[] SQLConnectionArray
90555>>>>>>>        tSQLConnection[] SQLConnectionArray
90556>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
90556>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
90556>>>>>>>        Handle hoIniFile
90556>>>>>>>        Integer iSize iCount
90556>>>>>>>
90556>>>>>>>        Get psIniFilePath to sPath
90557>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
90558>>>>>>>        If (sPath = "") Begin
90560>>>>>>>            Get ApplicationPath of hoIniFile to sPath
90561>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
90562>>>>>>>        End
90562>>>>>>>>
90562>>>>>>>        Get vFolderFormat sPath to sPath
90563>>>>>>>        Get psIniFileName to sFileName
90564>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
90565>>>>>>>
90565>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
90566>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
90567>>>>>>>        If (iSize = 0) Begin
90569>>>>>>>            // This may have been set by the "ReadcConnections" function,
90569>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
90569>>>>>>>            // in the cApplication object.
90569>>>>>>>            Get pSQLConnection to SQLConnection
90570>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
90572>>>>>>>                Function_Return SQLConnectionEmpty
90573>>>>>>>            End
90573>>>>>>>>
90573>>>>>>>            Move SQLConnection to SQLConnectionArray[0]
90574>>>>>>>        End
90574>>>>>>>>
90574>>>>>>>
90574>>>>>>>        // The first connection should be the one that is active, but just in case...
90574>>>>>>>        Decrement iSize
90575>>>>>>>        For iCount from 0 to iSize
90581>>>>>>>>
90581>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
90582>>>>>>>            If (SQLConnection.bEnabled = True) Begin
90584>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
90585>>>>>>>            End
90585>>>>>>>>
90585>>>>>>>        Loop
90586>>>>>>>>
90586>>>>>>>
90586>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
90587>>>>>>>
90587>>>>>>>        Set pSQLConnection to SQLConnection
90588>>>>>>>        Send AutoSetConnectionID
90589>>>>>>>
90589>>>>>>>        Function_Return SQLConnection
90590>>>>>>>    End_Function
90591>>>>>>>
90591>>>>>>>    Procedure Set psIniFilePath String sPath
90593>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
90594>>>>>>>    End_Procedure
90595>>>>>>>
90595>>>>>>>    Function psIniFilePath Returns String
90597>>>>>>>        String sRetval
90597>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
90598>>>>>>>        Function_Return sRetval
90599>>>>>>>    End_Function
90600>>>>>>>
90600>>>>>>>    Procedure Set psIniFileName String sFileName
90602>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
90603>>>>>>>    End_Procedure
90604>>>>>>>
90604>>>>>>>    Function psIniFileName Returns String
90606>>>>>>>        String sRetval
90606>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
90607>>>>>>>        Function_Return sRetval
90608>>>>>>>    End_Function
90609>>>>>>>
90609>>>>>>>    // We use Base64 coding instead of the cCryptographer class because the
90609>>>>>>>    // password will get scrambled while writing/reading to/from the ini-file.
90609>>>>>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
90609>>>>>>>//    Procedure Set psHashString String sHashString
90609>>>>>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
90609>>>>>>>//    End_Procedure
90609>>>>>>>//
90609>>>>>>>//    Function psHashString Returns String
90609>>>>>>>//        String sRetval
90609>>>>>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
90609>>>>>>>//        Function_Return sRetval
90609>>>>>>>//    End_Function
90609>>>>>>>
90609>>>>>>>    Procedure Set psIniSectionName String sSection
90611>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
90612>>>>>>>    End_Procedure
90613>>>>>>>
90613>>>>>>>    Function psIniSectionName Returns String
90615>>>>>>>        String sRetval
90615>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
90616>>>>>>>        Function_Return sRetval
90617>>>>>>>    End_Function
90618>>>>>>>
90618>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
90620>>>>>>>        Handle ho
90620>>>>>>>        Get phoSQLConnectionIniFile to ho
90621>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
90622>>>>>>>    End_Procedure
90623>>>>>>>
90623>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
90625>>>>>>>        Handle ho
90625>>>>>>>        String sRetval
90625>>>>>>>        Get phoSQLConnectionIniFile to ho
90626>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
90627>>>>>>>        Function_Return sRetval
90628>>>>>>>    End_Function
90629>>>>>>>
90629>>>>>>>    Function SectionExists String sSection Returns Boolean
90631>>>>>>>        Handle ho
90631>>>>>>>        Boolean bRetval
90631>>>>>>>        Get phoSQLConnectionIniFile to ho
90632>>>>>>>        Get SectionExists of ho sSection to bRetval
90633>>>>>>>        Function_Return bRetval
90634>>>>>>>    End_Function
90635>>>>>>>
90635>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
90637>>>>>>>        Handle ho
90637>>>>>>>        Boolean bRetval
90637>>>>>>>        Get phoSQLConnectionIniFile to ho
90638>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
90639>>>>>>>        Function_Return bRetval
90640>>>>>>>    End_Function
90641>>>>>>>
90641>>>>>>>    Function EncryptPassword String sPassword Returns String
90643>>>>>>>        Handle ho
90643>>>>>>>        String sRetval
90643>>>>>>>        Get phoSQLConnectionIniFile to ho
90644>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
90645>>>>>>>        Function_Return sRetval
90646>>>>>>>    End_Function
90647>>>>>>>
90647>>>>>>>    Function DecryptPassword String sPassword Returns String
90649>>>>>>>        Handle ho
90649>>>>>>>        String sRetval
90649>>>>>>>        Get phoSQLConnectionIniFile to ho
90650>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
90651>>>>>>>        Function_Return sRetval
90652>>>>>>>    End_Function
90653>>>>>>>
90653>>>>>>>    // *** Main Connection Message ***
90653>>>>>>>    // It will create a Connection ID for the passed driver.
90653>>>>>>>    // It will also set the psDriverID & psConnectionID of this class.
90653>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
90655>>>>>>>        Integer iResult
90655>>>>>>>        Handle hoCLI hoDriver
90655>>>>>>>        String sConnectionString sError
90655>>>>>>>        Boolean bMertech bLoginSuccessful
90655>>>>>>>
90655>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
90656>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
90657>>>>>>>        Set psDriverID of hoDriver to sDriverID
90658>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
90659>>>>>>>        If (bLoginSuccessful = False) Begin
90661>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
90662>>>>>>>>
90662>>>>>>>        End
90662>>>>>>>>
90662>>>>>>>        Send Destroy of hoDriver
90663>>>>>>>
90663>>>>>>>    End_Procedure
90664>>>>>>>
90664>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
90666>>>>>>>        Integer iRetval
90666>>>>>>>        Handle hoCLI
90666>>>>>>>        String sDriverID
90666>>>>>>>
90666>>>>>>>        Get psDriverID to sDriverID
90667>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
90668>>>>>>>        If (hoCLI <> 0) Begin
90670>>>>>>>            Set psDriverID of hoCLI to sDriverID
90671>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
90672>>>>>>>            Send Destroy of hoCLI
90673>>>>>>>        End
90673>>>>>>>>
90673>>>>>>>
90673>>>>>>>        Function_Return iRetval
90674>>>>>>>    End_Function
90675>>>>>>>
90675>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
90677>>>>>>>        Integer iResult
90677>>>>>>>        Handle hoCLI
90677>>>>>>>        String sServer sDatabase sUserID sPassword
90677>>>>>>>        tSQLConnection SQLConnection
90677>>>>>>>        tSQLConnection SQLConnection
90677>>>>>>>
90677>>>>>>>        Set psDriverID to sDriverID
90678>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
90679>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
90680>>>>>>>    End_Procedure
90681>>>>>>>
90681>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
90681>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
90681>>>>>>>    // or the one in the DataFlex Bin folder.)
90681>>>>>>>    // We then need to delete the current one before creating a new one.
90681>>>>>>>    // This is because the parameters may differ between the program code and the
90681>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
90681>>>>>>>    // when one tries to create a Connection ID that already exists.
90681>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
90683>>>>>>>        Integer iResult iDriver iNumConn iConn
90683>>>>>>>        Handle hoCLI
90683>>>>>>>        String sID
90683>>>>>>>
90683>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
90685>>>>>>>            Procedure_Return
90686>>>>>>>        End
90686>>>>>>>>
90686>>>>>>>
90686>>>>>>>        Move 0 to iResult
90687>>>>>>>        Get Create U_cCLIHandler to hoCLI
90688>>>>>>>        If (hoCLI <> 0) Begin
90690>>>>>>>            Set psDriverID of hoCLI to sDriverID
90691>>>>>>>            Get DriverIndex sDriverID to iDriver
90692>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
90695>>>>>>>            Decrement iNumConn
90696>>>>>>>            For iConn from 0 to iNumConn
90702>>>>>>>>
90702>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
90705>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
90707>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
90708>>>>>>>                End
90708>>>>>>>>
90708>>>>>>>            Loop
90709>>>>>>>>
90709>>>>>>>            Send Destroy of hoCLI
90710>>>>>>>        End
90710>>>>>>>>
90710>>>>>>>
90710>>>>>>>    End_Procedure
90711>>>>>>>
90711>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
90713>>>>>>>        Integer iResult iDriver iNumConn iConn
90713>>>>>>>        Handle hoCLI
90713>>>>>>>        String sID sConnectionString sVal sDatabase
90713>>>>>>>        tSQLConnection SQLConnection
90713>>>>>>>        tSQLConnection SQLConnection
90713>>>>>>>        Boolean bTrusted
90713>>>>>>>
90713>>>>>>>        Move 0 to iResult
90714>>>>>>>        Get Create U_cCLIHandler to hoCLI
90715>>>>>>>        If (hoCLI <> 0) Begin
90717>>>>>>>            Set psDriverID of hoCLI to sDriverID
90718>>>>>>>            Get DriverIndex sDriverID to iDriver
90719>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
90722>>>>>>>            Decrement iNumConn
90723>>>>>>>            For iConn from 0 to iNumConn
90729>>>>>>>>
90729>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
90732>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
90734>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
90735>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
90738>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
90741>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
90742>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
90745>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
90746>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
90747>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
90748>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
90749>>>>>>>
90749>>>>>>>                    Case Begin
90749>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
90751>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
90752>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
90753>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
90754>>>>>>>                            Case Break
90755>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
90758>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90759>>>>>>>                            Case Break
90760>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
90763>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90764>>>>>>>                            Case Break
90765>>>>>>>                        Case (sDriverID = SQLFLEX)
90768>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90769>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
90770>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
90772>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
90773>>>>>>>                            End
90773>>>>>>>>
90773>>>>>>>                            Else Begin
90774>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
90775>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
90776>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
90777>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
90778>>>>>>>                            End
90778>>>>>>>>
90778>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
90779>>>>>>>                            Case Break
90780>>>>>>>                        Case (sDriverID = MDSMySQL)
90783>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90784>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
90785>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
90787>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
90788>>>>>>>                            End
90788>>>>>>>>
90788>>>>>>>                            Else Begin
90789>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
90790>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
90791>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
90792>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
90793>>>>>>>                            End
90793>>>>>>>>
90793>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
90794>>>>>>>                            Case Break
90795>>>>>>>                        Case (sDriverID = MDSPgSQL)
90798>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
90799>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
90800>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
90802>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
90803>>>>>>>                            End
90803>>>>>>>>
90803>>>>>>>                            Else Begin
90804>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
90805>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
90806>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
90807>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
90808>>>>>>>                            End
90808>>>>>>>>
90808>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
90809>>>>>>>                            Case Break
90810>>>>>>>
90810>>>>>>>                        Case (sDriverID = ORAFLEX)
90813>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
90814>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
90815>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
90816>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
90818>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
90819>>>>>>>                            End
90819>>>>>>>>
90819>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
90821>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
90822>>>>>>>                            End
90822>>>>>>>>
90822>>>>>>>                            Else Begin
90823>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
90824>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
90825>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
90826>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
90827>>>>>>>                            End
90827>>>>>>>>
90827>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
90828>>>>>>>                            Case Break
90829>>>>>>>                        Case Else
90829>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
90830>>>>>>>>
90830>>>>>>>                            Case Break
90831>>>>>>>                    Case End
90831>>>>>>>                End
90831>>>>>>>>
90831>>>>>>>            Loop
90832>>>>>>>>
90832>>>>>>>            Send Destroy of hoCLI
90833>>>>>>>        End
90833>>>>>>>>
90833>>>>>>>
90833>>>>>>>        Function_Return SQLConnection
90834>>>>>>>    End_Function
90835>>>>>>>
90835>>>>>>>    Function DriverIndex String sDriverID Returns Integer
90837>>>>>>>        String  sCurrentDriver
90837>>>>>>>        Integer iNumberOfDrivers iDriver iCount iRetval
90837>>>>>>>
90837>>>>>>>        Move 0 to iDriver
90838>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
90841>>>>>>>        For iCount from 1 to iNumberOfDrivers
90847>>>>>>>>
90847>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
90850>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
90852>>>>>>>                Function_Return iCount
90853>>>>>>>            End
90853>>>>>>>>
90853>>>>>>>        Loop
90854>>>>>>>>
90854>>>>>>>
90854>>>>>>>        // If driver not previously loaded; attempt to do so now.
90854>>>>>>>        If (iDriver = 0) Begin
90856>>>>>>>            Move 0 to LastErr
90857>>>>>>>            Load_Driver sDriverID
90858>>>>>>>            // If driver could not be loaded.
90858>>>>>>>            If (LastErr = 4255) Begin
90860>>>>>>>                Move 0 to iCount
90861>>>>>>>            End
90861>>>>>>>>
90861>>>>>>>            Function_Return iCount
90862>>>>>>>        End
90862>>>>>>>>
90862>>>>>>>        Function_Return 0
90863>>>>>>>    End_Function
90864>>>>>>>
90864>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
90864>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
90866>>>>>>>        String sRetval sDriverID sConnectionID sConnectionString sServer sDatabase sUserID sPassword
90866>>>>>>>        Boolean bTrusted bSilent
90866>>>>>>>        Integer iConnOptions
90866>>>>>>>
90866>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
90867>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
90868>>>>>>>        Move SQLConnection.sServer       to sServer
90869>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
90870>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
90871>>>>>>>        Move SQLConnection.sUserID       to sUserID
90872>>>>>>>        Move SQLConnection.sPassword     to sPassword
90873>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
90874>>>>>>>
90874>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
90875>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
90875>>>>>>>        Send AutoSetConnectionID
90876>>>>>>>    End_Procedure
90877>>>>>>>
90877>>>>>>>    // Called when the object is constructed.
90877>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
90877>>>>>>>    // as psConnectionID property. It is later used whenever a login to
90877>>>>>>>    // the database is needed.
90877>>>>>>>    Procedure AutoSetConnectionID
90879>>>>>>>        String sConnectionID sValue sDriverID sConnectionString
90879>>>>>>>        Integer iDriver iNumConn iConn iConnOptions iRetval
90879>>>>>>>        Handle hoCLI
90879>>>>>>>        Boolean bOK bSilent bMertechDriver
90879>>>>>>>
90879>>>>>>>        Get pbSilentLogin      to bSilent
90880>>>>>>>        Get psConnectionID     to sConnectionID
90881>>>>>>>        Get psConnectionString to sConnectionString
90882>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
90882>>>>>>>        Get psDriverID to sDriverID
90883>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90884>>>>>>>        If (bOK = False) Begin
90886>>>>>>>            Procedure_Return
90887>>>>>>>        End
90887>>>>>>>>
90887>>>>>>>
90887>>>>>>>        // Mertech drivers can't use connection ID's.
90887>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
90888>>>>>>>        If (bMertechDriver = True) Begin
90890>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
90890>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
90890>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
90891>>>>>>>            Procedure_Return
90892>>>>>>>        End
90892>>>>>>>>
90892>>>>>>>
90892>>>>>>>        Get DriverIndex sDriverID          to iDriver
90893>>>>>>>        // If driver not loaded; load it.
90893>>>>>>>        If (iDriver = 0) Begin
90895>>>>>>>            Load_Driver sDriverID
90896>>>>>>>            Get DriverIndex sDriverID      to iDriver
90897>>>>>>>        End
90897>>>>>>>>
90897>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
90897>>>>>>>        If (iDriver = 0) Begin
90899>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
90900>>>>>>>>
90900>>>>>>>            Procedure_Return
90901>>>>>>>        End
90901>>>>>>>>
90901>>>>>>>
90901>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
90902>>>>>>>        Set psDriverID of hoCLI            to sDriverID
90903>>>>>>>        // Delete the connection first; in case it exists
90903>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
90904>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval
90905>>>>>>>
90905>>>>>>>        Send Destroy of hoCLI
90906>>>>>>>    End_Procedure
90907>>>>>>>
90907>>>>>>>    // Returns the handle of the Mertech SQL handler.
90907>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
90907>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
90907>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
90907>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
90907>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
90909>>>>>>>        Handle hoSQLHandler
90909>>>>>>>        String sDriverID sServer sDatabase
90909>>>>>>>
90909>>>>>>>        Move 0 to hoSQLHandler
90910>>>>>>>        Get psDriverID to sDriverID
90911>>>>>>>        Get psServer   to sServer
90912>>>>>>>        Get psDatabase to sDatabase
90913>>>>>>>        // This command is used to set the server to be used when opening tables
90913>>>>>>>        SET_CURRENT_SQL_SERVER to sServer
90932>>>>>>>>
90932>>>>>>>        // This command is used to specify which server to use for embedded SQL statements,
90932>>>>>>>        // but it has been constructed rather studidly as only constants and not variables
90932>>>>>>>        // are allowed...
90932>>>>>>>        If (sDriverID = MDSPgSQL) Begin
90934>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
90950>>>>>>>        End
90950>>>>>>>>
90950>>>>>>>        If (sDriverID = MDSMySQL) Begin
90952>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
90968>>>>>>>        End
90968>>>>>>>>
90968>>>>>>>        If (sDriverID = ORAFLEX) Begin
90970>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
90986>>>>>>>        End
90986>>>>>>>>
90986>>>>>>>        If (sDriverID = SQLFLEX) Begin
90988>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
91004>>>>>>>        End
91004>>>>>>>>
91004>>>>>>>
91004>>>>>>>        // This command is used to specify which database is used for embedded SQL statements.
91004>>>>>>>        SQL_USE_DATABASE sDatabase
91018>>>>>>>>
91018>>>>>>>        SET_DATABASE_NAME to sDatabase
91032>>>>>>>>
91032>>>>>>>
91032>>>>>>>        // Can't have this here because the property is defined for the cDbUpdateFunctionLibrary class,
91032>>>>>>>        // which object may or may not have been created at this point. So don't use the return
91032>>>>>>>        // value for this function!
91032>>>>>>>        //Get phoSQLManagerMT to hoSQLHandler
91032>>>>>>>
91032>>>>>>>        Function_Return hoSQLHandler
91033>>>>>>>    End_Function
91034>>>>>>>
91034>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
91036>>>>>>>        Boolean bOK bMertechDriver
91036>>>>>>>
91036>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
91037>>>>>>>
91037>>>>>>>        If (bOK = False) Begin
91039>>>>>>>            Get IsMertechDriver sDriverID to bOK
91040>>>>>>>        End
91040>>>>>>>>
91040>>>>>>>
91040>>>>>>>        If (bOK = False) Begin
91042>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
91043>>>>>>>            If (bMertechDriver = True) Begin
91045>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
91046>>>>>>>>
91046>>>>>>>            End
91046>>>>>>>>
91046>>>>>>>            Else Begin
91047>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
91048>>>>>>>>
91048>>>>>>>            End
91048>>>>>>>>
91048>>>>>>>            Function_Return False
91049>>>>>>>        End
91049>>>>>>>>
91049>>>>>>>
91049>>>>>>>        Function_Return True
91050>>>>>>>    End_Function
91051>>>>>>>
91051>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
91053>>>>>>>        Boolean bOK
91053>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
91054>>>>>>>        Function_Return bOK
91055>>>>>>>    End_Function
91056>>>>>>>
91056>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
91058>>>>>>>        Boolean bOK
91058>>>>>>>        Move False to bOK
91059>>>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
91060>>>>>>>        Function_Return bOK
91061>>>>>>>    End_Function
91062>>>>>>>
91062>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
91064>>>>>>>        Handle hoIniFile
91064>>>>>>>        String sConnect
91064>>>>>>>
91064>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
91065>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
91066>>>>>>>
91066>>>>>>>        Function_Return sConnect
91067>>>>>>>    End_Function
91068>>>>>>>
91068>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
91068>>>>>>>    // Pass a complete driver connection string
91068>>>>>>>    // Returns the following as a struct:
91068>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
91068>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
91068>>>>>>>    //
91068>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
91070>>>>>>>        tSQLConnection SQLConnection
91070>>>>>>>        tSQLConnection SQLConnection
91070>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
91070>>>>>>>        Boolean bTrusted bSilent bOK
91070>>>>>>>        Integer iPos
91070>>>>>>>
91070>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91071>>>>>>>        If (bOK = False) Begin
91073>>>>>>>            Function_Return SQLConnection
91074>>>>>>>        End
91074>>>>>>>>
91074>>>>>>>
91074>>>>>>>        Move False to bTrusted
91075>>>>>>>        Move False to bSilent
91076>>>>>>>
91076>>>>>>>        Case Begin
91076>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91078>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
91079>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
91080>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
91081>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
91082>>>>>>>                If (bTrusted = False) Begin
91084>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
91085>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
91086>>>>>>>                End
91086>>>>>>>>
91086>>>>>>>                Case Break
91087>>>>>>>
91087>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
91090>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
91091>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
91092>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
91093>>>>>>>                If (bTrusted = False) Begin
91095>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
91096>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
91097>>>>>>>                End
91097>>>>>>>>
91097>>>>>>>                Case Break
91098>>>>>>>
91098>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91101>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
91102>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
91103>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
91104>>>>>>>                Case Break
91105>>>>>>>
91105>>>>>>>            Case (sDriverID = SQLFLEX)
91108>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
91109>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
91110>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
91111>>>>>>>                If (bTrusted = False) Begin
91113>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
91114>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
91115>>>>>>>                End
91115>>>>>>>>
91115>>>>>>>                Case Break
91116>>>>>>>
91116>>>>>>>            Case (sDriverID = ORAFLEX)
91119>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
91120>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
91121>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
91123>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
91124>>>>>>>                End
91124>>>>>>>>
91124>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
91125>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
91126>>>>>>>                Case Break
91127>>>>>>>
91127>>>>>>>            Case (sDriverID = MDSPgSQL)
91130>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
91131>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
91132>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
91133>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
91134>>>>>>>                Case Break
91135>>>>>>>
91135>>>>>>>            Case (sDriverID = MDSMySQL)
91138>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
91139>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
91140>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
91141>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
91142>>>>>>>                Case Break
91143>>>>>>>
91143>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
91146>>>>>>>                Break
91147>>>>>>>        Case End
91147>>>>>>>
91147>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
91148>>>>>>>
91148>>>>>>>        // bSilent?
91148>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
91149>>>>>>>        If (iPos = 0) Begin
91151>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
91152>>>>>>>        End
91152>>>>>>>>
91152>>>>>>>        If (iPos = 0) Move "0"                                                  to sValue
91155>>>>>>>        Else Move (Mid(sConnectionString, 1, (iPos +1)))                        to sValue
91157>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
91158>>>>>>>
91158>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
91159>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
91160>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
91161>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
91162>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
91163>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
91164>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
91165>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
91166>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
91167>>>>>>>
91167>>>>>>>        Function_Return SQLConnection
91168>>>>>>>    End_Function
91169>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
91169>>>>>>>>
91169>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
91171>>>>>>>>    Integer iStart iEnd
91171>>>>>>>>    String sRetval
91171>>>>>>>>
91171>>>>>>>>    Move (Trim(sConnect)) to sConnect
91172>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
91173>>>>>>>>    If (iStart = 0) Begin
91175>>>>>>>>        Function_Return ""
91176>>>>>>>>    End
91176>>>>>>>>>
91176>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
91177>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
91178>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
91180>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
91181>>>>>>>>    End
91181>>>>>>>>>
91181>>>>>>>>    Else Begin
91182>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
91183>>>>>>>>    End
91183>>>>>>>>>
91183>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
91185>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
91186>>>>>>>>        Decrement iEnd
91187>>>>>>>>    End
91187>>>>>>>>>
91187>>>>>>>>    If (iEnd <> 0) Begin
91189>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
91190>>>>>>>>    End
91190>>>>>>>>>
91190>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
91191>>>>>>>>
91191>>>>>>>>    Function_Return (Trim(sRetval))
91192>>>>>>>>End_Function
91193>>>>>>>>
91193>>>>>>>>
91193>>>>>>>
91193>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
91193>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
91195>>>>>>>        Handle ho
91195>>>>>>>        Integer iRetval iIndex
91195>>>>>>>        Boolean bRetval bOK
91195>>>>>>>        tSQLConnection SQLConnection
91195>>>>>>>        tSQLConnection SQLConnection
91195>>>>>>>
91195>>>>>>>        Get pSQLConnection to SQLConnection
91196>>>>>>>        Get phoSQLConnectionIniFile to ho
91197>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
91198>>>>>>>        If (iIndex = -1) Begin
91200>>>>>>>            Function_Return False
91201>>>>>>>        End
91201>>>>>>>>
91201>>>>>>>
91201>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
91202>>>>>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
91203>>>>>>>        If (ghoConnection > 0) Begin
91205>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
91206>>>>>>>            If (iIndex <> -1) Begin
91208>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
91209>>>>>>>            End
91209>>>>>>>>
91209>>>>>>>        End
91209>>>>>>>>
91209>>>>>>>
91209>>>>>>>        Function_Return bRetval
91210>>>>>>>    End_Function
91211>>>>>>>
91211>>>>>>>End_Class
91212>>>>>Use vWin32fh.pkg
91212>>>>>
91212>>>>>//
91212>>>>>Class cDbUpdateFunctionLibrary is a cObject
91213>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
91214>>>>>>
91214>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
91216>>>>>>    Integer iStart iEnd
91216>>>>>>    String sRetval
91216>>>>>>
91216>>>>>>    Move (Trim(sConnect)) to sConnect
91217>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
91218>>>>>>    If (iStart = 0) Begin
91220>>>>>>        Function_Return ""
91221>>>>>>    End
91221>>>>>>>
91221>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
91222>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
91223>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
91225>>>>>>        Move (Pos(",", sRetval))          to iEnd
91226>>>>>>    End
91226>>>>>>>
91226>>>>>>    Else Begin
91227>>>>>>        Move (Pos(";", sRetval))          to iEnd
91228>>>>>>    End
91228>>>>>>>
91228>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
91230>>>>>>        Move (Pos(",", sRetval))          to iEnd
91231>>>>>>        Decrement iEnd
91232>>>>>>    End
91232>>>>>>>
91232>>>>>>    If (iEnd <> 0) Begin
91234>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
91235>>>>>>    End
91235>>>>>>>
91235>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
91236>>>>>>
91236>>>>>>    Function_Return (Trim(sRetval))
91237>>>>>>End_Function
91238>>>>>>
91238>>>>>>
91238>>>>>
91238>>>>>    Procedure Construct_Object
91240>>>>>        Handle ho
91240>>>>>        Forward Send Construct_Object
91242>>>>>
91242>>>>>        Move Self to ghoDbUpdateFunctionLibrary
91243>>>>>
91243>>>>>        Send CreateDbUpdateLibraryProperties
91244>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
91244>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
91244>>>>>        // etc settings.
91244>>>>>        If (ghoSQLConnectionHandler = 0) Begin
91246>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
91247>>>>>            Set phoSQLConnectionHandler to ho
91248>>>>>        End
91248>>>>>>
91248>>>>>
91248>>>>>    End_Procedure
91249>>>>>
91249>>>>>    Procedure End_Construct_Object
91251>>>>>        Forward Send End_Construct_Object
91253>>>>>    End_Procedure
91254>>>>>
91254>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
91254>>>>>    //
91254>>>>>
91254>>>>>    // Function for creating a new *Database*.
91254>>>>>    // Note: This is for creating SQL DATABASES - not tables!
91254>>>>>    // Returns True if successful.
91254>>>>>    // ToDo: Only works for MS-SQL...
91254>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
91256>>>>>        String sSQL sSQL1 sConnectionID sConnectionString sCreateDatabaseKeyWord sSelectFromWhereName
91256>>>>>        Handle hConnection hStmt hoSQLManager
91256>>>>>        Integer iFetchResult iDbType
91256>>>>>        Boolean bOK bMertechDriver
91256>>>>>
91256>>>>>        Get piDbType to iDbType
91257>>>>>        If (iDbType <> EN_DbTypeMSSQL) Begin
91259>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL"
91260>>>>>>
91260>>>>>            Function_Return False
91261>>>>>        End
91261>>>>>>
91261>>>>>
91261>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91262>>>>>        If (bMertechDriver = False) Begin
91264>>>>>            Get phoSQLManager to hoSQLManager
91265>>>>>        End
91265>>>>>>
91265>>>>>        Else Begin
91266>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
91267>>>>>        End
91267>>>>>>
91267>>>>>
91267>>>>>        Get psConnectionID     to sConnectionID
91268>>>>>        Get psConnectionString to sConnectionString
91269>>>>>        Move 0 to LastErr
91270>>>>>
91270>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91271>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
91272>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91273>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91275>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
91276>>>>>>
91276>>>>>            Function_Return False
91277>>>>>        End
91277>>>>>>
91277>>>>>
91277>>>>>        Get SqlOpen of hConnection to hStmt
91278>>>>>
91278>>>>>        If (hStmt = 0) Begin
91280>>>>>            Send SqlDisconnect of hoSQLManager
91281>>>>>            Error DFERR_PROGRAM CS_SQLConnectError
91282>>>>>>
91282>>>>>            Function_Return False
91283>>>>>        End
91283>>>>>>
91283>>>>>
91283>>>>>        Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
91284>>>>>        Get _SqlSelectFromWhereName to sSelectFromWhereName
91285>>>>>        Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
91286>>>>>
91286>>>>>        // Check if database exists
91286>>>>>        Send SqlExecDirect of hStmt sSQL
91287>>>>>        Get SqlFetch of hStmt to iFetchResult
91288>>>>>        Send SqlClose of hStmt
91289>>>>>        Send SqlDisconnect of hConnection
91290>>>>>
91290>>>>>        // If database already exists we're out of here!
91290>>>>>        // Note that we return True as this is not an error.
91290>>>>>        If (iFetchResult > 0) Begin
91292>>>>>            Function_Return True
91293>>>>>        End
91293>>>>>>
91293>>>>>
91293>>>>>        // Database doesn't exist, create it.
91293>>>>>        If (iFetchResult = 0) Begin
91295>>>>>            Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
91296>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
91297>>>>>
91297>>>>>            Send SqlUtilExecuteQuery sSQL1 sDriverID
91298>>>>>
91298>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
91299>>>>>            If (LastErr = CLIERR_GENERAL_ERROR) Begin
91301>>>>>               Function_Return False
91302>>>>>            End
91302>>>>>>
91302>>>>>
91302>>>>>            // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
91302>>>>>            Sleep 1
91303>>>>>            Send SqlUtilExecuteQuery sSQL sDriverID
91304>>>>>        End
91304>>>>>>
91304>>>>>
91304>>>>>        // If used in e.g. the cDbUpdteHandler we want to change the login database name to
91304>>>>>        // the one we just created.
91304>>>>>        If (bUpdateConnectionString = True) Begin
91306>>>>>            Set psDatabase to sDatabase
91307>>>>>            //...and perhaps also the SQLConnections.ini file setting.
91307>>>>>            If (bPermanantly = True) Begin
91309>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
91311>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
91312>>>>>                End
91312>>>>>>
91312>>>>>            End
91312>>>>>>
91312>>>>>        End
91312>>>>>>
91312>>>>>
91312>>>>>        Function_Return (Err = False)
91313>>>>>    End_Function
91314>>>>>
91314>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
91314>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
91314>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
91314>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
91314>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
91314>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
91316>>>>>        Handle hToTable
91316>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bCopyData
91316>>>>>        String sDriverID sPhysicalName sRootName sDisplayName sEmpty sConnectionID sConnectionString
91316>>>>>        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase
91316>>>>>        tSQLConnection SQLConnection
91316>>>>>        tSQLConnection SQLConnection
91316>>>>>        Integer iPos iMaxRecords
91316>>>>>
91316>>>>>        Get psDriverID to sDriverID
91317>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
91318>>>>>        If (bExists = False) Begin
91320>>>>>            Function_Return False
91321>>>>>        End
91321>>>>>>
91321>>>>>
91321>>>>>        If (num_arguments > 1) Begin
91323>>>>>            Move bCpyDat to bCopyData
91324>>>>>        End
91324>>>>>>
91324>>>>>        Else Begin
91325>>>>>            Move False to bCopyData
91326>>>>>        End
91326>>>>>>
91326>>>>>
91326>>>>>        Open hTable
91328>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91331>>>>>        If (bOpened = False) Begin
91333>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
91334>>>>>>
91334>>>>>            Function_Return False
91335>>>>>        End
91335>>>>>>
91335>>>>>        Move 0 to hToTable
91336>>>>>
91336>>>>>        Move 16711679 to iMaxRecords
91337>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91340>>>>>        Move (Pos(".", sDisplayName)) to iPos
91341>>>>>        If (iPos > 0) Begin
91343>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
91344>>>>>        End
91344>>>>>>
91344>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
91347>>>>>        Get _TableNameOnly sRootName                 to sRootName
91348>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
91349>>>>>
91349>>>>>        If (ghoProgressBar <> 0) Begin
91351>>>>>            Send DoAdvance of ghoProgressBar
91352>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
91353>>>>>        End
91353>>>>>>
91353>>>>>
91353>>>>>        Move False to Err
91354>>>>>
91354>>>>>        Structure_Start hToTable DATAFLEX_ID
91355>>>>>            Structure_Copy hTable to hToTable
91356>>>>>
91356>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
91359>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
91362>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
91365>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
91368>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
91371>>>>>
91371>>>>>        Structure_End hToTable
91373>>>>>
91373>>>>>        Move (not(Err)) to bOK
91374>>>>>        If (bOK = True and bCopyData = True) Begin
91376>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
91377>>>>>        End
91377>>>>>>
91377>>>>>
91377>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91378>>>>>        If (bMertechDriver = True) Begin
91380>>>>>            Open hTable
91382>>>>>        End
91382>>>>>>
91382>>>>>
91382>>>>>        // This must be after copying data...
91382>>>>>        If (Err = False) Begin
91384>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
91387>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91390>>>>>        End
91390>>>>>>
91390>>>>>        Move (not(Err)) to bOK
91391>>>>>
91391>>>>>        Function_Return (bOK = True)
91392>>>>>    End_Function
91393>>>>>
91393>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
91393>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
91393>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
91395>>>>>        String sTableName sSQLString sPath sVal sCreateTable sDriverID
91395>>>>>        Integer iRetval iDbType
91395>>>>>        Boolean bExists bOK
91395>>>>>
91395>>>>>        Get psDriverID to sDriverID
91396>>>>>        Get UtilTableHandleToString hTable to sTableName
91397>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
91398>>>>>        If (bExists = True) Begin
91400>>>>>            Function_Return False
91401>>>>>        End
91401>>>>>>
91401>>>>>
91401>>>>>        Get psDataPathFirstPart to sPath
91402>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
91403>>>>>
91403>>>>>        Get piDbType to iDbType
91404>>>>>        Get _SqlProperTableName sTableName to sTableName
91405>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
91406>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
91407>>>>>
91407>>>>>        Move False to Err
91408>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91409>>>>>
91409>>>>>        Function_Return (Err = False)
91410>>>>>    End_Function
91411>>>>>
91411>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
91411>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
91411>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
91413>>>>>        String sSQLString sPath sVal sCreateTable sDriverID
91413>>>>>        Integer iRetval iDbType
91413>>>>>        Boolean bExists bOK
91413>>>>>
91413>>>>>        Get psDriverID to sDriverID
91414>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
91415>>>>>        If (bExists = True) Begin
91417>>>>>            Function_Return False
91418>>>>>        End
91418>>>>>>
91418>>>>>
91418>>>>>        Get psDataPathFirstPart to sPath
91419>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
91420>>>>>        If (bExists = True) Begin
91422>>>>>            // ToDo: What should we do if an .int file already exists?
91422>>>>>        End
91422>>>>>>
91422>>>>>
91422>>>>>        Get piDbType to iDbType
91423>>>>>        Get _SqlProperTableName sTableName to sTableName
91424>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
91425>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
91426>>>>>
91426>>>>>        Move False to Err
91427>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91428>>>>>
91428>>>>>        Function_Return (Err = False)
91429>>>>>    End_Function
91430>>>>>
91430>>>>>    // First deletes the data cache file and then drops the passed SQL table.
91430>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
91430>>>>>    //       else try using the SqlTableRemoveByTableName message.
91430>>>>>    Function SqlTableRemove Integer hTable Returns Boolean
91432>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
91432>>>>>        Integer iRetval iDbType
91432>>>>>        Boolean bExists bMertechDriver bOK
91432>>>>>
91432>>>>>        Get psDriverID to sDriverID
91433>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91434>>>>>        Get UtilTableHandleToString hTable to sTableName
91435>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
91436>>>>>        If (bExists = False) Begin
91438>>>>>            Function_Return False
91439>>>>>        End
91439>>>>>>
91439>>>>>
91439>>>>>        Get psDataPathFirstPart to sPath
91440>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
91441>>>>>
91441>>>>>        Get piDbType to iDbType
91442>>>>>        Get _SqlProperTableName sTableName to sTableName
91443>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
91444>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
91445>>>>>
91445>>>>>        Move False to Err
91446>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91447>>>>>
91447>>>>>        // We also need to remove the cache-file since the table has been changed
91447>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91448>>>>>
91448>>>>>        Function_Return (Err = False)
91449>>>>>    End_Function
91450>>>>>
91450>>>>>    // First deletes the data cache file and then drops the passed data table.
91450>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
91452>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
91452>>>>>        Integer iRetval iDbType
91452>>>>>        Boolean bMertechDriver bOK
91452>>>>>
91452>>>>>        Get psDriverID to sDriverID
91453>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91454>>>>>        Get psDataPathFirstPart to sPath
91455>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
91456>>>>>
91456>>>>>        Get piDbType to iDbType
91457>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
91458>>>>>        Get psSchema to sSchema
91459>>>>>        If (sSchema = "") Begin
91461>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91462>>>>>        End
91462>>>>>>
91462>>>>>        Move (Uppercase(sTableName)) to sVal
91463>>>>>        If (not(sVal contains (sSchema + "."))) Begin
91465>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
91466>>>>>        End
91466>>>>>>
91466>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
91467>>>>>
91467>>>>>        Move False to Err
91468>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91469>>>>>
91469>>>>>        // We also need to remove the cache-file since the table has been changed
91469>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91470>>>>>
91470>>>>>        Function_Return (Err = False)
91471>>>>>    End_Function
91472>>>>>
91472>>>>>    // *** Sql View Messages ***
91472>>>>>
91472>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
91472>>>>>    Function SqlViewRemove String sDataView Returns Boolean
91474>>>>>        String sDriverID sSQLString sPath sDropViewKeyWord
91474>>>>>        Integer iRetval
91474>>>>>        Boolean bMertechDriver bOK
91474>>>>>
91474>>>>>        Get psDriverID to sDriverID
91475>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91476>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
91477>>>>>
91477>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
91478>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
91479>>>>>        Set psSQLStatementString to sSQLString
91480>>>>>
91480>>>>>        // As we don't check if the view exist or not, it might happen
91480>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
91480>>>>>        Move False to Err
91481>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91482>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91483>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91484>>>>>        Move 0 to LastErr
91485>>>>>
91485>>>>>        // We also need to remove the cache-file since the table has been changed
91485>>>>>        Get UtilDeleteCacheFile sDataView to bOK
91486>>>>>
91486>>>>>        Function_Return (Err = False)
91487>>>>>    End_Function
91488>>>>>
91488>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
91490>>>>>        Boolean bOK
91490>>>>>        Integer iDbType 
91490>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
91490>>>>>        
91490>>>>>        Get psDriverID to sDriverID
91491>>>>>        Get piDbType   to iDbType
91492>>>>>        
91492>>>>>        Case Begin
91492>>>>>            Case (iDbType = EN_DbTypeDB2)
91494>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91495>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91496>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
91497>>>>>            Break
91498>>>>>
91498>>>>>            Case (iDbType = EN_DbTypeMSSQL)
91501>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91502>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91503>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - sNewtTableName - "'") to sSQLString
91504>>>>>            Break
91505>>>>>
91505>>>>>            Case (iDbType = EN_DbTypeOracle)
91508>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91509>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91510>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
91511>>>>>            Break
91512>>>>>
91512>>>>>            Case (iDbType = EN_DbTypePostgre)
91515>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
91516>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91517>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91518>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * sNewtTableName) to sSQLString
91519>>>>>            Break
91520>>>>>
91520>>>>>            Case (iDbType = EN_DbTypeMySQL)
91523>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
91524>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
91525>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * sNewtTableName) to sSQLString
91526>>>>>            Break
91527>>>>>        Case End   
91527>>>>>        
91527>>>>>        Move False to Err
91528>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
91529>>>>>        Move (Err = False) to bOK
91530>>>>>        
91530>>>>>        Function_Return bOK
91531>>>>>    End_Function
91532>>>>>    
91532>>>>>     // *** Sql Column Messages ***
91532>>>>>    //
91532>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
91532>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
91534>>>>>        Integer iColumn iDbType iLength iDecimals
91534>>>>>        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
91534>>>>>        String sTableName sDriverID sUpdate sSet sNoCountOn
91534>>>>>        Boolean bExists bOK bInitializeValue
91534>>>>>
91534>>>>>        Get psDriverID to sDriverID
91535>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91536>>>>>        If (bOK = False) Begin
91538>>>>>            Function_Return False
91539>>>>>        End
91539>>>>>>
91539>>>>>
91539>>>>>        Get UtilTableHandleToString hTable to sTableName
91540>>>>>        If (sTableName = "") Begin
91542>>>>>            Function_Return False
91543>>>>>        End
91543>>>>>>
91543>>>>>
91543>>>>>        If (num_arguments > 3) Begin
91545>>>>>            Move iLen     to iLength
91546>>>>>            Move iDec     to iDecimals
91547>>>>>            Move bInitVal to bInitializeValue
91548>>>>>            Move sColVal  to sColumnValue
91549>>>>>        End
91549>>>>>>
91549>>>>>
91549>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
91550>>>>>
91550>>>>>        Function_Return (bOK = True)
91551>>>>>    End_Function
91552>>>>>
91552>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
91552>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
91554>>>>>        Integer iColumn iDbType iLength iDecimals iDriver
91554>>>>>        String sStmt sAlterTable sAddColumn sModifyColumn sVal sDataType sLengthAndDecimals sColumnValue
91554>>>>>        String sDriverID sUpdate sSet sNoCountOn sNotNull
91554>>>>>        Boolean bExists bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
91554>>>>>        Handle hTable
91554>>>>>
91554>>>>>        Get psDriverID to sDriverID
91555>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91556>>>>>        If (bOK = False) Begin
91558>>>>>            Function_Return False
91559>>>>>        End
91559>>>>>>
91559>>>>>
91559>>>>>        Get UtilTableNameToHandle sTableName to hTable
91560>>>>>        If (hTable = 0) Begin
91562>>>>>            Get NextFreeFilelistSlot to hTable
91563>>>>>        End 
91563>>>>>>
91563>>>>>
91563>>>>>        Get piDbType to iDbType
91564>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
91564>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
91565>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
91567>>>>>            Function_Return False
91568>>>>>        End
91568>>>>>>
91568>>>>>
91568>>>>>        Get DriverIndex sDriverID to iDriver
91569>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91572>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
91575>>>>>
91575>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
91576>>>>>        If (num_arguments > 3) Begin
91578>>>>>            Move iLen     to iLength
91579>>>>>            Move iDec     to iDecimals
91580>>>>>            Move bInitVal to bInitializeValue
91581>>>>>            Move sColVal  to sColumnValue
91582>>>>>        End
91582>>>>>>
91582>>>>>
91582>>>>>        Get _SqlProperTableName sTableName   to sTableName
91583>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
91584>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
91585>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
91586>>>>>
91586>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
91587>>>>>        If (bFixed = False) Begin
91589>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
91590>>>>>        End
91590>>>>>>
91590>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
91591>>>>>
91591>>>>>        Move False to Err
91592>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91593>>>>>
91593>>>>>        If (bInitializeValue = True and Err = False) Begin
91595>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
91596>>>>>        End
91596>>>>>>
91596>>>>>
91596>>>>>        If (Err = False) Begin
91598>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
91599>>>>>        End
91599>>>>>>
91599>>>>>
91599>>>>>        Move (not(Err)) to bRetval
91600>>>>>
91600>>>>>        // We also need to remove the cache-file since the table has been changed
91600>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91601>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91604>>>>>
91604>>>>>        Function_Return bRetval
91605>>>>>    End_Function
91606>>>>>    
91606>>>>>    // To update all current rows for a table column with a common value.
91606>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
91608>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sStmt
91608>>>>>        Boolean bRetval bSQLDriver 
91608>>>>>        Integer iCurrErr
91608>>>>>        
91608>>>>>        Move False to bRetval
91609>>>>>        Get psDriverID to sDriverID
91610>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91611>>>>>        If (bSQLDriver = False) Begin
91613>>>>>            Function_Return bRetval
91614>>>>>        End
91614>>>>>>
91614>>>>>        Get UtilTableHandleToString hTable to sTableName
91615>>>>>        
91615>>>>>        Move Err to iCurrErr
91616>>>>>        Move False to Err
91617>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
91618>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
91619>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
91620>>>>>        Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
91621>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91622>>>>>        Move (Err = False) to bRetval
91623>>>>>        Move iCurrErr to Err
91624>>>>>        
91624>>>>>        Function_Return bRetval
91625>>>>>    End_Function
91626>>>>>
91626>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
91626>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
91626>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
91628>>>>>        Integer iColumn iDbType iLength iDecimals
91628>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sTableName sNotNull
91628>>>>>        Boolean bExists bOK bFixed
91628>>>>>
91628>>>>>        Get psDriverID to sDriverID
91629>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91630>>>>>        If (bOK = False) Begin
91632>>>>>            Function_Return False
91633>>>>>        End
91633>>>>>>
91633>>>>>
91633>>>>>        Get UtilTableHandleToString hTable to sTableName
91634>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
91635>>>>>
91635>>>>>        Function_Return (Err = False)
91636>>>>>    End_Function
91637>>>>>
91637>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
91637>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
91637>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
91637>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
91639>>>>>        Integer iColumn iDbType iLength iDecimals
91639>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sVal sDataType sRetval sLengthAndDecimals sNotNull
91639>>>>>        Boolean bExists bOK bFixed
91639>>>>>        Handle hTable
91639>>>>>
91639>>>>>        Get psDriverID to sDriverID
91640>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91641>>>>>        If (bOK = False) Begin
91643>>>>>            Function_Return False
91644>>>>>        End
91644>>>>>>
91644>>>>>
91644>>>>>        Get UtilTableNameToHandle sTableName to hTable
91645>>>>>        If (hTable = 0) Begin
91647>>>>>            Get NextFreeFilelistSlot to hTable
91648>>>>>        End
91648>>>>>>
91648>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
91649>>>>>        If (bExists = True) Begin
91651>>>>>            Function_Return False
91652>>>>>        End
91652>>>>>>
91652>>>>>
91652>>>>>        If (num_arguments > 3) Begin
91654>>>>>            Move iLen to iLength
91655>>>>>        End
91655>>>>>>
91655>>>>>        If (num_arguments > 4) Begin
91657>>>>>            Move iDec to iDecimals
91658>>>>>        End
91658>>>>>>
91658>>>>>
91658>>>>>        Get piDbType to iDbType
91659>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
91660>>>>>
91660>>>>>        Move False to Err
91661>>>>>        Get _SqlProperTableName sTableName    to sTableName
91662>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
91663>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
91664>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
91665>>>>>
91665>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
91666>>>>>        If (bFixed = False) Begin
91668>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
91669>>>>>        End
91669>>>>>>
91669>>>>>
91669>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
91670>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91671>>>>>
91671>>>>>        // We also need to remove the cache-file since the table has been changed
91671>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91672>>>>>
91672>>>>>        Function_Return (Err = False)
91673>>>>>    End_Function
91674>>>>>
91674>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
91676>>>>>        Boolean bOK bErr bIsSQLDriver
91676>>>>>        String sDriverID
91676>>>>>
91676>>>>>        Get psDriverID to sDriverID
91677>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
91678>>>>>        If (bIsSQLDriver = False) Begin
91680>>>>>            Function_Return False
91681>>>>>        End
91681>>>>>>
91681>>>>>
91681>>>>>        Move Err to bErr
91682>>>>>        Move False to bErr
91683>>>>>
91683>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
91683>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
91683>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
91684>>>>>
91684>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
91687>>>>>        Move (not(Err)) to bOK
91688>>>>>        Move bErr to Err
91689>>>>>
91689>>>>>        Function_Return bOK
91690>>>>>    End_Function
91691>>>>>
91691>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
91693>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
91693>>>>>        String sDriverID
91693>>>>>
91693>>>>>        Get psDriverID to sDriverID
91694>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
91695>>>>>        If (bIsSQLDriver = False) Begin
91697>>>>>            Function_Return False
91698>>>>>        End
91698>>>>>>
91698>>>>>
91698>>>>>        Move Err to bErr
91699>>>>>        Move False to bErr
91700>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
91703>>>>>        If (bNullable = bCurrentState) Begin
91705>>>>>            Function_Return True
91706>>>>>        End
91706>>>>>>
91706>>>>>
91706>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91709>>>>>        If (bOpen = False) Begin
91711>>>>>            Get AutoConnectionIDLogin to bOK
91712>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91713>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
91714>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
91715>>>>>            Open hTable
91717>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91718>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
91719>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
91720>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91723>>>>>        End
91723>>>>>>
91723>>>>>        If (bOpen = True) Begin
91725>>>>>            Structure_Start hTable sDriverID
91726>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
91729>>>>>            Structure_End hTable
91731>>>>>        End
91731>>>>>>
91731>>>>>
91731>>>>>        Move (not(Err)) to bOK
91732>>>>>        Move bErr to Err
91733>>>>>
91733>>>>>        Function_Return bOK
91734>>>>>    End_Function
91735>>>>>
91735>>>>>    // Drop column by its table handle
91735>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
91737>>>>>        Integer iColumn idbType
91737>>>>>        String sDriverID sStmt sAlterTable sDropColumn sVal sTableName
91737>>>>>        Boolean bExists bOK
91737>>>>>
91737>>>>>        Get psDriverID to sDriverID
91738>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91739>>>>>        If (bOK = False) Begin
91741>>>>>            Function_Return False
91742>>>>>        End
91742>>>>>>
91742>>>>>
91742>>>>>        Get UtilTableHandleToString hTable to sTableName
91743>>>>>        If (sTableName = "") Begin
91745>>>>>            Function_Return False
91746>>>>>        End
91746>>>>>>
91746>>>>>
91746>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
91747>>>>>
91747>>>>>        Function_Return (bOK = True)
91748>>>>>    End_Function
91749>>>>>
91749>>>>>    // Drop column by its table name as a string.
91749>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
91751>>>>>        Integer iColumn iDbType iDriver
91751>>>>>        String sDriverID sStmt sAlterTable sDropColumn sVal
91751>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
91751>>>>>        Handle hTable
91751>>>>>
91751>>>>>        Get psDriverID to sDriverID
91752>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91753>>>>>        If (bOK = False) Begin
91755>>>>>            Function_Return False
91756>>>>>        End
91756>>>>>>
91756>>>>>
91756>>>>>        Get DriverIndex sDriverID to iDriver
91757>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91760>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
91763>>>>>
91763>>>>>        Get UtilTableNameToHandle sTableName to hTable
91764>>>>>        If (hTable <> 0) Begin
91766>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
91767>>>>>            If (bExists = False) Begin
91769>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91772>>>>>                Function_Return False
91773>>>>>            End
91773>>>>>>
91773>>>>>        End
91773>>>>>>
91773>>>>>
91773>>>>>        Get piDbType to iDbType
91774>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
91776>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
91777>>>>>            Get UtilDeleteCacheFile sTableName to bOK
91778>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91781>>>>>            Function_Return bOK
91782>>>>>        End
91782>>>>>>
91782>>>>>
91782>>>>>        Move False to Err
91783>>>>>        Get _SqlProperTableName sTableName    to sTableName
91784>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
91785>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
91786>>>>>
91786>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
91787>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91788>>>>>        Move (not(Err)) to bRetval
91789>>>>>
91789>>>>>        // We also need to remove the cache-file since the table has been changed
91789>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91790>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
91793>>>>>
91793>>>>>        Function_Return bRetval
91794>>>>>    End_Function
91795>>>>>
91795>>>>>    // Rename a field/column by table handle (filelist number)
91795>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
91797>>>>>        Integer iColumn idbType
91797>>>>>        String sDriverID sTableName sStmt sAlterTable sRenameColumn sVal sColumnKeyWord
91797>>>>>        Boolean bExists bOK
91797>>>>>
91797>>>>>        Get psDriverID to sDriverID
91798>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91799>>>>>        If (bOK = False) Begin
91801>>>>>            Function_Return False
91802>>>>>        End
91802>>>>>>
91802>>>>>
91802>>>>>        Get UtilTableHandleToString hTable to sTableName
91803>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
91804>>>>>
91804>>>>>        Function_Return (Err = False)
91805>>>>>    End_Function
91806>>>>>
91806>>>>>    // Rename a field/column by table name.
91806>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
91808>>>>>        Integer iColumn iDbType iDataType
91808>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
91808>>>>>        Boolean bExists bOK bRetval
91808>>>>>        Handle hTable
91808>>>>>
91808>>>>>        Move sTableName to sOrgTableName
91809>>>>>        Get psDriverID to sDriverID
91810>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91811>>>>>        If (bOK = False) Begin
91813>>>>>            Function_Return False
91814>>>>>        End
91814>>>>>>
91814>>>>>
91814>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
91815>>>>>        If (sVal = "") Begin
91817>>>>>            Function_Return False
91818>>>>>        End
91818>>>>>>
91818>>>>>
91818>>>>>        Get piDbType to iDbType
91819>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
91820>>>>>        Get _SqlProperTableName sTableName     to sTableName
91821>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
91822>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
91823>>>>>
91823>>>>>        Case Begin
91823>>>>>            Case (iDbType = EN_dbTypeMSSQL)
91825>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
91826>>>>>                Case Break
91827>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
91827>>>>>            Case (iDbType = EN_dbTypeOracle)
91830>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
91831>>>>>                Case Break
91832>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
91832>>>>>            Case (iDbType = EN_dbTypeDB2)
91835>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
91836>>>>>                Case Break
91837>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
91837>>>>>            Case (iDbType = EN_dbTypePostgre)
91840>>>>>                Move sOrgTableName to sTableName
91841>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
91842>>>>>                Case Break
91843>>>>>            Case (iDbType = EN_dbTypeMySQL)
91846>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
91846>>>>>                Move sOrgTableName to sTableName
91847>>>>>                Get psDatabase to sDatabase
91848>>>>>                Get UtilTableNameToHandle sTableName to hTable
91849>>>>>                If (hTable = 0) Begin
91851>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
91852>>>>>                    If (bOK = False) Begin
91854>>>>>                        Function_Return False
91855>>>>>                    End
91855>>>>>>
91855>>>>>                    Get NextFreeFilelistSlot to hTable
91856>>>>>                End
91856>>>>>>
91856>>>>>                Else Begin
91857>>>>>                    Open hTable
91859>>>>>                End
91859>>>>>>
91859>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
91860>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
91861>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
91862>>>>>                Case Break
91863>>>>>            Case Else
91863>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
91864>>>>>        Case End
91864>>>>>
91864>>>>>        Move False to Err
91865>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91866>>>>>        Move (Err = False) to bRetval
91867>>>>>        // We also need to remove the cache-file since the table has been changed
91867>>>>>        Get UtilDeleteCacheFile sTableName to bOK
91868>>>>>
91868>>>>>        Function_Return bRetval
91869>>>>>    End_Function
91870>>>>>
91870>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
91872>>>>>        Handle hoSQLHandler hSQLConnect hStmt
91872>>>>>        Boolean bMertechDriver
91872>>>>>        Integer iNumCols iCount iSQLType iDataType
91872>>>>>        String sValue
91872>>>>>
91872>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91873>>>>>        If (bMertechDriver = False) Begin
91875>>>>>            Get phoSQLManager to hoSQLHandler
91876>>>>>        End
91876>>>>>>
91876>>>>>        Else Begin
91877>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
91878>>>>>        End
91878>>>>>>
91878>>>>>
91878>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
91879>>>>>        If (hSQLConnect <> 0) Begin
91881>>>>>            Get SQLOpen of hSQLConnect to hStmt
91882>>>>>            If (hStmt <> 0) Begin
91884>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
91885>>>>>
91885>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
91886>>>>>                For iCount from 1 to iNumCols
91892>>>>>>
91892>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
91893>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
91895>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
91896>>>>>                        Move iNumCols to iCount // We're out of here
91897>>>>>                    End
91897>>>>>>
91897>>>>>                Loop
91898>>>>>>
91898>>>>>
91898>>>>>                Send SQLClose of hStmt
91899>>>>>            End
91899>>>>>>
91899>>>>>            Send SQLDisconnect of hSQLConnect
91900>>>>>        End
91900>>>>>>
91900>>>>>
91900>>>>>        Function_Return iDataType
91901>>>>>    End_Function
91902>>>>>
91902>>>>>
91902>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
91902>>>>>    // the DbUpdateVersion database revision in.
91902>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
91902>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
91902>>>>>    Function SqlCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
91904>>>>>        Boolean bOK bOpened
91904>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt sDropColumn
91904>>>>>
91904>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
91907>>>>>        Get _TableNameOnly sTableName to sTableName
91908>>>>>        If (sTableName = "") Begin
91910>>>>>            Function_Return False
91911>>>>>        End
91911>>>>>>
91911>>>>>
91911>>>>>        // This just creates the table and a "dummy" column.
91911>>>>>        Get SqlTableCreate hTable sDriverID to bOK
91912>>>>>        If (bOK = False) Begin
91914>>>>>            Function_Return False
91915>>>>>        End
91915>>>>>>
91915>>>>>
91915>>>>>        Close hTable
91916>>>>>        Move False to Err
91917>>>>>
91917>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
91918>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
91919>>>>>        Move "Decimal" to sDataType
91920>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
91921>>>>>
91921>>>>>        // Adds the "sColumnName" passed to the function
91921>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
91922>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
91923>>>>>
91923>>>>>        // Now we can delete the dummy column:
91923>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
91924>>>>>
91924>>>>>        // Finally, we attach to the newly created table.
91924>>>>>        If (Err = False) Begin
91926>>>>>            Get ApiTableAttachToSQL hTable True to bOK
91927>>>>>        End
91927>>>>>>
91927>>>>>        Open hTable
91929>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91932>>>>>
91932>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
91933>>>>>    End_Function
91934>>>>>
91934>>>>>    // Checks if a column/field name exists in a SQL table definition
91934>>>>>    // Returns True if it does
91934>>>>>    // Sample:
91934>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
91934>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
91936>>>>>        Integer iNumColumns iColumn
91936>>>>>        String sColumn sDriverID
91936>>>>>        String[] sColumnsArray
91937>>>>>        Boolean bExists bOK
91937>>>>>
91937>>>>>        Move False to bExists
91938>>>>>        Get AutoConnectionIDLogin to bOK
91939>>>>>        Get psDriverID to sDriverID
91940>>>>>
91940>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
91941>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
91942>>>>>        Decrement iNumColumns
91943>>>>>        For iColumn from 0 to iNumColumns
91949>>>>>>
91949>>>>>            Move sColumnsArray[iColumn] to sColumn
91950>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
91952>>>>>                Move True to bExists
91953>>>>>                Move iNumColumns to iColumn // We're out of here
91954>>>>>            End
91954>>>>>>
91954>>>>>        Loop
91955>>>>>>
91955>>>>>
91955>>>>>        Function_Return bExists
91956>>>>>    End_Function
91957>>>>>
91957>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
91959>>>>>        Integer iNumColumns iColumn iDFType iNativeType
91959>>>>>        Boolean bOpened bOK
91959>>>>>        String sColumnName sNativeTypeName
91959>>>>>
91959>>>>>        Get AutoConnectionIDLogin to bOK
91960>>>>>        Get OpenTableExclusive hTable to bOK
91961>>>>>        If (bOK = False) Begin
91963>>>>>            Function_Return False
91964>>>>>        End
91964>>>>>>
91964>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91967>>>>>        If (bOpened = False) Begin
91969>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
91970>>>>>>
91970>>>>>            Function_Return False
91971>>>>>        End
91971>>>>>>
91971>>>>>
91971>>>>>        Move False to Err
91972>>>>>
91972>>>>>        Structure_Start hTable
91973>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91976>>>>>
91976>>>>>            For iColumn from 1 to iNumColumns
91982>>>>>>
91982>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
91985>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
91988>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
91991>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
91994>>>>>
91994>>>>>                Case Begin
91994>>>>>                    Case (iDFType = DF_DATE)
91996>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
91998>>>>>                            // Convert datetime to date
91998>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
92001>>>>>                        End
92001>>>>>>
92001>>>>>                        Case Break
92002>>>>>                    Case (iDFType = DF_DATETIME)
92005>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
92007>>>>>                            // Convert datetime to datetime2
92007>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
92010>>>>>                        End
92010>>>>>>
92010>>>>>                        Case Break
92011>>>>>                    Case (iDFType = DF_ASCII)
92014>>>>>                        If (iNativeType = SQL_CHAR) Begin
92016>>>>>                            // Convert char to varchar
92016>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
92019>>>>>                        End
92019>>>>>>
92019>>>>>                        Case Break
92020>>>>>                    Case (iDFType = DF_TEXT)
92023>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
92025>>>>>                            // Convert text to varchar(max)
92025>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
92028>>>>>                        End
92028>>>>>>
92028>>>>>                        Case Break
92029>>>>>                    Case (iDFType = DF_BINARY)
92032>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
92034>>>>>                            // Convert image to varbinary(max)
92034>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
92037>>>>>                        End
92037>>>>>>
92037>>>>>                        Case Break
92038>>>>>                Case End
92038>>>>>            Loop
92039>>>>>>
92039>>>>>        Structure_End hTable
92041>>>>>
92041>>>>>        Function_Return (Err = False)
92042>>>>>    End_Function
92043>>>>>
92043>>>>>    // Does three things with auxilirary files;
92043>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
92043>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
92043>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
92043>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
92045>>>>>        String sDataPath sDDSrcPath sVal sDriverID
92045>>>>>        Boolean bOK bExists bMertechDriver
92045>>>>>        Integer iCount iItems iCh iPos
92045>>>>>
92045>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
92045>>>>>        If (sTableName contains ".") Begin
92047>>>>>            Move (Pos(".", sTableName)) to iPos
92048>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
92049>>>>>        End
92049>>>>>>
92049>>>>>
92049>>>>>        Get psDriverID to sDriverID
92050>>>>>        Get psDataPathFirstPart to sDataPath
92051>>>>>        Get vFolderExists sDataPath to bOK
92052>>>>>        If (bOK = False) Begin
92054>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
92055>>>>>>
92055>>>>>            Function_Return False
92056>>>>>        End
92056>>>>>>
92056>>>>>
92056>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
92057>>>>>        // First delete the cache file:
92057>>>>>        Get UtilDeleteCacheFile sTableName to bOK
92058>>>>>
92058>>>>>        Get Seq_New_Channel to iCh
92059>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
92061>>>>>            Function_Return False
92062>>>>>        End
92062>>>>>>
92062>>>>>
92062>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
92063>>>>>        If (bExists = False) Begin
92065>>>>>            Function_Return False
92066>>>>>        End
92066>>>>>>
92066>>>>>
92066>>>>>        // Add the new column name to the .tag file:
92066>>>>>        Append_Output channel iCh (sDataPath + sTableName + ".tag")
92068>>>>>            Writeln channel iCh sColumnName
92071>>>>>        Close_Output
92072>>>>>
92072>>>>>        // If in development environment; output new .fd file:
92072>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
92073>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92074>>>>>        If (iCount > 1) Begin
92076>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
92077>>>>>        End
92077>>>>>>
92077>>>>>        Get vFolderExists sDDSrcPath to bExists
92078>>>>>        If (bExists = True) Begin
92080>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
92081>>>>>            Move False to Err
92082>>>>>            Get AutoConnectionIDLogin to bOK
92083>>>>>            If (hTable <> 0) Begin
92085>>>>>                Open hTable
92087>>>>>            End
92087>>>>>>
92087>>>>>            Else Begin
92088>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
92089>>>>>            End
92089>>>>>>
92089>>>>>
92089>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
92092>>>>>            If (bOK = True) Begin
92094>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
92096>>>>>            End
92096>>>>>>
92096>>>>>            If (Err = True) Begin
92098>>>>>                Move False to bOK
92099>>>>>            End
92099>>>>>>
92099>>>>>        End
92099>>>>>>
92099>>>>>
92099>>>>>        Function_Return (bOK = True)
92100>>>>>    End_Function
92101>>>>>
92101>>>>>    // The table must already exist in the filelist for this function to work.
92101>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
92101>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
92103>>>>>        Boolean bOK bExists bUseConnectionID bMertech
92103>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
92103>>>>>        String[] sIndexArray
92104>>>>>        Integer iCount iCh iSize
92104>>>>>
92104>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
92105>>>>>        Get psConnectionString to sConnectionString
92106>>>>>
92106>>>>>        Move CS_ANSI_Txt to sANSI_OEM
92107>>>>>        If (bANSI = False) Begin
92109>>>>>            Move CS_OEM_Txt to sANSI_OEM
92110>>>>>        End
92110>>>>>>
92110>>>>>
92110>>>>>        Get psDataPathFirstPart to sDataPath
92111>>>>>        Get vFolderExists sDataPath to bOK
92112>>>>>        If (bOK = False) Begin
92114>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
92115>>>>>>
92115>>>>>            Function_Return False
92116>>>>>        End
92116>>>>>>
92116>>>>>        Get vFolderFormat sDataPath to sDataPath
92117>>>>>
92117>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
92120>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
92123>>>>>        Get _TableNameOnly sRootName to sDatabaseName
92124>>>>>        Move sLogicalName  to sPhysicalFileName
92125>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
92126>>>>>
92126>>>>>        Get IsMertechDriver sDriverID to bMertech
92127>>>>>        If (bMertech = True) Begin
92129>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
92129>>>>>            // Else it will create an error in the error log (although it won't do anything...)
92129>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
92129>>>>>            Function_Return (bOK = True)
92130>>>>>        End
92130>>>>>>
92130>>>>>
92130>>>>>        Get psSchema hTable to sSchemaName
92131>>>>>        If (sSchemaName = "") Begin
92133>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
92134>>>>>        End
92134>>>>>>
92134>>>>>
92134>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
92134>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
92135>>>>>        If (bExists = True) Begin
92137>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
92138>>>>>        End
92138>>>>>>
92138>>>>>
92138>>>>>        Get UtilDeleteCacheFile sRootName to bOK
92139>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
92140>>>>>
92140>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
92141>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
92146>>>>>            If (bUseConnectionID = True) Begin
92148>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
92155>>>>>            End
92155>>>>>>
92155>>>>>            Else Begin
92156>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
92163>>>>>            End
92163>>>>>>
92163>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
92168>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
92173>>>>>            // There seems to be a new order how these are set from DF19.
92173>>>>>            If (bSysFile = True) Begin
92175>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
92180>>>>>            End
92180>>>>>>
92180>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
92185>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
92190>>>>>            If (bSysFile = True) Begin
92192>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
92197>>>>>            End
92197>>>>>>
92197>>>>>
92197>>>>>            If (bSysFile = False) Begin
92199>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
92200>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
92201>>>>>                If (iSize > 0) Begin
92203>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
92206>>>>>                    Writeln channel iCh // Just an empty line
92208>>>>>                End
92208>>>>>>
92208>>>>>                Decrement iSize
92209>>>>>                For iCount from 0 to iSize
92215>>>>>>
92215>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
92218>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
92221>>>>>                    Writeln channel iCh
92223>>>>>                Loop
92224>>>>>>
92224>>>>>            End
92224>>>>>>
92224>>>>>        Send Seq_Close_Channel iCh
92225>>>>>
92225>>>>>        // Wait a sec for Windows to finish writing the file:
92225>>>>>        Sleep 1
92226>>>>>
92226>>>>>        Function_Return (bOK = True)
92227>>>>>    End_Function
92228>>>>>
92228>>>>>    // Message for changing .int files to use connection ID's
92228>>>>>    //
92228>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
92228>>>>>    // OR changes an existing connection id to a new id.
92228>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
92228>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
92228>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
92230>>>>>        String sFileName sDriverID sDriverFile sConnectionString
92230>>>>>        String[] sFilesData
92231>>>>>        Boolean bExists bOK bCancel
92231>>>>>        Integer iSize iCount
92231>>>>>
92231>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
92232>>>>>        Move (SizeOfArray(sFilesData))    to iSize
92233>>>>>        If (iSize = 0) Begin    
92235>>>>>            If (ghoStatusPanel <> 0) Begin
92237>>>>>                If (Active_State(ghoStatusPanel)) Begin
92239>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
92240>>>>>                End
92240>>>>>>
92240>>>>>            End
92240>>>>>>
92240>>>>>            Send Info_Box "No .int files found! Nothing was changed."
92241>>>>>            Procedure_Return
92242>>>>>        End
92242>>>>>>
92242>>>>>
92242>>>>>        Move (Trim(sConnectionID)) to sConnectionID
92243>>>>>        Get vFolderFormat sDataPath to sDataPath
92244>>>>>        Decrement iSize
92245>>>>>        For iCount from 0 to iSize
92251>>>>>>
92251>>>>>            Move sFilesData[iCount] to sFileName
92252>>>>>            // This makes sure that we also can change an existing connection id to something new:
92252>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
92253>>>>>            If (ghoStatusPanel <> 0) Begin
92255>>>>>                If (Active_State(ghoStatusPanel)) Begin
92257>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
92258>>>>>                    If (bCancel = True) Begin
92260>>>>>                        Send Deactivate of ghoStatusPanel
92261>>>>>                        Procedure_Return
92262>>>>>                    End
92262>>>>>>
92262>>>>>                End
92262>>>>>>
92262>>>>>            End
92262>>>>>>
92262>>>>>        Loop
92263>>>>>>
92263>>>>>
92263>>>>>        Get psDriverID to sDriverID
92264>>>>>
92264>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
92264>>>>>        Move "" to sFileName
92265>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
92267>>>>>            Move "MSSQLDrv.int" to sFileName
92268>>>>>        End
92268>>>>>>
92268>>>>>        If (sDriverID = DB2_DRV_ID) Begin
92270>>>>>            Move "DB2_Drv.int" to sFileName
92271>>>>>        End
92271>>>>>>
92271>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92273>>>>>            Move "ODBC_Drv.int" to sFileName
92274>>>>>        End
92274>>>>>>
92274>>>>>        If (sFileName <> "") Begin
92276>>>>>            Move "" to sDriverFile
92277>>>>>            Get_File_Path sFileName to sDriverFile
92278>>>>>            If (sDriverFile <> "") Begin
92280>>>>>                Get psConnectionString to sConnectionString
92281>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
92282>>>>>            End
92282>>>>>>
92282>>>>>        End
92282>>>>>>
92282>>>>>    End_Procedure
92283>>>>>
92283>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
92283>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
92285>>>>>        String[] sDatabaseArray
92286>>>>>        String sVal sServer sDriverID
92286>>>>>        Integer iCount iSize iPos
92286>>>>>        Boolean bExists
92286>>>>>        tSQLConnection SQLConnection
92286>>>>>        tSQLConnection SQLConnection
92286>>>>>
92286>>>>>        Move False to bExists
92287>>>>>        Get psDriverID to sDriverID
92288>>>>>        // DB2 doesn't need to have a "Database" name, so we always return True.
92288>>>>>        If (sDriverID = DB2_DRV_ID) Begin
92290>>>>>            Function_Return bExists
92291>>>>>        End
92291>>>>>>
92291>>>>>
92291>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
92292>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
92294>>>>>            Function_Return False
92295>>>>>        End
92295>>>>>>
92295>>>>>
92295>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92296>>>>>        Get ParseKeyWord SQLConnection.sConnectionString (CS_SQLIniDSNKeyword + "=") to sServer
92297>>>>>        If (sServer contains "/") Begin
92299>>>>>            Move (Pos("/", sServer)) to iPos
92300>>>>>            Move (Mid(sServer, 999, (iPos +1)))                        to sDatabase
92301>>>>>        End
92301>>>>>>
92301>>>>>
92301>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
92302>>>>>        Decrement iSize
92303>>>>>        For iCount from 0 to iSize
92309>>>>>>
92309>>>>>            Move sDatabaseArray[iCount] to sVal
92310>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
92312>>>>>                Move True to bExists
92313>>>>>            End
92313>>>>>>
92313>>>>>        Loop
92314>>>>>>
92314>>>>>
92314>>>>>        Function_Return bExists
92315>>>>>    End_Function
92316>>>>>
92316>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
92316>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
92318>>>>>        String sTableName sVal
92318>>>>>        Boolean bExists
92318>>>>>        String[] sTablesArray
92319>>>>>        Integer iSize iCount
92319>>>>>
92319>>>>>        Move False to bExists
92320>>>>>        Get UtilTableHandleToString hTable to sTableName
92321>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
92322>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
92323>>>>>        Decrement iSize
92324>>>>>        For iCount from 0 to iSize
92330>>>>>>
92330>>>>>            Move sTablesArray[iCount] to sVal
92331>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
92333>>>>>                Move True to bExists
92334>>>>>                Move iSize to iCount // We're done!
92335>>>>>            End
92335>>>>>>
92335>>>>>        Loop
92336>>>>>>
92336>>>>>
92336>>>>>        Function_Return bExists
92337>>>>>    End_Function
92338>>>>>
92338>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
92338>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
92340>>>>>        String sVal
92340>>>>>        Boolean bExists
92340>>>>>        String[] sTablesArray
92341>>>>>        Integer iSize iCount
92341>>>>>
92341>>>>>        Move False to bExists
92342>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
92343>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
92344>>>>>        Decrement iSize
92345>>>>>        For iCount from 0 to iSize
92351>>>>>>
92351>>>>>            Move sTablesArray[iCount] to sVal
92352>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
92354>>>>>                Move True to bExists
92355>>>>>                Move iSize to iCount // We're done!
92356>>>>>            End
92356>>>>>>
92356>>>>>        Loop
92357>>>>>>
92357>>>>>
92357>>>>>        Function_Return bExists
92358>>>>>    End_Function
92359>>>>>
92359>>>>>    // ToDo: This index name function needs to be finished...
92359>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
92361>>>>>        String sStmt sSchema sTableName sDriverID
92361>>>>>        Boolean bExists
92361>>>>>
92361>>>>>        Get psDriverID to sDriverID
92362>>>>>        Get psSchema to sSchema
92363>>>>>        Get UtilTableHandleToString hTable to sTableName
92364>>>>>
92364>>>>>        Function_Return bExists
92365>>>>>    End_Function
92366>>>>>
92366>>>>>    // Function creates the passed Sql script as a ".sql" file in the workspace's
92366>>>>>    // Home folder, if no path was specified for the filename.
92366>>>>>    // Mostly for debugging purposes. E.g. to recreate a Sql script that has been
92366>>>>>    // compiled into the program, when the program is run at other location.
92366>>>>>//    Function SqlUtilCreateScriptAsFile String sSQLScript String sFileName Returns String
92366>>>>>//        String sRetval sPath
92366>>>>>//        Integer iCh
92366>>>>>//
92366>>>>>//        Get ParseFolderName sFileName to sPath
92366>>>>>//        If (Trim(sPath) = "") Begin
92366>>>>>//            Get psHome of (phoWorkspace(ghoApplication)) to sPath
92366>>>>>//        End
92366>>>>>//        Get vFolderFormat sPath to sPath
92366>>>>>//        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
92366>>>>>//            Write channel iCh sSQLScript
92366>>>>>//        Send Seq_Close_Channel iCh
92366>>>>>//
92366>>>>>//        Function_Return (sPath + sFileName)
92366>>>>>//    End_Function
92366>>>>>
92366>>>>>    // Enumerate SQL Servers.
92366>>>>>    // Pass a driver id. Returns a string array.
92366>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
92366>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
92366>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
92368>>>>>        String[] sReturnArray
92369>>>>>        Handle hoSQLHandler
92369>>>>>        String sServer
92369>>>>>        Integer iCount iNumItems iDataSourceType
92369>>>>>        Boolean bOK
92369>>>>>
92369>>>>>        If (num_arguments > 1) Begin
92371>>>>>            Move iDatSrcType to iDataSourceType
92372>>>>>        End
92372>>>>>>
92372>>>>>
92372>>>>>        Case Begin
92372>>>>>            Case (sDriverID = MSSQLDRV_ID)
92374>>>>>                Get phoMSSQLHandler to hoSQLHandler
92375>>>>>                    Get EnumerateServersLocal of hoSQLHandler to iNumItems
92376>>>>>                    If (iNumItems = 0) Begin
92378>>>>>                        Get EnumerateServers of hoSQLHandler to iNumItems
92379>>>>>                    End
92379>>>>>>
92379>>>>>                For iCount from 0 to (iNumItems - 1)
92385>>>>>>
92385>>>>>                    Get String_Value of hoSQLHandler item iCount to sServer
92386>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
92387>>>>>                Loop
92388>>>>>>
92388>>>>>                Case Break
92389>>>>>
92389>>>>>            Case (sDriverID = DB2_DRV_ID)
92392>>>>>                Get phoDB2SQLHandler to hoSQLHandler
92393>>>>>                Send SeedDataSources of hoSQLHandler
92394>>>>>                Move 0 to iCount
92395>>>>>                Repeat
92395>>>>>>
92395>>>>>                    Get DataSources of hoSQLHandler to sServer
92396>>>>>                    If (sServer <> "") Begin
92398>>>>>                        Move (Replace(",", sServer, "")) to sServer
92399>>>>>                        Move sServer to sReturnArray[iCount]
92400>>>>>                    End
92400>>>>>>
92400>>>>>                    Increment iCount
92401>>>>>                Until (sServer = "")
92403>>>>>                Case Break
92404>>>>>
92404>>>>>            Case (sDriverID = ODBC_DRV_ID)
92407>>>>>                Get phoODBCSQLHandler to hoSQLHandler
92408>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
92409>>>>>                Move 0 to iCount
92410>>>>>                Repeat
92410>>>>>>
92410>>>>>                    Get DataSources of hoSQLHandler to sServer
92411>>>>>                    If (sServer <> "") Begin
92413>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
92414>>>>>                        Move sServer to sReturnArray[iCount]
92415>>>>>                    End
92415>>>>>>
92415>>>>>                    Increment iCount
92416>>>>>                Until (sServer = "")
92418>>>>>                Case Break
92419>>>>>
92419>>>>>            Case (sDriverID = SQLFLEX)
92422>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
92423>>>>>                Case Break
92424>>>>>
92424>>>>>            Case (sDriverID = ORAFLEX)
92427>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
92428>>>>>                Case Break
92429>>>>>
92429>>>>>            // There appearantly is no way to enumerate servers for this backend.
92429>>>>>            Case (sDriverID = MDSPgSQL)
92432>>>>>                Move "localhost" to sReturnArray[0]
92433>>>>>                Case Break
92434>>>>>
92434>>>>>            // There appearantly is no way to enumerate servers for this backend.
92434>>>>>            Case (sDriverID = MDSMySQL)
92437>>>>>                Move "localhost" to sReturnArray[0]
92438>>>>>                Case Break
92439>>>>>
92439>>>>>            Case Else
92439>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
92440>>>>>>
92440>>>>>        Case End
92440>>>>>
92440>>>>>        Function_Return sReturnArray
92441>>>>>    End_Function
92442>>>>>
92442>>>>>    // Returns all databases as a string array for the passed driver id.
92442>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
92444>>>>>        String[] sReturnArray
92445>>>>>        String sUserID sPassword
92445>>>>>        Boolean bOK
92445>>>>>
92445>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92446>>>>>        If (bOK = False) Begin
92448>>>>>            Function_Return sReturnArray
92449>>>>>        End
92449>>>>>>
92449>>>>>
92449>>>>>        Case Begin
92449>>>>>            Case (sDriverID = MSSQLDRV_ID)
92451>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
92452>>>>>                Case Break
92453>>>>>            Case (sDriverID = DB2_DRV_ID)
92456>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
92457>>>>>                Case Break
92458>>>>>
92458>>>>>            // Enumeration of ODBC databases should be irrelevant as the database
92458>>>>>            // should have been specified when the ODBC source was setup with the ODBC manager.
92458>>>>>            Case (sDriverID = ODBC_DRV_ID)
92461>>>>>                Case Break
92462>>>>>
92462>>>>>            Case (sDriverID = SQLFLEX)
92465>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
92466>>>>>                Case Break
92467>>>>>
92467>>>>>            Case (sDriverID = MDSPgSQL)
92470>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
92471>>>>>                Case Break
92472>>>>>
92472>>>>>            Case (sDriverID = MDSMySQL)
92475>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
92476>>>>>                Case Break
92477>>>>>
92477>>>>>            Case (sDriverID = ORAFLEX)
92480>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
92481>>>>>                Case Break
92482>>>>>
92482>>>>>            Case Else
92482>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
92483>>>>>>
92483>>>>>        Case End
92483>>>>>
92483>>>>>        Function_Return sReturnArray
92484>>>>>    End_Function
92485>>>>>
92485>>>>>    // Returns all table spaces as a string array for the passed driver id.
92485>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
92487>>>>>        String[] sReturnArray
92488>>>>>        String sServer sUserID sPassword
92488>>>>>        Boolean bOK
92488>>>>>
92488>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92489>>>>>        If (bOK = False) Begin
92491>>>>>            Function_Return sReturnArray
92492>>>>>        End
92492>>>>>>
92492>>>>>
92492>>>>>        Case Begin
92492>>>>>            Case (sDriverID = DB2_DRV_ID)
92494>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
92495>>>>>                Case Break
92496>>>>>
92496>>>>>            Case (sDriverID = MDSPgSQL)
92499>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
92500>>>>>                Case Break
92501>>>>>
92501>>>>>            Case (sDriverID = ORAFLEX)
92504>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
92505>>>>>                Case Break
92506>>>>>
92506>>>>>            Case Else
92506>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
92507>>>>>>
92507>>>>>                Case Break
92508>>>>>        Case End
92508>>>>>
92508>>>>>        Function_Return sReturnArray
92509>>>>>    End_Function
92510>>>>>
92510>>>>>    // Returns all schemas as a string array for the passed driver id.
92510>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
92512>>>>>        String[] sReturnArray
92513>>>>>        Boolean bOK
92513>>>>>
92513>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92514>>>>>        If (bOK = False) Begin
92516>>>>>            Function_Return sReturnArray
92517>>>>>        End
92517>>>>>>
92517>>>>>
92517>>>>>        Case Begin
92517>>>>>            Case (sDriverID = DB2_DRV_ID)
92519>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
92520>>>>>                Case Break
92521>>>>>
92521>>>>>            Case (sDriverID = MDSPgSQL)
92524>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
92525>>>>>                Case Break
92526>>>>>
92526>>>>>            Case (sDriverID = ORAFLEX)
92529>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
92530>>>>>                Case Break
92531>>>>>
92531>>>>>            Case Else
92531>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
92532>>>>>>
92532>>>>>                Case Break
92533>>>>>        Case End
92533>>>>>
92533>>>>>        Function_Return sReturnArray
92534>>>>>    End_Function
92535>>>>>
92535>>>>>    // Returns a string array with all tables for the current database.
92535>>>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
92537>>>>>        String[] sReturnArray sArray
92539>>>>>        String sServer sDatabase sConnectionString sSelect sSchema
92539>>>>>        Integer iSize iCount
92539>>>>>        Boolean bOK
92539>>>>>
92539>>>>>        If (sDriverID = DATAFLEX_ID) Begin
92541>>>>>            Function_Return sArray
92542>>>>>        End
92542>>>>>>
92542>>>>>
92542>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92543>>>>>        If (bOK = False) Begin
92545>>>>>            Function_Return sReturnArray
92546>>>>>        End
92546>>>>>>
92546>>>>>
92546>>>>>        Get psConnectionString to sConnectionString
92547>>>>>        Get psDatabase to sDatabase
92548>>>>>        Get psSchema   to sSchema
92549>>>>>
92549>>>>>        Case Begin
92549>>>>>            Case (sDriverID = MSSQLDRV_ID)
92551>>>>>                Get _SqlTableArrayDAW to sReturnArray
92552>>>>>                Case Break
92553>>>>>
92553>>>>>            Case (sDriverID = DB2_DRV_ID)
92556>>>>>                Get _SqlTableArrayDAW to sReturnArray
92557>>>>>                Case Break
92558>>>>>
92558>>>>>            Case (sDriverID = ODBC_DRV_ID)
92561>>>>>                Get _SqlTableArrayDAW to sReturnArray
92562>>>>>                Case Break
92563>>>>>
92563>>>>>            Case (sDriverID = SQLFLEX)
92566>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
92567>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
92568>>>>>                Case Break
92569>>>>>
92569>>>>>            Case (sDriverID = MDSMySQL)
92572>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
92573>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
92574>>>>>                Case Break
92575>>>>>
92575>>>>>            Case (sDriverID = MDSPgSQL)
92578>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
92579>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
92580>>>>>                Case Break
92581>>>>>
92581>>>>>            Case (sDriverID = ORAFLEX)
92584>>>>>                Move "SELECT table_name from user_tables" to sSelect
92585>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
92586>>>>>                Move (SizeOfArray(sArray)) to iSize
92587>>>>>                Decrement iSize
92588>>>>>                For iCount from 0 to iSize
92594>>>>>>
92594>>>>>                    If (not(sArray[iCount] contains "$")) Begin
92596>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
92597>>>>>                    End
92597>>>>>>
92597>>>>>                Loop
92598>>>>>>
92598>>>>>                Case Break
92599>>>>>
92599>>>>>            Case Else
92599>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
92600>>>>>>
92600>>>>>                Case Break
92601>>>>>        Case End
92601>>>>>
92601>>>>>        Function_Return sReturnArray
92602>>>>>    End_Function
92603>>>>>
92603>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
92603>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
92605>>>>>        String[] sReturnArray
92606>>>>>        String sServer sConnectionString sSelect sSchema
92606>>>>>        Boolean bOK
92606>>>>>
92606>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92607>>>>>        If (bOK = False) Begin
92609>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
92610>>>>>>
92610>>>>>            Function_Return sReturnArray
92611>>>>>        End
92611>>>>>>
92611>>>>>
92611>>>>>        Get psConnectionString to sConnectionString
92612>>>>>        Get psSchema to sSchema
92613>>>>>
92613>>>>>        Case Begin
92613>>>>>            Case (sDriverID = MSSQLDRV_ID)
92615>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
92616>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
92617>>>>>                Case Break
92618>>>>>
92618>>>>>            Case (sDriverID = DB2_DRV_ID)
92621>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
92622>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
92623>>>>>                Case Break
92624>>>>>
92624>>>>>            Case (sDriverID = SQLFLEX)
92627>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
92628>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
92629>>>>>                Case Break
92630>>>>>
92630>>>>>            Case (sDriverID = MDSMySQL)
92633>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
92634>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
92635>>>>>                Case Break
92636>>>>>
92636>>>>>            Case (sDriverID = MDSPgSQL)
92639>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
92640>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
92641>>>>>                Case Break
92642>>>>>
92642>>>>>            Case (sDriverID = ORAFLEX)
92645>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
92646>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
92647>>>>>                Case Break
92648>>>>>
92648>>>>>            Case Else
92648>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
92649>>>>>>
92649>>>>>                Case Break
92650>>>>>        Case End
92650>>>>>
92650>>>>>        Function_Return sReturnArray
92651>>>>>    End_Function
92652>>>>>
92652>>>>>
92652>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
92652>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
92654>>>>>        String[] sReturnArray sReturnArray2
92656>>>>>        String sServer sConnectionString sSelect sSchema
92656>>>>>        Boolean bOK
92656>>>>>        Integer iCount iSize
92656>>>>>
92656>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92657>>>>>        If (bOK = False) Begin
92659>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
92660>>>>>>
92660>>>>>            Function_Return sReturnArray
92661>>>>>        End
92661>>>>>>
92661>>>>>
92661>>>>>        Get psConnectionString to sConnectionString
92662>>>>>        Get psSchema to sSchema
92663>>>>>
92663>>>>>        Case Begin
92663>>>>>            Case (sDriverID = MSSQLDRV_ID)
92665>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
92666>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
92667>>>>>                Case Break
92668>>>>>
92668>>>>>            Case (sDriverID = DB2_DRV_ID)
92671>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92672>>>>>>
92672>>>>>//                Move () to sSelect
92672>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
92672>>>>>                Case Break
92673>>>>>
92673>>>>>            Case (sDriverID = SQLFLEX)
92676>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92677>>>>>>
92677>>>>>//                Move () to sSelect
92677>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
92677>>>>>                Case Break
92678>>>>>
92678>>>>>            Case (sDriverID = MDSMySQL)
92681>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92682>>>>>>
92682>>>>>//                Move () to sSelect
92682>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
92682>>>>>                Case Break
92683>>>>>
92683>>>>>            Case (sDriverID = MDSPgSQL)
92686>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92687>>>>>>
92687>>>>>//                Move () to sSelect
92687>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
92687>>>>>                Case Break
92688>>>>>
92688>>>>>            Case (sDriverID = ORAFLEX)
92691>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92692>>>>>>
92692>>>>>//                Move () to sSelect
92692>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
92692>>>>>                Case Break
92693>>>>>
92693>>>>>            Case Else
92693>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
92694>>>>>>
92694>>>>>                Case Break
92695>>>>>        Case End
92695>>>>>
92695>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
92696>>>>>        Decrement iSize
92697>>>>>        For iCount from 0 to iSize
92703>>>>>>
92703>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
92705>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
92706>>>>>            End
92706>>>>>>
92706>>>>>        Loop
92707>>>>>>
92707>>>>>
92707>>>>>        Function_Return sReturnArray2
92708>>>>>    End_Function
92709>>>>>
92709>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
92709>>>>>    // The format of the array is "TableName.FieldName"
92709>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
92711>>>>>        String[] sFileNameArray sFieldNameArray
92713>>>>>        tSQLRelation[] sRelationsArray
92713>>>>>        tSQLRelation[] sRelationsArray
92714>>>>>        String sServer sConnectionString sSelect sSchema sFileName sFieldName sVal
92714>>>>>        Boolean bOK
92714>>>>>        Integer iCount iSize iLength iPos
92714>>>>>        Integer iFileNumber iFieldNumber
92714>>>>>
92714>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92715>>>>>        If (bOK = False) Begin
92717>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
92718>>>>>>
92718>>>>>            Function_Return sRelationsArray
92719>>>>>        End
92719>>>>>>
92719>>>>>
92719>>>>>        Get psConnectionString to sConnectionString
92720>>>>>        Get psSchema to sSchema
92721>>>>>
92721>>>>>        Case Begin
92721>>>>>            Case (sDriverID = MSSQLDRV_ID)
92723>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
92724>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
92725>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
92726>>>>>                Case Break
92727>>>>>
92727>>>>>            Case (sDriverID = DB2_DRV_ID)
92730>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92731>>>>>>
92731>>>>>//                Move () to sSelect
92731>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
92731>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
92731>>>>>                Case Break
92732>>>>>
92732>>>>>            Case (sDriverID = SQLFLEX)
92735>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92736>>>>>>
92736>>>>>//                Move () to sSelect
92736>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
92736>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
92736>>>>>                Case Break
92737>>>>>
92737>>>>>            Case (sDriverID = MDSMySQL)
92740>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92741>>>>>>
92741>>>>>//                Move () to sSelect
92741>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
92741>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
92741>>>>>                Case Break
92742>>>>>
92742>>>>>            Case (sDriverID = MDSPgSQL)
92745>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92746>>>>>>
92746>>>>>//                Move () to sSelect
92746>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
92746>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
92746>>>>>                Case Break
92747>>>>>
92747>>>>>            Case (sDriverID = ORAFLEX)
92750>>>>>                Error "Not implemented yet! The select statement has not been finalized."
92751>>>>>>
92751>>>>>//                Move () to sSelect
92751>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
92751>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
92751>>>>>                Case Break
92752>>>>>
92752>>>>>            Case Else
92752>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
92753>>>>>>
92753>>>>>                Case Break
92754>>>>>        Case End
92754>>>>>
92754>>>>>        Move (Length(sTableName)) to iLength
92755>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
92756>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
92757>>>>>        Decrement iSize
92758>>>>>        For iCount from 0 to iSize
92764>>>>>>
92764>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
92766>>>>>                Move sFileNameArray[iCount]         to sFileName
92767>>>>>                Move sFieldNameArray[iCount]        to sFieldName
92768>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
92769>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
92770>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
92771>>>>>            End
92771>>>>>>
92771>>>>>        Loop
92772>>>>>>
92772>>>>>
92772>>>>>        Function_Return sRelationsArray
92773>>>>>    End_Function
92774>>>>>
92774>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
92776>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
92776>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
92777>>>>>        String[] sUsers sPrograms
92779>>>>>        String sSelect
92779>>>>>        Integer iSize iCount
92779>>>>>
92779>>>>>        Case Begin
92779>>>>>            Case (sDriverID = MSSQLDRV_ID)
92781>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
92782>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
92783>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
92784>>>>>                Case Break
92785>>>>>            Case (sDriverID = SQLFLEX)
92788>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
92789>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
92790>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
92791>>>>>                Case Break
92792>>>>>            Case Else
92792>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
92793>>>>>>
92793>>>>>        Case End
92793>>>>>
92793>>>>>        Move (SizeOfArray(sUsers)) to iSize
92794>>>>>        Decrement iSize
92795>>>>>        For iCount from 0 to iSize
92801>>>>>>
92801>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
92802>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
92803>>>>>        Loop
92804>>>>>>
92804>>>>>
92804>>>>>        Function_Return SQLLoggedInUser
92805>>>>>    End_Function
92806>>>>>
92806>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
92806>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
92806>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
92808>>>>>        String[] sFilesData
92809>>>>>        Boolean bExists
92809>>>>>        Integer iCh
92809>>>>>        String sFileName sExt
92809>>>>>
92809>>>>>        Get vFolderExists sDataPath to bExists
92810>>>>>        If (bExists = True) Begin
92812>>>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
92813>>>>>            Move ("dir:" + sDataPath)      to sDataPath
92814>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
92815>>>>>            Direct_Input channel iCh sDataPath
92817>>>>>                Repeat
92817>>>>>>
92817>>>>>                    Readln channel iCh sFileName
92819>>>>>                    Get ParseFileExtension sFileName to sExt
92820>>>>>                    If (Uppercase(sExt) = "INT") Begin
92822>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
92824>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
92825>>>>>                        End
92825>>>>>>
92825>>>>>                    End
92825>>>>>>
92825>>>>>                Until (SeqEof = True)
92827>>>>>            Close_Input channel iCh
92829>>>>>        End
92829>>>>>>
92829>>>>>        Function_Return sFilesData
92830>>>>>    End_Function
92831>>>>>
92831>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
92831>>>>>    // Pass e.g. the psServer property to determine the current connection server.
92831>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
92831>>>>>    // This handle can be used to obtain attributes about the server, such as default
92831>>>>>    // column types.
92831>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
92833>>>>>        Handle hDatabase
92833>>>>>        Integer iDriver iServers iCount
92833>>>>>        String sValue
92833>>>>>
92833>>>>>        If (sServer = "") Begin
92835>>>>>            Function_Return 0
92836>>>>>        End
92836>>>>>>
92836>>>>>
92836>>>>>        Get DriverIndex sDriverID to iDriver
92837>>>>>        If (iDriver = 0) Begin
92839>>>>>            Function_Return 0
92840>>>>>        End
92840>>>>>>
92840>>>>>
92840>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
92843>>>>>        For iCount from 1 to iServers
92849>>>>>>
92849>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
92852>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
92854>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
92857>>>>>            End
92857>>>>>>
92857>>>>>        Loop
92858>>>>>>
92858>>>>>
92858>>>>>        Function_Return hDatabase
92859>>>>>    End_Function
92860>>>>>
92860>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
92862>>>>>        String sConnectionString sMessage
92862>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
92862>>>>>        Integer i iMsgs iFetchResult iResultCount iRowType iRows iErr iMessage iLastErr
92862>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
92865>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
92865>>>>>        TimeSpan tsQuery tsFetch
92865>>>>>        tSqlErrorArray aSqlErrorArray
92865>>>>>        tSqlErrorArray aSqlErrorArray
92865>>>>>        Boolean bOK bMertechDriver bShowProgress
92865>>>>>        tSQLConnection SQLConnection
92865>>>>>        tSQLConnection SQLConnection
92865>>>>>
92865>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
92866>>>>>        If (bOK = False) Begin
92868>>>>>            Procedure_Return
92869>>>>>        End
92869>>>>>>
92869>>>>>
92869>>>>>        If (num_arguments > 2) Begin
92871>>>>>            Move bShowProgr to bShowProgress
92872>>>>>        End
92872>>>>>>
92872>>>>>
92872>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92873>>>>>
92873>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
92874>>>>>        If (bMertechDriver = True) Begin
92876>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
92877>>>>>        End
92877>>>>>>
92877>>>>>        If (bMertechDriver = False) Begin
92879>>>>>            Get phoSQLManager to hoSqlHandler
92880>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
92881>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
92882>>>>>        End
92882>>>>>>
92882>>>>>
92882>>>>>        If (hoSQLConnect <> 0) Begin
92884>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
92885>>>>>            If (hoStmt <> 0) Begin
92887>>>>>                // record starting date/time stamp
92887>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
92888>>>>>                // turn on error handling if enabled
92888>>>>>                If (pbHandleQueryErrors(Self)) Begin
92890>>>>>                    Set pbSqlError to False
92891>>>>>                    Set paSqlErrorArray to aSqlErrorArray
92892>>>>>                    Move Error_Object_Id to hoError
92893>>>>>                    Move Self to Error_Object_Id
92894>>>>>                End
92894>>>>>>
92894>>>>>
92894>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
92894>>>>>                Set psSQLStatementString to sStmt
92895>>>>>                Send SqlExecDirect of hoStmt sStmt
92896>>>>>
92896>>>>>                If (pbHandleQueryErrors(Self)) Begin
92898>>>>>                    Move hoError to Error_Object_Id
92899>>>>>                End
92899>>>>>>
92899>>>>>
92899>>>>>                Move 0 to iMsgs
92900>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
92900>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
92900>>>>>                If (bMertechDriver = False) Begin
92902>>>>>                    Move Err to iErr
92903>>>>>                    Move LastErr to iLastErr
92904>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
92905>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
92906>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
92907>>>>>                    Send _SqlColumnInfo hoStmt
92908>>>>>                    Send Ignore_Error of Error_Object_Id 12289
92909>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92910>>>>>                    Repeat
92910>>>>>>
92910>>>>>                        Get SqlFetch of hoStmt to iFetchResult
92911>>>>>                        If (iFetchResult <> 0) Begin
92913>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
92914>>>>>                        End
92914>>>>>>
92914>>>>>                    Until (iFetchResult = 0)
92916>>>>>                    Send Trap_Error of Error_Object_Id 12289
92917>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92918>>>>>                    Move iErr to Err
92919>>>>>                    Move iLastErr to LastErr
92920>>>>>                    Set paSQLFetchResults to aSQLFetchResults
92921>>>>>                End
92921>>>>>>
92921>>>>>
92921>>>>>                Set piRows    to iRows
92922>>>>>                Set piRowType to iRowType
92923>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
92924>>>>>                Move (CurrentDateTime()) to dtFetchStart
92925>>>>>
92925>>>>>                If (iMsgs <> 0) Begin
92927>>>>>                    If (ghoDbUpdateHandler > 0) Begin
92929>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
92930>>>>>                    End
92930>>>>>>
92930>>>>>                    For i from 1 to iMsgs
92936>>>>>>
92936>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
92937>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
92938>>>>>                        If (bShowProgress = True) Begin
92940>>>>>                            If (Active_State(ghoStatusPanel)) Begin
92942>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
92943>>>>>                            End
92943>>>>>>
92943>>>>>                            Else Begin
92944>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
92946>>>>>                            End
92946>>>>>>
92946>>>>>                        End
92946>>>>>>
92946>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
92947>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
92948>>>>>                    Loop
92949>>>>>>
92949>>>>>                    If (ghoDbUpdateHandler > 0) Begin
92951>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
92952>>>>>                    End
92952>>>>>>
92952>>>>>                    Set paQueryMessages to sMsg
92953>>>>>                End
92953>>>>>>
92953>>>>>                Move (CurrentDateTime()) to dtFetchEnd
92954>>>>>            End
92954>>>>>>
92954>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
92955>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
92956>>>>>            Set ptsQueryExec to tsQuery
92957>>>>>            Set ptsFetchResults to tsFetch
92958>>>>>            Send SqlClose of hoStmt
92959>>>>>        End
92959>>>>>>
92959>>>>>
92959>>>>>        Send SqlDisconnect of hoSQLConnect
92960>>>>>    End_Procedure
92961>>>>>
92961>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
92961>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
92961>>>>>    // Returns False if no error occured.
92961>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
92963>>>>>        Boolean bOK bShowProgress
92963>>>>>        tSQLScriptArray SQLScriptArray
92963>>>>>        tSQLScriptArray SQLScriptArray
92963>>>>>        Integer iOut iRows iCount
92963>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
92963>>>>>        TimeSpan tsTotalTime
92963>>>>>        String sMessage
92963>>>>>
92963>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
92964>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
92965>>>>>        If (SQLScriptArray.bError = True) Begin
92967>>>>>            Function_Return False
92968>>>>>        End
92968>>>>>>
92968>>>>>
92968>>>>>        If (num_arguments > 3) Begin
92970>>>>>            Move bShowProgr to bShowProgress
92971>>>>>        End
92971>>>>>>
92971>>>>>
92971>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92972>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
92973>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92974>>>>>
92974>>>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
92976>>>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
92977>>>>>>
92977>>>>>        End
92977>>>>>>
92977>>>>>
92977>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
92978>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
92979>>>>>        Set ptsTotalQueryTime to tsTotalTime
92980>>>>>
92980>>>>>        Function_Return bOK
92981>>>>>    End_Procedure
92982>>>>>
92982>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
92982>>>>>//        String sRootName
92982>>>>>//        Boolean bOK
92982>>>>>//
92982>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92982>>>>>//        Move (sRootName contains sDriverID) to bOK
92982>>>>>//
92982>>>>>//        Function_Return bOK
92982>>>>>//    End_Function
92982>>>>>
92982>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
92982>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
92982>>>>>//        Integer iDbType
92982>>>>>//        Boolean bOK
92982>>>>>//
92982>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
92982>>>>>//        If (bOK = True) Begin
92982>>>>>//            Function_Return False
92982>>>>>//        End
92982>>>>>//
92982>>>>>//        Get psDriverID to sDriverID
92982>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
92982>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
92982>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
92982>>>>>//
92982>>>>>//        Get psDriverID to sDriverID
92982>>>>>//        Get piDbType   to iDbType
92982>>>>>//        Get psSchema   to sSchema
92982>>>>>//        If (sSchema = "") Begin
92982>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92982>>>>>//        End
92982>>>>>//
92982>>>>>//        Move (Uppercase(sDisplayName)) to sVal
92982>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
92982>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
92982>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
92982>>>>>//            End
92982>>>>>//            Else Begin
92982>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
92982>>>>>//            End
92982>>>>>//        End
92982>>>>>//
92982>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
92982>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
92982>>>>>//
92982>>>>>//        Function_Return True
92982>>>>>//    End_Function
92982>>>>>
92982>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
92982>>>>>    // from the passed filelist.
92982>>>>>    // Returns the number of tables affected.
92982>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
92984>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
92984>>>>>        Integer iRetval
92984>>>>>        Handle hTable
92984>>>>>
92984>>>>>        // We first save the current filelist as the passed filelist name
92984>>>>>        // may come from another workspace, to restore it when we're ready.
92984>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
92987>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
92990>>>>>        Move 0 to hTable
92991>>>>>        Move 0 to iRetval
92992>>>>>
92992>>>>>        Repeat
92992>>>>>>
92992>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92995>>>>>            If (hTable <> 0) Begin
92997>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
93000>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
93003>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
93006>>>>>                Move (Uppercase(sRootName)) to sVal
93007>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
93009>>>>>                    // Prefixes:
93009>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
93010>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
93011>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
93012>>>>>                    // Suffixes:
93012>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
93013>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
93014>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
93015>>>>>
93015>>>>>                    // Change Filelist entry:
93015>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
93018>>>>>
93018>>>>>                    Move (Lowercase(sDisplayName)) to sVal
93019>>>>>                    If (sVal contains "dbo.") Begin
93021>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
93022>>>>>
93022>>>>>                        // Change Filelist entry:
93022>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
93025>>>>>                    End
93025>>>>>>
93025>>>>>                    Increment iRetval
93026>>>>>                End
93026>>>>>>
93026>>>>>            End
93026>>>>>>
93026>>>>>        Until (hTable = 0)
93028>>>>>
93028>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
93031>>>>>
93031>>>>>        Function_Return iRetval
93032>>>>>    End_Function
93033>>>>>
93033>>>>>    // To open all Sql based tables in Filelist.cfg
93033>>>>>    Procedure SqlUtilOpenAllTables
93035>>>>>        Handle hTable
93035>>>>>        String sRoot sDriverID
93035>>>>>        Boolean bOK
93035>>>>>
93035>>>>>        Move 0 to hTable
93036>>>>>        Move "" to sDriverID
93037>>>>>        Get AutoConnectionIDLogin to bOK
93038>>>>>
93038>>>>>        Repeat
93038>>>>>>
93038>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
93041>>>>>            If (hTable > 0) Begin
93043>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93046>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
93048>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
93051>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
93053>>>>>                        Open hTable
93055>>>>>                    End
93055>>>>>>
93055>>>>>                End
93055>>>>>>
93055>>>>>            End
93055>>>>>>
93055>>>>>
93055>>>>>        Until (hTable = 0)
93057>>>>>    End_Procedure
93058>>>>>
93058>>>>>    // This function allows you to put an Sql script in a CM Image. It makes it easier to
93058>>>>>    // copy and paste between a DataFlex program and an Sql Editor.
93058>>>>>    Function SqlUtilLoadImageFile String sFileName Returns String
93060>>>>>        Integer iChannel iPos
93060>>>>>        String sTextValue sLine sPath
93060>>>>>        Boolean bSeqEof
93060>>>>>
93060>>>>>        Move "" to sTextValue
93061>>>>>        Get ParseFolderName sFileName to sPath
93062>>>>>        If (Trim(sPath) = "") Begin
93064>>>>>            Get psDataPathFirstPart to sPath
93065>>>>>            Move (sPath + sFileName) to sFileName
93066>>>>>        End
93066>>>>>>
93066>>>>>
93066>>>>>        Get Seq_New_Channel to iChannel
93067>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93069>>>>>            Error DFERR_PROGRAM "No channel available..."
93070>>>>>>
93070>>>>>        End
93070>>>>>>
93070>>>>>        Else Begin
93071>>>>>            Direct_Input channel iChannel sFileName
93073>>>>>            Move (SeqEof) to bSeqEof
93074>>>>>            If (bSeqEof = True) Begin
93076>>>>>                Send Seq_Release_Channel iChannel
93077>>>>>                Set psSQLStatementString to ""
93078>>>>>                Error DFERR_PROGRAM ("The Sql script file:\n" + sFileName + "\nCould not be found.")
93079>>>>>>
93079>>>>>                Function_Return ""
93080>>>>>            End
93080>>>>>>
93080>>>>>
93080>>>>>            While (not(bSeqEof))
93084>>>>>                Readln channel iChannel sLine
93086>>>>>                Move (Pos("/", sLine)) to iPos
93087>>>>>                Move (SeqEol) to bSeqEof
93088>>>>>                If (not(bSeqEof) and iPos <> 1) Begin
93090>>>>>                    Move (sTextValue + sLine + Character(13)) to sTextValue
93091>>>>>                End
93091>>>>>>
93091>>>>>            Loop
93092>>>>>>
93092>>>>>            Send Seq_Release_Channel iChannel
93093>>>>>        End
93093>>>>>>
93093>>>>>
93093>>>>>        Set psSQLStatementString to sTextValue
93094>>>>>        Function_Return sTextValue
93095>>>>>    End_Function
93096>>>>>
93096>>>>>    // Reads an Sql script that have been compiled into the program as an "image" (/MyImageName) and returns the full script as a string.
93096>>>>>    // Usage: Get SqlUtilReadScriptFromCMImage of ghoDbUpdateFunctionLibrary CreatevwWorkflowInbox.n
93096>>>>>    //
93096>>>>>    // This is a trick to use an old DataFlex feature/syntax to include "image names" at the top
93096>>>>>    // of a file. Each such section must end with a "/*".
93096>>>>>    // Note: Sql script files remarks/comments cannot be handled by the DataFlex compiler. All Sql comment
93096>>>>>    //       sections in the "xxx.pkg.sql" file _must_ be removed.
93096>>>>>//    Function SqlUtilReadScriptFromCMImage Integer iImg Returns tSQLScriptResult
93096>>>>>//        Integer iChannel iPos
93096>>>>>//        String sTextValue sLine
93096>>>>>//        Boolean bSeqEof
93096>>>>>//        tSQLScriptResult SqlScriptResult
93096>>>>>//
93096>>>>>//        Move "" to sTextValue
93096>>>>>//
93096>>>>>//        Get Seq_New_Channel to iChannel
93096>>>>>//        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93096>>>>>//            Error DFERR_PROGRAM "No channel available..."
93096>>>>>//            Function_Return ""
93096>>>>>//        End
93096>>>>>//
93096>>>>>//        Get SqlUtilCheckScriptSize False "" iImg True to SqlScriptResult
93096>>>>>//
93096>>>>>//        Direct_Input channel iChannel ("image: " + String(iImg))
93096>>>>>//        Move (SeqEof) to bSeqEof
93096>>>>>//        While (not(bSeqEof))
93096>>>>>//            Readln channel iChannel sLine
93096>>>>>//            Move (SeqEol) to bSeqEof
93096>>>>>//            If (not(bSeqEof)) Begin
93096>>>>>//                Move (Trim(sLine)) to sLine
93096>>>>>//                If (Left(sLine, 2) <> (Character(47) + Character(47))) Begin // ASCII 47 = "/" (Comments)
93096>>>>>//                    Move (sTextValue + sLine + character(13)) to sTextValue
93096>>>>>//                End
93096>>>>>//            End
93096>>>>>//        Loop
93096>>>>>//        Send Seq_Release_Channel iChannel
93096>>>>>//
93096>>>>>//        Set psSQLStatementString to sTextValue
93096>>>>>//        Move sTextValue to SqlScriptResult.sSQLScript
93096>>>>>//        Function_Return SqlScriptResult
93096>>>>>//    End_Function
93096>>>>>
93096>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
93096>>>>>//        String sRetval sDriverID
93096>>>>>//        String sTableName
93096>>>>>//        Integer iDbType iIndex
93096>>>>>//        Boolean bOK
93096>>>>>//
93096>>>>>//        Get psDriverID to sDriverID
93096>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
93096>>>>>//        If (hTable = 0 or bOK = False) Begin
93096>>>>>//            Function_Return ""
93096>>>>>//        End
93096>>>>>//
93096>>>>>//        Move False to Err
93096>>>>>//        Get UtilTableHandleToString hTable to sTableName
93096>>>>>//        Get piDbType to iDbType
93096>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
93096>>>>>//        If (iIndex = -1) Begin
93096>>>>>//            Function_Return ""
93096>>>>>//        End
93096>>>>>//
93096>>>>>//        Function_Return sRetval
93096>>>>>//    End_Function
93096>>>>>
93096>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
93098>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
93098>>>>>        Boolean bOpened bOK bMertech
93098>>>>>        
93098>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
93101>>>>>        Get _TableNameOnly sRootName to sDatabaseName
93102>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
93102>>>>>        // which makes the program unable to run because they can't be opened.
93102>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
93102>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
93102>>>>>        // proper .int files for the two tables.
93102>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
93104>>>>>            Function_Return True
93105>>>>>        End                     
93105>>>>>>
93105>>>>>        
93105>>>>>        Move CS_OEM_Txt  to sOrgFormat
93106>>>>>        Move CS_ANSI_Txt to sNewFormat
93107>>>>>        Get AutoConnectionIDLogin to bOK
93108>>>>>        Send Ignore_Error of Error_Object_Id DFERR_MISSING_VALUE
93109>>>>>        Open hTable
93111>>>>>        Send Trap_Error of Error_Object_Id DFERR_MISSING_VALUE
93112>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93115>>>>>
93115>>>>>        // ToDo: What to do if we cannot open the table?!
93115>>>>>        If (bOpened = False) Begin
93117>>>>>            Function_Return False
93118>>>>>        End
93118>>>>>>
93118>>>>>
93118>>>>>        Get psDriverID to sDriverID
93119>>>>>        Get IsMertechDriver sDriverID to bMertech
93120>>>>>        If (bMertech = True) Begin
93122>>>>>            Get psDataPathFirstPart to sDataPath
93123>>>>>            Get vFolderExists sDataPath to bOK
93124>>>>>            If (bOK = False) Begin
93126>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
93127>>>>>>
93127>>>>>                Function_Return False
93128>>>>>            End
93128>>>>>>
93128>>>>>            Get vFolderFormat sDataPath to sDataPath
93129>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
93132>>>>>            Get _TableNameOnly sRootName to sDatabaseName
93133>>>>>            Move sDatabaseName to sPhysicalFileName
93134>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
93135>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDataPath sPhysicalFileName to bOK
93136>>>>>            Function_Return (bOK = True)
93137>>>>>        End
93137>>>>>>
93137>>>>>
93137>>>>>        Move False to Err
93138>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
93141>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
93142>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
93142>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
93142>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
93143>>>>>
93143>>>>>        Structure_Start hTable
93144>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
93147>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
93150>>>>>        Structure_End hTable (DF_STRUCTEND_OPT_IN_PLACE ior DF_STRUCTEND_OPT_FORCE)
93152>>>>>
93152>>>>>        Function_Return (Err = False)
93153>>>>>    End_Function
93154>>>>>
93154>>>>>    // Checks if the passed Table;
93154>>>>>    // 1) Already has a Filelist entry that points to SQL and
93154>>>>>    // 2) It has an .int file.
93154>>>>>    // If both is True it should already be connected to SQL
93154>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
93156>>>>>        Boolean bExists bRootName
93156>>>>>        String sRootName sDataPath
93156>>>>>        Integer iCount
93156>>>>>
93156>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
93159>>>>>        Move (sRootName contains sDriverID) to bRootName
93160>>>>>
93160>>>>>        Get psDataPathFirstPart to sDataPath
93161>>>>>        Get vFolderExists sDataPath to bExists
93162>>>>>        If (bExists = False) Begin
93164>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
93164>>>>>            Function_Return False
93165>>>>>        End
93165>>>>>>
93165>>>>>
93165>>>>>        Get vFolderFormat sDataPath to sDataPath
93166>>>>>        Get _TableNameOnly sRootName to sRootName
93167>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
93168>>>>>
93168>>>>>        Function_Return (bRootName = True and bExists = True)
93169>>>>>    End_Function
93170>>>>>
93170>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
93172>>>>>        Boolean bViewTableType bOpen bMertechDriver bOK
93172>>>>>        Integer hoSQLHandler
93172>>>>>        Integer iTableCount iNumTables iPos iTableIndex
93172>>>>>        String sTableName sOwner sTableType sLogin sEnumTableName sEnumSchemaName sCurrent_Login
93172>>>>>        Handle hoCliHandler
93172>>>>>        tSQLConnection SQLConnection
93172>>>>>        tSQLConnection SQLConnection
93172>>>>>
93172>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
93175>>>>>        If (bOpen = False) Begin
93177>>>>>            Get AutoConnectionIDLogin to bOK
93178>>>>>            Open hTable
93180>>>>>        End
93180>>>>>>
93180>>>>>
93180>>>>>        Get pSQLConnection to SQLConnection
93181>>>>>        Get phoCLIHandler to hoCliHandler
93182>>>>>        Set psDriverID of hoCliHandler to sDriverID
93183>>>>>
93183>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
93186>>>>>        Get _TableNameOnly sTableName to sTableName
93187>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
93190>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
93191>>>>>
93191>>>>>        For iTableCount from 1 to iNumTables
93197>>>>>>
93197>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
93198>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
93199>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
93201>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
93202>>>>>                Move iNumTables to iTableCount // We're done.
93203>>>>>            End
93203>>>>>>
93203>>>>>        Loop
93204>>>>>>
93204>>>>>
93204>>>>>        Move (sTableType = "VIEW") to bViewTableType
93205>>>>>        If (bOpen = False) Begin
93207>>>>>            Close hTable
93208>>>>>        End
93208>>>>>>
93208>>>>>
93208>>>>>        Function_Return bViewTableType
93209>>>>>    End_Function
93210>>>>>
93210>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
93210>>>>>    //
93210>>>>>    // SQL utility function that returns a database type (string) constant
93210>>>>>    // corresponding to the passed iDbType.
93210>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
93212>>>>>        String sRetval
93212>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
93213>>>>>        Function_Return sRetval
93214>>>>>    End_Function
93215>>>>>
93215>>>>>    // SQL utility function that returns a database type constant (integer)
93215>>>>>    // corresponding to the passed sDbType string constant.
93215>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
93217>>>>>        Integer iRetval
93217>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
93218>>>>>        Function_Return iRetval
93219>>>>>    End_Function
93220>>>>>
93220>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
93220>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
93220>>>>>    // the SQL Connection program's grid.
93220>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
93222>>>>>        String sRetval
93222>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
93223>>>>>        Function_Return sRetval
93224>>>>>    End_Function
93225>>>>>
93225>>>>>    // Pass a driver name as a string and the function will return
93225>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
93225>>>>>    // quite work and always returns "MS SQL Server"
93225>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
93227>>>>>        Integer iRetval
93227>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
93228>>>>>        Function_Return iRetval
93229>>>>>    End_Function
93230>>>>>
93230>>>>>    // *** Helper Functions ***
93230>>>>>    // They all start with an underscore: "_" in the function name.
93230>>>>>    //
93230>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
93230>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
93230>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
93230>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
93232>>>>>        Integer iChannel iArgumentSize iOut iChunk iPointer iCount iSize
93232>>>>>        Number nByteCount
93232>>>>>        String sCharacter sSQLScript
93232>>>>>        Boolean bSeqEof
93232>>>>>        tSQLScriptArray SqlScriptArray
93232>>>>>        tSQLScriptArray SqlScriptArray
93232>>>>>        UChar[] uCharData
93233>>>>>
93233>>>>>        Move False to Err
93234>>>>>        Get Seq_New_Channel to iChannel
93235>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93237>>>>>            Error DFERR_PROGRAM 'No channel available...'
93238>>>>>>
93238>>>>>            Move True to SqlScriptArray.bError
93239>>>>>            Function_Return SqlScriptArray
93240>>>>>        End
93240>>>>>>
93240>>>>>
93240>>>>>        // First decide the size of the script
93240>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
93242>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
93244>>>>>        Close_Input channel iChannel
93246>>>>>
93246>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
93247>>>>>        If (nByteCount  < 1) Begin
93249>>>>>            Send Seq_Release_Channel iChannel
93250>>>>>            Move True to SqlScriptArray.bError
93251>>>>>            Function_Return SqlScriptArray
93252>>>>>        End
93252>>>>>>
93252>>>>>
93252>>>>>        // If necessary change the string argument_size
93252>>>>>        Get_Argument_Size to iArgumentSize
93253>>>>>        If (nByteCount >= iArgumentSize) Begin
93255>>>>>            Move (nByteCount + 2048) to nByteCount
93256>>>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
93257>>>>>>
93257>>>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
93258>>>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
93259>>>>>        End
93259>>>>>>
93259>>>>>        Else Begin
93260>>>>>            Move False to SqlScriptArray.bArgumentSizeChanged
93261>>>>>        End
93261>>>>>>
93261>>>>>
93261>>>>>        // Read the script file from memory line-by-line
93261>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
93263>>>>>            Move 0 to iCount
93264>>>>>            Repeat
93264>>>>>>
93264>>>>>                Readln channel iChannel sSQLScript
93266>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
93267>>>>>                Increment iCount
93268>>>>>            Until (SeqEof = True)
93270>>>>>        Close_Input channel iChannel
93272>>>>>        Send Seq_Release_Channel iChannel
93273>>>>>
93273>>>>>        // Finally "sanitize" the script by removing all comments.
93273>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
93274>>>>>
93274>>>>>        Function_Return SqlScriptArray
93275>>>>>    End_Function
93276>>>>>
93276>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
93278>>>>>        String sSQLVal sStmt sCR sDebugFileName sTmp sGOKeyWord sNoCountKeyWord sMessage sExportFile
93278>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
93278>>>>>        Integer i iMsgs iFetchResult iResultCount iRows iRowType iCount iChunkCounter iChunkMax iPos iOut iNextSet iMessage
93278>>>>>        String[] sMsg aSQLQueryMessages
93280>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
93280>>>>>        TimeSpan tsQuery
93280>>>>>        tSqlErrorArray aSqlErrorArray
93280>>>>>        tSqlErrorArray aSqlErrorArray
93280>>>>>        tSQLConnection SQLConnection
93280>>>>>        tSQLConnection SQLConnection
93280>>>>>        Boolean bOK bMertechDriver bShowProgress
93280>>>>>
93280>>>>>        If (num_arguments > 4) Begin
93282>>>>>            Move bShowProgr to bShowProgress
93283>>>>>        End
93283>>>>>>
93283>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
93284>>>>>        If (bMertechDriver = False) Begin
93286>>>>>            Get phoSQLManager to hoSql
93287>>>>>        End
93287>>>>>>
93287>>>>>        Else Begin
93288>>>>>            Get _MertechSQLManagerHandle to hoSql
93289>>>>>        End
93289>>>>>>
93289>>>>>
93289>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
93290>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
93290>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
93290>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
93290>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
93290>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
93290>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
93290>>>>>        Get piChunkMax to iChunkMax
93291>>>>>        Move 0 to iChunkCounter
93292>>>>>        Move "" to sStmt
93293>>>>>
93293>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
93294>>>>>        Move (Character(13) + Character(10)) to sCR
93295>>>>>
93295>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93296>>>>>
93296>>>>>        If (bMertechDriver = True) Begin
93298>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
93299>>>>>        End
93299>>>>>>
93299>>>>>        If (bMertechDriver = False) Begin
93301>>>>>            Get phoSQLManager  to hoSQL
93302>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
93303>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
93304>>>>>        End
93304>>>>>>
93304>>>>>
93304>>>>>        If (hoSQLConnect <> 0) Begin
93306>>>>>            Move False to Err
93307>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
93308>>>>>            If (hoStmt <> 0) Begin
93310>>>>>
93310>>>>>                // If the embedded resource should be written as a script file to disk:
93310>>>>>                If (bCreateScriptFile = True) Begin
93312>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
93313>>>>>                    Get vFolderFormat sExportFile to sExportFile
93314>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
93315>>>>>                    Get Seq_New_Channel to iOut
93316>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93318>>>>>                        Direct_Output channel iOut sExportFile
93320>>>>>                    End
93320>>>>>>
93320>>>>>                End
93320>>>>>>
93320>>>>>
93320>>>>>                // Record starting date/time stamp
93320>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
93321>>>>>                // Turn on error handling if enabled
93321>>>>>                If (pbHandleQueryErrors(Self)) Begin
93323>>>>>                    Set pbSqlError to False
93324>>>>>                    Set paSqlErrorArray to aSqlErrorArray
93325>>>>>                    Move Error_Object_Id to hoError
93326>>>>>                    Move Self to Error_Object_Id
93327>>>>>                End
93327>>>>>>
93327>>>>>
93327>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
93328>>>>>                Decrement iRows
93329>>>>>                Move (sNoCountKeyWord + sCR) to sStmt
93330>>>>>
93330>>>>>                For iCount from 0 to iRows
93336>>>>>>
93336>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
93337>>>>>
93337>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
93339>>>>>                        If (sSQLVal <> "") Begin
93341>>>>>                            Move (sSQLVal + sCR) to sSQLVal
93342>>>>>                        End
93342>>>>>>
93342>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
93343>>>>>                    End
93343>>>>>>
93343>>>>>
93343>>>>>                    // - Each time we encounter a "GO" statement we execute it,
93343>>>>>                    // or if at the very end of the script.
93343>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
93345>>>>>
93345>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
93345>>>>>                        // instead of all in one go.
93345>>>>>                        Send SqlExecDirect of hoStmt sStmt
93346>>>>>
93346>>>>>                        If (bCreateScriptFile = True) Begin
93348>>>>>                            Write channel iOut sStmt
93350>>>>>                        End
93350>>>>>>
93350>>>>>                        Move "" to sStmt
93351>>>>>                        Move 0 to iChunkCounter
93352>>>>>                    End
93352>>>>>>
93352>>>>>                    Increment iChunkCounter
93353>>>>>                Loop
93354>>>>>>
93354>>>>>
93354>>>>>                Repeat
93354>>>>>>
93354>>>>>                    If (pbHandleQueryErrors(Self)) Begin
93356>>>>>                        Move hoError to Error_Object_Id
93357>>>>>                    End
93357>>>>>>
93357>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
93358>>>>>
93358>>>>>                    Send _SqlColumnInfo hoStmt
93359>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
93360>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
93361>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
93362>>>>>                    Set piRows    to iRows
93363>>>>>                    Set piRowType to iRowType
93364>>>>>
93364>>>>>                    If (iMsgs <> 0) Begin
93366>>>>>                        If (ghoDbUpdateHandler > 0) Begin
93368>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
93369>>>>>                        End
93369>>>>>>
93369>>>>>                        For i from 1 to iMsgs
93375>>>>>>
93375>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
93376>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
93377>>>>>                            If (bShowProgress = True) Begin
93379>>>>>                                If (Active_State(ghoStatusPanel)) Begin
93381>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
93382>>>>>                                End
93382>>>>>>
93382>>>>>                                Else Begin
93383>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
93385>>>>>                                End
93385>>>>>>
93385>>>>>                            End
93385>>>>>>
93385>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
93386>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
93387>>>>>                        Loop
93388>>>>>>
93388>>>>>
93388>>>>>
93388>>>>>                        If (ghoDbUpdateHandler > 0) Begin
93390>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
93391>>>>>                        End
93391>>>>>>
93391>>>>>                        Set paQueryMessages to sMsg
93392>>>>>                    End
93392>>>>>>
93392>>>>>
93392>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
93393>>>>>                Until (iNextSet = 0)
93395>>>>>
93395>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
93396>>>>>            End
93396>>>>>>
93396>>>>>
93396>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
93397>>>>>            Set ptsQueryExec to tsQuery
93398>>>>>            Send SqlClose of hoStmt
93399>>>>>
93399>>>>>            If (bCreateScriptFile = True) Begin
93401>>>>>                Close_Output channel iOut
93403>>>>>                Send Seq_Release_Channel iOut
93404>>>>>            End
93404>>>>>>
93404>>>>>        End
93404>>>>>>
93404>>>>>        Send SqlDisconnect of hoSQLConnect
93405>>>>>
93405>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
93406>>>>>    End_Function
93407>>>>>
93407>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
93407>>>>>    // for DAW drivers.
93407>>>>>    // Returns: A string array.
93407>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
93409>>>>>        String[] sReturnArray
93410>>>>>        String sValue sPrevious
93410>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
93410>>>>>        Integer iFetchResult iRows
93410>>>>>        tSQLConnection SQLConnection
93410>>>>>        tSQLConnection SQLConnection
93410>>>>>
93410>>>>>        Get phoSQLManager to hoSQLHandler
93411>>>>>
93411>>>>>        If (hoSQLHandler <> 0) Begin
93413>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93414>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
93415>>>>>
93415>>>>>            If (hoSQLConnect <> 0) Begin
93417>>>>>                Get SQLOpen of hoSQLConnect to hstmt
93418>>>>>                If (hstmt <> 0) Begin
93420>>>>>                    Send SqlExecDirect of hstmt sStmt
93421>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
93422>>>>>                    Repeat
93422>>>>>>
93422>>>>>                        Get SQLFetch of hstmt to iFetchResult
93423>>>>>                        If (iFetchResult <> 0) Begin
93425>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
93426>>>>>                            If (sValue <> sPrevious) Begin
93428>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
93429>>>>>                            End
93429>>>>>>
93429>>>>>                            Move sValue to sPrevious
93430>>>>>                        End
93430>>>>>>
93430>>>>>                    Until (iFetchResult = 0)
93432>>>>>                    Send SQLClose of hstmt
93433>>>>>                End
93433>>>>>>
93433>>>>>                Send SQLDisconnect of hoSQLConnect
93434>>>>>            End
93434>>>>>>
93434>>>>>        End
93434>>>>>>
93434>>>>>
93434>>>>>        Function_Return sReturnArray
93435>>>>>    End_Function
93436>>>>>
93436>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
93436>>>>>    // for Mertech drivers.
93436>>>>>    // Returns: A string array.
93436>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
93438>>>>>        String[] sReturnArray
93439>>>>>        String sValue sUserID sPassword
93439>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
93439>>>>>        Integer iFetchResult iRows
93439>>>>>        tSQLConnection SQLConnection
93439>>>>>        tSQLConnection SQLConnection
93439>>>>>
93439>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
93440>>>>>
93440>>>>>        If (hoSQLHandler <> 0) Begin
93442>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93443>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
93444>>>>>
93444>>>>>            If (hoSQLConnect <> 0) Begin
93446>>>>>                Get SQLOpen of hoSQLConnect to hStmt
93447>>>>>                If (hStmt <> 0) Begin
93449>>>>>                    Send SqlExecDirect of hStmt sStmt
93450>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
93451>>>>>                    Repeat
93451>>>>>>
93451>>>>>                        Get SQLFetch of hStmt to iFetchResult
93452>>>>>                        If (iFetchResult <> 0) Begin
93454>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
93455>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
93456>>>>>                        End
93456>>>>>>
93456>>>>>                    Until (iFetchResult = 0)
93458>>>>>                    Send SQLClose of hStmt
93459>>>>>                End
93459>>>>>>
93459>>>>>                Send SQLDisconnect of hoSQLConnect
93460>>>>>            End
93460>>>>>>
93460>>>>>        End
93460>>>>>>
93460>>>>>
93460>>>>>        Function_Return sReturnArray
93461>>>>>    End_Function
93462>>>>>
93462>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
93462>>>>>    // will be used.
93462>>>>>    Function SqlUtilBackupDatabaseToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
93464>>>>>        Boolean bOK bExists bShowProgress
93464>>>>>        String sStatement sDriverID
93464>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
93464>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
93464>>>>>        Integer iDbType
93464>>>>>
93464>>>>>        If (sDatabase = "") Begin
93466>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
93467>>>>>>
93467>>>>>            Function_Return False
93468>>>>>        End
93468>>>>>>
93468>>>>>        If (sBackupName = "") Begin
93470>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
93471>>>>>>
93471>>>>>            Function_Return False
93472>>>>>        End
93472>>>>>>
93472>>>>>
93472>>>>>        // Create backup-folder if it doesn't exist
93472>>>>>        Get vFolderExists sPath to bExists
93473>>>>>        If (bExists = False) Begin
93475>>>>>            Get vCreateDirectory sPath to bOK
93476>>>>>            If (bOK = False) Begin
93478>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
93479>>>>>>
93479>>>>>                Function_Return False
93480>>>>>            End
93480>>>>>>
93480>>>>>        End
93480>>>>>>
93480>>>>>        // Make sure the path ends with a back-slash
93480>>>>>        If (sPath <> "") Begin
93482>>>>>            Get vFolderFormat sPath to sPath
93483>>>>>        End
93483>>>>>>
93483>>>>>
93483>>>>>        Get psDriverID to sDriverID
93484>>>>>        Get piDbType   to iDbType
93485>>>>>        If (num_arguments > 3) Begin
93487>>>>>            Move bShowProg to bShowProgress
93488>>>>>        End
93488>>>>>>
93488>>>>>
93488>>>>>        Case Begin
93488>>>>>            Case (iDbType = EN_DbTypeMSSQL)
93490>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
93490>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
93490>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
93491>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
93492>>>>>
93492>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
93493>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
93494>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
93495>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
93496>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
93497>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
93498>>>>>                Case Break
93499>>>>>            Case Else
93499>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
93500>>>>>        Case End
93500>>>>>
93500>>>>>        Function_Return bOK
93501>>>>>    End_Function
93502>>>>>
93502>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
93502>>>>>    // that "fits" in the max allowed length for table names.
93502>>>>>    // Max number of characters allowed for table names;
93502>>>>>    // IBM DB2      = 128
93502>>>>>    // MS-SQL       = 128
93502>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
93502>>>>>    // MySQL        = 64
93502>>>>>    // PostgreSQL   = 64
93502>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
93504>>>>>        String sGUIDName
93504>>>>>        Integer iDbType iLength
93504>>>>>        
93504>>>>>        Get piDbType to iDbType
93505>>>>>        Move (RandomHexUUID()) to sGUIDName
93506>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
93507>>>>>        Move (Length(sGUIDName)) to iLength
93508>>>>>        
93508>>>>>        Case Begin
93508>>>>>            Case (iDbType = EN_DbTypeDB2)
93510>>>>>            If (iLength > 128) Begin
93512>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
93513>>>>>            End
93513>>>>>>
93513>>>>>            Case Break
93514>>>>>
93514>>>>>            Case (iDbType = EN_DbTypeMSSQL)
93517>>>>>            If (iLength > 128) Begin
93519>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
93520>>>>>            End
93520>>>>>>
93520>>>>>            Case Break
93521>>>>>
93521>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
93524>>>>>            If (iLength > 128) Begin
93526>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
93527>>>>>            End
93527>>>>>>
93527>>>>>            Case Break
93528>>>>>
93528>>>>>            Case (iDbType = EN_DbTypeMySQL)
93531>>>>>            If (iLength > 64) Begin
93533>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
93534>>>>>            End
93534>>>>>>
93534>>>>>            Case Break
93535>>>>>
93535>>>>>            Case (iDbType = EN_DbTypePostgre)
93538>>>>>            If (iLength > 64) Begin
93540>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
93541>>>>>            End
93541>>>>>>
93541>>>>>        Case End
93541>>>>>       
93541>>>>>        Function_Return sGUIDName   
93542>>>>>    End_Function
93543>>>>>       
93543>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
93543>>>>>    // Pass the memory resource file reference and the filename to be created,
93543>>>>>    // including full path.
93543>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
93545>>>>>        String sText
93545>>>>>        Integer iCh iSize iArgSize
93545>>>>>
93545>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
93546>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
93547>>>>>            Get_Channel_Size iCh to iSize
93548>>>>>            Get_Argument_Size to iArgSize
93549>>>>>            If (iSize > iArgSize) Begin
93551>>>>>                Set_Argument_Size iSize
93552>>>>>>
93552>>>>>            End
93552>>>>>>
93552>>>>>            Read_Block channel iCh sText iSize
93554>>>>>        Send Seq_Close_Channel iCh
93555>>>>>
93555>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
93556>>>>>            Write channel iCh sText
93558>>>>>        Send Seq_Close_Channel iCh
93559>>>>>
93559>>>>>        If (iSize <> iArgSize) Begin
93561>>>>>            Set_Argument_Size iArgSize
93562>>>>>>
93562>>>>>        End
93562>>>>>>
93562>>>>>
93562>>>>>        // Wait for file to be written to disk.
93562>>>>>        Sleep 2
93563>>>>>    End_Procedure
93564>>>>>
93564>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
93566>>>>>        String sNotNull sRetval sDefaultValue
93566>>>>>        Boolean bOK
93566>>>>>
93566>>>>>        Get IsSQLDriver sDriverID to bOK
93567>>>>>        If (bOK = False) Begin
93569>>>>>            Function_Return ""
93570>>>>>        End
93570>>>>>>
93570>>>>>
93570>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
93571>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
93572>>>>>
93572>>>>>        Case Begin
93572>>>>>            Case (iDbType = EN_dbTypeMSSQL)
93574>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
93575>>>>>                Case Break
93576>>>>>            Case (iDbType = EN_dbTypeMySQL)
93579>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
93580>>>>>                Case Break
93581>>>>>            Case (iDbType = EN_dbTypePostgre)
93584>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
93585>>>>>                Case Break
93586>>>>>            Case (iDbType = EN_dbTypeDB2)
93589>>>>>                Move (String(sNotNull))                                     to sRetval
93590>>>>>                Case Break
93591>>>>>
93591>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
93591>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
93591>>>>>            Case (iDbType = EN_dbTypeOracle)
93594>>>>>                Move  ""                                                    to sRetval
93595>>>>>                Case Break
93596>>>>>
93596>>>>>            Case Else
93596>>>>>                Move  ""                                                    to sRetval
93597>>>>>        Case End
93597>>>>>
93597>>>>>        Function_Return sRetval
93598>>>>>    End_Function
93599>>>>>
93599>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
93601>>>>>        String[] sReturnArray
93602>>>>>        String sValue sUserID sPassword
93602>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
93602>>>>>        Integer iFetchResult iRetval
93602>>>>>        tSQLConnection SQLConnection
93602>>>>>        tSQLConnection SQLConnection
93602>>>>>
93602>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
93603>>>>>        If (hoSQLHandler <> 0) Begin
93605>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93606>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
93607>>>>>            If (hoSQLConnect <> 0) Begin
93609>>>>>                Get SQLOpen of hoSQLConnect to hStmt
93610>>>>>                If (hStmt <> 0) Begin
93612>>>>>                    Send SQLSetProcedureName of hStmt sStmt
93613>>>>>                    If (sArgument <> "") Begin
93615>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
93616>>>>>                    End
93616>>>>>>
93616>>>>>                    Send SQLCall of hStmt
93617>>>>>
93617>>>>>                    Get SqlReturnValue       of hStmt to iRetval
93618>>>>>                    If (iRetval = 0) Begin
93620>>>>>                        Repeat
93620>>>>>>
93620>>>>>                            Get SQLFetch of hStmt to iFetchResult
93621>>>>>                            If (iFetchResult <> 0) Begin
93623>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
93624>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
93625>>>>>                            End
93625>>>>>>
93625>>>>>                        Until (iFetchResult = 0)
93627>>>>>                        Send SQLClose of hStmt
93628>>>>>                    End
93628>>>>>>
93628>>>>>                End
93628>>>>>>
93628>>>>>                Send SQLDisconnect of hoSQLConnect
93629>>>>>            End
93629>>>>>>
93629>>>>>        End
93629>>>>>>
93629>>>>>
93629>>>>>        Function_Return sReturnArray
93630>>>>>    End_Function
93631>>>>>
93631>>>>>    // Returns the index for the passed sTableName
93631>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
93631>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
93633>>>>>        Integer iIndex iSize iCount
93633>>>>>        String[] sTablesArray
93634>>>>>        String sVal sConnectionString
93634>>>>>
93634>>>>>        Move -1 to iIndex
93635>>>>>        Get psConnectionString to sConnectionString
93636>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
93637>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
93638>>>>>        Decrement iSize
93639>>>>>        For iCount from 0 to iSize
93645>>>>>>
93645>>>>>            Move sTablesArray[iCount] to sVal
93646>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
93648>>>>>                Move iCount to iIndex // We found it!
93649>>>>>                Move iSize to iCount  // End the loop
93650>>>>>            End
93650>>>>>>
93650>>>>>        Loop
93651>>>>>>
93651>>>>>
93651>>>>>        Function_Return iIndex
93652>>>>>    End_Function
93653>>>>>
93653>>>>>    // Helper function that builds a string like;
93653>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
93653>>>>>    Function _SqlSelectFromWhereName Returns String
93655>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
93655>>>>>
93655>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
93656>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
93657>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
93658>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
93659>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
93660>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
93661>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
93662>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
93663>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
93664>>>>>        Function_Return sRetval
93665>>>>>    End_Function
93666>>>>>
93666>>>>>    // Helper function to create a SQL statement like;
93666>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
93666>>>>>    // Used for checking if an index exists.
93666>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
93668>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
93668>>>>>
93668>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
93669>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
93670>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
93671>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
93672>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
93673>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
93674>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
93675>>>>>
93675>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
93676>>>>>
93676>>>>>        Function_Return sRetval
93677>>>>>    End_Function
93678>>>>>
93678>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
93678>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
93678>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
93680>>>>>        String sRetval
93680>>>>>        If (iLength <> 0) Begin
93682>>>>>            Move ("(" + String(iLength)) to sRetval
93683>>>>>            If (iDecimals <> 0) Begin
93685>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
93686>>>>>            End
93686>>>>>>
93686>>>>>            Move (sRetval + ")") to sRetval
93687>>>>>        End
93687>>>>>>
93687>>>>>        Function_Return sRetval
93688>>>>>    End_Function
93689>>>>>
93689>>>>>    Procedure _SqlColumnInfo Handle hoStmt
93691>>>>>        Integer i iCols iItem
93691>>>>>        tSqlColumnNew[] aQueryColumns
93691>>>>>        tSqlColumnNew[] aQueryColumns
93692>>>>>
93692>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
93693>>>>>        For i from 1 to iCols
93699>>>>>>
93699>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
93700>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
93701>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
93702>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
93703>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
93704>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
93705>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
93706>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
93707>>>>>        Loop
93708>>>>>>
93708>>>>>        Set piColumns to iCols
93709>>>>>        Set paQueryColumns to aQueryColumns
93710>>>>>    End_Procedure
93711>>>>>
93711>>>>>    // Checks that the passed sDriverID is defined.
93711>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
93711>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
93713>>>>>        Boolean bOK
93713>>>>>        Integer iDriver
93713>>>>>
93713>>>>>        If (sDriverID = DATAFLEX_ID) Begin
93715>>>>>            Function_Return False
93716>>>>>        End
93716>>>>>>
93716>>>>>
93716>>>>>        Get IsDAWSQLDriver sDriverID to bOK
93717>>>>>
93717>>>>>        If (bOK = False) Begin
93719>>>>>            Get IsMertechDriver sDriverID to bOK
93720>>>>>        End
93720>>>>>>
93720>>>>>
93720>>>>>        If (bOK = False) Begin
93722>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
93723>>>>>>
93723>>>>>            Function_Return False
93724>>>>>        End
93724>>>>>>
93724>>>>>
93724>>>>>        Get DriverIndex sDriverID to iDriver
93725>>>>>        If (iDriver = 0) Begin
93727>>>>>            Load_Driver sDriverID
93728>>>>>        End
93728>>>>>>
93728>>>>>
93728>>>>>        Function_Return True
93729>>>>>    End_Function
93730>>>>>
93730>>>>>    // Checks that the length parameter has been passed correctly.
93730>>>>>    // This is only of concern for certain SQL data types.
93730>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
93732>>>>>        Integer iLength
93732>>>>>        Boolean bOK bCheckTypeLength
93732>>>>>
93732>>>>>        If (num_arguments > 1) Begin
93734>>>>>            Move iLen to iLength
93735>>>>>        End
93735>>>>>>
93735>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
93736>>>>>
93736>>>>>        If (bCheckTypeLength = True) Begin
93738>>>>>            Move (iLength > 0) to bOK
93739>>>>>        End
93739>>>>>>
93739>>>>>
93739>>>>>        Function_Return (bOK = True)
93740>>>>>    End_Function
93741>>>>>
93741>>>>>    Function _SqlProperTableName String sTableName Returns String
93743>>>>>        String sVal sSchema sDriverID sValue
93743>>>>>        Handle hTable
93743>>>>>        Integer iDbType
93743>>>>>
93743>>>>>        If (Trim(sTableName) = "") Begin
93745>>>>>            Function_Return ""
93746>>>>>        End
93746>>>>>>
93746>>>>>
93746>>>>>        Get psDriverID to sDriverID
93747>>>>>        Get piDbType   to iDbType
93748>>>>>        If (iDbType = EN_dbTypeOracle) Begin
93750>>>>>            Get psUserID to sSchema
93751>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
93751>>>>>            Move (Uppercase(sSchema)) to sSchema
93752>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
93753>>>>>            Function_Return sTableName
93754>>>>>        End
93754>>>>>>
93754>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
93756>>>>>            Get psDatabase to sVal
93757>>>>>            Move (sVal + "." + sTableName) to sTableName
93758>>>>>            Function_Return sTableName
93759>>>>>        End
93759>>>>>>
93759>>>>>        If (iDbType = EN_DbTypePostgre) Begin
93761>>>>>            Move ('"' + sTableName + '"') to sTableName
93762>>>>>            Function_Return sTableName
93763>>>>>        End
93763>>>>>>
93763>>>>>
93763>>>>>        Get psSchema to sSchema
93764>>>>>        If (sSchema = "") Begin
93766>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
93767>>>>>        End
93767>>>>>>
93767>>>>>
93767>>>>>        Move (Uppercase(sTableName)) to sVal
93768>>>>>        If (not(sVal contains (sSchema + "."))) Begin
93770>>>>>            If (iDbType = EN_dbTypeDB2) Begin
93772>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
93773>>>>>            End
93773>>>>>>
93773>>>>>            Else Begin
93774>>>>>                Move (sSchema + "." + sTableName) to sTableName
93775>>>>>            End
93775>>>>>>
93775>>>>>        End
93775>>>>>>
93775>>>>>
93775>>>>>        Function_Return sTableName
93776>>>>>    End_Function
93777>>>>>
93777>>>>>    // SQL column names can be case-sensitive. This function is used to check that
93777>>>>>    // the passed sFieldName has the correct spelling.
93777>>>>>    // Used with Embedded SQL statement calls.
93777>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
93777>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
93779>>>>>        String sRetval sValue sConnectionString sDriverID
93779>>>>>        String[] sColumnNamesArray
93780>>>>>        Integer iCount iColumns
93780>>>>>
93780>>>>>        Move "" to sRetval
93781>>>>>        Get psDriverID to sDriverID
93782>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
93783>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
93784>>>>>        Decrement iColumns
93785>>>>>
93785>>>>>        For iCount from 0 to iColumns
93791>>>>>>
93791>>>>>            Move sColumnNamesArray[iCount] to sValue
93792>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
93794>>>>>                Move sValue to sRetval
93795>>>>>                Move iColumns to iCount // We're done.
93796>>>>>            End
93796>>>>>>
93796>>>>>        Loop
93797>>>>>>
93797>>>>>
93797>>>>>        Function_Return sRetval
93798>>>>>    End_Function
93799>>>>>
93799>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
93801>>>>>        String[] sReturnArray
93802>>>>>        Handle hoSQLHandler
93802>>>>>        Integer iCount iSize iItem
93802>>>>>        String sServer sUser sPassword
93802>>>>>        tSQLConnection SQLConnection
93802>>>>>        tSQLConnection SQLConnection
93802>>>>>
93802>>>>>        Get phoMSSQLHandler to hoSQLHandler
93803>>>>>        Send Delete_Data    of hoSQLHandler
93804>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
93805>>>>>
93805>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93806>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
93807>>>>>        Decrement iSize
93808>>>>>
93808>>>>>        For iCount from 0 to iSize
93814>>>>>>
93814>>>>>            Get String_Value of hoSQLHandler item iCount to sServer
93815>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
93816>>>>>            Increment iItem
93817>>>>>        Loop
93818>>>>>>
93818>>>>>
93818>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93819>>>>>
93819>>>>>        Function_Return sReturnArray
93820>>>>>    End_Function
93821>>>>>
93821>>>>>    Function _SqlTableArrayDAW Returns String[]
93823>>>>>        String[] sReturnArray
93824>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord
93824>>>>>        Handle hoSQLHandler
93824>>>>>        Integer iCount iSize iItem
93824>>>>>        Boolean bOK
93824>>>>>        tSQLConnection SQLConnection
93824>>>>>        tSQLConnection SQLConnection
93824>>>>>
93824>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93825>>>>>        If (SQLConnection.sConnectionString = "") Begin
93827>>>>>            Function_Return sReturnArray
93828>>>>>        End
93828>>>>>>
93828>>>>>
93828>>>>>        Move SQLConnection.sSchema      to sDefSchema
93829>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
93830>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
93831>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
93832>>>>>
93832>>>>>        Get phoCLIHandler to hoSQLHandler
93833>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
93834>>>>>        Send Delete_Data  of hoSQLHandler
93835>>>>>
93835>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93836>>>>>        Get EnumerateTables of hoSQLHandler SQLConnection.sConnectionString to iSize
93837>>>>>        Move False to Err
93838>>>>>        Decrement iSize
93839>>>>>
93839>>>>>        For iCount from 0 to iSize
93845>>>>>>
93845>>>>>            Get TableName    of hoSQLHandler iCount to sTable
93846>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
93847>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
93848>>>>>            Get TableComment of hoSQLHandler iCount to sComment
93849>>>>>            Move (Trim(sTable)) to sTable
93850>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
93852>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
93853>>>>>            End
93853>>>>>>
93853>>>>>            Else Begin
93854>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
93855>>>>>            End
93855>>>>>>
93855>>>>>            If (bOK = True) Begin
93857>>>>>                Move sTable to sReturnArray[iItem]
93858>>>>>                Increment iItem
93859>>>>>            End
93859>>>>>>
93859>>>>>        Loop
93860>>>>>>
93860>>>>>
93860>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93861>>>>>
93861>>>>>        Function_Return sReturnArray
93862>>>>>    End_Function
93863>>>>>
93863>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
93865>>>>>        String[] sReturnArray
93866>>>>>        String sValue
93866>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
93866>>>>>        Integer iRetval iCols iFetchResult
93866>>>>>        tSQLConnection SQLConnection
93866>>>>>        tSQLConnection SQLConnection
93866>>>>>
93866>>>>>        Get phoSQLManager to hoSQLHandler
93867>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
93868>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
93869>>>>>
93869>>>>>        If (hoSQLConnect <> 0) Begin
93871>>>>>            Get SqlOpen of hoSQLConnect to hStmt
93872>>>>>            If (hStmt <> 0) Begin
93874>>>>>                Send SqlSetProcedurename of hStmt sStmt
93875>>>>>                If (sArgument <> "") Begin
93877>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
93878>>>>>                End
93878>>>>>>
93878>>>>>
93878>>>>>                Send SqlCall             of hStmt
93879>>>>>                Get SqlReturnValue       of hStmt to iRetval
93880>>>>>                If (iRetval = 0) Begin
93882>>>>>                    Repeat
93882>>>>>>
93882>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
93883>>>>>                        If (iCols > 0) Begin
93885>>>>>                            Repeat
93885>>>>>>
93885>>>>>                                Get SqlFetch of hStmt to iFetchResult
93886>>>>>                                If (iFetchResult <> 0) Begin
93888>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
93889>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
93890>>>>>                                End
93890>>>>>>
93890>>>>>                            Until (iFetchResult = 0)
93892>>>>>                        End
93892>>>>>>
93892>>>>>                        Get SqlNextResultSet of hStmt to iRetval
93893>>>>>                    Until (iRetval = 0)
93895>>>>>                    Send SqlClose of hStmt
93896>>>>>                End
93896>>>>>>
93896>>>>>            End
93896>>>>>>
93896>>>>>            Send SqlDisconnect of hoSQLConnect
93897>>>>>        End
93897>>>>>>
93897>>>>>        Function_Return sReturnArray
93898>>>>>    End_Function
93899>>>>>
93899>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
93901>>>>>        String[] sReturnArray
93902>>>>>        String sDataSource
93902>>>>>        Handle hoSQLHandler
93902>>>>>        Integer iItem
93902>>>>>
93902>>>>>        Get phoDB2SQLHandler to hoSQLHandler
93903>>>>>        Send SeedDataSources of hoSQLHandler
93904>>>>>
93904>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93905>>>>>
93905>>>>>        Repeat
93905>>>>>>
93905>>>>>            Get DataSources of hoSQLHandler to sDataSource
93906>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
93907>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
93908>>>>>            Increment iItem
93909>>>>>        Until (sDataSource = "")
93911>>>>>
93911>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93912>>>>>
93912>>>>>        Function_Return sReturnArray
93913>>>>>    End_Function
93914>>>>>
93914>>>>>    Function _SqlDatabasesArrayODBC Returns String[]
93916>>>>>        String[] sReturnArray
93917>>>>>        String sDataSource
93917>>>>>        Handle hoSQLHandler
93917>>>>>        Integer iItem
93917>>>>>
93917>>>>>        Get phoODBCSQLHandler to hoSQLHandler
93918>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93919>>>>>
93919>>>>>        Send SeedDataSources of hoSQLHandler
93920>>>>>
93920>>>>>        Repeat
93920>>>>>>
93920>>>>>            Get DataSources of hoSQLHandler to sDataSource
93921>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
93923>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
93924>>>>>                Increment iItem
93925>>>>>            End
93925>>>>>>
93925>>>>>        Until (sDataSource = "")
93927>>>>>
93927>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
93928>>>>>
93928>>>>>        Function_Return sReturnArray
93929>>>>>    End_Function
93930>>>>>
93930>>>>>    // We might have a split Sql script where the info about which database to use is
93930>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
93930>>>>>    // insert it for scriplets to come after the first one.
93930>>>>>    Function _SqlFormatStatement String sStmt Returns String
93932>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
93932>>>>>        Integer iStart iEnd iDbType
93932>>>>>        Boolean bOK
93932>>>>>
93932>>>>>        Get piDbType to iDbType
93933>>>>>        Get psDriverID to sDriverID
93934>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
93935>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
93936>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
93937>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
93938>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
93939>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
93941>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
93942>>>>>            Move (Pos("]", sTmp)) to iEnd
93943>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
93944>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
93945>>>>>            Set Private.psUseDatabase to sUseDatabase
93946>>>>>        End
93946>>>>>>
93946>>>>>        Else Begin
93947>>>>>            Move (Uppercase(sStmt)) to sTmp
93948>>>>>
93948>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
93948>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
93950>>>>>                Get Private.psUseDatabase to sUseDatabase
93951>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
93952>>>>>            End
93952>>>>>>
93952>>>>>
93952>>>>>            // This is a bit special to place here but was done so because it was easier that way.
93952>>>>>            // We will get an error when trying to create a view if it already exists.
93952>>>>>            // So to avoid such errors; we first remove it & then recreate it.
93952>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
93955>>>>>                // Make sure we only have one space between statements/words.
93955>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
93956>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
93957>>>>>                Move (Trim(sTmp)) to sTmp
93958>>>>>                Move (Pos(" ", sTmp)) to iEnd
93959>>>>>                Move (Left(sTmp, iEnd)) to sTmp
93960>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
93962>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
93963>>>>>                End
93963>>>>>>
93963>>>>>                Move (Trim(sTmp)) to sTmp
93964>>>>>                // Remove data view as it already exists!
93964>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
93965>>>>>            End
93965>>>>>>
93965>>>>>        End
93965>>>>>>
93965>>>>>
93965>>>>>        Function_Return sStmt
93966>>>>>    End_Function
93967>>>>>
93967>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
93967>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
93969>>>>>        String sRetval
93969>>>>>        Integer iDbType iSize iItem iIndex
93969>>>>>        tSQLKeyWords[] SQLKeywordArray
93969>>>>>        tSQLKeyWords[] SQLKeywordArray
93970>>>>>        tSQLKeyWords   SQLKeyWords
93970>>>>>        tSQLKeyWords   SQLKeyWords
93970>>>>>
93970>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
93970>>>>>        Get piDbType to iDbType
93971>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
93972>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
93973>>>>>
93973>>>>>        Get paSQLKeywordArray to SQLKeywordArray
93974>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
93975>>>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
93976>>>>>
93976>>>>>        Function_Return sRetval
93977>>>>>    End_Function
93978>>>>>
93978>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
93978>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
93980>>>>>        String[] sSQLScriptArray
93981>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
93981>>>>>        Integer iCh iSize iArgSize iPos iCount
93981>>>>>        Boolean bCommentStart bCommentEnd bDashComment
93981>>>>>
93981>>>>>        Move False to bCommentStart
93982>>>>>        Move False to bCommentEnd
93983>>>>>        Move False to bDashComment
93984>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
93985>>>>>        Move "*/"  to sCommentEnd
93986>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
93987>>>>>
93987>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
93988>>>>>        Decrement iSize
93989>>>>>        Move "" to sText
93990>>>>>
93990>>>>>        For iCount from 0 to iSize
93996>>>>>>
93996>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
93997>>>>>            Move (Trim(sLine)) to sTmp
93998>>>>>            If (sTmp <> "") Begin
94000>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
94001>>>>>                If (bCommentStart = False) Begin
94003>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
94004>>>>>                    If (bCommentStart = False) Begin
94006>>>>>                    End
94006>>>>>>
94006>>>>>                End
94006>>>>>>
94006>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
94007>>>>>                If (bCommentEnd = True) Begin
94009>>>>>                    Move False to bCommentStart
94010>>>>>                End
94010>>>>>>
94010>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
94012>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
94013>>>>>                End
94013>>>>>>
94013>>>>>            End
94013>>>>>>
94013>>>>>        Loop
94014>>>>>>
94014>>>>>
94014>>>>>        // Update the retval struct array:
94014>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
94015>>>>>        Function_Return SqlScriptArray
94016>>>>>    End_Function
94017>>>>>    
94017>>>>>
94017>>>>>    // *** Database API Functions: ***
94017>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
94017>>>>>    // make changes/updates to the database.
94017>>>>>    //
94017>>>>>    //
94017>>>>>    // This might not do what you think - Here's what it does:
94017>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
94017>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
94017>>>>>    // to the SQL table.
94017>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
94017>>>>>    // already exists in SQL.
94017>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
94017>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
94017>>>>>    // restructuring an existing table.
94017>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
94019>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
94019>>>>>        String sDriverID sTableName sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
94019>>>>>        Handle hToTable
94019>>>>>        Integer iPos
94019>>>>>
94019>>>>>        Move True to bUseConnectionID
94020>>>>>        If (num_arguments > 1) Begin
94022>>>>>            Move bUseConnID to bUseConnectionID
94023>>>>>        End
94023>>>>>>
94023>>>>>
94023>>>>>        Get psDriverID to sDriverID
94024>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
94024>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
94025>>>>>        If (bExists = False) Begin
94027>>>>>            Function_Return False
94028>>>>>        End
94028>>>>>>
94028>>>>>
94028>>>>>        Get UtilTableIsAlias hTable to bIsAlias
94029>>>>>        
94029>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
94030>>>>>        If (bOK = False) Begin
94032>>>>>            Function_Return False
94033>>>>>        End
94033>>>>>>
94033>>>>>
94033>>>>>        // Then we need to check that the function hasn't been called before; which in case
94033>>>>>        // we do nothing
94033>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
94034>>>>>        If (bExists = True) Begin
94036>>>>>            Function_Return False
94037>>>>>        End
94037>>>>>>
94037>>>>>
94037>>>>>        Get psConnectionID     to sConnectionID
94038>>>>>        Get psConnectionString to sConnectionString
94039>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
94041>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
94042>>>>>>
94042>>>>>            Function_Return False
94043>>>>>        End
94043>>>>>>
94043>>>>>
94043>>>>>        Get psSchema to sSchema
94044>>>>>        If (sSchema = "") Begin
94046>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
94047>>>>>        End
94047>>>>>>
94047>>>>>
94047>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
94048>>>>>
94048>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
94048>>>>>        // was a programmer's error and we adjust for it here.
94048>>>>>        If (bMertechDriver = True) Begin
94050>>>>>            Move False to bUseConnectionID
94051>>>>>        End
94051>>>>>>
94051>>>>>
94051>>>>>        // If we should use a connection id we need to check it exists;
94051>>>>>        // else we create it before attempting creating the table
94051>>>>>        If (bUseConnectionID = True) Begin
94053>>>>>            Get AutoConnectionIDLogin to bOK
94054>>>>>            If (bOk = False) Begin
94056>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
94057>>>>>>
94057>>>>>                Function_Return False
94058>>>>>            End
94058>>>>>>
94058>>>>>        End
94058>>>>>>
94058>>>>>
94058>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94061>>>>>        Get _TableNameOnly sRootName to sRootName
94062>>>>>        If (sRootName = "") Begin
94064>>>>>            Function_Return False
94065>>>>>        End
94065>>>>>>
94065>>>>>        Move (sRootName + ".int")                    to sPhysicalName
94066>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94069>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName  
94072>>>>>
94072>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
94072>>>>>        // because then the table should not be visible to users.
94072>>>>>        Move (Pos("@", sDisplayName)) to iPos
94073>>>>>        If (iPos <> 1) Begin
94075>>>>>            If (sDisplayName contains ".") Begin
94077>>>>>                Move (Pos(".", sDisplayName)) to iPos
94078>>>>>                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
94079>>>>>                Move (sSchema + "." + sDisplayName)       to sDisplayName
94080>>>>>            End
94080>>>>>>
94080>>>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
94082>>>>>                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
94083>>>>>            End
94083>>>>>>
94083>>>>>        End
94083>>>>>>
94083>>>>>
94083>>>>>        If (bIsAlias = False) Begin
94085>>>>>            Get OpenTableExclusive hTable to bOpened
94086>>>>>            If (bOpened = False) Begin
94088>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
94089>>>>>>
94089>>>>>                Function_Return False
94090>>>>>            End
94090>>>>>>
94090>>>>>        End
94090>>>>>>
94090>>>>>
94090>>>>>        If (ghoProgressBar <> 0) Begin
94092>>>>>            Send DoAdvance of ghoProgressBar
94093>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
94094>>>>>        End
94094>>>>>>
94094>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
94094>>>>>        Move hTable to hToTable
94095>>>>>        Move False to Err
94096>>>>>
94096>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
94096>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
94096>>>>>        // a proper and updated .int file.
94096>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
94099>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
94100>>>>>        
94100>>>>>        If (bIsAlias = False) Begin
94102>>>>>            Structure_Start hToTable sDriverID
94103>>>>>                If (bUseConnectionID = True) Begin
94105>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
94108>>>>>                End
94108>>>>>>
94108>>>>>                Else Begin
94109>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
94112>>>>>                End
94112>>>>>>
94112>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
94115>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
94115>>>>>                Move False to Err
94116>>>>>                Move 0 to LastErr
94117>>>>>            Structure_End hToTable
94119>>>>>        End
94119>>>>>>
94119>>>>>
94119>>>>>        Move (not(Err)) to bOK
94120>>>>>        If (bOK = True) Begin
94122>>>>>            // The attributes set above will always trigger an error
94122>>>>>            // We also adjust the Filelist entries
94122>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
94125>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94128>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
94131>>>>>
94131>>>>>            // This pseudo updates the .int file to make it up-to-date with the SQL back-end.
94131>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
94132>>>>>        End
94132>>>>>>
94132>>>>>
94132>>>>>        Function_Return (bOK = True)
94133>>>>>    End_Function
94134>>>>>
94134>>>>>    // Sample usage:
94134>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
94134>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
94134>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
94136>>>>>        Boolean bOK
94136>>>>>
94136>>>>>        Get AutoConnectionIDLogin to bOK
94137>>>>>        Move False to Err
94138>>>>>        Get OpenTableExclusive hTable to bOK
94139>>>>>        If (bOK = False) Begin
94141>>>>>            Function_Return False
94142>>>>>        End
94142>>>>>>
94142>>>>>        Structure_Start hTable
94143>>>>>            Set_Attribute iAttribute of hTable to iValue
94146>>>>>        Structure_End hTable
94148>>>>>
94148>>>>>        Function_Return (Err = False)
94149>>>>>    End_Function
94150>>>>>
94150>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
94150>>>>>    // or to change the filelist slot names.
94150>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
94152>>>>>        Boolean bExists
94152>>>>>        Integer iPos
94152>>>>>        
94152>>>>>        Move False to Err
94153>>>>>        Get UtilTableNumberIsInUse hTable to bExists
94154>>>>>        If (bExists = False) Begin
94156>>>>>            Function_Return False
94157>>>>>        End
94157>>>>>>
94157>>>>>
94157>>>>>        If (ghoProgressBar <> 0) Begin
94159>>>>>            Send DoAdvance of ghoProgressBar
94160>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
94161>>>>>        End
94161>>>>>>
94161>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
94161>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
94163>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
94166>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
94169>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
94172>>>>>            Function_Return (Err = False) // And we're done.
94173>>>>>        End
94173>>>>>>
94173>>>>>
94173>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94175>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
94178>>>>>        End
94178>>>>>>
94178>>>>>        Else Begin
94179>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94182>>>>>        End
94182>>>>>>
94182>>>>>
94182>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94185>>>>>
94185>>>>>        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
94187>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
94190>>>>>        End
94190>>>>>>
94190>>>>>        Else Begin
94191>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
94194>>>>>        End
94194>>>>>>
94194>>>>>
94194>>>>>        Function_Return (Err = False)
94195>>>>>    End_Function
94196>>>>>
94196>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
94198>>>>>        Boolean bOK
94198>>>>>
94198>>>>>        Get AutoConnectionIDLogin to bOK
94199>>>>>        Move False to Err
94200>>>>>        Get OpenTableExclusive hTable to bOK
94201>>>>>        If (bOK = False) Begin
94203>>>>>            Function_Return False
94204>>>>>        End
94204>>>>>>
94204>>>>>
94204>>>>>        Structure_Start hTable
94205>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
94208>>>>>        Structure_End hTable
94210>>>>>
94210>>>>>        Function_Return (Err = False)
94211>>>>>    End_Function
94212>>>>>
94212>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
94214>>>>>        Boolean bOK
94214>>>>>
94214>>>>>        Move False to Err
94215>>>>>        Get AutoConnectionIDLogin to bOK
94216>>>>>        Open hToTable
94218>>>>>        Get OpenTableExclusive hTable to bOK
94219>>>>>        If (bOK = False) Begin
94221>>>>>            Function_Return False
94222>>>>>        End
94222>>>>>>
94222>>>>>
94222>>>>>        Structure_Start hTable
94223>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
94226>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
94229>>>>>        Structure_End hTable
94231>>>>>
94231>>>>>        Function_Return (Err = False)
94232>>>>>    End_Function
94233>>>>>
94233>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
94235>>>>>        Integer[] iTableConvertExceptions
94236>>>>>        Get piTableConvertExceptions to iTableConvertExceptions
94237>>>>>        Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
94238>>>>>        Set piTableConvertExceptions to iTableConvertExceptions
94239>>>>>    End_Procedure
94240>>>>>
94240>>>>>    Procedure ApiTableConvertALLToSql
94242>>>>>        Integer[] iTablesArray
94243>>>>>        Integer iSize iCount
94243>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
94243>>>>>        String sDriverID
94243>>>>>
94243>>>>>        Get psDriverID to sDriverID
94244>>>>>        Get pbUseConnectionID to bUseConnectionID
94245>>>>>        Get pbToANSI          to bToANSI
94246>>>>>        Get pbRecnum          to bRecnum
94247>>>>>        Get pbCopyData        to bCopyData
94248>>>>>        If (ghoDbUpdateHandler > 0) Begin
94250>>>>>            Get pbContinueOnError to bContinueOnError
94251>>>>>        End
94251>>>>>>
94251>>>>>
94251>>>>>        Get _AllTablesToConvert to iTablesArray
94252>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
94253>>>>>        Decrement iSize
94254>>>>>        For iCount from 0 to iSize
94260>>>>>>
94260>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
94261>>>>>            // Probably the right logic here is to just continue trying to convert every table even
94261>>>>>            // if there was an error converting one table...
94261>>>>>            //If (bContinueOnError = False and bOK = False) Break
94261>>>>>        Loop
94262>>>>>>
94262>>>>>
94262>>>>>    End_Procedure
94263>>>>>
94263>>>>>    Procedure ApiTableAttachALLToSql 
94265>>>>>        Integer[] iTablesArray
94266>>>>>        Integer iSize iCount
94266>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
94266>>>>>        String sDriverID
94266>>>>>
94266>>>>>        Get psDriverID to sDriverID
94267>>>>>        Get pbUseConnectionID to bUseConnectionID
94268>>>>>        Get pbToANSI          to bToANSI
94269>>>>>        Get pbRecnum          to bRecnum
94270>>>>>        Get pbCopyData        to bCopyData
94271>>>>>        If (ghoDbUpdateHandler > 0) Begin
94273>>>>>            Get pbContinueOnError to bContinueOnError
94274>>>>>        End
94274>>>>>>
94274>>>>>
94274>>>>>        Get _AllTablesToConvert to iTablesArray
94275>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
94276>>>>>        Decrement iSize
94277>>>>>        For iCount from 0 to iSize
94283>>>>>>
94283>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
94284>>>>>        Loop
94285>>>>>>
94285>>>>>
94285>>>>>    End_Procedure
94286>>>>>
94286>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
94288>>>>>        Handle hToTable hoLogFile
94288>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
94288>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sEmpty sConnectionID sConnectionString
94288>>>>>        String sDBOKeyWord sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
94288>>>>>        tSQLConnection SQLConnection
94288>>>>>        tSQLConnection SQLConnection
94288>>>>>
94288>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
94289>>>>>        // If this is an Alias file there is nothing to convert to SQL.
94289>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
94289>>>>>        If (bIsAlias = True) Begin   
94291>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94294>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
94296>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName) 
94299>>>>>                Get psConnectionID to sConnectionID
94300>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
94301>>>>>            End
94301>>>>>>
94301>>>>>            Function_Return True
94302>>>>>        End
94302>>>>>>
94302>>>>>        
94302>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
94305>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94308>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
94311>>>>>
94311>>>>>        If (ghoProgressBar <> 0) Begin
94313>>>>>            Send DoAdvance of ghoProgressBar
94314>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sLogicalName) * "Number:" * String(hTable))
94315>>>>>        End  
94315>>>>>>
94315>>>>>        
94315>>>>>        // Marco Kuipers suggestion;
94315>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
94315>>>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
94315>>>>>        // table again.
94315>>>>>        Get UtilTableIsSQL hTable to bOK
94316>>>>>        If (bOK = False) Begin
94318>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists 
94319>>>>>            If (bExists = True) Begin
94321>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
94322>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
94323>>>>>                Get phoLogFile to hoLogFile
94324>>>>>                If (hoLogFile <> 0) Begin
94326>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
94327>>>>>                    Send LogError sWarning False
94328>>>>>                End                                        
94328>>>>>>
94328>>>>>                Else Begin
94329>>>>>                    Error DFERR_PROGRAM sWarning
94330>>>>>>
94330>>>>>                End
94330>>>>>>
94330>>>>>            End
94330>>>>>>
94330>>>>>        End
94330>>>>>>
94330>>>>>        
94330>>>>>        // Does the rootname contain a driver?
94330>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
94332>>>>>            // Does the table already exist as an SQL table?
94332>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
94333>>>>>            // It can happen that the table is missing from Filelist.cfg but still
94333>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
94333>>>>>            If (bExists = False) Begin
94335>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
94336>>>>>            End
94336>>>>>>
94336>>>>>            If (bExists = True) Begin
94338>>>>>                Set TableName_Text of ghoStatusPanel to ""
94339>>>>>                Function_Return False
94340>>>>>            End
94340>>>>>>
94340>>>>>        End
94340>>>>>>
94340>>>>>
94340>>>>>        Move CS_ANSI_Txt to sANSI_OEM
94341>>>>>        If (bToAnsi = False) Begin
94343>>>>>            Move CS_OEM_Txt to sANSI_OEM
94344>>>>>        End
94344>>>>>>
94344>>>>>
94344>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
94345>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
94345>>>>>        // passed as True, we adjust for that here.
94345>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
94346>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
94348>>>>>            Move False to bUseConnectionID
94349>>>>>        End
94349>>>>>>
94349>>>>>
94349>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94350>>>>>        Move SQLConnection.sSchema           to sSchema
94351>>>>>        If (sSchema = "") Begin
94353>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema 
94354>>>>>            Move (Lowercase(sSchema))        to sSchema
94355>>>>>        End
94355>>>>>>
94355>>>>>
94355>>>>>        If (sDriverID = ORAFLEX) Begin
94357>>>>>            Move SQLConnection.sUserID       to sSchema
94358>>>>>        End
94358>>>>>>
94358>>>>>
94358>>>>>        Move SQLConnection.sDatabase         to sDatabase
94359>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
94360>>>>>        Move SQLConnection.sConnectionString to sConnectionString
94361>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
94363>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
94364>>>>>>
94364>>>>>            Function_Return False
94365>>>>>        End
94365>>>>>>
94365>>>>>
94365>>>>>        Get AutoConnectionIDLogin to bOK
94366>>>>>        Open hTable
94368>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94371>>>>>        If (bOpened = False) Begin
94373>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
94374>>>>>>
94374>>>>>            Function_Return False
94375>>>>>        End
94375>>>>>>
94375>>>>>
94375>>>>>        If (ghoProgressBar <> 0) Begin
94377>>>>>            Send DoAdvance of ghoProgressBar
94378>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
94379>>>>>        End  
94379>>>>>>
94379>>>>>        
94379>>>>>        Move 0 to hToTable
94380>>>>>        Get _TableNameOnly sRootName                 to sRootName
94381>>>>>        Move (sRootName + ".int")                    to sPhysicalName
94382>>>>>
94382>>>>>        Case Begin
94382>>>>>            Case (sDriverID = MSSQLDRV_ID)
94384>>>>>                Case Break
94385>>>>>            Case (sDriverID = ODBC_DRV_ID)
94388>>>>>                Case Break
94389>>>>>            Case (sDriverID = DB2_DRV_ID)
94392>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
94393>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
94394>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
94395>>>>>                Case Break
94396>>>>>            Case (sDriverID = ORAFLEX)
94399>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
94400>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
94401>>>>>                Case Break
94402>>>>>            Case (sDriverID = MDSMySQL)
94405>>>>>                Case Break
94406>>>>>            Case (sDriverID = MDSPgSQL)
94409>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
94410>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
94411>>>>>                Case Break
94412>>>>>            Case (sDriverID = DATAFLEX_ID)
94415>>>>>                Case Break
94416>>>>>            Case Else
94416>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
94417>>>>>>
94417>>>>>                Case Break
94418>>>>>        Case End
94418>>>>>
94418>>>>>        Move False to Err
94419>>>>>        
94419>>>>>        If (bIsAlias = False) Begin
94421>>>>>    
94421>>>>>            If (bMertechDriver = True) Begin
94423>>>>>                // Note: This function also sets the Err flag.
94423>>>>>                Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bCopyData to bOK
94424>>>>>            End
94424>>>>>>
94424>>>>>    
94424>>>>>            If (bMertechDriver = False) Begin
94426>>>>>                Structure_Start hToTable sDriverID
94427>>>>>                    Structure_Copy hTable to hToTable
94428>>>>>    
94428>>>>>                    Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
94431>>>>>    
94431>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
94433>>>>>                        If (bUseConnectionID = True) Begin
94435>>>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
94438>>>>>                        End
94438>>>>>>
94438>>>>>                        Else Begin
94439>>>>>                            Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
94442>>>>>                        End
94442>>>>>>
94442>>>>>    
94442>>>>>                        Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hToTable to sANSI_OEM
94445>>>>>                        Set_Attribute DF_FILE_RECNUM_TABLE             of hToTable to bRecnum
94448>>>>>    
94448>>>>>                        If (sSchema <> "") Begin
94450>>>>>                            Set_Attribute DF_FILE_OWNER                of hToTable to sSchema
94453>>>>>                        End
94453>>>>>>
94453>>>>>    
94453>>>>>                        If (sDriverID = DB2_DRV_ID) Begin
94455>>>>>                            If (sLongTableSpace <> "") Begin
94457>>>>>                                Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
94460>>>>>                            End
94460>>>>>>
94460>>>>>                            If (sBaseTableSpace <> "") Begin
94462>>>>>                                Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
94465>>>>>                            End
94465>>>>>>
94465>>>>>                            If (sIndexTableSpace <> "") Begin
94467>>>>>                                Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
94470>>>>>                            End
94470>>>>>>
94470>>>>>                        End
94470>>>>>>
94470>>>>>                    End
94470>>>>>>
94470>>>>>    
94470>>>>>                Structure_End hToTable
94472>>>>>            End
94472>>>>>>
94472>>>>>    
94472>>>>>            Move (not(Err)) to bOK
94473>>>>>            If (bOK = True and bCopyData = True and bMertechDriver = False) Begin
94475>>>>>                If (bIsAlias = False) Begin
94477>>>>>                    Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
94478>>>>>                    If (ghoDbUpdateHandler > 0) Begin
94480>>>>>                        Get pbContinueOnError to bContinueOnError
94481>>>>>                    End
94481>>>>>>
94481>>>>>                    // If the data copy failed we will keep the newly created SQL table but
94481>>>>>                    // rename it by adding a GUID at the end of the table name
94481>>>>>                    // - or as much as "fit" because different SQL back-ends have
94481>>>>>                    // different rules how long a table name can be.
94481>>>>>                    // The new table will probably contain data but something went
94481>>>>>                    // wrong while converting the data from embedded to SQL.
94481>>>>>                    If (bOK = False and bContinueOnError = False) Begin
94483>>>>>                        Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
94484>>>>>                        Get SqlTableRename hTable sLogicalName sGUIDName to bOK
94485>>>>>                        Error DFERR_PROGRAM ("Copying of data failed. The SQL table:" * sLogicalName * "was renamed to:" * String(sGUIDName))
94486>>>>>>
94486>>>>>                    End
94486>>>>>>
94486>>>>>                End
94486>>>>>>
94486>>>>>            End
94486>>>>>>
94486>>>>>        End
94486>>>>>>
94486>>>>>        
94486>>>>>        If (bMertechDriver = True) Begin
94488>>>>>            Open hTable
94490>>>>>        End
94490>>>>>>
94490>>>>>
94490>>>>>        // This must be after copying data...
94490>>>>>        If (Err = False) Begin
94492>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
94495>>>>>            // We also adjust the display name by prefixing it by the schema name;
94495>>>>>            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
94497>>>>>                // The max length for the display_name is 31 characters...
94497>>>>>                If (Length(sSchema + "." + sDisplayName) < 31) Begin
94499>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
94502>>>>>                End
94502>>>>>>
94502>>>>>            End
94502>>>>>>
94502>>>>>        End
94502>>>>>>
94502>>>>>        
94502>>>>>        Close hTable
94503>>>>>        Move (not(Err)) to bOK
94504>>>>>        Function_Return (bOK = True)
94505>>>>>    End_Function  
94506>>>>>    
94506>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
94506>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
94506>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
94506>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
94508>>>>>        Boolean bOpened bOK
94508>>>>>        Integer hToTable iIndex iCount iRetval iVoid iOrgFreq
94508>>>>>        String sErrorFile sEmpty sPath
94508>>>>>
94508>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
94511>>>>>        Get AutoConnectionIDLogin to bOK
94512>>>>>        If (sDriverID = DATAFLEX_ID) Begin
94514>>>>>            Send IncreaseSortBufferSize
94515>>>>>//            Send SetAllIndexesToBatch hToTable
94515>>>>>        End
94515>>>>>>
94515>>>>>
94515>>>>>        Move False to Err
94516>>>>>        Open sPhysicalName as hToTable
94518>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
94521>>>>>        If (bOpened = False) Begin
94523>>>>>            Function_Return False
94524>>>>>        End
94524>>>>>>
94524>>>>>
94524>>>>>        If (ghoStatusPanel <> 0) Begin
94526>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
94527>>>>>        End
94527>>>>>>
94527>>>>>
94527>>>>>        Move "" to sEmpty
94528>>>>>        Move False to Err
94529>>>>>        Move True to bOK
94530>>>>>
94530>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
94533>>>>>//        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
94533>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94535>>>>>            // Remove all indices to speed up copying of data:
94535>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
94540>>>>>            If (iRetval <> 0) Begin
94542>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table:" * sRootName)
94543>>>>>>
94543>>>>>                Function_Return False
94544>>>>>            End
94544>>>>>>
94544>>>>>        End
94544>>>>>>
94544>>>>>
94544>>>>>        Move (sRootName + ".err") to sErrorFile
94545>>>>>        Move 0 to iIndex
94546>>>>>        Move False to Err
94547>>>>>
94547>>>>>        Copy_Records hFromTable to hToTable using 0 Callback Self
94550>>>>>
94550>>>>>        If (Err = False) Begin
94552>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
94553>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
94554>>>>>        End
94554>>>>>>
94554>>>>>
94554>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94556>>>>>            // Recreate indices:
94556>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback Self Passing sEmpty sEmpty iVoid Result iRetval
94561>>>>>        End
94561>>>>>>
94561>>>>>
94561>>>>>        Close hToTable
94562>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
94565>>>>>
94565>>>>>        If (bOK = True) Begin
94567>>>>>            Move (not(Err)) to bOK
94568>>>>>        End
94568>>>>>>
94568>>>>>
94568>>>>>        If (ghoStatusPanel <> 0) Begin
94570>>>>>            Set TableName_Text of ghoStatusPanel to ""
94571>>>>>            Set Message_Text   of ghoStatusPanel to ""
94572>>>>>            Set Action_Text    of ghoStatusPanel to ""
94573>>>>>        End
94573>>>>>>
94573>>>>>
94573>>>>>        Function_Return (bOK = True)
94574>>>>>    End_Function
94575>>>>>
94575>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
94575>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
94575>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
94577>>>>>        Handle hFile
94577>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
94577>>>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
94577>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened
94577>>>>>        tSQLConnection SQLConnection
94577>>>>>        tSQLConnection SQLConnection
94577>>>>>        tAPIColumn[] aColumns
94577>>>>>        tAPIColumn[] aColumns
94578>>>>>        tColumnType ColumnType
94578>>>>>        tColumnType ColumnType
94578>>>>>        
94578>>>>>        // First check if the passed filenumber already exists; in case we do nothing
94578>>>>>        Get UtilTableExists hTable to bOk
94579>>>>>        If (bOk = True) Begin
94581>>>>>            Function_Return False
94582>>>>>        End
94582>>>>>>
94582>>>>>        
94582>>>>>        Move sLogicalName to sTableName
94583>>>>>        If (ghoProgressBar <> 0) Begin
94585>>>>>            Send DoAdvance of ghoProgressBar
94586>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable))
94587>>>>>        End
94587>>>>>>
94587>>>>>
94587>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
94588>>>>>        Get psDriverID to sDriverID
94589>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
94590>>>>>        Get piDbType to iDbType
94591>>>>>
94591>>>>>        // If no columns passed in, we need to create a "dummy" column 
94591>>>>>        Move False to bDeleteDummy 
94592>>>>>        If (Num_Arguments = 8) Begin
94594>>>>>            Move aColumnIn to aColumns
94595>>>>>        End
94595>>>>>>
94595>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
94597>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
94598>>>>>            Move ColumnType.iType to iDataType
94599>>>>>            If (bRecnum = False) Begin
94601>>>>>                Move C_tAPIColumn_Identity to iIdentityType
94602>>>>>            End                                            
94602>>>>>>
94602>>>>>            Else Begin
94603>>>>>                Move C_tAPIColumn_None     to iIdentityType
94604>>>>>            End
94604>>>>>>
94604>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
94605>>>>>            Move True to bDeleteDummy 
94606>>>>>        End  
94606>>>>>>
94606>>>>>        
94606>>>>>        // If columns have been passed as an array we need to check if an identity column
94606>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
94606>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be 
94606>>>>>        // two identity columns and SQL doesn't like that and throws an error.
94606>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
94608>>>>>            Move (SizeOfArray(aColumns)) to iSize
94609>>>>>            Decrement iSize
94610>>>>>            for iCount from 0 to iSize
94616>>>>>>
94616>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
94618>>>>>                    Move False to bRecnum  
94619>>>>>                    Move iSize to iCount
94620>>>>>                End
94620>>>>>>
94620>>>>>            Loop
94621>>>>>>
94621>>>>>        End
94621>>>>>>
94621>>>>>        
94621>>>>>        // If this is a SQL based driver we also check if the table exists
94621>>>>>        // in the SQL back end; in case we do nothing.
94621>>>>>        If (bSqlDriver = True) Begin
94623>>>>>            // Get all connection properties
94623>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94624>>>>>            Move SQLConnection.sSchema to sSchema
94625>>>>>            If (sSchema = "") Begin
94627>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
94628>>>>>            End   
94628>>>>>>
94628>>>>>
94628>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
94629>>>>>            // It can happen that the table is missing from Filelist.cfg but still
94629>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
94629>>>>>            If (bExists = False) Begin
94631>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
94632>>>>>            End
94632>>>>>>
94632>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
94632>>>>>            // we will just add it to Filelist.cfg
94632>>>>>            If (bExists = True) Begin
94634>>>>>                If (bExistsInFilelist = False) Begin
94636>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
94638>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
94639>>>>>                    End
94639>>>>>>
94639>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
94642>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94645>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName                        
94648>>>>>                    Move False to bSysFile
94649>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
94650>>>>>                End
94650>>>>>>
94650>>>>>                Function_Return False
94651>>>>>            End
94651>>>>>>
94651>>>>>        End
94651>>>>>>
94651>>>>>
94651>>>>>        Move CS_ANSI_Txt to sANSI_OEM
94652>>>>>        If (num_arguments > 6) Begin
94654>>>>>            If (bANSI = False) Begin
94656>>>>>                Move CS_OEM_Txt to sANSI_OEM
94657>>>>>            End
94657>>>>>>
94657>>>>>        End
94657>>>>>>
94657>>>>>
94657>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
94657>>>>>        // is a programmer's error and we auto-correct for it here.
94657>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
94657>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
94657>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
94657>>>>>        // set it back and use a Mertech function to convert it to SQL.
94657>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
94658>>>>>        If (bMertechDriver = True) Begin
94660>>>>>            If (bUseConnectionID = True) Begin
94662>>>>>                Move False to bUseConnectionID
94663>>>>>            End
94663>>>>>>
94663>>>>>            Move sDriverID to sOriginalDriverID
94664>>>>>            Move DATAFLEX_ID to sDriverID
94665>>>>>        End
94665>>>>>>
94665>>>>>
94665>>>>>        Move False to Err
94666>>>>>        If (sDriverID = DATAFLEX_ID) Begin
94668>>>>>            Move sRootName to sPhysicalFile
94669>>>>>        End
94669>>>>>>
94669>>>>>
94669>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94671>>>>>            Move SQLConnection.sConnectionID to sConnectionID
94672>>>>>
94672>>>>>            // If DAW driver and we should use a connection id we need to
94672>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
94672>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
94674>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
94675>>>>>                If (bExists = False) Begin
94677>>>>>                    Get UtilCreateConnectionID sConnectionID to bOk
94678>>>>>                    If (bOk = False) Begin
94680>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
94681>>>>>>
94681>>>>>                        Function_Return False
94682>>>>>                    End
94682>>>>>>
94682>>>>>                End
94682>>>>>>
94682>>>>>            End
94682>>>>>>
94682>>>>>
94682>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
94684>>>>>                Move (sTableName + ".int") to sPhysicalFile
94685>>>>>            End                                            
94685>>>>>>
94685>>>>>            Else Begin
94686>>>>>                Move (sRootName + ".int") to sPhysicalFile
94687>>>>>            End
94687>>>>>>
94687>>>>>            Move (Uppercase(sDisplayName)) to sVal
94688>>>>>            If (not(sVal contains (sSchema + "."))) Begin
94690>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
94691>>>>>            End
94691>>>>>>
94691>>>>>        End
94691>>>>>>
94691>>>>>        Move False to Err
94692>>>>>        Move 0 to hFile
94693>>>>>
94693>>>>>        Structure_Start hFile sDriverID
94694>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
94696>>>>>                If (bUseConnectionID = True) Begin
94698>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
94701>>>>>                End
94701>>>>>>
94701>>>>>                Else Begin
94702>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
94705>>>>>                End
94705>>>>>>
94705>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
94708>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
94711>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
94714>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
94717>>>>>
94717>>>>>                If (sSchema <> "") Begin
94719>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
94722>>>>>                End
94722>>>>>>
94722>>>>>
94722>>>>>                If (sDriverID = DB2_DRV_ID) Begin
94724>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
94726>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
94729>>>>>                    End
94729>>>>>>
94729>>>>>                End
94729>>>>>>
94729>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
94731>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
94733>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
94736>>>>>                    End
94736>>>>>>
94736>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
94738>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
94741>>>>>                    End
94741>>>>>>
94741>>>>>                End
94741>>>>>>
94741>>>>>            End
94741>>>>>>
94741>>>>>
94741>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME                of hFile to sPhysicalFile
94744>>>>>            Send ApiColumnsAddToTable hFile aColumns True
94745>>>>>        Structure_End hFile
94747>>>>>
94747>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
94747>>>>>        If (bMertechDriver = True) Begin
94749>>>>>            Move sOriginalDriverID to sDriverID
94750>>>>>            If (not(sVal contains (sSchema + "."))) Begin
94752>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
94753>>>>>            End
94753>>>>>>
94753>>>>>            // Note: This function also sets the Err flag.
94753>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
94754>>>>>        End
94754>>>>>>
94754>>>>>
94754>>>>>        Move (not(Err)) to bOK
94755>>>>>        If (bOk = True) Begin
94757>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
94759>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
94760>>>>>            End
94760>>>>>>
94760>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
94763>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94766>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
94769>>>>>
94769>>>>>            // Lastly we remove the temporary column we created above, if all went well.
94769>>>>>            If (bDeleteDummy) Begin
94771>>>>>                Get ApiColumnRemove hTable "temp" to bOk
94772>>>>>            End
94772>>>>>>
94772>>>>>        End
94772>>>>>>
94772>>>>>        
94772>>>>>        Close hTable
94773>>>>>        Function_Return (bOK = True)
94774>>>>>    End_Function
94775>>>>>
94775>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
94777>>>>>        Boolean bExists
94777>>>>>
94777>>>>>        Move False to Err
94778>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
94781>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
94784>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
94787>>>>>
94787>>>>>        Function_Return (Err = False)
94788>>>>>    End_Function
94789>>>>>
94789>>>>>    // ToDo: Needs to be revised
94789>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
94791>>>>>        Handle hTable
94791>>>>>        String sDEFName sDataPath sDriverID
94791>>>>>        Boolean bExists
94791>>>>>
94791>>>>>        // Do nothing if MSSQL Driver.
94791>>>>>//        Get IsMSSQLDriver to bExists
94791>>>>>//        If (bExists = True) Begin
94791>>>>>//            Procedure_Return
94791>>>>>//        End
94791>>>>>
94791>>>>>        Get psDataPathFirstPart to sDataPath
94792>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
94793>>>>>        If (bExists = True) Begin
94795>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
94795>>>>>            // still be missing from the filelist and needs to be added.
94795>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
94796>>>>>            If (bExists = True) Begin
94798>>>>>                Procedure_Return
94799>>>>>            End
94799>>>>>>
94799>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
94799>>>>>            Else Begin
94800>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
94803>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
94806>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
94809>>>>>                Procedure_Return
94810>>>>>            End
94810>>>>>>
94810>>>>>        End
94810>>>>>>
94810>>>>>
94810>>>>>        Move (sPath + sFileName + ".def") to sDEFName
94811>>>>>        Move 0 to hTable
94812>>>>>        Move False to Err
94813>>>>>
94813>>>>>        Structure_Start hTable DATAFLEX_ID
94814>>>>>            Load_Def sDEFName Onto hTable
94815>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
94818>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
94820>>>>>
94820>>>>>        Move iFilelistSlot to hTable
94821>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
94824>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94827>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
94830>>>>>
94830>>>>>    End_Procedure
94831>>>>>
94831>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
94833>>>>>        Boolean bTmp bErr bOK
94833>>>>>        String sTableName sDisplayName sFileName sDBOKeyWord sVal
94833>>>>>
94833>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
94833>>>>>        Move Err to bTmp
94834>>>>>        Move False to Err
94835>>>>>
94835>>>>>        Get AutoConnectionIDLogin to bOK
94836>>>>>        // First get the info for the current filelist slot:
94836>>>>>        Open iFromFileSlot
94838>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
94841>>>>>        If (bOK = True) Begin
94843>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
94846>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
94849>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
94852>>>>>
94852>>>>>            //...then move it.
94852>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
94855>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
94858>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
94861>>>>>
94861>>>>>            //...and finally remove the old filelist values.
94861>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
94864>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
94867>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
94870>>>>>        End
94870>>>>>>
94870>>>>>        Close iFromFileSlot
94871>>>>>
94871>>>>>        Move Err to bErr
94872>>>>>        Move bTmp to Err
94873>>>>>        Function_Return (bErr = False)
94874>>>>>    End_Function
94875>>>>>
94875>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
94877>>>>>        Handle hTable
94877>>>>>        Boolean bOK
94877>>>>>
94877>>>>>        Get AutoConnectionIDLogin to bOK
94878>>>>>        Move False to Err
94879>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
94881>>>>>        If (hTableTo > 0) Begin
94883>>>>>            Open hTableTo
94885>>>>>        End
94885>>>>>>
94885>>>>>        Move hTableFrom to hTable
94886>>>>>
94886>>>>>        Structure_Start hTable
94887>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
94890>>>>>            If (iColumnTo <> 0) Begin
94892>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
94895>>>>>            End
94895>>>>>>
94895>>>>>        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE
94897>>>>>
94897>>>>>        Close hTableFrom
94898>>>>>        If (hTableTo > 0) Begin
94900>>>>>            Close hTableTo
94901>>>>>        End
94901>>>>>>
94901>>>>>
94901>>>>>        Function_Return (Err = False)
94902>>>>>    End_Function
94903>>>>>
94903>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
94903>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
94905>>>>>        String sTableName sDriverID
94905>>>>>        Boolean bOk
94905>>>>>        String sDataPath
94905>>>>>
94905>>>>>        Get AutoConnectionIDLogin to bOK
94906>>>>>        Move False to Err
94907>>>>>        Get psDriverID to sDriverID
94908>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
94909>>>>>        If (sTableName = "") Begin
94911>>>>>            Function_Return False
94912>>>>>        End
94912>>>>>>
94912>>>>>
94912>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
94913>>>>>        Delete_db sTableName
94914>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
94915>>>>>
94915>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94917>>>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
94918>>>>>            Get psDataPathFirstPart to sDataPath
94919>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
94920>>>>>        End
94920>>>>>>
94920>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
94920>>>>>        If (hTable <> 0) Begin
94922>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
94925>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
94928>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
94931>>>>>        End
94931>>>>>>
94931>>>>>        
94931>>>>>        Close hTable
94932>>>>>        Function_Return (hTable <> 0)
94933>>>>>    End_Function
94934>>>>>
94934>>>>>    Function ApiTableRemoveRelation Handle hTableTo Integer iColumn Returns Boolean
94936>>>>>        Handle hTable
94936>>>>>        Boolean bOK
94936>>>>>
94936>>>>>        Get AutoConnectionIDLogin to bOK
94937>>>>>        Move False to Err
94938>>>>>        Open hTableTo Mode DF_EXCLUSIVE
94940>>>>>        Move hTableTo to hTable
94941>>>>>
94941>>>>>        Structure_Start hTable
94942>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
94945>>>>>        Structure_End hTable DF_STRUCTEND_OPT_IN_PLACE
94947>>>>>
94947>>>>>        Close hTableTo
94948>>>>>        Function_Return (Err = False)
94949>>>>>    End_Function
94950>>>>>
94950>>>>>    Function ApiTableRename Integer hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
94952>>>>>        String sPhysicalName sDataPath sDriverID
94952>>>>>        Boolean bOK bExists
94952>>>>>        Integer iRetval
94952>>>>>
94952>>>>>        Move False to Err
94953>>>>>        Get psDataPathFirstPart to sDataPath
94954>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
94957>>>>>
94957>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94960>>>>>        Close hTable
94961>>>>>        If (sDriverID = DATAFLEX_ID) Begin
94963>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
94964>>>>>            If (bExists = True) Begin
94966>>>>>                If (Uppercase(sPhysicalName) = Uppercase(sRootName)) Begin
94968>>>>>                    Function_Return False
94969>>>>>                End
94969>>>>>>
94969>>>>>            End
94969>>>>>>
94969>>>>>            Copy_db (sDataPath + sPhysicalName) to (sDataPath + sRootName)
94972>>>>>        End
94972>>>>>>
94972>>>>>
94972>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
94974>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
94975>>>>>        End
94975>>>>>>
94975>>>>>
94975>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
94978>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
94981>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94984>>>>>
94984>>>>>        // We need a short break here before attempting to delete the physical file or Windows
94984>>>>>        // might report "File in use..." and the deletion will fail.
94984>>>>>        Sleep 2
94985>>>>>        If (sDriverID = DATAFLEX_ID) Begin
94987>>>>>            Get vDeleteFile (sDataPath + sPhysicalName + ".*") to bOK
94988>>>>>        End
94988>>>>>>
94988>>>>>
94988>>>>>        Function_Return (Err = False)
94989>>>>>    End_Function
94990>>>>>
94990>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
94992>>>>>        Move False to Err
94993>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
94996>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
94999>>>>>
94999>>>>>        Function_Return (Err = False)
95000>>>>>    End_Function                        
95001>>>>>    
95001>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
95001>>>>>    // Note that it first removes any driver prefixes in the rootname.
95001>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
95003>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
95003>>>>>        Boolean bTheSame bIsSQL 
95003>>>>>        Handle hTable
95003>>>>>        
95003>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95003>>>>>        Move APITableInfo.iTableNumber      to hTable
95004>>>>>        Get UtilTableIsSQL hTable           to bIsSQL
95005>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
95006>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo  
95009>>>>>        Get _TableNameOnly sRootNameTo                to sRootNameTo
95010>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
95013>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
95016>>>>>        
95016>>>>>        If (bCompareFilelistUppercase = True) Begin
95018>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bTheSame                  
95019>>>>>        End
95019>>>>>>
95019>>>>>        Else Begin
95020>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bTheSame                  
95021>>>>>        End
95021>>>>>>
95021>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
95021>>>>>            
95021>>>>>        Function_Return bTheSame
95022>>>>>    End_Function  
95023>>>>>    
95023>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
95025>>>>>        Handle hFile hTable 
95025>>>>>        String sTableName sLogicalName sDisplayName 
95025>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
95025>>>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
95025>>>>>        Boolean bOk bExists bMertechDriver bDeleteDummy bExistsInFilelist bSysFile bOpened bSameColumnDefinitions
95025>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase bExistingTable
95025>>>>>        Boolean bIsSame bSameTableNames bIsOpen bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
95025>>>>>        tSQLConnection SQLConnection  
95025>>>>>        tSQLConnection SQLConnection  
95025>>>>>        tColumnType    ColumnType
95025>>>>>        tColumnType    ColumnType
95025>>>>>        tAPITable      APITableFrom APITableTo
95025>>>>>        tAPITable      APITableFrom APITableTo
95025>>>>>        
95025>>>>>        // We don't allow update of the framework's DbVersion table.
95025>>>>>        If (Uppercase(sTableName) = "DBVERSION") Begin
95027>>>>>            Function_Return False
95028>>>>>        End
95028>>>>>>
95028>>>>>        
95028>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
95029>>>>>        Get piDbType                            to iDbType
95030>>>>>        Get pbUseConnectionID                   to bUseConnectionID
95031>>>>>        Get pbRecnum                            to bRecnum
95032>>>>>        Get pbToANSI                            to bToANSI
95033>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
95034>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
95035>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase 
95036>>>>>        
95036>>>>>        Move CS_ANSI_Txt to sANSI_OEM
95037>>>>>        If (bToANSI = False) Begin
95039>>>>>            Move CS_OEM_Txt to sANSI_OEM
95040>>>>>        End
95040>>>>>>
95040>>>>>        Move APITableNameInfoFrom.sRootName  to sTableName
95041>>>>>        Get _TableNameOnly sTableName        to sTableName
95042>>>>>        If (sDriverIDFrom = DATAFLEX_ID) Begin
95044>>>>>            Move sTableName to sPhysicalFile
95045>>>>>        End
95045>>>>>>
95045>>>>>
95045>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
95045>>>>>        // is a programmer's error and we auto-correct for it here.
95045>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
95045>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
95045>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
95045>>>>>        // set it back and use a Mertech function to convert it to SQL.
95045>>>>>        Get IsMertechDriver sDriverIDFrom to bMertechDriver
95046>>>>>        If (bMertechDriver = True) Begin
95048>>>>>            If (bUseConnectionID = True) Begin
95050>>>>>                Move False to bUseConnectionID
95051>>>>>            End
95051>>>>>>
95051>>>>>            Move sDriverIDFrom to sOriginalDriverID
95052>>>>>            Move DATAFLEX_ID to sDriverIDFrom
95053>>>>>        End
95053>>>>>>
95053>>>>>        
95053>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
95054>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
95055>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
95056>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
95057>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
95058>>>>>        Move APITableNameInfoFrom.sRootName     to sRootName
95059>>>>>        Move APITableNameInfoFrom.sLogicalName  to sLogicalName
95060>>>>>        Move APITableNameInfoFrom.sDisplayName  to sDisplayName
95061>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
95062>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
95063>>>>>        
95063>>>>>        // 'To' table properties:
95063>>>>>        Get UtilTableIsAlias hTable             to bIsAliasTo
95064>>>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
95065>>>>>        If (bIsSQLTableTo = False) Begin
95067>>>>>            Move DATAFLEX_ID to sDriverIDTo
95068>>>>>        End                                
95068>>>>>>
95068>>>>>        Else Begin
95069>>>>>            Move sDriverIDFrom to sDriverIDTo
95070>>>>>        End
95070>>>>>>
95070>>>>>        
95070>>>>>        // Does the 'To' table exist in Filelist.cfg _and_ on disk (embedded) or on the SQL back-end.
95070>>>>>        Get UtilTableExists  hTable             to bExistingTable
95071>>>>>        If (bExistingTable = False and bIsSQLTableFrom = True and bMertechDriver = False) Begin
95073>>>>>            Move True                           to bIsSQLTableTo 
95074>>>>>            Move sDriverIDFrom                  to sDriverIDTo   
95075>>>>>        End
95075>>>>>>
95075>>>>>        // Does table exist in Filelist.cfg:
95075>>>>>        Get UtilTableNumberIsInUse hTable       to bExistsInFilelist 
95076>>>>>
95076>>>>>        If (bIsSQLTableFrom = False and sDriverIDFrom <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverIDFrom)) Begin
95078>>>>>            Move (sDriverIDFrom + ":" + sRootName) to sRootName
95079>>>>>        End
95079>>>>>>
95079>>>>>
95079>>>>>        If (ghoProgressBar <> 0) Begin
95081>>>>>            Send DoAdvance of ghoProgressBar   
95082>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * String(sTableName) * "Number:" * String(hTable))
95083>>>>>        End   
95083>>>>>>
95083>>>>>        
95083>>>>>        // a) The table is an Alias table:
95083>>>>>        //
95083>>>>>        // If this is an Alias file the Logical or Display name might have changed. Other than that
95083>>>>>        // there is nothing that can be updated for an Alias table.
95083>>>>>        // But we change all three attributes in case this is a new Alias table.
95083>>>>>        If (bIsAliasFrom = True) Begin           
95085>>>>>            // ToDo: The first param needs to be paramerized:
95085>>>>>            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
95086>>>>>            If (bSameTableNames = True) Begin
95088>>>>>                Function_Return True
95089>>>>>            End
95089>>>>>>
95089>>>>>            Else Begin 
95090>>>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
95092>>>>>                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sTableName
95095>>>>>                End                                                           
95095>>>>>>
95095>>>>>                Else Begin
95096>>>>>                    Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName  
95099>>>>>                End
95099>>>>>>
95099>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
95102>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName                        
95105>>>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
95107>>>>>                    Get SqlUtilCreateIntFile hTable sDriverIDFrom sConnectionID True False to bOk
95108>>>>>                End
95108>>>>>>
95108>>>>>            End  
95108>>>>>>
95108>>>>>            Function_Return True
95109>>>>>        End                                                           
95109>>>>>>
95109>>>>>        
95109>>>>>        Move hTable         to APITableTo.ApiTableInfo.iTableNumber
95110>>>>>        If (bIsSQLTableTo = True) Begin
95112>>>>>            Move sRootName  to APITableTo.ApiTableInfo.sRootName
95113>>>>>        End 
95113>>>>>>
95113>>>>>        Else Begin
95114>>>>>            Move sTableName to APITableTo.ApiTableInfo.sRootName
95115>>>>>        End
95115>>>>>>
95115>>>>>        
95115>>>>>        Move sLogicalName   to APITableTo.ApiTableInfo.sLogicalName
95116>>>>>        Move sDisplayName   to APITableTo.ApiTableInfo.sDisplayName
95117>>>>>        Move bIsAliasTo     to APITableTo.ApiTableInfo.bIsAlias
95118>>>>>        Move bIsSQLTableTo  to APITableTo.ApiTableInfo.bIsSQL
95119>>>>>        
95119>>>>>        // b) Table exists in Filelist.cfg. We will then compare & check the Filelist.cfg entries for differences.
95119>>>>>        If (bExistsInFilelist = True) Begin
95121>>>>>            // ToDo: The first param needs to be paramerized:
95121>>>>>            Get ApiTableFilelistNamesCompare True APITableFrom.ApiTableInfo to bSameTableNames
95122>>>>>            If (bSameTableNames = False) Begin
95124>>>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
95126>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
95129>>>>>                End
95129>>>>>>
95129>>>>>                Else Begin
95130>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to APITableFrom.ApiTableInfo.sRootName
95133>>>>>                End
95133>>>>>>
95133>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to APITableFrom.ApiTableInfo.sLogicalName
95136>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to APITableFrom.ApiTableInfo.sDisplayName                        
95139>>>>>            End  
95139>>>>>>
95139>>>>>        End                                     
95139>>>>>>
95139>>>>>        
95139>>>>>        // c) Both exists in Filelist.cfg and the table exists on disk (embedded) or as an SQL table. 
95139>>>>>        //    We then check for differences.
95139>>>>>        If (bExistingTable = True) Begin 
95141>>>>>            Get UtilColumnsStructFill  hTable to APITableTo.aApiColumns
95142>>>>>            Get UtilIndexesStructFill  hTable to APITableTo.aApiIndexes
95143>>>>>            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
95144>>>>>        
95144>>>>>            Move False to bFilelistError
95145>>>>>            Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
95146>>>>>            // If there was a "Filelist" error (aka the logical names for the 'From' and 'To' tables weren't the same,
95146>>>>>            // we will _not_ attempt to make any table changes. An error has by now been generated and will
95146>>>>>            // appear in the logfile.
95146>>>>>            // Of course, if the tables were the same we also do nothing.
95146>>>>>            If (bFilelistError = True or bIsSame = True) Begin
95148>>>>>                Set TableName_Text of ghoStatusPanel to ""
95149>>>>>                Function_Return True
95150>>>>>            End
95150>>>>>>
95150>>>>>        End
95150>>>>>>
95150>>>>>        
95150>>>>>        // d) Create as new Table?
95150>>>>>        //
95150>>>>>        Move False to Err
95151>>>>>        If (bExistingTable = False) Begin
95153>>>>>            Get ApiTableCreate hTable sRootName sDisplayName sTableName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
95154>>>>>            Function_Return bOk // And we're done.
95155>>>>>        End
95155>>>>>>
95155>>>>>        
95155>>>>>        // e) If we got this far we need to Update the table:
95155>>>>>        //    This is the last case (a-e).
95155>>>>>        If (ghoProgressBar <> 0) Begin
95157>>>>>            Send DoAdvance of ghoProgressBar   
95158>>>>>            Set TableName_Text of ghoStatusPanel to ("Updating Table:" * String(sTableName) * "Number:" * String(hTable))
95159>>>>>        End
95159>>>>>>
95159>>>>>        
95159>>>>>        // If an SQL 'To' table we fetch the connection details for login & Schema:
95159>>>>>        If (bIsSQLTableTo = True) Begin
95161>>>>>
95161>>>>>            // Get connection properties
95161>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
95162>>>>>            Move SQLConnection.sSchema to sSchema
95163>>>>>            If (sSchema = "") Begin
95165>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
95166>>>>>            End                                            
95166>>>>>>
95166>>>>>            Move SQLConnection.sConnectionID to sConnectionID
95167>>>>>
95167>>>>>            // If a DAW driver and using a connection id we need to check if it exists;
95167>>>>>            // else we create it before attempting creating the table
95167>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
95169>>>>>                Get IsConnectionID sConnectionID sDriverIDFrom to bExists
95170>>>>>                If (bExists = False) Begin
95172>>>>>                    Get UtilCreateConnectionID sConnectionID to bOk
95173>>>>>                    If (bOk = False) Begin
95175>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
95176>>>>>>
95176>>>>>                        Function_Return False
95177>>>>>                    End
95177>>>>>>
95177>>>>>                End
95177>>>>>>
95177>>>>>            End
95177>>>>>>
95177>>>>>
95177>>>>>            Move (sTableName + ".int") to sPhysicalFile
95178>>>>>            Move (Uppercase(sDisplayName)) to sVal
95179>>>>>            // Pre-face the DisplayName with the schema name;
95179>>>>>            // that is how DAW's tools does it.
95179>>>>>            If (not(sVal contains (sSchema + "."))) Begin
95181>>>>>                Move (Lowercase(sSchema) + "." + sLogicalName) to sDisplayName
95182>>>>>            End
95182>>>>>>
95182>>>>>        End 
95182>>>>>>
95182>>>>>        
95182>>>>>        Open hTable Mode DF_EXCLUSIVE
95184>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
95187>>>>>        If (bOpened = False) Begin
95189>>>>>            Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
95190>>>>>            Function_Return False
95191>>>>>        End
95191>>>>>>
95191>>>>>                
95191>>>>>        Move False to Err
95192>>>>>        Move hTable to hFile
95193>>>>>
95193>>>>>        // This will create new columns or update existing ones.     
95193>>>>>        Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
95194>>>>>                
95194>>>>>        If (bOk = True) Begin             
95196>>>>>            If (bExistingTable = False) Begin
95198>>>>>                If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
95200>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
95203>>>>>                End                                                            
95203>>>>>>
95203>>>>>                Else Begin
95204>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95207>>>>>                End
95207>>>>>>
95207>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
95210>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName 
95213>>>>>                If (bIsSQLTableTo = True) Begin
95215>>>>>                    Get SqlUtilUpdateIntFile hTable to bOk
95216>>>>>                End
95216>>>>>>
95216>>>>>            End
95216>>>>>>
95216>>>>>
95216>>>>>            // Compare Indexes and if different; either create or change them 
95216>>>>>            Get UtilIndexesStructFill hTable to APITableTo.aApiIndexes
95217>>>>>            Get UtilIndexesCompare hTable APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
95218>>>>>            If (bIsSame = False) Begin
95220>>>>>                Get UtilIndexesUpdate hFile APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
95221>>>>>            End
95221>>>>>>
95221>>>>>            
95221>>>>>            Get UtilRelationStructFill hTable to APITableTo.aApiRelations
95222>>>>>            Get UtilRelationsCompare hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
95223>>>>>            If (bIsSame = False) Begin
95225>>>>>                Get UtilRelationsUpdate hFile APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
95226>>>>>            End
95226>>>>>>
95226>>>>>        End
95226>>>>>>
95226>>>>>        
95226>>>>>        Close hTable
95227>>>>>        Set TableName_Text of ghoStatusPanel to ""
95228>>>>>
95228>>>>>        Function_Return (bOK = True)
95229>>>>>    End_Function                                                                                                        
95230>>>>>
95230>>>>>    // *** Field/Column Level Functions: ***
95230>>>>>    //
95230>>>>>    // Adds a column name to the passed table number.
95230>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
95232>>>>>        Integer iColumn iCount iFile iPrecision
95232>>>>>        Boolean bExists bOK bInitializeValue bRetval
95232>>>>>        String sDdSrcPath sTableName sColumnValue
95232>>>>>
95232>>>>>        Get UtilColumnExists hTable sFieldName to bExists  
95233>>>>>        Move False to Err
95234>>>>>        If (bExists = True) Begin
95236>>>>>            Function_Return False
95237>>>>>        End 
95237>>>>>>
95237>>>>>        If (num_arguments > 4) Begin
95239>>>>>            Move iPrec to iPrecision
95240>>>>>        End
95240>>>>>>
95240>>>>>        If (num_arguments > 6) Begin
95242>>>>>            Move bInitVal to bInitializeValue
95243>>>>>            Move sColVal  to sColumnValue
95244>>>>>        End
95244>>>>>>
95244>>>>>        If (iType < -1490) Begin
95246>>>>>            Move (iType + 1500) to iType
95247>>>>>        End
95247>>>>>>
95247>>>>>        
95247>>>>>        Get AutoConnectionIDLogin to bOK
95248>>>>>        Move False to Err
95249>>>>>        // Structure_start will change the value of hTable...
95249>>>>>        Move hTable to iFile
95250>>>>>        Open iFile Mode DF_EXCLUSIVE
95252>>>>>
95252>>>>>        Structure_Start iFile
95253>>>>>            Move 0 to iColumn
95254>>>>>            Create_Field hTable At iColumn
95255>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
95258>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
95261>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to iLength
95264>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
95267>>>>>        Structure_End iFile
95269>>>>>
95269>>>>>        // If in development environment; create .fd file:
95269>>>>>        Open hTable
95271>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
95272>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
95273>>>>>        If (iCount > 1) Begin
95275>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
95276>>>>>        End
95276>>>>>>
95276>>>>>        Get vFolderExists sDDSrcPath to bExists
95277>>>>>        If (bExists = True) Begin
95279>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
95280>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
95283>>>>>            Get _TableNameOnly sTableName to sTableName
95284>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
95286>>>>>        End
95286>>>>>>
95286>>>>>        
95286>>>>>        // Check for a default value
95286>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
95288>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
95289>>>>>        End
95289>>>>>>
95289>>>>>        Close hTable
95290>>>>>
95290>>>>>        Function_Return (Err = False)
95291>>>>>    End_Function   
95292>>>>>    
95292>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean 
95292>>>>>//        Integer iColumn iCount iFile
95292>>>>>//        Boolean bExists bOK  
95292>>>>>//        String sDdSrcPath sTableName
95292>>>>>//    
95292>>>>>//        Get AutoConnectionIDLogin to bOK
95292>>>>>//        Move False to Err   
95292>>>>>//        
95292>>>>>//        // Structure_start will change the value of hTable...
95292>>>>>//        Move hTable to iFile
95292>>>>>//        Open iFile Mode DF_EXCLUSIVE
95292>>>>>//        
95292>>>>>//        Structure_Start iFile
95292>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
95292>>>>>//        Structure_End iFile
95292>>>>>//        
95292>>>>>//        // If in development environment; create .fd file:
95292>>>>>//        Open hTable
95292>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
95292>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
95292>>>>>//        If (iCount > 1) Begin
95292>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath    
95292>>>>>//        End 
95292>>>>>//        Get vFolderExists sDDSrcPath to bExists
95292>>>>>//        If (bExists = True) Begin                                   
95292>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath 
95292>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
95292>>>>>//            Get _TableNameOnly sTableName to sTableName 
95292>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
95292>>>>>//        End
95292>>>>>//        Close hTable
95292>>>>>//
95292>>>>>//        Function_Return (Err = False)
95292>>>>>//    End_Function
95292>>>>>
95292>>>>>    // To update all records for a table column with a fixed value.
95292>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
95294>>>>>        Integer iRecs iCurrErr iField iRecord
95294>>>>>        Boolean bRetval bOpen
95294>>>>>        
95294>>>>>        Move 0 to iRecs                
95295>>>>>        Move False to bRetval 
95296>>>>>        Move Err to iCurrErr
95297>>>>>        Move False to Err
95298>>>>>        
95298>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
95301>>>>>        If (bOpen = False) Begin
95303>>>>>            Open hTable
95305>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
95308>>>>>            If (bOpen = False) Begin
95310>>>>>                Function_Return bRetval
95311>>>>>            End
95311>>>>>>
95311>>>>>        End
95311>>>>>>
95311>>>>>        
95311>>>>>        Field_Map hTable sFieldName to iField
95313>>>>>        If (iField <> 0) Begin
95315>>>>>            Clear hTable
95316>>>>>            Repeat
95316>>>>>>
95316>>>>>                Vfind hTable 0 GT
95318>>>>>                If (Found) Begin
95320>>>>>                    If (ghoStatusPanel <> 0) Begin
95322>>>>>                        Get_Field_Value hTable 0 to iRecord
95325>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
95326>>>>>                    End
95326>>>>>>
95326>>>>>                    Reread hTable
95330>>>>>                        Set_Field_Value hTable iField to sColumnValue
95333>>>>>                        SaveRecord hTable
95334>>>>>                    Unlock   
95335>>>>>>
95335>>>>>                End
95335>>>>>>
95335>>>>>           Until (not(Found))
95337>>>>>        End
95337>>>>>>
95337>>>>>        
95337>>>>>        Move (Err = False) to bRetval
95338>>>>>        Move iCurrErr to Err
95339>>>>>        
95339>>>>>        Function_Return bRetval
95340>>>>>    End_Function  
95341>>>>>    
95341>>>>>    Procedure ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating
95343>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
95343>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen
95343>>>>>        String sFieldName sDriverID sTableName
95343>>>>>        
95343>>>>>        Get psDriverID to sDriverID                      
95344>>>>>        Get piDbType to iDbType
95345>>>>>        Get UtilTableHandleToString hTable to sTableName
95346>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
95347>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver                     
95348>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable 
95349>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
95351>>>>>            Move True to bIsSqlTable
95352>>>>>        End
95352>>>>>>
95352>>>>>        Move False to bIsOpen
95353>>>>>        If (hTable > 0) Begin
95355>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95358>>>>>        End
95358>>>>>>
95358>>>>>        If (bIsOpen = True) Begin
95360>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
95363>>>>>        End 
95363>>>>>>
95363>>>>>        Else Begin
95364>>>>>            Move True to bRecnumTable
95365>>>>>        End
95365>>>>>>
95365>>>>>        
95365>>>>>        Move (SizeOfArray(aColumns)) to iSize
95366>>>>>        Decrement iSize
95367>>>>>        for iCount from 0 to iSize   
95373>>>>>>
95373>>>>>            Move aColumns[iCount].sFieldName to sFieldName
95374>>>>>            If (hTable > 0) Begin    
95376>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95377>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95378>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
95381>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
95382>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
95383>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95384>>>>>            End
95384>>>>>>
95384>>>>>            Else Begin
95385>>>>>                Move False to bFieldExists
95386>>>>>            End
95386>>>>>>
95386>>>>>            
95386>>>>>            If (bFieldExists = False) Begin 
95388>>>>>                Move 0 to iColumn
95389>>>>>                Create_Field hTable At iColumn                                                   
95390>>>>>            End  
95390>>>>>>
95390>>>>>            Else Begin
95391>>>>>                Move iCount to iColumn
95392>>>>>            End
95392>>>>>>
95392>>>>>            
95392>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
95393>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName                             
95396>>>>>
95396>>>>>            Move aColumns[iCount].iType to iType
95397>>>>>            Move (not(iType < -1490)) to bNativeType
95398>>>>>            If (iType < -1490) Begin
95400>>>>>                Move (iType + 1500) to iType
95401>>>>>            End
95401>>>>>>
95401>>>>>            
95401>>>>>            If (bIsSqlTable = True) Begin
95403>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
95405>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
95406>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iDataFlexType
95409>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType  
95412>>>>>                End
95412>>>>>>
95412>>>>>                Else Begin
95413>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
95416>>>>>                End
95416>>>>>>
95416>>>>>            End
95416>>>>>>
95416>>>>>            Else Begin
95417>>>>>                If (bCreating = False) Begin
95419>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
95420>>>>>                End
95420>>>>>>
95420>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
95423>>>>>            End
95423>>>>>>
95423>>>>>            
95423>>>>>            Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
95426>>>>>            Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
95429>>>>>            
95429>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
95431>>>>>                If (bRecnumTable = False) Begin
95433>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True 
95436>>>>>                End
95436>>>>>>
95436>>>>>                
95436>>>>>                Move 0 to iIndex 
95437>>>>>                Create_Index hTable at iIndex
95438>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
95441>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn  
95444>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
95447>>>>>                
95447>>>>>                // If we have an identity table - we must create a primary_key table. 
95447>>>>>                If (bIsSqlTable = True) Begin
95449>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True     
95452>>>>>                End
95452>>>>>>
95452>>>>>            End
95452>>>>>>
95452>>>>>        Loop
95453>>>>>>
95453>>>>>    End_Procedure
95454>>>>>
95454>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
95456>>>>>        Integer iCount iSize iColumn iType iIndex iColumnsToSize hFile
95456>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsSame bOK bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen
95456>>>>>        String sFieldName sTableName sDriverTo
95456>>>>>        
95456>>>>>        Move False to Err
95457>>>>>        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
95458>>>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
95459>>>>>        If (bIsSQLTableTo = False) Begin
95461>>>>>            Move DATAFLEX_ID to sDriverTo
95462>>>>>        End                            
95462>>>>>>
95462>>>>>        Else Begin
95463>>>>>            Get psDriverID to sDriverTo
95464>>>>>        End
95464>>>>>>
95464>>>>>        Get UtilTableHandleToString hTable to sTableName
95465>>>>>        
95465>>>>>        Move (SizeOfArray(aColumnsFrom)) to iSize 
95466>>>>>        Move (SizeOfArray(aColumnsTo)) to iColumnsToSize
95467>>>>>        Get OpenTableExclusive hTable to bOpened
95468>>>>>        
95468>>>>>        Decrement iSize
95469>>>>>        For iCount from 0 to iSize   
95475>>>>>>
95475>>>>>            Move aColumnsFrom[iCount].sFieldName   to sFieldName
95476>>>>>            Move aColumnsFrom[iCount].iFieldNumber to iColumn
95477>>>>>            If (hTable > 0) Begin                       
95479>>>>>                Move False to bFieldExists
95480>>>>>                If (iCount < iColumnsToSize) Begin
95482>>>>>                    Move aColumnsTo[iCount].sFieldName to sFieldName
95483>>>>>                    Move (Trim(sFieldName) <> "") to bFieldExists
95484>>>>>                End
95484>>>>>>
95484>>>>>            End
95484>>>>>>
95484>>>>>            Else Begin
95485>>>>>                Move False to bFieldExists
95486>>>>>            End
95486>>>>>>
95486>>>>>            
95486>>>>>            If (bFieldExists = True) Begin     
95488>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95489>>>>>                Get UtilColumnCompare sDriverIDFrom bIsSQLTableFrom bIsSQLTableTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DateTime to bIsSame
95490>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
95491>>>>>                If (bIsSame = False) Begin  
95493>>>>>                    // ToDo: We might need to set more properties for the field than what currently is set...
95493>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95494>>>>>                    Get ApiColumnChangeByColumnNumber sDriverIDFrom bIsSQLTableFrom hTable bIsSQLTableTo aColumnsFrom[iCount].sFieldName aColumnsFrom[iCount].iFieldNumber aColumnsFrom[iCount].iType aColumnsFrom[iCount].iLength aColumnsFrom[iCount].iPrecision aColumnsFrom[iCount].iOptions to bOK
95495>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
95496>>>>>                End
95496>>>>>>
95496>>>>>            End
95496>>>>>>
95496>>>>>            
95496>>>>>            If (bFieldExists = False) Begin  
95498>>>>>                Move False to bIsOpen
95499>>>>>                If (hTable > 0) Begin        
95501>>>>>                    Close hTable
95502>>>>>                    Open hTable Mode DF_EXCLUSIVE
95504>>>>>                    Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95507>>>>>                End
95507>>>>>>
95507>>>>>                If (bIsOpen = True) Begin
95509>>>>>                    Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
95512>>>>>                End 
95512>>>>>>
95512>>>>>                Else Begin
95513>>>>>                    Move True to bRecnumTable
95514>>>>>                End
95514>>>>>>
95514>>>>>
95514>>>>>                Move hTable to hFile
95515>>>>>                Structure_Start hFile sDriverIDFrom
95516>>>>>                    Move aColumnsFrom[iCount].iFieldNumber to iColumn
95517>>>>>                    Create_Field hFile At iColumn                                                   
95518>>>>>                    Set_Attribute DF_FIELD_NAME   of hFile iColumn to aColumnsFrom[iCount].sFieldName                                 
95521>>>>>//                    If (bIsSQLTable = True) Begin
95521>>>>>//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength - aColumnsFrom[iCount].iPrecision)
95521>>>>>                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to aColumnsFrom[iCount].iLength
95524>>>>>//                    End
95524>>>>>//                    Else Begin
95524>>>>>//                        Set_Attribute DF_FIELD_LENGTH of hFile iColumn to (aColumnsFrom[iCount].iLength + aColumnsFrom[iCount].iPrecision)
95524>>>>>//                    End
95524>>>>>                    
95524>>>>>                    If (aColumnsFrom[iCount].iPrecision > 0) Begin
95526>>>>>                        Set_Attribute DF_FIELD_PRECISION of hFile iColumn to aColumnsFrom[iCount].iPrecision
95529>>>>>                    End
95529>>>>>>
95529>>>>>                    
95529>>>>>                    Move aColumnsFrom[iCount].iType to iType
95530>>>>>                    Move (not(iType < -1490)) to bNativeType
95531>>>>>                    If (iType < -1490) Begin
95533>>>>>                        Move (iType + 1500) to iType
95534>>>>>                    End
95534>>>>>>
95534>>>>>                    // ToDo: This test is not enough. Do check for bSQLTableFrom
95534>>>>>                    If (bIsSQLTableTo = True) Begin
95536>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
95539>>>>>                    End
95539>>>>>>
95539>>>>>                    Else Begin
95540>>>>>                        Set_Attribute DF_FIELD_TYPE of hFile iColumn to iType
95543>>>>>                    End
95543>>>>>>
95543>>>>>                    
95543>>>>>                    If (aColumnsFrom[iCount].iOptions iand C_tAPIColumn_Identity) Begin 
95545>>>>>                        If (bRecnumTable = False) Begin
95547>>>>>                            Set_Attribute DF_FIELD_IS_IDENTITY     of hFile iColumn to True 
95550>>>>>                        End
95550>>>>>>
95550>>>>>                        // If we have an identity table - we must create a primary_key table. 
95550>>>>>                        Move 0 to iIndex 
95551>>>>>                        Create_Index hFile at iIndex
95552>>>>>                        Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
95555>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn  
95558>>>>>                        Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile iIndex to 1
95561>>>>>                        If (bIsSQLDriver = True) Begin
95563>>>>>                            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True     
95566>>>>>                        End
95566>>>>>>
95566>>>>>                    End  
95566>>>>>>
95566>>>>>                Structure_End hFile
95568>>>>>    
95568>>>>>            End
95568>>>>>>
95568>>>>>        Loop
95569>>>>>>
95569>>>>>            
95569>>>>>        Function_Return (Err = False)
95570>>>>>    End_Function
95571>>>>>
95571>>>>>    // Changes a field type, length and precision for the passed table number and field name
95571>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
95573>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
95573>>>>>        Boolean bOK bIsSqlTable  
95573>>>>>        String sFieldNameTo
95573>>>>>
95573>>>>>        If (num_arguments > 4) Begin
95575>>>>>            Move iPrec to iPrecFrom
95576>>>>>        End
95576>>>>>>
95576>>>>>        If (iTypeFrom < -1490) Begin
95578>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
95579>>>>>        End
95579>>>>>>
95579>>>>>        
95579>>>>>        Get AutoConnectionIDLogin to bOK
95580>>>>>        Move False to Err
95581>>>>>        Get OpenTableExclusive hTable to bOK
95582>>>>>        If (bOK = False) Begin
95584>>>>>            Function_Return False
95585>>>>>        End  
95585>>>>>>
95585>>>>>        
95585>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95586>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95587>>>>>        Field_Map hTable sFieldNameFrom to iColumn
95589>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95590>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95591>>>>>        If (Err = True) Begin
95593>>>>>            Function_Return False
95594>>>>>        End
95594>>>>>>
95594>>>>>        
95594>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
95597>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
95598>>>>>        If (bIsSqlTable = False) Begin
95600>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
95603>>>>>        End
95603>>>>>>
95603>>>>>        Else Begin
95604>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
95607>>>>>        End 
95607>>>>>>
95607>>>>>        // Let the driver decide the other values;
95607>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
95610>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
95613>>>>>        
95613>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
95615>>>>>            Function_Return False
95616>>>>>        End
95616>>>>>>
95616>>>>>
95616>>>>>        Structure_Start hTable      
95617>>>>>            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
95620>>>>>            If (bIsSqlTable = False) Begin
95622>>>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
95625>>>>>            End
95625>>>>>>
95625>>>>>            Else Begin
95626>>>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
95629>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
95632>>>>>            End
95632>>>>>>
95632>>>>>            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
95635>>>>>            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
95638>>>>>        Structure_End hTable
95640>>>>>
95640>>>>>        Function_Return (Err = False)
95641>>>>>    End_Function
95642>>>>>
95642>>>>>    // Changes a field type, length and precision for the passed table number and field name
95642>>>>>    Function ApiColumnChangeByColumnNumber String sDriverID Boolean bIsSQLTableFrom Handle hTable Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
95644>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType
95644>>>>>        Boolean bOK bIsSQL bCompareDate_DateTime bSkip
95644>>>>>        String sFieldNameTo    
95644>>>>>        tColumnType ColumnType
95644>>>>>        tColumnType ColumnType
95644>>>>>        
95644>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
95645>>>>>        Get piDbType to iDbType
95646>>>>>        If (num_arguments > 4) Begin
95648>>>>>            Move iPrec to iPrecFrom                                    
95649>>>>>            Move iOpt  to iOptionFrom
95650>>>>>        End
95650>>>>>>
95650>>>>>        If (iTypeFrom < -1490) Begin
95652>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
95653>>>>>        End
95653>>>>>>
95653>>>>>        
95653>>>>>        Get UtilTableIsSql hTable to bIsSQL
95654>>>>>        Get AutoConnectionIDLogin to bOK
95655>>>>>        Move False to Err
95656>>>>>        Get OpenTableExclusive hTable to bOK
95657>>>>>        If (bOK = False) Begin
95659>>>>>            Function_Return False
95660>>>>>        End  
95660>>>>>>
95660>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
95663>>>>>        
95663>>>>>        If (bIsSQLTableTo = True) Begin
95665>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
95668>>>>>        End
95668>>>>>>
95668>>>>>        Else Begin
95669>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
95672>>>>>        End
95672>>>>>>
95672>>>>>        
95672>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
95675>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo  
95678>>>>>        Get_Attribute DF_FIELD_IS_IDENTITY          of hTable iColumn to iOptionTo
95681>>>>>        
95681>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
95681>>>>>        // data types between Embedded and SQL.
95681>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
95683>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iTypeFrom
95684>>>>>        End
95684>>>>>>
95684>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
95687>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeTo   iLengthTo   to iTypeTo
95688>>>>>        End
95688>>>>>>
95688>>>>>        
95688>>>>>        
95688>>>>>        If (bCompareDate_DateTime = False) Begin
95690>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
95691>>>>>            If (bSkip = True) Begin
95693>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
95695>>>>>                    Function_Return False
95696>>>>>                End
95696>>>>>>
95696>>>>>            End
95696>>>>>>
95696>>>>>        End
95696>>>>>>
95696>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
95699>>>>>            Function_Return False
95700>>>>>        End
95700>>>>>>
95700>>>>>
95700>>>>>        Structure_Start hTable      
95701>>>>>            Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
95704>>>>>            If (bIsSQLTableTo = False) Begin
95706>>>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iTypeFrom
95709>>>>>            End
95709>>>>>>
95709>>>>>            Else Begin
95710>>>>>                Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iTypeFrom iLengthFrom to iDataFlexType
95711>>>>>                Set_Attribute DF_FIELD_TYPE         of hTable iColumn to iDataFlexType
95714>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
95717>>>>>            End
95717>>>>>>
95717>>>>>            Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
95720>>>>>            Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
95723>>>>>            
95723>>>>>            If (bIsSQL = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
95725>>>>>                Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
95728>>>>>            End
95728>>>>>>
95728>>>>>        Structure_End hTable
95730>>>>>
95730>>>>>        Function_Return (Err = False)
95731>>>>>    End_Function
95732>>>>>
95732>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
95734>>>>>        Boolean bOK
95734>>>>>
95734>>>>>        Get AutoConnectionIDLogin to bOK
95735>>>>>        Move False to Err
95736>>>>>        Get OpenTableExclusive hTable to bOK
95737>>>>>        If (bOK = False) Begin
95739>>>>>            Function_Return False
95740>>>>>        End
95740>>>>>>
95740>>>>>
95740>>>>>        Structure_Start hTable
95741>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
95744>>>>>        Structure_End hTable
95746>>>>>
95746>>>>>        Function_Return (Err = False)
95747>>>>>    End_Function
95748>>>>>
95748>>>>>    // To move an existing field to another position in a table.
95748>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Returns Boolean
95750>>>>>        String sColumn sDriverID
95750>>>>>        Integer iType iLength iPrecision
95750>>>>>        Boolean bOK
95750>>>>>
95750>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
95753>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
95755>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
95756>>>>>>
95756>>>>>            Function_Return False
95757>>>>>        End
95757>>>>>>
95757>>>>>
95757>>>>>        Close hTable
95758>>>>>        Get AutoConnectionIDLogin to bOK
95759>>>>>        Get OpenTableExclusive hTable to bOK
95760>>>>>        If (bOK = False) Begin
95762>>>>>            Function_Return False
95763>>>>>        End
95763>>>>>>
95763>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
95766>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
95769>>>>>
95769>>>>>        If (iType <> DF_DATE) Begin
95771>>>>>            Get_Attribute DF_FIELD_LENGTH of hTable iOld to iLength
95774>>>>>        End
95774>>>>>>
95774>>>>>
95774>>>>>        If (iType = DF_BCD) Begin
95776>>>>>            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
95779>>>>>        End
95779>>>>>>
95779>>>>>        Move False to Err
95780>>>>>
95780>>>>>        Structure_Start hTable
95781>>>>>            Delete_Field hTable iOld
95782>>>>>            Create_Field hTable At iNew
95783>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
95786>>>>>            Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
95789>>>>>
95789>>>>>            If (iType <> DF_DATE) Begin
95791>>>>>                Set_Attribute DF_FIELD_LENGTH of hTable iNew to iLength
95794>>>>>            End
95794>>>>>>
95794>>>>>
95794>>>>>            If (iType = DF_BCD) Begin
95796>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
95799>>>>>            End
95799>>>>>>
95799>>>>>
95799>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
95802>>>>>        Structure_End hTable
95804>>>>>
95804>>>>>        Function_Return (Err = False)
95805>>>>>    End_Function
95806>>>>>
95806>>>>>    // Deletes a column name for the passed table number (and column number).
95806>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
95808>>>>>        Integer iColumn
95808>>>>>        Boolean bOK
95808>>>>>
95808>>>>>        Get AutoConnectionIDLogin to bOK 
95809>>>>>        Move False to Err
95810>>>>>        Close hTable
95811>>>>>        Get OpenTableExclusive hTable to bOK
95812>>>>>        If (bOK = False) Begin
95814>>>>>            Function_Return False
95815>>>>>        End
95815>>>>>>
95815>>>>>        
95815>>>>>        If (not(Err)) Begin
95817>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95818>>>>>            Field_Map hTable sFieldName to iColumn
95820>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95821>>>>>            If (Err = True) Begin
95823>>>>>                Function_Return False
95824>>>>>            End
95824>>>>>>
95824>>>>>            Move False to Err
95825>>>>>    
95825>>>>>            Structure_Start hTable
95826>>>>>                Delete_Field hTable iColumn
95827>>>>>            Structure_End hTable
95829>>>>>        End  
95829>>>>>>
95829>>>>>        Else Begin
95830>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
95831>>>>>>
95831>>>>>        End
95831>>>>>>
95831>>>>>
95831>>>>>        Function_Return (Err = False)
95832>>>>>    End_Function
95833>>>>>
95833>>>>>    // Renames a field for the passed table number & old field name & new field name
95833>>>>>    // Returns True if no errors occured.
95833>>>>>    // Sample usage:
95833>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
95833>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
95835>>>>>        Integer iField
95835>>>>>        Boolean bOK
95835>>>>>
95835>>>>>        Get AutoConnectionIDLogin to bOK
95836>>>>>        Move False to Err
95837>>>>>        Get OpenTableExclusive hTable to bOK
95838>>>>>        If (bOK = False) Begin
95840>>>>>            Function_Return False
95841>>>>>        End
95841>>>>>>
95841>>>>>
95841>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95842>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95843>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
95844>>>>>        Structure_Start hTable
95845>>>>>            Field_Map hTable sOldFieldName to iField
95847>>>>>            If (iField > 0) Begin
95849>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
95852>>>>>            End
95852>>>>>>
95852>>>>>            Else Begin
95853>>>>>                Move 0 to LastErr
95854>>>>>                Move False to Err
95855>>>>>            End
95855>>>>>>
95855>>>>>        Structure_End hTable
95857>>>>>
95857>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
95858>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
95859>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95860>>>>>
95860>>>>>        Function_Return (Err = False)
95861>>>>>    End_Function
95862>>>>>
95862>>>>>    // *** Index Level Functions: ***
95862>>>>>    //
95862>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
95862>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
95862>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
95862>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
95864>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10
95864>>>>>        String sDriverID
95864>>>>>        Boolean bOK
95864>>>>>
95864>>>>>        Get AutoConnectionIDLogin to bOK
95865>>>>>        Move -1 to iSegment1
95866>>>>>        Move -1 to iSegment2
95867>>>>>        Move -1 to iSegment3
95868>>>>>        Move -1 to iSegment4
95869>>>>>        Move -1 to iSegment5
95870>>>>>        Move -1 to iSegment6
95871>>>>>        Move -1 to iSegment7
95872>>>>>        Move -1 to iSegment8
95873>>>>>        Move -1 to iSegment9
95874>>>>>        Move -1 to iSegment10
95875>>>>>
95875>>>>>        If (num_arguments > 3) Begin
95877>>>>>            Move iSgmnt1 to iSegment1
95878>>>>>        End
95878>>>>>>
95878>>>>>        If (num_arguments > 4) Begin
95880>>>>>            Move iSgmnt2 to iSegment2
95881>>>>>        End
95881>>>>>>
95881>>>>>        If (num_arguments > 5) Begin
95883>>>>>            Move iSgmnt3 to iSegment3
95884>>>>>        End
95884>>>>>>
95884>>>>>        If (num_arguments > 6) Begin
95886>>>>>            Move iSgmnt4 to iSegment4
95887>>>>>        End
95887>>>>>>
95887>>>>>        If (num_arguments > 7) Begin
95889>>>>>            Move iSgmnt5 to iSegment5
95890>>>>>        End
95890>>>>>>
95890>>>>>        If (num_arguments > 8) Begin
95892>>>>>            Move iSgmnt6 to iSegment6
95893>>>>>        End
95893>>>>>>
95893>>>>>        If (num_arguments > 9) Begin
95895>>>>>            Move iSgmnt7 to iSegment7
95896>>>>>        End
95896>>>>>>
95896>>>>>        If (num_arguments > 10) Begin
95898>>>>>            Move iSgmnt8 to iSegment8
95899>>>>>        End
95899>>>>>>
95899>>>>>        If (num_arguments > 11) Begin
95901>>>>>            Move iSgmnt9 to iSegment9
95902>>>>>        End
95902>>>>>>
95902>>>>>        If (num_arguments > 12) Begin
95904>>>>>            Move iSgmnt10 to iSegment10
95905>>>>>        End
95905>>>>>>
95905>>>>>
95905>>>>>        Move False to Err
95906>>>>>        Move hTable to iTableNo
95907>>>>>        Get OpenTableExclusive hTable to bOK
95908>>>>>        If (bOK = False) Begin
95910>>>>>            Function_Return False
95911>>>>>        End
95911>>>>>>
95911>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
95914>>>>>
95914>>>>>        // We start by deleting the index
95914>>>>>        Structure_Start hTable sDriverID
95915>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95916>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
95917>>>>>            Delete_Index iTableNo iIndex
95918>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
95919>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
95920>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
95922>>>>>
95922>>>>>        Move False to Err
95923>>>>>        Move iTableNo to hTable
95924>>>>>        Get OpenTableExclusive hTable to bOK
95925>>>>>        If (bOK = False) Begin
95927>>>>>            Function_Return False
95928>>>>>        End
95928>>>>>>
95928>>>>>
95928>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
95929>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95929>>>>>        Structure_Start hTable sDriverID
95930>>>>>            Create_Index hTable At iIndex
95931>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
95934>>>>>
95934>>>>>            If (iSgmnt1 <> -1) Begin
95936>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
95939>>>>>            End
95939>>>>>>
95939>>>>>            If (iSegment2 <> -1) Begin
95941>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
95944>>>>>            End
95944>>>>>>
95944>>>>>            If (iSegment3 <> -1) Begin
95946>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
95949>>>>>            End
95949>>>>>>
95949>>>>>            If (iSegment4 <> -1) Begin
95951>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
95954>>>>>            End
95954>>>>>>
95954>>>>>            If (iSegment5 <> -1) Begin
95956>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
95959>>>>>            End
95959>>>>>>
95959>>>>>            If (iSegment6 <> -1) Begin
95961>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
95964>>>>>            End
95964>>>>>>
95964>>>>>            If (iSegment7 <> -1) Begin
95966>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
95969>>>>>            End
95969>>>>>>
95969>>>>>            If (iSegment8 <> -1) Begin
95971>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
95974>>>>>            End
95974>>>>>>
95974>>>>>            If (iSegment9 <> -1) Begin
95976>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
95979>>>>>            End
95979>>>>>>
95979>>>>>            If (iSegment10 <> -1) Begin
95981>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
95984>>>>>            End
95984>>>>>>
95984>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
95986>>>>>
95986>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
95987>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
95987>>>>>
95987>>>>>        Function_Return (Err = False)
95988>>>>>    End_Function
95989>>>>>
95989>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex Integer iIndex tAPIIndexSegment[] aIndexSegments Returns Boolean 
95991>>>>>        String[] aFields
95992>>>>>        Integer iCount iSize iMax iTableNo iField iSegments
95992>>>>>        String sDriverID
95992>>>>>        Boolean bOK 
95992>>>>>
95992>>>>>        Move (SizeOfArray(aIndexSegments)) to iSize
95993>>>>>        If (iSize = 0) Begin
95995>>>>>            Function_Return False                                                            
95996>>>>>        End
95996>>>>>>
95996>>>>>        Decrement iSize
95997>>>>>        
95997>>>>>        Move hTable to iTableNo
95998>>>>>        Get AutoConnectionIDLogin to bOK
95999>>>>>        Move False to Err
96000>>>>>        Get OpenTableExclusive hTable to bOK
96001>>>>>        If (bOK = False) Begin
96003>>>>>            Function_Return False
96004>>>>>        End
96004>>>>>>
96004>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96007>>>>>        
96007>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER 
96008>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
96009>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
96010>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96011>>>>>        // We will only attempt to delete the index in case it exists.
96011>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
96014>>>>>        If (iSegments > 0) Begin
96016>>>>>            // We start by deleting the index
96016>>>>>            Structure_Start hTable sDriverID 
96017>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96018>>>>>                Delete_Index iTableNo iIndex
96019>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96020>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE
96022>>>>>        End
96022>>>>>>
96022>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER 
96023>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
96024>>>>>        Send Trap_Error of Error_Object_Id DFERR_FIELD_NUMBER_RANGE
96025>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96026>>>>>        
96026>>>>>        Move False to Err
96027>>>>>        Move 0 to LastErr
96028>>>>>        Move iTableNo to hTable
96029>>>>>        Get OpenTableExclusive hTable to bOK
96030>>>>>        If (bOK = False) Begin
96032>>>>>            Function_Return False
96033>>>>>        End
96033>>>>>>
96033>>>>>    
96033>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
96034>>>>>        Structure_Start hTable sDriverID
96035>>>>>            Create_Index hTable At iIndex
96036>>>>>            Set_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndex.sSQLIndexName
96039>>>>>            Set_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
96042>>>>>            Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndex.bIsPrimaryKey
96045>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iSize + 1)
96048>>>>>            for iCount from 0 to iSize
96054>>>>>>
96054>>>>>                Move aIndexSegments[iCount].iFieldNumber to iField
96055>>>>>                If (iField <> -1) Begin 
96057>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iCount + 1) to iField
96060>>>>>                End
96060>>>>>>
96060>>>>>            Loop
96061>>>>>>
96061>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
96063>>>>>
96063>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
96064>>>>>        Function_Return (Err = False)
96065>>>>>    End_Function
96066>>>>>    
96066>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
96068>>>>>        Boolean bOK
96068>>>>>
96068>>>>>        Get AutoConnectionIDLogin to bOK
96069>>>>>        Move False to Err
96070>>>>>        Get OpenTableExclusive hTable to bOK
96071>>>>>        If (bOK = False) Begin
96073>>>>>            Function_Return False
96074>>>>>        End
96074>>>>>>
96074>>>>>        Structure_Start hTable
96075>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
96078>>>>>        Structure_End hTable
96080>>>>>
96080>>>>>        Function_Return (Err = False)
96081>>>>>    End_Function
96082>>>>>
96082>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
96084>>>>>        Integer iCase
96084>>>>>        Boolean bOK
96084>>>>>
96084>>>>>        If (bUppercase = True) Begin
96086>>>>>            Move DF_CASE_IGNORED to iCase
96087>>>>>        End
96087>>>>>>
96087>>>>>        Else Begin
96088>>>>>            Move DF_CASE_USED to iCase
96089>>>>>        End
96089>>>>>>
96089>>>>>
96089>>>>>        Get AutoConnectionIDLogin to bOK
96090>>>>>        Move False to Err
96091>>>>>        Get OpenTableExclusive hTable to bOK
96092>>>>>        If (bOK = False) Begin
96094>>>>>            Function_Return False
96095>>>>>        End
96095>>>>>>
96095>>>>>        Structure_Start hTable
96096>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
96099>>>>>        Structure_End hTable
96101>>>>>
96101>>>>>        Function_Return (Err = False)
96102>>>>>    End_Function
96103>>>>>
96103>>>>>    // To delete an index
96103>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
96105>>>>>        Integer iTableNo iNumSegments
96105>>>>>        String sDriverID
96105>>>>>        Boolean bOK
96105>>>>>
96105>>>>>        Get AutoConnectionIDLogin to bOK
96106>>>>>        Move False to Err
96107>>>>>        Move hTable to iTableNo
96108>>>>>        Get OpenTableExclusive hTable to bOK
96109>>>>>        If (bOK = False) Begin
96111>>>>>            Function_Return False
96112>>>>>        End
96112>>>>>>
96112>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96115>>>>>
96115>>>>>        // Check to see if the index exists or not...
96115>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96118>>>>>        If (iNumSegments = 0) Begin
96120>>>>>            Function_Return False
96121>>>>>        End
96121>>>>>>
96121>>>>>
96121>>>>>        Structure_Start hTable sDriverID
96122>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
96123>>>>>            Delete_Index iTableNo iIndex
96124>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
96125>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
96127>>>>>
96127>>>>>        Function_Return (Err = False)
96128>>>>>    End_Function
96129>>>>>
96129>>>>>    // Delete an Index Segment
96129>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
96131>>>>>        Boolean bOK bSQLDriver bIndexTemporary
96131>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
96131>>>>>        Integer iIndexType
96131>>>>>        String sDriverID 
96131>>>>>
96131>>>>>        Get AutoConnectionIDLogin to bOK
96132>>>>>        Move False to Err
96133>>>>>    
96133>>>>>        Get OpenTableExclusive hTable to bOK
96134>>>>>        If (bOK = False) Begin
96136>>>>>            Function_Return False
96137>>>>>        End
96137>>>>>>
96137>>>>>        
96137>>>>>        // Check to see if the index exists or not...
96137>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96140>>>>>        If (iNumSegments = 0) Begin
96142>>>>>            Function_Return False
96143>>>>>        End
96143>>>>>>
96143>>>>>        
96143>>>>>        Move False to bIndexTemporary
96144>>>>>        Get psDriverID to sDriverID
96145>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
96146>>>>>        If (bSQLDriver) Begin
96148>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
96151>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
96154>>>>>                Move True to bIndexTemporary
96155>>>>>        End
96155>>>>>>
96155>>>>>    
96155>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
96155>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
96157>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96160>>>>>            If (iSegment = iNumSegments) Begin
96162>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96165>>>>>            End
96165>>>>>>
96165>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
96168>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
96174>>>>>>
96174>>>>>                    //*** Move index segment attributes
96174>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
96177>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
96180>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
96183>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
96186>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
96189>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
96192>>>>>                Loop
96193>>>>>>
96193>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96196>>>>>            End
96196>>>>>>
96196>>>>>        End
96196>>>>>>
96196>>>>>
96196>>>>>        Else Begin
96197>>>>>           Structure_Start hTable
96198>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96201>>>>>               If (iSegment = iNumSegments) Begin
96203>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96206>>>>>               End
96206>>>>>>
96206>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
96209>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
96215>>>>>>
96215>>>>>                       //*** Move index segment attributes
96215>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
96218>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
96221>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
96224>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
96227>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
96230>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
96233>>>>>                   Loop
96234>>>>>>
96234>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
96237>>>>>               End
96237>>>>>>
96237>>>>>           Structure_End hTable
96239>>>>>        End
96239>>>>>>
96239>>>>>        
96239>>>>>        Function_Return (Err = False)
96240>>>>>    End_Function
96241>>>>>    
96241>>>>>    // Add/Insert an Index Segment
96241>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
96243>>>>>        Boolean bOK bSQLDriver bIndexTemporary
96243>>>>>        Integer iSQLType iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
96243>>>>>        Integer iIndexType
96243>>>>>        String sDriverId
96243>>>>>        
96243>>>>>        Get AutoConnectionIDLogin to bOK
96244>>>>>        Move False to Err
96245>>>>>    
96245>>>>>        Get OpenTableExclusive hTable to bOK
96246>>>>>        If (bOK = False) Begin
96248>>>>>            Function_Return False
96249>>>>>        End
96249>>>>>>
96249>>>>>        
96249>>>>>        Move False to bIndexTemporary
96250>>>>>        // Check to see if the index exists or not...
96250>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96253>>>>>        If (iNumSegments = 0) Begin
96255>>>>>            Function_Return False
96256>>>>>        End
96256>>>>>>
96256>>>>>    
96256>>>>>        Get psDriverID to sDriverID
96257>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
96258>>>>>        If (bSQLDriver) Begin
96260>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
96263>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
96266>>>>>                Move True to bIndexTemporary
96267>>>>>        End
96267>>>>>>
96267>>>>>
96267>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
96267>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
96269>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96272>>>>>    
96272>>>>>           If (iSegment > iNumSegments) Begin
96274>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
96277>>>>>               Move (iNumSegments + 1) to iCurSegment
96278>>>>>           End
96278>>>>>>
96278>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
96281>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
96284>>>>>               Move iNumSegments to iCurSegment
96285>>>>>           
96285>>>>>               While (iCurSegment > iSegment)
96289>>>>>                   //*** Move index segment attributes
96289>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
96292>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
96295>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
96298>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
96301>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
96304>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
96307>>>>>                   Decrement iCurSegment
96308>>>>>               End
96309>>>>>>
96309>>>>>           
96309>>>>>               //*** Now set new segment attributes
96309>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
96312>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
96315>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
96318>>>>>           End
96318>>>>>>
96318>>>>>        End
96318>>>>>>
96318>>>>>        
96318>>>>>        Else Begin
96319>>>>>           Structure_Start hTable
96320>>>>>              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96323>>>>>           
96323>>>>>              If (iSegment > iNumSegments) Begin
96325>>>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
96328>>>>>                  Move (iNumSegments + 1) to iCurSegment
96329>>>>>              End
96329>>>>>>
96329>>>>>              Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
96332>>>>>                  Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
96335>>>>>                  Move iNumSegments to iCurSegment
96336>>>>>              
96336>>>>>                  While (iCurSegment > iSegment)
96340>>>>>                      //*** Move index segment attributes
96340>>>>>                      Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
96343>>>>>                      Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
96346>>>>>                      Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
96349>>>>>                      Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
96352>>>>>                      Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
96355>>>>>                      Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
96358>>>>>                      Decrement iCurSegment
96359>>>>>                  End
96360>>>>>>
96360>>>>>              
96360>>>>>                  //*** Now set new segment attributes
96360>>>>>                  Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
96363>>>>>                  Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
96366>>>>>                  Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
96369>>>>>              End
96369>>>>>>
96369>>>>>           Structure_End hTable
96371>>>>>        End
96371>>>>>>
96371>>>>>        
96371>>>>>        Function_Return (Err = False)
96372>>>>>    End_Function
96373>>>>>    
96373>>>>>    // Returns an SQL Driver ID if it appears as a prefix for the passed sRootName
96373>>>>>    // If no driver found the DATAFLEX_ID is returned
96373>>>>>//    Function UtilDriverIDFromRootName String sRootName Returns String
96373>>>>>//        String sDriverID
96373>>>>>//        Integer iPos
96373>>>>>//        Move (Pos(":", sRootName)) to iPos
96373>>>>>//        If (iPos <> 0) Begin
96373>>>>>//            Move (Left(sRootName, (iPos -1))) to sDriverID
96373>>>>>//        End
96373>>>>>//        Else Begin
96373>>>>>//            Move DATAFLEX_ID to sDriverID
96373>>>>>//        End
96373>>>>>//        Function_Return sDriverID
96373>>>>>//    End_Function              
96373>>>>>    
96373>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
96373>>>>>    // Note that it first removes any driver prefixes in the rootname.
96373>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfoFrom tAPITableNameInfo APITableInfoTo Returns Boolean
96375>>>>>        Boolean bTheSame 
96375>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
96375>>>>>        
96375>>>>>        Get _TableNameOnly APITableInfoFrom.sRootName to sRootNameFrom
96376>>>>>        Get _TableNameOnly APITableInfoTo.sRootName   to sRootNameTo                                    
96377>>>>>        Move APITableInfoFrom.sLogicalName            to sLogicalNameFrom
96378>>>>>        Move APITableInfoTo.sLogicalName              to sLogicalNameTo
96379>>>>>        Move APITableInfoFrom.sDisplayName            to sDisplayNameFrom
96380>>>>>        Move APITableInfoTo.sDisplayName              to sDisplayNameTo
96381>>>>>        If (bCompareFilelistUppercase = True) Begin
96383>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bTheSame
96384>>>>>        End
96384>>>>>>
96384>>>>>        Else Begin
96385>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bTheSame                  
96386>>>>>        End
96386>>>>>>
96386>>>>>            
96386>>>>>        Function_Return bTheSame
96387>>>>>    End_Function                
96388>>>>>    
96388>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
96390>>>>>        Handle hTableFrom hTableTo 
96390>>>>>        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
96390>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase 
96390>>>>>        String sRootName sDriverID
96390>>>>>
96390>>>>>        Move False to bFilelistError
96391>>>>>        Move True to bIsSame
96392>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
96393>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
96394>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
96395>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
96396>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo          
96397>>>>>        
96397>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
96398>>>>>        Get _TableNameOnly sRootName             to sRootName
96399>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
96400>>>>>
96400>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
96400>>>>>        // bCodeGenerateMode = True = Code Generation mode.
96400>>>>>        If (bCodeGenerateMode = True) Begin
96402>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
96402>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
96404>>>>>                Function_Return False
96405>>>>>            End
96405>>>>>>
96405>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
96406>>>>>            If (bIsSame = False) Begin   
96408>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
96409>>>>>                Move True to bFilelistError
96410>>>>>                Function_Return False
96411>>>>>            End
96411>>>>>>
96411>>>>>        End
96411>>>>>>
96411>>>>>        
96411>>>>>        If (bCodeGenerateMode = False) Begin
96413>>>>>            // Then we want to create this table
96413>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
96415>>>>>                Function_Return False
96416>>>>>            End
96416>>>>>>
96416>>>>>                
96416>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
96417>>>>>            If (bIsSame = False) Begin
96419>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
96420>>>>>>
96420>>>>>                Move True to bFilelistError
96421>>>>>                Function_Return False
96422>>>>>            End
96422>>>>>>
96422>>>>>        End
96422>>>>>>
96422>>>>>
96422>>>>>        // Check columns:                        
96422>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
96423>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
96424>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom 
96425>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
96426>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverID
96427>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns  
96428>>>>>        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bIsSame
96429>>>>>        If (bIsSame = False) Begin
96431>>>>>            Function_Return False
96432>>>>>        End
96432>>>>>>
96432>>>>>        
96432>>>>>        // ...then check indexes:
96432>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
96433>>>>>        Get UtilIndexesCompare    hTableFrom APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending to bIsSame
96434>>>>>        If (bIsSame = False) Begin
96436>>>>>            Function_Return False
96437>>>>>        End
96437>>>>>>
96437>>>>>        
96437>>>>>        // ...and finally relationships:
96437>>>>>        Get UtilRelationStructFill hTableFrom to APITableTo.aApiRelations
96438>>>>>        Get UtilRelationsCompare      hTableFrom APITableFrom.aApiRelations APITableTo.aApiRelations to bIsSame
96439>>>>>        
96439>>>>>        Function_Return (bIsSame = True)
96440>>>>>    End_Function
96441>>>>>    
96441>>>>>    // Similar to UtilTableCompare, but takes two tAPITable struct arrays as parameters and a apitableboolean struct as params.
96441>>>>>    Function UtilTableCompare_Ex tAPITable CompareTableFrom tAPITable CompareTableTo tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
96443>>>>>        Handle hTableFrom hTableTo 
96443>>>>>        Boolean bIsSame bIsAlias bIsSQLFrom bIsSQLTo
96443>>>>>        tAPITableNameInfo APITableInfoFrom APITableInfoTo
96443>>>>>        tAPITableNameInfo APITableInfoFrom APITableInfoTo
96443>>>>>        tAPIIndex[]    aIndexesFrom   aIndexesTo
96443>>>>>        tAPIIndex[]    aIndexesFrom   aIndexesTo
96445>>>>>        tAPIColumn[]   aColumnsFrom   aColumnsTo
96445>>>>>        tAPIColumn[]   aColumnsFrom   aColumnsTo
96447>>>>>        tAPIRelation[] aRelationsFrom aRelationsTo        
96447>>>>>        tAPIRelation[] aRelationsFrom aRelationsTo        
96449>>>>>        String sRootName sDriverID
96449>>>>>        
96449>>>>>        If (CompareTableFrom.ApiTableInfo.iTableNumber < 0 or CompareTableTo.ApiTableInfo.iTableNumber < 0) Begin
96451>>>>>            Move True to bFilelistError
96452>>>>>            Function_Return False    
96453>>>>>        End 
96453>>>>>>
96453>>>>>        
96453>>>>>        Move True  to bIsSame 
96454>>>>>        Move False to bFilelistError
96455>>>>>        
96455>>>>>        Move CompareTableFrom.ApiTableInfo  to APITableInfoFrom
96456>>>>>        Move CompareTableFrom.aApiColumns   to aColumnsFrom
96457>>>>>        Move CompareTableFrom.aApiIndexes   to aIndexesFrom
96458>>>>>        Move CompareTableFrom.aApiRelations to aRelationsFrom  
96459>>>>>        Move APITableInfoFrom.iTableNumber  to hTableFrom 
96460>>>>>        Move APITableInfoFrom.bIsSQL        to bIsSQLFrom         
96461>>>>>        Move APITableInfoFrom.sDriverID     to sDriverID
96462>>>>>        
96462>>>>>        Move CompareTableTo.ApiTableInfo    to APITableInfoTo
96463>>>>>        Move CompareTableTo.aApiColumns     to aColumnsTo
96464>>>>>        Move CompareTableTo.aApiIndexes     to aIndexesTo
96465>>>>>        Move CompareTableTo.aApiRelations   to aRelationsTo
96466>>>>>        Move APITableInfoTo.iTableNumber    to hTableTo          
96467>>>>>        Move APITableInfoTo.bIsSQL          to bIsSQLTo
96468>>>>>        
96468>>>>>        Move APITableInfoTo.sRootName       to sRootName
96469>>>>>        Get _TableNameOnly sRootName        to sRootName
96470>>>>>
96470>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
96470>>>>>        // bCodeGenerateMode = True = Code Generation mode.
96470>>>>>        If (bCodeGenerateMode = True) Begin
96472>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
96472>>>>>            If (Trim(APITableInfoTo.sLogicalName) = "") Begin
96474>>>>>                Function_Return False
96475>>>>>            End                                                                    
96475>>>>>>
96475>>>>>            Move (Uppercase(APITableInfoFrom.sLogicalName) = Uppercase(APITableInfoTo.sLogicalName)) to bIsSame
96476>>>>>            If (bIsSame = False) Begin
96478>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableInfoFrom.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableInfoTo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
96479>>>>>                Move True to bFilelistError
96480>>>>>                Function_Return False
96481>>>>>            End
96481>>>>>>
96481>>>>>        End
96481>>>>>>
96481>>>>>        
96481>>>>>        If (bCodeGenerateMode = False) Begin
96483>>>>>            If (Trim(Uppercase(APITableInfoTo.sLogicalName)) = "") Begin
96485>>>>>                // Then we might want to create this table
96485>>>>>                Function_Return False
96486>>>>>            End
96486>>>>>>
96486>>>>>            
96486>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableInfoFrom APITableInfoTo to bIsSame
96487>>>>>            If (bIsSame = False) Begin
96489>>>>>                Function_Return False
96490>>>>>            End
96490>>>>>>
96490>>>>>        End
96490>>>>>>
96490>>>>>
96490>>>>>        // Check columns:         
96490>>>>>        Get UtilColumnsCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom aColumnsTo CompareTableBooleans.bCompareDate_DateTime to bIsSame
96491>>>>>        If (bIsSame = False) Begin
96493>>>>>            Function_Return False
96494>>>>>        End
96494>>>>>>
96494>>>>>        
96494>>>>>        // ...then check indexes:
96494>>>>>        Get UtilIndexesCompare hTableFrom aIndexesFrom aIndexesTo CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
96495>>>>>        If (bIsSame = False) Begin
96497>>>>>            Function_Return False
96498>>>>>        End
96498>>>>>>
96498>>>>>        
96498>>>>>        // ...and finally relationships:
96498>>>>>        Get UtilRelationsCompare hTableFrom aRelationsFrom aRelationsTo to bIsSame
96499>>>>>        
96499>>>>>        Function_Return (bIsSame = True)
96500>>>>>    End_Function
96501>>>>>    
96501>>>>>    // Compare multiple columns. (For 'From' & 'To' tables)
96501>>>>>    Function UtilColumnsCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
96503>>>>>        Boolean bIsSame        
96503>>>>>        Integer iCount iSize iSizeFrom iSizeTo iColumn iType iLength
96503>>>>>        String sColumnNameFrom sColumnNameTo
96503>>>>>        
96503>>>>>        Move True to bIsSame
96504>>>>>        Move (SizeOfArray(aColumnsFrom)) to iSizeFrom
96505>>>>>        Move (SizeOfArray(aColumnsTo))   to iSizeTo
96506>>>>>        If (iSizeFrom <> iSizeTo) Begin
96508>>>>>            Function_Return False
96509>>>>>        End          
96509>>>>>>
96509>>>>>        Move (iSizeFrom max iSizeTo)     to iSize 
96510>>>>>        Set piMaximum of ghoProgressBar  to iSize
96511>>>>>        
96511>>>>>        Decrement iSize
96512>>>>>        for iCount from 0 to iSize       
96518>>>>>>
96518>>>>>            Set piPosition of ghoProgressBar to iCount
96519>>>>>            If (iCount <= iSizeFrom and iCount <= iSizeTo) Begin
96521>>>>>                Get UtilColumnCompare sDriverID bIsSQLFrom bIsSQLTo aColumnsFrom[iCount] aColumnsTo[iCount] bCompareDate_DataTime to bIsSame
96522>>>>>            End 
96522>>>>>>
96522>>>>>            Else Begin
96523>>>>>                Move False to bIsSame
96524>>>>>            End
96524>>>>>>
96524>>>>>            
96524>>>>>            If (bIsSame = False) Begin
96526>>>>>                Function_Return False
96527>>>>>            End
96527>>>>>>
96527>>>>>        Loop
96528>>>>>>
96528>>>>>        
96528>>>>>        Function_Return (bIsSame = True)
96529>>>>>    End_Function
96530>>>>>    
96530>>>>>    // Compares a single column (For 'From' & 'To' tables)
96530>>>>>    Function UtilColumnCompare String sDriverID Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumn aColumnsFrom tAPIColumn aColumnsTo Boolean bCompareDate_DataTime Returns Boolean
96532>>>>>        Boolean bIsSame 
96532>>>>>        Integer iFromType iToType iDbType                    
96532>>>>>        tColumnType ColumnType
96532>>>>>        tColumnType ColumnType
96532>>>>>        
96532>>>>>        Get piDbType to iDbType
96533>>>>>        Move (aColumnsFrom.iFieldNumber <> 0 and aColumnsTo.iFieldNumber <> 0) to bIsSame
96534>>>>>        // Check that _both_ field_number and field_name are the same
96534>>>>>        // else they needs to be changed...                                  
96534>>>>>        If (bIsSame = False) Begin
96536>>>>>            Move (aColumnsFrom.iFieldNumber = aColumnsTo.iFieldNumber) to bIsSame
96537>>>>>        End
96537>>>>>>
96537>>>>>        If (bIsSame = False) Begin
96539>>>>>            Function_Return False
96540>>>>>        End
96540>>>>>>
96540>>>>>        Move (aColumnsFrom.sFieldName = aColumnsTo.sFieldName) to bIsSame
96541>>>>>        If (bIsSame = False) Begin
96543>>>>>            Function_Return False
96544>>>>>        End
96544>>>>>>
96544>>>>>        
96544>>>>>        Move aColumnsFrom.iType to iFromType
96545>>>>>        Move aColumnsTo.iType   to iToType
96546>>>>>        
96546>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
96546>>>>>        // data types between Embedded and SQL.
96546>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
96548>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iFromType aColumnsFrom.iLength to iFromType
96549>>>>>        End
96549>>>>>>
96549>>>>>        Else If (bIsSQLFrom = False and bIsSQLTo = True) Begin
96552>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iToType   aColumnsFrom.iLength to iToType
96553>>>>>        End
96553>>>>>>
96553>>>>>        
96553>>>>>        // *** THIS NEEDS TO BE REDONE ***
96553>>>>>        
96553>>>>>        // Make Date and DateTime comparison?
96553>>>>>        If (bCompareDate_DataTime = True and iFromType = DF_DATE or iFromType = DF_DATETIME or iFromType = SQL_TYPE_TIMESTAMP or iFromType = SQL_TYPE_TIMESTAMP2) Begin
96555>>>>>            Move (iFromType = iToType) to bIsSame
96556>>>>>            If (bIsSame = False) Begin
96558>>>>>                Function_Return False
96559>>>>>            End
96559>>>>>>
96559>>>>>        End
96559>>>>>>
96559>>>>>        
96559>>>>>        // This is when checking for other field types than dates...
96559>>>>>//        If (bCompareDate_DataTime = False and iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
96559>>>>>            Move (iFromType = iToType) to bIsSame
96560>>>>>            If (bIsSame = False) Begin
96562>>>>>                Function_Return False
96563>>>>>            End
96563>>>>>>
96563>>>>>//        End
96563>>>>>        
96563>>>>>        // If the field is of Date type (any of them) we don't compare length & precision.
96563>>>>>        If (iFromType <> DF_DATE and iFromType <> DF_DATETIME and iFromType <> SQL_TYPE_TIMESTAMP and iFromType <> SQL_TYPE_TIMESTAMP2) Begin
96565>>>>>            Move (aColumnsFrom.iLength = aColumnsTo.iLength) to bIsSame
96566>>>>>            If (bIsSame = False) Begin
96568>>>>>                Function_Return False
96569>>>>>            End                                               
96569>>>>>>
96569>>>>>            Move (aColumnsFrom.iPrecision = aColumnsTo.iPrecision) to bIsSame
96570>>>>>            If (bIsSame = False) Begin
96572>>>>>                Function_Return False
96573>>>>>            End                                               
96573>>>>>>
96573>>>>>        End
96573>>>>>>
96573>>>>>        
96573>>>>>        Move (aColumnsFrom.iOptions = aColumnsTo.iOptions) to bIsSame
96574>>>>>        If (bIsSame = False) Begin
96576>>>>>            Function_Return False
96577>>>>>        End                                               
96577>>>>>>
96577>>>>>
96577>>>>>        Function_Return True
96578>>>>>    End_Function
96579>>>>>    
96579>>>>>    // Compares multiple indexes for a 'From' and a 'To' table.
96579>>>>>    Function UtilIndexesCompare Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
96581>>>>>        Boolean bIsSame bDAWSQLDriver 
96581>>>>>        Integer iCount iSize iSizeFrom iSizeTo iSegment iNumSegments iColumn
96581>>>>>        String sIndexNameFrom sIndexNameTo sDriverID sColumnNameFrom
96581>>>>>        
96581>>>>>        Move True to bIsSame
96582>>>>>        Get psDriverID to sDriverID
96583>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
96584>>>>>        
96584>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
96585>>>>>        Move (SizeOfArray(aIndexesTo))   to iSizeTo  
96586>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
96588>>>>>            Function_Return True
96589>>>>>        End
96589>>>>>>
96589>>>>>        If (iSizeFrom <> iSizeTo) Begin
96591>>>>>            Function_Return False
96592>>>>>        End          
96592>>>>>>
96592>>>>>        Move (iSizeFrom max iSizeTo) to iSize
96593>>>>>
96593>>>>>        Decrement iSize
96594>>>>>        For iCount from 0 to iSize 
96600>>>>>>
96600>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96601>>>>>            Get UtilIndexCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
96602>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96603>>>>>            If (bIsSame = False) Begin
96605>>>>>                Function_Return False
96606>>>>>            End
96606>>>>>>
96606>>>>>        Loop
96607>>>>>>
96607>>>>>        
96607>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96608>>>>>        Function_Return bIsSame
96609>>>>>    End_Function
96610>>>>>    
96610>>>>>    // Compares a single index for a 'From' and a 'To' table.
96610>>>>>    Function UtilIndexCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
96612>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
96612>>>>>        String sDriverID  
96612>>>>>        Integer iSegment
96612>>>>>        
96612>>>>>        Move True to bIsSame
96613>>>>>        Get psDriverID to sDriverID
96614>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
96615>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
96616>>>>>        If (bIsSqlTable = True) Begin
96618>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
96619>>>>>        End
96619>>>>>>
96619>>>>>        
96619>>>>>        Move True to bIsSame
96620>>>>>        If (bIsSqlTable = True) Begin
96622>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
96623>>>>>            If (bIsSame = False) Begin
96625>>>>>                Function_Return False
96626>>>>>            End
96626>>>>>>
96626>>>>>            Move (aIndexFrom.bIsPrimaryKey = aIndexTo.bIsPrimaryKey) to bIsSame
96627>>>>>            If (bIsSame = False) Begin
96629>>>>>                Function_Return False
96630>>>>>            End
96630>>>>>>
96630>>>>>            Move (aIndexFrom.sSQLIndexName = aIndexTo.sSQLIndexName) to bIsSame
96631>>>>>            If (bIsSame = False) Begin
96633>>>>>                Function_Return False
96634>>>>>            End
96634>>>>>>
96634>>>>>        End
96634>>>>>>
96634>>>>>        
96634>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96635>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
96636>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96637>>>>>        If (bIsSame = False) Begin
96639>>>>>            Function_Return False
96640>>>>>        End                      
96640>>>>>>
96640>>>>>        
96640>>>>>        Get UtilIndexSegmentsCompare aIndexFrom aIndexTo bCompareIndexUppercase bCompareIndexAscending to iSegment
96641>>>>>        If (iSegment = -1) Begin
96643>>>>>            Move True to bIsSame
96644>>>>>        End  
96644>>>>>>
96644>>>>>        Else Begin                                                         
96645>>>>>            Move True to aIndexTo.bShouldChange
96646>>>>>            Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
96647>>>>>        End
96647>>>>>>
96647>>>>>        
96647>>>>>        Function_Return (bIsSame = True)
96648>>>>>    End_Function
96649>>>>>    
96649>>>>>    // Compares each segment for the passed index.
96649>>>>>    // Returns -1 if same; else returns the index segment that differs.
96649>>>>>    Function UtilIndexSegmentsCompare tAPIIndex aIndexFrom tAPIIndex aIndexTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
96651>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment                                                
96651>>>>>        Boolean bIsSame
96651>>>>>        
96651>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96652>>>>>        Move (SizeOfArray(aIndexFrom.IndexSegmentArray)) to iNumSegmentsFrom
96653>>>>>        Move (SizeOfArray(aIndexTo.IndexSegmentArray))   to iNumSegmentsTo
96654>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo)       to iNumSegments
96655>>>>>        
96655>>>>>        Decrement iNumSegments
96656>>>>>        for iSegment from 0 to iNumSegments  
96662>>>>>>
96662>>>>>            Move False to bIsSame
96663>>>>>            If (iSegment <= iNumSegmentsFrom and iSegment <= iNumSegmentsTo) Begin
96665>>>>>                Get UtilIndexSegmentCompare aIndexFrom.IndexSegmentArray[iSegment] aIndexTo.IndexSegmentArray[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
96666>>>>>            End
96666>>>>>>
96666>>>>>            If (bIsSame = False) Begin
96668>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96669>>>>>                Move True to aIndexTo.bShouldChange
96670>>>>>                Move True to aIndexTo.IndexSegmentArray[iSegment].bShouldChange
96671>>>>>                Function_Return iSegment
96672>>>>>            End
96672>>>>>>
96672>>>>>        Loop             
96673>>>>>>
96673>>>>>        
96673>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96674>>>>>        Function_Return -1 // This means bIsSame = True
96675>>>>>    End_Function
96676>>>>>    
96676>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
96678>>>>>        Integer iNumSegments iSegment                                                
96678>>>>>        Boolean bIsSame
96678>>>>>
96678>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
96679>>>>>        If (bIsSame = False) Begin
96681>>>>>            Function_Return False
96682>>>>>        End
96682>>>>>>
96682>>>>>        If (bCompareIndexUppercase = True) Begin
96684>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
96685>>>>>            If (bIsSame = False) Begin
96687>>>>>                Function_Return False
96688>>>>>            End
96688>>>>>>
96688>>>>>        End
96688>>>>>>
96688>>>>>        If (bCompareIndexAscending = True) Begin
96690>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
96691>>>>>            If (bIsSame = False) Begin
96693>>>>>                Function_Return False
96694>>>>>            End
96694>>>>>>
96694>>>>>        End
96694>>>>>>
96694>>>>>        
96694>>>>>        Function_Return True
96695>>>>>    End_Function
96696>>>>>    
96696>>>>>    // This is the same as the UtilIndexCompare function _except_ it only checks if the Index type and number are equal or not.
96696>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
96698>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
96698>>>>>        Integer iCount iSize iSegment iNumSegments iIndexSegment
96698>>>>>        String sDriverID 
96698>>>>>        
96698>>>>>        Move True to bIsSame
96699>>>>>        Get psDriverID to sDriverID
96700>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
96701>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
96702>>>>>        If (bIsSqlTable = True) Begin
96704>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
96705>>>>>        End
96705>>>>>>
96705>>>>>        
96705>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96706>>>>>        Move True to bIsSame
96707>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
96709>>>>>            // Don't think we should do this. Or should we?
96709>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
96709>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
96710>>>>>            If (bIsSame = False) Begin
96712>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96713>>>>>                Function_Return False
96714>>>>>            End
96714>>>>>>
96714>>>>>        End
96714>>>>>>
96714>>>>>        
96714>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
96715>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96716>>>>>        If (bIsSame = False) Begin
96718>>>>>            Function_Return False
96719>>>>>        End                      
96719>>>>>>
96719>>>>>        
96719>>>>>        Function_Return bIsSame
96720>>>>>    End_Function
96721>>>>>    
96721>>>>>    // Compares multiple relationships for a 'From' and a 'To' table
96721>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
96723>>>>>        Boolean bIsSame
96723>>>>>        Integer iSize iCount
96723>>>>>        
96723>>>>>        Move True to bIsSame
96724>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
96725>>>>>        Decrement iSize
96726>>>>>        For iCount from 0 to iSize   
96732>>>>>>
96732>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96733>>>>>            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
96734>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96735>>>>>            If (bIsSame = False) Begin
96737>>>>>                Function_Return False
96738>>>>>            End
96738>>>>>>
96738>>>>>        Loop
96739>>>>>>
96739>>>>>        
96739>>>>>        Function_Return bIsSame
96740>>>>>    End_Function
96741>>>>>
96741>>>>>    // Compares a single relationship for a 'From' and a 'To' table
96741>>>>>    Function UtilRelationCompare Handle hTable tAPIRelation aRelationsFrom tAPIRelation aRelationsTo Returns Boolean
96743>>>>>        Boolean bIsSame
96743>>>>>        Integer iSize iCount
96743>>>>>        
96743>>>>>        Move True to bIsSame
96744>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96745>>>>>        Move (aRelationsFrom.hTableFrom = aRelationsTo.hTableFrom) to bIsSame
96746>>>>>        If (bIsSame = False) Begin
96748>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96749>>>>>            Function_Return False
96750>>>>>        End
96750>>>>>>
96750>>>>>        Move (aRelationsFrom.hTableTo = aRelationsTo.hTableTo) to bIsSame
96751>>>>>        If (bIsSame = False) Begin
96753>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96754>>>>>            Function_Return False
96755>>>>>        End
96755>>>>>>
96755>>>>>        Move (aRelationsFrom.iColumnFrom = aRelationsTo.iColumnFrom) to bIsSame
96756>>>>>        If (bIsSame = False) Begin
96758>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96759>>>>>            Function_Return False
96760>>>>>        End
96760>>>>>>
96760>>>>>        
96760>>>>>        Move (aRelationsFrom.iColumnTo = aRelationsTo.iColumnTo) to bIsSame
96761>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96762>>>>>
96762>>>>>        Function_Return bIsSame
96763>>>>>    End_Function
96764>>>>>
96764>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
96764>>>>>    // already exists. Instead it checks if the table needs to be updated with any of the struct arrays,
96764>>>>>    // for fields, indexes or relations.
96764>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
96766>>>>>        Boolean bIsSame bOK
96766>>>>>        Integer iSize iCount 
96766>>>>>        
96766>>>>>        Move True to bOK
96767>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
96768>>>>>        Decrement iSize
96769>>>>>        for iCount from 0 to iSize
96775>>>>>>
96775>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96776>>>>>            Get UtilRelationCompare hTable aRelationsFrom[iCount] aRelationsTo[iCount] to bIsSame
96777>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96778>>>>>            If (bIsSame = False) Begin
96780>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96781>>>>>                Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo to bOK
96782>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96783>>>>>            End
96783>>>>>>
96783>>>>>        Loop
96784>>>>>>
96784>>>>>        
96784>>>>>        Function_Return bOK
96785>>>>>    End_Function
96786>>>>>    
96786>>>>>    Function UtilIndexesUpdate Handle hTable tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
96788>>>>>        Boolean bIsSame bOK
96788>>>>>        Integer iSizeFrom iSizeTo iCount iIndexSegment                   
96788>>>>>        String sIndexFields
96788>>>>>        
96788>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSizeFrom
96789>>>>>        Move (SizeOfArray(aIndexesTo))   to iSizeTo 
96790>>>>>        Decrement iSizeTo
96791>>>>>        Decrement iSizeFrom
96792>>>>>        for iCount from 0 to iSizeFrom
96798>>>>>>
96798>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96799>>>>>            Get UtilIndexTypeNumberCompare hTable aIndexesFrom[iCount] aIndexesTo[iCount] to bIsSame
96800>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96801>>>>>            If (bIsSame = False and iSizeTo <> 0 and iCount <= iSizeTo) Begin
96803>>>>>                Get APIIndexCreateByFieldNames hTable iCount aIndexesFrom[iCount] aIndexesFrom[iCount].IndexSegmentArray to bOK
96804>>>>>            End
96804>>>>>>
96804>>>>>            If (bIsSame = True) Begin
96806>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT 
96807>>>>>                Move 0 to iIndexSegment
96808>>>>>                Get UtilIndexSegmentsCompare aIndexesFrom[iCount] aIndexesTo[iCount] bCompareIndexUppercase bCompareIndexAscending to iIndexSegment
96809>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96810>>>>>                If (iIndexSegment <> -1) Begin
96812>>>>>                    Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount].iIndexNumber aIndexesFrom[iCount].IndexSegmentArray to bOK
96813>>>>>                End
96813>>>>>>
96813>>>>>            End
96813>>>>>>
96813>>>>>        Loop
96814>>>>>>
96814>>>>>    
96814>>>>>        Function_Return bOK
96815>>>>>    End_Function  
96816>>>>>    
96816>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
96816>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
96816>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
96816>>>>>//        String sFieldName sDriverID
96816>>>>>//        
96816>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96816>>>>>//        If (bIsOpen = False) Begin
96816>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96816>>>>>//            Open hTable
96816>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96816>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96816>>>>>//            If (bIsOpen = False) Begin
96816>>>>>//                Function_Return False
96816>>>>>//            End
96816>>>>>//        End
96816>>>>>//
96816>>>>>//        Move True to bEqual
96816>>>>>//        Get psDriverID to sDriverID
96816>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
96816>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
96816>>>>>//        Move (SizeOfArray(aColumns)) to iSize
96816>>>>>//        Decrement iSize   
96816>>>>>//        
96816>>>>>//        For iCount from 0 to iSize
96816>>>>>//            Move 0 to iOptions    
96816>>>>>//            Move False to bIdentityKey
96816>>>>>//            Move aColumns[iCount].sFieldName to sFieldName               
96816>>>>>//            
96816>>>>>//            // We need to use the column name - not the column integer as
96816>>>>>//            // the order does not need to be the same, and the logic should still work.
96816>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
96816>>>>>//            If (iColumn > 0) Begin
96816>>>>>//                If (bDawSqlDriver = True) Begin
96816>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96816>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
96816>>>>>//                    If (iType <> aColumns[iCount].iType) Begin
96816>>>>>//                        Move False to bEqual
96816>>>>>//                    End
96816>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
96816>>>>>//                    If (bIdentityKey = True) Begin
96816>>>>>//                        Move C_tAPIColumn_Identity to iOptions
96816>>>>>//                    End
96816>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
96816>>>>>//                        Move False to bEqual
96816>>>>>//                    End
96816>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96816>>>>>//                End
96816>>>>>//                Else Begin
96816>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
96816>>>>>//                    If (iType <> aColumns[iCount].iType) Begin
96816>>>>>//                        Move False to bEqual
96816>>>>>//                    End
96816>>>>>//                End
96816>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
96816>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
96816>>>>>//                    Move False to bEqual
96816>>>>>//                End
96816>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
96816>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
96816>>>>>//                    Move False to bEqual
96816>>>>>//                End
96816>>>>>//                If (bEqual = False) Begin
96816>>>>>//                    Function_Return False
96816>>>>>//                End
96816>>>>>//            End
96816>>>>>//                    
96816>>>>>//            Else Begin
96816>>>>>//                Function_Return False
96816>>>>>//            End
96816>>>>>//        Loop
96816>>>>>//        
96816>>>>>//        Function_Return bEqual
96816>>>>>//    End_Function  
96816>>>>>    
96816>>>>>    // To fill a complete Table structure (tAPITable) with data.
96816>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
96816>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
96816>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
96816>>>>>    Function UtilTableStructFill Boolean bStatusPanel Boolean bFromTables Returns tAPITable[]
96818>>>>>        tAPIColumn[]    aApiColumns   
96818>>>>>        tAPIColumn[]    aApiColumns   
96819>>>>>        tAPIIndex[]     aApiIndexes   
96819>>>>>        tAPIIndex[]     aApiIndexes   
96820>>>>>        tAPIRelation[]  aApiRelations 
96820>>>>>        tAPIRelation[]  aApiRelations 
96821>>>>>        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
96821>>>>>        tAPITable[]     aApiTables aApiTablesEmpty                                                                          
96823>>>>>        Handle hTable
96823>>>>>        Integer iCount iPos 
96823>>>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
96823>>>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID
96823>>>>>        
96823>>>>>        Move 0 to hTable    
96824>>>>>        If (bFromTables = True) Begin
96826>>>>>            Set Message_Text of ghoStatusPanel to "Reading 'From' Table Structure:"
96827>>>>>        End 
96827>>>>>>
96827>>>>>        Else Begin
96828>>>>>            Set Message_Text of ghoStatusPanel to "Reading 'To' Table Structure:"
96829>>>>>        End
96829>>>>>>
96829>>>>>        Get UtilFilelistNoOfTables to iCount
96830>>>>>        Set piMaximum of ghoProgressBarOverall to iCount
96831>>>>>        Move 0 to iCount                                
96832>>>>>        
96832>>>>>        Repeat
96832>>>>>>
96832>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
96835>>>>>            If (hTable > 0 and hTable <> 50) Begin           
96837>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable    to sRootName   
96840>>>>>                Get _TableNameOnly sRootName                 to sTableName
96841>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName   
96844>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
96847>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bIsOpen
96848>>>>>                Get_Attribute DF_FILE_DRIVER       of hTable to sDriverID
96851>>>>>                Set piPosition of ghoProgressBarOverall to iCount
96852>>>>>                Set Action_Text of ghoStatusPanel  to (sTableName * "Number:" * String(hTable))
96853>>>>>                
96853>>>>>                Get UtilColumnsStructFill  hTable to aApiColumns
96854>>>>>                Get UtilIndexesStructFill  hTable to aApiIndexes
96855>>>>>                Get UtilRelationStructFill hTable to aApiRelations
96856>>>>>                Get UtilTableIsAlias       hTable to bIsAlias  
96857>>>>>                Get UtilTableIsSQL         hTable to bIsSQL
96858>>>>>                
96858>>>>>                Move hTable                                  to aApiTables[iCount].ApiTableInfo.iTableNumber
96859>>>>>                Move sRootName                               to aApiTables[iCount].ApiTableInfo.sRootName
96860>>>>>                Move sLogicalName                            to aApiTables[iCount].ApiTableInfo.sLogicalName
96861>>>>>                Move sDisplayName                            to aApiTables[iCount].ApiTableInfo.sDisplayName
96862>>>>>                Move sDriverID                               to aApiTables[iCount].ApiTableInfo.sDriverID
96863>>>>>                Move bIsAlias                                to aApiTables[iCount].ApiTableInfo.bIsAlias
96864>>>>>                Move bIsSQL                                  to aApiTables[iCount].ApiTableInfo.bIsSQL
96865>>>>>                Move aApiColumns                             to aApiTables[iCount].aApiColumns
96866>>>>>                Move aApiIndexes                             to aApiTables[iCount].aApiIndexes
96867>>>>>                Move aApiRelations                           to aApiTables[iCount].aApiRelations
96868>>>>>                Increment iCount
96869>>>>>            End     
96869>>>>>>
96869>>>>>            
96869>>>>>            If (bStatusPanel = True) Begin
96871>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
96872>>>>>                If (bUserCancel = True) Begin
96874>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
96875>>>>>                    Function_Return aApiTablesEmpty
96876>>>>>                End
96876>>>>>>
96876>>>>>            End
96876>>>>>>
96876>>>>>
96876>>>>>        Until (hTable = 0)    
96878>>>>>    
96878>>>>>        Function_Return aApiTables    
96879>>>>>    End_Function
96880>>>>>
96880>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
96882>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
96882>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
96882>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
96882>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
96884>>>>>        String sDriverID sFieldName sRootName sLogicalName sValue
96884>>>>>        
96884>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
96885>>>>>        Get piDbType to iDbType
96886>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
96889>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
96892>>>>>        Open hTable
96894>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96897>>>>>        If (bIsOpen = False) Begin
96899>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96900>>>>>            Open hTable
96902>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96903>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96906>>>>>            If (bIsOpen = False) Begin
96908>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT 
96909>>>>>                Function_Return APIColumnsEmpty
96910>>>>>            End
96910>>>>>>
96910>>>>>        End
96910>>>>>>
96910>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96913>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
96914>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver       
96915>>>>>        
96915>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
96917>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
96918>>>>>            If (bIsSqlTable = True) Begin
96920>>>>>                Get UtilTableExists hTable to bExists
96921>>>>>                If (bExists = False) Begin
96923>>>>>                    Function_Return APIColumnsEmpty
96924>>>>>                End
96924>>>>>>
96924>>>>>            End                                    
96924>>>>>>
96924>>>>>        End
96924>>>>>>
96924>>>>>        
96924>>>>>        Move 0 to iCount
96925>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
96928>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
96929>>>>>        
96929>>>>>        for iColumn from 1 to iNumColumns
96935>>>>>>
96935>>>>>            Move 0 to iOptions       
96936>>>>>            Move False to bIdentityKey         
96937>>>>>            Move False to Err
96938>>>>>            Move 0     to LastErr     
96939>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
96940>>>>>            Set piPosition of ghoProgressBar to iColumn
96941>>>>>            If (bDawSqlDriver = True) Begin
96943>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE   
96944>>>>>                If (bIsSqlTable = True) Begin
96946>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to APIColumns[iCount].iType
96949>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
96952>>>>>                End
96952>>>>>>
96952>>>>>                Else Begin
96953>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType 
96956>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
96957>>>>>                End
96957>>>>>>
96957>>>>>                
96957>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
96957>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
96960>>>>>                Move (iCheckFieldNumber >= 0) to bExists
96961>>>>>                If (bExists = False) Begin
96963>>>>>                    Move 0 to APIColumns[iCount].iType
96964>>>>>                End
96964>>>>>>
96964>>>>>                If (bExists = True) Begin
96966>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey                
96969>>>>>                End
96969>>>>>>
96969>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96970>>>>>                If (bIdentityKey = True) Begin
96972>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
96973>>>>>                End
96973>>>>>>
96973>>>>>            End
96973>>>>>>
96973>>>>>            Else Begin
96974>>>>>                Move False to Err
96975>>>>>                Move 0     to LastErr
96976>>>>>                If (bIsSqlTable = True) Begin
96978>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
96981>>>>>                End
96981>>>>>>
96981>>>>>                Else Begin
96982>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
96985>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
96986>>>>>                End
96986>>>>>>
96986>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
96986>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists           
96987>>>>>                If (bExists = False) Begin
96989>>>>>                    Move 0 to APIColumns[iCount].iType
96990>>>>>                End
96990>>>>>>
96990>>>>>            End
96990>>>>>>
96990>>>>>            
96990>>>>>            If (bExists = True) Begin                                                          
96992>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
96993>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
96996>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems. 
96996>>>>>//                If (bIsSqlTable = True) Begin
96996>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
96996>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
96996>>>>>//                End
96996>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
96999>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
97002>>>>>                
97002>>>>>                // If the length was zero we might have an Overlap(!) field.
97002>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
97002>>>>>                If (APIColumns[iCount].iLength = 0) Begin
97004>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
97007>>>>>                    If (iType = DF_OVERLAP) Begin
97009>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
97010>>>>>                        Move 0 to APIColumns[iCount].iLength
97011>>>>>                        Move 0 to APIColumns[iCount].iOptions
97012>>>>>                        Move 0 to APIColumns[iCount].iPrecision
97013>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
97014>>>>>                        Move "" to APIColumns[iCount].sFieldName
97015>>>>>                        Decrement iCount
97016>>>>>                    End                                                          
97016>>>>>>
97016>>>>>                End
97016>>>>>>
97016>>>>>            End
97016>>>>>>
97016>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
97017>>>>>            If (bUserCancel = True) Begin
97019>>>>>                Send Stop_StatusPanel of ghoStatusPanel
97020>>>>>                Send Info_Box "Process interrupted..."
97021>>>>>                Function_Return APIColumnsEmpty
97022>>>>>            End
97022>>>>>>
97022>>>>>            Increment iCount
97023>>>>>        Loop
97024>>>>>>
97024>>>>>        
97024>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97025>>>>>        Function_Return APIColumns                          
97026>>>>>    End_Function        
97027>>>>>    
97027>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
97029>>>>>        tAPIIndex[] APIIndexes
97029>>>>>        tAPIIndex[] APIIndexes
97030>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn iIndexType iCase
97030>>>>>        String sDriverID
97030>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsPrimaryKey
97030>>>>>        
97030>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97031>>>>>        Get psDriverID to sDriverID
97032>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver 
97033>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
97034>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97037>>>>>        If (bIsOpen = False) Begin
97039>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97040>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97041>>>>>            Open hTable
97043>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
97044>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97045>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97048>>>>>            If (bIsOpen = False) Begin
97050>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
97051>>>>>                Function_Return APIIndexes
97052>>>>>            End
97052>>>>>>
97052>>>>>        End
97052>>>>>>
97052>>>>>        
97052>>>>>        Move 0 to iCount
97053>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
97056>>>>>        for iIndex from 1 to iIndexes                                              
97062>>>>>>
97062>>>>>            // This is a test that the index exists as there might be "holes" aka the index
97062>>>>>            // numbers doesn not need to be consequitive:
97062>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
97065>>>>>            If (iNumSegments > 0) Begin
97067>>>>>            
97067>>>>>                Move iIndex to APIIndexes[iCount].iIndexNumber    
97068>>>>>                If (bIsSQLTable = True) Begin
97070>>>>>                    Get_Attribute DF_INDEX_NAME     of hTable iIndex to APIIndexes[iCount].sSQLIndexName
97073>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
97076>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsPrimaryKey
97079>>>>>                End
97079>>>>>>
97079>>>>>    
97079>>>>>                Move 0 to iSegmentCount
97080>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments       
97083>>>>>                for iSegment from 1 to iNumSegments     
97089>>>>>>
97089>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
97092>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
97093>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
97096>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
97099>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
97102>>>>>                    Increment iSegmentCount
97103>>>>>                Loop                                                                                       
97104>>>>>>
97104>>>>>            End
97104>>>>>>
97104>>>>>    
97104>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
97105>>>>>            Increment iCount
97106>>>>>        Loop                              
97107>>>>>>
97107>>>>>        
97107>>>>>        Function_Return APIIndexes
97108>>>>>    End_Function
97109>>>>>    
97109>>>>>    Function UtilRelationStructFill Handle hTable Returns tAPIRelation[]
97111>>>>>        tAPIRelation[] APIRelations
97111>>>>>        tAPIRelation[] APIRelations
97112>>>>>        Integer iColumn iNumColumns iCount
97112>>>>>        Handle hParent 
97112>>>>>        Boolean bIsOpen
97112>>>>>        
97112>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97113>>>>>        Move 0 to iCount
97114>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97117>>>>>        If (bIsOpen = False) Begin
97119>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97120>>>>>            Open hTable
97122>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97123>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
97126>>>>>            If (bIsOpen = False) Begin
97128>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
97129>>>>>                Function_Return APIRelations
97130>>>>>            End
97130>>>>>>
97130>>>>>        End
97130>>>>>>
97130>>>>>
97130>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
97133>>>>>        For iColumn from 1 to iNumColumns
97139>>>>>>
97139>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
97142>>>>>            If (hParent <> 0) Begin
97144>>>>>                Move (String(hTable))  to APIRelations[iCount].hTableFrom
97145>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APIRelations[iCount].sLogicalNameFrom
97148>>>>>                Move (String(iColumn)) to APIRelations[iCount].iColumnFrom                          
97149>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to APIRelations[iCount].sFieldNameFrom
97152>>>>>
97152>>>>>                Move (String(hParent)) to APIRelations[iCount].hTableTo
97153>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent to APIRelations[iCount].sLogicalNameTo
97156>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to APIRelations[iCount].iColumnTo
97159>>>>>                Get_Attribute DF_FIELD_NAME of hTable APIRelations[iCount].iColumnTo to APIRelations[iCount].sFieldNameTo
97162>>>>>                Increment iCount
97163>>>>>            End         
97163>>>>>>
97163>>>>>        Loop                                                    
97164>>>>>>
97164>>>>>        
97164>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97165>>>>>        Function_Return APIRelations
97166>>>>>    End_Function
97167>>>>>    
97167>>>>>    // Checks if a field name exists in a table definition
97167>>>>>    // Returns True if it does
97167>>>>>    // Sample:
97167>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
97167>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
97169>>>>>        Integer iNumColumns iColumn
97169>>>>>        String sColumn
97169>>>>>        Boolean bExists bOK bOpen
97169>>>>>
97169>>>>>        Get AutoConnectionIDLogin to bOK
97170>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97171>>>>>        Open hTable
97173>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97174>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97177>>>>>        If (bOpen = False) Begin
97179>>>>>            Function_Return False
97180>>>>>        End
97180>>>>>>
97180>>>>>
97180>>>>>        Move False to bExists
97181>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
97184>>>>>        for iColumn from 1 to iNumColumns
97190>>>>>>
97190>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
97193>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
97195>>>>>                Move iNumColumns to iColumn
97196>>>>>                Move True to bExists
97197>>>>>            End
97197>>>>>>
97197>>>>>        Loop
97198>>>>>>
97198>>>>>        Close hTable
97199>>>>>
97199>>>>>        Function_Return bExists
97200>>>>>    End_Function
97201>>>>>    
97201>>>>>    // Returns the field/column number for the passed FieldName as an integer.
97201>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
97203>>>>>        Integer iNumColumns iColumn iRetval
97203>>>>>        String sColumn
97203>>>>>        Boolean bExists bOK bOpen
97203>>>>>
97203>>>>>        Get AutoConnectionIDLogin to bOK
97204>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97205>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97206>>>>>        Open hTable
97208>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97209>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97212>>>>>        If (bOpen = False) Begin
97214>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
97215>>>>>            Function_Return False
97216>>>>>        End
97216>>>>>>
97216>>>>>        
97216>>>>>        Move 0 to iColumn                  
97217>>>>>        Move 0 to iRetval
97218>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
97221>>>>>        for iColumn from 1 to iNumColumns
97227>>>>>>
97227>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
97230>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
97232>>>>>                Move iColumn to iRetval
97233>>>>>                Move iNumColumns to iColumn
97234>>>>>            End
97234>>>>>>
97234>>>>>        Loop
97235>>>>>>
97235>>>>>        Close hTable
97236>>>>>
97236>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97237>>>>>        Function_Return iRetval
97238>>>>>    End_Function
97239>>>>>
97239>>>>>    // Checks if the current psConnectionID is logged in; if not
97239>>>>>    // attempts to make a login.
97239>>>>>    // Because
97239>>>>>    // Returns True if already logged in or the new login was successful.
97239>>>>>    // *** Utility Messages ***
97239>>>>>    //
97239>>>>>    //
97239>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
97239>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
97239>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
97239>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
97241>>>>>        Boolean bError bFound
97241>>>>>
97241>>>>>        Move False to Err
97242>>>>>        Open CodeMast
97244>>>>>        Open CodeType
97246>>>>>
97246>>>>>        If (bCodeType = True) Begin
97248>>>>>            Clear CodeType
97249>>>>>            Move sTypeValue to CODETYPE.Type
97250>>>>>            Find eq CODETYPE.Type
97251>>>>>>
97251>>>>>            Move (Found = True) to bFound
97252>>>>>            If (bFound = True) Begin
97254>>>>>                Reread CodeType
97258>>>>>            End
97258>>>>>>
97258>>>>>            If (bFound = False) Begin
97260>>>>>                Clear CodeType
97261>>>>>            End
97261>>>>>>
97261>>>>>                Move sTypeValue to CODETYPE.Type
97262>>>>>                Move sValue2    to CODETYPE.Description
97263>>>>>                Move sValue3    to CODETYPE.Comment
97264>>>>>                SaveRecord CODETYPE
97265>>>>>            If (bFound = True) Begin
97267>>>>>                Unlock
97268>>>>>>
97268>>>>>            End
97268>>>>>>
97268>>>>>        End
97268>>>>>>
97268>>>>>
97268>>>>>        If (bCodeType = False) Begin
97270>>>>>            Clear CODEMAST
97271>>>>>            Move sTypeValue to CODEMAST.Type
97272>>>>>            Move sValue2    to CODEMAST.Code
97273>>>>>            Find eq CODEMAST.Code
97274>>>>>>
97274>>>>>            Move (Found = True) to bFound
97275>>>>>            If (bFound = True) Begin
97277>>>>>                Reread CODEMAST
97281>>>>>            End
97281>>>>>>
97281>>>>>            If (bFound = False) Begin
97283>>>>>                Clear CODEMAST
97284>>>>>            End
97284>>>>>>
97284>>>>>                Move sTypeValue to CODEMAST.Type
97285>>>>>                Move sValue2    to CODEMAST.Code
97286>>>>>                Move sValue3    to CODEMAST.Description
97287>>>>>                SaveRecord CODEMAST
97288>>>>>            If (bFound = True) Begin
97290>>>>>            Unlock
97291>>>>>>
97291>>>>>            End
97291>>>>>>
97291>>>>>        End
97291>>>>>>
97291>>>>>
97291>>>>>        Close CodeMast
97292>>>>>        Close CodeType
97293>>>>>
97293>>>>>        Function_Return (Err = False)
97294>>>>>    End_Function
97295>>>>>
97295>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
97295>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
97295>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
97297>>>>>        Boolean bFound
97297>>>>>
97297>>>>>        Move False to Err
97298>>>>>        Open CodeMast
97300>>>>>        Open CodeType
97302>>>>>
97302>>>>>        Clear CodeType
97303>>>>>        Move sFromValue to CODETYPE.Type
97304>>>>>        Find eq CODETYPE.Type
97305>>>>>>
97305>>>>>        If (Found = True) Begin
97307>>>>>            Reread CODETYPE
97311>>>>>                Move sToValue to CODETYPE.Type
97312>>>>>                SaveRecord CODETYPE
97313>>>>>            Unlock
97314>>>>>>
97314>>>>>        End
97314>>>>>>
97314>>>>>
97314>>>>>        Clear CODEMAST
97315>>>>>        Find gt CODEMAST by Recnum
97316>>>>>>
97316>>>>>        While (Found = True)
97320>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
97321>>>>>            If (bFound = True) Begin
97323>>>>>                Reread CODEMAST
97327>>>>>                    Move sToValue to CODEMAST.Type
97328>>>>>                    SaveRecord CODEMAST
97329>>>>>                Unlock
97330>>>>>>
97330>>>>>            End
97330>>>>>>
97330>>>>>            Find gt CODEMAST by Recnum
97331>>>>>>
97331>>>>>        Loop
97332>>>>>>
97332>>>>>
97332>>>>>        Close CodeMast
97333>>>>>        Close CodeType
97334>>>>>
97334>>>>>        Function_Return (Err = False)
97335>>>>>    End_Function
97336>>>>>
97336>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
97336>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
97338>>>>>        Boolean bError bFound
97338>>>>>
97338>>>>>        Move False to Err
97339>>>>>        Open CodeMast
97341>>>>>
97341>>>>>        Clear CODEMAST
97342>>>>>        Move sTypeValue to CODEMAST.Type
97343>>>>>        Move sValue2    to CODEMAST.Code
97344>>>>>        Find eq CODEMAST.Code
97345>>>>>>
97345>>>>>        Move (Found = True) to bFound
97346>>>>>        If (bFound = True) Begin
97348>>>>>            Delete CODEMAST
97349>>>>>        End
97349>>>>>>
97349>>>>>
97349>>>>>        Close CodeMast
97350>>>>>
97350>>>>>        Function_Return (Err = False)
97351>>>>>    End_Function
97352>>>>>
97352>>>>>    // Note:
97352>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
97352>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
97352>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
97352>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
97352>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
97352>>>>>    Function UtilTableHandleToString Handle hTable Returns String
97354>>>>>        String sTableName
97354>>>>>        Boolean bOpen bExists bRecnum bOK
97354>>>>>
97354>>>>>        Get UtilTableNumberIsInUse hTable to bExists
97355>>>>>        If (bExists = False) Begin
97357>>>>>            Function_Return ""
97358>>>>>        End
97358>>>>>>
97358>>>>>
97358>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
97359>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97362>>>>>        If (bOpen = False) Begin
97364>>>>>            Get AutoConnectionIDLogin to bOK
97365>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97366>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
97367>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
97368>>>>>            Open hTable
97370>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97371>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
97372>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
97373>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
97376>>>>>        End
97376>>>>>>
97376>>>>>        If (bOpen = True) Begin
97378>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97379>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
97382>>>>>            // If blank it is an embedded table:
97382>>>>>            If (sTableName = "") Begin
97384>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
97387>>>>>                Move 0 to LastErr
97388>>>>>                Move False to Err
97389>>>>>            End
97389>>>>>>
97389>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
97390>>>>>        End
97390>>>>>>
97390>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
97391>>>>>
97391>>>>>        Function_Return sTableName
97392>>>>>    End_Function
97393>>>>>
97393>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
97393>>>>>    // Returns 0 if unsuccessful.
97393>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
97393>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
97395>>>>>        String sValue sPrefixTableName sDriverID
97395>>>>>        Handle hTable hRetval
97395>>>>>
97395>>>>>        Get psDriverID to sDriverID
97396>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
97398>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
97399>>>>>        End
97399>>>>>>
97399>>>>>        Move 0 to hTable
97400>>>>>        Move 0 to hRetval
97401>>>>>        Repeat
97401>>>>>>
97401>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97404>>>>>            If (hTable <> 0) Begin
97406>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
97409>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
97411>>>>>                    Move hTable to hRetval
97412>>>>>                    Move 0 to hTable
97413>>>>>                End
97413>>>>>>
97413>>>>>            End
97413>>>>>>
97413>>>>>        Until (hTable = 0)
97415>>>>>
97415>>>>>        Function_Return hRetval
97416>>>>>    End_Function
97417>>>>>
97417>>>>>    // Check if the file exists in the Data folder,
97417>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
97417>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
97419>>>>>        String sPath sDataPath
97419>>>>>        Boolean bExists
97419>>>>>
97419>>>>>        Get psDataPathFirstPart to sPath
97420>>>>>        Move (sPath + sFileName) to sFileName
97421>>>>>        Get vFilePathExists sFileName to bExists
97422>>>>>
97422>>>>>        If (bExists = False) Begin
97424>>>>>            // Read from memory & create file on disk.
97424>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
97425>>>>>            Get vFilePathExists sFileName to bExists
97426>>>>>        End
97426>>>>>>
97426>>>>>        Function_Return bExists
97427>>>>>    End_Function
97428>>>>>
97428>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
97428>>>>>    // The reciprocal function of UtilColumnTypeToInteger.
97428>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
97430>>>>>        tColumnType RetvalType
97430>>>>>        tColumnType RetvalType
97430>>>>>
97430>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
97431>>>>>        Function_Return RetvalType.iType
97432>>>>>    End_Function
97433>>>>>
97433>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
97433>>>>>    // The reciprocal function of UtilColumnTypeToString.
97433>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
97435>>>>>        tColumnType RetvalType
97435>>>>>        tColumnType RetvalType
97435>>>>>        String sValue
97435>>>>>
97435>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97436>>>>>        Function_Return RetvalType.sType
97437>>>>>    End_Function
97438>>>>>
97438>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
97440>>>>>        tColumnType RetvalType 
97440>>>>>        tColumnType RetvalType 
97440>>>>>        Integer iRetval
97440>>>>>        
97440>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97441>>>>>        Move RetvalType.iDataFlexType to iRetval
97442>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
97444>>>>>            If (iLength <= 255) Begin
97446>>>>>                Move DF_ASCII to iRetval
97447>>>>>            End
97447>>>>>>
97447>>>>>        End                             
97447>>>>>>
97447>>>>>        Function_Return iRetval
97448>>>>>    End_Function
97449>>>>>
97449>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
97451>>>>>        tColumnType RetvalType
97451>>>>>        tColumnType RetvalType
97451>>>>>        String sValue
97451>>>>>
97451>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97452>>>>>        Function_Return RetvalType.sPrecision
97453>>>>>    End_Function
97454>>>>>
97454>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
97456>>>>>        tColumnType RetvalType
97456>>>>>        tColumnType RetvalType
97456>>>>>        String sValue
97456>>>>>
97456>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97457>>>>>        Function_Return RetvalType.bFixedSize
97458>>>>>    End_Function
97459>>>>>
97459>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
97461>>>>>        tColumnType RetvalType
97461>>>>>        tColumnType RetvalType
97461>>>>>        String sValue
97461>>>>>        Integer iRetval iPos
97461>>>>>
97461>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97462>>>>>        Move RetvalType.sPrecision to sValue
97463>>>>>        Move (Pos(".", sValue)) to iPos
97464>>>>>        If (iPos <> 0) Begin
97466>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
97467>>>>>        End
97467>>>>>>
97467>>>>>        Else Begin
97468>>>>>            Move sValue to iRetval
97469>>>>>        End
97469>>>>>>
97469>>>>>        Function_Return iRetval
97470>>>>>    End_Function
97471>>>>>
97471>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
97473>>>>>        tColumnType RetvalType
97473>>>>>        tColumnType RetvalType
97473>>>>>        String sValue
97473>>>>>        Integer iRetval iPos
97473>>>>>
97473>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97474>>>>>        Move RetvalType.sPrecision to sValue
97475>>>>>        Move (Pos(".", sValue)) to iPos
97476>>>>>        If (iPos = 0) Begin
97478>>>>>            Function_Return 0
97479>>>>>        End
97479>>>>>>
97479>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
97480>>>>>
97480>>>>>        Function_Return iRetval
97481>>>>>    End_Function
97482>>>>>
97482>>>>>    // The default value used for a datatype as specified in the driver int file.
97482>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
97484>>>>>        String sRetval sServer
97484>>>>>        tColumnType RetvalType
97484>>>>>        tColumnType RetvalType
97484>>>>>        Integer iDriver iDataFlexType
97484>>>>>        Handle hDatabase
97484>>>>>
97484>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97485>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
97486>>>>>        Get DriverIndex sDriverID to iDriver
97487>>>>>        Get psServer to sServer
97488>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
97489>>>>>        If (hDatabase = 0) Begin
97491>>>>>            Function_Return ""
97492>>>>>        End
97492>>>>>>
97492>>>>>
97492>>>>>        Case Begin
97492>>>>>            Case (iDataFlexType = DF_ASCII)
97494>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
97497>>>>>                Case Break
97498>>>>>            Case (iDataFlexType = DF_BCD)
97501>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
97504>>>>>                Case Break
97505>>>>>            Case (iDataFlexType = DF_BINARY)
97508>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
97511>>>>>                Case Break
97512>>>>>            Case (iDataFlexType = DF_DATE)
97515>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
97518>>>>>                Case Break
97519>>>>>            Case (iDataFlexType = DF_DATETIME)
97522>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
97525>>>>>                Case Break
97526>>>>>            Case (iDataFlexType = DF_TEXT)
97529>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
97532>>>>>                Case Break
97533>>>>>            Case Else
97533>>>>>                Move "" to sRetval
97534>>>>>        Case End
97534>>>>>
97534>>>>>        Function_Return sRetval
97535>>>>>    End_Function 
97536>>>>>    
97536>>>>>    Procedure Set DF_DATABASE_DEFAULT_DEFAULT_DATE_DUF String sDateValue
97538>>>>>        String sDriverID sRetval sServer
97538>>>>>        tColumnType RetvalType
97538>>>>>        tColumnType RetvalType
97538>>>>>        Integer iDbType iDriver iDataFlexType
97538>>>>>        Handle hDatabase
97538>>>>>        
97538>>>>>        Get psDriverID to sDriverID
97539>>>>>        Get piDbType   to iDbType
97540>>>>>        Get DriverIndex sDriverID to iDriver
97541>>>>>        Get psServer to sServer
97542>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
97543>>>>>        If (hDatabase = 0) Begin
97545>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database."
97546>>>>>>
97546>>>>>            Procedure_Return
97547>>>>>        End                      
97547>>>>>>
97547>>>>>        
97547>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
97550>>>>>
97550>>>>>    End_Procedure
97551>>>>>
97551>>>>>    Procedure Set DF_DATABASE_DEFAULT_DEFAULT_DATETIME_DUF String sDateValue
97553>>>>>        String sDriverID sRetval sServer
97553>>>>>        tColumnType RetvalType
97553>>>>>        tColumnType RetvalType
97553>>>>>        Integer iDbType iDriver iDataFlexType
97553>>>>>        Handle hDatabase
97553>>>>>        
97553>>>>>        Get psDriverID to sDriverID
97554>>>>>        Get piDbType   to iDbType
97555>>>>>        Get DriverIndex sDriverID to iDriver
97556>>>>>        Get psServer to sServer
97557>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
97558>>>>>        If (hDatabase = 0) Begin
97560>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
97561>>>>>>
97561>>>>>            Procedure_Return
97562>>>>>        End                      
97562>>>>>>
97562>>>>>        
97562>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
97565>>>>>
97565>>>>>    End_Procedure
97566>>>>>
97566>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
97566>>>>>    // are mapped to the standard DataFlex data types.
97566>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
97566>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
97568>>>>>        tColumnType[] ColumnTypeArray EmptyArray
97568>>>>>        tColumnType[] ColumnTypeArray EmptyArray
97570>>>>>        String sDataType
97570>>>>>        Integer iDataType iDriverID iCount  
97570>>>>>        Boolean bSQLDriver
97570>>>>>
97570>>>>>        Move 0 to iCount
97571>>>>>        Get DriverIndex sDriverID to iDriverID
97572>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
97573>>>>>        If (bSQLDriver = False) Begin
97575>>>>>            Function_Return EmptyArray
97576>>>>>        End
97576>>>>>>
97576>>>>>
97576>>>>>        // DF_ASCII
97576>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97578>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
97581>>>>>        End
97581>>>>>>
97581>>>>>        Else Begin
97582>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
97585>>>>>        End
97585>>>>>>
97585>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97586>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
97587>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
97588>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
97589>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
97590>>>>>        Increment iCount
97591>>>>>
97591>>>>>        // DF_BINARY
97591>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97593>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
97596>>>>>        End
97596>>>>>>
97596>>>>>        Else Begin
97597>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
97600>>>>>        End
97600>>>>>>
97600>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97601>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
97602>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
97603>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
97604>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
97605>>>>>        Increment iCount
97606>>>>>
97606>>>>>        // DF_DATE
97606>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97608>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
97611>>>>>        End
97611>>>>>>
97611>>>>>        Else Begin
97612>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
97615>>>>>        End
97615>>>>>>
97615>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97616>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
97617>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
97618>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
97619>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
97620>>>>>        Increment iCount
97621>>>>>
97621>>>>>        // DF_DATETIME
97621>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97623>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
97626>>>>>        End
97626>>>>>>
97626>>>>>        Else Begin
97627>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
97630>>>>>        End
97630>>>>>>
97630>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97631>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
97632>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
97633>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
97634>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
97635>>>>>        Increment iCount
97636>>>>>
97636>>>>>        // DF_NUMERIC
97636>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
97636>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
97636>>>>>        // we make them here all "Numeric"... 
97636>>>>>        Case Begin
97636>>>>>            Case (sDriverID = MSSQLDRV_ID)
97638>>>>>                Move SQL_NUMERIC to iDataType 
97639>>>>>                Move "numeric"   to sDataType
97640>>>>>                Case Break
97641>>>>>            Case (sDriverID = DB2_DRV_ID)
97644>>>>>                Move SQL_NUMERIC to iDataType
97645>>>>>                Move "NUMERIC"   to sDataType
97646>>>>>                Case Break                   
97647>>>>>            Case (sDriverID = SQLFLEX)
97650>>>>>                Move eSQLServer_NUMERIC to iDataType
97651>>>>>                Move "numeric"   to sDataType
97652>>>>>                Case Break                   
97653>>>>>            Case (sDriverID = MDSMySQL)
97656>>>>>                Move eMySQL_DECIMAL to iDataType
97657>>>>>                Move "decimal"   to sDataType
97658>>>>>                Case Break       
97659>>>>>            Case (sDriverID = ORAFLEX)
97662>>>>>                Move eOracle_NUMBER to iDataType
97663>>>>>                Move "NUMBER"   to sDataType
97664>>>>>                Case Break       
97665>>>>>            Case (sDriverID = MDSPgSQL)
97668>>>>>                Move ePgSQL_FLOAT4 to iDataType
97669>>>>>                Move "decimal"   to sDataType
97670>>>>>                Case Break       
97671>>>>>            Case Else
97671>>>>>                Move DF_BCD      to iDataType
97672>>>>>                Move "Numeric"   to sDataType
97673>>>>>        Case End
97673>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
97674>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
97675>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
97676>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
97677>>>>>        Increment iCount
97678>>>>>
97678>>>>>        // DF_TEXT
97678>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97680>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
97683>>>>>        End
97683>>>>>>
97683>>>>>        Else Begin
97684>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
97687>>>>>        End
97687>>>>>>
97687>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97688>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
97689>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
97690>>>>>        Move sDataType   to ColumnTypeArray[iCount].sType
97691>>>>>        Move iDataType   to ColumnTypeArray[iCount].iType
97692>>>>>
97692>>>>>        Function_Return ColumnTypeArray
97693>>>>>    End_Function 
97694>>>>>    
97694>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
97696>>>>>        tColumnType[] ColumnTypeArray
97696>>>>>        tColumnType[] ColumnTypeArray
97697>>>>>        tColumnType   ColumnType 
97697>>>>>        tColumnType   ColumnType 
97697>>>>>        Integer iCount iSize
97697>>>>>        
97697>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
97698>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
97699>>>>>        Decrement iSize
97700>>>>>        
97700>>>>>        for iCount from 0 to iSize
97706>>>>>>
97706>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
97708>>>>>                Move ColumnTypeArray[iCount].bFixedSize     to ColumnType.bFixedSize
97709>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
97710>>>>>                Move ColumnTypeArray[iCount].iType          to ColumnType.iType
97711>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
97712>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
97713>>>>>                Move ColumnTypeArray[iCount].sType          to ColumnType.sType
97714>>>>>                Move iSize to iCount
97715>>>>>            End
97715>>>>>>
97715>>>>>        Loop
97716>>>>>>
97716>>>>>        
97716>>>>>        Function_Return ColumnType
97717>>>>>    End_Function
97718>>>>>
97718>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
97718>>>>>    // are mapped to a framework DataFlex data type.
97718>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
97720>>>>>        tColumnType ColumnType
97720>>>>>        tColumnType ColumnType
97720>>>>>        String sDataType
97720>>>>>        Integer iDriverID iDataType iCount
97720>>>>>
97720>>>>>        Move 0 to iCount
97721>>>>>        Get DriverIndex sDriverID to iDriverID
97722>>>>>            
97722>>>>>        Case Begin
97722>>>>>            // DF_ASCII
97722>>>>>            Case (iType = DF_ASCII_DUF)
97724>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97726>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
97729>>>>>                End
97729>>>>>>
97729>>>>>                Else Begin
97730>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType 
97733>>>>>                End
97733>>>>>>
97733>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
97734>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
97735>>>>>                Move sDataType   to ColumnType.sType
97736>>>>>                Move DF_ASCII    to ColumnType.iType
97737>>>>>                Move False       to ColumnType.bFixedSize
97738>>>>>                Case Break
97739>>>>>                
97739>>>>>            // DF_BINARY
97739>>>>>            Case (iType = DF_BINARY_DUF)
97742>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97744>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
97747>>>>>                End
97747>>>>>>
97747>>>>>                Else Begin
97748>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
97751>>>>>                End
97751>>>>>>
97751>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
97752>>>>>                Move "Binary"    to ColumnType.sDataFlexType
97753>>>>>                Move sDataType   to ColumnType.sType
97754>>>>>                Move DF_BINARY   to ColumnType.iType
97755>>>>>                Move False       to ColumnType.bFixedSize
97756>>>>>                Case Break
97757>>>>>    
97757>>>>>            // DF_DATE
97757>>>>>            Case (iType = DF_DATE_DUF)
97760>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97762>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
97765>>>>>                End
97765>>>>>>
97765>>>>>                Else Begin
97766>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
97769>>>>>                End
97769>>>>>>
97769>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
97770>>>>>                Move "Date"      to ColumnType.sDataFlexType
97771>>>>>                Move sDataType   to ColumnType.sType
97772>>>>>                Move DF_DATE     to ColumnType.iType
97773>>>>>                Move True        to ColumnType.bFixedSize
97774>>>>>                Case Break
97775>>>>>    
97775>>>>>            // DF_DATETIME       
97775>>>>>            Case (iType = DF_DATETIME_DUF)
97778>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97780>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
97783>>>>>                End
97783>>>>>>
97783>>>>>                Else Begin
97784>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
97787>>>>>                End
97787>>>>>>
97787>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
97788>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
97789>>>>>                Move sDataType   to ColumnType.sType
97790>>>>>                Move DF_DATETIME to ColumnType.iType
97791>>>>>                Move True        to ColumnType.bFixedSize
97792>>>>>                Case Break
97793>>>>>    
97793>>>>>            // DF_NUMERIC
97793>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
97793>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
97793>>>>>            // we make them here all "Numeric"...
97793>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
97793>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
97793>>>>>            // End
97793>>>>>            // Else Begin
97793>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
97793>>>>>            // End 
97793>>>>>            // ToDo: How should we find the best "Numeric" data type here?
97793>>>>>            Case (iType = DF_BCD_DUF)
97796>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
97797>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
97798>>>>>                Move "Numeric"   to ColumnType.sType
97799>>>>>                Move SQL_NUMERIC to ColumnType.iType
97800>>>>>                Move False       to ColumnType.bFixedSize
97801>>>>>                Case Break
97802>>>>>                
97802>>>>>            // DF_TEXT
97802>>>>>            Case (iType = DF_TEXT_DUF)
97805>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97807>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
97810>>>>>                End
97810>>>>>>
97810>>>>>                Else Begin
97811>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
97814>>>>>                End
97814>>>>>>
97814>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
97815>>>>>                Move "Text"      to ColumnType.sDataFlexType
97816>>>>>                Move sDataType   to ColumnType.sType
97817>>>>>                Move DF_TEXT     to ColumnType.iType
97818>>>>>                Move False       to ColumnType.bFixedSize
97819>>>>>                Case Break
97820>>>>>                
97820>>>>>            Case Else
97820>>>>>                Move -1999       to ColumnType.iDataFlexType
97821>>>>>                Move "Undefined" to ColumnType.sDataFlexType
97822>>>>>                Move "Undefined" to ColumnType.sType
97823>>>>>                Move -1999       to ColumnType.iType
97824>>>>>                Move True        to ColumnType.bFixedSize
97825>>>>>
97825>>>>>        Case End
97825>>>>>
97825>>>>>        Function_Return ColumnType
97826>>>>>    End_Function
97827>>>>>
97827>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
97829>>>>>        String sDataPath sDriverID
97829>>>>>        Boolean bMertechDriver bOK
97829>>>>>        Integer iPos
97829>>>>>
97829>>>>>        If (sTableName contains ".") Begin
97831>>>>>            Move (Pos(".", sTableName)) to iPos
97832>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
97833>>>>>        End
97833>>>>>>
97833>>>>>
97833>>>>>        Get psDriverID to sDriverID
97834>>>>>        Get psDataPathFirstPart to sDataPath
97835>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
97836>>>>>        // First delete the cache file:
97836>>>>>        If (bMertechDriver = False) Begin
97838>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
97839>>>>>        End
97839>>>>>>
97839>>>>>        Else Begin
97840>>>>>            Get _MertechDeleteTDFile sTableName to bOK
97841>>>>>        End
97841>>>>>>
97841>>>>>
97841>>>>>        Function_Return bOK
97842>>>>>    End_Function
97843>>>>>
97843>>>>>    // Changes source code files.
97843>>>>>    // Pass a file name with full path and a value to search for, together with the value
97843>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
97843>>>>>    // to use a Connection ID.
97843>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
97843>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
97843>>>>>    // Returns True if no errors occured.
97843>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
97845>>>>>        Integer iCh iRow iItems iCount
97845>>>>>        String sValue sRow
97845>>>>>        String[] sFileArray
97846>>>>>        Boolean bExists bIsActive
97846>>>>>
97846>>>>>        Move False to Err
97847>>>>>        Move 0 to iRow
97848>>>>>
97848>>>>>        If (ghoStatusPanel <> 0) Begin
97850>>>>>            Get Active_state of ghoStatusPanel to bIsActive
97851>>>>>        End
97851>>>>>>
97851>>>>>
97851>>>>>        Get vFilePathExists sFileName to bExists
97852>>>>>        If (bExists = False) Begin
97854>>>>>            If (bShowResult = True) Begin                  
97856>>>>>                If (bIsActive = True) Begin
97858>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
97859>>>>>                End 
97859>>>>>>
97859>>>>>                Else Begin
97860>>>>>                    Showln "File does not exist: " sFileName
97863>>>>>                End
97863>>>>>>
97863>>>>>            End
97863>>>>>>
97863>>>>>            Function_Return False
97864>>>>>        End
97864>>>>>>
97864>>>>>
97864>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
97865>>>>>        If (iCh < 1) Begin
97867>>>>>            Function_Return False
97868>>>>>        End
97868>>>>>>
97868>>>>>
97868>>>>>        If (bShowResult = True) Begin      
97870>>>>>            If (ghoStatusPanel <> 0) Begin
97872>>>>>                Get Active_state of ghoStatusPanel to bIsActive
97873>>>>>                If (bIsActive = True) Begin
97875>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
97876>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo)) 
97877>>>>>                    Send DoAdvance of ghoProgressBar
97878>>>>>                End
97878>>>>>>
97878>>>>>            End
97878>>>>>>
97878>>>>>            Else Begin
97879>>>>>                Showln ""
97881>>>>>                Showln "sFileName = " sFileName
97884>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
97889>>>>>            End
97889>>>>>>
97889>>>>>        End
97889>>>>>>
97889>>>>>
97889>>>>>        While (not(SeqEof))
97893>>>>>            Readln channel iCh sRow
97895>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
97897>>>>>//                If (bShowResult = True) Begin  
97897>>>>>//                    If (bIsActive = True) Begin
97897>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
97897>>>>>//                    End
97897>>>>>//                    Else Begin
97897>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
97897>>>>>//                    End
97897>>>>>//                End
97897>>>>>                // Change the whole line to the new connection id:
97897>>>>>                Move sChangeTo to sRow
97898>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
97898>>>>>            End
97898>>>>>>
97898>>>>>            Move sRow to sFileArray[iRow]
97899>>>>>            Increment iRow
97900>>>>>        End
97901>>>>>>
97901>>>>>        Send Seq_Close_Channel iCh
97902>>>>>
97902>>>>>        Sleep 1 // Wait for Windows to close the file
97903>>>>>
97903>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
97904>>>>>        If (iCh < 1) Begin
97906>>>>>            Function_Return False
97907>>>>>        End
97907>>>>>>
97907>>>>>        Move (SizeOfArray(sFileArray)) to iItems
97908>>>>>        Decrement iItems
97909>>>>>
97909>>>>>        For iCount from 0 to iItems
97915>>>>>>
97915>>>>>            Move sFileArray[iCount] to sValue
97916>>>>>            Writeln channel iCh sValue
97919>>>>>        Loop
97920>>>>>>
97920>>>>>        Send Seq_Close_Channel iCh
97921>>>>>
97921>>>>>        Function_Return (Err = False)
97922>>>>>    End_Function
97923>>>>>
97923>>>>>    // This might be needed by API-methods when a connection id is to be used and
97923>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
97923>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
97923>>>>>    Function UtilCreateConnectionID String sConnectionID Returns Boolean
97925>>>>>        String sConnectionString sDriverID
97925>>>>>        Boolean bOK bSilent bDawDriver
97925>>>>>        Handle hoCLI
97925>>>>>
97925>>>>>        Move False to bOK
97926>>>>>        Get psDriverID to sDriverID
97927>>>>>        Get IsDAWSQLDriver sDriverID to bDawDriver
97928>>>>>        If (bDawDriver = False) Begin
97930>>>>>            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
97931>>>>>>
97931>>>>>            Function_Return False
97932>>>>>        End
97932>>>>>>
97932>>>>>
97932>>>>>        Get psConnectionString to sConnectionString
97933>>>>>        Get pbSilentLogin      to bSilent
97934>>>>>
97934>>>>>        Get phoCLIHandler to hoCLI
97935>>>>>        If (hoCLI <> 0) Begin
97937>>>>>            Set psDriverID of hoCLI to sDriverID
97938>>>>>            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
97939>>>>>        End
97939>>>>>>
97939>>>>>
97939>>>>>        Function_Return (bOK = False)
97940>>>>>    End_Function
97941>>>>>
97941>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
97941>>>>>    // and opens it in "notepad.exe".
97941>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
97941>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
97941>>>>>    Procedure UtilShowErrorList
97943>>>>>        tSqlErrorArray aSqlErrorArray
97943>>>>>        tSqlErrorArray aSqlErrorArray
97943>>>>>        Integer iRows iCount iCh iErrorNum
97943>>>>>        String sPath sFileName sErrorTxt sStatement
97943>>>>>
97943>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
97944>>>>>        Get vFolderFormat sPath to sPath
97945>>>>>        Move "SQLErrorLog.txt"  to sFileName
97946>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
97947>>>>>            Get paSqlErrorArray to aSqlErrorArray
97948>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
97949>>>>>            If (iRows > 0) Begin
97951>>>>>                Decrement iRows
97952>>>>>                for iCount from 0 to iRows
97958>>>>>>
97958>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
97959>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
97960>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
97961>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
97967>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
97971>>>>>                Loop
97972>>>>>>
97972>>>>>            End
97972>>>>>>
97972>>>>>        Send Seq_Close_Channel iCh
97973>>>>>
97973>>>>>        If (iRows > 0) Begin
97975>>>>>            Runprogram Background "Notepad.exe" (sPath + sFileName)
97976>>>>>        End
97976>>>>>>
97976>>>>>    End_Procedure
97977>>>>>    
97977>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
97977>>>>>    // and the table needs to exist as an SQL table.
97977>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
97979>>>>>        String sRootName sLogicalName sDriverID
97979>>>>>        Boolean bIsSQL
97979>>>>>        
97979>>>>>        Move False to bIsSQL
97980>>>>>        If (hTable > 0) Begin
97982>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97985>>>>>            Move (sRootName contains ":") to bIsSQL
97986>>>>>            If (bIsSQL = True) Begin               
97988>>>>>                Get psDriverID to sDriverID
97989>>>>>                Get _TableNameOnly sRootName to sRootName
97990>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
97991>>>>>            End
97991>>>>>>
97991>>>>>        End
97991>>>>>>
97991>>>>>
97991>>>>>        Function_Return bIsSQL
97992>>>>>    End_Function
97993>>>>>
97993>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
97995>>>>>        Boolean bIsSQL
97995>>>>>        Move (sRootName contains ":") to bIsSQL
97996>>>>>        Function_Return bIsSQL
97997>>>>>    End_Function
97998>>>>>
97998>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
97998>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
97998>>>>>    // but the Logical name is different.
97998>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
97998>>>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
97998>>>>>//        String sPhysicalName sPhysicalNameCompare
97998>>>>>//        Boolean bWasOpen bOpened bOK
97998>>>>>//        Integer iCount 
97998>>>>>//        
97998>>>>>//        Move 0 to iCount    
97998>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
97998>>>>>//        If (bWasOpen = False) Begin
97998>>>>>//            Open hTable
97998>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
97998>>>>>//            If (bOpened = False) Begin
97998>>>>>//                Function_Return False
97998>>>>>//            End  
97998>>>>>//        End
97998>>>>>//        
97998>>>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
97998>>>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
97998>>>>>//        If (bWasOpen = False and bOpened = True) Begin
97998>>>>>//            Close hTable
97998>>>>>//        End
97998>>>>>//
97998>>>>>//        Move 0 to hTable
97998>>>>>//        Repeat
97998>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97998>>>>>//            If (hTable > 0 and hTable <> 50) Begin
97998>>>>>//                Open hTable
97998>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
97998>>>>>//                If (bOpened = True) Begin
97998>>>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
97998>>>>>//                    Close hTable
97998>>>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
97998>>>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
97998>>>>>//                        Increment iCount 
97998>>>>>//                    End
97998>>>>>//                End
97998>>>>>//            End
97998>>>>>//        Until (hTable = 0)
97998>>>>>//        
97998>>>>>//        If (iCount > 1) Begin
97998>>>>>//            Function_Return True
97998>>>>>//        End
97998>>>>>//
97998>>>>>//        Function_Return False
97998>>>>>//    End_Function  
97998>>>>>
97998>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
98000>>>>>        String sPhysicalName sPhysicalNameCompare
98000>>>>>        Integer iCount iMaster iAlias iInTable
98000>>>>>        
98000>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
98003>>>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
98004>>>>>        Move hTable to iInTable
98005>>>>>        Move 0 to hTable                      
98006>>>>>        Move 0 to iCount    
98007>>>>>        
98007>>>>>        Repeat
98007>>>>>>
98007>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98010>>>>>            If (hTable > 0 and hTable <> 50) Begin
98012>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
98015>>>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
98016>>>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
98018>>>>>                
98018>>>>>                    If (iCount = 0) Begin
98020>>>>>                        Move hTable to iMaster
98021>>>>>                    End
98021>>>>>>
98021>>>>>                    If (iCount > 0) Begin
98023>>>>>                        Move hTable to iAlias
98024>>>>>                    End
98024>>>>>>
98024>>>>>                    Increment iCount 
98025>>>>>                End
98025>>>>>>
98025>>>>>            End
98025>>>>>>
98025>>>>>        Until (hTable = 0)
98027>>>>>        
98027>>>>>        If (iCount > 1) Begin
98029>>>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
98030>>>>>        End
98030>>>>>>
98030>>>>>
98030>>>>>        Function_Return False
98031>>>>>    End_Function  
98032>>>>>    
98032>>>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
98032>>>>>//        String sDDSrcPath sDataPath sLogicalName
98032>>>>>//        Boolean bOK bExists
98032>>>>>//        
98032>>>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath  
98032>>>>>//        If (Right(sDataPath, 1) = "\") Begin
98032>>>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
98032>>>>>//        End
98032>>>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
98032>>>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
98032>>>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
98032>>>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
98032>>>>>//        
98032>>>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
98032>>>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
98032>>>>>//        
98032>>>>>//        Function_Return bExists
98032>>>>>//    End_Function  
98032>>>>>
98032>>>>>    // To Open a table with any driver.
98032>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
98032>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
98032>>>>>    //
98032>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
98032>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
98032>>>>>    // returns a True if successful (table could be opened).
98032>>>>>    //
98032>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
98032>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
98032>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
98032>>>>>    // set properly we can open the table.
98032>>>>>    //
98032>>>>>    // DAW Driver Syntax:
98032>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
98032>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
98032>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
98032>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
98032>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
98032>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
98032>>>>>    //
98032>>>>>    // DAW Driver Sample:
98032>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
98032>>>>>    //
98032>>>>>    // Mertech Driver Samples:
98032>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
98032>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
98032>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
98032>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
98032>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
98034>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
98034>>>>>        Boolean bOpen bMertechDriver bOK
98034>>>>>        Integer iRetval
98034>>>>>        tSQLConnection SQLConnection
98034>>>>>        tSQLConnection SQLConnection
98034>>>>>
98034>>>>>        Move sTableName to sTableNameOrg
98035>>>>>        If (hTable > 0) Begin
98037>>>>>//        If (hTable > 0 and Trim(sTableName) = "") Begin
98037>>>>>            Send Ignore_Error of Error_Object_Id 20529
98038>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
98039>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
98040>>>>>            Open hTable
98042>>>>>            Send Trap_Error of Error_Object_Id 20529
98043>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
98044>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND  
98045>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
98048>>>>>            If (bOpen = True) Begin
98050>>>>>                Function_Return True
98051>>>>>            End
98051>>>>>>
98051>>>>>        End
98051>>>>>>
98051>>>>>
98051>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98052>>>>>        Move SQLConnection.sDriverID to sDriverID
98053>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
98054>>>>>        Move SQLConnection.sConnectionString to sConnection
98055>>>>>        Move SQLConnection.sSchema to sSchema
98056>>>>>        If (sSchema = "") Begin
98058>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
98059>>>>>        End
98059>>>>>>
98059>>>>>
98059>>>>>        // We need to remove the ".int" part of the table name because
98059>>>>>        // the table name after the "#" in the connection syntax below wants the
98059>>>>>        // "bare" table name without any extension.
98059>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
98061>>>>>            If (Lowercase(sTableName) contains ".int") Begin
98063>>>>>                Get ParseFileExtension sTableName to sExt
98064>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
98065>>>>>            End
98065>>>>>>
98065>>>>>            Else Begin
98066>>>>>                Move sTableName to sTableNameShort
98067>>>>>                Move (Append(sTableName, ".int")) to sTableName
98068>>>>>            End
98068>>>>>>
98068>>>>>            If (bMertechDriver = False) Begin
98070>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
98071>>>>>                Move sConnection to sTableName
98072>>>>>            End
98072>>>>>>
98072>>>>>        End
98072>>>>>>
98072>>>>>
98072>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
98073>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
98074>>>>>        If (hTable = 0) Begin
98076>>>>>            Get NextFreeFilelistSlot to hTable
98077>>>>>        End
98077>>>>>>
98077>>>>>
98077>>>>>        Case Begin
98077>>>>>            Case (sDriverID = MSSQLDRV_ID)
98079>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
98079>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
98081>>>>>                    Open sTableName as hTable
98083>>>>>                End
98083>>>>>>
98083>>>>>                Else Begin
98084>>>>>                    Get OpenTableExclusive hTable to bOK
98085>>>>>                    If (bOK = False) Begin
98087>>>>>                        Function_Return False
98088>>>>>                    End
98088>>>>>>
98088>>>>>                End
98088>>>>>>
98088>>>>>                Case Break
98089>>>>>
98089>>>>>            Case (sDriverID = DB2_DRV_ID)
98092>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
98092>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
98094>>>>>                    Open sTableName as hTable
98096>>>>>                End
98096>>>>>>
98096>>>>>                Else Begin
98097>>>>>                    Get OpenTableExclusive hTable to bOK
98098>>>>>                    If (bOK = False) Begin
98100>>>>>                        Function_Return False
98101>>>>>                    End
98101>>>>>>
98101>>>>>                End
98101>>>>>>
98101>>>>>                Case Break
98102>>>>>
98102>>>>>            Case (sDriverID = ODBC_DRV_ID)
98105>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
98105>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
98107>>>>>                    Open sTableName as hTable
98109>>>>>                End
98109>>>>>>
98109>>>>>                Else Begin
98110>>>>>                    Get OpenTableExclusive hTable to bOK
98111>>>>>                    If (bOK = False) Begin
98113>>>>>                        Function_Return False
98114>>>>>                    End
98114>>>>>>
98114>>>>>                End
98114>>>>>>
98114>>>>>                Case Break
98115>>>>>
98115>>>>>            Case (sDriverID = SQLFLEX)
98118>>>>>                // ToDo: What is the <owner>? Same as Schema?
98118>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
98118>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
98119>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
98119>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
98121>>>>>                    Open sTableName as hTable
98123>>>>>                End
98123>>>>>>
98123>>>>>                Else Begin
98124>>>>>                    Get OpenTableExclusive hTable to bOK
98125>>>>>                    If (bOK = False) Begin
98127>>>>>                        Function_Return False
98128>>>>>                    End
98128>>>>>>
98128>>>>>                End
98128>>>>>>
98128>>>>>                Case Break
98129>>>>>
98129>>>>>            Case (sDriverID = MDSMySQL)
98132>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
98132>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
98133>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
98133>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
98135>>>>>                    Open sTableName as hTable
98137>>>>>                End
98137>>>>>>
98137>>>>>                Else Begin
98138>>>>>                    Get OpenTableExclusive hTable to bOK
98139>>>>>                    If (bOK = False) Begin
98141>>>>>                        Function_Return False
98142>>>>>                    End
98142>>>>>>
98142>>>>>                End
98142>>>>>>
98142>>>>>                Case Break
98143>>>>>
98143>>>>>            Case (sDriverID = MDSPgSQL)
98146>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
98146>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
98147>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
98147>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
98149>>>>>                    Open sTableName as hTable
98151>>>>>                End
98151>>>>>>
98151>>>>>                Else Begin
98152>>>>>                    Get OpenTableExclusive hTable to bOK
98153>>>>>                    If (bOK = False) Begin
98155>>>>>                        Function_Return False
98156>>>>>                    End
98156>>>>>>
98156>>>>>                End
98156>>>>>>
98156>>>>>                Case Break
98157>>>>>
98157>>>>>            Case (sDriverID = ORAFLEX)
98160>>>>>                // ToDo: What is the <owner>? Same as Schema?
98160>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
98160>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
98161>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
98161>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
98163>>>>>                    Open sTableName as hTable
98165>>>>>                End
98165>>>>>>
98165>>>>>                Else Begin
98166>>>>>                    Get OpenTableExclusive hTable to bOK
98167>>>>>                    If (bOK = False) Begin
98169>>>>>                        Function_Return False
98170>>>>>                    End
98170>>>>>>
98170>>>>>                End
98170>>>>>>
98170>>>>>                Case Break
98171>>>>>
98171>>>>>            Case (sDriverID = DATAFLEX_ID)
98174>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
98176>>>>>                    Open sTableName as hTable
98178>>>>>                End
98178>>>>>>
98178>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
98181>>>>>                    Get OpenTableExclusive hTable to bOK
98182>>>>>                    If (bOK = False) Begin
98184>>>>>                        Function_Return False
98185>>>>>                    End
98185>>>>>>
98185>>>>>                End
98185>>>>>>
98185>>>>>                Else Begin
98186>>>>>                    Open hTable
98188>>>>>                End
98188>>>>>>
98188>>>>>                Case Break
98189>>>>>
98189>>>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
98189>>>>>
98189>>>>>            Case Else
98189>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
98190>>>>>>
98190>>>>>        Case End
98190>>>>>
98190>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
98191>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
98192>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
98194>>>>>            Move False to Found
98195>>>>>        End
98195>>>>>>
98195>>>>>        // If open failed, the Err is set to true,
98195>>>>>        // but we don't want that because it could end our loop.
98195>>>>>        Move False to Err
98196>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
98199>>>>>
98199>>>>>        Function_Return bOpen
98200>>>>>    End_Function
98201>>>>>
98201>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
98201>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
98201>>>>>    // if it is an SQL table
98201>>>>>    Function UtilTableExists Handle hTable Returns Boolean
98203>>>>>        Boolean bExists bIsSQLTable
98203>>>>>        String sDataPath sRootName
98203>>>>>        
98203>>>>>        Get UtilTableNumberIsInUse hTable to bExists
98204>>>>>        If (bExists = False) Begin
98206>>>>>            Function_Return False
98207>>>>>        End
98207>>>>>>
98207>>>>>        
98207>>>>>        Move False to bIsSQLTable
98208>>>>>        If (hTable > 0) Begin
98210>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
98213>>>>>            Move (sRootName contains ":") to bIsSQLTable
98214>>>>>        End
98214>>>>>>
98214>>>>>        If (bIsSQLTable = True) Begin
98216>>>>>            Get UtilTableIsSQL hTable to bExists
98217>>>>>            Function_Return bExists
98218>>>>>        End
98218>>>>>>
98218>>>>>        Else Begin
98219>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
98220>>>>>            Get vFolderFormat sDataPath to sDataPath
98221>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
98222>>>>>        End
98222>>>>>>
98222>>>>>        
98222>>>>>        Function_Return bExists
98223>>>>>    End_Function               
98224>>>>>    
98224>>>>>    // Pass a table handle
98224>>>>>    // Returns True if the table exists in filelist.cfg.
98224>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
98226>>>>>        Handle hTable
98226>>>>>        Boolean bFound
98226>>>>>
98226>>>>>        Move False to bFound
98227>>>>>        Move 0 to hTable
98228>>>>>        Repeat
98228>>>>>>
98228>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98231>>>>>            If (hTable > 0) Begin
98233>>>>>                If (hTable = hCheckTable) Begin
98235>>>>>                    Move True to bFound
98236>>>>>                End
98236>>>>>>
98236>>>>>            End
98236>>>>>>
98236>>>>>            If (bFound = True) Break
98239>>>>>        Until (hTable = 0)
98241>>>>>
98241>>>>>        Function_Return (bFound = True)
98242>>>>>    End_Function
98243>>>>>
98243>>>>>    // Number of tables in Filelist.cfg. Returns integger
98243>>>>>    Function UtilFilelistNoOfTables Returns Integer
98245>>>>>        Handle hTable
98245>>>>>        Integer iRetval
98245>>>>>
98245>>>>>        Move 0 to hTable         
98246>>>>>        Move 0 to iRetval
98247>>>>>        
98247>>>>>        Repeat
98247>>>>>>
98247>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98250>>>>>            If (hTable > 0) Begin
98252>>>>>                Increment iRetval
98253>>>>>            End
98253>>>>>>
98253>>>>>        Until (hTable = 0)
98255>>>>>
98255>>>>>        Function_Return iRetval
98256>>>>>    End_Function
98257>>>>>
98257>>>>>    // Pass a table's logical name
98257>>>>>    // Returns True if the table exists in filelist.cfg.
98257>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
98259>>>>>        Handle hTable
98259>>>>>        Boolean bFound                           
98259>>>>>        String sCompareTable
98259>>>>>
98259>>>>>        Move False to bFound
98260>>>>>        Move 0 to hTable
98261>>>>>        Repeat
98261>>>>>>
98261>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98264>>>>>            If (hTable > 0) Begin
98266>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
98269>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
98271>>>>>                    Move True to bFound
98272>>>>>                End
98272>>>>>>
98272>>>>>            End
98272>>>>>>
98272>>>>>            If (bFound = True) Break
98275>>>>>        Until (hTable = 0)
98277>>>>>
98277>>>>>        Function_Return (bFound = True)
98278>>>>>    End_Function    
98279>>>>>    
98279>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
98281>>>>>        Boolean bOK bRecnum bToAnsi
98281>>>>>        Integer iCh                   
98281>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
98281>>>>>        
98281>>>>>        If (Trim(sDataPath) = "") Begin
98283>>>>>            Function_Return False
98284>>>>>        End
98284>>>>>>
98284>>>>>        
98284>>>>>        Move False to Err
98285>>>>>        Get psDriverID     to sDriverID
98286>>>>>        Get psConnectionID to sConnectionID
98287>>>>>        Get psSchema       to sSchemaName
98288>>>>>        Get True           to bRecnum
98289>>>>>        Get pbToANSI       to bToAnsi
98290>>>>>        Move CS_ANSI_Txt to sANSI_OEM
98291>>>>>        If (bToAnsi = False) Begin
98293>>>>>            Move CS_OEM_Txt to sANSI_OEM
98294>>>>>        End
98294>>>>>>
98294>>>>>        
98294>>>>>        Get vFolderFormat sDataPath to sDataPath
98295>>>>>        Move "CodeMast.int"         to sFileName
98296>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
98297>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
98300>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
98303>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
98306>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
98309>>>>>            Writeln channel iCh ("")
98312>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
98315>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
98318>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
98321>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
98324>>>>>            Writeln channel iCh ("")
98327>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
98330>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
98333>>>>>            Writeln channel iCh ("")
98336>>>>>        Send Seq_Close_Channel iCh
98337>>>>>        
98337>>>>>        Get vFolderFormat sDataPath to sDataPath
98338>>>>>        Move "CodeType.int"         to sFileName
98339>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
98340>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
98343>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
98346>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
98349>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
98352>>>>>            Writeln channel iCh ("")
98355>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
98358>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
98361>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
98364>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
98367>>>>>            Writeln channel iCh ("")
98370>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
98373>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
98376>>>>>            Writeln channel iCh ("")
98379>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
98382>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
98385>>>>>            Writeln channel iCh ("")
98388>>>>>        Send Seq_Close_Channel iCh
98389>>>>>    
98389>>>>>        Function_Return (Err = False)
98390>>>>>    End_Function
98391>>>>>
98391>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
98393>>>>>        String  sRetval sColumnName
98393>>>>>        String[] sOverlapFieldsArray
98394>>>>>        Integer iType iColumn iColumns
98394>>>>>        Boolean bOpen bOverlap
98394>>>>>
98394>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
98397>>>>>        If (bOpen = False) Begin
98399>>>>>            Open hTable
98401>>>>>        End
98401>>>>>>
98401>>>>>
98401>>>>>        Move "" to sRetval
98402>>>>>
98402>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
98405>>>>>
98405>>>>>        for iColumn from 0 to iColumns
98411>>>>>>
98411>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
98414>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
98416>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
98419>>>>>                If (bOverlap) Begin
98421>>>>>                    If (sRetval <> "") Begin
98423>>>>>                        Append sRetval ","
98424>>>>>                    End
98424>>>>>>
98424>>>>>                    Append sRetval iColumn
98425>>>>>                End
98425>>>>>>
98425>>>>>            End
98425>>>>>>
98425>>>>>        Loop
98426>>>>>>
98426>>>>>
98426>>>>>        If (bOpen = False) Begin
98428>>>>>            Close hTable
98429>>>>>        End
98429>>>>>>
98429>>>>>
98429>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
98430>>>>>
98430>>>>>        Function_Return sOverlapFieldsArray
98431>>>>>    End_Function
98432>>>>>
98432>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
98432>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
98434>>>>>        tColumnType[] ColumnType
98434>>>>>        tColumnType[] ColumnType
98435>>>>>
98435>>>>>        Case Begin
98435>>>>>            Case (iDbType = EN_dbTypeDataFlex)
98437>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
98438>>>>>                Case Break
98439>>>>>
98439>>>>>            Case (iDbType = EN_DbTypeDB2)
98442>>>>>                Get _UtilEnumerateDB2Types to ColumnType
98443>>>>>                Case Break
98444>>>>>
98444>>>>>            Case (iDbType = EN_DbTypeMSSQL)
98447>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
98448>>>>>                Case Break
98449>>>>>
98449>>>>>            Case (sDriverID = MDSMySQL)
98452>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
98453>>>>>                Case Break
98454>>>>>
98454>>>>>            Case (sDriverID = ORAFLEX)
98457>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
98458>>>>>                Case Break
98459>>>>>
98459>>>>>            Case (sDriverID = MDSPgSQL)
98462>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
98463>>>>>                Case Break
98464>>>>>        Case End
98464>>>>>
98464>>>>>        Function_Return ColumnType
98465>>>>>    End_Function 
98466>>>>>    
98466>>>>>    Function UtilEnumerateMSSQLODBCDrivers Returns String
98468>>>>>        Handle hoRegistry hoODBCDriverNames
98468>>>>>        Boolean bExists bKeyOpened
98468>>>>>        String sKey
98468>>>>>        String[] sDrivers
98469>>>>>        Integer iDriverNames iDriverName
98469>>>>>        
98469>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
98470>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
98471>>>>>        Set pfAccessRights of hoRegistry to Key_Read
98472>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
98473>>>>>        Get KeyExists of hoRegistry sKey to bExists
98474>>>>>        If (bExists) Begin
98476>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
98477>>>>>            If (bKeyOpened) Begin
98479>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
98480>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
98481>>>>>                If (iDriverNames > 0) Begin
98483>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
98484>>>>>                    Decrement iDriverNames
98485>>>>>                    for iDriverName from 0 to iDriverNames
98491>>>>>>
98491>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
98492>>>>>                      Loop
98493>>>>>>
98493>>>>>                End
98493>>>>>>
98493>>>>>                Send CloseKey of hoRegistry
98494>>>>>            End
98494>>>>>>
98494>>>>>        End
98494>>>>>>
98494>>>>>        Send Destroy of hoRegistry
98495>>>>>        
98495>>>>>        Function_Return sDrivers
98496>>>>>    End_Function
98497>>>>>
98497>>>>>    // DataFlex Embedded Database Data Types:
98497>>>>>    // Helper function for UtilEnumerateColumnTypes
98497>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
98499>>>>>        tColumnType[] ColumnType
98499>>>>>        tColumnType[] ColumnType
98500>>>>>        Integer i
98500>>>>>
98500>>>>>        Move DF_ASCII           to ColumnType[i].iType
98501>>>>>        Move "ASCII"            to ColumnType[i].sType
98502>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
98503>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
98504>>>>>        Move "254"              to ColumnType[i].sPrecision
98505>>>>>        Increment i
98506>>>>>
98506>>>>>        Move DF_BCD             to ColumnType[i].iType
98507>>>>>        Move "Numeric"          to ColumnType[i].sType
98508>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98509>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98510>>>>>        Move "14.8"             to ColumnType[i].sPrecision
98511>>>>>        Increment i
98512>>>>>
98512>>>>>        Move DF_DATE            to ColumnType[i].iType
98513>>>>>        Move "Date"             to ColumnType[i].sType
98514>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
98515>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
98516>>>>>        Move "6.0"              to ColumnType[i].sPrecision
98517>>>>>        Move True               to ColumnType[i].bFixedSize
98518>>>>>        Increment i
98519>>>>>
98519>>>>>        Move DF_TEXT            to ColumnType[i].iType
98520>>>>>        Move "Text"             to ColumnType[i].sType
98521>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98522>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
98523>>>>>        Move "16384"            to ColumnType[i].sPrecision
98524>>>>>        Increment i
98525>>>>>
98525>>>>>        Move DF_BINARY          to ColumnType[i].iType
98526>>>>>        Move "Binary"           to ColumnType[i].sType
98527>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
98528>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
98529>>>>>        Move "16384"            to ColumnType[i].sPrecision
98530>>>>>        Increment i
98531>>>>>
98531>>>>>        Move DF_DATETIME        to ColumnType[i].iType
98532>>>>>        Move "DateTime"         to ColumnType[i].sType
98533>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
98534>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
98535>>>>>        Move "23"               to ColumnType[i].sPrecision
98536>>>>>        Move True               to ColumnType[i].bFixedSize
98537>>>>>        Increment i
98538>>>>>
98538>>>>>        Move DF_OVERLAP         to ColumnType[i].iType
98539>>>>>        Move "Overlap"          to ColumnType[i].sType
98540>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
98541>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
98542>>>>>        Move "0.0"              to ColumnType[i].sPrecision
98543>>>>>
98543>>>>>        Function_Return ColumnType
98544>>>>>    End_Function
98545>>>>>
98545>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
98547>>>>>        tColumnType[] ColumnType
98547>>>>>        tColumnType[] ColumnType
98548>>>>>        Integer i
98548>>>>>
98548>>>>>        Move SQL_DBCLOB         to ColumnType[i].iType
98549>>>>>        Move "DBCLOB"           to ColumnType[i].sType
98550>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98551>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
98552>>>>>        Move "16384"            to ColumnType[i].sPrecision
98553>>>>>        Increment i
98554>>>>>
98554>>>>>        Move SQL_BIGINT         to ColumnType[i].iType
98555>>>>>        Move "BIGINT"           to ColumnType[i].sType
98556>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98557>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98558>>>>>        Move "14.0"             to ColumnType[i].sPrecision
98559>>>>>        Increment i
98560>>>>>
98560>>>>>        Move SQL_BLOB           to ColumnType[i].iType
98561>>>>>        Move "BLOB"             to ColumnType[i].sType
98562>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
98563>>>>>        Move "BINARY"           to ColumnType[i].sDataFlexType
98564>>>>>        Move "16384"            to ColumnType[i].sPrecision
98565>>>>>        Increment i
98566>>>>>
98566>>>>>        Move SQL_CHAR           to ColumnType[i].iType
98567>>>>>        Move "CHAR"             to ColumnType[i].sType
98568>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
98569>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
98570>>>>>        Move "254"              to ColumnType[i].sPrecision
98571>>>>>        Increment i
98572>>>>>
98572>>>>>        // ToDo: We need to change the sType when using this!
98572>>>>>        Move SQL_CHARBIT            to ColumnType[i].iType
98573>>>>>        Move "CHAR FOR BIT DATA"    to ColumnType[i].sType
98574>>>>>        Move DF_BINARY              to ColumnType[i].iDataFlexType
98575>>>>>        Move "Binary"               to ColumnType[i].sDataFlexType
98576>>>>>        Move "254"                  to ColumnType[i].sPrecision
98577>>>>>        Increment i
98578>>>>>
98578>>>>>        Move SQL_DATE           to ColumnType[i].iType
98579>>>>>        Move "DATE"             to ColumnType[i].sType
98580>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
98581>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
98582>>>>>        Move "6.0"              to ColumnType[i].sPrecision
98583>>>>>        Move True               to ColumnType[i].bFixedSize
98584>>>>>        Increment i
98585>>>>>
98585>>>>>        Move SQL_CLOB           to ColumnType[i].iType
98586>>>>>        Move "CLOB"             to ColumnType[i].sType
98587>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98588>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
98589>>>>>        Move "16384"            to ColumnType[i].sPrecision
98590>>>>>        Increment i
98591>>>>>
98591>>>>>        Move SQL_DECIMAL        to ColumnType[i].iType
98592>>>>>        Move "DECIMAL"          to ColumnType[i].sType
98593>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98594>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98595>>>>>        Move "14.8"             to ColumnType[i].sPrecision
98596>>>>>        Increment i
98597>>>>>
98597>>>>>        Move SQL_DOUBLE         to ColumnType[i].iType
98598>>>>>        Move "DOUBLE"           to ColumnType[i].sType
98599>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98600>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98601>>>>>        Move "14.8"             to ColumnType[i].sPrecision
98602>>>>>        Increment i
98603>>>>>
98603>>>>>        Move SQL_FLOAT          to ColumnType[i].iType
98604>>>>>        Move "FLOAT"            to ColumnType[i].sType
98605>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98606>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98607>>>>>        Move "14.8"             to ColumnType[i].sPrecision
98608>>>>>        Increment i
98609>>>>>
98609>>>>>        Move SQL_GRAPHIC        to ColumnType[i].iType
98610>>>>>        Move "GRAPHIC"          to ColumnType[i].sType
98611>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
98612>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
98613>>>>>        Move "255"              to ColumnType[i].sPrecision
98614>>>>>        Increment i
98615>>>>>
98615>>>>>        Move SQL_INTEGER        to ColumnType[i].iType
98616>>>>>        Move "INTEGER"          to ColumnType[i].sType
98617>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98618>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98619>>>>>        Move "9.0"              to ColumnType[i].sPrecision
98620>>>>>        Increment i
98621>>>>>
98621>>>>>        Move SQL_LONGVARCHAR    to ColumnType[i].iType
98622>>>>>        Move "LONG VARCHAR"     to ColumnType[i].sType
98623>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98624>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
98625>>>>>        Move "32000"            to ColumnType[i].sPrecision
98626>>>>>        Increment i
98627>>>>>
98627>>>>>        Move SQL_LONGVARCHARBIT to ColumnType[i].iType
98628>>>>>        Move "LONG VARCHAR BIT" to ColumnType[i].sType
98629>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98630>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
98631>>>>>        Move "32000"            to ColumnType[i].sPrecision
98632>>>>>        Increment i
98633>>>>>
98633>>>>>        Move SQL_LONGVARGRAPHIC to ColumnType[i].iType
98634>>>>>        Move "LONG VARGRAPHIC"  to ColumnType[i].sType
98635>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98636>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
98637>>>>>        Move "32000"            to ColumnType[i].sPrecision
98638>>>>>        Increment i
98639>>>>>
98639>>>>>        Move SQL_NUMERIC        to ColumnType[i].iType
98640>>>>>        Move "NUMERIC"          to ColumnType[i].sType
98641>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98642>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98643>>>>>        Move "14.8"             to ColumnType[i].sPrecision
98644>>>>>        Increment i
98645>>>>>
98645>>>>>        Move SQL_REAL           to ColumnType[i].iType
98646>>>>>        Move "REAL"             to ColumnType[i].sType
98647>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98648>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98649>>>>>        Move "14.8"             to ColumnType[i].sPrecision
98650>>>>>        Increment i
98651>>>>>
98651>>>>>        Move SQL_SMALLINT       to ColumnType[i].iType
98652>>>>>        Move "SMALLINT"         to ColumnType[i].sType
98653>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98654>>>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
98655>>>>>        Move "5.0"              to ColumnType[i].sPrecision
98656>>>>>        Increment i
98657>>>>>
98657>>>>>        Move SQL_TIME           to ColumnType[i].iType
98658>>>>>        Move "TIME"             to ColumnType[i].sType
98659>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
98660>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
98661>>>>>        Move "19.0"             to ColumnType[i].sPrecision
98662>>>>>        Move True               to ColumnType[i].bFixedSize
98663>>>>>        Increment i
98664>>>>>
98664>>>>>        Move SQL_TIMESTAMP      to ColumnType[i].iType
98665>>>>>        Move "TIMESTAMP"        to ColumnType[i].sType
98666>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
98667>>>>>        Move "DATETIME"         to ColumnType[i].sDataFlexType
98668>>>>>        Move "23.6"             to ColumnType[i].sPrecision
98669>>>>>        Move True               to ColumnType[i].bFixedSize
98670>>>>>        Increment i
98671>>>>>
98671>>>>>        Move SQL_VARCHAR        to ColumnType[i].iType
98672>>>>>        Move "VARCHAR"          to ColumnType[i].sType
98673>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98674>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
98675>>>>>        Move "16384"            to ColumnType[i].sPrecision
98676>>>>>        Increment i
98677>>>>>
98677>>>>>        // ToDo: We need to change the sType when using this!
98677>>>>>        Move SQL_VARCHARBIT         to ColumnType[i].iType
98678>>>>>        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sType
98679>>>>>        Move DF_TEXT                to ColumnType[i].iDataFlexType
98680>>>>>        Move "TEXT"                 to ColumnType[i].sDataFlexType
98681>>>>>        Move "16384"                to ColumnType[i].sPrecision
98682>>>>>        Increment i
98683>>>>>
98683>>>>>        Move SQL_VARGRAPHIC     to ColumnType[i].iType
98684>>>>>        Move "VARGRAPHIC"       to ColumnType[i].sType
98685>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98686>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
98687>>>>>        Move "16384"            to ColumnType[i].sPrecision
98688>>>>>
98688>>>>>        Move SQL_XML            to ColumnType[i].iType
98689>>>>>        Move "XML"              to ColumnType[i].sType
98690>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98691>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
98692>>>>>        Move "16384"            to ColumnType[i].sPrecision
98693>>>>>
98693>>>>>        Function_Return ColumnType
98694>>>>>    End_Function
98695>>>>>
98695>>>>>    // Microsoft SQL Server Database Data Types:
98695>>>>>    // Helper function for UtilEnumerateColumnTypes
98695>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
98697>>>>>        tColumnType[] ColumnType
98697>>>>>        tColumnType[] ColumnType
98698>>>>>        Integer i
98698>>>>>
98698>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
98700>>>>>            Move SQL_BIGINT         to ColumnType[i].iType
98701>>>>>            Move "bigint"           to ColumnType[i].sType
98702>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98703>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98704>>>>>            Move "14.0"             to ColumnType[i].sPrecision
98705>>>>>            Move True               to ColumnType[i].bFixedSize
98706>>>>>            Increment i
98707>>>>>
98707>>>>>            Move SQL_BINARY         to ColumnType[i].iType
98708>>>>>            Move "binary"           to ColumnType[i].sType
98709>>>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
98710>>>>>            Move "Binary"           to ColumnType[i].sDataFlexType
98711>>>>>            Move "8000"             to ColumnType[i].sPrecision
98712>>>>>            Increment i
98713>>>>>
98713>>>>>            Move SQL_BIT            to ColumnType[i].iType
98714>>>>>            Move "bit"              to ColumnType[i].sType
98715>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
98716>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
98717>>>>>            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
98718>>>>>            Move True               to ColumnType[i].bFixedSize
98719>>>>>            Increment i
98720>>>>>
98720>>>>>            Move SQL_CHAR           to ColumnType[i].iType
98721>>>>>            Move "char"             to ColumnType[i].sType
98722>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98723>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
98724>>>>>            Move "8000"             to ColumnType[i].sPrecision
98725>>>>>            Increment i
98726>>>>>
98726>>>>>            Move SQL_DATE           to ColumnType[i].iType
98727>>>>>            Move "date"             to ColumnType[i].sType
98728>>>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
98729>>>>>            Move "Date"             to ColumnType[i].sDataFlexType
98730>>>>>            Move "6.0"              to ColumnType[i].sPrecision
98731>>>>>            Move True               to ColumnType[i].bFixedSize
98732>>>>>            Increment i
98733>>>>>
98733>>>>>            Move SQL_DATETIME       to ColumnType[i].iType
98734>>>>>            Move "datetime"         to ColumnType[i].sType
98735>>>>>            Move DF_DATETIME        to ColumnType[i].iDataFlexType
98736>>>>>            Move "DateTime"         to ColumnType[i].sDataFlexType
98737>>>>>            Move "23.3"             to ColumnType[i].sPrecision
98738>>>>>            Move True               to ColumnType[i].bFixedSize
98739>>>>>            Increment i
98740>>>>>
98740>>>>>            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iType
98741>>>>>            Move "datetime2"         to ColumnType[i].sType
98742>>>>>            Move DF_DATETIME         to ColumnType[i].iDataFlexType
98743>>>>>            Move "DateTime"          to ColumnType[i].sDataFlexType
98744>>>>>            Move "23.6"              to ColumnType[i].sPrecision
98745>>>>>            Move True                to ColumnType[i].bFixedSize
98746>>>>>            Increment i
98747>>>>>
98747>>>>>            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iType
98748>>>>>            Move "datetimeoffset"       to ColumnType[i].sType
98749>>>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98750>>>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
98751>>>>>            Move "34.0"                 to ColumnType[i].sPrecision
98752>>>>>            Move True                   to ColumnType[i].bFixedSize
98753>>>>>            Increment i
98754>>>>>
98754>>>>>            Move SQL_DECIMAL        to ColumnType[i].iType
98755>>>>>            Move "decimal"          to ColumnType[i].sType
98756>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98757>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98758>>>>>            Move "14.8"             to ColumnType[i].sPrecision
98759>>>>>            Increment i
98760>>>>>
98760>>>>>            Move SQL_FLOAT          to ColumnType[i].iType
98761>>>>>            Move "float"            to ColumnType[i].sType
98762>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98763>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98764>>>>>            Move "14.8"             to ColumnType[i].sPrecision
98765>>>>>            Increment i
98766>>>>>
98766>>>>>            Move SQL_INTEGER        to ColumnType[i].iType
98767>>>>>            Move "int"              to ColumnType[i].sType
98768>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98769>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98770>>>>>            Move "8.0"              to ColumnType[i].sPrecision
98771>>>>>            Move True               to ColumnType[i].bFixedSize
98772>>>>>            Increment i
98773>>>>>
98773>>>>>            Move SQL_TYPE_MONEY     to ColumnType[i].iType
98774>>>>>            Move "money"            to ColumnType[i].sType
98775>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98776>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98777>>>>>            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
98778>>>>>            Increment i
98779>>>>>
98779>>>>>            Move SQL_WCHAR          to ColumnType[i].iType
98780>>>>>            Move "nchar"            to ColumnType[i].sType
98781>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98782>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
98783>>>>>            Move "4000"             to ColumnType[i].sPrecision
98784>>>>>            Increment i
98785>>>>>
98785>>>>>            Move SQL_WLONGVARCHAR   to ColumnType[i].iType
98786>>>>>            Move "ntext"            to ColumnType[i].sType
98787>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98788>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
98789>>>>>            Move "16384"            to ColumnType[i].sPrecision
98790>>>>>            Increment i
98791>>>>>
98791>>>>>            Move SQL_NUMERIC        to ColumnType[i].iType
98792>>>>>            Move "numeric"          to ColumnType[i].sType
98793>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98794>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98795>>>>>            Move "14.8"             to ColumnType[i].sPrecision
98796>>>>>            Increment i
98797>>>>>
98797>>>>>            Move SQL_WVARCHAR       to ColumnType[i].iType
98798>>>>>            Move "nvarchar"         to ColumnType[i].sType
98799>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98800>>>>>            Move "Text"             to ColumnType[i].sDataFlexType
98801>>>>>            Move "4000"             to ColumnType[i].sPrecision
98802>>>>>            Increment i
98803>>>>>
98803>>>>>            Move SQL_VARCHARMAX     to ColumnType[i].iType
98804>>>>>            Move "nvarchar(max)"    to ColumnType[i].sType
98805>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98806>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
98807>>>>>            Move "16384"            to ColumnType[i].sPrecision
98808>>>>>            Move True               to ColumnType[i].bFixedSize
98809>>>>>            Increment i
98810>>>>>
98810>>>>>            Move SQL_REAL           to ColumnType[i].iType
98811>>>>>            Move "real"             to ColumnType[i].sType
98812>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98813>>>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98814>>>>>            Move "14.8"             to ColumnType[i].sPrecision
98815>>>>>            Increment i
98816>>>>>
98816>>>>>            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iType
98817>>>>>            Move "smalldatetime"        to ColumnType[i].sType
98818>>>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98819>>>>>            Move "DATETIME"             to ColumnType[i].sDataFlexType
98820>>>>>            Move "23.0"                 to ColumnType[i].sPrecision
98821>>>>>            Move True                   to ColumnType[i].bFixedSize
98822>>>>>            Increment i
98823>>>>>
98823>>>>>            Move SQL_SMALLINT       to ColumnType[i].iType
98824>>>>>            Move "smallint"         to ColumnType[i].sType
98825>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98826>>>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98827>>>>>            Move "4.0"              to ColumnType[i].sPrecision
98828>>>>>            Move True               to ColumnType[i].bFixedSize
98829>>>>>            Increment i
98830>>>>>
98830>>>>>            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iType
98831>>>>>            Move "smallmoney"        to ColumnType[i].sType
98832>>>>>            Move DF_BCD              to ColumnType[i].iDataFlexType
98833>>>>>            Move "NUMERIC"           to ColumnType[i].sDataFlexType
98834>>>>>            Move "10.0"              to ColumnType[i].sPrecision
98835>>>>>            Increment i
98836>>>>>
98836>>>>>            Move SQL_TEXT           to ColumnType[i].iType
98837>>>>>            Move "text"             to ColumnType[i].sType
98838>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98839>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
98840>>>>>            Move "8000"             to ColumnType[i].sPrecision
98841>>>>>            Move True               to ColumnType[i].bFixedSize
98842>>>>>            Increment i
98843>>>>>
98843>>>>>            Move SQL_TIME           to ColumnType[i].iType
98844>>>>>            Move "time"             to ColumnType[i].sType
98845>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
98846>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
98847>>>>>            Move "19.0"             to ColumnType[i].sPrecision
98848>>>>>            Move True               to ColumnType[i].bFixedSize
98849>>>>>            Increment i
98850>>>>>
98850>>>>>            Move SQL_TINYINT        to ColumnType[i].iType
98851>>>>>            Move "tinyint"          to ColumnType[i].sType
98852>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98853>>>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98854>>>>>            Move "2.0"              to ColumnType[i].sPrecision
98855>>>>>            Move True               to ColumnType[i].bFixedSize
98856>>>>>            Increment i
98857>>>>>
98857>>>>>            Move SQL_GUID           to ColumnType[i].iType
98858>>>>>            Move "uniqueidentifier" to ColumnType[i].sType
98859>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
98860>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
98861>>>>>            Move "36"               to ColumnType[i].sPrecision
98862>>>>>            Move True               to ColumnType[i].bFixedSize
98863>>>>>            Increment i
98864>>>>>
98864>>>>>            Move SQL_VARBINARY      to ColumnType[i].iType
98865>>>>>            Move "varbinary"        to ColumnType[i].sType
98866>>>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
98867>>>>>            Move "BINARY"           to ColumnType[i].sDataFlexType
98868>>>>>            Move "16384"            to ColumnType[i].sPrecision
98869>>>>>            Increment i
98870>>>>>
98870>>>>>            Move SQL_LONGVARBINARY  to ColumnType[i].iType
98871>>>>>            Move "varbinary(max)"   to ColumnType[i].sType
98872>>>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
98873>>>>>            Move "BINARY"           to ColumnType[i].sDataFlexType
98874>>>>>            Move "16384"            to ColumnType[i].sPrecision
98875>>>>>            Move True               to ColumnType[i].bFixedSize
98876>>>>>            Increment i
98877>>>>>
98877>>>>>            Move SQL_VARCHAR        to ColumnType[i].iType
98878>>>>>            Move "varchar"          to ColumnType[i].sType
98879>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
98880>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
98881>>>>>            Move "8000"             to ColumnType[i].sPrecision
98882>>>>>            Increment i
98883>>>>>
98883>>>>>            Move SQL_LONGVARCHAR    to ColumnType[i].iType
98884>>>>>            Move "varchar(max)"     to ColumnType[i].sType
98885>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98886>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
98887>>>>>            Move "16384"            to ColumnType[i].sPrecision
98888>>>>>            Move True               to ColumnType[i].bFixedSize
98889>>>>>            Increment i
98890>>>>>
98890>>>>>            Move SQL_SS_XML         to ColumnType[i].iType
98891>>>>>            Move "xml"              to ColumnType[i].sType
98892>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98893>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
98894>>>>>            Move "16384"            to ColumnType[i].sPrecision
98895>>>>>            Increment i
98896>>>>>
98896>>>>>            Move SQL_TYPE_DATE      to ColumnType[i].iType
98897>>>>>            Move "DATE"             to ColumnType[i].sType
98898>>>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
98899>>>>>            Move "date"             to ColumnType[i].sDataFlexType
98900>>>>>            Move "6.0"              to ColumnType[i].sPrecision
98901>>>>>            Move True               to ColumnType[i].bFixedSize
98902>>>>>            Increment i
98903>>>>>
98903>>>>>            Move SQL_TYPE_TIME      to ColumnType[i].iType
98904>>>>>            Move "time"             to ColumnType[i].sType
98905>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
98906>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
98907>>>>>            Move "8.7"              to ColumnType[i].sPrecision
98908>>>>>            Move True               to ColumnType[i].bFixedSize
98909>>>>>            Increment i
98910>>>>>
98910>>>>>            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iType
98911>>>>>            Move "datetime"         to ColumnType[i].sType
98912>>>>>            Move DF_DATETIME        to ColumnType[i].iDataFlexType
98913>>>>>            Move "DateTime"         to ColumnType[i].sDataFlexType
98914>>>>>            Move "23.6"             to ColumnType[i].sPrecision
98915>>>>>            Move True               to ColumnType[i].bFixedSize
98916>>>>>            Increment i
98917>>>>>
98917>>>>>        End
98917>>>>>>
98917>>>>>
98917>>>>>        // Mertech SQLFlex driver
98917>>>>>        If (sDriverID = SQLFLEX) Begin
98919>>>>>            Move eSQLServer_BIGINT  to ColumnType[i].iType
98920>>>>>            Move "BigInt"           to ColumnType[i].sType
98921>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98922>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98923>>>>>            Move "14.0"             to ColumnType[i].sPrecision
98924>>>>>            Move True               to ColumnType[i].bFixedSize
98925>>>>>            Increment i
98926>>>>>
98926>>>>>            Move eSQLServer_BINARY  to ColumnType[i].iType
98927>>>>>            Move "Binary"           to ColumnType[i].sType
98928>>>>>            Move DF_BINARY          to ColumnType[i].iDataFlexType
98929>>>>>            Move "Binary"           to ColumnType[i].sDataFlexType
98930>>>>>            Move "8000"             to ColumnType[i].sPrecision
98931>>>>>            Increment i
98932>>>>>
98932>>>>>            Move eSQLServer_BIT     to ColumnType[i].iType
98933>>>>>            Move "Bit"              to ColumnType[i].sType
98934>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
98935>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
98936>>>>>            Move "1.0"              to ColumnType[i].sPrecision
98937>>>>>            Move True               to ColumnType[i].bFixedSize // In SQL allows 1, 0, or "NULL"
98938>>>>>            Increment i
98939>>>>>
98939>>>>>            Move eSQLServer_CHAR    to ColumnType[i].iType
98940>>>>>            Move "Char"             to ColumnType[i].sType
98941>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
98942>>>>>            Move "Text"             to ColumnType[i].sDataFlexType
98943>>>>>            Move "8000"             to ColumnType[i].sPrecision
98944>>>>>            Increment i
98945>>>>>
98945>>>>>            Move eSQLServer_DATE    to ColumnType[i].iType
98946>>>>>            Move "Date"             to ColumnType[i].sType
98947>>>>>            Move DF_DATE            to ColumnType[i].iDataFlexType
98948>>>>>            Move "Date"             to ColumnType[i].sDataFlexType
98949>>>>>            Move "6.0"              to ColumnType[i].sPrecision
98950>>>>>            Move True               to ColumnType[i].bFixedSize
98951>>>>>            Increment i
98952>>>>>
98952>>>>>            Move eSQLServer_DATETIME    to ColumnType[i].iType
98953>>>>>            Move "DateTime"             to ColumnType[i].sType
98954>>>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98955>>>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
98956>>>>>            Move "23.3"                 to ColumnType[i].sPrecision
98957>>>>>            Move True                   to ColumnType[i].bFixedSize
98958>>>>>            Increment i
98959>>>>>
98959>>>>>            Move eSQLServer_DATETIME2   to ColumnType[i].iType
98960>>>>>            Move "DateTime2"            to ColumnType[i].sType
98961>>>>>            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98962>>>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
98963>>>>>            Move "23.6"                 to ColumnType[i].sPrecision
98964>>>>>            Move True                   to ColumnType[i].bFixedSize
98965>>>>>            Increment i
98966>>>>>
98966>>>>>            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iType
98967>>>>>            Move "DateTimeOffest"           to ColumnType[i].sType
98968>>>>>            Move DF_DATETIME                to ColumnType[i].iDataFlexType
98969>>>>>            Move "DateTime"                 to ColumnType[i].sDataFlexType
98970>>>>>            Move "23.0"                     to ColumnType[i].sPrecision
98971>>>>>            Move True                       to ColumnType[i].bFixedSize
98972>>>>>            Increment i
98973>>>>>
98973>>>>>            Move eSQLServer_DECIMAL to ColumnType[i].iType
98974>>>>>            Move "Decimal"          to ColumnType[i].sType
98975>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98976>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98977>>>>>            Move "14.8"             to ColumnType[i].sPrecision
98978>>>>>            Increment i
98979>>>>>
98979>>>>>            Move eSQLServer_DOUBLE  to ColumnType[i].iType
98980>>>>>            Move "Double"           to ColumnType[i].sType
98981>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98982>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98983>>>>>            Move "14.8"             to ColumnType[i].sPrecision
98984>>>>>            Increment i
98985>>>>>
98985>>>>>            Move eSQLServer_FLOAT   to ColumnType[i].iType
98986>>>>>            Move "Float"            to ColumnType[i].sType
98987>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98988>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98989>>>>>            Move "14.8"             to ColumnType[i].sPrecision
98990>>>>>            Increment i
98991>>>>>
98991>>>>>            Move eSQLServer_INT     to ColumnType[i].iType
98992>>>>>            Move "Int"              to ColumnType[i].sType
98993>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
98994>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
98995>>>>>            Move "11.0"             to ColumnType[i].sPrecision
98996>>>>>            Increment i
98997>>>>>
98997>>>>>            Move eSQLServer_NCHAR   to ColumnType[i].iType
98998>>>>>            Move "Nchar"            to ColumnType[i].sType
98999>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
99000>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
99001>>>>>            Move "4000"             to ColumnType[i].sPrecision
99002>>>>>            Increment i
99003>>>>>
99003>>>>>            Move eSQLServer_NTEXT   to ColumnType[i].iType
99004>>>>>            Move "Ntext"            to ColumnType[i].sType
99005>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
99006>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
99007>>>>>            Move "16384"            to ColumnType[i].sPrecision
99008>>>>>            Increment i
99009>>>>>
99009>>>>>            Move eSQLServer_NUMERIC to ColumnType[i].iType
99010>>>>>            Move "Numeric"          to ColumnType[i].sType
99011>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
99012>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
99013>>>>>            Move "14.8"             to ColumnType[i].sPrecision
99014>>>>>            Increment i
99015>>>>>
99015>>>>>            Move eSQLServer_NVARCHAR    to ColumnType[i].iType
99016>>>>>            Move "NvarChar"             to ColumnType[i].sType
99017>>>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
99018>>>>>            Move "Text"                 to ColumnType[i].sDataFlexType
99019>>>>>            Move "4000"                 to ColumnType[i].sPrecision
99020>>>>>            Increment i
99021>>>>>
99021>>>>>            Move eSQLServer_NVARCHARMAX to ColumnType[i].iType
99022>>>>>            Move "NvarCharMax"          to ColumnType[i].sType
99023>>>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
99024>>>>>            Move "Text"                 to ColumnType[i].sDataFlexType
99025>>>>>            Move "16384"                to ColumnType[i].sPrecision
99026>>>>>            Move True                   to ColumnType[i].bFixedSize
99027>>>>>            Increment i
99028>>>>>
99028>>>>>            Move eSQLServer_REAL    to ColumnType[i].iType
99029>>>>>            Move "Real"             to ColumnType[i].sType
99030>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
99031>>>>>            Move "NUMERIC"          to ColumnType[i].sDataFlexType
99032>>>>>            Move "14.8"             to ColumnType[i].sPrecision
99033>>>>>            Increment i
99034>>>>>
99034>>>>>            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iType
99035>>>>>            Move "SmallDateTime"            to ColumnType[i].sType
99036>>>>>            Move DF_DATETIME                to ColumnType[i].iDataFlexType
99037>>>>>            Move "DATETIME"                 to ColumnType[i].sDataFlexType
99038>>>>>            Move "23.0"                     to ColumnType[i].sPrecision
99039>>>>>            Move True                       to ColumnType[i].bFixedSize
99040>>>>>            Increment i
99041>>>>>
99041>>>>>            Move eSQLServer_SMALLINT    to ColumnType[i].iType
99042>>>>>            Move "SmallInt"             to ColumnType[i].sType
99043>>>>>            Move DF_BCD                 to ColumnType[i].iDataFlexType
99044>>>>>            Move "NUMERIC"              to ColumnType[i].sDataFlexType
99045>>>>>            Move "6.0"                  to ColumnType[i].sPrecision
99046>>>>>            Increment i
99047>>>>>
99047>>>>>            Move eSQLServer_TEXT    to ColumnType[i].iType
99048>>>>>            Move "Text"             to ColumnType[i].sType
99049>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
99050>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
99051>>>>>            Move "8000"             to ColumnType[i].sPrecision
99052>>>>>            Move True               to ColumnType[i].bFixedSize
99053>>>>>            Increment i
99054>>>>>
99054>>>>>            Move eSQLServer_TIME    to ColumnType[i].iType
99055>>>>>            Move "Time"             to ColumnType[i].sType
99056>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
99057>>>>>            Move "Date"             to ColumnType[i].sDataFlexType
99058>>>>>            Move "16.0"             to ColumnType[i].sPrecision
99059>>>>>            Move True               to ColumnType[i].bFixedSize
99060>>>>>            Increment i
99061>>>>>
99061>>>>>            Move eSQLServer_TIMESTAMP   to ColumnType[i].iType
99062>>>>>            Move "TimeStamp"            to ColumnType[i].sType
99063>>>>>            Move DF_ASCII               to ColumnType[i].iDataFlexType
99064>>>>>            Move "DateTime"             to ColumnType[i].sDataFlexType
99065>>>>>            Move "8.0"                  to ColumnType[i].sPrecision
99066>>>>>            Move True                   to ColumnType[i].bFixedSize
99067>>>>>            Increment i
99068>>>>>
99068>>>>>            Move eSQLServer_TINYINT to ColumnType[i].iType
99069>>>>>            Move "TinyInt"          to ColumnType[i].sType
99070>>>>>            Move DF_BCD             to ColumnType[i].iDataFlexType
99071>>>>>            Move "Numeric"          to ColumnType[i].sDataFlexType
99072>>>>>            Move "3.0"              to ColumnType[i].sPrecision
99073>>>>>            Increment i
99074>>>>>
99074>>>>>            Move eSQLServer_GUID    to ColumnType[i].iType
99075>>>>>            Move "UniqueIdentifier" to ColumnType[i].sType
99076>>>>>            Move DF_ASCII           to ColumnType[i].iDataFlexType
99077>>>>>            Move "ASCII"            to ColumnType[i].sDataFlexType
99078>>>>>            Move "38"               to ColumnType[i].sPrecision
99079>>>>>            Move True               to ColumnType[i].bFixedSize
99080>>>>>            Increment i
99081>>>>>
99081>>>>>            Move eSQLServer_VARBINARY   to ColumnType[i].iType
99082>>>>>            Move "VarBinary"            to ColumnType[i].sType
99083>>>>>            Move DF_BINARY              to ColumnType[i].iDataFlexType
99084>>>>>            Move "BINARY"               to ColumnType[i].sDataFlexType
99085>>>>>            Move "8000"                 to ColumnType[i].sPrecision
99086>>>>>            Increment i
99087>>>>>
99087>>>>>            Move eSQLServer_VARBINARYMAX to ColumnType[i].iType
99088>>>>>            Move "VarBinary(Max)"        to ColumnType[i].sType
99089>>>>>            Move DF_BINARY               to ColumnType[i].iDataFlexType
99090>>>>>            Move "BINARY"                to ColumnType[i].sDataFlexType
99091>>>>>            Move "16384"                 to ColumnType[i].sPrecision
99092>>>>>            Move True                    to ColumnType[i].bFixedSize
99093>>>>>            Increment i
99094>>>>>
99094>>>>>            Move eSQLServer_VARCHAR to ColumnType[i].iType
99095>>>>>            Move "VarChar"          to ColumnType[i].sType
99096>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
99097>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
99098>>>>>            Move "8000"             to ColumnType[i].sPrecision
99099>>>>>            Increment i
99100>>>>>
99100>>>>>            Move eSQLServer_VARCHARMAX  to ColumnType[i].iType
99101>>>>>            Move "VarChar(Max)"         to ColumnType[i].sType
99102>>>>>            Move DF_TEXT                to ColumnType[i].iDataFlexType
99103>>>>>            Move "TEXT"                 to ColumnType[i].sDataFlexType
99104>>>>>            Move "16384"                to ColumnType[i].sPrecision
99105>>>>>            Move True                   to ColumnType[i].bFixedSize
99106>>>>>            Increment i
99107>>>>>
99107>>>>>            Move eSQLServer_SQLVARIANT  to ColumnType[i].iType
99108>>>>>            Move "SQL_Variant"          to ColumnType[i].sType
99109>>>>>            Move DF_BINARY              to ColumnType[i].iDataFlexType
99110>>>>>            Move "Binary"               to ColumnType[i].sDataFlexType
99111>>>>>            Move "8016"                 to ColumnType[i].sPrecision
99112>>>>>            Move True                   to ColumnType[i].bFixedSize
99113>>>>>            Increment i
99114>>>>>
99114>>>>>            Move eSQLServer_XML     to ColumnType[i].iType
99115>>>>>            Move "XML"              to ColumnType[i].sType
99116>>>>>            Move DF_TEXT            to ColumnType[i].iDataFlexType
99117>>>>>            Move "TEXT"             to ColumnType[i].sDataFlexType
99118>>>>>            Move "16384"            to ColumnType[i].sPrecision
99119>>>>>        End
99119>>>>>>
99119>>>>>
99119>>>>>        Function_Return ColumnType
99120>>>>>    End_Function
99121>>>>>
99121>>>>>    // MySQL Data Types
99121>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
99123>>>>>        tColumnType[] ColumnType
99123>>>>>        tColumnType[] ColumnType
99124>>>>>        Integer i
99124>>>>>
99124>>>>>        Move eMySQL_LONGLONG    to ColumnType[i].iType
99125>>>>>        Move "bigint"           to ColumnType[i].sType
99126>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99127>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99128>>>>>        Move "14.0"             to ColumnType[i].sPrecision
99129>>>>>        Increment i
99130>>>>>
99130>>>>>        Move eMySQL_BIT         to ColumnType[i].iType
99131>>>>>        Move "bit"              to ColumnType[i].sType
99132>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99133>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99134>>>>>        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
99135>>>>>        Move True               to ColumnType[i].bFixedSize
99136>>>>>        Increment i
99137>>>>>
99137>>>>>        Move eMySQL_BLOB        to ColumnType[i].iType
99138>>>>>        Move "blob"             to ColumnType[i].sType
99139>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99140>>>>>        Move "BINARY"           to ColumnType[i].sDataFlexType
99141>>>>>        Move "16384"            to ColumnType[i].sPrecision
99142>>>>>        Increment i
99143>>>>>
99143>>>>>        Move eMySQL_STRING      to ColumnType[i].iType
99144>>>>>        Move "char"             to ColumnType[i].sType
99145>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99146>>>>>        Move "TEXT"             to ColumnType[i].sDataFlexType
99147>>>>>        Move "254"              to ColumnType[i].sPrecision
99148>>>>>        Increment i
99149>>>>>
99149>>>>>        Move eMySQL_DATE        to ColumnType[i].iType
99150>>>>>        Move "date"             to ColumnType[i].sType
99151>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
99152>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
99153>>>>>        Move "6.0"              to ColumnType[i].sPrecision
99154>>>>>        Move True               to ColumnType[i].bFixedSize
99155>>>>>        Increment i
99156>>>>>
99156>>>>>        Move eMySQL_DATETIME    to ColumnType[i].iType
99157>>>>>        Move "datetime"         to ColumnType[i].sType
99158>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99159>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
99160>>>>>        Move "23.0"             to ColumnType[i].sPrecision
99161>>>>>        Move True               to ColumnType[i].bFixedSize
99162>>>>>        Increment i
99163>>>>>
99163>>>>>        Move eMySQL_DECIMAL     to ColumnType[i].iType
99164>>>>>        Move "decimal"          to ColumnType[i].sType
99165>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99166>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99167>>>>>        Move "14.8"             to ColumnType[i].sPrecision
99168>>>>>        Increment i
99169>>>>>
99169>>>>>        Move eMySQL_DOUBLE      to ColumnType[i].iType
99170>>>>>        Move "double"           to ColumnType[i].sType
99171>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99172>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99173>>>>>        Move "14.8"             to ColumnType[i].sPrecision
99174>>>>>        Increment i
99175>>>>>
99175>>>>>        Move eMySQL_ENUM        to ColumnType[i].iType
99176>>>>>        Move "enum"             to ColumnType[i].sType
99177>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99178>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99179>>>>>        Move "254"              to ColumnType[i].sPrecision
99180>>>>>        Increment i
99181>>>>>
99181>>>>>        Move eMySQL_FLOAT       to ColumnType[i].iType
99182>>>>>        Move "float"            to ColumnType[i].sType
99183>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99184>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99185>>>>>        Move "14.8"             to ColumnType[i].sPrecision
99186>>>>>        Increment i
99187>>>>>
99187>>>>>        Move eMySQL_INT24       to ColumnType[i].iType
99188>>>>>        Move "int"              to ColumnType[i].sType
99189>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99190>>>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
99191>>>>>        Move "11.0"             to ColumnType[i].sPrecision
99192>>>>>        Increment i
99193>>>>>
99193>>>>>        Move eMySQL_LONG_BLOB   to ColumnType[i].iType
99194>>>>>        Move "longblob"         to ColumnType[i].sType
99195>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99196>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99197>>>>>        Move "16384"            to ColumnType[i].sPrecision
99198>>>>>        Increment i
99199>>>>>
99199>>>>>        Move eMySQL_LONG_TEXT   to ColumnType[i].iType
99200>>>>>        Move "longtext"         to ColumnType[i].sType
99201>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99202>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99203>>>>>        Move "16384"            to ColumnType[i].sPrecision
99204>>>>>        Increment i
99205>>>>>
99205>>>>>        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iType
99206>>>>>        Move "mediumblob"       to ColumnType[i].sType
99207>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99208>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99209>>>>>        Move "16384"            to ColumnType[i].sPrecision
99210>>>>>        Increment i
99211>>>>>
99211>>>>>        Move eMySQL_INT24       to ColumnType[i].iType
99212>>>>>        Move "mediumint"        to ColumnType[i].sType
99213>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99214>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99215>>>>>        Move "9.0"              to ColumnType[i].sPrecision
99216>>>>>
99216>>>>>        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iType
99217>>>>>        Move "mediumtext"       to ColumnType[i].sType
99218>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99219>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99220>>>>>        Move "16384"            to ColumnType[i].sPrecision
99221>>>>>        Increment i
99222>>>>>
99222>>>>>        Move eMySQL_SET         to ColumnType[i].iType
99223>>>>>        Move "set"              to ColumnType[i].sType
99224>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99225>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99226>>>>>        Move "254"              to ColumnType[i].sPrecision
99227>>>>>        Increment i
99228>>>>>
99228>>>>>        Move eMySQL_SHORT       to ColumnType[i].iType
99229>>>>>        Move "smallint"         to ColumnType[i].sType
99230>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99231>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99232>>>>>        Move "6.0"              to ColumnType[i].sPrecision
99233>>>>>        Increment i
99234>>>>>
99234>>>>>        Move eMySQL_TEXT        to ColumnType[i].iType
99235>>>>>        Move "text"             to ColumnType[i].sType
99236>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99237>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99238>>>>>        Move "16384"            to ColumnType[i].sPrecision
99239>>>>>        Increment i
99240>>>>>
99240>>>>>        Move eMySQL_TIME        to ColumnType[i].iType
99241>>>>>        Move "time"             to ColumnType[i].sType
99242>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99243>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99244>>>>>        Move "10.0"             to ColumnType[i].sPrecision
99245>>>>>        Move True               to ColumnType[i].bFixedSize
99246>>>>>        Increment i
99247>>>>>
99247>>>>>        Move eMySQL_TIMESTAMP   to ColumnType[i].iType
99248>>>>>        Move "timestamp"        to ColumnType[i].sType
99249>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99250>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
99251>>>>>        Move "23.0"             to ColumnType[i].sPrecision
99252>>>>>        Move True               to ColumnType[i].bFixedSize
99253>>>>>        Increment i
99254>>>>>
99254>>>>>        Move eMySQL_TINY_BLOB   to ColumnType[i].iType
99255>>>>>        Move "tinyblob"         to ColumnType[i].sType
99256>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99257>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99258>>>>>        Move "254"              to ColumnType[i].sPrecision
99259>>>>>        Increment i
99260>>>>>
99260>>>>>        Move eMySQL_TINY        to ColumnType[i].iType
99261>>>>>        Move "tinyint"          to ColumnType[i].sType
99262>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99263>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99264>>>>>        Move "4.0"              to ColumnType[i].sPrecision
99265>>>>>        Increment i
99266>>>>>
99266>>>>>        Move eMySQL_TINY_TEXT   to ColumnType[i].iType
99267>>>>>        Move "tinytext"         to ColumnType[i].sType
99268>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99269>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99270>>>>>        Move "254"              to ColumnType[i].sPrecision
99271>>>>>        Increment i
99272>>>>>
99272>>>>>        Move eMySQL_VAR_STRING  to ColumnType[i].iType
99273>>>>>        Move "varchar"          to ColumnType[i].sType
99274>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99275>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99276>>>>>        Move "16384"            to ColumnType[i].sPrecision
99277>>>>>        Increment i
99278>>>>>
99278>>>>>        Move eMySQL_YEAR        to ColumnType[i].iType
99279>>>>>        Move "year"             to ColumnType[i].sType
99280>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99281>>>>>        Move "NUMERIC"          to ColumnType[i].sDataFlexType
99282>>>>>        Move "4.0"              to ColumnType[i].sPrecision
99283>>>>>        Move True               to ColumnType[i].bFixedSize
99284>>>>>        Increment i
99285>>>>>
99285>>>>>        Function_Return ColumnType
99286>>>>>    End_Function
99287>>>>>
99287>>>>>    // Oracle Data Types
99287>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
99289>>>>>        tColumnType[] ColumnType
99289>>>>>        tColumnType[] ColumnType
99290>>>>>        Integer i
99290>>>>>
99290>>>>>        Move eOracle_BLOB       to ColumnType[i].iType
99291>>>>>        Move "BLOB"             to ColumnType[i].sType
99292>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99293>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99294>>>>>        Move "16384"            to ColumnType[i].sPrecision
99295>>>>>        Increment i
99296>>>>>
99296>>>>>        Move eOracle_CHAR       to ColumnType[i].iType
99297>>>>>        Move "CHAR"             to ColumnType[i].sType
99298>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99299>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99300>>>>>        Move "2000"             to ColumnType[i].sPrecision
99301>>>>>        Increment i
99302>>>>>
99302>>>>>        Move eOracle_CLOB       to ColumnType[i].iType
99303>>>>>        Move "CLOB"             to ColumnType[i].sType
99304>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99305>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99306>>>>>        Move "16384"            to ColumnType[i].sPrecision
99307>>>>>        Increment i
99308>>>>>
99308>>>>>        Move eOracle_DATE       to ColumnType[i].iType
99309>>>>>        Move "DATE"             to ColumnType[i].sType
99310>>>>>        Move DF_Date            to ColumnType[i].iDataFlexType
99311>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
99312>>>>>        Move "6.0"              to ColumnType[i].sPrecision
99313>>>>>        Move True               to ColumnType[i].bFixedSize
99314>>>>>        Increment i
99315>>>>>
99315>>>>>        Move eOracle_FLOAT      to ColumnType[i].iType
99316>>>>>        Move "FLOAT"            to ColumnType[i].sType
99317>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99318>>>>>        Move "Number"           to ColumnType[i].sDataFlexType
99319>>>>>        Move "14.8"             to ColumnType[i].sPrecision
99320>>>>>        Increment i
99321>>>>>
99321>>>>>        Move eOracle_INT        to ColumnType[i].iType
99322>>>>>        Move "INT"              to ColumnType[i].sType
99323>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99324>>>>>        Move "Number"           to ColumnType[i].sDataFlexType
99325>>>>>        Move "14.0"             to ColumnType[i].sPrecision
99326>>>>>        Increment i
99327>>>>>
99327>>>>>        Move eOracle_INTERVALDS to ColumnType[i].iType
99328>>>>>        Move "INTERVALDAYTOSEC" to ColumnType[i].sType
99329>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99330>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
99331>>>>>        Move "23.0"             to ColumnType[i].sPrecision
99332>>>>>        Move True               to ColumnType[i].bFixedSize
99333>>>>>        Increment i
99334>>>>>
99334>>>>>        Move eOracle_INTERVALYM  to ColumnType[i].iType
99335>>>>>        Move "INTERVALYEARTOMON" to ColumnType[i].sType
99336>>>>>        Move DF_DATETIME         to ColumnType[i].iDataFlexType
99337>>>>>        Move "DateTime"          to ColumnType[i].sDataFlexType
99338>>>>>        Move "23.0"              to ColumnType[i].sPrecision
99339>>>>>        Move True                to ColumnType[i].bFixedSize
99340>>>>>        Increment i
99341>>>>>
99341>>>>>        Move eOracle_RAW        to ColumnType[i].iType
99342>>>>>        Move "LONG"             to ColumnType[i].sType
99343>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99344>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99345>>>>>        Move "16384"            to ColumnType[i].sPrecision
99346>>>>>        Increment i
99347>>>>>
99347>>>>>        Move eOracle_LONGRAW    to ColumnType[i].iType
99348>>>>>        Move "LONG RAW"         to ColumnType[i].sType
99349>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99350>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99351>>>>>        Move "16384"            to ColumnType[i].sPrecision
99352>>>>>        Increment i
99353>>>>>
99353>>>>>        Move eOracle_NCHAR      to ColumnType[i].iType
99354>>>>>        Move "NCHAR"            to ColumnType[i].sType
99355>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99356>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99357>>>>>        Move "2000"             to ColumnType[i].sPrecision
99358>>>>>        Increment i
99359>>>>>
99359>>>>>        Move eOracle_NCLOB      to ColumnType[i].iType
99360>>>>>        Move "NCLOB"            to ColumnType[i].sType
99361>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99362>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99363>>>>>        Move "16384"            to ColumnType[i].sPrecision
99364>>>>>        Increment i
99365>>>>>
99365>>>>>        Move eOracle_NUMBER     to ColumnType[i].iType
99366>>>>>        Move "NUMBER"           to ColumnType[i].sType
99367>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99368>>>>>        Move "Number"           to ColumnType[i].sDataFlexType
99369>>>>>        Move "14.8"             to ColumnType[i].sPrecision
99370>>>>>        Increment i
99371>>>>>
99371>>>>>        Move eOracle_NVARCHAR2  to ColumnType[i].iType
99372>>>>>        Move "NVARCHAR2"        to ColumnType[i].sType
99373>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99374>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99375>>>>>        Move "4000"             to ColumnType[i].sPrecision
99376>>>>>        Increment i
99377>>>>>
99377>>>>>        Move eOracle_RAW        to ColumnType[i].iType
99378>>>>>        Move "RAW"              to ColumnType[i].sType
99379>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99380>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99381>>>>>        Move "2000"             to ColumnType[i].sPrecision
99382>>>>>        Increment i
99383>>>>>
99383>>>>>        Move eOracle_ROWID      to ColumnType[i].iType
99384>>>>>        Move "ROWID"            to ColumnType[i].sType
99385>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99386>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99387>>>>>        Move "16384"            to ColumnType[i].sPrecision
99388>>>>>        Increment i
99389>>>>>
99389>>>>>        Move eOracle_TIMESTAMP  to ColumnType[i].iType
99390>>>>>        Move "TimeStamp"        to ColumnType[i].sType
99391>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99392>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
99393>>>>>        Move "11.0"             to ColumnType[i].sPrecision
99394>>>>>        Move True               to ColumnType[i].bFixedSize
99395>>>>>        Increment i
99396>>>>>
99396>>>>>        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iType
99397>>>>>        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sType
99398>>>>>        Move DF_DATETIME            to ColumnType[i].iDataFlexType
99399>>>>>        Move "DateTime"             to ColumnType[i].sDataFlexType
99400>>>>>        Move "13.0"                 to ColumnType[i].sPrecision
99401>>>>>        Move True                   to ColumnType[i].bFixedSize
99402>>>>>        Increment i
99403>>>>>
99403>>>>>        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iType
99404>>>>>        Move "TIMEZONETIMEZONE"     to ColumnType[i].sType
99405>>>>>        Move DF_DATETIME            to ColumnType[i].iDataFlexType
99406>>>>>        Move "DateTime"             to ColumnType[i].sDataFlexType
99407>>>>>        Move "11.0"                 to ColumnType[i].sPrecision
99408>>>>>        Move True                   to ColumnType[i].bFixedSize
99409>>>>>        Increment i
99410>>>>>
99410>>>>>        Move eOracle_VARCHAR2   to ColumnType[i].iType
99411>>>>>        Move "VARCHAR"          to ColumnType[i].sType
99412>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99413>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99414>>>>>        Move "16384"            to ColumnType[i].sPrecision
99415>>>>>
99415>>>>>        Function_Return ColumnType
99416>>>>>    End_Function
99417>>>>>
99417>>>>>    // PostgreSQL Data Types
99417>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
99419>>>>>        tColumnType[] ColumnType
99419>>>>>        tColumnType[] ColumnType
99420>>>>>        Integer i
99420>>>>>
99420>>>>>        Move ePgSQL_INT8        to ColumnType[i].iType
99421>>>>>        Move "bigint"           to ColumnType[i].sType
99422>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99423>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99424>>>>>        Move "14.0"             to ColumnType[i].sPrecision
99425>>>>>        Move True               to ColumnType[i].bFixedSize
99426>>>>>        Increment i
99427>>>>>
99427>>>>>        Move ePgSQL_BIT         to ColumnType[i].iType
99428>>>>>        Move "bit"              to ColumnType[i].sType
99429>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99430>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99431>>>>>        Move "16384"            to ColumnType[i].sPrecision
99432>>>>>        Increment i
99433>>>>>
99433>>>>>        Move ePgSQL_BOOL        to ColumnType[i].iType
99434>>>>>        Move "boolean"          to ColumnType[i].sType
99435>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99436>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99437>>>>>        Move "1"                to ColumnType[i].sPrecision
99438>>>>>        Increment i
99439>>>>>
99439>>>>>        Move ePgSQL_BYTEA       to ColumnType[i].iType
99440>>>>>        Move "bytea"            to ColumnType[i].sType
99441>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99442>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99443>>>>>        Move "16384"            to ColumnType[i].sPrecision
99444>>>>>        Increment i
99445>>>>>
99445>>>>>        Move ePgSQL_CHAR        to ColumnType[i].iType
99446>>>>>        Move "char"             to ColumnType[i].sType
99447>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99448>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99449>>>>>        Move "2000"             to ColumnType[i].sPrecision
99450>>>>>        Increment i
99451>>>>>
99451>>>>>        Move ePgSQL_CITEXT      to ColumnType[i].iType
99452>>>>>        Move "citext"           to ColumnType[i].sType
99453>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99454>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99455>>>>>        Move "254"              to ColumnType[i].sPrecision
99456>>>>>        Increment i
99457>>>>>
99457>>>>>        Move ePgSQL_DATE        to ColumnType[i].iType
99458>>>>>        Move "date"             to ColumnType[i].sType
99459>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
99460>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
99461>>>>>        Move "6.0"              to ColumnType[i].sPrecision
99462>>>>>        Move True               to ColumnType[i].bFixedSize
99463>>>>>        Increment i
99464>>>>>
99464>>>>>        Move ePgSQL_FLOAT4      to ColumnType[i].iType
99465>>>>>        Move "decimal"          to ColumnType[i].sType
99466>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99467>>>>>        Move "Decimal"          to ColumnType[i].sDataFlexType
99468>>>>>        Move "14.8"             to ColumnType[i].sPrecision
99469>>>>>        Increment i
99470>>>>>
99470>>>>>        Move ePgSQL_FLOAT8      to ColumnType[i].iType
99471>>>>>        Move "double"           to ColumnType[i].sType
99472>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99473>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99474>>>>>        Move "22"               to ColumnType[i].sPrecision
99475>>>>>        Increment i
99476>>>>>
99476>>>>>        Move ePgSQL_INT4        to ColumnType[i].iType
99477>>>>>        Move "integer"          to ColumnType[i].sType
99478>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99479>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99480>>>>>        Move "8.0"              to ColumnType[i].sPrecision
99481>>>>>        Increment i
99482>>>>>
99482>>>>>        Move ePgSQL_MONEY       to ColumnType[i].iType
99483>>>>>        Move "money"            to ColumnType[i].sType
99484>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99485>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99486>>>>>        Move "8.0"              to ColumnType[i].sPrecision
99487>>>>>        Increment i
99488>>>>>
99488>>>>>        Move ePgSQL_OID         to ColumnType[i].iType
99489>>>>>        Move "oid"              to ColumnType[i].sType
99490>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
99491>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
99492>>>>>        Move "16384"            to ColumnType[i].sPrecision
99493>>>>>        Increment i
99494>>>>>
99494>>>>>        Move ePgSQL_FLOAT4      to ColumnType[i].iType
99495>>>>>        Move "real"             to ColumnType[i].sType
99496>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99497>>>>>        Move "Real"             to ColumnType[i].sDataFlexType
99498>>>>>        Move "6.6"              to ColumnType[i].sPrecision
99499>>>>>        Increment i
99500>>>>>
99500>>>>>        Move ePgSQL_REGPROC     to ColumnType[i].iType
99501>>>>>        Move "regproc"          to ColumnType[i].sType
99502>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99503>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99504>>>>>        Move "64"               to ColumnType[i].sPrecision
99505>>>>>        Increment i
99506>>>>>
99506>>>>>        Move ePgSQL_INT2        to ColumnType[i].iType
99507>>>>>        Move "smallint"         to ColumnType[i].sType
99508>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
99509>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
99510>>>>>        Move "6.0"              to ColumnType[i].sPrecision
99511>>>>>        Increment i
99512>>>>>
99512>>>>>        Move ePgSQL_TEXT        to ColumnType[i].iType
99513>>>>>        Move "text"             to ColumnType[i].sType
99514>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99515>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
99516>>>>>        Move "16384"            to ColumnType[i].sPrecision
99517>>>>>        Increment i
99518>>>>>
99518>>>>>        Move ePgSQL_TIME        to ColumnType[i].iType
99519>>>>>        Move "time"             to ColumnType[i].sType
99520>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99521>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
99522>>>>>        Move "15.0"             to ColumnType[i].sPrecision
99523>>>>>        Increment i
99524>>>>>
99524>>>>>        Move ePgSQL_TIMESTAMP   to ColumnType[i].iType
99525>>>>>        Move "timestamp"        to ColumnType[i].sType
99526>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99527>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
99528>>>>>        Move "23.0"             to ColumnType[i].sPrecision
99529>>>>>        Move True               to ColumnType[i].bFixedSize
99530>>>>>        Increment i
99531>>>>>
99531>>>>>        Move ePgSQL_UUID        to ColumnType[i].iType
99532>>>>>        Move "uuid"             to ColumnType[i].sType
99533>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
99534>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
99535>>>>>        Move "40"               to ColumnType[i].sPrecision
99536>>>>>        Move True               to ColumnType[i].bFixedSize
99537>>>>>        Increment i
99538>>>>>
99538>>>>>        Move ePgSQL_VARCHAR     to ColumnType[i].iType
99539>>>>>        Move "varchar"          to ColumnType[i].sType
99540>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
99541>>>>>        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
99542>>>>>        Move "16384"            to ColumnType[i].sPrecision
99543>>>>>        Increment i
99544>>>>>
99544>>>>>        Function_Return ColumnType
99545>>>>>    End_Function
99546>>>>>
99546>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
99546>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
99548>>>>>        Integer iValue iSize iCount iStart iDriverID
99548>>>>>        tColumnType[] ColumnTypeArray
99548>>>>>        tColumnType[] ColumnTypeArray
99549>>>>>        tColumnType RetvalType
99549>>>>>        tColumnType RetvalType
99549>>>>>        String sValue  
99549>>>>>        Boolean bFrameworkDataFlexType
99549>>>>>
99549>>>>>        Move "Undefined" to RetvalType.sType
99550>>>>>        Move -1999       to RetvalType.iType
99551>>>>>
99551>>>>>        Move 0 to iStart
99552>>>>>        Move (Uppercase(sType)) to sType
99553>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
99554>>>>>        If (bFrameworkDataFlexType = True) Begin
99556>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
99557>>>>>            Function_Return RetvalType
99558>>>>>        End
99558>>>>>>
99558>>>>>
99558>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
99559>>>>>
99559>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
99560>>>>>        Decrement iSize
99561>>>>>
99561>>>>>        for iCount from iStart to iSize
99567>>>>>>
99567>>>>>            Move ColumnTypeArray[iCount].iType to iValue
99568>>>>>            Move ColumnTypeArray[iCount].sType to sValue
99569>>>>>            If (bIntegerInputType = True) Begin
99571>>>>>                If (iValue = iType) Begin
99573>>>>>                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
99574>>>>>                    Move iType                                  to RetvalType.iType
99575>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
99576>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
99577>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
99578>>>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
99579>>>>>                    Move iSize to iCount // We're done!
99580>>>>>                End
99580>>>>>>
99580>>>>>            End
99580>>>>>>
99580>>>>>            Else Begin
99581>>>>>                Move (Uppercase(sValue)) to sValue
99582>>>>>                If (sValue = sType) Begin
99584>>>>>                    Move sType                                  to RetvalType.sType
99585>>>>>                    Move ColumnTypeArray[iCount].iType          to RetvalType.iType
99586>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
99587>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
99588>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
99589>>>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
99590>>>>>                    Move iSize to iCount // We're done!
99591>>>>>                End
99591>>>>>>
99591>>>>>            End
99591>>>>>>
99591>>>>>        Loop            
99592>>>>>>
99592>>>>>        
99592>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
99592>>>>>        // In which case we search for a match in DataFlex standard types:
99592>>>>>        If (RetvalType.sType = "Undefined") Begin
99594>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
99595>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
99596>>>>>            Decrement iSize
99597>>>>>    
99597>>>>>            for iCount from iStart to iSize
99603>>>>>>
99603>>>>>                Move ColumnTypeArray[iCount].iType to iValue
99604>>>>>                Move ColumnTypeArray[iCount].sType to sValue
99605>>>>>                If (iValue = iType) Begin
99607>>>>>                    Move ColumnTypeArray[iCount].sType          to RetvalType.sType
99608>>>>>                    Move iType                                  to RetvalType.iType
99609>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
99610>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
99611>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
99612>>>>>                    Move ColumnTypeArray[iCount].bFixedSize     to RetvalType.bFixedSize
99613>>>>>                    Move iSize to iCount // We're done!
99614>>>>>                End
99614>>>>>>
99614>>>>>            Loop    
99615>>>>>>
99615>>>>>        End
99615>>>>>>
99615>>>>>
99615>>>>>        Function_Return RetvalType
99616>>>>>    End_Function
99617>>>>>
99617>>>>>    Function _AllTablesToConvert Returns Integer[]
99619>>>>>        Integer[] iTableConvertExceptions iTablesArray
99621>>>>>        Handle hTable
99621>>>>>        Integer iIndex
99621>>>>>        String sTableName
99621>>>>>        Boolean bFlexErrs
99621>>>>>
99621>>>>>        // a) Get the exception table array the developer has specified
99621>>>>>        Get piTableConvertExceptions to iTableConvertExceptions
99622>>>>>
99622>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
99622>>>>>        Repeat
99622>>>>>>
99622>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99625>>>>>            If (hTable <> 0) Begin
99627>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
99630>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
99631>>>>>                If (bFlexErrs = False) Begin
99633>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
99635>>>>>                        Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
99636>>>>>                        If (iIndex = -1) Begin
99638>>>>>                            Move hTable to iTableConvertExceptions[SizeOfArray(iTableConvertExceptions)]
99639>>>>>                        End
99639>>>>>>
99639>>>>>                    End
99639>>>>>>
99639>>>>>                End
99639>>>>>>
99639>>>>>            End
99639>>>>>>
99639>>>>>        Until (hTable = 0)
99641>>>>>
99641>>>>>        Move 0 to hTable
99642>>>>>
99642>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
99642>>>>>        Repeat
99642>>>>>>
99642>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99645>>>>>            If (hTable > 0) Begin
99647>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
99650>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
99651>>>>>                If (bFlexErrs = False) Begin
99653>>>>>                    Move (SearchArray(hTable, iTableConvertExceptions)) to iIndex
99654>>>>>                    If (iIndex = -1) Begin
99656>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
99657>>>>>                    End
99657>>>>>>
99657>>>>>                End
99657>>>>>>
99657>>>>>            End
99657>>>>>>
99657>>>>>        Until (hTable = 0)
99659>>>>>
99659>>>>>        Function_Return iTablesArray
99660>>>>>    End_Function
99661>>>>>
99661>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[] 
99663>>>>>        tAPIColumn NewAPIColumn 
99663>>>>>        tAPIColumn NewAPIColumn 
99663>>>>>        
99663>>>>>        Move sFieldName to NewAPIColumn.sFieldName
99664>>>>>        Move iType      to NewAPIColumn.iType
99665>>>>>        Move iLength    to NewAPIColumn.iLength
99666>>>>>        Move iPrecision to NewAPIColumn.iPrecision
99667>>>>>        Move iOptions   to NewAPIColumn.iOptions
99668>>>>>        
99668>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
99669>>>>>        
99669>>>>>        Function_Return aCurrent
99670>>>>>    End_Function
99671>>>>>
99671>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
99673>>>>>        String sRetval sFieldName
99673>>>>>        Integer iCount iSize
99673>>>>>        
99673>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
99674>>>>>        Decrement iSize
99675>>>>>        for iCount from 0 to iSize
99681>>>>>>
99681>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
99682>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
99683>>>>>        Loop                                                
99684>>>>>>
99684>>>>>        Move (Trim(sRetval)) to sRetval
99685>>>>>        
99685>>>>>        Function_Return sRetval
99686>>>>>    End_Function
99687>>>>>
99687>>>>>    // *** Miscellaneous other functions ***
99687>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
99687>>>>>    //
99687>>>>>
99687>>>>>    // Callback functionality used when e.g. calling driver functions directly.
99687>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
99689>>>>>        Integer iRetval iPos iPerc
99689>>>>>        String sVal1 sVal2
99689>>>>>        Number nReady nTotal
99689>>>>>
99689>>>>>        Send DoAdvance of ghoProgressBar
99690>>>>>
99690>>>>>        If (sCallback_Text contains "Copy records") Begin
99692>>>>>            Move CS_SQLCopyingData to sCallback_Text
99693>>>>>        End
99693>>>>>>
99693>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
99695>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
99696>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
99697>>>>>        End
99697>>>>>>
99697>>>>>        If (sCallback_Text contains "Creating index") Begin
99699>>>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
99700>>>>>        End
99700>>>>>>
99700>>>>>
99700>>>>>        Case Begin
99700>>>>>            Case (iCallback_Type = DF_Message_Text)
99702>>>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
99702>>>>>                Set Action_Text  of ghoStatusPanel to ""
99703>>>>>                Case Break
99704>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
99707>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99708>>>>>                Set Action_Text  of ghoStatusPanel to ""
99709>>>>>                Case Break
99710>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
99713>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99714>>>>>                Set Action_Text  of ghoStatusPanel to ""
99715>>>>>                Case Break
99716>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
99719>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99720>>>>>                Set Action_Text  of ghoStatusPanel to ""
99721>>>>>                Case Break
99722>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
99725>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99726>>>>>                Set Action_Text  of ghoStatusPanel to ""
99727>>>>>                Case Break
99728>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
99731>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99732>>>>>                Set Action_Text  of ghoStatusPanel to ""
99733>>>>>                Case Break
99734>>>>>            Case (iCallback_Type = DF_Message_Warning)
99737>>>>>                Send None
99738>>>>>                Case Break
99739>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
99742>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
99743>>>>>                Set Action_Text  of ghoStatusPanel to ""
99744>>>>>                Case Break
99745>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
99748>>>>>                //*** Interpret numbers
99748>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
99749>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
99750>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
99751>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
99752>>>>>                Case Break
99753>>>>>            Case Else
99753>>>>>                Set Message_Text to ""
99754>>>>>                Set Action_Text  to ""
99755>>>>>        Case End
99755>>>>>
99755>>>>>        Send ProcessEvents of ghoStatusPanel
99756>>>>>        Function_Return False
99757>>>>>    End_Function
99758>>>>>
99758>>>>>    Procedure IncreaseSortBufferSize
99760>>>>>        String sNull
99760>>>>>        Integer iSortBufferSize
99760>>>>>        Boolean bBufferSet
99760>>>>>
99760>>>>>        Move "" to sNull
99761>>>>>        Move (1024 * 128) to iSortBufferSize
99762>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback Self Passing sNull sNull iSortBufferSize Result bBufferSet
99767>>>>>
99767>>>>>    End_Procedure
99768>>>>>
99768>>>>>    Procedure SetAllIndexesToBatch Handle hTable
99770>>>>>        Integer iLastIndex iIndex iNumSegments iIndexType
99770>>>>>        String sTable
99770>>>>>        Boolean bOK
99770>>>>>        
99770>>>>>        If (hTable > 0) Begin
99772>>>>>            Close hTable
99773>>>>>            Get OpenTableExclusive hTable to bOK
99774>>>>>            If (bOK = False) Begin
99776>>>>>                Function_Return False
99777>>>>>            End
99777>>>>>>
99777>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
99780>>>>>            for iIndex from 1 to iLastIndex
99786>>>>>>
99786>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
99789>>>>>                If (iNumSegments > 0) Begin
99791>>>>>                    Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
99794>>>>>                End
99794>>>>>>
99794>>>>>            Loop
99795>>>>>>
99795>>>>>            Close hTable
99796>>>>>        End
99796>>>>>>
99796>>>>>    End_Procedure
99797>>>>>
99797>>>>>    Function NextFreeFilelistSlot Returns Handle
99799>>>>>        Handle hTable
99799>>>>>
99799>>>>>        Move 0 to hTable
99800>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
99803>>>>>
99803>>>>>        Function_Return hTable
99804>>>>>    End_Function
99805>>>>>
99805>>>>>    // For debugging purposes. To print Sql statements as they are build...
99805>>>>>    Procedure DebugPrint String sStmt String sFileName
99807>>>>>        Integer iCh
99807>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
99808>>>>>            Write channel iCh sStmt
99810>>>>>        Send Seq_Close_Channel iCh
99811>>>>>    End_Procedure
99812>>>>>
99812>>>>>    // Returns the integer number for the passed Driver ID that is
99812>>>>>    // needed by some database API calls.
99812>>>>>    Function DriverIndex String sDriverID Returns Integer
99814>>>>>        String  sCurrentDriver
99814>>>>>        Integer iNumberOfDrivers iDriver iCount
99814>>>>>
99814>>>>>        Move 0 to iDriver
99815>>>>>
99815>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
99818>>>>>        for iCount from 1 to iNumberOfDrivers
99824>>>>>>
99824>>>>>
99824>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
99827>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
99829>>>>>                Move iCount to iDriver
99830>>>>>            End
99830>>>>>>
99830>>>>>        Loop
99831>>>>>>
99831>>>>>
99831>>>>>        // In case it was not found, it wasn't loaded so we do that now.
99831>>>>>        If (iDriver = 0) Begin
99833>>>>>            Move False to Err
99834>>>>>            Load_Driver sDriverID
99835>>>>>            If (Err = False) Begin
99837>>>>>                Move 1 to iDriver
99838>>>>>            End
99838>>>>>>
99838>>>>>        End
99838>>>>>>
99838>>>>>
99838>>>>>        Function_Return iDriver
99839>>>>>    End_Function
99840>>>>>
99840>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE  
99840>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
99840>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
99840>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
99842>>>>>        Integer iMode
99842>>>>>        Boolean bOpened bCodeMasterType                        
99842>>>>>        String sTableName
99842>>>>>        
99842>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
99843>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
99846>>>>>        If (bOpened) Begin
99848>>>>>            If (IsDebuggerPresent()) Begin
99850>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
99853>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
99855>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
99856>>>>>                    Function_Return True
99857>>>>>                End
99857>>>>>>
99857>>>>>            End
99857>>>>>>
99857>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
99860>>>>>            If (iMode=DF_EXCLUSIVE) Begin
99862>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
99863>>>>>                Function_Return True
99864>>>>>            End
99864>>>>>>
99864>>>>>            Close hTable
99865>>>>>        End
99865>>>>>>
99865>>>>>        Else Begin
99866>>>>>            Open hTable
99868>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
99871>>>>>            If (bOpened and IsDebuggerPresent()) Begin
99873>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
99876>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
99878>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
99879>>>>>                    Function_Return True
99880>>>>>                End
99880>>>>>>
99880>>>>>            End
99880>>>>>>
99880>>>>>            
99880>>>>>        End
99880>>>>>>
99880>>>>>
99880>>>>>        Open hTable Mode DF_EXCLUSIVE
99882>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
99885>>>>>
99885>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
99886>>>>>        Function_Return bOpened
99887>>>>>    End_Function
99888>>>>>    
99888>>>>>    Function AutoConnectionIDLogin Returns Boolean
99890>>>>>        String sConnectionID sConnectionString sDriverID
99890>>>>>        Boolean bExists bOK bDAWDriver bSQLDriver
99890>>>>>        Handle hoCLI hoDriver
99890>>>>>        Integer iRetval
99890>>>>>        tSQLConnection SQLConnection
99890>>>>>        tSQLConnection SQLConnection
99890>>>>>        
99890>>>>>        Get psDriverID to sDriverID
99891>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
99892>>>>>        If (bSQLDriver = False) Begin
99894>>>>>            Function_Return True
99895>>>>>        End                     
99895>>>>>>
99895>>>>>        
99895>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
99896>>>>>        Move SQLConnection.sDriverID                  to sDriverID
99897>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
99898>>>>>        Get IsDAWSQLDriver sDriverID to bOK
99899>>>>>        If (bOK = True) Begin
99901>>>>>//            Get SQLLogin of ghoSQLConnectionHandler SQLConnection to bOK
99901>>>>>        End
99901>>>>>>
99901>>>>>        If (bOK = False) Begin
99903>>>>>            Get _MertechSQLManagerHandle to hoCLI
99904>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
99905>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
99906>>>>>            If (SQLConnection.sDriverID <> DATAFLEX_ID) Begin
99908>>>>>                Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
99909>>>>>                Send Destroy of hoDriver
99910>>>>>            End
99910>>>>>>
99910>>>>>            Function_Return False
99911>>>>>        End
99911>>>>>>
99911>>>>>
99911>>>>>        Move SQLConnection.sConnectionID to sConnectionID
99912>>>>>
99912>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
99913>>>>>        If (bExists = False) Begin
99915>>>>>            // We always start by deleting the current connection - if any - because the
99915>>>>>            // login details my have changed.
99915>>>>>            Get phoCLIHandler to hoCLI
99916>>>>>            Set psDriverID    of hoCLI to sDriverID
99917>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
99918>>>>>            Get UtilCreateConnectionID sConnectionID to bOk
99919>>>>>            If (bOk = False) Begin
99921>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
99922>>>>>>
99922>>>>>                Function_Return False
99923>>>>>            End
99923>>>>>>
99923>>>>>            Move bOK to bExists
99924>>>>>        End
99924>>>>>>
99924>>>>>
99924>>>>>        Function_Return (bExists = True)
99925>>>>>    End_Function
99926>>>>>
99926>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
99926>>>>>    // Returns: False if nobody else is running
99926>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
99926>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
99926>>>>>    //      tables are not locked as DataFlex tables are.
99926>>>>>    Function IsDatabaseInUse Returns Boolean
99928>>>>>        Handle  hTable
99928>>>>>        Integer iTemp
99928>>>>>        String  sRootName sOrgOpenPath sOrgFileList
99928>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
99928>>>>>
99928>>>>>        Get AutoConnectionIDLogin to bOK
99929>>>>>        Move 0 to hTable
99930>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99933>>>>>        Move False to bErr
99934>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
99935>>>>>
99935>>>>>        Repeat
99935>>>>>>
99935>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
99938>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
99939>>>>>
99939>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
99939>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
99940>>>>>            Move False to bOpen
99941>>>>>
99941>>>>>            // Don't bother about FlexErrs (Normally table 50)
99941>>>>>            If (bIsSQLTable = False and hTable <> 0 and bFlexErrs = False) Begin
99943>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
99944>>>>>                Open hTable
99946>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
99949>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
99950>>>>>                If (bOpen = True) Begin
99952>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
99952>>>>>                    Get UtilTableIsAlias hTable to bAlias
99953>>>>>                    If (bAlias = False) Begin 
99955>>>>>                        Close hTable
99956>>>>>                        Get OpenTableExclusive hTable to bOpen
99957>>>>>                        If (bOpen = False) Begin
99959>>>>>                            Move True to bErr
99960>>>>>                        End
99960>>>>>>
99960>>>>>                    End
99960>>>>>>
99960>>>>>                End 
99960>>>>>>
99960>>>>>                Close hTable
99961>>>>>            End
99961>>>>>>
99961>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
99964>>>>>            If (bErr = True ) Break
99967>>>>>        Until (not(hTable))
99969>>>>>
99969>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
99970>>>>>        Move False to Err
99971>>>>>
99971>>>>>        Function_Return bErr
99972>>>>>    End_Function
99973>>>>>
99973>>>>>    // Checks if the passed connection id exists in the CLI interface.
99973>>>>>    // This might be needed by API-methods when a connection id is to be used and
99973>>>>>    // the connection id hasn't been established with the driver's CLI interface.
99973>>>>>    // NOTE: Only applicable for DAW drivers.
99973>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
99975>>>>>        String sID sConnString
99975>>>>>        Integer iDriver iNumConn iCount
99975>>>>>        Handle hoCLI
99975>>>>>        Boolean bOK
99975>>>>>
99975>>>>>        Get IsDAWSQLDriver sDriverID to bOK
99976>>>>>        If (bOK = False) Begin
99978>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
99979>>>>>>
99979>>>>>            Function_Return False
99980>>>>>        End
99980>>>>>>
99980>>>>>
99980>>>>>        Move False to bOK
99981>>>>>        Get phoCLIHandler to hoCLI
99982>>>>>        If (hoCLI <> 0) Begin
99984>>>>>            Set psDriverID of hoCLI to sDriverID
99985>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
99986>>>>>
99986>>>>>            // If driver not loaded; load it.
99986>>>>>            If (iDriver = 0) Begin
99988>>>>>                Load_Driver sDriverID
99989>>>>>                Get DriverIndex sDriverID to iDriver
99990>>>>>            End
99990>>>>>>
99990>>>>>            If (iDriver <> 0) Begin
99992>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
99995>>>>>                Decrement iNumConn
99996>>>>>                for iCount from 0 to iNumConn
100002>>>>>>
100002>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
100005>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
100008>>>>>                    If (sID = sConnectionID) Move True to bOK
100011>>>>>                Loop
100012>>>>>>
100012>>>>>            End
100012>>>>>>
100012>>>>>        End
100012>>>>>>
100012>>>>>
100012>>>>>        Function_Return bOK
100013>>>>>    End_Function
100014>>>>>
100014>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
100016>>>>>        Boolean bOK
100016>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
100017>>>>>        Function_Return bOK
100018>>>>>    End_Function
100019>>>>>
100019>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
100021>>>>>        Boolean bOK
100021>>>>>        Move False to bOK
100022>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
100023>>>>>        Function_Return bOK
100024>>>>>    End_Function
100025>>>>>
100025>>>>>    Function IsMSSQLDriver Returns Boolean
100027>>>>>        Handle ho
100027>>>>>        Integer iDriverIndex
100027>>>>>
100027>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
100028>>>>>
100028>>>>>        Function_Return (iDriverIndex <> 0)
100029>>>>>    End_Function
100030>>>>>
100030>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
100030>>>>>    // attempt to load the driver.
100030>>>>>    // Returns true if the passed driver is SQL based.
100030>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
100032>>>>>        Boolean bOK
100032>>>>>        Integer iDriver
100032>>>>>
100032>>>>>        Get IsDAWSQLDriver sDriverID to bOK
100033>>>>>
100033>>>>>        If (bOK = False) Begin
100035>>>>>            Get IsMertechDriver sDriverID to bOK
100036>>>>>        End
100036>>>>>>
100036>>>>>
100036>>>>>        Function_Return bOK
100037>>>>>    End_Function
100038>>>>>
100038>>>>>    // *** Error Handler ***
100038>>>>>    //
100038>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
100038>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
100038>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
100040>>>>>        String sText
100040>>>>>        Integer iSize iErrorMode
100040>>>>>        tSqlErrorArray aSqlErrorArray
100040>>>>>        tSqlErrorArray aSqlErrorArray
100040>>>>>
100040>>>>>        If (pbProcessingError(Self)) Begin
100042>>>>>            Procedure_Return
100043>>>>>        End
100043>>>>>>
100043>>>>>
100043>>>>>        Get Error_Report_Mode to iErrorMode
100044>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
100046>>>>>            Procedure_Return
100047>>>>>        End
100047>>>>>>
100047>>>>>
100047>>>>>        Set pbProcessingError to True
100048>>>>>        Set pbSqlError to True
100049>>>>>        Get paSqlErrorArray      to aSqlErrorArray
100050>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
100051>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
100052>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
100053>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
100054>>>>>        Set paSqlErrorArray      to aSqlErrorArray
100055>>>>>        Set pbProcessingError to False
100056>>>>>    End_Procedure
100057>>>>>
100057>>>>>    // *** Miscellanous Helper Functions ***
100057>>>>>    //
100057>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
100057>>>>>    // returns the table name only; stripped of any path or filename extension.
100057>>>>>    Function _TableNameOnly String sName Returns String
100059>>>>>        String sPath sExt
100059>>>>>
100059>>>>>        Get ParseFolderName sName to sPath
100060>>>>>        If (sPath <> "") Begin
100062>>>>>            Move (Replace(sPath, sName, "")) to sName
100063>>>>>        End
100063>>>>>>
100063>>>>>        Get ParseFileExtension sName to sExt
100064>>>>>        If (sExt <> "") Begin
100066>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
100067>>>>>        End
100067>>>>>>
100067>>>>>
100067>>>>>        Function_Return sName
100068>>>>>    End_Function
100069>>>>>
100069>>>>>    // Returns the first datapath found in the psDataPath property.
100069>>>>>    // The returned path always ends with a "\"
100069>>>>>    Function psDataPathFirstPart Returns String
100071>>>>>        String sDataPath
100071>>>>>        Integer iCount
100071>>>>>
100071>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
100072>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
100073>>>>>        If (iCount > 1) Begin
100075>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
100076>>>>>        End
100076>>>>>>
100076>>>>>        If (sDataPath <> "") Begin
100078>>>>>            Get vFolderFormat sDataPath to sDataPath
100079>>>>>        End
100079>>>>>>
100079>>>>>
100079>>>>>        Function_Return sDataPath
100080>>>>>    End_Function
100081>>>>>
100081>>>>>    // *** Property Messages ***
100081>>>>>    //
100081>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
100081>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
100081>>>>>    //
100081>>>>>
100081>>>>>    Function pSQLConnection Returns tSQLConnection
100083>>>>>        tSQLConnection SQLConnection
100083>>>>>        tSQLConnection SQLConnection
100083>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100085>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
100085>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100086>>>>>>
100086>>>>>            Function_Return
100087>>>>>        End
100087>>>>>>
100087>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
100088>>>>>        Function_Return SQLConnection
100089>>>>>    End_Function
100090>>>>>
100090>>>>>    Procedure Set psServer String sValue
100092>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100094>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
100094>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100095>>>>>>
100095>>>>>            Procedure_Return
100096>>>>>        End
100096>>>>>>
100096>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
100097>>>>>    End_Procedure
100098>>>>>
100098>>>>>    Function psServer Returns String
100100>>>>>        String sValue
100100>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100102>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100103>>>>>>
100103>>>>>            Function_Return
100104>>>>>        End
100104>>>>>>
100104>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
100105>>>>>        Function_Return sValue
100106>>>>>    End_Function
100107>>>>>
100107>>>>>    Procedure Set psDatabase String sValue
100109>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100111>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100112>>>>>>
100112>>>>>            Procedure_Return
100113>>>>>        End
100113>>>>>>
100113>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
100114>>>>>    End_Procedure
100115>>>>>
100115>>>>>    Function psDatabase Returns String
100117>>>>>        String sValue
100117>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100119>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100120>>>>>>
100120>>>>>            Function_Return
100121>>>>>        End
100121>>>>>>
100121>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
100122>>>>>        Function_Return sValue
100123>>>>>    End_Function
100124>>>>>
100124>>>>>    Procedure Set psUserID String sValue
100126>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100128>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100129>>>>>>
100129>>>>>            Function_Return
100130>>>>>        End
100130>>>>>>
100130>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
100131>>>>>    End_Procedure
100132>>>>>
100132>>>>>    Function psUserID Returns String
100134>>>>>        String sValue
100134>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100136>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100137>>>>>>
100137>>>>>            Function_Return
100138>>>>>        End
100138>>>>>>
100138>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
100139>>>>>        Function_Return sValue
100140>>>>>    End_Function
100141>>>>>
100141>>>>>    Procedure Set psPassword String sValue
100143>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100145>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100146>>>>>>
100146>>>>>            Procedure_Return
100147>>>>>        End
100147>>>>>>
100147>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
100148>>>>>    End_Procedure
100149>>>>>
100149>>>>>    Function psPassword Returns String
100151>>>>>        String sValue
100151>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100153>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100154>>>>>>
100154>>>>>            Function_Return
100155>>>>>        End
100155>>>>>>
100155>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
100156>>>>>        Function_Return sValue
100157>>>>>    End_Function
100158>>>>>
100158>>>>>    Procedure Set pbTrusted Boolean bValue
100160>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100162>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100163>>>>>>
100163>>>>>            Procedure_Return
100164>>>>>        End
100164>>>>>>
100164>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
100165>>>>>    End_Procedure
100166>>>>>
100166>>>>>    Function pbTrusted Returns Boolean
100168>>>>>        Boolean bValue
100168>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100170>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100171>>>>>>
100171>>>>>            Function_Return
100172>>>>>        End
100172>>>>>>
100172>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
100173>>>>>        Function_Return bValue
100174>>>>>    End_Function
100175>>>>>
100175>>>>>    Procedure Set pbSilentLogin Boolean bValue
100177>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100179>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100180>>>>>>
100180>>>>>            Procedure_Return
100181>>>>>        End
100181>>>>>>
100181>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
100182>>>>>    End_Procedure
100183>>>>>
100183>>>>>    Function pbSilentLogin Returns Boolean
100185>>>>>        Boolean bValue
100185>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100187>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100188>>>>>>
100188>>>>>            Function_Return
100189>>>>>        End
100189>>>>>>
100189>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
100190>>>>>        Function_Return bValue
100191>>>>>    End_Function
100192>>>>>
100192>>>>>    Procedure Set psConnectionID String sValue
100194>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100196>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100197>>>>>>
100197>>>>>            Procedure_Return
100198>>>>>        End
100198>>>>>>
100198>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
100199>>>>>    End_Procedure
100200>>>>>
100200>>>>>    Function psConnectionID Returns String
100202>>>>>        String sValue
100202>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100204>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100205>>>>>>
100205>>>>>            Function_Return
100206>>>>>        End
100206>>>>>>
100206>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
100207>>>>>        Function_Return sValue
100208>>>>>    End_Function
100209>>>>>
100209>>>>>    Procedure Set psConnectionString String sValue
100211>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100213>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100214>>>>>>
100214>>>>>            Procedure_Return
100215>>>>>        End
100215>>>>>>
100215>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
100216>>>>>    End_Procedure
100217>>>>>
100217>>>>>    Function psConnectionString Returns String
100219>>>>>        String sValue
100219>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100221>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100222>>>>>>
100222>>>>>            Function_Return
100223>>>>>        End
100223>>>>>>
100223>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
100224>>>>>        Function_Return sValue
100225>>>>>    End_Function
100226>>>>>
100226>>>>>    // The normal connection string looks something like this;
100226>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
100226>>>>>    // ...and the full connection string looks like this;
100226>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
100226>>>>>    Function psFullConnectionString Returns String
100228>>>>>        String sConnectionID sConnectionString
100228>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100230>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100231>>>>>>
100231>>>>>            Function_Return
100232>>>>>        End
100232>>>>>>
100232>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
100233>>>>>        Move (Trim(sConnectionID)) to sConnectionID
100234>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
100235>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
100236>>>>>    End_Function
100237>>>>>
100237>>>>>    Function piConnectionOptions Returns Integer
100239>>>>>        Integer iValue
100239>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100241>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100242>>>>>>
100242>>>>>            Function_Return
100243>>>>>        End
100243>>>>>>
100243>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
100244>>>>>        Function_Return iValue
100245>>>>>    End_Function
100246>>>>>
100246>>>>>    Procedure Set psSchema String sValue
100248>>>>>        tSQLConnection SQLConnection
100248>>>>>        tSQLConnection SQLConnection
100248>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100250>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100251>>>>>>
100251>>>>>            Procedure_Return
100252>>>>>        End
100252>>>>>>
100252>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
100253>>>>>    End_Procedure
100254>>>>>
100254>>>>>    Function psSchema Returns String
100256>>>>>        String sRetval
100256>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100258>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100259>>>>>>
100259>>>>>            Function_Return
100260>>>>>        End
100260>>>>>>
100260>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
100261>>>>>        Function_Return sRetval
100262>>>>>    End_Function
100263>>>>>
100263>>>>>    Procedure Set psBaseTableSpace String sValue
100265>>>>>        String sRetval
100265>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100267>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100268>>>>>>
100268>>>>>            Procedure_Return
100269>>>>>        End
100269>>>>>>
100269>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
100270>>>>>    End_Procedure
100271>>>>>
100271>>>>>    Function psBaseTableSpace Returns String
100273>>>>>        String sRetval
100273>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100275>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100276>>>>>>
100276>>>>>            Function_Return
100277>>>>>        End
100277>>>>>>
100277>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
100278>>>>>        Function_Return sRetval
100279>>>>>    End_Function
100280>>>>>
100280>>>>>    Procedure Set psLongTableSpace String sValue
100282>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100284>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100285>>>>>>
100285>>>>>            Procedure_Return
100286>>>>>        End
100286>>>>>>
100286>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
100287>>>>>    End_Procedure
100288>>>>>
100288>>>>>    Function psLongTableSpace Returns String
100290>>>>>        String sRetval
100290>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100292>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100293>>>>>>
100293>>>>>            Function_Return
100294>>>>>        End
100294>>>>>>
100294>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
100295>>>>>        Function_Return sRetval
100296>>>>>    End_Function
100297>>>>>
100297>>>>>    Procedure Set psIndexTableSpace String sValue
100299>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100301>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100302>>>>>>
100302>>>>>            Procedure_Return
100303>>>>>        End
100303>>>>>>
100303>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
100304>>>>>    End_Procedure
100305>>>>>
100305>>>>>    Function psIndexTableSpace Returns String
100307>>>>>        String sRetval
100307>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100309>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100310>>>>>>
100310>>>>>            Function_Return
100311>>>>>        End
100311>>>>>>
100311>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
100312>>>>>        Function_Return sRetval
100313>>>>>    End_Function
100314>>>>>
100314>>>>>    Procedure Set pbUseConnectionID Boolean bState
100316>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100318>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100319>>>>>>
100319>>>>>            Procedure_Return
100320>>>>>        End
100320>>>>>>
100320>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
100321>>>>>    End_Procedure
100322>>>>>
100322>>>>>    Function pbUseConnectionID Returns Boolean
100324>>>>>        Boolean bState
100324>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100326>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100327>>>>>>
100327>>>>>            Function_Return
100328>>>>>        End
100328>>>>>>
100328>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
100329>>>>>        Function_Return bState
100330>>>>>    End_Function
100331>>>>>
100331>>>>>    Procedure Set pbToANSI Boolean bState
100333>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100335>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100336>>>>>>
100336>>>>>            Procedure_Return
100337>>>>>        End
100337>>>>>>
100337>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
100338>>>>>    End_Procedure
100339>>>>>
100339>>>>>    Function pbToANSI Returns Boolean
100341>>>>>        Boolean bState
100341>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100343>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100344>>>>>>
100344>>>>>            Function_Return
100345>>>>>        End
100345>>>>>>
100345>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
100346>>>>>        Function_Return bState
100347>>>>>    End_Function
100348>>>>>
100348>>>>>    Procedure Set pbRecnum Boolean bState
100350>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100352>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100353>>>>>>
100353>>>>>            Procedure_Return
100354>>>>>        End
100354>>>>>>
100354>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
100355>>>>>    End_Procedure
100356>>>>>
100356>>>>>    Function pbRecnum Returns Boolean
100358>>>>>        Boolean bState
100358>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100360>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100361>>>>>>
100361>>>>>            Function_Return
100362>>>>>        End
100362>>>>>>
100362>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
100363>>>>>        Function_Return bState
100364>>>>>    End_Function
100365>>>>>
100365>>>>>    Procedure Set pbCopyData Boolean bState
100367>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100369>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100370>>>>>>
100370>>>>>            Procedure_Return
100371>>>>>        End
100371>>>>>>
100371>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
100372>>>>>    End_Procedure
100373>>>>>
100373>>>>>    Function pbCopyData Returns Boolean
100375>>>>>        Boolean bState
100375>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100377>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100378>>>>>>
100378>>>>>            Function_Return
100379>>>>>        End
100379>>>>>>
100379>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
100380>>>>>        Function_Return bState
100381>>>>>    End_Function
100382>>>>>
100382>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
100384>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100386>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100387>>>>>>
100387>>>>>            Procedure_Return
100388>>>>>        End
100388>>>>>>
100388>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
100389>>>>>    End_Procedure
100390>>>>>
100390>>>>>    Function pbCompareDate_DateTime Returns Boolean
100392>>>>>        Boolean bState
100392>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100394>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100395>>>>>>
100395>>>>>            Function_Return
100396>>>>>        End
100396>>>>>>
100396>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
100397>>>>>        Function_Return bState
100398>>>>>    End_Function
100399>>>>>
100399>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
100401>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100403>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100404>>>>>>
100404>>>>>            Procedure_Return
100405>>>>>        End
100405>>>>>>
100405>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
100406>>>>>    End_Procedure
100407>>>>>
100407>>>>>    Function pbCompareIndexAscending Returns Boolean
100409>>>>>        Boolean bState
100409>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100411>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100412>>>>>>
100412>>>>>            Function_Return
100413>>>>>        End
100413>>>>>>
100413>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
100414>>>>>        Function_Return bState
100415>>>>>    End_Function
100416>>>>>
100416>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
100418>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100420>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100421>>>>>>
100421>>>>>            Procedure_Return
100422>>>>>        End
100422>>>>>>
100422>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
100423>>>>>    End_Procedure
100424>>>>>
100424>>>>>    Function pbCompareIndexUppercase Returns Boolean
100426>>>>>        Boolean bState
100426>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100428>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100429>>>>>>
100429>>>>>            Function_Return
100430>>>>>        End
100430>>>>>>
100430>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
100431>>>>>        Function_Return bState
100432>>>>>    End_Function
100433>>>>>
100433>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
100435>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100437>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100438>>>>>>
100438>>>>>            Procedure_Return
100439>>>>>        End
100439>>>>>>
100439>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
100440>>>>>    End_Procedure
100441>>>>>
100441>>>>>    Function psDriverDefaultValueASCII Returns String
100443>>>>>        String sRetval
100443>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100445>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100446>>>>>>
100446>>>>>            Function_Return
100447>>>>>        End
100447>>>>>>
100447>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
100448>>>>>        Function_Return sRetval
100449>>>>>    End_Function
100450>>>>>
100450>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
100452>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100454>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100455>>>>>>
100455>>>>>            Procedure_Return
100456>>>>>        End
100456>>>>>>
100456>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
100457>>>>>    End_Procedure
100458>>>>>
100458>>>>>    Function psDriverDefaultValueBinary Returns String
100460>>>>>        String sRetval
100460>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100462>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100463>>>>>>
100463>>>>>            Function_Return
100464>>>>>        End
100464>>>>>>
100464>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
100465>>>>>        Function_Return sRetval
100466>>>>>    End_Function
100467>>>>>
100467>>>>>    Procedure Set psDriverDefaultValueDate String sValue
100469>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100471>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100472>>>>>>
100472>>>>>            Procedure_Return
100473>>>>>        End
100473>>>>>>
100473>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
100474>>>>>    End_Procedure
100475>>>>>
100475>>>>>    Function psDriverDefaultValueDate Returns String
100477>>>>>        String sRetval
100477>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100479>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100480>>>>>>
100480>>>>>            Function_Return
100481>>>>>        End
100481>>>>>>
100481>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
100482>>>>>        Function_Return sRetval
100483>>>>>    End_Function
100484>>>>>
100484>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
100486>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100488>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100489>>>>>>
100489>>>>>            Procedure_Return
100490>>>>>        End
100490>>>>>>
100490>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
100491>>>>>    End_Procedure
100492>>>>>
100492>>>>>    Function psDriverDefaultValueDateTime Returns String
100494>>>>>        String sRetval
100494>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100496>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100497>>>>>>
100497>>>>>            Function_Return
100498>>>>>        End
100498>>>>>>
100498>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
100499>>>>>        Function_Return sRetval
100500>>>>>    End_Function
100501>>>>>
100501>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
100503>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100505>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100506>>>>>>
100506>>>>>            Procedure_Return
100507>>>>>        End
100507>>>>>>
100507>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
100508>>>>>    End_Procedure
100509>>>>>
100509>>>>>    Function psDriverDefaultValueNumeric Returns String
100511>>>>>        String sRetval
100511>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100513>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100514>>>>>>
100514>>>>>            Function_Return
100515>>>>>        End
100515>>>>>>
100515>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
100516>>>>>        Function_Return sRetval
100517>>>>>    End_Function
100518>>>>>
100518>>>>>    Procedure Set psDriverDefaultValueText String sValue
100520>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100522>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100523>>>>>>
100523>>>>>            Procedure_Return
100524>>>>>        End
100524>>>>>>
100524>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
100525>>>>>    End_Procedure
100526>>>>>
100526>>>>>    Function psDriverDefaultValueText Returns String
100528>>>>>        String sRetval
100528>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100530>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100531>>>>>>
100531>>>>>            Function_Return
100532>>>>>        End
100532>>>>>>
100532>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
100533>>>>>        Function_Return sRetval
100534>>>>>    End_Function
100535>>>>>
100535>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
100537>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100539>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100540>>>>>>
100540>>>>>            Procedure_Return
100541>>>>>        End
100541>>>>>>
100541>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
100542>>>>>    End_Procedure
100543>>>>>
100543>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
100545>>>>>        Boolean bState
100545>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100547>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100548>>>>>>
100548>>>>>            Function_Return
100549>>>>>        End
100549>>>>>>
100549>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
100550>>>>>        Function_Return bState
100551>>>>>    End_Function
100552>>>>>
100552>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
100554>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100556>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100557>>>>>>
100557>>>>>            Procedure_Return
100558>>>>>        End
100558>>>>>>
100558>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
100559>>>>>    End_Procedure
100560>>>>>
100560>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
100562>>>>>        Boolean bState
100562>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100564>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100565>>>>>>
100565>>>>>            Function_Return
100566>>>>>        End
100566>>>>>>
100566>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
100567>>>>>        Function_Return bState
100568>>>>>    End_Function
100569>>>>>
100569>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
100571>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100573>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100574>>>>>>
100574>>>>>            Procedure_Return
100575>>>>>        End
100575>>>>>>
100575>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
100576>>>>>    End_Procedure
100577>>>>>
100577>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
100579>>>>>        Boolean bState
100579>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100581>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100582>>>>>>
100582>>>>>            Function_Return
100583>>>>>        End
100583>>>>>>
100583>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
100584>>>>>        Function_Return bState
100585>>>>>    End_Function
100586>>>>>
100586>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
100588>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100590>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100591>>>>>>
100591>>>>>            Procedure_Return
100592>>>>>        End
100592>>>>>>
100592>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
100593>>>>>    End_Procedure
100594>>>>>
100594>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
100596>>>>>        Boolean bState
100596>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100598>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100599>>>>>>
100599>>>>>            Function_Return
100600>>>>>        End
100600>>>>>>
100600>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
100601>>>>>        Function_Return bState
100602>>>>>    End_Function
100603>>>>>
100603>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
100605>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100607>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100608>>>>>>
100608>>>>>            Procedure_Return
100609>>>>>        End
100609>>>>>>
100609>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
100610>>>>>    End_Procedure
100611>>>>>
100611>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
100613>>>>>        Boolean bState
100613>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100615>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100616>>>>>>
100616>>>>>            Function_Return
100617>>>>>        End
100617>>>>>>
100617>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
100618>>>>>        Function_Return bState
100619>>>>>    End_Function
100620>>>>>
100620>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
100622>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100624>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100625>>>>>>
100625>>>>>            Procedure_Return
100626>>>>>        End
100626>>>>>>
100626>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
100627>>>>>    End_Procedure
100628>>>>>
100628>>>>>    Function pbDriverDefaultNullableText Returns Boolean
100630>>>>>        Boolean bState
100630>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100632>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
100633>>>>>>
100633>>>>>            Function_Return
100634>>>>>        End
100634>>>>>>
100634>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
100635>>>>>        Function_Return bState
100636>>>>>    End_Function
100637>>>>>
100637>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
100637>>>>>    //       the psDriverID *must* be the first property that gets changed!
100637>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
100637>>>>>    //       for a connection string has the wrong format for that driver.
100637>>>>>    Procedure Set psDriverID String sValue
100639>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
100640>>>>>        Delegate Set psDriverID to sValue
100642>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
100643>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
100644>>>>>    End_Procedure
100645>>>>>
100645>>>>>    Function psDriverID Returns String
100647>>>>>        String sDriverID
100647>>>>>
100647>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
100648>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
100648>>>>>        Delegate Get psDriverID to sDriverID
100650>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
100651>>>>>        Move False to Err
100652>>>>>
100652>>>>>        // ...and in case it didn't use property of this class. Then the library is
100652>>>>>        // probably used as "utilites" from a special made program and
100652>>>>>        // the ghoSQLConnectionHandler must have been setup
100652>>>>>        If (sDriverID = "") Begin
100654>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
100655>>>>>        End
100655>>>>>>
100655>>>>>        Function_Return sDriverID
100656>>>>>    End_Function
100657>>>>>
100657>>>>>    Procedure Set piDbType Integer iValue
100659>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
100660>>>>>        Delegate Set piDbType to iValue
100662>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
100663>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
100664>>>>>    End_Procedure
100665>>>>>
100665>>>>>    Function piDbType Returns String
100667>>>>>        Integer iRetval
100667>>>>>
100667>>>>>//        Move False to Err
100667>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
100667>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
100667>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
100667>>>>>//        Delegate Get piDbType to iRetval
100667>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
100667>>>>>//        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
100667>>>>>
100667>>>>>        // ...and in case it didn't use property of this class. Then the library is
100667>>>>>        // probably used as "utilites" from a special made program and
100667>>>>>        // the ghoSQLConnectionHandler must have been setup
100667>>>>>//        If (Err = True) Begin
100667>>>>>            Get piDbType of ghoSQLConnectionHandler to iRetval
100668>>>>>//        End
100668>>>>>
100668>>>>>//        Move False to Err
100668>>>>>        Function_Return iRetval
100669>>>>>    End_Function  
100670>>>>>    
100670>>>>>    Function phoLogFile Returns Handle
100672>>>>>        Handle hoLogFile
100672>>>>>        
100672>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
100673>>>>>        Delegate Get phoLogFile to hoLogFile
100675>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
100676>>>>>
100676>>>>>        Function_Return hoLogFile
100677>>>>>    End_Function
100678>>>>>
100678>>>>>    Function pnCurrentVersionUpdate Returns Number
100680>>>>>        Number nCurrentVersionUpdate
100680>>>>>
100680>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
100681>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
100683>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
100684>>>>>
100684>>>>>        Function_Return nCurrentVersionUpdate
100685>>>>>    End_Function
100686>>>>>    
100686>>>>>    Procedure LogError String sText Boolean bError
100688>>>>>        Handle hoLogFile 
100688>>>>>        Number nCurrentVersionUpdate
100688>>>>>        
100688>>>>>        Get phoLogFile to hoLogFile
100689>>>>>        If (hoLogFile = 0) Begin
100691>>>>>            Procedure_Return
100692>>>>>        End 
100692>>>>>>
100692>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
100693>>>>>        
100693>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
100694>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
100695>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
100696>>>>>    End_Procedure        
100697>>>>>    
100697>>>>>    Function pbContinueOnError Returns Boolean
100699>>>>>        Boolean bContinueOnError
100699>>>>>        If (ghoDbUpdateHandler > 0) Begin
100701>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
100702>>>>>        End
100702>>>>>>
100702>>>>>        Function_Return bContinueOnError
100703>>>>>    End_Function
100704>>>>>
100704>>>>>    // Messages not available in pre DF18 versions:
100704>>>>>
100704>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer 
100706>>>>>        Integer iMax iPos 
100706>>>>>        String sName 
100706>>>>>        
100706>>>>>        Move (Lowercase(sField)) to sField
100707>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax 
100710>>>>>        for iPos from 0 to iMax 
100716>>>>>>
100716>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName 
100719>>>>>            Move (Lowercase(sName)) to sName 
100720>>>>>            If (sName = sField) Begin
100722>>>>>                Function_Return iPos 
100723>>>>>            End
100723>>>>>>
100723>>>>>        Loop
100724>>>>>>
100724>>>>>        Function_Return -1 
100725>>>>>    End_Function
100726>>>>>
100726>>>>>
100726>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
100726>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
100726>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
100726>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
100726>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
100726>>>>>    //   ALTER TABLE MyTable
100726>>>>>    //       REBUILD
100726>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
100728>>>>>        Boolean bOK
100728>>>>>
100728>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
100730>>>>>            Function_Return False
100731>>>>>        End
100731>>>>>>
100731>>>>>
100731>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
100731>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
100732>>>>>
100732>>>>>        Function_Return (bOK = True)
100733>>>>>    End_Function
100734>>>>>
100734>>>>>
100734>>>>>    // *** Helper functions with compiled sql script code ***
100734>>>>>    //
100734>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
100734>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
100734>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
100734>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
100734>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
100734>>>>>    //   ALTER TABLE MyTable
100734>>>>>    //       REBUILD
100734>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
100736>>>>>        tSQLScriptArray SQLScriptArray
100736>>>>>        tSQLScriptArray SQLScriptArray
100736>>>>>        String sDriverID sVal
100736>>>>>        Boolean bOK
100736>>>>>        Integer iSize iCount
100736>>>>>
100736>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
100738>>>>>            Function_Return False
100739>>>>>        End
100739>>>>>>
100739>>>>>
100739>>>>>        Get psDriverID to sDriverID
100740>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
100741>>>>>        If (SQLScriptArray.bError = True) Begin
100743>>>>>            Function_Return False
100744>>>>>        End
100744>>>>>>
100744>>>>>
100744>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
100745>>>>>        Decrement iSize
100746>>>>>
100746>>>>>        for iCount from 0 to iSize
100752>>>>>>
100752>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
100754>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
100755>>>>>            End
100755>>>>>>
100755>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
100757>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
100758>>>>>            End
100758>>>>>>
100758>>>>>        Loop
100759>>>>>>
100759>>>>>
100759>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
100760>>>>>
100760>>>>>        Function_Return (bOK = True)
100761>>>>>    End_Function
100762>>>>>
100762>>>>>    // *** Helper functions for Mertech Drivers ***
100762>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
100762>>>>>    // and commands that the Studio editor knows nothing about.
100762>>>>>    Function _MertechDeleteTDFile String sTableName Returns Integer
100764>>>>>        Integer iRetval
100764>>>>>        String sPath
100764>>>>>
100764>>>>>            SQL_GET_LOCAL_TD_PATH to sPath
100778>>>>>>
100778>>>>>        If (sPath = "" or sTableName = "") Begin
100780>>>>>            Function_Return 0
100781>>>>>        End
100781>>>>>>
100781>>>>>
100781>>>>>        Get vFolderFormat sPath to sPath
100782>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
100783>>>>>        Function_Return iRetval
100784>>>>>    End_Function
100785>>>>>
100785>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sDataPath String sPhysicalFileName Returns Boolean
100787>>>>>        Move False to Err
100788>>>>>            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to False
100791>>>>>            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to False
100794>>>>>            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to False
100797>>>>>            OUTPUT_INT_FILE for hTable to (sDataPath + sPhysicalFileName)
100818>>>>>>
100818>>>>>        Function_Return (Err = False)
100819>>>>>    End_Function
100820>>>>>
100820>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
100822>>>>>        Integer iNumItems iCount
100822>>>>>        String[] sReturnArray
100823>>>>>        String sServer
100823>>>>>
100823>>>>>        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
100824>>>>>        For iCount from 1 to iNumItems
100830>>>>>>
100830>>>>>            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
100831>>>>>            Move sServer to sReturnArray[iCount -1]
100832>>>>>        Loop
100833>>>>>>
100833>>>>>
100833>>>>>        Function_Return sReturnArray
100834>>>>>    End_Function
100835>>>>>
100835>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
100837>>>>>        String[] sReturnArray
100838>>>>>        String sServer
100838>>>>>
100838>>>>>        GET_CURRENT_SQL_SERVER to sServer
100858>>>>>>
100858>>>>>        Move sServer to sReturnArray[0]
100859>>>>>
100859>>>>>        Function_Return sReturnArray
100860>>>>>    End_Function
100861>>>>>
100861>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
100863>>>>>        Handle hoSQLHandler hoSQLConnect
100863>>>>>
100863>>>>>        Move 0 to hoSQLConnect
100864>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
100865>>>>>            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
100866>>>>>
100866>>>>>        Function_Return hoSQLConnect
100867>>>>>    End_Function
100868>>>>>
100868>>>>>    // Returns the handle of the Mertech SQL handler.
100868>>>>>    // It also ensures that the correct Server & Database attributes are set both for
100868>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
100868>>>>>    Function _MertechSQLManagerHandle Returns Handle
100870>>>>>        Handle hoSQLHandler
100870>>>>>        String sDriverID sServer sDatabase
100870>>>>>
100870>>>>>        Move 0 to hoSQLHandler
100871>>>>>        Get psDriverID to sDriverID
100872>>>>>        Get psServer   to sServer
100873>>>>>        Get psDatabase to sDatabase
100874>>>>>        // This command is used to set the server to be used when opening tables
100874>>>>>        SET_CURRENT_SQL_SERVER            to sServer
100893>>>>>>
100893>>>>>        // This command is used to specify which server to use for embedded SQL statements,
100893>>>>>        // but it has been constructed rather studidly as only constants and not variables
100893>>>>>        // are allowed...
100893>>>>>        If (sDriverID = MDSPgSQL) Begin
100895>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
100911>>>>>        End
100911>>>>>>
100911>>>>>        If (sDriverID = MDSMySQL) Begin
100913>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
100929>>>>>        End
100929>>>>>>
100929>>>>>        If (sDriverID = ORAFLEX) Begin
100931>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
100947>>>>>        End
100947>>>>>>
100947>>>>>        If (sDriverID = SQLFLEX) Begin
100949>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
100965>>>>>        End
100965>>>>>>
100965>>>>>
100965>>>>>        // This command is used to specify which database is used for SQL statements only.
100965>>>>>        SQL_USE_DATABASE sDatabase
100979>>>>>>
100979>>>>>        SET_DATABASE_NAME to sDatabase
100993>>>>>>
100993>>>>>
100993>>>>>        Get phoSQLManagerMT to hoSQLHandler
100994>>>>>
100994>>>>>        Function_Return hoSQLHandler
100995>>>>>    End_Function
100996>>>>>
100996>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
100996>>>>>    // macro-commands <sigh!>
100996>>>>>    // Note: The function sets the Err flag.
100996>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bCopyData Returns Boolean
100998>>>>>        Move False to Err
100999>>>>>
100999>>>>>            MERTECH_WARNING_MESSAGE Disabled
101008>>>>>>
101008>>>>>            SET_DATABASE_NAME to sDatabase
101022>>>>>>
101022>>>>>            If (sBaseTableSpace <> "") Begin
101024>>>>>                SET_DEFAULT_TABLESPACE to sBaseTableSpace
101037>>>>>>
101037>>>>>            End
101037>>>>>>
101037>>>>>            If (sIndexTableSpace <> "") Begin
101039>>>>>                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
101052>>>>>>
101052>>>>>            End
101052>>>>>>
101052>>>>>            CREATE_TABLE_FROM_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_NOT_NULL sRootName
101074>>>>>>
101074>>>>>            If (bCopyData = True) Begin
101076>>>>>                COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
101091>>>>>>
101091>>>>>            End
101091>>>>>>
101091>>>>>
101091>>>>>        Function_Return (Err = False)
101092>>>>>    End_Function
101093>>>>>
101093>>>>>End_Class
101094>>>Use MSSqldrv.pkg
101094>>>Use db2_drv.pkg
101094>>>Use odbc_drv.pkg
101094>>>
101094>>>Object oDatabaseSelection_sl is a ModalPanel
101096>>>    Set Label to "SQL Database Selection"
101097>>>    Set Size to 121 183
101098>>>    Set piMinSize to 89 170
101099>>>    Set Location to 2 2
101100>>>    Set Border_Style to Border_Thick
101101>>>
101101>>>    Property String[] psTheData
101103>>>
101103>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
101105>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
101107>>>        End_Object
101108>>>    End
101108>>>>
101108>>>
101108>>>    Object oSelList is a cCJGridPromptList
101110>>>        Set Size to 89 167
101111>>>        Set Location to 6 6
101112>>>        Set peAnchors to anAll
101113>>>        Set pbAllowColumnRemove to False
101114>>>        Set pbUseAlternateRowBackgroundColor to True
101115>>>        Set pbGrayIfDisable to False
101116>>>        Set pbHeaderReorders to False
101117>>>        Set pbHeaderSelectsColumn to False
101118>>>        Set pbHeaderTogglesDirection to False
101119>>>        Set pbShadeSortColumn to False
101120>>>        Set piFocusCellBackColor to clDkGray
101121>>>
101121>>>        Object oName is a cCJGridColumn
101123>>>            Set piWidth to 334
101124>>>            Set psCaption to "Database Name"
101125>>>        End_Object
101126>>>
101126>>>        Procedure Activating
101129>>>            tDataSourceRow[] MyData
101129>>>            tDataSourceRow[] MyData
101130>>>            Handle hoDataSource
101130>>>            String[] sTheData
101131>>>            Integer iCount iSize
101131>>>
101131>>>            Send Cursor_Wait of Cursor_Control
101132>>>            Forward Send Activating
101134>>>
101134>>>            Get psTheData to sTheData
101135>>>            Move (SizeOfArray(sTheData)) to iSize
101136>>>            Decrement iSize
101137>>>            For iCount from 0 to iSize
101143>>>>
101143>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
101144>>>            Loop
101145>>>>
101145>>>
101145>>>            Get phoDataSource to hoDataSource
101146>>>            Send InitializeData of hoDataSource MyData
101147>>>            Send Cursor_Ready of Cursor_Control
101148>>>        End_Procedure
101149>>>
101149>>>    End_Object
101150>>>
101150>>>    Object oOK_Btn is a Button
101152>>>        Set Label    to "&OK"
101153>>>        Set Location to 100 68
101154>>>        Set peAnchors To anBottomRight
101155>>>
101155>>>        Procedure OnClick
101158>>>            Send Ok of oSelList
101159>>>        End_Procedure
101160>>>
101160>>>    End_Object
101161>>>
101161>>>    Object oCancel_Btn is a Button
101163>>>        Set Label    to "&Cancel"
101164>>>        Set Location to 100 123
101165>>>        Set peAnchors to anBottomRight
101166>>>
101166>>>        Procedure OnClick
101169>>>            Send Close_Panel
101170>>>        End_Procedure
101171>>>
101171>>>    End_Object
101172>>>
101172>>>    Procedure Page Integer iPageObject
101175>>>        Set Icon to "DatabaseLookup.ico"
101176>>>        Forward Send Page iPageObject
101178>>>    End_Procedure
101179>>>
101179>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
101180>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
101181>>>End_Object
101182>        Use SQLDatabaseBackup.dg
Including file: SQLDatabaseBackup.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLDatabaseBackup.dg)
101182>>>// Note: At the bottom of this package there's a general purpose access method for this dialog.
101182>>>Use Windows.pkg
101182>>>Use vWin32fh.pkg
101182>>>
101182>>>Object oSQLDatabaseBackup_dg is a ModalPanel
101184>>>    Set Size to 104 298
101185>>>    Set Label to "SQL Database Backup"
101186>>>    Set piMinSize to 89 211
101187>>>    Set Location to 2 4
101188>>>    Set Border_Style To Border_Thick
101189>>>
101189>>>    Property Boolean pbOK False
101191>>>    Property String  psDatabase
101193>>>    Property String  psPath
101195>>>    Property String  psBackupName
101197>>>
101197>>>    Object oDatabase_fm is a Form
101199>>>        Set Size to 13 204
101200>>>        Set Location to 14 71
101201>>>        Set Label_Justification_Mode to JMode_Right
101202>>>        Set Label_Col_Offset to 2
101203>>>        Set Label to "Database Name"
101204>>>        Set Enabled_State to False
101205>>>        Set peAnchors to anTopLeftRight
101206>>>
101206>>>        Procedure Page Integer iPageObject
101209>>>            String sValue
101209>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
101210>>>            Set Value to sValue
101211>>>            Set psDatabase to sValue
101212>>>            Forward Send Page iPageObject
101214>>>        End_Procedure
101215>>>
101215>>>    End_Object
101216>>>
101216>>>    Object oBackupName_fm is a Form
101218>>>        Set Size to 13 204
101219>>>        Set Location to 29 71
101220>>>        Set Label_Justification_Mode to JMode_Right
101221>>>        Set Label_Col_Offset to 2
101222>>>        Set Label to "Backup Name"
101223>>>        Set peAnchors to anTopLeftRight
101224>>>
101224>>>        Procedure Page Integer iPageObject
101227>>>            String sValue
101227>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sValue
101228>>>            Set Value to sValue
101229>>>            Forward Send Page iPageObject
101231>>>        End_Procedure
101232>>>
101232>>>        Procedure OnChange
101235>>>            String sValue
101235>>>            Get Value to sValue
101236>>>            Set psBackupName to sValue
101237>>>        End_Procedure
101238>>>
101238>>>    End_Object
101239>>>
101239>>>    Object oUseDefaultBackupFolder_cb is a CheckBox
101241>>>        Set Size to 10 50
101242>>>        Set Location to 50 71
101243>>>        Set Label to "Use Default SQL Backup Folder"
101244>>>        Set Checked_State to True
101245>>>
101245>>>        Procedure OnChange
101248>>>            Boolean bChecked
101248>>>            Get Checked_State to bChecked
101249>>>            Set Enabled_State of oPath_fm to (bChecked = False)
101250>>>        End_Procedure
101251>>>
101251>>>    End_Object
101252>>>
101252>>>    Object oPath_fm is a Form
101254>>>        Set Size to 13 204
101255>>>        Set Location to 62 71
101256>>>        Set Label_Justification_Mode to JMode_Right
101257>>>        Set Label_Col_Offset to 2
101258>>>        Set Label to "Path"
101259>>>        Set Prompt_Button_Mode to PB_PromptOn
101260>>>        Set peAnchors to anTopLeftRight
101261>>>        Set Enabled_State to False
101262>>>
101262>>>        Procedure Page Integer iPageObject
101265>>>            String sValue
101265>>>            Get psDataPathFirstPart of ghoDbUpdateFunctionLibrary to sValue
101266>>>            Get vFolderFormat sValue to sValue
101267>>>            Move (sValue + "Backup") to sValue
101268>>>            Set Value to sValue
101269>>>            Forward Send Page iPageObject
101271>>>        End_Procedure
101272>>>
101272>>>        Procedure Prompt
101275>>>            String sPath sFileMask sRetval
101275>>>
101275>>>            Get Value to sPath
101276>>>            Move "Database Backup files (*.bak)|*.bak" to sFileMask
101277>>>            Get vSelect_File sFileMask "Please select a .bak file" sPath to sRetval
101278>>>            If (sRetval <> "") Begin
101280>>>                Get ParseFolderName sRetval to sPath
101281>>>                If (Right(sPath, 1) ="\") Move (Left(sPath, Length(sPath) -1)) to sPath
101284>>>                Set Value to sPath
101285>>>            End
101285>>>>
101285>>>        End_Procedure
101286>>>
101286>>>        Procedure OnChange
101289>>>            String sValue
101289>>>            Get Value to sValue
101290>>>            Set psPath to sValue
101291>>>        End_Procedure
101292>>>
101292>>>    End_Object
101293>>>
101293>>>    Object oOK_Btn is a Button
101295>>>        Set Label    to "&OK"
101296>>>        Set Location to 81 169
101297>>>        Set peAnchors to anBottomRight
101298>>>
101298>>>        Procedure OnClick
101301>>>            Set pbOK to True
101302>>>            Send Close_Panel
101303>>>        End_Procedure
101304>>>
101304>>>    End_Object
101305>>>
101305>>>    Object oCancel_Btn is a Button
101307>>>        Set Label    to "&Cancel"
101308>>>        Set Location to 81 224
101309>>>        Set peAnchors to anBottomRight
101310>>>
101310>>>        Procedure OnClick
101313>>>            Set pbOK to False
101314>>>            Send Close_Panel
101315>>>        End_Procedure
101316>>>
101316>>>    End_Object
101317>>>
101317>>>    Object oButton1 is a Button
101319>>>        Set Size to 14 96
101320>>>        Set Location to 80 32
101321>>>        Set Label to "Enum table types"
101322>>>
101322>>>        Procedure OnClick
101325>>>            String sDriverID sLogin
101325>>>            tSQLConnection SQLConnection
101325>>>            tSQLConnection SQLConnection
101325>>>            Get pSQLConnection of ghoDbUpdateFunctionLibrary to SQLConnection
101326>>>            Send ShowAllTablesAndColumns SQLConnection.sDriverID SQLConnection.sConnectionString
101327>>>        End_Procedure
101328>>>
101328>>>        Procedure ShowAllTablesAndColumns String sDriver String sLogin
101331>>>            Handle hoCLIHandler
101331>>>            Integer iNumTables
101331>>>            Integer iNumColumns
101331>>>            Integer iTableCount
101331>>>            Integer iColumnCount
101331>>>
101331>>>            Get Create U_cCLIHandler to hoCLIhandler
101332>>>            If (hoCLIHandler > 0) Begin
101334>>>                Set psDriverID of hoCLIHandler to sDriver
101335>>>                Get EnumerateTables of hoCLIHandler sLogin to iNumTables
101336>>>                For iTableCount from 1 to iNumTables
101342>>>>
101342>>>                    Show (TableName(hoCLIHandler, iTableCount)) "; "
101344>>>                    Show (SchemaName(hoCLIHandler, iTableCount)) "; "
101346>>>                    Show (TableType(hoCLIHandler, iTableCount)) "; "
101348>>>                    Showln (TableComment(hoCLIHandler, iTableCount))
101350>>>//                    Get EnumerateColumns of hoCLIHandler sLogin (TableName(hoCLIHandler, iTableCount)) to iNumColumns
101350>>>//                    For iColumnCount from 1 to iNumColumns
101350>>>//                        Showln " " (ColumnName(hoCLIHandler, iColumnCount))
101350>>>//                    Loop
101350>>>                    Showln
101351>>>                Loop
101352>>>>
101352>>>                Send Destroy of hoCLIHandler
101353>>>            End
101353>>>>
101353>>>        End_Procedure
101354>>>
101354>>>    End_Object
101355>>>
101355>>>    Procedure Page Integer iPageObject
101358>>>        Set Icon to "DdBackup.ico"
101359>>>        Forward Send Page iPageObject
101361>>>    End_Procedure
101362>>>
101362>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
101363>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
101364>>>
101364>>>End_Object
101365>>>
101365>>>// *** General purpose access method for this dialog ***
101365>>>Function MakeSQLDatabaseBackup Returns Boolean
101368>>>    Handle ho
101368>>>    Boolean bOK bDefault
101368>>>    String sDatabase sPath sBackupName
101368>>>
101368>>>    Move (oSQLDatabaseBackup_dg(Self)) to ho
101369>>>    Set pbOK of ho to False
101370>>>    Send Popup of ho
101371>>>
101371>>>    Get pbOk of ho to bOK
101372>>>    If (bOK = True) Begin
101374>>>        Get Value of (oDatabase_fm(ho))   to sDatabase
101375>>>        Get Value of (oBackupName_fm(ho)) to sBackupName
101376>>>        Get Checked_State of (oUseDefaultBackupFolder_cb(ho)) to bDefault
101377>>>        If (bDefault = False) Begin
101379>>>            Get Value of (oPath_fm(ho)) to sPath
101380>>>        End
101380>>>>
101380>>>        Get SqlUtilBackupDatabaseToDisk of ghoDbUpdateFunctionLibrary sDatabase sBackupName sPath True to bOK
101381>>>    End
101381>>>>
101381>>>
101381>>>    Function_Return bOK
101382>>>End_Function
101383>        Use SQLConnections.vw
Including file: SQLConnections.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLConnections.vw)
101383>>>Use Windows.pkg
101383>>>Use DFClient.pkg
101383>>>Use cDbScrollingContainer.pkg
Including file: cDbScrollingContainer.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cDbScrollingContainer.pkg)
101383>>>>>// Provides support for db aware scrolling containers.
101383>>>>>// Scrolling containers is provided by creating two objects,
101383>>>>>// a host (dbScrollingContainer) and a scrolling clientarea (dbScrollingClientArea)
101383>>>>>// The host has no public interface, you just drop the object. It should have only one child object
101383>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
101383>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
101383>>>>>
101383>>>>>Use DFClient.pkg
101383>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files (x86)\DataFlex 19.0\Pkg\cScrollingContainerMixin.pkg)
101383>>>>>>>// Mixin classes for scrolling container support:
101383>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
101383>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
101383>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
101383>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
101383>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
101383>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
101383>>>>>>>
101383>>>>>>>Use Windows.pkg
101383>>>>>>>Use Winuser.pkg
101383>>>>>>>Use tWinStructs.pkg
101383>>>>>>>
101383>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
101383>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
101383>>>>>>>// support for the scrolling client area mixin object.
101383>>>>>>>
101383>>>>>>>Class cScrollingClientAreaMixin is a Mixin
101384>>>>>>>    
101384>>>>>>>    Procedure Define_cScrollingClientAreaMixin
101386>>>>>>>
101386>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
101387>>>>>>>        Set Border_Style to Border_None
101388>>>>>>>        
101388>>>>>>>        Property Boolean pbAutoScroll True
101389>>>>>>>        Property Boolean pbAutoScrollFocus True
101390>>>>>>>        Property Integer piAutoScrollMarginX 5
101391>>>>>>>        Property Integer piAutoScrollMarginY 5
101392>>>>>>>        Property Integer piAutoScrollMinX 0
101393>>>>>>>        Property Integer piAutoScrollMinY 0
101394>>>>>>>        Property Boolean pbShowDisabledScrollBar False 
101395>>>>>>>        
101395>>>>>>>        
101395>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
101396>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
101397>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
101398>>>>>>>        // keeps track of scrolling
101398>>>>>>>        Property Integer piCurrentVertScrolled 0
101399>>>>>>>        Property Integer piCurrentHorzScrolled 0
101400>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
101401>>>>>>>        Delegate Set phoScrollingClientArea to Self
101403>>>>>>>
101403>>>>>>>        // set this true to make this a tabbed workspace view (design time)
101403>>>>>>>        Property Boolean pbTabWorkspaceView False
101404>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
101404>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
101405>>>>>>>    End_Procedure
101406>>>>>>>
101406>>>>>>>    // low level event sent from windows.
101406>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
101408>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
101408>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
101409>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
101410>>>>>>>        If (wParam<0) Begin
101412>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
101413>>>>>>>        End
101413>>>>>>>>
101413>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
101414>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
101415>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
101415>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
101416>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
101417>>>>>>>        // If we have enough Clicks send OnMouseWheel
101417>>>>>>>        If (iClicks<>0) Begin
101419>>>>>>>            Send OnMouseWheel iClicks iKeys
101420>>>>>>>        End
101420>>>>>>>>
101420>>>>>>>        // tell windows that we've handled the event.    
101420>>>>>>>        Set Windows_Override_State to True    
101421>>>>>>>    End_Procedure
101422>>>>>>>
101422>>>>>>>
101422>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
101422>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
101424>>>>>>>        Integer iLineScrollUnit
101424>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
101425>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
101426>>>>>>>    End_Procedure
101427>>>>>>>
101427>>>>>>>    // should be sent by WM_VSCROLL
101427>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
101429>>>>>>>        Boolean bOk
101429>>>>>>>        tWinScrollInfo ScrollInfo
101429>>>>>>>        tWinScrollInfo ScrollInfo
101429>>>>>>>        Integer iLineScrollUnit
101429>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
101430>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
101431>>>>>>>        If bOk Begin 
101433>>>>>>>            
101433>>>>>>>            Case Begin
101433>>>>>>>                Case (iType=SB_PAGEDOWN) 
101435>>>>>>>                    Send VScroll ScrollInfo.nPage
101436>>>>>>>                    Case Break
101437>>>>>>>                    
101437>>>>>>>                Case (iType=SB_PAGEUP) 
101440>>>>>>>                    Send VScroll (-ScrollInfo.nPage)
101441>>>>>>>                    Case Break
101442>>>>>>>                    
101442>>>>>>>                Case (iType=SB_LINEDOWN) 
101445>>>>>>>                    Send VScroll iLineScrollUnit
101446>>>>>>>                    Case Break
101447>>>>>>>                    
101447>>>>>>>                Case (iType=SB_LINEUP) 
101450>>>>>>>                    Send VScroll (-iLineScrollUnit)
101451>>>>>>>                    Case Break
101452>>>>>>>    
101452>>>>>>>                Case (iType=SB_BOTTOM) 
101455>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
101456>>>>>>>                    Case Break
101457>>>>>>>    
101457>>>>>>>                Case (iType=SB_Top) 
101460>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
101461>>>>>>>                    Case Break
101462>>>>>>>                    
101462>>>>>>>                Case (iType=SB_THUMBPOSITION) 
101465>>>>>>>                    Case Break
101466>>>>>>>    
101466>>>>>>>                Case (iType=SB_THUMBTRACK) 
101469>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
101470>>>>>>>                    Case Break
101471>>>>>>>            Case End
101471>>>>>>>        End
101471>>>>>>>>
101471>>>>>>>    End_Procedure
101472>>>>>>>    
101472>>>>>>>    // should be sent by WM_HSCROLL
101472>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
101474>>>>>>>        Boolean bOk
101474>>>>>>>        tWinScrollInfo ScrollInfo
101474>>>>>>>        tWinScrollInfo ScrollInfo
101474>>>>>>>        Integer iLineScrollUnit
101474>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
101475>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
101476>>>>>>>        If bOk Begin 
101478>>>>>>>            
101478>>>>>>>            Case Begin
101478>>>>>>>                Case (iType=SB_PAGEDOWN) 
101480>>>>>>>                    Send hScroll ScrollInfo.nPage
101481>>>>>>>                    Case Break
101482>>>>>>>                    
101482>>>>>>>                Case (iType=SB_PAGEUP) 
101485>>>>>>>                    Send hScroll (-ScrollInfo.nPage)
101486>>>>>>>                    Case Break
101487>>>>>>>                    
101487>>>>>>>                Case (iType=SB_LINEDOWN) 
101490>>>>>>>                    Send hScroll iLineScrollUnit
101491>>>>>>>                    Case Break
101492>>>>>>>                    
101492>>>>>>>                Case (iType=SB_LINEUP) 
101495>>>>>>>                    Send hScroll (-iLineScrollUnit)
101496>>>>>>>                    Case Break
101497>>>>>>>    
101497>>>>>>>                Case (iType=SB_BOTTOM) 
101500>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
101501>>>>>>>                    Case Break
101502>>>>>>>    
101502>>>>>>>                Case (iType=SB_Top) 
101505>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
101506>>>>>>>                    Case Break
101507>>>>>>>                    
101507>>>>>>>                Case (iType=SB_THUMBPOSITION) 
101510>>>>>>>                    Case Break
101511>>>>>>>    
101511>>>>>>>                Case (iType=SB_THUMBTRACK) 
101514>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
101515>>>>>>>                    Case Break
101516>>>>>>>            Case End
101516>>>>>>>        End
101516>>>>>>>>
101516>>>>>>>    End_Procedure
101517>>>>>>>    
101517>>>>>>>    
101517>>>>>>>    // this calls SetScrollInfo with proper info
101517>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
101519>>>>>>>        tWinScrollInfo ScrollInfo
101519>>>>>>>        tWinScrollInfo ScrollInfo
101519>>>>>>>        Integer iVoid
101519>>>>>>>        Handle hWnd
101519>>>>>>>        Boolean bShow
101519>>>>>>>
101519>>>>>>>        Delegate Get Window_Handle to hWnd
101521>>>>>>>        If (hWnd <> 0) Begin        
101523>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
101524>>>>>>>             
101524>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
101525>>>>>>>            Get pbShowDisabledScrollBar to bShow
101526>>>>>>>            If bShow Begin
101528>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
101529>>>>>>>            End
101529>>>>>>>>
101529>>>>>>>            Move iRangeMin to ScrollInfo.nMin
101530>>>>>>>            Move iRangeMax to ScrollInfo.nMax
101531>>>>>>>            Move iPageSize to ScrollInfo.nPage
101532>>>>>>>            Move 0 to ScrollInfo.nPos
101533>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
101534>>>>>>>
101534>>>>>>>        End
101534>>>>>>>>
101534>>>>>>>    End_Procedure // 
101535>>>>>>>    
101535>>>>>>>    // this wraps GetScrollInfo
101535>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
101537>>>>>>>        Boolean bOk
101537>>>>>>>        Handle hWnd
101537>>>>>>>
101537>>>>>>>        Delegate Get Window_Handle to hWnd
101539>>>>>>>        If (hWnd <> 0) Begin        
101541>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
101542>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
101543>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
101544>>>>>>>        End
101544>>>>>>>>
101544>>>>>>>        Function_Return bOk
101545>>>>>>>    End_Function
101546>>>>>>>
101546>>>>>>>    // this wraps SetScrollPos
101546>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
101548>>>>>>>        Integer iVoid
101548>>>>>>>        Handle hWnd
101548>>>>>>>
101548>>>>>>>        Delegate Get Window_Handle to hWnd
101550>>>>>>>        If (hWnd <> 0) Begin        
101552>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
101553>>>>>>>        End
101553>>>>>>>>
101553>>>>>>>    End_Procedure
101554>>>>>>>
101554>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
101554>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
101554>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
101556>>>>>>>         Send ScrollClientArea
101557>>>>>>>    End_Procedure
101558>>>>>>>
101558>>>>>>>    // augment to handle the scrolling area initialization.
101558>>>>>>>    Procedure Add_Focus Handle hoParent
101560>>>>>>>        Forward Send Add_Focus hoParent
101562>>>>>>>        // at this the scrolling container and client area should both be paged. 
101562>>>>>>>        // child objects ae also paged with initial anchors applied
101562>>>>>>>        Send CalculateAutoScrollMinimums
101563>>>>>>>    End_Procedure
101564>>>>>>>    
101564>>>>>>>    Procedure Page Integer iPage
101566>>>>>>>        Forward Send Page iPage
101568>>>>>>>        If iPage Begin
101570>>>>>>>            // at this the scrolling container and client area should both be paged
101570>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
101570>>>>>>>            // the child items are paged (else they may get anchored oddly) 
101570>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
101570>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
101570>>>>>>>            // before they were really needed. This should be more accurate
101570>>>>>>>            Send SetScrollBarInfo True 0 0 0
101571>>>>>>>            Send SetScrollBarInfo False 0 0 0
101572>>>>>>>        End
101572>>>>>>>>
101572>>>>>>>    End_Procedure
101573>>>>>>>
101573>>>>>>>    // determine scrolling minimums and set the client area as required.
101573>>>>>>>    
101573>>>>>>>    Procedure CalculateAutoScrollMinimums
101575>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
101575>>>>>>>        Integer iAutoMinX iAutoMinY
101575>>>>>>>        Boolean bAutoScroll
101575>>>>>>>        Handle hoNext hoFirst
101575>>>>>>>        
101575>>>>>>>        Get pbAutoScroll to bAutoScroll
101576>>>>>>>        Get piAutoScrollMinX to iAutoMinX
101577>>>>>>>        Get piAutoScrollMinY to iAutoMinY
101578>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
101579>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
101580>>>>>>>        Move (Low(iSiz)) to iAutoMinX
101581>>>>>>>        Set piMinimumHeight to iAutoMinY
101582>>>>>>>        Set piMinimumWidth to iAutoMinX
101583>>>>>>>        
101583>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
101585>>>>>>>        
101585>>>>>>>            Get Next_Level to hoFirst
101586>>>>>>>            Move hoFirst to hoNext
101587>>>>>>>            If (hoFirst) Begin
101589>>>>>>>                Repeat
101589>>>>>>>>
101589>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
101590>>>>>>>                    Get GuiLocation of hoNext to iLoc
101591>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
101592>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
101593>>>>>>>                    Get Next_Focus of hoNext to hoNext
101594>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
101596>>>>>>>
101596>>>>>>>                If (iAutoMinY=0) Begin
101598>>>>>>>                    Get piAutoScrollMarginY to iMargin
101599>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
101600>>>>>>>                End
101600>>>>>>>>
101600>>>>>>>
101600>>>>>>>                If (iAutoMinX=0) Begin
101602>>>>>>>                    Get piAutoScrollMarginX to iMargin
101603>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
101604>>>>>>>
101604>>>>>>>                End
101604>>>>>>>>
101604>>>>>>>            End
101604>>>>>>>>
101604>>>>>>>        End
101604>>>>>>>>
101604>>>>>>>        
101604>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
101604>>>>>>>        Broadcast Set pbAnchorCreated to False
101606>>>>>>>        Send ScrollClientArea
101607>>>>>>>        // after the scroll set up, reinitialize all anchors.
101607>>>>>>>        Broadcast Send DoCreateAnchors
101609>>>>>>>    End_Procedure
101610>>>>>>>    
101610>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
101610>>>>>>>    // work of scrolling.
101610>>>>>>>    
101610>>>>>>>    Procedure ScrollClientArea
101612>>>>>>>        Integer iSiz
101612>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
101612>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
101612>>>>>>>        Integer iSzY iSzX iLocX iLocY
101612>>>>>>>        
101612>>>>>>>        Delegate Get GuiClientSize to iSiz
101614>>>>>>>        Move (Hi(iSiz)) to iHeight
101615>>>>>>>        Move (Low(iSiz)) to iWidth
101616>>>>>>>
101616>>>>>>>        // Vertical scrolling
101616>>>>>>>        
101616>>>>>>>        Get piMinimumHeight to iOrig
101617>>>>>>>        Get piMinimumWidth to iWOrig
101618>>>>>>>        
101618>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
101620>>>>>>>        
101620>>>>>>>            If (iOrig<>0) Begin
101622>>>>>>>                Get piCurrentVertScrolled to iHCur
101623>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up        
101623>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
101625>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
101626>>>>>>>                    Set piCurrentVertScrolled to iHCur
101627>>>>>>>                End
101627>>>>>>>>
101627>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
101629>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
101630>>>>>>>                    Send SetScrollBarPosInfo True iHCur 
101631>>>>>>>                End
101631>>>>>>>>
101631>>>>>>>                Else Begin
101632>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
101633>>>>>>>                End
101633>>>>>>>>
101633>>>>>>>            End
101633>>>>>>>>
101633>>>>>>>                
101633>>>>>>>            // Horiz scrolling
101633>>>>>>>            
101633>>>>>>>            Get piCurrentHorzScrolled to iWCur
101634>>>>>>>    //        If (iWCur<>0) Begin
101634>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll left        
101634>>>>>>>                If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
101636>>>>>>>                    Move (iWOrig-iWidth max 0) to iWCur
101637>>>>>>>                    Set piCurrentHorzScrolled to iWCur
101638>>>>>>>                End
101638>>>>>>>>
101638>>>>>>>                If (iWCur<>0 or iWOrig>iWidth) Begin
101640>>>>>>>                    Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
101641>>>>>>>                    Send SetScrollBarPosInfo False iWCur 
101642>>>>>>>                End
101642>>>>>>>>
101642>>>>>>>                Else Begin
101643>>>>>>>                    Send SetScrollBarInfo False 0 0 0 
101644>>>>>>>                End
101644>>>>>>>>
101644>>>>>>>    //        End
101644>>>>>>>        End
101644>>>>>>>>
101644>>>>>>>        
101644>>>>>>>        // this could change depending on scrollbars appearing or not    
101644>>>>>>>        Delegate Get GuiClientSize to iSiz
101646>>>>>>>        
101646>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
101646>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
101646>>>>>>>        // This is required to make anchors work sensibly 
101646>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
101647>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
101648>>>>>>>        Move (-iHCur) to iLocY
101649>>>>>>>        Move (-iWCur) to iLocX
101650>>>>>>>
101650>>>>>>>        // Allow chance to make modifications
101650>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
101651>>>>>>>
101651>>>>>>>        Set GuiSize to iSzY iSzX
101652>>>>>>>        // if we've scrolled, we need to reposition the container
101652>>>>>>>        Set GuiLocation to iLocY iLocX  
101653>>>>>>>    End_Procedure
101654>>>>>>>
101654>>>>>>>    // note that scrolling never changes the size of the scrolling client.
101654>>>>>>>    // this way, it does not interfere with anchors.
101654>>>>>>>    
101654>>>>>>>    Procedure VScroll Integer iDelta
101656>>>>>>>        Integer iHeight iCur iOrig iSiz 
101656>>>>>>>        Delegate Get GuiClientSize to iSiz
101658>>>>>>>        Move (hi(iSiz)) to iHeight
101659>>>>>>>        Get piCurrentVertScrolled to iCur
101660>>>>>>>        Get piMinimumHeight to iOrig
101661>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
101663>>>>>>>            Procedure_Return
101664>>>>>>>        End
101664>>>>>>>>
101664>>>>>>>        // make sure delta is within range  
101664>>>>>>>        If (iDelta+iCur<0) Begin
101666>>>>>>>            Move (-iCur) to iDelta
101667>>>>>>>        End
101667>>>>>>>>
101667>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
101670>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
101671>>>>>>>        End
101671>>>>>>>>
101671>>>>>>>        If (iDelta=0) Procedure_Return
101674>>>>>>>        
101674>>>>>>>        Move (iCur + iDelta) to iCur 
101675>>>>>>>        Set piCurrentVertScrolled to iCur 
101676>>>>>>>        Send SetScrollBarPosInfo True iCur 
101677>>>>>>>        Get GuiLocation to iSiz
101678>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)-iDelta) (cast(low(iSiz),Short))
101679>>>>>>>        Send ScrollClientArea
101680>>>>>>>    End_Procedure
101681>>>>>>>    
101681>>>>>>>    
101681>>>>>>>    Procedure HScroll Integer iDelta
101683>>>>>>>        Integer iHeight iCur iOrig iSiz
101683>>>>>>>        Delegate Get GuiClientSize to iSiz
101685>>>>>>>        Move (low(iSiz)) to iHeight
101686>>>>>>>        Get piCurrentHorzScrolled to iCur
101687>>>>>>>        Get piMinimumWidth to iOrig
101688>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
101690>>>>>>>            Procedure_Return
101691>>>>>>>        End
101691>>>>>>>>
101691>>>>>>>        If (iDelta+iCur<0) Begin
101693>>>>>>>            Move (-iCur) to iDelta
101694>>>>>>>        End
101694>>>>>>>>
101694>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
101697>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
101698>>>>>>>        End
101698>>>>>>>>
101698>>>>>>>        If (iDelta=0) Procedure_Return
101701>>>>>>>        
101701>>>>>>>        Move (iCur + iDelta) to iCur 
101702>>>>>>>        Set piCurrentHorzScrolled to iCur 
101703>>>>>>>        Send SetScrollBarPosInfo False iCur 
101704>>>>>>>        Get GuiLocation to iSiz
101705>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
101706>>>>>>>        Send ScrollClientArea
101707>>>>>>>    End_Procedure
101708>>>>>>>    
101708>>>>>>>    // make sure client is a 0,0
101708>>>>>>>    Procedure ScrollHome
101710>>>>>>>        Send SetVScrollbox SB_TOP 0
101711>>>>>>>        Send SetHScrollbox SB_TOP 0
101712>>>>>>>    End_Procedure
101713>>>>>>>
101713>>>>>>>    // get relative GUI location of this object to the parent one passed.
101713>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
101715>>>>>>>        Integer ivoid
101715>>>>>>>        tWinRect Rect0 Rect1
101715>>>>>>>        tWinRect Rect0 Rect1
101715>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
101716>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
101717>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
101718>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
101719>>>>>>>    End_Procedure
101720>>>>>>>    
101720>>>>>>>    // This scrolls this object into visual range. 
101720>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
101722>>>>>>>        Handle hoScrollingContainer
101722>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
101722>>>>>>>        Integer iViewHeight iViewWidth
101722>>>>>>>        Integer iRelLocHeight iRelLocWidth
101722>>>>>>>        Integer iSize iControlHeight iControlWidth
101722>>>>>>>        Integer iScroll
101722>>>>>>>        Integer iMarginX iMarginY
101722>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
101722>>>>>>>        
101722>>>>>>>        Get piAutoScrollMarginX to iMarginX
101723>>>>>>>        Get piAutoScrollMarginY to iMarginY
101724>>>>>>>        
101724>>>>>>>        // the scrolling container 
101724>>>>>>>        Move Self to hoScrollingContainer
101725>>>>>>>        // the amount the SC is currently scrolled
101725>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
101726>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
101727>>>>>>>        
101727>>>>>>>        // size of view's client area (this is the viewport area)
101727>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
101728>>>>>>>        Move (hi(iSize)) to iViewHeight
101729>>>>>>>        Move (low(iSize)) to iViewWidth
101730>>>>>>>        
101730>>>>>>>        // get this object's location relative to the scrolling container
101730>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
101731>>>>>>>
101731>>>>>>>        // we expect that the client size is the window size but just in case
101731>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
101732>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
101733>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight 
101734>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
101735>>>>>>>        
101735>>>>>>>        // the outer size of the control object
101735>>>>>>>        Get GUIWindowSize of hoControl to iSize
101736>>>>>>>        Move (hi(iSize)) to iControlHeight
101737>>>>>>>        Move (low(iSize)) to iControlWidth
101738>>>>>>>        
101738>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
101738>>>>>>>
101738>>>>>>>        // Vertical Scroll
101738>>>>>>>        
101738>>>>>>>        // Vertical Scroll down
101738>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
101738>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
101740>>>>>>>           
101740>>>>>>>           // set scroll amount so that the bottom of the control is visible  
101740>>>>>>>           Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
101741>>>>>>>           
101741>>>>>>>           // See if this amount, scrolls the top out of range. If so just scroll enough so that the
101741>>>>>>>           // top of the object appears at the bottom 
101741>>>>>>>           If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
101743>>>>>>>               Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
101744>>>>>>>           End
101744>>>>>>>>
101744>>>>>>>           // if the scroll amnt is negative it's best to just keep it where it is.
101744>>>>>>>           If (iScroll>0) Begin
101746>>>>>>>                Send VScroll of hoScrollingContainer iScroll
101747>>>>>>>           End
101747>>>>>>>>
101747>>>>>>>        End
101747>>>>>>>>
101747>>>>>>>        // else vertical scroll up 
101747>>>>>>>        // We scroll if the top of the object is not visible.  
101747>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
101750>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
101750>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
101751>>>>>>>            If (iScroll<0) Begin
101753>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
101754>>>>>>>            End
101754>>>>>>>>
101754>>>>>>>        End
101754>>>>>>>>
101754>>>>>>>
101754>>>>>>>        // Horizonal Scroll
101754>>>>>>>        
101754>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
101754>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
101756>>>>>>>           Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
101757>>>>>>>           If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
101759>>>>>>>               Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
101760>>>>>>>           End
101760>>>>>>>>
101760>>>>>>>           If (iScroll>0) Begin
101762>>>>>>>                Send HScroll of hoScrollingContainer iScroll
101763>>>>>>>           End
101763>>>>>>>>
101763>>>>>>>        End
101763>>>>>>>>
101763>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
101765>>>>>>>            // if this can fit by moving all the way to left, do so.
101765>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
101767>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
101768>>>>>>>            End
101768>>>>>>>>
101768>>>>>>>            Else Begin
101769>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
101770>>>>>>>            End
101770>>>>>>>>
101770>>>>>>>            If (iScroll<0) Begin
101772>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
101773>>>>>>>            End
101773>>>>>>>>
101773>>>>>>>        End
101773>>>>>>>>
101773>>>>>>>
101773>>>>>>>
101773>>>>>>>    End_Procedure
101774>>>>>>>
101774>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
101774>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
101776>>>>>>>        Boolean bScrollOnFocus
101776>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
101777>>>>>>>        If bScrollOnFocus Begin
101779>>>>>>>            Send ScrollObjectInRange hoControl
101780>>>>>>>        End
101780>>>>>>>>
101780>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
101782>>>>>>>    End_Procedure
101783>>>>>>>
101783>>>>>>>
101783>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
101785>>>>>>>        Boolean bCenter
101785>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
101786>>>>>>>        Function_Return bCenter
101787>>>>>>>    End_Function
101788>>>>>>>    
101788>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
101790>>>>>>>        Boolean bTabWorkspaceView
101790>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView 
101791>>>>>>>        If bTabWorkspaceView Begin
101793>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
101794>>>>>>>        End
101794>>>>>>>>
101794>>>>>>>    End_Procedure
101795>>>>>>>    
101795>>>>>>>    Function ParentView Returns Handle
101797>>>>>>>        Function_Return (Parent(Parent(Self)))
101798>>>>>>>    End_Function
101799>>>>>>>    
101799>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
101801>>>>>>>        Integer iSize iMax iDiff
101801>>>>>>>        Handle hoView
101801>>>>>>>        Boolean bCenter bModal
101801>>>>>>>        Get ParentView to hoView
101802>>>>>>>        Get Block_Mouse_State of hoView to bModal
101803>>>>>>>        If not bModal Begin
101805>>>>>>>            Get CenterTabWorkspaceView to bCenter
101806>>>>>>>            Get GuiSize of hoView to iSize
101807>>>>>>>            Get piMaxSize of hoView to iMax
101808>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
101809>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
101811>>>>>>>                If bCenter Begin
101813>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
101814>>>>>>>                End
101814>>>>>>>>
101814>>>>>>>                Move (Low(iMax)) to iWidth
101815>>>>>>>            End
101815>>>>>>>>
101815>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
101817>>>>>>>                If bCenter Begin
101819>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
101820>>>>>>>                    Move (iLocy min 25) to  iLocY
101821>>>>>>>                End
101821>>>>>>>>
101821>>>>>>>                Move (Hi(imax)) to iHeight
101822>>>>>>>            End
101822>>>>>>>>
101822>>>>>>>        End
101822>>>>>>>>
101822>>>>>>>    End_Procedure
101823>>>>>>>
101823>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
101823>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
101823>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
101823>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
101823>>>>>>>    // This should almost always yield the right answer.
101823>>>>>>>    // This is called by the scrolling container's end_constructor
101823>>>>>>>    Procedure AutoSetTabWorkspaceView
101825>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
101825>>>>>>>        Handle hoParent
101825>>>>>>>        Integer iSize
101825>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView  
101826>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
101828>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
101829>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
101829>>>>>>>            // change this after the commandbar is paged.
101829>>>>>>>            If (bTabView) Begin
101831>>>>>>>                Get ParentView to hoParent
101832>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
101833>>>>>>>                If (bIsView) Begin
101835>>>>>>>                    // set this as a tab workspace view
101835>>>>>>>                    Set pbTabWorkspaceView to True
101836>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
101836>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
101836>>>>>>>                    Set pbAutoScroll to True
101837>>>>>>>                    
101837>>>>>>>//                    // if piMaxSize is not set, we will do it for you by setting it
101837>>>>>>>//                    // to the current size.
101837>>>>>>>//                    Get piMaxSize of hoParent to iSize
101837>>>>>>>//                    If (iSize=0) Begin
101837>>>>>>>//                        Get Size of hoParent to iSize
101837>>>>>>>//                        Set piMaxSize of hoParent to (Hi(iSize)) (Low(iSize))
101837>>>>>>>//                    End
101837>>>>>>>                End
101837>>>>>>>>
101837>>>>>>>            End
101837>>>>>>>>
101837>>>>>>>        End
101837>>>>>>>>
101837>>>>>>>    End_Procedure
101838>>>>>>>
101838>>>>>>>End_Class
101839>>>>>>>
101839>>>>>>>// Container scrolling class support. Nothing in here is public
101839>>>>>>>Class cScrollingContainerMixin is a Mixin
101840>>>>>>>
101840>>>>>>>    Procedure Define_cScrollingContainerMixin
101842>>>>>>>        Forward Set Border_Style to Border_None
101844>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
101845>>>>>>>        Forward Set peAnchors to anAll
101847>>>>>>>
101847>>>>>>>        // forcing scrollbars right away seems to make painting better
101847>>>>>>>        Set Window_Style WS_HSCROLL to True
101848>>>>>>>        Set Window_Style WS_VSCROLL to True
101849>>>>>>>
101849>>>>>>>        Property Handle phoScrollingClientArea 0
101850>>>>>>>    End_Procedure
101851>>>>>>>    
101851>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
101851>>>>>>>    Procedure Set peAnchors Integer eAnchors
101853>>>>>>>    End_Procedure
101854>>>>>>>
101854>>>>>>>    // if a border style is set, it will not work. We won't let that happen
101854>>>>>>>    Procedure Set Border_Style Integer eStyle
101856>>>>>>>    End_Procedure
101857>>>>>>>
101857>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
101857>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
101859>>>>>>>        Handle hoClient
101859>>>>>>>        Get phoScrollingClientArea to hoClient
101860>>>>>>>        If hoClient Begin
101862>>>>>>>           Send OnMouseWheel of hoClient wParam lParam
101863>>>>>>>        End
101863>>>>>>>>
101863>>>>>>>    End_Procedure
101864>>>>>>>
101864>>>>>>>    // should be sent by WM_VSCROLL
101864>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
101866>>>>>>>        Handle hoClient
101866>>>>>>>        Get phoScrollingClientArea to hoClient
101867>>>>>>>        If hoClient Begin
101869>>>>>>>           Send SetVScrollbox of hoClient iType iNewPos
101870>>>>>>>        End
101870>>>>>>>>
101870>>>>>>>    End_Procedure
101871>>>>>>>
101871>>>>>>>    // should be sent by WM_HSCROLL
101871>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
101873>>>>>>>        Handle hoClient
101873>>>>>>>        Get phoScrollingClientArea to hoClient
101874>>>>>>>        If hoClient Begin
101876>>>>>>>           Send SetHScrollbox of hoClient iType iNewPos
101877>>>>>>>        End
101877>>>>>>>>
101877>>>>>>>    End_Procedure
101878>>>>>>>
101878>>>>>>>    // augmented to adjust its size to the size of the parent client area.
101878>>>>>>>    // After this is set, anchors will handle any further resizing.
101878>>>>>>>    Procedure Page Integer iState
101880>>>>>>>        Integer iSiz iHeight iWidth
101880>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
101880>>>>>>>        Boolean bGroup
101880>>>>>>>        Handle hoClient
101880>>>>>>>        If (iState =1) Begin
101882>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
101884>>>>>>>            // We have special code to support groups because they
101884>>>>>>>            // draw a border inside of the client rectangle
101884>>>>>>>            If bGroup Begin
101886>>>>>>>                Get Physical_FontSize to iFontSize
101887>>>>>>>                Move (Hi(iFontSize)) to iTop
101888>>>>>>>                Move 2 to iLeft
101889>>>>>>>                Move 2 to iRight
101890>>>>>>>                Move 2 to iBottom
101891>>>>>>>            End
101891>>>>>>>>
101891>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
101891>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
101891>>>>>>>            // makes anchors work properly with unpaged tab-pages
101891>>>>>>>            Delegate Get GetContainerClientSize to iSiz
101893>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
101894>>>>>>>            Set GuiLocation to iTop iLeft
101895>>>>>>>            Send Adjust_Logicals
101896>>>>>>>        End
101896>>>>>>>>
101896>>>>>>>        Forward Send Page iState
101898>>>>>>>    End_Procedure
101899>>>>>>>    
101899>>>>>>>    Procedure End_Construct_Object 
101901>>>>>>>        Handle hoClient
101901>>>>>>>        Forward Send End_Construct_Object
101903>>>>>>>        Get phoScrollingClientArea to hoClient
101904>>>>>>>        If (hoClient) Begin
101906>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
101907>>>>>>>        End
101907>>>>>>>>
101907>>>>>>>    End_Procedure
101908>>>>>>>
101908>>>>>>>End_Class
101909>>>>>>>
101909>>>>>
101909>>>>>Class cDbScrollingClientArea is a dbContainer3d
101910>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
101911>>>>>    Procedure Construct_Object
101913>>>>>        Forward Send Construct_Object
101915>>>>>        Send Define_cScrollingClientAreaMixin
101916>>>>>    End_Procedure
101917>>>>>End_Class
101918>>>>>
101918>>>>>
101918>>>>>
101918>>>>>Class cDbScrollingContainer is a dbContainer3d
101919>>>>>    Import_Class_Protocol cScrollingContainerMixin
101920>>>>>    Procedure Construct_Object
101922>>>>>        Forward Send Construct_Object
101924>>>>>        Send Define_cScrollingContainerMixin
101925>>>>>    End_Procedure
101926>>>>>End_Class
101927>>>Use cDbUpdateFunctionLibrary.pkg
101927>>>Use cButtonDPI.pkg
Including file: cButtonDPI.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\cButtonDPI.pkg)
101927>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
101927>>>>>Class cButtonDPI is a Button
101928>>>>>    Procedure Construct_Object 
101930>>>>>        Integer iIconSize
101930>>>>>        Forward Send Construct_Object
101932>>>>>        Get GetCorrectIconSize to iIconSize
101933>>>>>        Set piImageSize to iIconSize
101934>>>>>    End_Procedure
101935>>>>>
101935>>>>>    // Returns: DPI setting as an integer.
101935>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
101935>>>>>    //                      iDPI=120 is "Medium setting" 125%
101935>>>>>    //                      iDPI= 144 is "Large setting" 150%
101935>>>>>    Function GetCurrentDPI Returns Integer
101937>>>>>        Handle hDC
101937>>>>>        Integer iPixelsX
101937>>>>>        Move (GetDC(0)) to hDC
101938>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
101939>>>>>        Move (ReleaseDC(0, hDC)) to hDC
101940>>>>>        Function_Return iPixelsX
101941>>>>>    End_Function  
101942>>>>>    
101942>>>>>    Function GetCorrectIconSize Returns Integer
101944>>>>>        Integer iPixelsX iIndex iSize 
101944>>>>>        Integer[] iaSizes
101945>>>>>        
101945>>>>>        Move 16 to iaSizes[0]
101946>>>>>        Move 24 to iaSizes[1]
101947>>>>>        Move 32 to iaSizes[2]
101948>>>>>        Move 48 to iaSizes[3]
101949>>>>>        Move 64 to iaSizes[4]
101950>>>>>        
101950>>>>>        Get piImageSize to iSize  // the "100%" size
101951>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
101952>>>>>        Move (0 max iIndex) to iIndex
101953>>>>>        Get GetCurrentDPI to iPixelsX
101954>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
101954>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
101954>>>>>        // will increment iIndex as many times as we need here.
101954>>>>>        Case Begin
101954>>>>>            Case (iPixelsX > 144)
101956>>>>>                Increment iIndex
101957>>>>>            Case (iPixelsX = 144)
101960>>>>>                Increment iIndex
101961>>>>>            Case (iPixelsX = 120)
101964>>>>>                Increment iIndex  
101965>>>>>        Case End
101965>>>>>        Move (iIndex min 4) to iIndex
101966>>>>>        Function_Return iaSizes[iIndex]
101967>>>>>    End_Function
101968>>>>>    
101968>>>>>//    Function GetCorrectIconSize Returns Integer
101968>>>>>//        Integer iPixelsX iRetval
101968>>>>>//        Get GetCurrentDPI to iPixelsX
101968>>>>>//        Case Begin
101968>>>>>//            Case (iPixelsX < 120)
101968>>>>>//                Move 16 to iRetval
101968>>>>>//                Case Break
101968>>>>>//            Case (iPixelsX = 120)
101968>>>>>//                Move 24 to iRetval
101968>>>>>//                Case Break
101968>>>>>//            Case (iPixelsX = 144)
101968>>>>>//                Move 32 to iRetval
101968>>>>>//                Case Break
101968>>>>>//            Case (iPixelsX > 144)
101968>>>>>//                Move 48 to iRetval
101968>>>>>//                Case Break
101968>>>>>//        Case End                
101968>>>>>//        Function_Return iRetval
101968>>>>>//    End_Function
101968>>>>>
101968>>>>>End_Class
101969>>>Use DatabaseSelection.dg
101969>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\ServerSelection.dg)
101969>>>>>Use Windows.pkg
101969>>>>>Use cCJGridPromptList.pkg
101969>>>>>Use cDbUpdateFunctionLibrary.pkg
101969>>>>>Use MSSqldrv.pkg
101969>>>>>Use db2_drv.pkg
101969>>>>>Use odbc_drv.pkg
101969>>>>>
101969>>>>>Object oServerSelection_sl is a ModalPanel
101971>>>>>    Set Size to 148 274
101972>>>>>    Set Label to "Database Server/DSN Selection"
101973>>>>>    Set piMinSize to 89 211
101974>>>>>    Set Location to 2 2
101975>>>>>    Set Border_Style to Border_Thick
101976>>>>>
101976>>>>>    Property String[] psTheData
101978>>>>>
101978>>>>>    Object oSelList is a cCJGridPromptList
101980>>>>>        Set Size to 115 264
101981>>>>>        Set Location to 6 6
101982>>>>>        Set peAnchors to anAll
101983>>>>>        Set pbAllowColumnRemove to False
101984>>>>>        Set pbUseAlternateRowBackgroundColor to True
101985>>>>>        Set pbGrayIfDisable to False
101986>>>>>        Set pbHeaderReorders to False
101987>>>>>        Set pbHeaderSelectsColumn to False
101988>>>>>        Set pbHeaderTogglesDirection to False
101989>>>>>        Set pbShadeSortColumn to False
101990>>>>>        Set piFocusCellBackColor to clDkGray
101991>>>>>
101991>>>>>        Object oName is a cCJGridColumn
101993>>>>>            Set piWidth to 528
101994>>>>>            Set psCaption to "Name"
101995>>>>>        End_Object
101996>>>>>
101996>>>>>        Procedure Activating
101999>>>>>            tDataSourceRow[] MyData
101999>>>>>            tDataSourceRow[] MyData
102000>>>>>            Handle hoDataSource
102000>>>>>            String[] sTheData
102001>>>>>            Integer iCount iSize
102001>>>>>
102001>>>>>            Send Cursor_Wait of Cursor_Control
102002>>>>>            Get psTheData to sTheData
102003>>>>>            Move (SizeOfArray(sTheData)) to iSize
102004>>>>>            Decrement iSize
102005>>>>>            For iCount from 0 to iSize
102011>>>>>>
102011>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
102012>>>>>            Loop
102013>>>>>>
102013>>>>>
102013>>>>>            Forward Send Activating
102015>>>>>
102015>>>>>            Get phoDataSource to hoDataSource
102016>>>>>            Send InitializeData of hoDataSource MyData
102017>>>>>            Send Cursor_Ready of Cursor_Control
102018>>>>>        End_Procedure
102019>>>>>
102019>>>>>    End_Object
102020>>>>>
102020>>>>>    Object oOK_Btn is a Button
102022>>>>>        Set Label    to "&OK"
102023>>>>>        Set Location to 130 165
102024>>>>>        Set peAnchors To anBottomRight
102025>>>>>
102025>>>>>        Procedure OnClick
102028>>>>>            Send Ok of oSelList
102029>>>>>        End_Procedure
102030>>>>>
102030>>>>>    End_Object
102031>>>>>
102031>>>>>    Object oCancel_Btn is a Button
102033>>>>>        Set Label    to "&Cancel"
102034>>>>>        Set Location to 130 220
102035>>>>>        Set peAnchors to anBottomRight
102036>>>>>
102036>>>>>        Procedure OnClick
102039>>>>>            Send Close_Panel
102040>>>>>        End_Procedure
102041>>>>>
102041>>>>>    End_Object
102042>>>>>
102042>>>>>    Procedure Page Integer iPageObject
102045>>>>>        Set Icon to "ServerLookup.ico"
102046>>>>>        Forward Send Page iPageObject
102048>>>>>    End_Procedure
102049>>>>>
102049>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
102050>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
102051>>>>>End_Object
102052>>>Use SQLConnections.dg
Including file: SQLConnections.dg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLConnections.dg)
102052>>>>>Use Windows.pkg
102052>>>>>Use cCJGridPromptList.pkg
102052>>>>>Use cDbUpdateFunctionLibrary.pkg
102052>>>>>Use MSSqldrv.pkg
102052>>>>>Use db2_drv.pkg
102052>>>>>Use odbc_drv.pkg
102052>>>>>
102052>>>>>Object oSQLConnections is a ModalPanel
102054>>>>>    Set Label to "SQL Connections"
102055>>>>>    Set Size to 121 185
102056>>>>>    Set piMinSize to 89 185
102057>>>>>    Set Location to 2 2
102058>>>>>    Set Border_Style to Border_Thick
102059>>>>>
102059>>>>>    Property String[] psTheData
102061>>>>>
102061>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
102063>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
102065>>>>>        End_Object
102066>>>>>    End
102066>>>>>>
102066>>>>>
102066>>>>>    Object oSelListSQLConnections is a cCJGridPromptList
102068>>>>>        Set Size to 90 167
102069>>>>>        Set Location to 6 6
102070>>>>>        Set peAnchors to anAll
102071>>>>>        Set pbAllowColumnRemove to False
102072>>>>>        Set pbUseAlternateRowBackgroundColor to True
102073>>>>>        Set pbGrayIfDisable to False
102074>>>>>        Set pbHeaderReorders to False
102075>>>>>        Set pbHeaderSelectsColumn to False
102076>>>>>        Set pbHeaderTogglesDirection to False
102077>>>>>        Set pbShadeSortColumn to False
102078>>>>>        Set piFocusCellBackColor to clDkGray
102079>>>>>
102079>>>>>        Object oName is a cCJGridColumn
102081>>>>>            Set piWidth to 223
102082>>>>>            Set psCaption to "SQL Connection"
102083>>>>>        End_Object
102084>>>>>
102084>>>>>        Object oDriverID is a cCJGridColumn
102086>>>>>            Set piWidth to 111
102087>>>>>            Set psCaption to "Driver ID"
102088>>>>>        End_Object
102089>>>>>
102089>>>>>        Procedure Activating
102092>>>>>            tDataSourceRow[] MyData
102092>>>>>            tDataSourceRow[] MyData
102093>>>>>            Handle hoDataSource
102093>>>>>            String[] sTheData
102094>>>>>            Integer iCount iSize iPos
102094>>>>>            String sDriverID sConnectionID sValue
102094>>>>>
102094>>>>>            Send Cursor_Wait of Cursor_Control
102095>>>>>            Forward Send Activating
102097>>>>>
102097>>>>>            Get psTheData to sTheData
102098>>>>>            Move (SizeOfArray(sTheData)) to iSize
102099>>>>>            Decrement iSize
102100>>>>>            For iCount from 0 to iSize
102106>>>>>>
102106>>>>>                Move sTheData[iCount] to sValue
102107>>>>>                Move (Pos("|", sValue)) to iPos
102108>>>>>                Move (Left(sValue, (iPos -1)))     to sConnectionID
102109>>>>>                Move (Mid(sValue, 999, (iPos +1))) to sDriverID
102110>>>>>                Move sConnectionID to MyData[iCount].sValue[0]
102111>>>>>                Move sDriverID     to MyData[iCount].sValue[1]
102112>>>>>            Loop
102113>>>>>>
102113>>>>>
102113>>>>>            Get phoDataSource to hoDataSource
102114>>>>>            Send InitializeData of hoDataSource MyData
102115>>>>>            Send Cursor_Ready of Cursor_Control
102116>>>>>        End_Procedure
102117>>>>>
102117>>>>>    End_Object
102118>>>>>
102118>>>>>    Object oOK_Btn is a Button
102120>>>>>        Set Label    to "&OK"
102121>>>>>        Set Location to 101 68
102122>>>>>        Set peAnchors to anBottomRight
102123>>>>>
102123>>>>>        Procedure OnClick
102126>>>>>            Send Ok of oSelListSQLConnections
102127>>>>>        End_Procedure
102128>>>>>
102128>>>>>    End_Object
102129>>>>>
102129>>>>>    Object oCancel_Btn is a Button
102131>>>>>        Set Label    to "&Cancel"
102132>>>>>        Set Location to 101 123
102133>>>>>        Set peAnchors to anBottomRight
102134>>>>>
102134>>>>>        Procedure OnClick
102137>>>>>            Send Close_Panel
102138>>>>>        End_Procedure
102139>>>>>
102139>>>>>    End_Object
102140>>>>>
102140>>>>>    Procedure Page Integer iPageObject
102143>>>>>        Set Icon to "SQLConnections.ico"
102144>>>>>        Forward Send Page iPageObject
102146>>>>>    End_Procedure
102147>>>>>
102147>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
102148>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
102149>>>>>End_Object
102150>>>
102150>>>Activate_View Activate_oSQLConnections_vw for oSQLConnections_vw
102160>>>>
102160>>>Object oSQLConnections_vw is a dbView
102162>>>    Set Border_Style to Border_Thick
102163>>>    Set Size to 251 427
102164>>>    Set Location to 2 2
102165>>>    Set Label to "SQL Connections"
102166>>>    Set pbAutoActivate to True
102167>>>    Set Icon to "SQLConnections.ico"
102168>>>
102168>>>    Object oScrollingContainer1 is a cDbScrollingContainer
102170>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
102172>>>
102172>>>            Object oCurrentSettings_grp is a Group
102174>>>                Set Size to 232 402
102175>>>                Set Location to 6 12
102176>>>                Set Label to "Current Connection Settings"
102177>>>                Set peAnchors to anAll
102178>>>
102178>>>                Object oConnectionID_fm is a Form
102180>>>                    Set Size to 13 100
102181>>>                    Set Location to 12 68
102182>>>                    Set Label to "Connection ID"
102183>>>                    Set Label_Col_Offset to 2
102184>>>                    Set Label_Justification_Mode to JMode_Right
102185>>>                    Set Prompt_Button_Mode to PB_PromptOn
102186>>>                    Set Prompt_Object to (oSQLConnections(Self))
102187>>>
102187>>>                    Procedure Prompt
102190>>>                        String[] sTheData
102191>>>                        String sCurrentVal sNewVal
102191>>>                        Handle hoIniFile ho
102191>>>                        Integer iSize iCount
102191>>>                        tSQLConnection[] SQLConnectionArray
102191>>>                        tSQLConnection[] SQLConnectionArray
102192>>>
102192>>>                        Get phoSQLConnectionIniFile of ghoSQLConnectionHandler to hoIniFile
102193>>>                        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
102194>>>                        Move (SizeOfArray(SQLConnectionArray)) to iSize
102195>>>                        Decrement iSize
102196>>>                        For iCount from 0 to iSize
102202>>>>
102202>>>                            Move (SQLConnectionArray[iCount].sConnectionID + "|" + SQLConnectionArray[iCount].sDriverID) to sTheData[iCount]
102203>>>                        Loop
102204>>>>
102204>>>
102204>>>                        Get Value to sCurrentVal
102205>>>                        Get Prompt_Object to ho
102206>>>                        Set psTheData     of ho to sTheData
102207>>>
102207>>>                        Forward Send Prompt
102209>>>                        Get Value to sNewVal
102210>>>                        If (sCurrentVal <> sNewVal) Begin
102212>>>                            Send Cursor_Wait of Cursor_Control
102213>>>                            Set psConnectionID of ghoSQLConnectionHandler to sNewVal
102214>>>                            Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
102216>>>                            Send Cursor_Ready of Cursor_Control
102217>>>                            Send KeyAction of oTestLogin_btn
102218>>>                        End
102218>>>>
102218>>>                    End_Procedure
102219>>>
102219>>>                    Procedure Refresh
102222>>>                        String sValue
102222>>>                        Get psConnectionID of ghoSQLConnectionHandler to sValue
102223>>>                        Set Value to sValue
102224>>>                    End_Procedure
102225>>>
102225>>>                End_Object
102226>>>
102226>>>                Object oDatabase_fm is a Form
102228>>>                    Set Size to 13 91
102229>>>                    Set Location to 27 222
102230>>>                    Set Label to "Database"
102231>>>                    Set Label_Col_Offset to 2
102232>>>                    Set Label_Justification_Mode to JMode_Right
102233>>>                    Set Prompt_Button_Mode to PB_PromptOn
102234>>>                    Set Prompt_Object to (oDatabaseSelection_sl(Self))
102235>>>                    Set peAnchors to anNone
102236>>>                    Set Entry_State to False
102237>>>
102237>>>                    Procedure Refresh
102240>>>                        String sDatabase
102240>>>
102240>>>                        Get psDatabase of ghoSQLConnectionHandler to sDatabase
102241>>>                        Set Value to sDatabase
102242>>>                    End_Procedure
102243>>>
102243>>>                    Procedure Prompt
102246>>>                        String[] sTheData
102247>>>                        Handle ho
102247>>>                        String sDriverID
102247>>>
102247>>>                        Get Value of oDriverID_cf to sDriverID
102248>>>                        Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary sDriverID to sTheData
102249>>>
102249>>>                        Get Prompt_Object to ho
102250>>>                        Set psTheData of ho to sTheData
102251>>>
102251>>>                        Forward Send Prompt
102253>>>                    End_Procedure
102254>>>
102254>>>                    Procedure OnChange
102257>>>                        String sValue sOrgValue
102257>>>                        Get Value to sValue
102258>>>                        Get psDatabase of ghoSQLConnectionHandler to sOrgValue
102259>>>                        If (Uppercase(Trim(sValue)) <> Uppercase(Trim(sOrgValue))) Begin
102261>>>                            Set psDatabase of ghoSQLConnectionHandler to sValue
102262>>>                            Get psConnectionString of ghoSQLConnectionHandler to sValue
102263>>>                            Set Value of oConnectionString_fm to sValue
102264>>>                        End
102264>>>>
102264>>>                    End_Procedure
102265>>>
102265>>>                End_Object
102266>>>
102266>>>                Object oTrusted_cb is a CheckBox
102268>>>                    Set Size to 10 50
102269>>>                    Set Location to 45 68
102270>>>                    Set Label to "Use Trusted Connection"
102271>>>
102271>>>                    Procedure Refresh
102274>>>                        Boolean bValue
102274>>>                        Get pbTrusted of ghoSQLConnectionHandler to bValue
102275>>>                        Set Checked_State to bValue
102276>>>                    End_Procedure
102277>>>
102277>>>                    Procedure OnChange
102280>>>                        Boolean bChecked
102280>>>
102280>>>                        Get Checked_State to bChecked
102281>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
102282>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
102283>>>                    End_Procedure
102284>>>
102284>>>                End_Object
102285>>>
102285>>>                Object oUserID_fm is a Form
102287>>>                    Set Size to 13 100
102288>>>                    Set Location to 57 68
102289>>>                    Set Label to "UserID"
102290>>>                    Set Label_Col_Offset to 2
102291>>>                    Set Label_Justification_Mode to JMode_Right
102292>>>
102292>>>                    Procedure Refresh
102295>>>                        String sValue
102295>>>                        Get psUserID of ghoSQLConnectionHandler to sValue
102296>>>                        Set Value to sValue
102297>>>                    End_Procedure
102298>>>
102298>>>                End_Object
102299>>>
102299>>>                Object oPassword_fm is a Form
102301>>>                    Set Size to 13 91
102302>>>                    Set Location to 57 222
102303>>>                    Set Label to "Password"
102304>>>                    Set Label_Col_Offset to 2
102305>>>                    Set Label_Justification_Mode to JMode_Right
102306>>>                    // Set psToolTip to "Note: The password form does _not_ have it's password state set to True because the view is for testing purposes only. And we can see the password - if set - from the connection string as well."
102306>>>                    Set psToolTip to "Press the 'Toggle Password' button to reveal the password"
102307>>>                    Set Password_State to True
102308>>>
102308>>>                    Procedure Refresh
102311>>>                        String sValue
102311>>>                        Get psPassword of ghoSQLConnectionHandler to sValue
102312>>>                        Set Value to sValue
102313>>>                    End_Procedure
102314>>>
102314>>>                End_Object
102315>>>
102315>>>                Object oViewPassword_btn is a cButtonDPI
102317>>>                    Set Size to 13 19
102318>>>                    Set Location to 57 319
102319>>>                    Set psToolTip to "Toggle password"  
102320>>>                    Set psImage to "PasswordView.ico"
102321>>>                    
102321>>>                    Property String psImageL "PasswordView.ico"
102323>>>                    Property String psImageU "PasswordViewUnlock.ico"
102325>>>                    
102325>>>                    Procedure OnClick                
102328>>>                        Boolean bState
102328>>>                        Get Password_State of oPassword_fm item 0 to bState
102329>>>                        Send Page_Object   of oPassword_fm False
102330>>>                        Set Password_State of oPassword_fm item 0 to (not(bState)) 
102331>>>                        Send Page_Object   of oPassword_fm True 
102332>>>                        Set psImage to (If(bState = False, psImageL(Self), psImageU(Self)))
102333>>>                    End_Procedure
102334>>>                
102334>>>                End_Object
102335>>>
102335>>>                Object oConnectionString_fm is a Form
102337>>>                    Set Size to 13 245
102338>>>                    Set Location to 75 68
102339>>>                    Set Label to "Connection String"
102340>>>                    Set Label_Col_Offset to 2
102341>>>                    Set Label_Justification_Mode to JMode_Right
102342>>>                    Set peAnchors to anTopLeftRight
102343>>>                    Set Enabled_State to False
102344>>>
102344>>>                    Procedure Refresh
102347>>>                        String sValue
102347>>>                        tSQLConnection SQLConnection
102347>>>                        tSQLConnection SQLConnection
102347>>>                        
102347>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
102348>>>                        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
102349>>>                        Set Value to sValue
102350>>>                    End_Procedure
102351>>>
102351>>>                End_Object
102352>>>
102352>>>                Object oTestLogin_btn is a cButtonDPI
102354>>>                    Set Size to 13 67
102355>>>                    Set Location to 75 319
102356>>>                    Set Label to "Test Login"
102357>>>                    Set peAnchors to anTopRight
102358>>>                    Set MultiLineState to True
102359>>>                    Set psToolTip to "Changes the connection string with any changes made and tries to login to the server with the connection string."
102360>>>                    Set FontWeight to fw_Bold
102361>>>                    Set psImage to "ActionLogin.ico"
102362>>>
102362>>>                    Procedure OnClick
102365>>>                        tSQLConnection SQLConnection
102365>>>                        tSQLConnection SQLConnection
102365>>>                        String sServer sDatabase sDriverID sUserID sPassword sConnectionID sConnectionString
102365>>>                        Boolean bTrusted bMertechDriver bLoginSuccessful
102365>>>                        Integer iDriverID
102365>>>                        Handle hoDriver
102365>>>
102365>>>                        Get Value of oDriverID_cf        to SQLConnection.sDriverID
102366>>>                        Get Value of oConnectionID_fm    to SQLConnection.sConnectionID
102367>>>                        Get Value of oServer_fm          to SQLConnection.sServer
102368>>>                        Get Value of oDatabase_fm        to SQLConnection.sDatabase
102369>>>                        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
102370>>>                        Get Value of oUserID_fm          to SQLConnection.sUserID
102371>>>                        Get Value of oPassword_fm        to SQLConnection.sPassword
102372>>>
102372>>>                        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
102373>>>
102373>>>                        Get DriverIndex of ghoSQLConnectionHandler SQLConnection.sDriverID to iDriverID
102374>>>                        If (iDriverID = 0) Begin
102376>>>                            Send Info_Box ("The driver" * SQLConnection.sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
102377>>>                            Procedure_Return
102378>>>                        End
102378>>>>
102378>>>
102378>>>                        Get IsMertechDriver of ghoSQLConnectionHandler SQLConnection.sDriverID to bMertechDriver
102379>>>                        If (bMertechDriver = False) Begin
102381>>>                            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
102384>>>                        End
102384>>>>
102384>>>
102384>>>                        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
102385>>>                        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
102386>>>                        Set psDriverID of hoDriver to SQLConnection.sDriverID
102387>>>                        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bLoginSuccessful
102388>>>                        Send Destroy   of hoDriver
102389>>>
102389>>>                        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
102390>>>                        If (LastErr <> CLIERR_LOGIN_UNSUCCESSFUL) Begin
102392>>>                            Move (Replace(("PWD=" + SQLConnection.sPassword), sConnectionString, "PWD=***")) to sConnectionString
102393>>>                            Set Value of oConnectionString_fm to sConnectionString
102394>>>                            Send Info_Box "Login Successful!"
102395>>>                        End
102395>>>>
102395>>>                        Else Begin
102396>>>                            Send Info_Box "Nope, that didn't work. Login failed."
102397>>>                        End
102397>>>>
102397>>>                        Broadcast Recursive Send Combo_Fill_List of (Client_Id(phoMainPanel(ghoApplication)))
102399>>>                        Move 0 to LastErr
102400>>>                    End_Procedure
102401>>>
102401>>>                End_Object
102402>>>
102402>>>                Object oInfo_tb is a TextBox
102404>>>                    Set Auto_Size_State to False
102405>>>                    Set Size to 18 303
102406>>>                    Set Location to 106 8
102407>>>                    Set Label to "Note: The above settings was read from the SQLConnections.ini file when the object was created and are properties of the 'ghoSQLConnectionHandler' object."
102408>>>                    Set Justification_Mode to JMode_Left
102409>>>                    Set FontItalics to True
102410>>>                End_Object
102411>>>
102411>>>                Object oDriverID_cf is a ComboForm
102413>>>                    Set Size to 11 91
102414>>>                    Set Location to 13 222
102415>>>                    Set Label_Col_Offset to 2
102416>>>                    Set Label_Justification_Mode to JMode_Right
102417>>>                    Set Label to "Driver ID"
102418>>>                    Set Entry_State to False
102419>>>                    Set Enabled_State to False
102420>>>
102420>>>                    Procedure Combo_Fill_List
102423>>>                        Send Combo_Add_Item MSSQLDRV_ID
102424>>>                        Send Combo_Add_Item DB2_DRV_ID
102425>>>                        Send Combo_Add_Item ODBC_DRV_ID
102426>>>                        Send Combo_Add_Item SQLFLEX
102427>>>                        Send Combo_Add_Item MDSDB2
102428>>>                        Send Combo_Add_Item MDSMySQL
102429>>>                        Send Combo_Add_Item MDSPgSQL
102430>>>                        Send Combo_Add_Item ORAFLEX
102431>>>                    End_Procedure
102432>>>
102432>>>                    Procedure OnChange
102435>>>                        String sValue sOrgValue
102435>>>                        Boolean bEnabled bChecked
102435>>>
102435>>>                        Get Value to sValue
102436>>>                        Get psDriverID of ghoSQLConnectionHandler to sOrgValue
102437>>>                        If (sValue <> "" and sValue <> sOrgValue and sValue <> "None") Begin
102439>>>                            Set psDriverID of ghoSQLConnectionHandler to sValue
102440>>>                        End
102440>>>>
102440>>>                        Move (sValue <> "None") to bEnabled
102441>>>                        Broadcast Set Enabled_State of (Parent(Self)) to bEnabled
102443>>>                        Set Enabled_State to False
102444>>>                        Set Enabled_State of oConnectionString_fm to False
102445>>>                        Set Enabled_State of oDatabase_fm to (sValue <> DB2_DRV_ID)
102446>>>
102446>>>                        Get Checked_State of oTrusted_cb  to bChecked
102447>>>                        Set Enabled_State of oUserID_fm   to (bChecked = False)
102448>>>                        Set Enabled_State of oPassword_fm to (bChecked = False)
102449>>>                    End_Procedure
102450>>>
102450>>>                    Procedure Refresh
102453>>>                        String sValue
102453>>>
102453>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
102454>>>                        Set Value to sValue
102455>>>                    End_Procedure
102456>>>
102456>>>                End_Object
102457>>>
102457>>>                Object oServer_fm is a Form
102459>>>                    Set Size to 13 100
102460>>>                    Set Location to 27 68
102461>>>                    Set Label to "Server"
102462>>>                    Set Label_Col_Offset to 2
102463>>>                    Set Label_Justification_Mode to JMode_Right
102464>>>                    Set Prompt_Button_Mode to PB_PromptOn
102465>>>                    Set Prompt_Object to (oServerSelection_sl(Self))
102466>>>
102466>>>                    Procedure Refresh
102469>>>                        String sValue
102469>>>                        Get psServer of ghoSQLConnectionHandler to sValue
102470>>>                        Set Value to sValue
102471>>>                    End_Procedure
102472>>>
102472>>>                    Procedure Prompt
102475>>>                        String[] sTheData
102476>>>                        String sDriverID
102476>>>                        Handle ho
102476>>>
102476>>>                        Send Cursor_Wait of Cursor_Control
102477>>>                        Get Prompt_Object to ho
102478>>>                        Get Value of oDriverID_cf to sDriverID
102479>>>                        Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID 2 to sTheData
102480>>>                        Set psTheData of ho to sTheData
102481>>>                        Send Cursor_Ready of Cursor_Control
102482>>>
102482>>>                        Forward Send Prompt
102484>>>                    End_Procedure
102485>>>
102485>>>                End_Object
102486>>>
102486>>>                Object oRunSQLConnectionsProgram_btn is a cButtonDPI
102488>>>                    Set Size to 21 75
102489>>>                    Set Location to 106 319
102490>>>                    Set Label to "SQL Connections Manager"
102491>>>                    Set peAnchors to anTopRight
102492>>>                    Set MultiLineState to True
102493>>>                    Set psImage to "SQLConnections.ico"
102494>>>
102494>>>                    Procedure OnClick
102497>>>                        Runprogram Background "SQLConnections.exe"
102498>>>                    End_Procedure
102499>>>
102499>>>                End_Object
102500>>>
102500>>>                Procedure Page Integer iPageObject
102503>>>//                    Broadcast Send Refresh
102503>>>                    Broadcast Recursive Send Refresh of (phoMainPanel(ghoApplication))
102505>>>                    Forward Send Page iPageObject
102507>>>                End_Procedure
102508>>>
102508>>>            End_Object
102509>>>
102509>>>        End_Object
102510>>>
102510>>>    End_Object
102511>>>
102511>>>End_Object
102512>        Use SQLFunctions.vw
Including file: SQLFunctions.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\SQLFunctions.vw)
102512>>>Use Windows.pkg
102512>>>Use DFClient.pkg
102512>>>Use Dfspnfrm.pkg
102512>>>Use cDbScrollingContainer.pkg
102512>>>Use cButtonDPI.pkg
102512>>>Use cDbUpdateFunctionLibrary.pkg
102512>>>Use SQLDatabaseBackup.dg
102512>>>
102512>>>Activate_View Activate_oSQLFunctions_vw for oSQLFunctions_vw
102522>>>>
102522>>>Object oSQLFunctions_vw is a dbView
102524>>>    Set Border_Style to Border_Thick
102525>>>    Set Size to 260 426
102526>>>    Set Location to -4 2
102527>>>    Set Label to "SQL Functions"
102528>>>    Set pbAutoActivate to True
102529>>>    Set Icon to "Sql.ico"
102530>>>
102530>>>    Procedure OnSetFocus
102533>>>        String sValue
102533>>>        tSQLConnection SQLConnection
102533>>>        tSQLConnection SQLConnection
102533>>>        
102533>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
102534>>>        Set Value of oSQLDatabase_fm to SQLConnection.sDatabase
102535>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
102536>>>        Set Value of oSQLConnectionString_fm to sValue
102537>>>    End_Procedure
102538>>>
102538>>>    Object oScrollingContainer1 is a cDbScrollingContainer
102540>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
102542>>>
102542>>>            Object oSQLFunctionTests_grp is a Group
102544>>>                Set Size to 243 402
102545>>>                Set Location to 7 12
102546>>>                Set Label to "Tests: Change SQL Database with Specialized SQL Functions"
102547>>>                Set peAnchors to anAll
102548>>>
102548>>>                Object oSQLConnectionString_fm is a Form
102550>>>                    Set Size to 13 375
102551>>>                    Set Location to 23 14
102552>>>                    Set Label to "Current Connection String Settings:"
102553>>>                    Set Label_Col_Offset to 0
102554>>>                    Set Label_Justification_Mode to JMode_Top
102555>>>                    Set peAnchors to anTopLeftRight
102556>>>                    Set Enabled_State to False
102557>>>                    Set Label_Row_Offset to 1
102558>>>                End_Object
102559>>>
102559>>>                Object oSQLDatabase_fm is a Form
102561>>>                    Set Size to 13 86
102562>>>                    Set Location to 50 14
102563>>>                    Set Label to "Database:"
102564>>>                    Set Label_Col_Offset to 0
102565>>>                    Set Label_Justification_Mode to JMode_Top
102566>>>                    Set Label_Row_Offset to 1
102567>>>                    Set FontWeight to fw_Bold
102568>>>                    Set Enabled_State to False
102569>>>                End_Object
102570>>>
102570>>>                Object oDriverID2_cf is a ComboForm
102572>>>                    Set Size to 11 91
102573>>>                    Set Location to 50 121
102574>>>                    Set Label_Col_Offset to 0
102575>>>                    Set Label_Justification_Mode to JMode_Top
102576>>>                    Set Label to "Driver ID:"
102577>>>                    Set Entry_State to False
102578>>>                    Set Enabled_State to False
102579>>>                    Set Label_Row_Offset to 1
102580>>>
102580>>>                    Procedure Combo_Fill_List
102583>>>                        Send Combo_Add_Item MSSQLDRV_ID
102584>>>                        Send Combo_Add_Item DB2_DRV_ID
102585>>>                        Send Combo_Add_Item ODBC_DRV_ID
102586>>>                        Send Combo_Add_Item SQLFLEX
102587>>>                        Send Combo_Add_Item MDSDB2
102588>>>                        Send Combo_Add_Item MDSMySQL
102589>>>                        Send Combo_Add_Item MDSPgSQL
102590>>>                        Send Combo_Add_Item ORAFLEX
102591>>>                    End_Procedure
102592>>>
102592>>>                    Procedure Refresh
102595>>>                        String sValue
102595>>>
102595>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
102596>>>                        Set Value to sValue
102597>>>                    End_Procedure
102598>>>
102598>>>                End_Object
102599>>>
102599>>>                Object oBackupSQLDatabase_btn is a cButtonDPI
102601>>>                    Set Size to 14 109
102602>>>                    Set Location to 49 220
102603>>>                    Set Label to "Backup MS-SQL Database"  
102604>>>                    Set psImage to "DdBackup.ico"
102605>>>
102605>>>                    Procedure OnClick
102608>>>                        Boolean bOK
102608>>>                        String sDatabase sPath sBackupName
102608>>>
102608>>>                        // SQLDatabaseBackup dialog:
102608>>>                        Get MakeSQLDatabaseBackup to bOK
102609>>>
102609>>>                        If (bOK = True) Begin
102611>>>                            Send Info_Box "The backup of the database was successful!"
102612>>>                        End
102612>>>>
102612>>>                        Else Begin
102613>>>                            Send Info_Box "The database was not backup up"
102614>>>                        End
102614>>>>
102614>>>                    End_Procedure
102615>>>
102615>>>                End_Object
102616>>>
102616>>>                Object oDatabaseInfo_tb is a TextBox
102618>>>                    Set Auto_Size_State to False
102619>>>                    Set Size to 25 96
102620>>>                    Set Location to 64 14
102621>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
102622>>>                    Set Justification_Mode to JMode_Left
102623>>>                End_Object
102624>>>
102624>>>                Object oSQLInfo_tb is a TextBox
102626>>>                    Set Auto_Size_State to False
102627>>>                    Set Size to 37 270
102628>>>                    Set Location to 76 118
102629>>>                    Set Label to "Note: The DataFlex database API is NOT used here. Instead all is done with specialized embedded SQL (ESQL) funtions from the cDbUpdateFunctionLibrary. This is because an API 'Structure_End' command could drop and rebuild the whole table (!). That can take a long time..."
102630>>>                    Set Justification_Mode to JMode_Left
102631>>>                End_Object
102632>>>
102632>>>                Object oSQLTableName_cf is a ComboForm
102634>>>                    Set Size to 11 96
102635>>>                    Set Location to 106 14
102636>>>                    Set Label_Col_Offset to 0
102637>>>                    Set Label_Justification_Mode to JMode_Top
102638>>>                    Set Label to "Select Table:"
102639>>>                    Set Label_Row_Offset to 1
102640>>>                    Set Entry_State to False
102641>>>
102641>>>                    Procedure OnDropDown
102644>>>                        Send DoCombo_Fill_List
102645>>>                    End_Procedure
102646>>>
102646>>>                    Procedure OnCloseUp
102649>>>                        Send Delete_Data of oSQLColumnName_cf
102650>>>                    End_Procedure
102651>>>
102651>>>                    Procedure DoCombo_Fill_List
102654>>>                        String[] sTablesArray
102655>>>                        String sDriverID sConnectionString
102655>>>                        Integer iCount iSize
102655>>>
102655>>>                        Send Delete_Data
102656>>>                        Get Value of oDriverID2_cf to sDriverID
102657>>>                        Get SQLUtilEnumerateTables of ghoDbUpdateFunctionLibrary sDriverID to sTablesArray
102658>>>                        Move (SizeOfArray(sTablesArray)) to iSize
102659>>>                        Decrement iSize
102660>>>                        For iCount from 0 to iSize
102666>>>>
102666>>>                            Send Combo_Add_Item sTablesArray[iCount]
102667>>>                        Loop
102668>>>>
102668>>>                    End_Procedure
102669>>>
102669>>>                    // DataFlex bug. It has been here as long as I can remember and _never_ seems to be fixed :-(
102669>>>                    // Augmented Value function.
102669>>>                    // We need to use Wincombo_x messages. Probably due to sync reasons.
102669>>>                    // When e.g. OnCloseUp is fired the data_value still holds the old value.
102669>>>                    Function Value Integer iItem Returns String
102672>>>                        Integer iRetval
102672>>>                        String sValue
102672>>>                        Get WinCombo_Current_Item      to iItem
102673>>>                        Get WinCombo_Value item iItem  to sValue
102674>>>                        Function_Return sValue
102675>>>                    End_Function
102676>>>
102676>>>                End_Object
102677>>>
102677>>>                Object oSQLColumnName_cf is a ComboForm
102679>>>                    Set Size to 11 96
102680>>>                    Set Location to 134 14
102681>>>                    Set Label_Col_Offset to 0
102682>>>                    Set Label_Justification_Mode to JMode_Top
102683>>>                    Set Label to "Select Column:"
102684>>>                    Set Label_Row_Offset to 1
102685>>>                    Set Entry_State to False
102686>>>
102686>>>                    Procedure DoCombo_Fill_List
102689>>>                        String[] sColumnsArray
102690>>>                        String sTableName sDriverID
102690>>>                        Integer iCount iSize
102690>>>
102690>>>                        Send Delete_Data
102691>>>                        Get Value of oDriverID2_cf    to sDriverID
102692>>>                        Get Value of oSQLTableName_cf to sTableName
102693>>>                        Get SQLUtilEnumerateColumns of ghoDbUpdateFunctionLibrary sDriverID sTableName to sColumnsArray
102694>>>                        Move (SizeOfArray(sColumnsArray)) to iSize
102695>>>                        Decrement iSize
102696>>>                        For iCount from 0 to iSize
102702>>>>
102702>>>                            Send Combo_Add_Item sColumnsArray[iCount]
102703>>>                        Loop
102704>>>>
102704>>>                        If (iSize > 1) Begin
102706>>>                            Set Current_Item to 1
102707>>>                        End
102707>>>>
102707>>>                    End_Procedure
102708>>>
102708>>>                    Procedure OnDropDown
102711>>>                        Send DoCombo_Fill_List
102712>>>                    End_Procedure
102713>>>                End_Object
102714>>>
102714>>>                Object oSQLRenameColumnTo_fm is a Form
102716>>>                    Set Size to 13 96
102717>>>                    Set Location to 133 116
102718>>>                    Set Label_Col_Offset to 0
102719>>>                    Set Label_Justification_Mode to JMode_Top
102720>>>                    Set Label to "Rename Column To:"
102721>>>                    Set Label_Row_Offset to 1
102722>>>                    Set Value to "NewColumnName"
102723>>>                End_Object
102724>>>
102724>>>                Object oSQLRenameColumn_btn is a cButtonDPI
102726>>>                    Set Size to 13 69
102727>>>                    Set Location to 133 220
102728>>>                    Set Label to "Rename Column"
102729>>>                    Set psToolTip to "Test of SQLColumnRename function"
102730>>>                    Set MultiLineState to True
102731>>>
102731>>>                    Procedure OnClick
102734>>>                        Boolean bOk bExists
102734>>>                        Handle hTable hoSQLQuery
102734>>>                        String sTableName sColumnName sNewColumnName sDriverID
102734>>>
102734>>>                        Get Value of oSQLTableName_cf to sTableName
102735>>>                        If (sTableName = "") Begin
102737>>>                            Send Info_Box "You need to select a table first..."
102738>>>                            Procedure_Return
102739>>>                        End
102739>>>>
102739>>>                        Get Value of oSQLColumnName_cf to sColumnName
102740>>>                        If (Uppercase(sColumnName) = "RECNUM" or sColumnName = "") Begin
102742>>>                            Send Info_Box "You need to select a column (and 'RECNUM' cannot be used)"
102743>>>                            Procedure_Return
102744>>>                        End
102744>>>>
102744>>>                        Get Value of oSQLRenameColumnTo_fm to sNewColumnName
102745>>>                        If (Trim(sNewColumnName) = "") Begin
102747>>>                            Send Info_Box "You need to enter a column name to rename to..."
102748>>>                            Procedure_Return
102749>>>                        End
102749>>>>
102749>>>
102749>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
102750>>>                        If (hTable = 0) Begin
102752>>>                            Send Info_Box "Sorry, no free fileslot in filelist.cfg could be found. Cannot continue changing table."
102753>>>                            Procedure_Return
102754>>>                        End
102754>>>>
102754>>>
102754>>>                        Get Value of oDriverID2_cf to sDriverID
102755>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
102756>>>                        Get SqlColumnRenameByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName sNewColumnName to bOk
102757>>>                        If (bOk = True) Begin
102759>>>                            // Better delete the combo values after a successful rename as it looks odd to show the old column name...
102759>>>                            Send Delete_Data of oSQLColumnName_cf
102760>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully renamed to" * sNewColumnName * "for table:" * sTableName)
102761>>>                        End
102761>>>>
102761>>>                        Else Begin
102762>>>                            Send Info_Box "Nope, that didn't work..."
102763>>>                        End
102763>>>>
102763>>>
102763>>>                    End_Procedure
102764>>>
102764>>>                End_Object
102765>>>
102765>>>                Object oSQLRemoveColumn_btn is a cButtonDPI
102767>>>                    Set Size to 13 91
102768>>>                    Set Location to 133 297
102769>>>                    Set Label to "Drop Column"
102770>>>                    Set MultiLineState to True
102771>>>                    Set psToolTip to "Test of SQLColumnRemove function" 
102772>>>                    Set psImage to "DeleteColumn.ico"
102773>>>
102773>>>                    Procedure OnClick
102776>>>                        Boolean bOk bExists bInitialize
102776>>>                        Handle hTable hoSQLQuery
102776>>>                        String sTableName sColumnName sSQLString sType sColumnValue sDriverID
102776>>>                        Integer iRetval
102776>>>
102776>>>                        Get Value of oDriverID2_cf              to sDriverID
102777>>>                        Get Value of oSQLTableName_cf           to sTableName
102778>>>                        Get Value of oSQLColumnName_cf          to sColumnName
102779>>>
102779>>>                        If (sTableName = "" or sColumnName = "") Begin
102781>>>                            Send Info_Box "You first need to select a table and a column."
102782>>>                            Procedure_Return
102783>>>                        End
102783>>>>
102783>>>
102783>>>                        Get YesNo_Box ("This will remove (drop) the column named:" * sColumnName * "from table:" * sTableName + ". Are you sure?") to iRetval
102784>>>                        If (iRetval <> MBR_Yes) Begin
102786>>>                            Procedure_Return
102787>>>                        End
102787>>>>
102787>>>
102787>>>                        Get SqlColumnRemoveByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOk
102788>>>
102788>>>                        If (bOk = True) Begin
102790>>>                            // Better delete the combo values after a successful operation as it looks odd to show the old column name...
102790>>>                            Send Delete_Data of oSQLColumnName_cf
102791>>>                            Send Info_Box ("Column" * sColumnName + ", was successfully removed")
102792>>>                        End
102792>>>>
102792>>>                        Else Begin
102793>>>                            Send Info_Box ("The column could NOT be removed. Either the column" * sColumnName * "doesn't exists or the current Database is incorrect?")
102794>>>                            Procedure_Return
102795>>>                        End
102795>>>>
102795>>>
102795>>>                    End_Procedure
102796>>>
102796>>>                End_Object
102797>>>
102797>>>                Object oSQLAddColumnName_fm is a Form
102799>>>                    Set Size to 13 96
102800>>>                    Set Location to 177 14
102801>>>                    Set Label_Col_Offset to 0
102802>>>                    Set Label_Justification_Mode to JMode_Top
102803>>>                    Set Label to "Column Name:"
102804>>>                    Set Label_Row_Offset to 1
102805>>>                    Set Value to "NewColumn"
102806>>>                End_Object
102807>>>
102807>>>                Object oSQLColumnType_cf is a ComboForm
102809>>>                    Set Size to 11 96
102810>>>                    Set Location to 178 116
102811>>>                    Set Label_Col_Offset to 0
102812>>>                    Set Label_Justification_Mode to JMode_Top
102813>>>                    Set Label_Row_Offset to 1
102814>>>                    Set Label to "Type:"
102815>>>                    Set Entry_State to False
102816>>>
102816>>>                    Procedure Combo_Fill_List
102819>>>                        tColumnType[] ColumnTypeArray
102819>>>                        tColumnType[] ColumnTypeArray
102820>>>                        Integer iSize iCount iDbType
102820>>>                        String sDriverID
102820>>>
102820>>>                        Send Delete_Data
102821>>>                        Get Value of oDriverID2_cf to sDriverID
102822>>>                        Get piDbType of ghoDbUpdateFunctionLibrary to iDbType
102823>>>                        Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary sDriverID iDbType to ColumnTypeArray
102824>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
102825>>>                        Decrement iSize
102826>>>                        For iCount from 0 to iSize
102832>>>>
102832>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sType
102833>>>                        Loop     
102834>>>>
102834>>>                        If (iSize > 0) Begin
102836>>>                            Set Value to ColumnTypeArray[0].sType
102837>>>                        End
102837>>>>
102837>>>                    End_Procedure
102838>>>
102838>>>                    Procedure OnChange
102841>>>                        String sType sPrecision
102841>>>                        Integer iType iSize iDec
102841>>>                        tSQLConnection SQLConnection
102841>>>                        tSQLConnection SQLConnection
102841>>>                        Boolean bFixed
102841>>>
102841>>>                        Get SelectedType to iType
102842>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
102843>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iSize
102844>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to iDec
102845>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType iType to bFixed
102846>>>
102846>>>                        Set Enabled_State of oSQLLength_sf   to (bFixed = False)
102847>>>                        Set Enabled_State of oSQLDecimals_sf to (bFixed = False)
102848>>>                        Set Value         of oSQLLength_sf   to iSize
102849>>>                        If (iDec = 0) Begin
102851>>>                            Set Value     of oSQLDecimals_sf to ""
102852>>>                        End
102852>>>>
102852>>>                        Else Begin
102853>>>                            Set Value     of oSQLDecimals_sf to iDec
102854>>>                        End
102854>>>>
102854>>>                        If (bFixed = False) Begin
102856>>>                            Set Enabled_State of oSQLDecimals_sf to (iDec <> 0)
102857>>>                        End
102857>>>>
102857>>>                    End_Procedure
102858>>>
102858>>>                    Function SelectedType Returns Integer
102861>>>                        String sValue sDriverID
102861>>>                        Integer iType iDbType
102861>>>
102861>>>                        Get Value to sValue
102862>>>                        Get psDriverID of ghoSQLConnectionHandler to sDriverID
102863>>>                        Get piDbType   of ghoSQLConnectionHandler to iDbType
102864>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary sDriverID iDbType sValue to iType
102865>>>
102865>>>                        Function_Return iType
102866>>>                    End_Function
102867>>>
102867>>>                End_Object
102868>>>
102868>>>                Object oSQLAddColumn_btn is a cButtonDPI
102870>>>                    Set Size to 13 69
102871>>>                    Set Location to 177 220
102872>>>                    Set Label to "Add Column"
102873>>>                    Set MultiLineState to True
102874>>>                    Set psToolTip to "Test of SQLColumnAdd function"  
102875>>>                    Set psImage to "AddColumn.ico"
102876>>>
102876>>>                    Procedure OnClick
102879>>>                        Boolean bOk bExists bInitialize
102879>>>                        Handle hTable hoSQLQuery
102879>>>                        String sTableName sColumnName sSQLString sType sColumnValue sDriverID
102879>>>                        Integer iType iLength iDecimals
102879>>>
102879>>>                        Get Value of oDriverID2_cf              to sDriverID
102880>>>                        Get Value of oSQLTableName_cf           to sTableName
102881>>>                        Get Value of oSQLAddColumnName_fm       to sColumnName
102882>>>                        Get SelectedType  of oSQLColumnType_cf  to iType
102883>>>                        Get Value         of oSQLColumnType_cf  to sType
102884>>>                        Get Checked_State of oSQLInitializeColumnValue_cb to bInitialize
102885>>>                        Get Value         of oSQLColumnValue_fm to sColumnValue
102886>>>                        Get Value         of oSQLLength_sf      to iLength
102887>>>                        Get Value         of oSQLDecimals_sf    to iDecimals
102888>>>
102888>>>                        If (sTableName <> "") Begin
102890>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
102891>>>                            If (hTable = 0) Begin
102893>>>                                Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
102894>>>                            End
102894>>>>
102894>>>                        End
102894>>>>
102894>>>                        If (hTable = 0) Begin
102896>>>                            Send Info_Box "You first need to select a table before you can add a column to it."
102897>>>                            Procedure_Return
102898>>>                        End
102898>>>>
102898>>>                        If (sColumnName = "") Begin
102900>>>                            Send Info_Box "You need to enter a column name"
102901>>>                            Procedure_Return
102902>>>                        End
102902>>>>
102902>>>
102902>>>                        Get SqlColumnAddByTableName of ghoDbUpdateFunctionLibrary sTableName sColumnName iType iLength iDecimals bInitialize sColumnValue to bOk
102903>>>
102903>>>                        If (bOk = True) Begin
102905>>>                            Send Info_Box ("New column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName)
102906>>>                        End
102906>>>>
102906>>>                        Else Begin
102907>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
102908>>>                            Procedure_Return
102909>>>                        End
102909>>>>
102909>>>
102909>>>                    End_Procedure
102910>>>
102910>>>                End_Object
102911>>>
102911>>>//                Object oTest_btn is a cButtonDPI
102911>>>//                    Set Size to 13 92
102911>>>//                    Set Location to 177 298
102911>>>//                    Set Label to "Test SQL script button"
102911>>>//
102911>>>//                    Procedure OnClick
102911>>>//                        Boolean bOK
102911>>>//                        String sTableName sColumnName
102911>>>//
102911>>>//                        Get Value of oSQLTableName_cf      to sTableName
102911>>>//                        Get Value of oSQLAddColumnName_fm  to sColumnName
102911>>>////                        Get SqlUtilDefaultConstraintsMSSQL of ghoDbUpdateFunctionLibrary sTableName sColumnName to bOK
102911>>>//
102911>>>//                    End_Procedure
102911>>>//
102911>>>//                End_Object
102911>>>
102911>>>                Object oSQLLength_sf is a SpinForm
102913>>>                    Set Label to "Length:"
102914>>>                    Set Size to 13 40
102915>>>                    Set Location to 202 16
102916>>>                    Set Label_Col_Offset to 0
102917>>>                    Set Label_Justification_Mode to JMode_Top
102918>>>                    Set Label_Row_Offset to 1
102919>>>                    Set Value to "10"
102920>>>                    Set Maximum_Position to 500
102921>>>                    Set Minimum_Position to 1
102922>>>                End_Object
102923>>>
102923>>>                Object oSQLDecimals_sf is a SpinForm
102925>>>                    Set Label to "Decimals:"
102926>>>                    Set Size to 13 33
102927>>>                    Set Location to 202 60
102928>>>                    Set Label_Col_Offset to 0
102929>>>                    Set Label_Justification_Mode to JMode_Top
102930>>>                    Set Label_Row_Offset to 1
102931>>>                    Set Value to "0"
102932>>>                    Set Maximum_Position to 16
102933>>>                    Set Minimum_Position to 1
102934>>>                End_Object
102935>>>
102935>>>                Object oSQLInitializeColumnValue_cb is a CheckBox
102937>>>                    Set Size to 10 50
102938>>>                    Set Location to 203 116
102939>>>                    Set Label to "Initialize Column Value"
102940>>>
102940>>>                    Procedure OnChange
102943>>>                        Boolean bChecked
102943>>>
102943>>>                        Get Checked_State to bChecked
102944>>>                        Set Enabled_State of oSQLColumnValue_fm to bChecked
102945>>>                    End_Procedure
102946>>>
102946>>>                End_Object
102947>>>
102947>>>                Object oSQLColumnValue_fm is a Form
102949>>>                    Set Size to 13 96
102950>>>                    Set Location to 218 116
102951>>>                    Set Label_Col_Offset to 2
102952>>>                    Set Label_Justification_Mode to JMode_Right
102953>>>                    Set Label to "Column Value"
102954>>>                    Set psToolTip to "When a new column is added the new column can be initialized with a value for all existing records."
102955>>>                    Set Enabled_State to False
102956>>>                End_Object
102957>>>
102957>>>                Object oEnumRelations_btn is a cButtonDPI
102959>>>                    Set Size to 13 91
102960>>>                    Set Location to 116 297
102961>>>                    Set Label to "Test Enum SQL Relations"
102962>>>
102962>>>                    Procedure OnClick
102965>>>                        tSQLRelation[] SQLRelationArray
102965>>>                        tSQLRelation[] SQLRelationArray
102966>>>                        String sTableName sDriverID
102966>>>                        Integer iSize iCount
102966>>>
102966>>>                        Get Value of oDriverID2_cf to sDriverID
102967>>>                        Get Value of oSQLTableName_cf to sTableName
102968>>>                        Get SqlUtilEnumerateRelations of ghoDbUpdateFunctionLibrary sTableName sDriverID to SQLRelationArray
102969>>>                        Move (SizeOfArray(SQLRelationArray)) to iSize
102970>>>                        Decrement iSize
102971>>>                        For iCount from 0 to iSize
102977>>>>
102977>>>                            Showln "Tablename.FieldName = " SQLRelationArray[iCount].sFileName "." SQLRelationArray[iCount].sFieldName " Number: " SQLRelationArray[iCount].iFileNumber "." SQLRelationArray[iCount].iFieldNumber
102986>>>                        Loop
102987>>>>
102987>>>                        If (iSize < 1) Begin
102989>>>                            Send Info_Box ("No SQL Foreign keys found for table:" * sTableName)
102990>>>                        End
102990>>>>
102990>>>
102990>>>                    End_Procedure
102991>>>
102991>>>                End_Object
102992>>>
102992>>>                Object oEnumerateLoggedInUsers is a cButtonDPI
102994>>>                    Set Size to 13 101
102995>>>                    Set Location to 177 297
102996>>>                    Set Label to "Enumerate Logged In Users"
102997>>>
102997>>>                    Procedure OnClick
103000>>>                        tSQLLoggedInUser[] SQLLoggedInUser
103000>>>                        tSQLLoggedInUser[] SQLLoggedInUser
103001>>>                        String sDriverID sDatabase
103001>>>                        Integer iSize iCount
103001>>>
103001>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
103002>>>                        Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
103003>>>                        Get SqlUtilEnumerateLoggedInUsers of ghoDbUpdateFunctionLibrary sDriverID sDatabase to SQLLoggedInUser
103004>>>                        Move (SizeOfArray(SQLLoggedInUser)) to iSize
103005>>>                        Decrement iSize
103006>>>
103006>>>                        Showln "SQL User Name" " and Program:"
103009>>>                        For iCount from 0 to iSize
103015>>>>
103015>>>                            Showln SQLLoggedInUser[iCount].sUser " " SQLLoggedInUser[iCount].sProgram
103019>>>                        Loop
103020>>>>
103020>>>                    End_Procedure
103021>>>
103021>>>                End_Object
103022>>>
103022>>>                Object oEnumerateTablesAndViews is a cButtonDPI
103024>>>                    Set Size to 13 101
103025>>>                    Set Location to 193 297
103026>>>                    Set Label to "Is Table or View?"
103027>>>
103027>>>                    Procedure OnClick
103030>>>                        String sDriverID sTableName
103030>>>                        Handle hTable
103030>>>                        Boolean bViewTableType
103030>>>
103030>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
103031>>>                        Get Value of oSQLTableName_cf to sTableName
103032>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
103033>>>                        If (hTable = 0) Begin
103035>>>                            Procedure_Return
103036>>>                        End
103036>>>>
103036>>>                        Get SQLUtilTableIsViewType of ghoDbUpdateFunctionLibrary sDriverID hTable to bViewTableType
103037>>>                        Send Info_Box ("The table" * sTableName * "is a" * If(bViewTableType = True, "View Table Type", "Standard Table (not view)"))
103038>>>                    End_Procedure
103039>>>
103039>>>                End_Object
103040>>>
103040>>>            End_Object
103041>>>
103041>>>        End_Object
103042>>>
103042>>>    End_Object
103043>>>
103043>>>End_Object
103044>        Use APIFunctions.vw
Including file: APIFunctions.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\APIFunctions.vw)
103044>>>Use Windows.pkg
103044>>>Use DFClient.pkg
103044>>>Use Dfspnfrm.pkg
103044>>>Use Dfline.pkg
103044>>>Use cDbScrollingContainer.pkg
103044>>>Use cButtonDPI.pkg
103044>>>Use cDbUpdateFunctionLibrary.pkg
103044>>>
103044>>>Define CI_Table1_FileNo for 401
103044>>>Define CI_View1_FileNo  for 402
103044>>>
103044>>>Activate_View Activate_oAPIFunctions_vw for oAPIFunctions_vw
103054>>>>
103054>>>Object oAPIFunctions_vw is a dbView
103056>>>    Set Border_Style to Border_Thick
103057>>>    Set Size to 237 424
103058>>>    Set Location to 2 2
103059>>>    Set Label to "API Functions"
103060>>>    Set pbAutoActivate to True
103061>>>    Set Icon to "APIFunctions.ico"
103062>>>
103062>>>    Property String psTableName ""
103064>>>
103064>>>    Procedure OnSetFocus
103067>>>        String sValue
103067>>>        tSQLConnection SQLConnection
103067>>>        tSQLConnection SQLConnection
103067>>>        
103067>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
103068>>>        Set Value of oApiDatabase_fm to SQLConnection.sDatabase
103069>>>        Move (Replace(("PWD=" + SQLConnection.sPassword), SQLConnection.sConnectionString, "PWD=***")) to sValue
103070>>>        Set Value of oApiConnectionString_fm to sValue
103071>>>    End_Procedure
103072>>>
103072>>>    Object oScrollingContainer1 is a cDbScrollingContainer
103074>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
103076>>>
103076>>>            Object oApiFunctions_grp is a Group
103078>>>                Set Size to 222 402
103079>>>                Set Location to 6 12
103080>>>                Set Label to "Tests: Change MS-SQL Database with Database API Functions"
103081>>>                Set peAnchors to anAll
103082>>>
103082>>>                Object oApiConnectionString_fm is a Form
103084>>>                    Set Size to 13 368
103085>>>                    Set Location to 23 14
103086>>>                    Set Label to "Current Connection String Settings:"
103087>>>                    Set Label_Col_Offset to 0
103088>>>                    Set Label_Justification_Mode to JMode_Top
103089>>>                    Set peAnchors to anTopLeftRight
103090>>>                    Set Enabled_State to False
103091>>>                    Set Label_Row_Offset to 1
103092>>>                End_Object
103093>>>
103093>>>                Object oApiDatabase_fm is a Form
103095>>>                    Set Size to 13 86
103096>>>                    Set Location to 50 14
103097>>>                    Set Label to "Database:"
103098>>>                    Set Label_Col_Offset to 0
103099>>>                    Set Label_Justification_Mode to JMode_Top
103100>>>                    Set Label_Row_Offset to 1
103101>>>                    Set Enabled_State to False
103102>>>                    Set FontWeight to fw_Bold
103103>>>//                    Set Label_FontWeight to fw_Bold
103103>>>
103103>>>                    Procedure Page Integer iPageObject
103106>>>                        String sValue
103106>>>                        Get psDatabase of ghoSQLConnectionHandler to sValue
103107>>>                        Set Value to sValue
103108>>>
103108>>>                        Forward Send Page iPageObject
103110>>>                    End_Procedure
103111>>>
103111>>>                End_Object
103112>>>
103112>>>                Object oDriverID3_cf is a ComboForm
103114>>>                    Set Size to 11 91
103115>>>                    Set Location to 51 121
103116>>>                    Set Label_Col_Offset to 0
103117>>>                    Set Label_Justification_Mode to JMode_Top
103118>>>                    Set Label to "Driver ID:"
103119>>>                    Set Entry_State to False
103120>>>                    Set Enabled_State to False
103121>>>                    Set Label_Row_Offset to 1
103122>>>                    Set Enabled_State to False
103123>>>
103123>>>                    Procedure Combo_Fill_List
103126>>>                        Send Combo_Add_Item MSSQLDRV_ID
103127>>>                        Send Combo_Add_Item DB2_DRV_ID
103128>>>                        Send Combo_Add_Item ODBC_DRV_ID
103129>>>                        Send Combo_Add_Item SQLFLEX
103130>>>                        Send Combo_Add_Item MDSDB2
103131>>>                        Send Combo_Add_Item MDSMySQL
103132>>>                        Send Combo_Add_Item MDSPgSQL
103133>>>                        Send Combo_Add_Item ORAFLEX
103134>>>                    End_Procedure
103135>>>
103135>>>                    Procedure Refresh
103138>>>                        String sValue
103138>>>
103138>>>                        Get psDriverID of ghoSQLConnectionHandler to sValue
103139>>>                        Set Value to sValue
103140>>>                    End_Procedure
103141>>>
103141>>>                End_Object
103142>>>
103142>>>                Object oDatabaseInfo_tb is a TextBox
103144>>>                    Set Auto_Size_State to False
103145>>>                    Set Size to 25 96
103146>>>                    Set Location to 64 14
103147>>>                    Set Label to "(Change database on the SQL Connections tabpage)"
103148>>>                    Set Justification_Mode to JMode_Left
103149>>>                End_Object
103150>>>
103150>>>                Object oApiTableName_fm is a Form
103152>>>                    Set Size to 13 77
103153>>>                    Set Location to 114 14
103154>>>                    Set Label_Col_Offset to 0
103155>>>                    Set Label_Justification_Mode to JMode_Top
103156>>>                    Set Label to "Table Name:"
103157>>>                    Set Label_Row_Offset to 1
103158>>>                    Set Value to "NewTable"
103159>>>                    Procedure OnChange
103162>>>                        String sValue
103162>>>                        Get Value to sValue
103163>>>                        Set psTableName to sValue
103164>>>                    End_Procedure
103165>>>                    Send OnChange
103166>>>                End_Object
103167>>>
103167>>>                Object oApiAddNewTable_btn is a cButtonDPI
103169>>>                    Set Size to 13 69
103170>>>                    Set Location to 114 271
103171>>>                    Set Label to "Add Table"
103172>>>                    Set MultiLineState to True    
103173>>>                    Set psImage to "ActionAddTable.ico"
103174>>>
103174>>>                    Procedure OnClick
103177>>>                        Boolean bOk
103177>>>                        Handle hTable
103177>>>                        String sTableName sDriverID
103177>>>
103177>>>                        Get Value of oDriverID3_cf to sDriverID
103178>>>                        Get Value of oApiTableName_fm to sTableName
103179>>>                        Move (Trim(sTableName)) to sTableName
103180>>>                        If (sTableName = "") Begin
103182>>>                            Send Info_Box "You first need to enter a table name."
103183>>>                            Procedure_Return
103184>>>                        End
103184>>>>
103184>>>
103184>>>                        Send Cursor_Wait of Cursor_Control
103185>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
103186>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
103187>>>                        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
103188>>>                        If (bOk = True) Begin
103190>>>                            Send Info_Box ("Test table" * sTableName * "was successfully created and put in filelist slot:" * String(hTable))
103191>>>                        End
103191>>>>
103191>>>                        Else Begin
103192>>>                            Send Cursor_Ready of Cursor_Control
103193>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created, or does it already exist?") "Error"
103194>>>                            Procedure_Return
103195>>>                        End
103195>>>>
103195>>>
103195>>>                    End_Procedure
103196>>>
103196>>>                End_Object
103197>>>
103197>>>                Object oApiAddColumn_fm is a Form
103199>>>                    Set Size to 13 77
103200>>>                    Set Location to 141 14
103201>>>                    Set Label_Col_Offset to 0
103202>>>                    Set Label_Justification_Mode to JMode_Top
103203>>>                    Set Label to "Column Name:"
103204>>>                    Set Label_Row_Offset to 1
103205>>>                    Set Value to "NewColumn"
103206>>>                End_Object
103207>>>
103207>>>                Object oApiColumnType_cf is a ComboForm
103209>>>                    Set Size to 11 85
103210>>>                    Set Location to 142 96
103211>>>                    Set Label_Col_Offset to 0
103212>>>                    Set Label_Justification_Mode to JMode_Top
103213>>>                    Set Label_Row_Offset to 1
103214>>>                    Set Label to "Type:"
103215>>>                    Set Entry_State to False
103216>>>
103216>>>                    Procedure Combo_Fill_List
103219>>>                        tColumnType[] ColumnTypeArray
103219>>>                        tColumnType[] ColumnTypeArray
103220>>>                        Integer iSize iCount
103220>>>
103220>>>                        Send Delete_Data
103221>>>                        Get UtilEnumerateColumnTypes of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex to ColumnTypeArray
103222>>>                        Move (SizeOfArray(ColumnTypeArray)) to iSize
103223>>>                        Decrement iSize
103224>>>                        For iCount from 0 to iSize
103230>>>>
103230>>>                            Send Combo_Add_Item ColumnTypeArray[iCount].sType
103231>>>                        Loop
103232>>>>
103232>>>                        Set Value to ColumnTypeArray[0].sType
103233>>>                    End_Procedure
103234>>>
103234>>>                    Procedure OnChange
103237>>>                        String sType sPrecision
103237>>>                        Integer iType iSize iDec
103237>>>                        tSQLConnection SQLConnection
103237>>>                        tSQLConnection SQLConnection
103237>>>                        Boolean bFixed
103237>>>
103237>>>                        Get SelectedType to iType
103238>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
103239>>>                        Get UtilColumnTypePrecisionSize of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iSize
103240>>>                        Get UtilColumnTypePrecisionDec  of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to iDec
103241>>>                        Get UtilColumnTypeFixed         of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex iType to bFixed
103242>>>
103242>>>                        Set Enabled_State of oApiLength_sf   to (bFixed = False)
103243>>>                        Set Enabled_State of oApiDecimals_sf to (bFixed = False)
103244>>>                        Set Value         of oApiLength_sf   to iSize
103245>>>                        If (iDec = 0) Begin
103247>>>                            Set Value     of oApiDecimals_sf to ""
103248>>>                        End
103248>>>>
103248>>>                        Else Begin
103249>>>                            Set Value     of oApiDecimals_sf to iDec
103250>>>                        End
103250>>>>
103250>>>                        If (bFixed = False) Begin
103252>>>                            Set Enabled_State of oApiDecimals_sf to (iDec <> 0)
103253>>>                        End
103253>>>>
103253>>>                    End_Procedure
103254>>>
103254>>>                    Function SelectedType Returns Integer
103257>>>                        String sValue sDriverID
103257>>>                        Integer iType iDbType
103257>>>
103257>>>                        Get Value to sValue
103258>>>                        Get UtilColumnTypeToInteger of ghoDbUpdateFunctionLibrary DATAFLEX_ID EN_DbTypeDataFlex sValue to iType
103259>>>
103259>>>                        Function_Return iType
103260>>>                    End_Function
103261>>>
103261>>>                End_Object
103262>>>
103262>>>                Object oApiLength_sf is a SpinForm
103264>>>                    Set Label to "Length:"
103265>>>                    Set Size to 13 35
103266>>>                    Set Location to 141 186
103267>>>                    Set Label_Col_Offset to 0
103268>>>                    Set Label_Justification_Mode to JMode_Top
103269>>>                    Set Label_Row_Offset to 1
103270>>>                    Set Value to "10"
103271>>>                    Set Maximum_Position to 500
103272>>>                    Set Minimum_Position to 1
103273>>>                End_Object
103274>>>
103274>>>                Object oApiDecimals_sf is a SpinForm
103276>>>                    Set Label to "Decimals:"
103277>>>                    Set Size to 13 33
103278>>>                    Set Location to 141 225
103279>>>                    Set Label_Col_Offset to 0
103280>>>                    Set Label_Justification_Mode to JMode_Top
103281>>>                    Set Label_Row_Offset to 1
103282>>>                    Set Value to "0"
103283>>>                    Set Maximum_Position to 16
103284>>>                    Set Minimum_Position to 1
103285>>>                End_Object
103286>>>
103286>>>                Object oApiAddColumn_btn is a cButtonDPI
103288>>>                    Set Size to 13 69
103289>>>                    Set Location to 141 271
103290>>>                    Set Label to "Add Column"
103291>>>                    Set MultiLineState to True
103292>>>                    Set psToolTip to "ApiColumnAdd function"   
103293>>>                    Set psImage to "ActionAddColumn.ico"
103294>>>
103294>>>                    Procedure OnClick
103297>>>                        Boolean bOk bExists
103297>>>                        Handle hTable hoSQLQuery
103297>>>                        String sTableName sColumnName sSQLString sType sDriverID
103297>>>                        Integer iType iLength iDecimals
103297>>>
103297>>>                        Get Value of oDriverID3_cf            to sDriverID
103298>>>                        Get Value of oApiTableName_fm         to sTableName
103299>>>                        Get Value of oApiAddColumn_fm         to sColumnName
103300>>>                        Get SelectedType of oApiColumnType_cf to iType
103301>>>                        Get Value        of oApiLength_sf     to iLength
103302>>>                        Get Value        of oApiDecimals_sf   to iDecimals
103303>>>
103303>>>                        Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
103304>>>                        Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
103305>>>                        If (hTable = 0) Begin
103307>>>                            Send Info_Box "You first need to create the new table by pressing the 'Create New Table...' button, before you can add a column to it."
103308>>>                            Procedure_Return
103309>>>                        End
103309>>>>
103309>>>                        If (sColumnName = "") Begin
103311>>>                            Send Info_Box "You need to enter a column name"
103312>>>                            Procedure_Return
103313>>>                        End
103313>>>>
103313>>>
103313>>>                        Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable sColumnName iType iLength iDecimals to bOk
103314>>>                        If (bOk = True) Begin
103316>>>                            Send Info_Box ("Column" * sColumnName * sType * String(iLength) + ", was successfully added to" * sTableName * "(at filelist slot:" * String(hTable) + ")")
103317>>>                        End
103317>>>>
103317>>>                        Else Begin
103318>>>                            Send Info_Box ("The column could NOT be added. Either column" * sColumnName * "already exists or the current Database is incorrect?")
103319>>>                            Procedure_Return
103320>>>                        End
103320>>>>
103320>>>
103320>>>                    End_Procedure
103321>>>
103321>>>                End_Object
103322>>>
103322>>>                Object oApiAddTableAndColumns_btn is a cButtonDPI
103324>>>                    Set Size to 26 77
103325>>>                    Set Location to 184 14
103326>>>                    Set Label to "Create 'New' Table with Three Columns"
103327>>>                    Set MultiLineState to True  
103328>>>                    Set psImage to "ActionAddTable.ico"
103329>>>
103329>>>                    Procedure OnClick
103332>>>                        Boolean bOk
103332>>>                        Handle hTable
103332>>>                        String sTableName sDriverID
103332>>>
103332>>>                        Get Value of oDriverID3_cf to sDriverID
103333>>>                        Get Value of oApiTableName_fm to sTableName
103334>>>                        Move (Trim(sTableName)) to sTableName
103335>>>                        If (sTableName = "") Begin
103337>>>                            Send Info_Box "You first need to enter a table name."
103338>>>                            Procedure_Return
103339>>>                        End
103339>>>>
103339>>>
103339>>>                        Send Cursor_Wait of Cursor_Control
103340>>>                        Get NextFreeFilelistSlot of ghoDbUpdateFunctionLibrary to hTable
103341>>>
103341>>>                        Set psDriverID       of ghoDbUpdateFunctionLibrary to sDriverID
103342>>>                        Get ApiTableCreate   of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True to bOk
103343>>>                        If (bOk = True) Begin
103345>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col1Ascii"   DF_ASCII 10 0 to bOk
103346>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col2Date"    DF_DATE   6 0 to bOk
103347>>>                            Get ApiColumnAdd of ghoDbUpdateFunctionLibrary hTable "Col3Numeric" DF_BCD    6 2 to bOk
103348>>>                        End
103348>>>>
103348>>>                        Send Cursor_Ready of Cursor_Control
103349>>>
103349>>>                        If (bOk = True) Begin
103351>>>                            Send Info_Box ("Test table" * sTableName * "with Columns: 'Col1 ASCII 10', 'Col2 Date' and 'Col3 Numeric 6,2' was successfully created and put in filelist slot:" * String(CI_Table1_FileNo))
103352>>>                        End
103352>>>>
103352>>>                        Else Begin
103353>>>                            Send Cursor_Ready of Cursor_Control
103354>>>                            Send Info_Box ("Nope, the test table" * sTableName * "could not be created") "Error"
103355>>>                            Procedure_Return
103356>>>                        End
103356>>>>
103356>>>
103356>>>                    End_Procedure
103357>>>
103357>>>                End_Object
103358>>>
103358>>>                Object oApiRemoveTable_btn is a cButtonDPI
103360>>>                    Set Size to 26 77
103361>>>                    Set Location to 184 96
103362>>>                    Set Label to "Remove 'New' Table"
103363>>>                    Set psImage to "ActionDeleteTable.ico"
103364>>>                    Set MultiLineState to True
103365>>>
103365>>>                    Procedure OnClick
103368>>>                        Boolean bOk
103368>>>                        Integer iRetval
103368>>>                        Handle hTable
103368>>>                        String sTableName sDriverID
103368>>>
103368>>>                        Get Value of oDriverID3_cf to sDriverID
103369>>>                        Get Value of oApiTableName_fm to sTableName
103370>>>                        Get YesNo_Box ("Are you sure you want to PERMANENTLY DELETE the table named:" * String(sTableName) + "?") to iRetval
103371>>>                        If (iRetval = MBR_Yes) Begin
103373>>>                            Send Cursor_Wait of Cursor_Control
103374>>>                            Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
103375>>>                            Get UtilTableNameToHandle of ghoDbUpdateFunctionLibrary sTableName to hTable
103376>>>                            Get ApiTableRemove of ghoDbUpdateFunctionLibrary hTable to bOk
103377>>>                            Send Cursor_Ready of Cursor_Control
103378>>>                            If (bOk = True) Begin
103380>>>                                Send Info_Box "Table removed"
103381>>>                            End
103381>>>>
103381>>>                            Else Begin
103382>>>                                Send Info_Box "Nope, that didnt' work. Either the table doesn't exist or your rights aren't sufficient."
103383>>>                            End
103383>>>>
103383>>>                        End
103383>>>>
103383>>>                    End_Procedure
103384>>>
103384>>>                End_Object
103385>>>
103385>>>                Object oLineControl1 is a LineControl
103387>>>                    Set Size to 2 387
103388>>>                    Set Location to 96 6
103389>>>                    Set peAnchors to anTopLeftRight
103390>>>                End_Object
103391>>>
103391>>>                Object oLineControl2 is a LineControl
103393>>>                    Set Size to 3 248
103394>>>                    Set Location to 171 9
103395>>>                End_Object
103396>>>
103396>>>            End_Object
103397>>>
103397>>>        End_Object
103398>>>
103398>>>    End_Object
103399>>>
103399>>>End_Object
103400>        Use UtilFunctions.vw
Including file: UtilFunctions.vw    (C:\Projects\DF18\DbUpdateFramework\AppSrc\UtilFunctions.vw)
103400>>>Use Windows.pkg
103400>>>Use DFClient.pkg
103400>>>Use Dfline.pkg
103400>>>Use cDbScrollingContainer.pkg
103400>>>Use cButtonDPI.pkg
103400>>>Use cDbUpdateFunctionLibrary.pkg
103400>>>Use Dftreevw.pkg
103400>>>Use Working.pkg
Including file: Working.pkg    (C:\Projects\DF18\DbUpdateFramework\AppSrc\Working.pkg)
103400>>>>>// COPYRIGHT (c) 2003-2017 RDC Tools International
103400>>>>>//
103400>>>>>// This program is free software; you can redistribute it and/or
103400>>>>>// modify it under the terms of the GNU General Public License
103400>>>>>// as published by the Free Software Foundation; version 2
103400>>>>>// of the License.
103400>>>>>
103400>>>>>// This program is distributed in the hope that it will be useful,
103400>>>>>// but WITHOUT ANY WARRANTY; without even the implied warranty of
103400>>>>>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
103400>>>>>// GNU General Public License for more details.
103400>>>>>
103400>>>>>// You should have received a copy of the GNU General Public License
103400>>>>>// along with this program; (See the GPL.txt file in the Help directory) if not, write to the Free Software
103400>>>>>// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
103400>>>>>Use Windows.pkg
103400>>>>>
103400>>>>>Object oWorkingMessagePanel is a ToolPanel
103402>>>>>    Set Label    to "Working"
103403>>>>>    Set Size to 48 150
103404>>>>>    Set Locate_Mode to CENTER_ON_PARENT
103405>>>>>    Set Popup_State to True
103406>>>>>
103406>>>>>    Object oWorkingMessage is a Textbox
103408>>>>>        Set Label to "Working message..."
103409>>>>>        Set Location to 15 5
103410>>>>>        Set Size to 27 123
103411>>>>>        Set Auto_Size_State to False
103412>>>>>        Set Justification_Mode to JMode_Center
103413>>>>>        Set FontWeight to fw_Bold
103414>>>>>    End_Object
103415>>>>>
103415>>>>>End_Object
103416>>>>>
103416>>>>>Procedure StartWorkingMessage Global String sText
103418>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
103419>>>>>    Set Label  of (oWorkingMessage(oWorkingMessagePanel(Self))) to sText
103420>>>>>    Send Popup of (oWorkingMessagePanel(Self))
103421>>>>>End_Procedure
103422>>>>>
103422>>>>>Procedure StopWorkingMessage Global
103424>>>>>    Send Close_Panel of (oWorkingMessagePanel(Self))
103425>>>>>End_Procedure
103426>>>Use DUFStatusPanel.pkg
103426>>>
103426>>>Struct tFilelistDUF
103426>>>    Integer iFileNumber
103426>>>    String sLogicalName
103426>>>    String sRootName
103426>>>    String sDisplayName
103426>>>End_Struct
103426>>>
103426>>>Activate_View Activate_oUtilFunctions_vw for oUtilFunctions_vw
103436>>>>
103436>>>Object oUtilFunctions_vw is a dbView
103438>>>    Set Border_Style to Border_Thick
103439>>>    Set Size to 268 428
103440>>>    Set Location to 2 1
103441>>>    Set Label to "Utility Functions"
103442>>>    Set pbAutoActivate to True
103443>>>    Set Icon to "TestTools.ico"
103444>>>    Set pbAcceptDropFiles to True
103445>>>
103445>>>    Object oScrollingContainer1 is a cDbScrollingContainer
103447>>>        Object oScrollingClientArea1 is a cDbScrollingClientArea
103449>>>
103449>>>            Object oSQL_grp is a Group
103451>>>                Set Size to 88 402
103452>>>                Set Location to 7 12
103453>>>                Set Label to "Run SQL Database Scripts Embedded as Resources"
103454>>>                Set peAnchors to anTopLeftRight
103455>>>
103455>>>                Object oCreateOrderEntry_btn is a cButtonDPI
103457>>>                    Set Size to 14 219
103458>>>                    Set Location to 13 13
103459>>>                    Set Label to "Create New SQL Database [OrderEntry] Complete with Data"
103460>>>                    Set psToolTip to "Creates the full Order Entry Sample database from the DataFlex samples complete with data with the name: [OrderEntry]"
103461>>>                    Set psImage to "ActionCreateDatabase.ico"
103462>>>                    
103462>>>                    Procedure OnClick
103465>>>                        String sInfoText sDriverID
103465>>>                        Boolean bOK
103465>>>                        TimeSpan tsTotalQueryTime
103465>>>                        Integer iRetval
103465>>>
103465>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
103465>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
103465>>>                        SQLIncludeScriptFile ..\Scripts\CreateOrderEntry.sql as CreateOrderEntry.sql
103465>>>                        Get YesNo_Box "This will run the 'CreateOrderEntry.sql' script from the 'Script' workspace folder which will create the [OrderEntry] database from the DataFlex samples for Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
103466>>>                        If (iRetval <> MBR_Yes) Begin
103468>>>                            Procedure_Return
103469>>>                        End
103469>>>>
103469>>>
103469>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
103470>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
103472>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
103473>>>                            Procedure_Return
103474>>>                        End
103474>>>>
103474>>>
103474>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
103475>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateOrderEntry.sql" MSSQLDRV_ID False to bOK
103476>>>                        Send StopWorkingMessage
103477>>>
103477>>>                        If (bOK = True) Begin
103479>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
103480>>>                            Move ("Success! DataFlex Order Entry Sample Database was created as [OrderEntry]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
103481>>>                        End
103481>>>>
103481>>>
103481>>>                        Else Begin
103482>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
103483>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
103484>>>                        End
103484>>>>
103484>>>
103484>>>                        Send Info_Box sInfoText
103485>>>                    End_Procedure
103486>>>
103486>>>                End_Object
103487>>>
103487>>>                Object oCreateNorthWind_btn is a cButtonDPI
103489>>>                    Set Size to 14 219
103490>>>                    Set Location to 33 13
103491>>>                    Set Label to "Create New SQL Database [NorthWind] Complete with Data"
103492>>>                    Set psToolTip to "Creates the full NorthWind Sample database from the DataFlex samples complete with data with the name: [NorthWind]"
103493>>>                    Set psImage to "ActionCreateDatabase.ico"
103494>>>
103494>>>                    Procedure OnClick
103497>>>                        String sInfoText sDriverID
103497>>>                        Boolean bOK
103497>>>                        TimeSpan tsTotalQueryTime
103497>>>                        Integer iRetval
103497>>>
103497>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
103497>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
103497>>>                        SQLIncludeScriptFile ..\Scripts\CreateNorthWindDatabase.sql as CreateNorthWindDatabase.sql
103497>>>
103497>>>                        Get YesNo_Box "This will run the 'CreateNorthWindDatabase.sql' script from the 'Script' workspace folder and it will create the [NorthWind] sample database in Microsoft SQL Server, complete with data. If it exists it will first be dropped, then re-created and populated with new data. Continue?" to iRetval
103498>>>                        If (iRetval <> MBR_Yes) Begin
103500>>>                            Procedure_Return
103501>>>                        End
103501>>>>
103501>>>
103501>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
103502>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
103504>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
103505>>>                            Procedure_Return
103506>>>                        End
103506>>>>
103506>>>
103506>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
103507>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateNorthWindDatabase.sql" MSSQLDRV_ID False to bOK
103508>>>                        Send StopWorkingMessage
103509>>>
103509>>>                        If (bOK = True) Begin
103511>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
103512>>>                            Move ("Success! The Northwind Sample Database was created as [NorthWind]. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
103513>>>                        End
103513>>>>
103513>>>
103513>>>                        Else Begin
103514>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
103515>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
103516>>>                        End
103516>>>>
103516>>>
103516>>>                        Send Info_Box sInfoText
103517>>>                    End_Procedure
103518>>>
103518>>>                End_Object
103519>>>
103519>>>                Object oCreateFullChinookDatabase_btn is a cButtonDPI
103521>>>                    Set Size to 14 219
103522>>>                    Set Location to 53 13
103523>>>                    Set Label to "Create New SQL Database [Chinook] Complete with Data"
103524>>>                    Set psToolTip to "Creates the Chinook demo database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated. Note: These scripts were part of Data Access Europe's '' training class."
103525>>>                    Set psImage to "ActionCreateDatabase.ico"
103526>>>
103526>>>                    Procedure OnClick
103529>>>                        String sInfoText sDriverID
103529>>>                        Boolean bOK
103529>>>                        TimeSpan tsTotalQueryTime
103529>>>                        Integer iRetval
103529>>>
103529>>>                        // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
103529>>>                        // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
103529>>>                        SQLIncludeScriptFile ..\Scripts\CreateChinookDatabase.sql as CreateChinookDatabase.sql
103529>>>
103529>>>                        Get YesNo_Box "This will run the 'CreateChinookDatabase.sql' script from the 'Script' workspace folder which will create the [Chinook] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
103530>>>                        If (iRetval <> MBR_Yes) Begin
103532>>>                            Procedure_Return
103533>>>                        End
103533>>>>
103533>>>                        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
103534>>>                        If (sDriverID <> MSSQLDRV_ID) Begin
103536>>>                            Send Info_Box "You need to have a Microsoft SQL Server connection active for this to work. Please adjust and try again."
103537>>>                            Procedure_Return
103538>>>                        End
103538>>>>
103538>>>
103538>>>                        Send StartWorkingMessage "Executing SQL Script. Please wait..."
103539>>>
103539>>>                        Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateChinookDatabase.sql" MSSQLDRV_ID False to bOK
103540>>>
103540>>>                        Send StopWorkingMessage
103541>>>                        If (bOK = True) Begin
103543>>>                            Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
103544>>>                            Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
103545>>>                        End
103545>>>>
103545>>>
103545>>>                        Else Begin
103546>>>                            Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
103547>>>                            Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
103548>>>                        End
103548>>>>
103548>>>
103548>>>                        Send Info_Box sInfoText
103549>>>                    End_Procedure
103550>>>
103550>>>                End_Object
103551>>>
103551>>>                Object oInfo_tb is a TextBox
103553>>>                    Set Auto_Size_State to False
103554>>>                    Set Size to 25 158
103555>>>                    Set Location to 53 238
103556>>>                    Set Label to "Note: The Chinook script was provided by Data Access Europe as part of their 'Web Touch Training' course."
103557>>>                    Set Justification_Mode to JMode_Left
103558>>>                    Set peAnchors to anTopLeftRight
103559>>>                End_Object
103560>>>
103560>>>        //  This will choke the computer so don't try it!
103560>>>        //        Object oCreateAdventureWorksDatabase_btn is a cButtonDPI
103560>>>        //            Set Size to 14 312
103560>>>        //            Set Location to 97 45
103560>>>        //            Set Label to "Create [AdventureWorks] Database and Populate with Data"
103560>>>        //            Set psToolTip to "Creates the Adenture Works database complete with data in Microsoft SQL Server. Note: If it exists it will first be dropped then recreated."
103560>>>        //
103560>>>        //            Procedure OnClick
103560>>>        //                String sInfoText
103560>>>        //                Boolean bOK
103560>>>        //                TimeSpan tsTotalQueryTime
103560>>>        //                Integer iRetval
103560>>>        //
103560>>>        //                // The default path for the include_resource command is the Data folder. So anything else needs a pathing.
103560>>>        //                // Note: The file name and the resource name (the 'as' part) needs to be exactly the same.
103560>>>        ////                SQLIncludeScriptFile ..\Scripts\CreateAdventureWorks.sql as CreateAdventureWorks.sql
103560>>>        //Procedure_Return
103560>>>        //                Get YesNo_Box "This will create the [AdventurWorks] sample database complete with data. If it exists it will first be dropped, then re-created and populated with new data.\n\nContinue?" to iRetval
103560>>>        //                If (iRetval <> MBR_Yes) Begin
103560>>>        //                    Procedure_Return
103560>>>        //                End
103560>>>        //
103560>>>        //                Send StartWorkingMessage "Executing SQL Script. Please wait..."
103560>>>        //                Get SqlUtilExecuteResource of ghoDbUpdateFunctionLibrary "CreateAdventureWorks.sql" MSSQLDRV_ID False to bOK
103560>>>        //                Send StopWorkingMessage
103560>>>        //
103560>>>        //                If (bOK = True) Begin
103560>>>        //                    Get ptsTotalQueryTime of ghoDbUpdateFunctionLibrary to tsTotalQueryTime
103560>>>        //                    Move ("Success! The script was run OK. Time elapsed:" * String(tsTotalQueryTime)) to sInfoText
103560>>>        //                End
103560>>>        //
103560>>>        //                Else Begin
103560>>>        //                    Send UtilShowErrorList of ghoDbUpdateFunctionLibrary
103560>>>        //                    Move ("Nope, that didn't work. There was a problem running the script.\n\n" + "See Notepad for details...") to sInfoText
103560>>>        //                End
103560>>>        //
103560>>>        //                Send Info_Box sInfoText
103560>>>        //            End_Procedure
103560>>>        //
103560>>>        //        End_Object
103560>>>
103560>>>            End_Object
103561>>>
103561>>>            Object oChangeIntFiles_grp is a Group
103563>>>                Set Size to 65 402
103564>>>                Set Location to 102 12
103565>>>                Set Label to "Change Old .int files to use Connection ID's"
103566>>>                Set peAnchors to anTopLeftRight
103567>>>
103567>>>                Object oSelectDataPath_fm is a Form
103569>>>                    Set Size to 13 300
103570>>>                    Set Location to 22 13
103571>>>                    Set Label to "Select path to a Data folder with .int files (Select one '.int' file):"
103572>>>                    Set Label_Col_Offset to 0
103573>>>                    Set Label_Row_Offset to 1
103574>>>                    Set Label_Justification_Mode to JMode_Top
103575>>>
103575>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
103575>>>        //            Set Prompt_Button_Mode to PB_PromptOn
103575>>>                    Set psToolTip to "You can use this if you have .int files that currently have content like; 'SERVER=xxx; DATABASE=yyy' et.al. and you need to change them to use a connection ID like; 'SERVER_NAME DFCONNID=MyConnID'"
103576>>>                    Set peAnchors to anTopLeftRight
103577>>>
103577>>>                    Procedure Prompt
103580>>>                        String sPath sFileMask sRetval
103580>>>
103580>>>                        Get psDataPathFirstPart to sPath
103581>>>                        Move "Database intermediate files (*.int)|*.int" to sFileMask
103582>>>                        Get vSelect_File sFileMask "Please select an .int file from the data folder" sPath to sRetval
103583>>>                        If (sRetval <> "") Begin
103585>>>                            Get ParseFolderName sRetval to sPath
103586>>>                            If (Right(sPath, 1) ="\") Move (Left(sPath, Length(sPath) -1)) to sPath
103589>>>                            Set Value to sPath
103590>>>                        End
103590>>>>
103590>>>                    End_Procedure
103591>>>
103591>>>                    // Returns the first datapath found in the psDataPath property.
103591>>>                    // The returned path always ends with a "\"
103591>>>                    Function psDataPathFirstPart Returns String
103594>>>                        String sDataPath
103594>>>                        Integer iCount
103594>>>
103594>>>                        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
103595>>>                        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
103596>>>                        If (iCount > 1) Begin
103598>>>                            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
103599>>>                        End
103599>>>>
103599>>>                        If (sDataPath <> "") Begin
103601>>>                            Get vFolderFormat sDataPath to sDataPath
103602>>>                        End
103602>>>>
103602>>>
103602>>>                        Function_Return sDataPath
103603>>>                    End_Function
103604>>>
103604>>>                End_Object
103605>>>
103605>>>                Object oSelectFolder_btn is a cButtonDPI
103607>>>                    Set Size to 13 73
103608>>>                    Set Location to 22 320
103609>>>                    Set Label to "Select Folder"
103610>>>                    Set psToolTip to "Please select an .int file from the data folder"
103611>>>                    Set peAnchors to anTopRight 
103612>>>                    Set psImage to "ActionOpen.ico"
103613>>>
103613>>>                    Procedure OnClick
103616>>>                        Send Prompt to oSelectDataPath_fm
103617>>>                    End_Procedure
103618>>>
103618>>>                End_Object
103619>>>
103619>>>                Object oConnectionID_fm is a Form
103621>>>                    Set Size to 13 111
103622>>>                    Set Location to 38 202
103623>>>                    Set Label_Col_Offset to 2
103624>>>                    Set Label_Justification_Mode to JMode_Right
103625>>>                    Set Label to "Change to DFConnID:"
103626>>>                    Set psToolTip to "Please enter your Connection ID (DFCONNID=) that should replace the SERVER_NAME settings for all .int files in the selected folder."
103627>>>                    Set peAnchors to anTopRight
103628>>>                End_Object
103629>>>
103629>>>                Object oChangeAllIntFiles_btn is a cButtonDPI
103631>>>                    Set Size to 13 65
103632>>>                    Set Location to 38 320
103633>>>                    Set Label to "GO !"
103634>>>                    Set psToolTip to "Changes or updates all .int files in the selected folder - except for DAW driver .int files (MSSQL_DRV.int, DB2_DRV.int & ODBC_DRV.int) - to use 'SERVER_NAME DFCONNID=xxx'"
103635>>>                    Set FontWeight to fw_Bold
103636>>>                    Set peAnchors to anTopRight
103637>>>
103637>>>                    Procedure OnClick
103640>>>                        String sDataPath sConnectionID
103640>>>                        Boolean bExists bActive
103640>>>                        Integer iRetval
103640>>>
103640>>>                        Get Value of oSelectDataPath_fm to sDataPath
103641>>>                        Get vFolderExists sDataPath to bExists
103642>>>                        If (bExists = False) Begin
103644>>>                            Send Info_Box ("The data folder doesn't exist!\n" + sDataPath)
103645>>>                            Procedure_Return
103646>>>                        End
103646>>>>
103646>>>                        Get Value of oConnectionID_fm to sConnectionID
103647>>>                        Move (Trim(sConnectionID)) to sConnectionID
103648>>>                        If (sConnectionID = "") Begin
103650>>>                            Send Info_Box "You need to specify a Connection_ID to use for the .int files."
103651>>>                            Procedure_Return
103652>>>                        End
103652>>>>
103652>>>
103652>>>                        Get YesNo_Box ("Do you want to change all .int files in folder:\n" + sDataPath + "\n\nTo use 'DFCONNID=" + sConnectionID +"' ?") to iRetval
103653>>>                        If (iRetval <> MBR_Yes) Begin
103655>>>                            Procedure_Return
103656>>>                        End
103656>>>>
103656>>>                        Get YesNo_Box "All '.CCH' files will first be deleted. Continue?" to iRetval
103657>>>                        If (iRetval <> MBR_Yes) Begin
103659>>>                            Procedure_Return
103660>>>                        End
103660>>>>
103660>>>
103660>>>                        Get vDeleteFile (sDataPath + "\*.cch") to iRetval
103661>>>                        If (iRetval <> 0) Begin
103663>>>                            Send Info_Box "Could not delete .cch files!"
103664>>>                            Procedure_Return
103665>>>                        End    
103665>>>>
103665>>>                        
103665>>>                        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Changing Connection ID's in .int files" ""
103666>>>                        Send Start_StatusPanel of ghoStatusPanel
103667>>>                        Send SqlUtilChangeIntFilesToConnectionIDs of ghoDbUpdateFunctionLibrary sDataPath sConnectionID True
103668>>>                        
103668>>>                        Get Active_State of ghoStatusPanel to bActive
103669>>>                        If (bActive = False) Begin
103671>>>                            Send Info_Box "Process interupted..."
103672>>>                        End                                     
103672>>>>
103672>>>                        Else Begin
103673>>>                            Send Stop_StatusPanel of ghoStatusPanel
103674>>>                            Send Info_Box "Ready! All .int files changed."
103675>>>                        End
103675>>>>
103675>>>                    End_Procedure
103676>>>
103676>>>                End_Object
103677>>>
103677>>>            End_Object
103678>>>
103678>>>            Object oRemoveFilelistDriverIDs_grp is a Group
103680>>>                Set Size to 82 402
103681>>>                Set Location to 175 12
103682>>>                Set Label to "Remove Database Identifications"
103683>>>                Set peAnchors to anAll
103684>>>//                Set TextColor to clGreen
103684>>>//                
103684>>>//                Procedure Page Integer iPage
103684>>>//                    Integer ia iz
103684>>>//                    Forward Send Page iPage
103684>>>//                    Move 0 to iz
103684>>>//                    Move (AddressOf(iz)) to ia
103684>>>//                    Move (SetWindowTheme(Window_Handle(Self),ia,ia)) to iPage
103684>>>//                End_Procedure              
103684>>>                
103684>>>                Object oFilelistPath_fm is a Form
103686>>>                    Set Size to 13 299
103687>>>                    Set Location to 22 13
103688>>>                    Set Label to "Path and Filelist.cfg Name:"
103689>>>                    Set Label_Col_Offset to 0
103690>>>                    Set Label_Row_Offset to 1
103691>>>                    Set Label_Justification_Mode to JMode_Top
103692>>>
103692>>>                    // This is very strange but for some reason the tooltip is _not_ displayed if PB_PromptOn is set...
103692>>>        //            Set Prompt_Button_Mode to PB_PromptOn
103692>>>                    Set psToolTip to "You can use this if you have entries in a Filelist.cfg with driver prefixes like 'MSSQLDRV;Customer' and you need to remove them all."
103693>>>                    Set peAnchors to anTopLeftRight
103694>>>
103694>>>                    Procedure Prompt
103697>>>                        String sFileName sPath sFileMask sRetval
103697>>>
103697>>>                        Get Value to sFileName
103698>>>                        Get ParseFolderName sFileName to sPath
103699>>>                        Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
103700>>>                        Get vSelect_File sFileMask "Please select a Filelist.cft file" sPath to sRetval
103701>>>                        If (sRetval <> "") Begin
103703>>>                            Set Value to sRetval
103704>>>                            Set_Attribute DF_FILELIST_NAME to sRetval
103707>>>                        End
103707>>>>
103707>>>                    End_Procedure
103708>>>
103708>>>                    Procedure OnCreate
103711>>>                        String sFilelist
103711>>>                        Get_Attribute DF_FILELIST_NAME to sFilelist
103714>>>                        Set Value to sFilelist
103715>>>                    End_Procedure
103716>>>                    Send OnCreate
103717>>>
103717>>>                End_Object
103718>>>
103718>>>                Object oSelectFilelist_btn is a cButtonDPI
103720>>>                    Set Size to 13 73
103721>>>                    Set Location to 22 319
103722>>>                    Set Label to "Select Filelist.cfg"
103723>>>                    Set psToolTip to "Please select a Filelist.cfg file to be changed"
103724>>>                    Set peAnchors to anTopRight
103725>>>
103725>>>                    Procedure OnClick
103728>>>                        Send Prompt to oFilelistPath_fm
103729>>>                    End_Procedure
103730>>>
103730>>>                End_Object
103731>>>
103731>>>                Object oInfo_tb is a TextBox
103733>>>                    Set Size to 9 207
103734>>>                    Set Location to 40 138
103735>>>                    Set Label to "Remove ALL database identifications from Filelist.cfg:"
103736>>>                    Set peAnchors to anTopRight
103737>>>                End_Object
103738>>>
103738>>>                Object oChangeFilelist_btn is a cButtonDPI
103740>>>                    Set Size to 13 65
103741>>>                    Set Location to 38 319
103742>>>                    Set Label to "GO !"
103743>>>                    Set FontWeight to fw_Bold
103744>>>                    Set peAnchors to anTopRight
103745>>>
103745>>>                    Procedure OnClick
103748>>>                        String sCurrentFileList sFileList sRootName sDisplayName sLogicalName sVal
103748>>>                        Integer iRetval iCount
103748>>>                        Boolean bExits
103748>>>                        Handle hTable
103748>>>
103748>>>                        Get Value of oFilelistPath_fm to sFileList
103749>>>                        Get vFilePathExists sFileList to bExits
103750>>>                        If (bExits = False) Begin
103752>>>                            Send Info_Box ("Sorry, the Filelist.cfg does not exist;\n" + sFileList)
103753>>>                            Procedure_Return
103754>>>                        End
103754>>>>
103754>>>
103754>>>                        Get YesNo_Box ("Are you sure you want to remove all driver identifications for the following Filelist.cfg?\n" + sFileList) to iRetval
103755>>>                        If (iRetval <> MBR_Yes) Begin
103757>>>                            Procedure_Return
103758>>>                        End
103758>>>>
103758>>>                        Send Cursor_Wait of Cursor_Control
103759>>>
103759>>>                        Get SqlUtilFilelistRemoveDriverInfo of ghoDbUpdateFunctionLibrary sFileList to iCount
103760>>>
103760>>>                        Send Cursor_Ready of Cursor_Control
103761>>>                        If (iCount <> 0) Begin
103763>>>                            Send Info_Box ("Ready!" * String(iCount) * "Filelist entries adjusted.")
103764>>>                        End
103764>>>>
103764>>>                        Else Begin
103765>>>                            Send Info_Box "Ready. No driver based Filelist entries found."
103766>>>                        End
103766>>>>
103766>>>
103766>>>                    End_Procedure
103767>>>
103767>>>                End_Object
103768>>>
103768>>>                Object oPrintFilelist_btn is a cButtonDPI
103770>>>                    Set Size to 14 76
103771>>>                    Set Location to 61 307
103772>>>                    Set Label to "Print Filelist.cfg"
103773>>>                    Set psToolTip to "Writes the content of Filelist.cfg to a textfile and shows the textfile in Notepad."
103774>>>                    Set psImage to "ActionDocument.ico"
103775>>>                    
103775>>>                    Property Integer piSortOrder 0 // Property gets set by the radio group object.
103777>>>
103777>>>                    // Custom array sort function.
103777>>>                    // iSortOrder = 0 -> Filelist number order
103777>>>                    // iSortOrder = 1 -> Logical name order
103777>>>                    // iSortOrder = 2 -> Root name order
103777>>>                    // iSortOrder = 3 -> Display name order
103777>>>                    Function CompareSortFilelist tFilelistDUF FilelistDUF1 tFilelistDUF FilelistDUF2 Returns Integer
103780>>>                        Integer iSortOrder
103780>>>
103780>>>                        Get piSortOrder to iSortOrder
103781>>>
103781>>>                        Case Begin
103781>>>                            Case (iSortOrder = 0)
103783>>>                                If (FilelistDUF1.iFileNumber  > FilelistDUF2.iFileNumber) Begin
103785>>>                                    Function_Return (GT)
103786>>>                                End
103786>>>>
103786>>>                                If (FilelistDUF1.iFileNumber  < FilelistDUF2.iFileNumber) Begin
103788>>>                                    Function_Return (LT)
103789>>>                                End
103789>>>>
103789>>>                                Function_Return (EQ)
103790>>>                            Case (iSortOrder = 1)
103793>>>                                If (Uppercase(FilelistDUF1.sLogicalName) > Uppercase(FilelistDUF2.sLogicalName)) Begin
103795>>>                                    Function_Return (GT)
103796>>>                                End
103796>>>>
103796>>>                                If (Uppercase(FilelistDUF1.sLogicalName) < Uppercase(FilelistDUF2.sLogicalName)) Begin
103798>>>                                    Function_Return (LT)
103799>>>                                End
103799>>>>
103799>>>                                Function_Return (EQ)
103800>>>                            Case (iSortOrder = 2)
103803>>>                                If (Uppercase(FilelistDUF1.sRootName)    > Uppercase(FilelistDUF2.sRootName)) Begin
103805>>>                                    Function_Return (GT)
103806>>>                                End
103806>>>>
103806>>>                                If (Uppercase(FilelistDUF1.sRootName)    < Uppercase(FilelistDUF2.sRootName)) Begin
103808>>>                                    Function_Return (LT)
103809>>>                                End
103809>>>>
103809>>>                                Function_Return (EQ)
103810>>>                            Case (iSortOrder = 3)
103813>>>                                If (Uppercase(FilelistDUF1.sDisplayName) > Uppercase(FilelistDUF2.sDisplayName)) Begin
103815>>>                                    Function_Return (GT)
103816>>>                                End
103816>>>>
103816>>>                                If (Uppercase(FilelistDUF1.sDisplayName) < Uppercase(FilelistDUF2.sDisplayName)) Begin
103818>>>                                    Function_Return (LT)
103819>>>                                End
103819>>>>
103819>>>                                Function_Return (EQ)
103820>>>                        Case End
103820>>>
103820>>>                    End_Function
103821>>>
103821>>>                    Procedure OnClick
103824>>>                        String sFileList sRootName sLogicalName sDisplayName sPath sOutputName sTable sExt
103824>>>                        Integer iCh iCount iSize
103824>>>                        Handle hTable
103824>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
103824>>>                        tFilelistDUF[] FilelistDUFArray FilelistDUFSorted
103826>>>
103826>>>                        Get Value of oFilelistPath_fm to sFileList
103827>>>                        Move (Trim(sFileList)) to sFileList
103828>>>                        If (sFileList = "") Begin
103830>>>                            Send Info_Box "You need to select a Filelist.cfg file first"
103831>>>                            Procedure_Return
103832>>>                        End
103832>>>>
103832>>>
103832>>>                        Get ParseFolderName sFileList to sPath
103833>>>                        Get vFolderFormat sPath to sPath
103834>>>                        Get ParseFileName sFileList to sOutputName
103835>>>                        Get ParseFileExtension sFileList to sExt
103836>>>                        Move (Replace(sExt, sOutputName, "")) to sOutputName
103837>>>                        Move (sOutputName + "txt")           to sOutputName
103838>>>                        Get Seq_Open_Output_Channel (sPath + sOutputName) to iCh
103839>>>                        If (iCh < 0) Begin
103841>>>                            Procedure_Return
103842>>>                        End
103842>>>>
103842>>>
103842>>>                        Move 0 to hTable
103843>>>                        Writeln channel iCh sFileList
103846>>>                        Writeln channel iCh "[Table No:]            [LogicalName:]        [RootName:]                             [DisplayName:]"
103849>>>                        Writeln channel iCh "==================================================================================================="
103852>>>                        Writeln channel iCh
103854>>>
103854>>>                        Move 0 to iCount
103855>>>                        Repeat
103855>>>>
103855>>>                            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
103858>>>                            If (hTable > 0) Begin
103860>>>                                Move hTable                                  to FilelistDUFArray[iCount].iFileNumber
103861>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to FilelistDUFArray[iCount].sLogicalName
103864>>>                                Get_Attribute DF_FILE_ROOT_NAME    of hTable to FilelistDUFArray[iCount].sRootName
103867>>>                                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to FilelistDUFArray[iCount].sDisplayName
103870>>>                                Increment iCount
103871>>>                            End
103871>>>>
103871>>>                        Until (hTable = 0)
103873>>>
103873>>>                        Move (SortArray(FilelistDUFArray, Self, (RefFunc(CompareSortFilelist)))) to FilelistDUFSorted
103874>>>                        Move (SizeOfArray(FilelistDUFSorted)) to iSize
103875>>>                        Decrement iSize
103876>>>
103876>>>                        For iCount from 0 to iSize
103882>>>>
103882>>>                            Move FilelistDUFSorted[iCount].iFileNumber  to hTable
103883>>>                            Move FilelistDUFSorted[iCount].sLogicalName to sLogicalName
103884>>>                            Move FilelistDUFSorted[iCount].sRootName    to sRootName
103885>>>                            Move FilelistDUFSorted[iCount].sDisplayName to sDisplayName
103886>>>
103886>>>                            Get PadLeft (String(hTable))        09 to sTable
103887>>>                            Get PadLeft (String(sLogicalName)) (27 - Length(sTable))       to sLogicalName
103888>>>                            Get PadLeft (String(sRootName))    (46 - Length(sLogicalName)) to sRootName
103889>>>                            Get PadLeft (String(sDisplayName)) (72 - Length(sRootName))    to sDisplayName
103890>>>
103890>>>                            Writeln channel iCh sTable (ToANSI(sRootName)) (ToANSI(sLogicalName)) (ToANSI(sDisplayName))
103896>>>                        Loop
103897>>>>
103897>>>
103897>>>                        Writeln channel iCh "==================================================================================================="
103900>>>                        Writeln channel iCh "Total Number of Tables in Filelist.cfg: " (iSize + 1)
103904>>>                        Close_Output
103905>>>
103905>>>                        Send vShellExecute "open" sOutputName "" sPath
103906>>>                    End_Procedure
103907>>>
103907>>>                    Function PadLeft String sString Integer iLength String sOptChar Returns String
103910>>>                        String sChar
103910>>>
103910>>>                        If (Num_Arguments >= 3) Begin
103912>>>                            Move sOptChar to sChar
103913>>>                        End
103913>>>>
103913>>>                        Else Begin
103914>>>                            Move " " to sChar
103915>>>                        End
103915>>>>
103915>>>
103915>>>                        While (Length(sString) < iLength)
103919>>>                            Move (sChar + sString) to sString
103920>>>                        Loop
103921>>>>
103921>>>
103921>>>                        Function_Return sString
103922>>>                    End_Function
103923>>>
103923>>>                End_Object
103924>>>
103924>>>                Object oOutput_rg is a RadioGroup
103926>>>                    Set Location to 53 13
103927>>>                    Set Size to 25 288
103928>>>                    Set Label to "Filelist Output Order"
103929>>>
103929>>>                    Object oRadio1 is a Radio
103931>>>                        Set Label to "Filelist Number"
103932>>>                        Set Size to 10 61
103933>>>                        Set Location to 10 7
103934>>>                    End_Object
103935>>>
103935>>>                    Object oRadio2 is a Radio
103937>>>                        Set Label to "Logical Name"
103938>>>                        Set Size to 10 61
103939>>>                        Set Location to 10 77
103940>>>                    End_Object
103941>>>
103941>>>                    Object oRadio3 is a Radio
103943>>>                        Set Label to "Root Name"
103944>>>                        Set Size to 10 61
103945>>>                        Set Location to 10 147
103946>>>                    End_Object
103947>>>
103947>>>                    Object oRadio4 is a Radio
103949>>>                        Set Label to "Display Name"
103950>>>                        Set Size to 10 62
103951>>>                        Set Location to 10 213
103952>>>                    End_Object
103953>>>
103953>>>                    Procedure Notify_Select_State Integer iToItem Integer iFromItem
103956>>>                        Forward Send Notify_Select_State iToItem iFromItem
103958>>>                        Set piSortOrder of oPrintFilelist_btn to iToItem
103959>>>                    End_Procedure
103960>>>
103960>>>                End_Object
103961>>>
103961>>>            End_Object
103962>>>
103962>>>        End_Object
103963>>>
103963>>>    End_Object
103964>>>
103964>>>    Procedure OnFileDropped String sFilename Boolean bLast
103967>>>        String sPath sTest
103967>>>        Forward Send OnFileDropped sFilename bLast
103969>>>        If (bLast = True) Begin
103971>>>            Get ParseFileName sFilename to sTest
103972>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
103974>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
103975>>>                Procedure_Return
103976>>>            End
103976>>>>
103976>>>            Set Value of oFilelistPath_fm to sFilename
103977>>>        End
103977>>>>
103977>>>    End_Procedure
103978>>>
103978>>>End_Object
103979>
103979>        Procedure Activate_About
103982>            Send DoAbout "" "" ("Copyright 2016-2018" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DbUpdateFrameworkDF19.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com"
103983>        End_Procedure
103984>
103984>        On_Key Key_Ctrl+Key_Tab           Send Switch_Prior_View
103985>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Next_View
103986>        On_Key Key_Ctrl+Key_W             Send Close_Panel
103987>    End_Object
103988>
103988>
103988>    // All of the code below are methods and augmentations which makes this work well as a test program. This:
103988>    // 1. Supports an auto-activate feature where all dialogs in the view and report menu are activated upon startup
103988>    // 2. forces the panel to resize if it is not large enough to accomodate all of the views.
103988>    // This code was placed directly in the testproject template and, therefore, directly in the .src file so
103988>    // a developer can easily modify this to fit their own needs. It is not expected that these techniques would
103988>    // get used in actual deployed projects.
103988>
103988>    // special test component code to activate all views and reports. For testing we assume
103988>    // that you want to see everything.
103988>
103988>    Procedure AutoActivate
103991>        Handle hoMenu
103991>
103991>        // this activates all views from the view menu
103991>        Get phoViewMenu to hoMenu
103992>        If hoMenu Begin
103994>           Broadcast Send Execute of hoMenu
103996>        End
103996>
103996>        // this activates all views from the report view menu
103996>        Get phoReportMenu to hoMenu
103997>        If hoMenu Begin
103999>           Broadcast Send Execute of hoMenu
104001>        End
104001>    End_Procedure
104002>
104002>    // This checks all views within the client area to make sure that they fit within
104002>    // the client area. If not we will adjust the main panel so everything fits. This
104002>    // can only be done after the objects are all activated.
104002>
104002>    Procedure MakeGoodPanelSize
104005>        Handle hoView hoClient
104005>        Integer iSize iLoc iHeight iWidth iOldHeight iOldWidth
104005>        Integer iLeft iTop iRight iBottom
104005>        Get Client_Id to hoClient
104006>        If hoClient Begin
104008>
104008>            // if not using commandbars or for some reason they are not created yet we
104008>            // will use whatever the client size is
104008>            If (ghoCommandBars=0 or not(IsComObjectCreated(ghoCommandBars))) Begin
104010>                Get GuiSize of hoClient to iSize  // starting size of client area
104011>                Move (Hi(iSize)) to iOldHeight
104012>                Move (Low(iSize)) to iOldWidth
104013>            End
104013>            Else Begin
104014>               // if commandbars are created, the actual size of the client area must be obtained
104014>               // from the commandbar
104014>               Send ComGetClientRect of ghoCommandBars (&iLeft) (&iTop) (&iRight) (&iBottom)
104015>               Move (iRight-iLeft) to iOldWidth
104016>               Move (iBottom-iTop) to iOldHeight
104017>            End
104017>
104017>            Move iOldHeight to iHeight
104018>            Move iOldWidth to iWidth
104019>
104019>            // for each mdi client see if it fits, keep track of largest size needed
104019>            Get Next_Mdi_Dialog of hoClient True to hoView // find first
104020>            While (hoView)
104024>                Get GuiWindowSize of hoView to iSize    // size of view
104025>                Get GuiLocation of hoView to iLoc // location of view
104026>                Move (hi(iSize)+hi(iLoc)+10 max iHeight)  to iHeight // max height needed (+10 pixels is small border)
104027>                Move (low(iSize)+low(iLoc)+10 max iWidth) to iWidth  // max width needed
104028>                Get Next_Mdi_Dialog of hoClient False to hoView // find next view
104029>            Loop
104030>            Move (iHeight-iOldHeight  max 0) to iHeight // get delta compared to old size. We want delta
104031>            Move (iWidth-iOldWidth max 0) to iWidth     // only if the new size is bigger (i.e., > 0)
104032>            If  (iHeight>0 or iWidth>0) Begin
104034>                Get GuiSize to iSize // now add the delta to the panel size
104035>                Set GuiSize to (hi(iSize)+iHeight) (low(iSize)+iWidth)
104036>                Send Adjust_Logicals // adjust from gui to regular size
104037>            End
104037>        End
104037>    End_Procedure
104038>
104038>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
104038>    // in the oHtmlHelp object, so we need to explitetly send the message
104038>    // to that object.
104038>    Procedure ShowProgramHelp
104041>        Send DoDisplayKeyword of oHtmlHelp "cDbUpdateFunctionLibrary"
104042>    End_Procedure
104043>
104043>    On_Key Key_F1 Send ShowProgramHelp
104044>End_Object
104045>
104045>// We do this to activate the first view:
104045>Send Activate_oSQLConnections_vw of (Client_Id(phoMainPanel(ghoApplication)))
104046>Start_UI
104047>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 54888
Total Resources: 6
Total Commands : 104046
Total Windows  : 1
Total Pages    : 1
Static Data    : 753917
Message area   : 661392
Total Blocks   : 76638
