Compiling Program: C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\DUFInternalUpdateProgram.src
Memory Available: 2147483646
1>// *** DUF Auto-Generated Program - For Internal Usage Only! ***
1>// *** Use it to send to a collegue that is working on the same project, ***
1>// *** to update his/her database with database changes you have made. ***
1>    CompilerLevelWarning All On
1>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cApplication.pkg)
1>>>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\windows.pkd)
7602>>>
7602>>>Use LanguageText.pkg
7602>>>Use WinUser.pkg
7602>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinShell.pkg)
7602>>>>>Use DLL.pkg
7602>>>>>
7602>>>>>External_Function PathFileExists "PathFileExistsA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7603>>>>>
7603>>>>>External_Function PathIsRelative "PathIsRelativeA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7604>>>>>
7604>>>>>External_Function PathRemoveExtension "PathRemoveExtensionA" shlwapi.dll ;    Address aPath ;    Returns Integer // void
7605>>>>>
7605>>>>>External_Function PathRemoveFileSpec "PathRemoveFileSpecA" shlwapi.dll ;    Address aPath ;    Returns Integer
7606>>>>>
7606>>>>>
7606>>>>>Define URL_UNESCAPE_INPLACE                    for |CI$00100000
7606>>>>>Define URL_ESCAPE_SEGMENT_ONLY                 for |CI$00002000
7606>>>>>
7606>>>>>External_Function UrlUnescape "UrlUnescapeA" shlwapi.dll;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord dwFlags;    Returns Integer // S_OK if succesfull
7607>>>>>
7607>>>>>External_Function UrlEscape "UrlEscapeA" shlwapi.dll;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord dwFlags;    Returns Integer
7608>>>>>
7608>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWorkspace.pkg)
7608>>>>>Use VdfBase.pkg
7608>>>>>Use tWinStructs.pkg
7608>>>>>Use LanguageText.pkg
7608>>>>>Use WinShell.pkg // Shell API functions
7608>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\seq_chnl.pkg)
7608>>>>>>>Use LanguageText.pkg
7608>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files (x86)\DataFlex 19.1\Pkg\errornum.inc)
7608>>>>>>>>
7608>>>>>>>>//
7608>>>>>>>>// these will get defined in fmac
7608>>>>>>>>//
7608>>>>>>>>// already defined
7608>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
7608>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
7608>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
7608>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
7608>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
7608>>>>>>>>// new compiler errors used by fmac
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
7608>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
7608>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
7608>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>
7608>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
7608>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
7608>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
7608>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
7608>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
7608>>>>>>>// so that programs that use direct_input/output
7608>>>>>>>// w/o specifying a channel will work.
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Integer Seq$Channel$Error$Mode
7608>>>>>>>
7608>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer Mode
7610>>>>>>>    Move Mode to Seq$Channel$Error$Mode
7611>>>>>>>End_Procedure
7612>>>>>>>
7612>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
7614>>>>>>>    Function_Return Seq$Channel$Error$Mode
7615>>>>>>>End_Function
7616>>>>>>>
7616>>>>>>>Object Seq_Channel_List is an Array
7618>>>>>>>    Procedure Initialize
7621>>>>>>>        Integer Itm
7621>>>>>>>        
7621>>>>>>>        Move DF_SEQ_CHANNEL_MIN to Itm
7622>>>>>>>        
7622>>>>>>>        While Itm LE DF_SEQ_CHANNEL_MAX
7626>>>>>>>            Set Array_Value  Itm to DF_SEQ_CHANNEL_MODE_CLOSED
7627>>>>>>>            Increment Itm
7628>>>>>>>        Loop
7629>>>>>>>>
7629>>>>>>>    End_Procedure
7630>>>>>>>    
7630>>>>>>>    Send Initialize
7631>>>>>>>End_Object
7632>>>>>>>
7632>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
7633>>>>>>>
7633>>>>>>>Function Seq_Channel_Mode Global Integer Chnl Returns Integer
7635>>>>>>>    Function_Return (Integer_Value(Seq_Channel_List(Self), Chnl))
7636>>>>>>>End_Function
7637>>>>>>>
7637>>>>>>>Procedure Set Seq_Channel_Mode Global Integer Chnl Integer Mode
7639>>>>>>>    Set Array_Value of (Seq_Channel_List(Self))  Chnl to Mode
7640>>>>>>>End_Procedure
7641>>>>>>>
7641>>>>>>>Function Seq_New_Channel Global Returns Integer
7643>>>>>>>    Integer Obj Chnl
7643>>>>>>>    
7643>>>>>>>    Move DF_SEQ_START_CHANNEL to Chnl
7644>>>>>>>    
7644>>>>>>>    While Chnl LE DF_SEQ_CHANNEL_MAX
7648>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7650>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7651>>>>>>>            Function_Return Chnl
7652>>>>>>>        End
7652>>>>>>>>
7652>>>>>>>        
7652>>>>>>>        Increment Chnl
7653>>>>>>>    Loop
7654>>>>>>>>
7654>>>>>>>    
7654>>>>>>>    // wrap back to beginning
7654>>>>>>>    Move 0 to Chnl
7655>>>>>>>    
7655>>>>>>>    While Chnl LT DF_SEQ_START_CHANNEL
7659>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7661>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7662>>>>>>>            Function_Return Chnl
7663>>>>>>>        End
7663>>>>>>>>
7663>>>>>>>        
7663>>>>>>>        Increment Chnl
7664>>>>>>>    Loop
7665>>>>>>>>
7665>>>>>>>    
7665>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
7666>>>>>>>End_Function
7667>>>>>>>
7667>>>>>>>Procedure Seq_Release_Channel Global Integer Chnl
7669>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
7672>>>>>>>End_Procedure
7673>>>>>>>
7673>>>>>>>Function Seq_Open_Input_Channel Global String Dvc Returns Integer
7675>>>>>>>    Integer Chnl
7675>>>>>>>    
7675>>>>>>>    Move (Seq_New_Channel()) to Chnl
7676>>>>>>>    
7676>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7678>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) ;            Error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
7681>>>>>>>        Function_Return Chnl
7682>>>>>>>    End
7682>>>>>>>>
7682>>>>>>>    
7682>>>>>>>    Move False to Err
7683>>>>>>>    Direct_Input channel Chnl Dvc
7685>>>>>>>    
7685>>>>>>>    If (Err) Begin
7687>>>>>>>        Send Seq_Release_Channel Chnl
7688>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7689>>>>>>>    End
7689>>>>>>>>
7689>>>>>>>    
7689>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
7690>>>>>>>    
7690>>>>>>>    Function_Return Chnl
7691>>>>>>>End_Function
7692>>>>>>>
7692>>>>>>>Function Seq_Open_Output_Channel Global String Dvc Returns Integer
7694>>>>>>>    Integer Chnl
7694>>>>>>>    
7694>>>>>>>    Move (Seq_New_Channel()) to Chnl
7695>>>>>>>    
7695>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7697>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7699>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7700>>>>>>>>
7700>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7701>>>>>>>        End
7701>>>>>>>>
7701>>>>>>>        
7701>>>>>>>        Function_Return Chnl
7702>>>>>>>    End
7702>>>>>>>>
7702>>>>>>>    
7702>>>>>>>    Move False to Err
7703>>>>>>>    Direct_Output channel Chnl Dvc
7705>>>>>>>    
7705>>>>>>>    If (Err) Begin
7707>>>>>>>        Send Seq_Release_Channel Chnl
7708>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7709>>>>>>>    End
7709>>>>>>>>
7709>>>>>>>    
7709>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7710>>>>>>>    
7710>>>>>>>    Function_Return Chnl
7711>>>>>>>End_Function
7712>>>>>>>
7712>>>>>>>Function Seq_Append_Output_Channel Global String Dvc Returns Integer
7714>>>>>>>    Integer Chnl
7714>>>>>>>    
7714>>>>>>>    Move (Seq_New_Channel()) to Chnl
7715>>>>>>>    
7715>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7717>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7719>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7720>>>>>>>>
7720>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7721>>>>>>>        End
7721>>>>>>>>
7721>>>>>>>        
7721>>>>>>>        Function_Return Chnl
7722>>>>>>>    End
7722>>>>>>>>
7722>>>>>>>    
7722>>>>>>>    Move False to Err
7723>>>>>>>    Append_Output channel Chnl Dvc
7725>>>>>>>    
7725>>>>>>>    If (Err) Begin
7727>>>>>>>        Send Seq_Release_Channel Chnl
7728>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7729>>>>>>>    End
7729>>>>>>>>
7729>>>>>>>    
7729>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7730>>>>>>>    
7730>>>>>>>    Function_Return Chnl
7731>>>>>>>End_Function
7732>>>>>>>
7732>>>>>>>Procedure Seq_Close_Channel Global Integer Chnl
7734>>>>>>>    Integer Mode
7734>>>>>>>    
7734>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) Begin
7736>>>>>>>        Move (Seq_Channel_Mode(Chnl)) to Mode
7737>>>>>>>        
7737>>>>>>>        If (Mode = DF_SEQ_CHANNEL_MODE_OUTPUT) ;            Close_Output channel Chnl
7741>>>>>>>        Else If (Mode = DF_SEQ_CHANNEL_MODE_INPUT) ;            Close_Input channel Chnl
7746>>>>>>>        // If channel not open, release it! No (fatal) Error.
7746>>>>>>>        Send Seq_Release_Channel Chnl
7747>>>>>>>    End
7747>>>>>>>>
7747>>>>>>>End_Procedure
7748>>>>>>>
7748>>>>>Use GlobalFunctionsProcedures.pkg
7748>>>>>
7748>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
7748>>>>>Register_Function VdfSystemDfPath   Returns String
7748>>>>>Register_Function VdfSystemMakePath Returns String
7748>>>>>
7748>>>>>Enum_List
7748>>>>>    Define wsWorkspaceOpened       // WS opened ok
7748>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
7748>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
7748>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
7748>>>>>    Define wsFileListEmpty         // The FileList entry was empty
7748>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
7748>>>>>End_Enum_List
7748>>>>>
7748>>>>>Define INVALID_HANDLE_VALUE for -1
7748>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
7748>>>>>
7748>>>>>
7748>>>>>External_Function winFindFirstFile "FindFirstFileA" Kernel32.dll ;    String sFileSpec Pointer lpsWin32FindData Returns Handle
7749>>>>>
7749>>>>>External_Function winFindNextFile "FindNextFileA" Kernel32.dll ;    Handle hFindFile Pointer lpsWin32FindData Returns Handle
7750>>>>>
7750>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
7751>>>>>
7751>>>>>Function DoesFileExist Global String sFilename Returns Boolean
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    String sMask
7753>>>>>    Integer iVoid
7753>>>>>    Handle hFileFind
7753>>>>>    
7753>>>>>    Move (winFindFirstFile(ToAnsi(sFilename), AddressOf(Win32FindData))) to hFileFind   // JVH 8.3.8.0 must pass Ansi filename
7754>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
7756>>>>>        Move (winFindClose(hFileFind)) to iVoid
7757>>>>>    End
7757>>>>>>
7757>>>>>    
7757>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
7758>>>>>End_Function
7759>>>>>
7759>>>>>
7759>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cIniFile.pkg)
7759>>>>>>>Use Dll.pkg
7759>>>>>>>Use errornum.inc
7759>>>>>>>Use LanguageText.pkg
7759>>>>>>>Use GlobalFunctionsProcedures.pkg
7759>>>>>>>
7759>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
7759>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
7759>>>>>>>External_Function WritePrivateProfileString "WritePrivateProfileStringA" Kernel32.dll ;    String sSection String sKeyName String sValue String sFileName Returns Integer
7760>>>>>>>
7760>>>>>>>External_Function GetPrivateProfileString "GetPrivateProfileStringA" Kernel32.dll ;    Address aSection Address aKeyName Address aDefault Pointer lpsValue Integer nSize String sFileName Returns Integer
7761>>>>>>>
7761>>>>>>>Class cIniFile is a cObject
7762>>>>>>>    Procedure Construct_Object
7764>>>>>>>        Forward Send Construct_Object
7766>>>>>>>        
7766>>>>>>>        Property String psFileName
7767>>>>>>>    End_Procedure
7768>>>>>>>    
7768>>>>>>>    Procedure WriteString String sSection String sKey String sValue
7770>>>>>>>        Boolean bSuccess
7770>>>>>>>        
7770>>>>>>>        If (trim(psFileName(Self))="") Begin
7772>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7773>>>>>>>>
7773>>>>>>>            Procedure_Return
7774>>>>>>>        End
7774>>>>>>>>
7774>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), ToAnsi(sValue), ToAnsi(psFilename(Self)))) to bSuccess
7775>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
7778>>>>>>>    End_Procedure
7779>>>>>>>    
7779>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
7781>>>>>>>        Integer iNumChars iSizeValue
7781>>>>>>>        String sValue
7781>>>>>>>        
7781>>>>>>>        Move (ToAnsi(sSection)) to sSection
7782>>>>>>>        Move (ToAnsi(sKey))     to sKey
7783>>>>>>>        Move (ToAnsi(sDefault)) to sDefault
7784>>>>>>>        
7784>>>>>>>        Move 2047 to iSizeValue
7785>>>>>>>        
7785>>>>>>>        Move (Pad(" ",iSizeValue)) to sValue
7786>>>>>>>        
7786>>>>>>>        If (trim(psFileName(Self))="") Begin
7788>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7789>>>>>>>>
7789>>>>>>>            Function_Return ''
7790>>>>>>>        End
7790>>>>>>>>
7790>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, ToAnsi(psFilename(Self)))) to iNumChars
7791>>>>>>>        Function_Return  (ToOem(CString(sValue)))
7792>>>>>>>    End_Function
7793>>>>>>>    
7793>>>>>>>    Function SectionExists String sSection Returns Boolean
7795>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
7795>>>>>>>        Handle hoKeys
7795>>>>>>>        Integer icKey iKey
7795>>>>>>>        
7795>>>>>>>        Get Create U_ARRAY to hoKeys
7796>>>>>>>        Send ReadSection sSection hoKeys
7797>>>>>>>        Get Item_Count of hoKeys to icKey
7798>>>>>>>        Send Destroy of hoKeys
7799>>>>>>>        
7799>>>>>>>        Function_Return (icKey >0)
7800>>>>>>>    End_Function
7801>>>>>>>    
7801>>>>>>>    Procedure ReadSection String sSection Handle hoArray
7803>>>>>>>        Integer iNumChars iSizeValue iPos
7803>>>>>>>        Pointer lpsKeys
7803>>>>>>>        String sKeys sKey
7803>>>>>>>        
7803>>>>>>>        Move 16384 to iSizeValue
7804>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sKeys
7805>>>>>>>        
7805>>>>>>>        Move (AddressOf(sKeys)) to lpsKeys
7806>>>>>>>        
7806>>>>>>>        Move (ToAnsi(sSection)) to sSection
7807>>>>>>>        
7807>>>>>>>        If (trim(psFileName(Self))="") Begin
7809>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7810>>>>>>>>
7810>>>>>>>            Procedure_Return
7811>>>>>>>        End
7811>>>>>>>>
7811>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), ToAnsi(psFilename(Self)))) to iNumChars
7812>>>>>>>        If (iNumChars >0) Begin
7814>>>>>>>            Repeat
7814>>>>>>>>
7814>>>>>>>                Move (Pos(Character(0),sKeys)) to iPos
7815>>>>>>>                If (iPos >1) Begin
7817>>>>>>>                    Move (Left(sKeys,iPos -1))  to sKey
7818>>>>>>>                    Move (Right(sKeys,Length(sKeys) - iPos)) to sKeys
7819>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sKey))
7820>>>>>>>                End
7820>>>>>>>>
7820>>>>>>>            Until (iPos <=1)
7822>>>>>>>        End
7822>>>>>>>>
7822>>>>>>>    End_Procedure
7823>>>>>>>    
7823>>>>>>>    Procedure ReadSections Handle hoArray
7825>>>>>>>        Integer iNumChars iSizeValue iPos
7825>>>>>>>        Pointer lpsSections
7825>>>>>>>        String sSections sSection
7825>>>>>>>        
7825>>>>>>>        Move 16384 to iSizeValue
7826>>>>>>>        
7826>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sSections
7827>>>>>>>        Move (AddressOf(sSections)) to lpsSections
7828>>>>>>>        
7828>>>>>>>        If (trim(psFileName(Self))="") Begin
7830>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7831>>>>>>>>
7831>>>>>>>            Procedure_Return
7832>>>>>>>        End
7832>>>>>>>>
7832>>>>>>>        Move (GetPrivateProfileString(0, 0, 0, lpsSections, Length(sSections), ToAnsi(psFilename(Self)))) to iNumChars
7833>>>>>>>        If (iNumChars >0) Begin
7835>>>>>>>            Repeat
7835>>>>>>>>
7835>>>>>>>                Move (Pos(Character(0),sSections)) to iPos
7836>>>>>>>                If (iPos >1) Begin
7838>>>>>>>                    Move (Left(sSections,iPos -1)) to sSection
7839>>>>>>>                    Move (Right(sSections, Length(sSections) - iPos)) to sSections
7840>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sSection))
7841>>>>>>>                End
7841>>>>>>>>
7841>>>>>>>            Until (iPos <=1)
7843>>>>>>>        End
7843>>>>>>>>
7843>>>>>>>        
7843>>>>>>>    End_Procedure
7844>>>>>>>    
7844>>>>>>>    Procedure DeleteSection String sSection
7846>>>>>>>        
7846>>>>>>>        If (trim(psFileName(Self))="") Begin
7848>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7849>>>>>>>>
7849>>>>>>>            Procedure_Return
7850>>>>>>>        End
7850>>>>>>>>
7850>>>>>>>        If (WritePrivateProfileString(ToAnsi(sSection), "", "", ToAnsi(psFilename(Self))) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
7853>>>>>>>    End_Procedure
7854>>>>>>>    
7854>>>>>>>    Procedure DeleteKey String sSection String sKey
7856>>>>>>>        Integer iVoid
7856>>>>>>>        If (trim(psFileName(Self))="") Begin
7858>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7859>>>>>>>>
7859>>>>>>>            Procedure_Return
7860>>>>>>>        End
7860>>>>>>>>
7860>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", ToAnsi(psFilename(Self)))) to iVoid
7861>>>>>>>    End_Procedure
7862>>>>>>>    
7862>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
7864>>>>>>>        Handle hoKeys
7864>>>>>>>        Integer iKey
7864>>>>>>>        Boolean bExists
7864>>>>>>>        
7864>>>>>>>        Move (False) to bExists
7865>>>>>>>        
7865>>>>>>>        Move (ToAnsi(Uppercase(sKey))) to sKey
7866>>>>>>>        
7866>>>>>>>        Get Create U_ARRAY to hoKeys
7867>>>>>>>        
7867>>>>>>>        Send ReadSection sSection hoKeys
7868>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
7874>>>>>>>>
7874>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
7876>>>>>>>                Move (True) to bExists
7877>>>>>>>            End
7877>>>>>>>>
7877>>>>>>>        Loop
7878>>>>>>>>
7878>>>>>>>        
7878>>>>>>>        Send Destroy of hoKeys
7879>>>>>>>        
7879>>>>>>>        Function_Return bExists
7880>>>>>>>    End_Function
7881>>>>>>>    
7881>>>>>>>End_Class
7882>>>>>
7882>>>>>Class cWorkspace is a cObject
7883>>>>>    
7883>>>>>    Procedure Construct_Object
7885>>>>>        Forward Send Construct_Object
7887>>>>>        
7887>>>>>        
7887>>>>>        Property String psAppSrcPath
7888>>>>>        Property String psBitmapPath
7889>>>>>        Property String psDataPath
7890>>>>>        Property String psDdSrcPath
7891>>>>>        Property String psDescription
7892>>>>>        Property String psFileList
7893>>>>>        Property String psHelpPath
7894>>>>>        Property String psHome
7895>>>>>        Property String psIdeSrcPath
7896>>>>>        Property String psProgramPath
7897>>>>>        Property String psAppHtmlPath
7898>>>>>        Property String psWorkspaceName
7899>>>>>        Property String psWorkspaceWSFile
7900>>>>>        Property String psConnectionIni
7901>>>>>        
7901>>>>>        Property String psSystemDfPath // took from the Registry!
7902>>>>>        Property String psSystemMakePath // took from the Registry!
7903>>>>>        Property String psDfPath        // Calculated
7904>>>>>        
7904>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
7905>>>>>        
7905>>>>>    End_Procedure
7906>>>>>    
7906>>>>>    Function FullPathNames String sShortPathNames Returns String
7908>>>>>        String sFileName
7908>>>>>        String sFullPathNames sFullPathName sShortPathName
7908>>>>>        Pointer lpsFilePart
7908>>>>>        Integer icChar // the number of characters returned
7908>>>>>        Integer iPos
7908>>>>>        
7908>>>>>        Move (Pos(";", sShortPathNames)) to iPos
7909>>>>>        While (length(sShortPathNames) >0)
7913>>>>>            If (iPos =0) Begin
7915>>>>>                Move sShortPathNames to sShortPathName
7916>>>>>                Move "" to sShortPathNames
7917>>>>>            End
7917>>>>>>
7917>>>>>            Else Begin // multiple paths
7918>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
7919>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
7920>>>>>            End
7920>>>>>>
7920>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
7921>>>>>            Move -1 to lpsFilePart
7922>>>>>            Move (GetFullPathName(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
7923>>>>>            Append sFullPathNames (CString(sFullPathName))
7924>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
7927>>>>>            Move (Pos(";", sShortPathNames)) to iPos
7928>>>>>        Loop
7929>>>>>>
7929>>>>>        
7929>>>>>        Function_Return sFullPathNames
7930>>>>>    End_Function
7931>>>>>    
7931>>>>>    Function GetApplicationPath Returns String
7933>>>>>        // Returns the path of the Application (no trailing "\")
7933>>>>>        String sApplicationFileName sPath
7933>>>>>        Boolean bRemoved
7933>>>>>        Integer iNumChars
7933>>>>>        String sFilename
7933>>>>>        
7933>>>>>        Move (Repeat(Character(0), 1024)) to sApplicationFileName
7934>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
7935>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
7936>>>>>        
7936>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
7937>>>>>        Move (CString(sApplicationFileName)) to sPath
7938>>>>>        
7938>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
7941>>>>>        Function_Return sPath
7942>>>>>    End_Function
7943>>>>>    
7943>>>>>    Procedure DoClearPaths
7945>>>>>        // Call this prior to changing from one WorkspAce to another
7945>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
7945>>>>>        Set psHome           to ""
7946>>>>>        Set psAppSrcPath     to ""
7947>>>>>        Set psBitmapPath     to ""
7948>>>>>        Set psDataPath       to ""
7949>>>>>        Set psDdSrcPath      to ""
7950>>>>>        Set psDescription    to ""
7951>>>>>        Set psFileList       to ""
7952>>>>>        Set psHelpPath       to ""
7953>>>>>        Set psIdeSrcPath     to ""
7954>>>>>        Set psAppHtmlPath    to ""
7955>>>>>        Set psProgramPath    to ""
7956>>>>>        Set psWorkspaceName  to ""
7957>>>>>        Set psSystemDfPath   to ""
7958>>>>>        Set psSystemMakePath to ""
7959>>>>>        Set psWorkspaceWSFile to ""
7960>>>>>        Set psConnectionIni to ""
7961>>>>>    End_Procedure
7962>>>>>    
7962>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
7964>>>>>        String sApplicationStartPath
7964>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
7964>>>>>        Boolean bRemoved
7964>>>>>        Handle hoIniFile
7964>>>>>        Boolean bSuccess // call succeeded?
7964>>>>>        String sOldDirectory
7964>>>>>        String sSystemDfPath sSystemMakePath
7964>>>>>        Boolean bExist // does the WS file exist?
7964>>>>>        Boolean bChangingWorkspace
7964>>>>>        
7964>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
7964>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
7964>>>>>        
7964>>>>>        Set psWorkspaceWSFile to ""
7965>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
7968>>>>>        
7968>>>>>        // Append extension if not supplied...
7968>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
7970>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
7971>>>>>        End
7971>>>>>>
7971>>>>>        
7971>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
7972>>>>>        
7972>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
7974>>>>>            // Set the properties to the paths of the Workspace
7974>>>>>            // Find the WS file (with program)...
7974>>>>>            Get GetApplicationPath to sApplicationStartPath
7975>>>>>            
7975>>>>>            Move sWorkspaceFile to sWsName
7976>>>>>            Move (sApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
7977>>>>>        End
7977>>>>>>
7977>>>>>        Else Begin
7978>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
7979>>>>>            
7979>>>>>            Move sWorkspaceFile to sApplicationStartPath
7980>>>>>            Move (PathRemoveFileSpec(AddressOf(sApplicationStartPath))) to bRemoved
7981>>>>>        End
7981>>>>>>
7981>>>>>        
7981>>>>>        // Ensure that the file can be found...
7981>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
7981>>>>>        // [JVH] Turn off support for
7981>>>>>        // Ansi extended characters in workspace until we can
7981>>>>>        // resolve all open issues
7981>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
7982>>>>>        File_Exist sWorkspaceFile bExist
7983>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
7986>>>>>        
7986>>>>>        Get psHome           to sHome
7987>>>>>        Get psAppSrcPath     to sAppSrcPath
7988>>>>>        Get psAppHtmlPath    to sAppHtmlPath
7989>>>>>        Get psBitmapPath     to sBitmapPath
7990>>>>>        Get psDataPath       to sDataPath
7991>>>>>        Get psDdSrcPath      to sDdSrcPath
7992>>>>>        Get psDescription    to sDescription
7993>>>>>        Get psFileList       to sFileList
7994>>>>>        Get psHelpPath       to sHelpPath
7995>>>>>        Get psIdeSrcPath     to sIdeSrcPath
7996>>>>>        Get psProgramPath    to sProgramPath
7997>>>>>        Get psSystemDfPath   to sSystemDfPath
7998>>>>>        Get psSystemMakePath to sSystemMakePath
7999>>>>>        Get psWorkspaceName  to sWorkspaceName
8000>>>>>        Get psConnectionIni to sConnectionIni
8001>>>>>        
8001>>>>>        Get_Current_Directory to sOldDirectory
8002>>>>>        // Note- this conversion is temporarily rolled back
8002>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(sApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
8002>>>>>        Move (SetCurrentDirectory(CString(sApplicationStartPath))) to bSuccess
8003>>>>>        
8003>>>>>        Get Create U_cIniFile to hoIniFile
8004>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
8005>>>>>        
8005>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
8008>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
8011>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
8014>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
8017>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
8020>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
8023>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
8026>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
8029>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
8032>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
8035>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
8038>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
8041>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
8044>>>>>        
8044>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
8047>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
8050>>>>>        
8050>>>>>        Set psHome          to (FullPathNames(Self, sHome))
8051>>>>>        
8051>>>>>        // Set CWD to Home...
8051>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
8052>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
8053>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
8054>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
8055>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
8056>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
8057>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
8058>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
8059>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
8060>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
8061>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
8062>>>>>        
8062>>>>>        Set psWorkspaceName to sWorkspaceName
8063>>>>>        Set psDescription   to sDescription
8064>>>>>        
8064>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
8065>>>>>        
8065>>>>>        // Restore CWD...
8065>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
8066>>>>>        
8066>>>>>        // Check for error conditions:
8066>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
8066>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
8069>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
8072>>>>>        
8072>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
8073>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
8076>>>>>        
8076>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
8079>>>>>        
8079>>>>>        Send DoAssignPaths // set psDfPath
8080>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
8081>>>>>        Set pbWorkspaceOpened to True
8082>>>>>        
8082>>>>>        Function_Return wsWorkspaceOpened
8083>>>>>    End_Function
8084>>>>>    
8084>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
8086>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
8086>>>>>        
8086>>>>>        Handle hoSections hoIniFile
8086>>>>>        Integer iWorkspace eOpened
8086>>>>>        String sWorkspaceName sPath
8086>>>>>        String sVdfRootDir
8086>>>>>        
8086>>>>>        Get Create U_Array    to hoSections
8087>>>>>        Get Create U_cIniFile to hoIniFile
8088>>>>>        
8088>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8091>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8094>>>>>        
8094>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8095>>>>>        
8095>>>>>        Send ReadSections of hoIniFile hoSections
8096>>>>>        
8096>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
8102>>>>>>
8102>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
8103>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
8105>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
8106>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
8109>>>>>                
8109>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
8110>>>>>                Send Destroy of hoSections
8111>>>>>                Send Destroy of hoIniFile
8112>>>>>                Function_Return eOpened
8113>>>>>            End
8113>>>>>>
8113>>>>>        Loop
8114>>>>>>
8114>>>>>        
8114>>>>>        Send Destroy of hoSections
8115>>>>>        Send Destroy of hoIniFile
8116>>>>>        Function_Return wsWorkspaceNotFound
8117>>>>>    End_Function
8118>>>>>    
8118>>>>>    Function IsRegistered String sWorkspace Returns Boolean
8120>>>>>        Boolean bRegistered
8120>>>>>        Handle hoIniFile
8120>>>>>        String sVdfRootDir
8120>>>>>        
8120>>>>>        Get Create U_cIniFile to hoIniFile
8121>>>>>        
8121>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8124>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8127>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8128>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
8129>>>>>        
8129>>>>>        Send Destroy of hoIniFile
8130>>>>>        
8130>>>>>        Function_Return bRegistered
8131>>>>>    End_Function
8132>>>>>    
8132>>>>>    Function VdfSystemDfPath Returns String
8134>>>>>        String sSystemDfPath
8134>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
8137>>>>>        
8137>>>>>        Function_Return sSystemDfPath
8138>>>>>    End_Function
8139>>>>>    
8139>>>>>    Function VdfSystemMakePath Returns String
8141>>>>>        String sSystemMakePath
8141>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
8144>>>>>        
8144>>>>>        Function_Return sSystemMakePath
8145>>>>>    End_Function
8146>>>>>    
8146>>>>>    Procedure DoAssignPaths
8148>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
8148>>>>>        
8148>>>>>        Get psDataPath     to sDataPath
8149>>>>>        Get psBitmapPath   to sBitmapPath
8150>>>>>        Get psHelpPath     to sHelpPath
8151>>>>>        Get psProgramPath  to sProgramPath
8152>>>>>        Get psSystemDfPath to sSystemDfPath
8153>>>>>        
8153>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
8154>>>>>        
8154>>>>>    End_Procedure
8155>>>>>    
8155>>>>>    Procedure DoSetPaths
8157>>>>>        // [JVH] must convert paths to Ansi before setting these values
8157>>>>>        // Note- this conversion is temporarily rolled back
8157>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
8157>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
8157>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
8160>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
8163>>>>>    End_Procedure
8164>>>>>    
8164>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
8166>>>>>        String sPath
8166>>>>>        
8166>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
8169>>>>>        Else Begin
8170>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
8171>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
8172>>>>>            Send hmGeneric to hoCallBack ""
8173>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
8174>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
8175>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
8176>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
8177>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
8178>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
8179>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
8180>>>>>        End
8180>>>>>>
8180>>>>>    End_Procedure
8181>>>>>    
8181>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
8183>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
8183>>>>>        // returns a corresponding message string.
8183>>>>>        String sError
8183>>>>>        
8183>>>>>        Case Begin
8183>>>>>            Case (eErrorCode = wsWorkspaceOpened)
8185>>>>>                Move C_$NoErrors to sError
8186>>>>>                Case Break
8187>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
8190>>>>>                Move C_$NoWsName to sError
8191>>>>>                Case Break
8192>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
8195>>>>>                Move C_$NoWsFileFound to sError
8196>>>>>                Case Break
8197>>>>>            Case (eErrorCode = wsDataPathEmpty)
8200>>>>>                Move C_$NoWsDataPath to sError
8201>>>>>                Case Break
8202>>>>>            Case (eErrorCode = wsFileListEmpty)
8205>>>>>                Move C_$NoWsFileList to sError
8206>>>>>                Case Break
8207>>>>>            Case (eErrorCode = wsFileListNotExist)
8210>>>>>                Move C_$NoFileListCfg to sError
8211>>>>>                Case Break
8212>>>>>            Case Else
8212>>>>>                Move C_$UnknownError to sError
8213>>>>>                Case Break
8214>>>>>        Case End
8214>>>>>        
8214>>>>>        Function_Return (sError-".")
8215>>>>>    End_Function
8216>>>>>    
8216>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
8218>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
8218>>>>>        String sVdfRootDir
8218>>>>>        Handle hoIniFile
8218>>>>>        String sPath
8218>>>>>        String sFileName
8218>>>>>        String sWorkspacePath
8218>>>>>        
8218>>>>>        Move "" to sFileName
8219>>>>>        
8219>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8222>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8225>>>>>        
8225>>>>>        Get Create U_cIniFile to hoIniFile
8226>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8227>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
8228>>>>>        If (sWorkspacePath <>"") Begin
8230>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
8233>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
8234>>>>>        End
8234>>>>>>
8234>>>>>        Send Destroy of hoIniFile
8235>>>>>        
8235>>>>>        Function_Return sFileName
8236>>>>>    End_Function
8237>>>>>    
8237>>>>>    Function CountOfPaths String sPaths Returns Integer
8239>>>>>        // Returns the number of paths defined in a string of paths
8239>>>>>        Integer iChar icChar icPath
8239>>>>>        
8239>>>>>        If (sPaths ="") ;            Function_Return 0
8242>>>>>        
8242>>>>>        Move (Length(sPaths) -1) to icChar
8243>>>>>        For iChar from 1 to icChar
8249>>>>>>
8249>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
8252>>>>>        Loop
8253>>>>>>
8253>>>>>        
8253>>>>>        Function_Return (icPath +1)
8254>>>>>    End_Function
8255>>>>>    
8255>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
8257>>>>>        // Returns the path at the 1-based index of passed paths.
8257>>>>>        // If the path contains a trailing "\", it will be removed
8257>>>>>        Integer iChar icPath iPath iPos
8257>>>>>        String sPath
8257>>>>>        
8257>>>>>        Move (sPaths +";") to sPaths
8258>>>>>        For iPath from 1 to iIndex
8264>>>>>>
8264>>>>>            Move (Pos(";", sPaths)) to iPos
8265>>>>>            If iPos Begin
8267>>>>>                Move (Left(sPaths, iPos -1)) to sPath
8268>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
8271>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
8272>>>>>            End
8272>>>>>>
8272>>>>>            Else ;                Function_Return "" // index past number of paths
8274>>>>>        Loop
8275>>>>>>
8275>>>>>        
8275>>>>>        Function_Return sPath
8276>>>>>    End_Function
8277>>>>>    
8277>>>>>End_Class
8278>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLine.pkg)
8278>>>>>Use VDFBase.pkg
8278>>>>>
8278>>>>>Class cCommandLine is a cObject
8279>>>>>    
8279>>>>>    Procedure Construct_Object
8281>>>>>        Forward Send Construct_Object
8283>>>>>        
8283>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
8284>>>>>    End_Procedure
8285>>>>>    
8285>>>>>    Procedure Private_DoCreateArgsArray
8287>>>>>        // creates the array for holding the arguments. Created upon demand only!
8287>>>>>        Integer icArg
8287>>>>>        String sArg
8287>>>>>        
8287>>>>>        Object oArgs is an Array
8289>>>>>            Delegate Set phoArgs to Self
8291>>>>>            Repeat
8291>>>>>>
8291>>>>>                CmdLine sArg
8292>>>>>>
8292>>>>>                If (sArg <> "") Begin
8294>>>>>                    Increment icArg
8295>>>>>                    Set Value  (icArg -1) to sArg
8296>>>>>                End
8296>>>>>>
8296>>>>>            Until (sArg = "")
8298>>>>>        End_Object
8299>>>>>    End_Procedure
8300>>>>>    
8300>>>>>    Function CountOfArgs Returns Integer
8302>>>>>        //Returns the number of arguments passed
8302>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8305>>>>>        Function_Return (Item_Count(phoArgs(Self)))
8306>>>>>    End_Function
8307>>>>>    
8307>>>>>    Function Argument Integer iIndex Returns String
8309>>>>>        //Returns the one-based argument string
8309>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8312>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
8313>>>>>    End_Function
8314>>>>>    
8314>>>>>End_Class
8315>>>>>
8315>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRegistry.pkg)
8315>>>>>Use Dll.pkg
8315>>>>>Use RegistryAPI.pkg
8315>>>>>
8315>>>>>Enum_List // Registry Data types
8315>>>>>    Define rdString
8315>>>>>    Define rdDword
8315>>>>>    Define rdBinary
8315>>>>>    Define rdUnknown
8315>>>>>End_Enum_List
8315>>>>>
8315>>>>>//Prototypes
8315>>>>>Register_Function phRootKey      Returns Handle // HKEY_CURRENT_USER
8315>>>>>Register_Function pfAccessRights Returns Integer // KEY_ALL_ACCESS - what access level should be used to open a Key?
8315>>>>>Register_Function phCurrentKey   Returns Handle // low-level key
8315>>>>>Register_Function pbLazyWrite    Returns Boolean // True
8315>>>>>
8315>>>>>Register_Function CountOfSubkeys      Returns Integer
8315>>>>>Register_Function CountOfValues       Returns Integer
8315>>>>>Register_Function CreateKey           String sKeyName Returns Integer   // return=error code
8315>>>>>Register_Function DeleteKey           String sKeyName Returns Boolean       // Deleted successfully?
8315>>>>>Register_Function DeleteValue         String sValueName Returns Boolean // Deleted successfully?
8315>>>>>Register_Function GetSubkeys          Handle hoArray Returns Integer    // count of Subkeys
8315>>>>>Register_Function GetValues           Handle hoArray Returns Integer    // count of Values
8315>>>>>Register_Function KeyExists           String sKeyName Returns Boolean   // does the key exist?
8315>>>>>Register_Function LongestDataLength   Returns Integer
8315>>>>>Register_Function LongestSubkeyLength Returns Integer
8315>>>>>Register_Function LongestValueLength  Returns Integer
8315>>>>>Register_Function OpenKey             String sKeyName Returns Integer
8315>>>>>Register_Function ReadBinary          String sValueName Address aValueData Integer iDataLength Returns Boolean
8315>>>>>Register_Function ReadDword           String sValueName Returns DWord
8315>>>>>Register_Function ReadString          String sValueName Returns String
8315>>>>>Register_Function ValueExists         String sValueName Returns Integer // does the Value exist?
8315>>>>>Register_Function ValueLength         String sValueName Returns Integer
8315>>>>>Register_Function ValueType           String sValueName Returns Integer // what is the datatype of the Value?
8315>>>>>Register_Procedure CloseKey
8315>>>>>Register_Procedure WriteBinary        String sValueName Address aValueData Integer iDataLength
8315>>>>>Register_Procedure WriteDword         String sValue DWord dwValueData
8315>>>>>Register_Procedure WriteString        String sValue String sValueData
8315>>>>>
8315>>>>>
8315>>>>>Class cRegistry is a cObject
8316>>>>>    Procedure Construct_Object
8318>>>>>        Forward Send Construct_Object
8320>>>>>        
8320>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
8321>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
8322>>>>>        Property Handle phCurrentKey
8323>>>>>        Property Boolean pbLazyWrite True
8324>>>>>    End_Procedure
8325>>>>>    
8325>>>>>    Function CountOfSubkeys Returns Integer
8327>>>>>        DWord dwCountOfSubkeys
8327>>>>>        Integer iError
8327>>>>>        String sError
8327>>>>>        
8327>>>>>        Move 0 to dwCountOfSubkeys
8328>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
8329>>>>>        If iError Begin
8331>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8332>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8333>>>>>>
8333>>>>>        End
8333>>>>>>
8333>>>>>        Function_Return dwCountOfSubkeys
8334>>>>>    End_Function
8335>>>>>    
8335>>>>>    Function CountOfValues Returns Integer
8337>>>>>        DWord dwCountOfValues
8337>>>>>        Integer iError
8337>>>>>        String sError
8337>>>>>        
8337>>>>>        Move 0 to dwCountOfValues
8338>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
8339>>>>>        If iError Begin
8341>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8342>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8343>>>>>>
8343>>>>>        End
8343>>>>>>
8343>>>>>        
8343>>>>>        Function_Return dwCountOfValues
8344>>>>>    End_Function
8345>>>>>    
8345>>>>>    Function LongestSubkeyLength Returns Integer
8347>>>>>        DWord dwLongestSubkeyLength
8347>>>>>        Integer iError
8347>>>>>        String sError
8347>>>>>        
8347>>>>>        Move 0 to dwLongestSubkeyLength
8348>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
8349>>>>>        If iError Begin
8351>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8352>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8353>>>>>>
8353>>>>>        End
8353>>>>>>
8353>>>>>        
8353>>>>>        Function_Return dwLongestSubkeyLength
8354>>>>>    End_Function
8355>>>>>    
8355>>>>>    Function LongestValueLength Returns Integer
8357>>>>>        DWord dwLongestValueLength
8357>>>>>        Integer iError
8357>>>>>        String sError
8357>>>>>        
8357>>>>>        Move 0 to dwLongestValueLength
8358>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
8359>>>>>        If iError Begin
8361>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8362>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8363>>>>>>
8363>>>>>        End
8363>>>>>>
8363>>>>>        
8363>>>>>        Function_Return dwLongestValueLength
8364>>>>>    End_Function
8365>>>>>    
8365>>>>>    Function LongestDataLength Returns Integer
8367>>>>>        DWord dwLongestDataLength
8367>>>>>        Integer iError
8367>>>>>        String sError
8367>>>>>        
8367>>>>>        Move 0 to dwLongestDataLength
8368>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
8369>>>>>        If iError Begin
8371>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8372>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8373>>>>>>
8373>>>>>        End
8373>>>>>>
8373>>>>>        
8373>>>>>        Function_Return dwLongestDataLength
8374>>>>>    End_Function
8375>>>>>    
8375>>>>>    Function ValueType String sValueName Returns Integer
8377>>>>>        DWord dwType
8377>>>>>        Integer iError eType
8377>>>>>        String sError
8377>>>>>        
8377>>>>>        Move 0 to dwType
8378>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwType), 0, 0)) to iError
8379>>>>>        If iError Begin
8381>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8382>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8383>>>>>>
8383>>>>>        End
8383>>>>>>
8383>>>>>        
8383>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
8386>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
8390>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
8394>>>>>        Else ;            Move rdUnknown to eType
8396>>>>>        
8396>>>>>        Function_Return eType
8397>>>>>    End_Function
8398>>>>>    
8398>>>>>    Function ValueLength String sValueName Returns Integer
8400>>>>>        DWord dwSize
8400>>>>>        Integer iError
8400>>>>>        String sError
8400>>>>>        
8400>>>>>        Move 0 to dwSize
8401>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, 0, 0, AddressOf(dwSize))) to iError
8402>>>>>        If iError Begin
8404>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8405>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8406>>>>>>
8406>>>>>        End
8406>>>>>>
8406>>>>>        
8406>>>>>        Function_Return dwSize
8407>>>>>    End_Function
8408>>>>>    
8408>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
8410>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
8410>>>>>        Handle hKey hKeyOpened
8410>>>>>        Integer iError
8410>>>>>        String sError
8410>>>>>        
8410>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8411>>>>>        
8411>>>>>        Get phRootKey to hKey
8412>>>>>        
8412>>>>>        Move (RegCreateKeyEx(hKey, ToAnsi(sKeyName), 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
8413>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8416>>>>>        Else Begin
8417>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8418>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8419>>>>>>
8419>>>>>        End
8419>>>>>>
8419>>>>>        Function_Return iError
8420>>>>>    End_Function
8421>>>>>    
8421>>>>>    Procedure CloseKey
8423>>>>>        Integer iError
8423>>>>>        Handle hKey
8423>>>>>        
8423>>>>>        Get phCurrentKey to hKey
8424>>>>>        
8424>>>>>        If (hKey <>0) Begin
8426>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
8429>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
8431>>>>>            
8431>>>>>            Set phCurrentKey to 0
8432>>>>>        End
8432>>>>>>
8432>>>>>    End_Procedure
8433>>>>>    
8433>>>>>    Function OpenKey String sKeyName Returns Boolean
8435>>>>>        Handle hKey hKeyOpened
8435>>>>>        Integer iError
8435>>>>>        
8435>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8436>>>>>        
8436>>>>>        Get phRootKey to hKey
8437>>>>>        Move (RegOpenKeyEx(hKey, ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8438>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8441>>>>>        
8441>>>>>        Function_Return (iError=0)
8442>>>>>    End_Function
8443>>>>>    
8443>>>>>    Procedure WriteDword String sValue DWord dwValueData
8445>>>>>        Handle hKey
8445>>>>>        Integer iError
8445>>>>>        DWord dwData
8445>>>>>        String sError
8445>>>>>        
8445>>>>>        Move dwValueData to dwData
8446>>>>>        Get phCurrentKey to hKey
8447>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_DWORD, AddressOf(dwData), SizeOfType(DWord))) to iError
8448>>>>>        If iError Begin
8450>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8451>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8452>>>>>>
8452>>>>>        End
8452>>>>>>
8452>>>>>    End_Procedure
8453>>>>>    
8453>>>>>    Procedure WriteString String sValue String sValueData
8455>>>>>        Handle hKey
8455>>>>>        Integer iError cbData
8455>>>>>        String sError
8455>>>>>        
8455>>>>>        If (sValueData = "") Begin
8457>>>>>            Move (Character(0)) to sValueData
8458>>>>>            Move 1 to cbData
8459>>>>>        End
8459>>>>>>
8459>>>>>        Else Begin
8460>>>>>            Move (Length(sValueData) +1) to cbData
8461>>>>>        End
8461>>>>>>
8461>>>>>        Move (ToAnsi(sValueData)) to sValueData
8462>>>>>        Get phCurrentKey to hKey
8463>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_SZ, AddressOf(sValueData), cbData)) to iError
8464>>>>>        If iError Begin
8466>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8467>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8468>>>>>>
8468>>>>>        End
8468>>>>>>
8468>>>>>    End_Procedure
8469>>>>>    
8469>>>>>    Procedure WriteBinary String sValueName Address aValueData Integer iDataLength
8471>>>>>        Handle hKey
8471>>>>>        Integer iError
8471>>>>>        String sError
8471>>>>>        
8471>>>>>        Get phCurrentKey to hKey
8472>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValueName), 0, REG_BINARY, aValueData, iDataLength)) to iError
8473>>>>>        If iError Begin
8475>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8476>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8477>>>>>>
8477>>>>>        End
8477>>>>>>
8477>>>>>    End_Procedure
8478>>>>>    
8478>>>>>    Function ReadDword String sValueName Returns DWord
8480>>>>>        Handle hKey
8480>>>>>        Integer iError
8480>>>>>        DWord dwValueData dwValueDataLength
8480>>>>>        String sError
8480>>>>>        
8480>>>>>        Move 0           to dwValueData
8481>>>>>        Move (SizeOfType(DWord)) to dwValueDataLength
8482>>>>>        
8482>>>>>        Get phCurrentKey to hKey
8483>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, AddressOf(dwValueData), AddressOf(dwValueDataLength))) to iError
8484>>>>>        If iError Begin
8486>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8487>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8488>>>>>>
8488>>>>>        End
8488>>>>>>
8488>>>>>        
8488>>>>>        Function_Return dwValueData
8489>>>>>    End_Function
8490>>>>>    
8490>>>>>    Function ReadString String sValueName Returns String
8492>>>>>        Handle hKey
8492>>>>>        Integer iError
8492>>>>>        String sValueData
8492>>>>>        DWord dwValueDataLength
8492>>>>>        Pointer lpsValueData
8492>>>>>        String sError
8492>>>>>        
8492>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to sValueData
8493>>>>>        Move (AddressOf(sValueData)) to lpsValueData
8494>>>>>        
8494>>>>>        Move (Length(sValueData)) to dwValueDataLength
8495>>>>>        
8495>>>>>        Get phCurrentKey to hKey
8496>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, lpsValueData, AddressOf(dwValueDataLength))) to iError
8497>>>>>        If iError Begin
8499>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8500>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8501>>>>>>
8501>>>>>        End
8501>>>>>>
8501>>>>>        
8501>>>>>        Function_Return (ToOem(CString(sValueData)))
8502>>>>>    End_Function
8503>>>>>    
8503>>>>>    Function ReadBinary String sValueName Address aValueData Integer iDataLength Returns Boolean
8505>>>>>        Handle hKey
8505>>>>>        Integer iError
8505>>>>>        String sError
8505>>>>>        
8505>>>>>        Get phCurrentKey to hKey
8506>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, aValueData, AddressOf(iDataLength))) to iError
8507>>>>>        If iError Begin
8509>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8510>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8511>>>>>>
8511>>>>>        End
8511>>>>>>
8511>>>>>        
8511>>>>>        Function_Return (iDataLength >0)
8512>>>>>    End_Function
8513>>>>>    
8513>>>>>    
8513>>>>>    // Private....
8513>>>>>    Function GetBaseKey Returns Handle
8515>>>>>        Handle hBaseKey
8515>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
8518>>>>>        Else ;            Get phCurrentKey to hBaseKey
8520>>>>>        
8520>>>>>        Function_Return hBaseKey
8521>>>>>    End_Function
8522>>>>>    
8522>>>>>    Function GetKey String sKeyName Returns Handle
8524>>>>>        Handle hKeyOpened
8524>>>>>        Integer iError
8524>>>>>        
8524>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
8525>>>>>        
8525>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8526>>>>>        
8526>>>>>        If (iError =0) ;            Function_Return hKeyOpened
8529>>>>>        Else ;            Function_Return 0
8531>>>>>    End_Function
8532>>>>>    
8532>>>>>    // Public
8532>>>>>    Function KeyExists String sKeyName Returns Boolean
8534>>>>>        Handle hKey
8534>>>>>        Integer iVoid
8534>>>>>        
8534>>>>>        Get GetKey sKeyName to hKey
8535>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
8538>>>>>        Function_Return (hKey <>0)
8539>>>>>    End_Function
8540>>>>>    
8540>>>>>    Function ValueExists String sValueName Returns Boolean
8542>>>>>        // Determines whether a Value exists for the currently-opened Key.
8542>>>>>        Integer iError
8542>>>>>        DWord dwDataType
8542>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
8543>>>>>        
8543>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwDataType), 0, 0)) to iError
8544>>>>>        
8544>>>>>        Function_Return (iError=0)
8545>>>>>    End_Function
8546>>>>>    
8546>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
8548>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), ToAnsi(sKeyName)) =0)
8549>>>>>    End_Function
8550>>>>>    
8550>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
8552>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), ToAnsi(sValueName)) =0)
8553>>>>>    End_Function
8554>>>>>    
8554>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
8556>>>>>        Integer iError
8556>>>>>        Integer icValue iLongestSubkey
8556>>>>>        Handle hKey
8556>>>>>        DWord dwSubkeyNameLength
8556>>>>>        String sSubkeyName
8556>>>>>        tWinFileTime FileTime
8556>>>>>        tWinFileTime FileTime
8556>>>>>        
8556>>>>>        Get LongestSubkeyLength to iLongestSubkey
8557>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
8558>>>>>        
8558>>>>>        Get phCurrentKey to hKey
8559>>>>>        Repeat
8559>>>>>>
8559>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
8560>>>>>            
8560>>>>>            Move (RegEnumKeyEx(hKey, icValue, AddressOf(sSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
8561>>>>>            If (iError =0) Begin
8563>>>>>                Increment icValue
8564>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sSubkeyName)))
8565>>>>>            End
8565>>>>>>
8565>>>>>        Until (iError)
8567>>>>>        Function_Return icValue
8568>>>>>        
8568>>>>>    End_Function
8569>>>>>    
8569>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
8571>>>>>        Integer iError
8571>>>>>        Integer icValue iLongestValue
8571>>>>>        Handle hKey
8571>>>>>        DWord dwValueNameLength
8571>>>>>        String sValueName sValueNameSize
8571>>>>>        Pointer lpsValueName
8571>>>>>        
8571>>>>>        Get LongestValueLength to iLongestValue
8572>>>>>        Move (Repeat(character(0), iLongestValue +1)) to sValueName
8573>>>>>        Move (AddressOf(sValueName)) to lpsValueName
8574>>>>>        
8574>>>>>        Get phCurrentKey to hKey
8575>>>>>        Repeat
8575>>>>>>
8575>>>>>            Move (iLongestValue +1) to dwValueNameLength
8576>>>>>            Move (RegEnumValue(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
8577>>>>>            If (iError =0) Begin
8579>>>>>                Increment icValue
8580>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sValueName)))
8581>>>>>            End
8581>>>>>>
8581>>>>>        Until (iError)
8583>>>>>        Function_Return icValue
8584>>>>>        
8584>>>>>    End_Function
8585>>>>>    
8585>>>>>End_Class
8586>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cVersionInfo.pkg)
8586>>>>>Use VdfBase.pkg
8586>>>>>Use DLL.pkg
8586>>>>>Use tWinStructs.pkg
8586>>>>>Use WinKern.pkg
8586>>>>>
8586>>>>>Define VS_FF_DEBUG         for |CI$00000001
8586>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
8586>>>>>Define VS_FF_PATCHED       for |CI$00000004
8586>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
8586>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
8586>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
8586>>>>>
8586>>>>>External_Function GetFileVersionInfoSize "GetFileVersionInfoSizeA" version.dll ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
8587>>>>>
8587>>>>>External_Function GetFileVersionInfo "GetFileVersionInfoA" version.dll ;    Pointer sFilename ;    DWord dwHandle ;    DWord dwLen ;    Address aData ;    Returns Integer
8588>>>>>
8588>>>>>External_Function VerQueryValue "VerQueryValueA" version.dll ;    Address aBlock ;    Address aSubBlock ;    Address aaBuffer ;    Address puLen ;    Returns Integer
8589>>>>>
8589>>>>>
8589>>>>>Class cVersionInfo is a cObject
8590>>>>>    Procedure Construct_Object
8592>>>>>        Forward Send Construct_Object
8594>>>>>        
8594>>>>>        
8594>>>>>        Property Integer piVersionMajor
8595>>>>>        Property Integer piVersionMinor
8596>>>>>        Property Integer piVersionRelease
8597>>>>>        Property Integer piVersionBuild
8598>>>>>        
8598>>>>>        Property Boolean pbIncluded
8599>>>>>        Property Boolean pbSpecialBuild
8600>>>>>        Property Boolean pbPrivateBuild
8601>>>>>        
8601>>>>>    End_Procedure
8602>>>>>    
8602>>>>>    Procedure DoCreate String sFileName
8604>>>>>        DWord dwHandle
8604>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
8604>>>>>        String sData
8604>>>>>        String sVersionBuffer
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        String sSubBlock
8604>>>>>        Address aVsFixedFileInfo
8604>>>>>        
8604>>>>>        Move 0 to aVsFixedFileInfo
8605>>>>>        Move 0 to dwHandle
8606>>>>>        Move 0 to iVerSize
8607>>>>>        
8607>>>>>        Move (GetFileVersionInfoSize(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
8608>>>>>        Set pbIncluded to (iInfoSize <>0)
8609>>>>>        
8609>>>>>        If (pbIncluded(Self)) Begin
8611>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
8612>>>>>            Move (GetFileVersionInfo(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
8613>>>>>            
8613>>>>>            If (iSuccess <>0) Begin
8615>>>>>                Move "\" to sSubBlock
8616>>>>>                If (VerQueryValue(AddressOf(sData), AddressOf(sSubBlock), AddressOf(aVsFixedFileInfo), AddressOf(iVerSize))) Begin
8618>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), aVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
8619>>>>>                    
8619>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
8620>>>>>                    Set piVersionMajor to (Hi(iVersion))
8621>>>>>                    Set piVersionMinor to (Low(iVersion))
8622>>>>>                    
8622>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
8623>>>>>                    Set piVersionRelease to (Hi(iVersion))
8624>>>>>                    Set piVersionBuild   to (Low(iVersion))
8625>>>>>                    
8625>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
8626>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
8627>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
8628>>>>>                End
8628>>>>>>
8628>>>>>            End
8628>>>>>>
8628>>>>>            
8628>>>>>        End
8628>>>>>>
8628>>>>>    End_Procedure
8629>>>>>    
8629>>>>>End_Class
8630>>>Use GlobalFunctionsProcedures.pkg
8630>>>Use tWinStructs.pkg
8630>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
8630>>>
8630>>>Register_Function phoWorkspace Returns Handle
8630>>>Register_Function phoCommandLine Returns Handle
8630>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
8630>>>Register_Function GetApplicationName Returns String
8630>>>Register_Function GetApplicationFileName Returns String
8630>>>
8630>>>Register_Function Statusbar_State Returns Integer
8630>>>Register_Function Toolbar_State Returns Integer
8630>>>Register_Procedure Set Statusbar_State
8630>>>Register_Procedure Set Toolbar_State
8630>>>
8630>>>
8630>>>Class cApplication is a cObject
8631>>>    Procedure Construct_Object
8633>>>        Forward Send Construct_Object
8635>>>        
8635>>>        Move Self to ghoApplication
8636>>>        
8636>>>        Property Handle phoVersionInfo
8637>>>        Property Handle phoWorkspace
8638>>>        Property Handle phoCommandLine
8639>>>        Property Handle phoMainPanel       // main panel will set this for us.
8640>>>        Property String psHelpFile         // type of file is determined by peHelpType
8641>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
8642>>>        
8642>>>        Property String psCompany "Data Access Worldwide"
8643>>>        Property String psProduct "DataFlex Applications"
8644>>>        Property String psVersion C_DFVersion
8645>>>        Property String psProgram (Module_Name(desktop))
8646>>>        
8646>>>        // set to '' to stop the auto open workspace behavior
8646>>>        Property String psAutoOpenWorkspace 'Config.ws'
8647>>>        
8647>>>        
8647>>>        Property Boolean pbPreserveEnvironment True
8648>>>        
8648>>>        Object oCommandLine is a cCommandLine
8650>>>            Delegate Set phoCommandLine to Self
8652>>>        End_Object
8653>>>        
8653>>>        Object oWorkspace is a cWorkspace
8655>>>            Delegate Set phoWorkspace to Self
8657>>>        End_Object
8658>>>        
8658>>>        Object oVersionInfo is a cVersionInfo
8660>>>            Delegate Set phoVersionInfo to Self
8662>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
8663>>>        End_Object
8664>>>        
8664>>>        Set pbUseWindowsFont to True
8665>>>        
8665>>>    End_Procedure
8666>>>    
8666>>>    Procedure Destroy_Object
8668>>>        If (ghoApplication=Self) Begin
8670>>>            Move 0 to ghoApplication
8671>>>        End
8671>>>>
8671>>>        Forward Send Destroy_Object
8673>>>    End_Procedure
8674>>>    
8674>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
8674>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
8674>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
8676>>>        Move bNext to gbKEnterNext
8677>>>    End_Procedure
8678>>>    
8678>>>    Function pbEnterKeyAsTabKey Returns Boolean
8680>>>        Function_Return gbKEnterNext
8681>>>    End_Function
8682>>>    
8682>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
8684>>>// not used with webapp
8684>>>        Handle hoRegistry hoCommandBars
8684>>>        Handle hMonitor
8684>>>        Integer iError cxy
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        String sKey
8684>>>        Boolean bSuccess
8684>>>        String sObjectName
8684>>>        
8684>>>        If (pbPreserveEnvironment(Self)) Begin
8686>>>            Get Create U_cRegistry to hoRegistry
8687>>>            Set pfAccessRights of hoRegistry to KEY_READ
8688>>>            
8688>>>            Get RegistryKeyString to sKey
8689>>>            
8689>>>            If (bProgram = False) Begin
8691>>>                Move (sKey +"\WINDOWS") to sKey
8692>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8693>>>                Move (sKey +"\" +sObjectName) to sKey
8694>>>            End
8694>>>>
8694>>>            Else ;                Move (sKey + "\Preferences") to sKey
8696>>>            
8696>>>            Get OpenKey of hoRegistry sKey to bSuccess
8697>>>            
8697>>>            If bSuccess Begin
8699>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
8701>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
8702>>>                    If bSuccess Begin
8704>>>                        // Do not restore size if the window is not resizable
8704>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
8706>>>                            // restore always works with outer size
8706>>>                            Get GuiWindowSize     of hoContainer to cxy
8707>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
8708>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
8709>>>                        End
8709>>>>
8709>>>                        
8709>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
8709>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
8709>>>                        If (bProgram) Begin
8711>>>                            // Test the top left point
8711>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
8712>>>                            
8712>>>                            If (hMonitor = 0) Begin
8714>>>                                // test the bottom right point
8714>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
8715>>>                            End
8715>>>>
8715>>>                            
8715>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
8715>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
8715>>>                            If (hMonitor = 0) Begin
8717>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
8718>>>                            End
8718>>>>
8718>>>                        End
8718>>>>
8718>>>                        
8718>>>                        // Set the placement
8718>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8719>>>                    End
8719>>>>
8719>>>                End
8719>>>>
8719>>>                If bProgram Begin
8721>>>                    Get phoCommandBars of hoContainer to hoCommandBars
8722>>>                    If not hoCommandBars Begin
8724>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
8727>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
8730>>>                    End
8730>>>>
8730>>>                End
8730>>>>
8730>>>                
8730>>>                Send CloseKey of hoRegistry
8731>>>            End
8731>>>>
8731>>>            
8731>>>            Send Destroy of hoRegistry
8732>>>        End
8732>>>>
8732>>>    End_Procedure
8733>>>    
8733>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
8735>>>// not used with webapp
8735>>>        Handle hoRegistry
8735>>>        Integer iError
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        String sKey
8735>>>        Boolean bSuccess
8735>>>        Integer eShowCmd
8735>>>        String sObjectName
8735>>>        
8735>>>        If (pbPreserveEnvironment(Self)) Begin
8737>>>            Get Create U_cRegistry to hoRegistry
8738>>>            Get RegistryKeyString to sKey
8739>>>            
8739>>>            If (bProgram = False) Begin
8741>>>                Move (sKey +"\WINDOWS") to sKey
8742>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8743>>>                Move (sKey +"\" +sObjectName) to sKey
8744>>>            End
8744>>>>
8744>>>            Else ;                Move (sKey +"\Preferences") to sKey
8746>>>            
8746>>>            Get CreateKey of hoRegistry sKey to iError
8747>>>            If (iError = 0) Begin
8749>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
8750>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8751>>>                If bSuccess Begin
8753>>>                    // if minimized, assume restored, as we don't want to restart minimized!
8753>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
8755>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
8756>>>                    End
8756>>>>
8756>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
8757>>>                End
8757>>>>
8757>>>                
8757>>>                If bProgram Begin
8759>>>                    Send WriteDword of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
8760>>>                    Send WriteDword of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
8761>>>                End
8761>>>>
8761>>>                
8761>>>                
8761>>>                Send CloseKey of hoRegistry
8762>>>            End
8762>>>>
8762>>>            
8762>>>            Send Destroy of hoRegistry
8763>>>        End
8763>>>>
8763>>>    End_Procedure
8764>>>    
8764>>>    
8764>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
8766>>>        Integer ixySize ixSize iySize
8766>>>        Integer ixOffset iyOffset
8766>>>        
8766>>>        // first calculate the offset needed to move onto the main monitor at 0,0
8766>>>        Move (0 - WindowPos.left) to ixOffset
8767>>>        Move (0 - WindowPos.top) to iyOffset
8768>>>        
8768>>>        Move 0 to WindowPos.left
8769>>>        Move 0 to WindowPos.top
8770>>>        
8770>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
8771>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
8772>>>        
8772>>>        // also make sure that the size of the window is <= the size of the main monitor
8772>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
8773>>>        Move (low(ixySize))      to ixSize
8774>>>        Move (hi(ixySize))       to iySize
8775>>>        
8775>>>        Move (ixSize min WindowPos.right) to WindowPos.right
8776>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
8777>>>    End_Procedure
8778>>>    
8778>>>    
8778>>>    Function RegistryKeyString Returns String
8780>>>        String sCompany sProduct sVersion sProgram
8780>>>        
8780>>>        Get psCompany to sCompany
8781>>>        Get psProduct to sProduct
8782>>>        Get psVersion to sVersion
8783>>>        Get psProgram to sProgram
8784>>>        
8784>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
8787>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
8790>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
8793>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
8796>>>        
8796>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
8797>>>    End_Function
8798>>>    
8798>>>    Procedure WriteString String sSubKey String sValueName String sValueData
8800>>>        String sKey
8800>>>        Handle hoRegistry
8800>>>        Integer iError
8800>>>        
8800>>>        Get Create U_cRegistry to hoRegistry
8801>>>        Get RegistryKeyString to sKey
8802>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8805>>>        Get CreateKey of hoRegistry sKey to iError
8806>>>        If (iError = 0) Begin
8808>>>            Send WriteString of hoRegistry sValueName sValueData
8809>>>            Send CloseKey of hoRegistry
8810>>>        End
8810>>>>
8810>>>        
8810>>>        Send Destroy of hoRegistry
8811>>>    End_Procedure
8812>>>    Procedure WriteDword String sSubKey String sValueName DWord dwValueData
8814>>>        String sKey
8814>>>        Handle hoRegistry
8814>>>        Integer iError
8814>>>        
8814>>>        Get Create U_cRegistry to hoRegistry
8815>>>        Get RegistryKeyString to sKey
8816>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8819>>>        Get CreateKey of hoRegistry sKey to iError
8820>>>        If (iError = 0) Begin
8822>>>            Send WriteDword of hoRegistry sValueName dwValueData
8823>>>            Send CloseKey of hoRegistry
8824>>>        End
8824>>>>
8824>>>        
8824>>>        Send Destroy of hoRegistry
8825>>>    End_Procedure
8826>>>    Procedure WriteBinary String sSubKey String sValueName Address aValueData Integer iDataLength
8828>>>        String sKey
8828>>>        Handle hoRegistry
8828>>>        Integer iError
8828>>>        
8828>>>        Get Create U_cRegistry to hoRegistry
8829>>>        Get RegistryKeyString to sKey
8830>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8833>>>        Get CreateKey of hoRegistry sKey to iError
8834>>>        If (iError = 0) Begin
8836>>>            Send WriteBinary of hoRegistry sValueName aValueData iDataLength
8837>>>            Send CloseKey of hoRegistry
8838>>>        End
8838>>>>
8838>>>        
8838>>>        Send Destroy of hoRegistry
8839>>>    End_Procedure
8840>>>    
8840>>>    // returns true if both sub-key and value exists.
8840>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
8842>>>        String sKey
8842>>>        Handle hoRegistry
8842>>>        Boolean bOK
8842>>>        Get Create U_cRegistry to hoRegistry
8843>>>        Get RegistryKeyString to sKey
8844>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8847>>>        Get OpenKey of hoRegistry sKey to bOk
8848>>>        If (bOK) Begin
8850>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
8851>>>            Send CloseKey of hoRegistry
8852>>>        End
8852>>>>
8852>>>        Send Destroy of hoRegistry
8853>>>        Function_Return bOk
8854>>>    End_Function
8855>>>    
8855>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
8857>>>        String sKey sData
8857>>>        Handle hoRegistry
8857>>>        Boolean bOK
8857>>>        
8857>>>        Move sDefault to sData
8858>>>        Get Create U_cRegistry to hoRegistry
8859>>>        Get RegistryKeyString to sKey
8860>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8863>>>        Get OpenKey of hoRegistry sKey to bOk
8864>>>        If (bOK) Begin
8866>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
8869>>>            Send CloseKey of hoRegistry
8870>>>        End
8870>>>>
8870>>>        
8870>>>        Send Destroy of hoRegistry
8871>>>        Function_Return sData
8872>>>    End_Function
8873>>>    
8873>>>    Function ReadDword String sSubKey String sValueName DWord dwDefault Returns DWord
8875>>>        String sKey
8875>>>        DWord dwData
8875>>>        Handle hoRegistry
8875>>>        Boolean bOK
8875>>>        
8875>>>        Move dwDefault to dwData
8876>>>        Get Create U_cRegistry to hoRegistry
8877>>>        Get RegistryKeyString to sKey
8878>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8881>>>        Get OpenKey of hoRegistry sKey to bOk
8882>>>        If bOK Begin
8884>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadDword of hoRegistry sValueName to dwData
8887>>>            Send CloseKey of hoRegistry
8888>>>        End
8888>>>>
8888>>>        
8888>>>        Send Destroy of hoRegistry
8889>>>        Function_Return dwData
8890>>>    End_Function
8891>>>    
8891>>>    Function ReadBinary String sSubKey String sValueName Address aValueData Integer iDataLength Returns Boolean
8893>>>        String sKey
8893>>>        Handle hoRegistry
8893>>>        Boolean bOK bSuccess
8893>>>        
8893>>>        Get Create U_cRegistry to hoRegistry
8894>>>        Get RegistryKeyString to sKey
8895>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8898>>>        Get OpenKey of hoRegistry sKey to bOk
8899>>>        If bOK Begin
8901>>>            Get ReadBinary of hoRegistry sValueName aValueData iDataLength to bSuccess
8902>>>            Send CloseKey of hoRegistry
8903>>>        End
8903>>>>
8903>>>        
8903>>>        Send Destroy of hoRegistry
8904>>>        Function_Return bSuccess
8905>>>    End_Function
8906>>>    
8906>>>    Procedure DoOpenWorkspace String sWorkspace
8908>>>        // Tries to open in this order:
8908>>>        // 1) if absolute path, use that; otherwise
8908>>>        // 2) try to open in the path of the EXE; otherwise
8908>>>        // 3) load it via the Registered list
8908>>>        
8908>>>        Integer eOpened
8908>>>        String sError sWSFile
8908>>>        Handle hoWorkspace
8908>>>        Boolean bChangingWorkspace
8908>>>        
8908>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
8908>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
8908>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
8908>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
8908>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
8908>>>        // that there should be no automatic opening of a worskpace.
8908>>>        Set psAutoOpenWorkspace to ""
8909>>>        
8909>>>        Get phoWorkspace to hoWorkspace
8910>>>        
8910>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
8911>>>        If (bChangingWorkspace and ghoConnection) Begin
8913>>>            Send AutoDisconnect
8914>>>        End
8914>>>>
8914>>>        
8914>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
8915>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
8917>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
8919>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
8920>>>            End
8920>>>>
8920>>>        End
8920>>>>
8920>>>        If (eOpened <> wsWorkspaceOpened) Begin
8922>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
8923>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
8924>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
8925>>>>
8925>>>            Abort
8926>>>>
8926>>>        End
8926>>>>
8926>>>        Else Begin
8927>>>            Send AutoConnect
8928>>>            Send OnWorkspaceOpened
8929>>>        End
8929>>>>
8929>>>    End_Procedure
8930>>>    
8930>>>    Procedure AutoConnect
8932>>>        If (ghoConnection) Begin
8934>>>            Send AutoConnect of ghoConnection
8935>>>        End
8935>>>>
8935>>>    End_Procedure
8936>>>    
8936>>>    Procedure AutoDisconnect
8938>>>        If (ghoConnection) Begin
8940>>>            Send AutoDisconnect of ghoConnection
8941>>>        End
8941>>>>
8941>>>    End_Procedure
8942>>>    
8942>>>    // send after a workspace is successfully opened and connected
8942>>>    Procedure OnWorkspaceOpened
8944>>>    End_Procedure
8945>>>    
8945>>>    Procedure OnCreate
8947>>>        // Event called when the Application object is ready to be used
8947>>>        // to open a Workspace, etc.
8947>>>    End_Procedure
8948>>>    
8948>>>    Procedure End_Construct_Object
8950>>>        String sName
8950>>>        Forward Send End_Construct_Object
8952>>>        Send OnCreate
8953>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
8953>>>        Get psAutoOpenWorkspace to sName
8954>>>        If (sName<>"") Begin
8956>>>            Send DoOpenWorkspace sName
8957>>>        End
8957>>>>
8957>>>    End_Procedure
8958>>>    
8958>>>    Function GetApplicationFileName Returns String
8960>>>        // Returns the filename from Windows
8960>>>        Integer iNumChars
8960>>>        String sFilename
8960>>>        
8960>>>        Move (Repeat(Character(0), 1024)) to sFileName
8961>>>        Move (GetModuleFileName(0, AddressOf(sFilename), 1024)) to iNumChars
8962>>>        
8962>>>        Function_Return (CString(sFilename))
8963>>>    End_Function
8964>>>    
8964>>>    Function GetApplicationPath Returns String
8966>>>        // Returns the path of the Application (no trailing "\")
8966>>>        String sApplicationFileName sPath
8966>>>        Boolean bRemoved
8966>>>        
8966>>>        Get GetApplicationFileName  to sApplicationFileName
8967>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
8968>>>        Move (CString(sApplicationFileName)) to sPath
8969>>>        
8969>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8972>>>        Function_Return sPath
8973>>>    End_Function
8974>>>    
8974>>>    Function GetApplicationName Returns String
8976>>>        // Returns the name of the Application (without its Path or Extension)
8976>>>        String sApplicationFileName sApplicationName
8976>>>        Boolean bRemoved
8976>>>        Integer iVoid
8976>>>        
8976>>>        Get GetApplicationFileName to sApplicationFileName
8977>>>        Move (ExtractFileName(sApplicationFileName)) to sApplicationName
8978>>>        Move (PathRemoveExtension(AddressOf(sApplicationName))) to iVoid
8979>>>        Function_Return (CString(sApplicationName))
8980>>>    End_Function
8981>>>    
8981>>>    Function DFRootPath Returns String
8983>>>        String sRoot
8983>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
8986>>>        // Ensure it does not contain a trailing "\"
8986>>>        If (Right(sRoot,1) = "\") Begin
8988>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
8989>>>        End
8989>>>>
8989>>>        Function_Return sRoot
8990>>>    End_Function
8991>>>    
8991>>>    Function DFBinPath Returns String
8993>>>        String sRoot
8993>>>        Get DFRootPath to sRoot
8994>>>        If (sRoot<>"") Begin
8996>>>            Move (sRoot+"\bin") to sRoot
8997>>>        End
8997>>>>
8997>>>        Else Begin
8998>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
8998>>>            // bin path must be the same as the application path.
8998>>>            Get GetApplicationPath to sRoot
8999>>>        End
8999>>>>
8999>>>        Function_Return sRoot
9000>>>    End_Function
9001>>>    
9001>>>    // this just directs to the desktop property. If you are using an application object you are
9001>>>    // encouraged to set this here.
9001>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
9003>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
9004>>>    End_Procedure
9005>>>    
9005>>>    Function pbUseWindowsFont Returns Boolean
9007>>>        Boolean bUseWindowsFont
9007>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
9008>>>        Function_Return bUseWindowsFont
9009>>>    End_Function
9010>>>    
9010>>>    // this just directs to the desktop property. If you are using an application object you are
9010>>>    // encouraged to set this here.
9010>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
9012>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
9013>>>    End_Procedure
9014>>>    
9014>>>    Function pbLegacyDialogRatio Returns Boolean
9016>>>        Boolean bLegacy
9016>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
9017>>>        Function_Return bLegacy
9018>>>    End_Function
9019>>>End_Class
9020>>>
9020>>>
9020>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateHandler.pkg)
9020>>>//****************************************************************************
9020>>>// $Module type: Class
9020>>>// $Module name: cDbUpdateHandler
9020>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
9020>>>// Web-site    : http://www.rdctools.com
9020>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
9020>>>//
9020>>>// Purpose     : A framework for doing automated code based updates of a database from within
9020>>>//               a program, when it is started.
9020>>>//
9020>>>// Description : Place _one_ object of this class right after the cApplication object.
9020>>>//               Then inside this object place a series of cDbUpdateVersion objects
9020>>>//               as childs. One child object for each new database update.
9020>>>//
9020>>>//               - OnPreUpdate is a pre-processing event called
9020>>>//               before any database changes are started.
9020>>>//               - OnPostUpdate is a post-processing event called after all
9020>>>//               database changes have taken place.
9020>>>//
9020>>>// Note        : If tables have been opened prior to an object of this class
9020>>>//               (e.g. in the cApplication object), those tables will be closed.
9020>>>//               In that case you need to use the OnPostUpdate hook event to re-open
9020>>>//               tables after the last update has finished.
9020>>>//
9020>>>// Security    : Before an update is attempted; three things are checked to ensure the
9020>>>//               database is not in use. Aka nobody else is running the application.
9020>>>//               - All tables are tested for "Open in Exclusive_Mode"
9020>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
9020>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
9020>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
9020>>>//                 folder and a bit-lock is performed for each start of the application and this
9020>>>//                 user counter is checked before an update is attempted.
9020>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
9020>>>//                            against the database being "in use", there is no such guarantee! The
9020>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
9020>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
9020>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
9020>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
9020>>>//                 automatically be released after the update is completed.
9020>>>//
9020>>>//
9020>>>// Usage       :  Use cDbUpdateHandler.pkg
9020>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
9020>>>//                    // Declare the table that contains a "database version" field.
9020>>>//                    Declare_Datafile Sys
9020>>>//                    // Either one of these syntaxes is fine:
9020>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
9020>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
9020>>>//
9020>>>//                    // Don't forget to increase the pnVersionNumber property for each
9020>>>//                    // cDbUpdateVersion object!
9020>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
9020>>>//                    // with the value of pnVersionNumber after each update has been finished.
9020>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
9020>>>//                        Set pnVersionNumber to 1.1
9020>>>//                        Use VersionUpdate1_1.pkg
9020>>>//                    End_Object
9020>>>//
9020>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
9020>>>//                        Set pnVersionNumber to 1.2
9020>>>//                        Use VersionUpdate1_2.pkg
9020>>>//                    End_Object
9020>>>//
9020>>>//                End_Object
9020>>>//
9020>>>//
9020>>>// $Rev History:
9020>>>//    2016-09-27  Module header created
9020>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
9020>>>//                take place before any tables have been opened, or errors
9020>>>//                could occur if the client database is out of sync with the
9020>>>//                compiled program.
9020>>>//                Added user counting checks + lockout while database is being
9020>>>//                updated.
9020>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
9020>>>//                as it is more in line with the child class cDbUpdateVersion name.
9020>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
9020>>>//****************************************************************************
9020>>>Use VdfBase.pkg
9020>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dferror.pkg)
9020>>>>>Use LanguageText.pkg
9020>>>>>Use Windows.pkg
9020>>>>>Use msgbox.pkg
9020>>>>>Use GlobalFunctionsProcedures.pkg
9020>>>>>
9020>>>>>// Include or define all useful symbols.
9020>>>>>Use errornum.inc
9020>>>>>// these are kept for compatibility. Don't use them
9020>>>>>
9020>>>>>// used by error handler and UserError to pull a caption out of the error string
9020>>>>>Define C_ErrorCaption for "*CAPTION*="
9020>>>>>
9020>>>>>// This array stores the set of trapped errors as toggled ranges starting
9020>>>>>// with the errors that are trapped. The array should always contain 0 and
9020>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
9020>>>>>// following items...
9020>>>>>//
9020>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
9020>>>>>//
9020>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
9020>>>>>// 10 through the rest are trapped.
9020>>>>>//
9020>>>>>Class Trapped_Errors_Array is an array
9021>>>>>    
9021>>>>>    // Find largest error LE targetError. Assumes array is sorted.
9021>>>>>    Function findErrorLE Integer targetError Returns Integer
9023>>>>>        
9023>>>>>        Integer lowIndex hiIndex midIndex currError
9023>>>>>        
9023>>>>>        // If error is outside of boudary conditions, use
9023>>>>>        // value of closest valid error# instead.
9023>>>>>        If (targetError <= 0);            Move 1 to targetError
9026>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
9030>>>>>        
9030>>>>>        Move 0 to lowIndex
9031>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
9032>>>>>        
9032>>>>>        // midIndex will contain the closest error LE to target upon exit.
9032>>>>>        Repeat
9032>>>>>>
9032>>>>>            
9032>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
9033>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
9034>>>>>            
9034>>>>>            // midIndex is targetIndex if a match occurs
9034>>>>>            If (currError = targetError) ;                Function_Return midIndex
9037>>>>>            
9037>>>>>            // We are either on it or just below it.
9037>>>>>            If ( lowIndex = midIndex ) Begin
9039>>>>>                
9039>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
9042>>>>>                
9042>>>>>                Function_Return midIndex
9043>>>>>                
9043>>>>>            End
9043>>>>>>
9043>>>>>            
9043>>>>>            // No match, so move the boundaries.
9043>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
9046>>>>>            Else ;                Move midIndex to lowIndex
9048>>>>>            
9048>>>>>        Until lowIndex gt hiIndex
9050>>>>>        
9050>>>>>        Function_Return midIndex
9051>>>>>        
9051>>>>>    End_Function
9052>>>>>    
9052>>>>>    // Boundaries of the table are assumed to hold error limits.
9052>>>>>    Procedure initArray
9054>>>>>        Send delete_data
9055>>>>>        Set array_value 0 to 0
9056>>>>>        Set array_value 1 to ( MAX_ERROR_NUMBER + 1 )
9057>>>>>    End_Procedure
9058>>>>>    
9058>>>>>    // Return 1 if Error is trapped, 0 otherwise.
9058>>>>>    Function IsTrapped Integer Error# Returns Integer
9060>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
9061>>>>>    End_Function
9062>>>>>    
9062>>>>>    // Add the error as long as it doesn't violate boundary conditions.
9062>>>>>    // This routine leaves the array unsorted.
9062>>>>>    Procedure addError Integer Error#
9064>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value ( item_count( Self ) ) to ( Integer( Error# ) )
9067>>>>>    End_Procedure
9068>>>>>    
9068>>>>>    // Set error to flagged state.
9068>>>>>    Procedure handleError Integer Error# Integer trapFlag
9070>>>>>        
9070>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
9070>>>>>        
9070>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
9072>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
9073>>>>>>
9073>>>>>            Procedure_Return
9074>>>>>        End
9074>>>>>>
9074>>>>>        
9074>>>>>        Get findErrorLE Error# to prevErrIndex
9075>>>>>        Get isTrapped   Error# to prevErrFlag
9076>>>>>        
9076>>>>>        // if eq, Error already handled in some range.
9076>>>>>        If (prevErrFlag <> trapFlag) Begin
9078>>>>>            
9078>>>>>            // This is kind of complicated. If we are adding an error,
9078>>>>>            // we have to account for the error already being in the
9078>>>>>            // array as well as rejoining ranges that have been previously
9078>>>>>            // split and splitting ranges when adding a new flag.
9078>>>>>            
9078>>>>>            Get integer_value ( prevErrIndex + 1 ) to nextErrValue
9079>>>>>            Get integer_value prevErrIndex         to prevErrValue
9080>>>>>            
9080>>>>>            // Do this first so prevErrIndex stays valid.
9080>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
9083>>>>>            Else ;                Send addError ( Error# + 1 )
9085>>>>>            
9085>>>>>            If ( prevErrValue lt Error# ) ;                Send addError Error#
9088>>>>>            Else ;                Send delete_item prevErrIndex
9090>>>>>        End
9090>>>>>>
9090>>>>>        Send sort_items UPWARD_DIRECTION
9091>>>>>        
9091>>>>>    End_Procedure
9092>>>>>    
9092>>>>>    // Flag error as trappable
9092>>>>>    Procedure Trap_Error Integer Error#
9094>>>>>        Send handleError Error# 1
9095>>>>>    End_Procedure
9096>>>>>    
9096>>>>>    // Flag error as non-trappable
9096>>>>>    Procedure Ignore_Error Integer Error#
9098>>>>>        Send handleError Error# 0
9099>>>>>    End_Procedure
9100>>>>>    
9100>>>>>    // Flag all errors as trappable
9100>>>>>    Procedure Trap_All
9102>>>>>        Send initArray
9103>>>>>    End_Procedure
9104>>>>>    
9104>>>>>    // Flag all errors as non-trappable
9104>>>>>    Procedure Ignore_All
9106>>>>>        Send delete_data
9107>>>>>        Set array_value 0 to 0
9108>>>>>        Set array_value 1 to 1
9109>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
9110>>>>>    End_Procedure
9111>>>>>    
9111>>>>>End_Class
9112>>>>>
9112>>>>>
9112>>>>>Class ErrorSystem is a cObject
9113>>>>>    
9113>>>>>    Procedure construct_object
9115>>>>>        Forward Send construct_object
9117>>>>>        
9117>>>>>        Set delegation_mode to no_delegate_or_error
9118>>>>>        
9118>>>>>        Property Integer Verbose_State            True
9119>>>>>        Property Integer Current_Error_Number     0
9120>>>>>        Property Integer Error_Line_Number        0
9121>>>>>        
9121>>>>>        // If set false, this makes the error handler work the old way which
9121>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
9121>>>>>        Property Boolean pbUnhandledErrorSupport       True
9122>>>>>        
9122>>>>>        // shows error numbers with user errors. Only set this true if your
9122>>>>>        // application has meaningful numbers that helps the end user. Note that
9122>>>>>        // unhandled errors always show numbers.
9122>>>>>        // this is ignored if pbUnhandledErrorSupport is false
9122>>>>>        Property Boolean pbShowErrorNumber        False
9123>>>>>        
9123>>>>>        
9123>>>>>        // This is the caption that appears for unhandled errors dialog box
9123>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
9124>>>>>        
9124>>>>>        // This is the caption that appears for standard user errors
9124>>>>>        Property String psUserErrorCaption C_$Error
9125>>>>>        
9125>>>>>        // Flag which is sent when error is being processed. This
9125>>>>>        // stops error recursion.
9125>>>>>        Property Integer Error_Processing_State  False
9126>>>>>        
9126>>>>>        // array of errors that we consider User Errors
9126>>>>>        Property Integer[] pUserErrorsArray
9127>>>>>        
9127>>>>>        //  This allows us to skip find errors (GT & LT) and to only
9127>>>>>        //  ring a bell when these occur.
9127>>>>>        //
9127>>>>>        Property Integer Bell_on_Find_Error_State True
9128>>>>>        
9128>>>>>        Object TrappedErrors is a Trapped_Errors_Array
9130>>>>>            Send initArray
9131>>>>>        End_Object
9132>>>>>        
9132>>>>>        Send Trap_All
9133>>>>>        
9133>>>>>        // define the standard user error numbers
9133>>>>>        Send AddUserError 0
9134>>>>>        Send AddUserError DFERR_NUMBER_TOO_LARGE
9135>>>>>        Send AddUserError DFERR_WINDOW_RANGE
9136>>>>>        Send AddUserError DFERR_ENTRY_REQUIRED
9137>>>>>        Send AddUserError DFERR_ENTER_A_NUMBER
9138>>>>>        Send AddUserError DFERR_BAD_ENTRY
9139>>>>>        Send AddUserError DFERR_ENTER_VALID_DATE
9140>>>>>        Send AddUserError DFERR_NUMERIC_RANGE
9141>>>>>        Send AddUserError DFERR_DUPLICATE_REC
9142>>>>>        Send AddUserError DFERR_TEXT_FIELD_TOO_LONG
9143>>>>>        Send AddUserError DFERR_FIND_PRIOR_BEG_OF_FILE
9144>>>>>        Send AddUserError DFERR_FIND_PAST_END_OF_FILE
9145>>>>>        Send AddUserError DFERR_NO_REC_TO_DELETE
9146>>>>>        Send AddUserError DFERR_FIELD_NOT_INDEXED // can be invoked w/ find keys
9147>>>>>        Send AddUserError DFERR_REC_NUMBER_RANGE
9148>>>>>        Send AddUserError DFERR_ENTER_VALID_REC_ID
9149>>>>>        Send AddUserError DFERR_OPERATOR_ERROR
9150>>>>>        Send AddUserError DFERR_CANT_CHANGE_KEY_FIELD
9151>>>>>        Send AddUserError DFERR_NO_DELETE_RELATED_RECORDS_EXIST
9152>>>>>        Send AddUserError DFERR_OPERATION_NOT_ALLOWED
9153>>>>>        Send AddUserError DFERR_OPERATOR
9154>>>>>        Send AddUserError DFERR_XML_HTTP
9155>>>>>        Send AddUserError DFERR_CLIENT_SOAP_TRANSFER
9156>>>>>        Send AddUserError DFERR_CLIENT_SOAP_FAULT
9157>>>>>        Send AddUserError DFERR_TEXT_TOO_LARGE_FOR_FIELD
9158>>>>>        Send AddUserError DFERR_WINPRINT
9159>>>>>        Send AddUserError DFERR_CRYSTAL_REPORT
9160>>>>>        Send AddUserError DFERR_MAPI
9161>>>>>        Send AddUserError DFERR_FILE_ACCESS_VIOLATION
9162>>>>>        Send AddUserError DFERR_DATAFLEX_REPORTS
9163>>>>>        Send AddUserError DFERR_CANT_REFIND_RECORD
9164>>>>>        Send AddUserError 999 // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error
9165>>>>>        // number of DDs.
9165>>>>>        Move Self to Error_Object_Id
9166>>>>>    End_Procedure
9167>>>>>    
9167>>>>>    Function Help_Context Integer Context_Type Returns String
9169>>>>>        Function_Return (Current_Error_Number(Self))
9170>>>>>    End_Function
9171>>>>>    
9171>>>>>    // Catch and display error Error#.
9171>>>>>    Procedure Trap_Error Integer Error#
9173>>>>>        Send Trap_Error to ( trappedErrors( Self ) ) Error#
9174>>>>>    End_Procedure
9175>>>>>    
9175>>>>>    // Pass error Error# on to the regular DataFlex error handler.
9175>>>>>    Procedure Ignore_Error Integer Error#
9177>>>>>        Send Ignore_Error to ( trappedErrors( Self ) ) Error#
9178>>>>>    End_Procedure
9179>>>>>    
9179>>>>>    // Catch and display all errors.
9179>>>>>    Procedure Trap_All
9181>>>>>        Send Trap_All to ( trappedErrors( Self ) )
9182>>>>>    End_Procedure
9183>>>>>    
9183>>>>>    // Forward all error to regular DataFlex error handler.
9183>>>>>    Procedure Ignore_All
9185>>>>>        Send Ignore_All to ( trappedErrors( Self ) )
9186>>>>>    End_Procedure
9187>>>>>    
9187>>>>>    // Build complete error description from Flexerrs and user error message.
9187>>>>>    Function Error_Description Integer Error# String ErrMsg Returns String
9189>>>>>        String Full_Error_Text
9189>>>>>        
9189>>>>>        Move (Trim(ErrMsg)) to ErrMsg
9190>>>>>        Move (trim(error_text(DESKTOP,Error#))) to Full_Error_Text
9191>>>>>        
9191>>>>>        If (ErrMsg<>"") Begin
9193>>>>>            
9193>>>>>            If ( ( Full_Error_Text<>"" ) and ;                error_text_available( DESKTOP, Error# ) ) Begin
9195>>>>>                // Make sure last character of error text is a separating symbol.
9195>>>>>                // if not, add a "." So we have format of "error-text. error-detail"
9195>>>>>                If ( pos(right(Full_error_text,1),".,:;")=0 ) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
9198>>>>>                Move (Full_Error_Text * ErrMsg) to Full_Error_Text
9199>>>>>            End
9199>>>>>>
9199>>>>>            Else ;                Move ErrMsg to Full_Error_Text
9201>>>>>            
9201>>>>>        End
9201>>>>>>
9201>>>>>        
9201>>>>>        Function_Return Full_Error_Text
9202>>>>>    End_Function
9203>>>>>    
9203>>>>>    // return true if an error number is critical
9203>>>>>    Function Is_Critical Integer Error# Returns Integer
9205>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(Error#)+"."))
9206>>>>>    End_Function
9207>>>>>    
9207>>>>>    // adds a user error to the array
9207>>>>>    Procedure AddUserError Integer iError
9209>>>>>        Integer[] UserErrors
9210>>>>>        Get pUserErrorsArray to UserErrors
9211>>>>>        // We assume that there are few enough user errors to worry about speed of finding
9211>>>>>        // the an array item. It always does a linear seach, which should be plenty fast.
9211>>>>>        If (SearchArray(iError,UserErrors)=-1) Begin
9213>>>>>            Move iError to UserErrors[SizeOfArray(UserErrors)]
9214>>>>>            Set pUserErrorsArray to UserErrors
9215>>>>>        End
9215>>>>>>
9215>>>>>    End_Procedure
9216>>>>>    
9216>>>>>    // removes an error from the user array
9216>>>>>    Procedure RemoveUserError Integer iError
9218>>>>>        Integer[] UserErrors
9219>>>>>        Integer iIndex iSize
9219>>>>>        Get pUserErrorsArray to UserErrors
9220>>>>>        Move (SearchArray(iError,UserErrors)) to iIndex
9221>>>>>        If (iIndex<>-1) Begin
9223>>>>>            // replace the removed error with the last error and resize the array
9223>>>>>            Move (SizeOfArray(UserErrors)) to iSize
9224>>>>>            Move UserErrors[iSize-1] to UserErrors[iIndex]
9225>>>>>            Set pUserErrorsArray to (ResizeArray(UserErrors,iSize-1))
9226>>>>>        End
9226>>>>>>
9226>>>>>    End_Procedure
9227>>>>>    
9227>>>>>    // removes all user errors
9227>>>>>    Procedure RemoveAllUserErrors
9229>>>>>        Integer[] UserErrors
9230>>>>>        Set pUserErrorsArray to UserErrors
9231>>>>>    End_Procedure
9232>>>>>    
9232>>>>>    // returns true if this is an unhandled error (i.e., not a user error
9232>>>>>    Function IsUnhandledError Integer iError Returns Boolean
9234>>>>>        Integer[] UserErrors
9235>>>>>        Get pUserErrorsArray to UserErrors
9236>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
9237>>>>>    End_Function
9238>>>>>    
9238>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
9240>>>>>        String sCaption sCRLF
9240>>>>>        Move (Character(13)+Character(10)) to sCRLF
9241>>>>>        Get psUnhandledErrorCaption to sCaption
9242>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
9243>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
9244>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
9245>>>>>    End_Procedure
9246>>>>>    
9246>>>>>    // Handle error event, displaying error info to user.
9246>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
9248>>>>>        Integer iReply iIcon
9248>>>>>        String  sErrorText sMess
9248>>>>>        String  sSource sCaption
9248>>>>>        Integer iSrcPos iSrc iTxtLen
9248>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
9248>>>>>        
9248>>>>>        If (Error_processing_State(Self)) Begin // don't allow error
9250>>>>>            Procedure_Return                     // recursion
9251>>>>>        End
9251>>>>>>
9251>>>>>        
9251>>>>>        Set Error_Processing_State to True // we are now in an error reporting state
9252>>>>>        
9252>>>>>        Set Current_Error_Number to ErrNum
9253>>>>>        Set Error_Line_Number    to Err_Line
9254>>>>>        
9254>>>>>        // if this is false, this will work old-style -- all errors go through message box
9254>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
9255>>>>>        
9255>>>>>        Get Is_Critical errnum to bCritical
9256>>>>>        Get IsUnhandledError ErrNum to bIsUnhandled
9257>>>>>        
9257>>>>>        
9257>>>>>        //
9257>>>>>        //   Changes made so find errors don't report - just beep
9257>>>>>        //
9257>>>>>        
9257>>>>>        If ( Bell_On_find_Error_State(Self) and ;            ErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or ErrNum=DFERR_FIND_PAST_END_OF_FILE) Begin
9259>>>>>            Send Bell
9260>>>>>        End
9260>>>>>>
9260>>>>>        Else If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
9263>>>>>            // if trapped do nothing
9263>>>>>            
9263>>>>>            // We used to forward send. Since this is based on array, it does not understand this message, the forward was
9263>>>>>            // not understood. Since arrays don't delegate or error, nothing happened.
9263>>>>>            // An easier way to do nothing, is to do nothing, hence this line if removed
9263>>>>>            //forward send Error_Report ErrNum Err_Line ErrMsg
9263>>>>>        End
9263>>>>>>
9263>>>>>        Else Begin
9264>>>>>            
9264>>>>>            // See if source information is provided (Source = module.function). If so remove
9264>>>>>            // as detail. Must find last instance of this in string
9264>>>>>            Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
9265>>>>>            If iSrc Begin
9267>>>>>                Move (iSrc-1) to iSrcPos
9268>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
9269>>>>>                Move ErrMsg to sSource
9270>>>>>                Repeat // this makes sure we find last instance of this
9270>>>>>>
9270>>>>>                    Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
9271>>>>>                    Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
9272>>>>>                    If iSrc ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
9275>>>>>                Until (iSrc=0)
9277>>>>>                Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
9278>>>>>                If (right(ErrMsg,1)=',') ;                    Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
9281>>>>>            End
9281>>>>>>
9281>>>>>            
9281>>>>>            // the caption normally used for handled user errors
9281>>>>>            Get psUserErrorCaption to sCaption
9282>>>>>            // if an operator error this may be a Procedure UserError situation where the
9282>>>>>            // caption is passed in the error text. If so, get the caption
9282>>>>>            If (ErrNum=DFERR_OPERATOR) Begin
9284>>>>>                Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
9285>>>>>                If iSrc Begin
9287>>>>>                    Move (length(C_ErrorCaption)) to  iTxtLen
9288>>>>>                    Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
9289>>>>>                    Move (Left(ErrMsg,iSrc-1)) to ErrMsg
9290>>>>>                End
9290>>>>>>
9290>>>>>            End
9290>>>>>>
9290>>>>>            
9290>>>>>            Get Error_Description ErrNum ErrMsg to sErrorText
9291>>>>>            
9291>>>>>            // if the error source is identified we can get extended error
9291>>>>>            // text for our error message
9291>>>>>            If ghoErrorSource Begin
9293>>>>>                Get extended_error_Message of ghoErrorSource to sMess
9294>>>>>                If (sMess <> '') ;                    Move (sErrorText + "\n\n" + sMess ) to sErrorText
9297>>>>>            End
9297>>>>>>
9297>>>>>            
9297>>>>>            If (bUnhandledSupport) Begin
9299>>>>>                // as of 14.1, this is the preferred way to do errors
9299>>>>>                If ( bCritical or bIsUnhandled) Begin
9301>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
9302>>>>>                    If (sSource<>"") Begin
9304>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
9305>>>>>                    End
9305>>>>>>
9305>>>>>                End
9305>>>>>>
9305>>>>>                Else If (pbShowErrorNumber(Self)) Begin
9308>>>>>                    // if a user error, we provide a way to see error numbers.
9308>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
9309>>>>>                End
9309>>>>>>
9309>>>>>            End
9309>>>>>>
9309>>>>>            Else Begin
9310>>>>>                // we get here if we want it to work the old (less good) way. This is provided
9310>>>>>                // only for backwards compatibility. All errors go through the message box
9310>>>>>                Get Verbose_State to bVerbose
9311>>>>>                If (bVerbose)  Begin
9313>>>>>                    Move ( sErrorText + "\n\n" + SFormat(C_$TechnicalDetails, ErrNum, Err_Line) ) to sErrorText
9314>>>>>                    If (sSource<>"") Begin
9316>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
9317>>>>>                    End
9317>>>>>>
9317>>>>>                End
9317>>>>>>
9317>>>>>            End
9317>>>>>>
9317>>>>>            
9317>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
9319>>>>>                Send UnhandledErrorDisplay Err_Line sErrorText
9320>>>>>            End
9320>>>>>>
9320>>>>>            Else Begin
9321>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
9322>>>>>                Move (Message_Box(sErrorText, sCaption, MB_Ok, iIcon)) to iReply
9323>>>>>            End
9323>>>>>>
9323>>>>>            
9323>>>>>            // abort on critical errors
9323>>>>>            If bCritical ;                Abort
9326>>>>>            
9326>>>>>        End
9326>>>>>>
9326>>>>>        Move 0 to ghoErrorSource
9327>>>>>        Set Error_Processing_State to False // no longer reporting an error
9328>>>>>    End_Procedure
9329>>>>>    
9329>>>>>    
9329>>>>>    // The following functions are rarely or never used.
9329>>>>>    
9329>>>>>    // The functions below are used to construct a general help
9329>>>>>    // name for errors that are generated by the system.  If processing
9329>>>>>    // comes here, then there was no module specific help found.  These
9329>>>>>    // functions will provide a more general help name that appears in
9329>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
9329>>>>>    // places in the help file under this application and module name.
9329>>>>>    
9329>>>>>    // Returns "ERROR:errornum" to supply error help.
9329>>>>>    Function Help_Name Returns String
9331>>>>>        Function_Return (Append("ERROR:",lastErr))
9332>>>>>    End_Function
9333>>>>>    
9333>>>>>    Function Application_Name Returns String
9335>>>>>        Function_Return 'SYSTEM'
9336>>>>>    End_Function
9337>>>>>    
9337>>>>>    Function Module_Name Returns String
9339>>>>>        Function_Return ''
9340>>>>>    End_Function
9341>>>>>End_Class
9342>>>>>
9342>>>>>Object Error_Info_Object is a ErrorSystem
9344>>>>>End_Object
9345>>>>>
9345>>>>>
9345>>>>>Procedure UserError Global String sMessage String sCaption
9347>>>>>    String sCapt
9347>>>>>    If (Error_Object_Id=0) Begin
9349>>>>>        Error DFERR_PROGRAM "No Error Handler"
9350>>>>>>
9350>>>>>        Procedure_Return
9351>>>>>    End
9351>>>>>>
9351>>>>>    
9351>>>>>    // Accept not passing a caption in which case the error handler's
9351>>>>>    // default caption. It had been the intention to require a caption ("" if none)
9351>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
9351>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
9351>>>>>    If (num_arguments>1) Begin
9353>>>>>        Move sCaption to sCapt
9354>>>>>    End
9354>>>>>>
9354>>>>>    
9354>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
9355>>>>>>
9355>>>>>    
9355>>>>>End_Procedure
9356>>>Use seq_chnl.pkg
9356>>>Use Datadict.pkg
Including file: Datadict.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Datadict.pkg)
9356>>>>>Use VDFBase.pkg
9356>>>>>Use LanguageText.pkg // language support VDF pkg replacement strings
9356>>>>>
9356>>>>>Register_Procedure File_Field_Value_Changed
9356>>>>>Register_Procedure File_Field_Mask_Changed
9356>>>>>Register_Procedure File_Field_Label_Changed
9356>>>>>Register_Procedure File_Field_Option_Changed
9356>>>>>Register_Function  Extended_DEO_State Returns Integer
9356>>>>>Register_Function  Entry_Refresh_State Returns Integer
9356>>>>>Register_Procedure Set Entry_Refresh_State Integer iState
9356>>>>>Register_Function  Allow_Foreign_New_Save_State Returns Integer
9356>>>>>Register_Function  Server Returns Integer
9356>>>>>
9356>>>>>Use Data_Set.pkg
Including file: Data_set.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Data_set.pkg)
9356>>>>>>>Use VDFBase.pkg
9356>>>>>>>Use fndmodes.pkg
Including file: fndmodes.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\fndmodes.pkg)
9356>>>>>>>>>//
9356>>>>>>>>>// special find modes
9356>>>>>>>>>//
9356>>>>>>>>>Define NEXT_RECORD  for 5 // find-next
9356>>>>>>>>>Define FIRST_RECORD for 6 // find-first
9356>>>>>>>>>Define LAST_RECORD  for 7 // find-last 
9356>>>>>>>Use refmodes.pkg
Including file: refmodes.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\refmodes.pkg)
9356>>>>>>>>>//
9356>>>>>>>>>// constants for REFRESH message parameter values
9356>>>>>>>>>//
9356>>>>>>>>>Define MODE_CLEAR             for 1  //notification from origin of clear
9356>>>>>>>>>Define MODE_FIND_OR_CLEAR_SET for 2  //notification from find or clear
9356>>>>>>>>>Define MODE_CLEAR_ALL         for 3  //notification from clear-all
9356>>>>>>>>>Define MODE_DELETE            for 4  //notification after successful delete
9356>>>>>>>>>Define MODE_SAVE              for 5  //notification after successful save
9356>>>>>>>>>
9356>>>>>>>
9356>>>>>>>
9356>>>>>>>//
9356>>>>>>>//Global integer status values
9356>>>>>>>//
9356>>>>>>>Define OPERATION_MODE   for |VI99  //status of data-sets in application
9356>>>>>>>Define OPERATION_ORIGIN for |VI108 //origin of current of data-set operation
9356>>>>>>>
9356>>>>>>>//
9356>>>>>>>//Constants for Operation_Mode global int values
9356>>>>>>>//
9356>>>>>>>Define MODE_WAITING  for 0  //wait-mode
9356>>>>>>>Define MODE_FINDING  for 1  //find-mode
9356>>>>>>>Define MODE_CLEARING for 2  //clear-mode
9356>>>>>>>Define MODE_CREATING for 3  //create-mode
9356>>>>>>>Define MODE_SAVING   for 4  //save-mode
9356>>>>>>>Define MODE_DELETING for 5  //delete-mode
9356>>>>>>>Define MODE_ABORTING for 6  //abort-mode
9356>>>>>>>Define MODE_VALIDATING for 7  //request_validate-mode : added for VDF7
9356>>>>>>>Define MODE_CLEARINGALL for 8 //clear-all mode (added in VDF8)
9356>>>>>>>
9356>>>>>>>//   The Data_Set class is implemented as a subclass of Entry_Client, with
9356>>>>>>>//   a C language handler providing the majority of new behavior.  The
9356>>>>>>>//   Data_Set class is intended to be a grouping agent for data-entry objects
9356>>>>>>>//   and a container for subordinate Data_Sets.
9356>>>>>>>//
9356>>>>>>>Use BaseData_Set.pkg
9356>>>>>>>
9356>>>>>>>// Data_Set class definition, public class layer. (Extra class layer needed
9356>>>>>>>// to augment C-based (Constrain) procedure(s).)
9356>>>>>>>
9356>>>>>>>Class DataSet is a BaseData_Set
9357>>>>>>>    
9357>>>>>>>    
9357>>>>>>>    // maintain old name for the time being to maximize compatability
9357>>>>>>>    // between character mode and windows versions. Developers should be
9357>>>>>>>    // able to move DS classes back and forth without changes.
9357>>>>>>>    Replace_Class_Name Data_Set DataSet
9357>>>>>>>    
9357>>>>>>>    Procedure Construct_Object //Integer Img#
9359>>>>>>>        Forward Send Construct_Object No_Image //Img#
9361>>>>>>>        
9361>>>>>>>        Property Integer Constrain_File 0
9362>>>>>>>        Property Integer Auto_Fill_State False
9363>>>>>>>        Property Integer Change_Disabled_State  False
9364>>>>>>>        // RT sets this inside of Mark_components a part of old entry_client DSO behavior. Now it is never used
9364>>>>>>>        Property Integer Component_State False
9365>>>>>>>        
9365>>>>>>>    End_Procedure
9366>>>>>>>    
9366>>>>>>>    
9366>>>>>>>    //
9366>>>>>>>    // This may be called by legacy DSO and DDO code
9366>>>>>>>    //
9366>>>>>>>    // IMPORTANT NOTE of change for 8.2:
9366>>>>>>>    //         DO NOT call or augment this anymore.
9366>>>>>>>    //
9366>>>>>>>    //         for sending: Find all cases of Field_main_index and change it to File_Field_Index
9366>>>>>>>    //
9366>>>>>>>    //         for augmenting: In DSOs - replace Field_main_index with File_field_index
9366>>>>>>>    //                         In DDOs - replace Field_main_Index with Field_Index and do not pass
9366>>>>>>>    //                                   the file parameter.
9366>>>>>>>    //                                   See DDOs Field_index and File_field_Index for more
9366>>>>>>>    //
9366>>>>>>>    Function Field_Main_Index Integer file Integer Field Returns Integer
9368>>>>>>>        Integer dataType fldNdx retval ordr
9368>>>>>>>        Move -1 to retval      //field has no main index (default)
9369>>>>>>>        If (file <> 0) Begin
9371>>>>>>>//      FIELD_DEF file field to dataType fldNdx
9371>>>>>>>            Get_Attribute DF_FIELD_INDEX of file Field to fldNdx // main index field
9374>>>>>>>            If (fldNdx > 0 or Field = 0) ;                Move fldNdx to retval //field has main index
9377>>>>>>>        End
9377>>>>>>>>
9377>>>>>>>        If (file = main_file(Self)) Begin
9379>>>>>>>            Get ordering to ordr
9380>>>>>>>            If (ordr >= 0) ;                Move ordr to retval  //ordering takes precedence over main index
9383>>>>>>>        End
9383>>>>>>>>
9383>>>>>>>        Function_Return retval
9384>>>>>>>    End_Function
9385>>>>>>>    
9385>>>>>>>    // This allows packages that still use data-sets instead of DDOs to use this
9385>>>>>>>    // message syntax.
9385>>>>>>>    // Note that this will never get here if the DD class is used as
9385>>>>>>>    // it has its own handler for this. It only is called if DSOs are used in which
9385>>>>>>>    // case it calls the old message field_main_index above.
9385>>>>>>>    // DDO based objects will NEVER call this code
9385>>>>>>>    //
9385>>>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
9387>>>>>>>        Function_Return (Field_main_Index(Self,iFile,iField))
9388>>>>>>>    End_Function
9389>>>>>>>    
9389>>>>>>>    
9389>>>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
9391>>>>>>>        
9391>>>>>>>        RowID   riRow
9391>>>>>>>        Integer iIndex
9391>>>>>>>        Handle  hoServer
9391>>>>>>>        Integer iSegments iSeg iSegFld iSegFldMainIndex
9391>>>>>>>        Boolean bChanged bDoCheck bOk
9391>>>>>>>        
9391>>>>>>>        //Get Field_Main_Index iFile iField to iIndex
9391>>>>>>>        Get File_Field_Index iFile iField to iIndex
9392>>>>>>>        If (iIndex<>-1) Begin
9394>>>>>>>            // get prior rowId before it get cleared
9394>>>>>>>            Move (GetRowID(iFile)) to riRow
9395>>>>>>>            //  'hold' buffer to prepare for entry_update
9395>>>>>>>            Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
9398>>>>>>>            If bDoEntryUpdate Begin
9400>>>>>>>                Send Request_Entry_Update iFile 1  //entUpdt all DEOs as required
9401>>>>>>>                
9401>>>>>>>                // If the buffer is cleared (no record and no changed data) then we want
9401>>>>>>>                // to do a constrained_clear which will force the buffer to get cleared
9401>>>>>>>                // according to the rules of the current constraints.
9401>>>>>>>                //Get_field_value iFile 0 to iRec
9401>>>>>>>                //Move (GetRowID(iFile)) to riRow // 12.1 moved above the set file inactive
9401>>>>>>>                
9401>>>>>>>                // If there was an active record to begin with we consider this changed (not cleared)
9401>>>>>>>                If (not(IsNullRowId(riRow))) Begin
9403>>>>>>>                    Move True to bChanged
9404>>>>>>>                End
9404>>>>>>>>
9404>>>>>>>                Else Begin
9405>>>>>>>                    // or, if the record was already changed or the entry_update created a change
9405>>>>>>>                    // we consider this changed
9405>>>>>>>                    Get_Attribute DF_FILE_CHANGED of iFile to bChanged
9408>>>>>>>                End
9408>>>>>>>>
9408>>>>>>>                
9408>>>>>>>                If not bChanged Begin
9410>>>>>>>                    // if buffer is unchanged, do a constrained clear. It is unchanged if there was not
9410>>>>>>>                    // active record, the record was unchanged, and the update didn't change anything.
9410>>>>>>>                    Constrained_Clear eFindMode iFile by iIndex
9413>>>>>>>                End
9413>>>>>>>>
9413>>>>>>>                Else If (eFindMode=GE or eFindMode=LE and iIndex>0) Begin
9416>>>>>>>                    
9416>>>>>>>                    // If mode is GE or LE we need to do some extra processing. We want to clear
9416>>>>>>>                    // all index segemnt fields that occur after this field in the index. This way
9416>>>>>>>                    // dbList searches and find ge searches (f9) will always find the first record
9416>>>>>>>                    // that matches the data in the field being searched. This was if an index like
9416>>>>>>>                    // customer.name x customer.number where you had 10 identical names "john" typing
9416>>>>>>>                    // john will find the first record, because customer.number will get cleared.
9416>>>>>>>                    // Note we can no do this with GT or LT or you'd get stuck in fields
9416>>>>>>>                    
9416>>>>>>>                    // check all fields for index. Once you find the iField field, clear all
9416>>>>>>>                    // fields that follow it. Only do this if the other fields do not use the
9416>>>>>>>                    // same index as its primary index (in which case we assume the data is intentional).
9416>>>>>>>                    // This should handle most cases.
9416>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
9419>>>>>>>                    For iSeg from 1 to iSegments
9425>>>>>>>>
9425>>>>>>>                        Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSeg to iSegFld
9428>>>>>>>                        If not bDoCheck Begin
9430>>>>>>>                            If (iSegFld=iField) ;                                Move True to bDoCheck // marked after we find the find field in the index
9433>>>>>>>                        End
9433>>>>>>>>
9433>>>>>>>                        Else Begin // we get here after we've found the main field segment
9434>>>>>>>                            // if main index if this segment is same as our find index, do nothing
9434>>>>>>>                            Get File_Field_Index iFile iSegFld to iSegFldMainIndex
9435>>>>>>>                            If (iSegFldMainIndex<>iIndex) ;                                Set_Field_Value iFile iSegFld to ''
9440>>>>>>>                        End
9440>>>>>>>>
9440>>>>>>>                    Loop
9441>>>>>>>>
9441>>>>>>>                End
9441>>>>>>>>
9441>>>>>>>                
9441>>>>>>>                Get Which_Data_Set iFile to hoServer
9442>>>>>>>                If (hoServer and iFile=main_file(hoServer)) ;                    Send Attach_Main_File to hoServer
9445>>>>>>>                Else ;                    Attach iFile
9447>>>>>>>            End
9447>>>>>>>>
9447>>>>>>>            
9447>>>>>>>            Move False to Err
9448>>>>>>>            
9448>>>>>>>            If (Is_SuperFind_Required(Self,iFile)) ;                Send Request_SuperFind eFindMode iFile iField
9451>>>>>>>            Else If bDeferred ;                Send Request_Read eFindMode iFile iIndex
9455>>>>>>>            Else ;                Send Request_Find eFindMode iFile iIndex
9457>>>>>>>            
9457>>>>>>>            If (not(Found) and not(err)) Begin
9459>>>>>>>                // refind original record (or leave it cleared if not record)
9459>>>>>>>                Move (FindByRowId(iFile,riRow)) to bOk
9460>>>>>>>                
9460>>>>>>>                If bShowFindErr ;                    Error (If(eFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
9463>>>>>>>                Move False to Found
9464>>>>>>>            End
9464>>>>>>>>
9464>>>>>>>        End
9464>>>>>>>>
9464>>>>>>>        Else ;            If bShowFindErr ;                Error DFERR_FIELD_NOT_INDEXED
9468>>>>>>>    End_Procedure
9469>>>>>>>    
9469>>>>>>>    
9469>>>>>>>    // We only care about should_saves of DEOs and not DSOs when
9469>>>>>>>    // exiting the app. Create a handler for data set class. We still
9469>>>>>>>    // broadcast in case we've got nested deos in the dso (hopefully not).
9469>>>>>>>    //
9469>>>>>>>    Function Exit_Application_Check Returns Integer
9471>>>>>>>        Integer rVal
9471>>>>>>>        Broadcast Get Exit_Application_Check to Rval // check w/ kids
9473>>>>>>>        Function_Return rVal
9474>>>>>>>    End_Function
9475>>>>>>>    
9475>>>>>>>    Procedure Constrain
9477>>>>>>>        Integer iFile
9477>>>>>>>        Send OnConstrain
9478>>>>>>>        Forward Send Constrain
9480>>>>>>>        Get Constrain_File to iFile
9481>>>>>>>        If iFile ;            Constrain (Main_file(Self)) relates to iFile
9484>>>>>>>    End_Procedure
9485>>>>>>>    
9485>>>>>>>    Procedure OnConstrain
9487>>>>>>>    End_Procedure
9488>>>>>>>    
9488>>>>>>>    // Less confusing Message for adding Updating servers
9488>>>>>>>    //
9488>>>>>>>    Procedure Set DDO_Server Handle ObjId
9490>>>>>>>        Send Attach_Server ObjId
9491>>>>>>>    End_Procedure
9492>>>>>>>    
9492>>>>>>>    // This is called when a view takes or retakes the
9492>>>>>>>    // focus. If DD not in use, do nothing.
9492>>>>>>>    //
9492>>>>>>>    Procedure Refind_DD_Records
9494>>>>>>>        If (in_use_state(Self)) ;            Send refind_records
9497>>>>>>>    End_Procedure
9498>>>>>>>    
9498>>>>>>>    // this returns true if the data-set is changed AND there are attached
9498>>>>>>>    // DEO objects. Without this you can get "changes exist" condition reported
9498>>>>>>>    // that the user will have no way of saving.
9498>>>>>>>    //
9498>>>>>>>    Function Data_Set_Should_Save Returns Integer
9500>>>>>>>        Function_Return (Should_Save(Self) and ;            Data_Set_User_interface_count(Self))
9501>>>>>>>    End_Function
9502>>>>>>>    
9502>>>>>>>    // returns 0 indicating that this is not DD enabled. DataDictionary objects will return 1.
9502>>>>>>>    // Add DSOs and DDOs must understand this message
9502>>>>>>>    
9502>>>>>>>    Function Extended_DSO_State Returns Integer
9504>>>>>>>        Function_Return 0
9505>>>>>>>    End_Function
9506>>>>>>>    
9506>>>>>>>    
9506>>>>>>>End_Class
9507>>>>>>>
9507>>>>>>>
9507>>>>>>>
9507>>>>>Use DDValtbl.pkg  // validation table classes
Including file: Ddvaltbl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Ddvaltbl.pkg)
9507>>>>>>>//  Validation Table Support for Extended Data-Sets. Fields may
9507>>>>>>>//  attached to validation tables which can then be used for
9507>>>>>>>//  validation (if Validate_state is true) or list loading.
9507>>>>>>>//  Developers can create their own validation tables as long as they
9507>>>>>>>//  conform to the following external interface:
9507>>>>>>>//
9507>>>>>>>// Properties
9507>>>>>>>//   Static_State       - if list must be rebuilt each validation, load
9507>>>>>>>//   Allow_Blank_state  - If Blank or 0 is a valid response
9507>>>>>>>//   Validate_State     - should table be used for validation
9507>>>>>>>//   Table_Loaded_State - is the validation table initialized?
9507>>>>>>>//
9507>>>>>>>// Methods
9507>>>>>>>//  Get Validate_Value sValue to iVal - if iVal=0, it is legal
9507>>>>>>>//  Send Fill_list                    - fills a static list
9507>>>>>>>//  Send Request_Fill_From_List iObject iMessage
9507>>>>>>>//        This is a callback that will fill an external list by sending
9507>>>>>>>//        the passed message (iMessage) back to the requesting object
9507>>>>>>>//        (iObject). It will send this message for each item in the
9507>>>>>>>//        validation table. It always passes back four params. Those are:
9507>>>>>>>//                     iItem - Item count being passed back
9507>>>>>>>//                     sData - The Database value of the item
9507>>>>>>>//                     sDesc - The Value's description, "" if none
9507>>>>>>>//                     iFile - File number associated with the item (if any)
9507>>>>>>>//                     iRec  - Record associated with the item (if any)
9507>>>>>>>// Developers can create classes of any complexity to support validation
9507>>>>>>>// tables. We have provided the following four classes.
9507>>>>>>>//
9507>>>>>>>//  ValidationTable is an Array
9507>>>>>>>//           Provides simple one dimensional table support. The table must be
9507>>>>>>>//           loaded manually by creating fill_list and sending the message
9507>>>>>>>//           Add_Table_Value (send Add_Table_Value Value). If list is static
9507>>>>>>>//           it is filled once. If non-static it is filled each time it is
9507>>>>>>>//           requested to validate or fill a foreign lis.
9507>>>>>>>//
9507>>>>>>>//  DescriptionValidationTable is a ValidationTable
9507>>>>>>>//           Provides a more complex three dimension array allowing the
9507>>>>>>>//           object to store a data value, description value and a record
9507>>>>>>>//           number. The developer must fill this list using the Add_table_
9507>>>>>>>//           value message passing up to three values (data, desc, record).
9507>>>>>>>//
9507>>>>>>>//  FileValidationTable is a DescriptionValidationTable
9507>>>>>>>//           Provides a data aware table. This can be used to load data from
9507>>>>>>>//           data-files, from data-sets. If you use data-sets you can place
9507>>>>>>>//           constraints within the data-set. You must define the file-number,
9507>>>>>>>//           data-set (if any), the file index, the file's data field, and
9507>>>>>>>//           the file's description field. You can also define an optional
9507>>>>>>>//           "Type". All records are constrained to this type (with or with-
9507>>>>>>>//           data-sets). If is assumed that this file has an optimized finding
9507>>>>>>>//           index.
9507>>>>>>>//
9507>>>>>>>//  CodeValidationTable is a FileValidationTable
9507>>>>>>>//           Used for Code lists. Simply set Type_Value to the "type"
9507>>>>>>>//
9507>>>>>>>Use VDFBase.pkg
9507>>>>>>>
9507>>>>>>>
9507>>>>>>>Class ValidationTable is an Array
9508>>>>>>>    
9508>>>>>>>    Procedure Construct_Object
9510>>>>>>>        Forward Send Construct_Object
9512>>>>>>>        Property Integer Static_State        True
9513>>>>>>>        
9513>>>>>>>        Property Integer Table_Loaded_State  False
9514>>>>>>>        
9514>>>>>>>        Property Integer Validate_State      True
9515>>>>>>>        Property Integer Allow_Blank_State   False
9516>>>>>>>        Property Integer Main_File           0
9517>>>>>>>        Property String  Table_Title         DD_VALIDATION_LIST_TITLE
9518>>>>>>>        
9518>>>>>>>        Property Integer Number_Elements     1
9519>>>>>>>        
9519>>>>>>>        // System maintained. Sub-classes use these
9519>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
9519>>>>>>>        
9519>>>>>>>        Property String  Current_Code            ''
9520>>>>>>>        
9520>>>>>>>        Property String  Current_Description     ''
9521>>>>>>>        
9521>>>>>>>        Property RowID Current_RowId
9522>>>>>>>    End_Procedure
9523>>>>>>>    
9523>>>>>>>    Function Data_Item_Count Returns Integer
9525>>>>>>>        Function_Return (Item_Count(Self))
9526>>>>>>>    End_Function
9527>>>>>>>    
9527>>>>>>>    Function Data_Value Integer iItem Returns String
9529>>>>>>>        Function_Return (Value(Self,iItem))
9530>>>>>>>    End_Function
9531>>>>>>>    
9531>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
9533>>>>>>>        Set Value  iItem to sValue
9534>>>>>>>    End_Procedure
9535>>>>>>>    
9535>>>>>>>    Function Data_Description Integer iItem Returns String
9537>>>>>>>        Function_Return ''
9538>>>>>>>    End_Function
9539>>>>>>>    
9539>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
9541>>>>>>>    End_Procedure
9542>>>>>>>    
9542>>>>>>>    Function Data_RowId Integer iItem Returns RowID
9544>>>>>>>        Function_Return (NullRowId())
9545>>>>>>>    End_Function
9546>>>>>>>    
9546>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
9548>>>>>>>    End_Procedure
9549>>>>>>>    
9549>>>>>>>    
9549>>>>>>>    Procedure Add_Table_Value String sValue
9551>>>>>>>        Set Data_Value  (Data_Item_Count(Self)) to sValue
9552>>>>>>>    End_Procedure
9553>>>>>>>    
9553>>>>>>>    Function Validate_Value String sCode Returns Integer
9555>>>>>>>        Integer iMax
9555>>>>>>>        Integer iCnt
9555>>>>>>>        If (sCode = '');            Function_Return (not(Allow_Blank_State(Self)))
9558>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
9560>>>>>>>            Send Delete_Data
9561>>>>>>>            Send Fill_list
9562>>>>>>>            Set Table_Loaded_State to True
9563>>>>>>>        End
9563>>>>>>>>
9563>>>>>>>        Get Data_Item_Count to iMax
9564>>>>>>>        Decrement iMax
9565>>>>>>>        For iCnt from 0 to iMax
9571>>>>>>>>
9571>>>>>>>            If (sCode=Data_Value(Self,iCnt)) Begin
9573>>>>>>>                Set Current_Code        to sCode
9574>>>>>>>                Set Current_Description to (Data_Description(Self,iCnt))
9575>>>>>>>                Set Current_RowId       to (Data_RowId(Self,iCnt))
9576>>>>>>>                Function_Return 0
9577>>>>>>>            End
9577>>>>>>>>
9577>>>>>>>        Loop
9578>>>>>>>>
9578>>>>>>>        Function_Return 1 // 0=OK
9579>>>>>>>    End_Function
9580>>>>>>>    
9580>>>>>>>    Function Find_Code_Description String sCode Returns String
9582>>>>>>>        If (sCode='' or ;            (sCode<>Current_Code(Self) and ;            Validate_Value(Self,sCode) ) );            Function_Return ''
9585>>>>>>>        Function_Return (Current_Description(Self))
9586>>>>>>>    End_Function
9587>>>>>>>    
9587>>>>>>>    
9587>>>>>>>    //  The deveveloper (or a sub-class) must fill this list. It is done
9587>>>>>>>    //  by finding the item and sending the Message:
9587>>>>>>>    //    Send Add_Table_Value sValue {sDescr}
9587>>>>>>>    //
9587>>>>>>>    Procedure Fill_List
9589>>>>>>>        Set Table_Loaded_State to True
9590>>>>>>>    End_Procedure
9591>>>>>>>    
9591>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
9593>>>>>>>        Integer iMax
9593>>>>>>>        Integer iCnt
9593>>>>>>>        Integer iFile
9593>>>>>>>        
9593>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
9596>>>>>>>        
9596>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
9598>>>>>>>            Send Delete_Data
9599>>>>>>>            Send Fill_list
9600>>>>>>>            Set Table_Loaded_State to True
9601>>>>>>>        End
9601>>>>>>>>
9601>>>>>>>        Get Main_File to iFile
9602>>>>>>>        Get Data_Item_Count to iMax
9603>>>>>>>        Decrement iMax
9604>>>>>>>        For iCnt from 0 to iMax
9610>>>>>>>>
9610>>>>>>>            Send iMsg to iObj iCnt (Data_Value(Self,iCnt)) ;                (Data_Description(Self,iCnt)) iFile ;                (Data_RowId(Self,iCnt))
9611>>>>>>>        Loop
9612>>>>>>>>
9612>>>>>>>    End_Procedure
9613>>>>>>>    
9613>>>>>>>    
9613>>>>>>>    // returns all data in a two dimension variant array.
9613>>>>>>>    // [i][0] = data
9613>>>>>>>    // [i][1] = description
9613>>>>>>>    // This can be used by Crystal CDO classes (this is why a variant array is used)
9613>>>>>>>    Function TableData Returns Variant[][]
9615>>>>>>>        Variant[][2] vData
9616>>>>>>>        Integer iMax i
9616>>>>>>>        If (Table_Loaded_State(Self)=0 or Static_State(Self)=0) Begin
9618>>>>>>>            Send Delete_Data
9619>>>>>>>            Send Fill_list
9620>>>>>>>            Set Table_Loaded_State to True
9621>>>>>>>        End
9621>>>>>>>>
9621>>>>>>>        Get Data_Item_Count to iMax
9622>>>>>>>        For i from 0 to (iMax-1)
9628>>>>>>>>
9628>>>>>>>            Get Data_Value       i to vData[i][0]
9629>>>>>>>            Get Data_Description i to vData[i][1]
9630>>>>>>>        Loop
9631>>>>>>>>
9631>>>>>>>        Function_Return vData
9632>>>>>>>    End_Function
9633>>>>>>>    
9633>>>>>>>End_Class
9634>>>>>>>
9634>>>>>>>
9634>>>>>>>
9634>>>>>>>Class DescriptionValidationTable is an ValidationTable
9635>>>>>>>    
9635>>>>>>>    Procedure Construct_Object
9637>>>>>>>        Forward Send Construct_Object
9639>>>>>>>        Set Number_Elements to 2
9640>>>>>>>    End_Procedure
9641>>>>>>>    
9641>>>>>>>    Function Data_Item_Count Returns Integer
9643>>>>>>>        Function_Return (item_count(Self)/3)
9644>>>>>>>    End_Function
9645>>>>>>>    
9645>>>>>>>    Function Data_Value Integer iItem Returns String
9647>>>>>>>        Function_Return (Value(Self,iItem*3))
9648>>>>>>>    End_Function
9649>>>>>>>    
9649>>>>>>>    Procedure Set Data_Value Integer iItem String sValue
9651>>>>>>>        Set Value  (iItem*3) to sValue
9652>>>>>>>    End_Procedure
9653>>>>>>>    
9653>>>>>>>    Function Data_Description Integer iItem Returns String
9655>>>>>>>        Function_Return (Value(Self,iItem*3+1))
9656>>>>>>>    End_Function
9657>>>>>>>    
9657>>>>>>>    Procedure Set Data_Description Integer iItem String sValue
9659>>>>>>>        Set Value  (iItem*3+1) to sValue
9660>>>>>>>    End_Procedure
9661>>>>>>>    
9661>>>>>>>    Function Data_RowId Integer iItem Returns RowID
9663>>>>>>>        String sRowId
9663>>>>>>>        Get Value (iItem*3+2) to sRowId
9664>>>>>>>        Function_Return (DeSerializeRowId(sRowId))
9665>>>>>>>    End_Function
9666>>>>>>>    
9666>>>>>>>    Procedure Set Data_RowId Integer iItem RowID riValue
9668>>>>>>>        Set Value  (iItem*3+2) to (SerializeRowId(riValue))
9669>>>>>>>    End_Procedure
9670>>>>>>>    
9670>>>>>>>    Procedure Add_Table_Value String sData String sDescr RowID riRec
9672>>>>>>>        String  sVal
9672>>>>>>>        RowID   riRecVal
9672>>>>>>>        Integer iCnt
9672>>>>>>>        Get Data_Item_Count to iCnt
9673>>>>>>>        Set Data_Value iCnt to sData
9674>>>>>>>        
9674>>>>>>>        // If one param passed use it for both display and database values
9674>>>>>>>        If (num_arguments <= 1);            Move sData  to sVal
9677>>>>>>>        Else ;            Move sDescr to sVal
9679>>>>>>>        Set Data_Description iCnt to sVal
9680>>>>>>>        
9680>>>>>>>        If (num_arguments <= 2) ;            Move (NullRowId()) to riRecVal
9683>>>>>>>        Else ;            Move riRec        to riRecVal
9685>>>>>>>        Set Data_RowId iCnt to riRecVal
9686>>>>>>>    End_Procedure
9687>>>>>>>End_Class
9688>>>>>>>
9688>>>>>>>
9688>>>>>>>Class FileValidationTable is an DescriptionValidationTable
9689>>>>>>>    
9689>>>>>>>    Procedure Construct_Object
9691>>>>>>>        Forward Send Construct_Object
9693>>>>>>>        Property Integer No_Fill_State     False // this is never used and is obsolete. (JJT)
9694>>>>>>>        Property Integer Ordering          1   // Indx1 is a good guess.
9695>>>>>>>        Property String  Type_Value        ''  // default these two to
9696>>>>>>>        Property Integer Type_Field        0   // Undefined (none).
9697>>>>>>>        Property Integer Code_Field        1   // Fld 1=code, 2=descr
9698>>>>>>>        Property Integer Description_Field 2   // are good guesses.
9699>>>>>>>        
9699>>>>>>>        Property Integer Code_Load_Object  0   // or (Code_Loader(Self))
9700>>>>>>>    End_Procedure
9701>>>>>>>    
9701>>>>>>>    Function Table_Loaded_State Returns Integer
9703>>>>>>>        Integer iRVal
9703>>>>>>>        Get No_fill_State to iRVal // if true, table always is loaded
9704>>>>>>>        If not iRval ;            Forward Get table_loaded_State to iRVal
9708>>>>>>>        Function_Return iRval
9709>>>>>>>    End_Function
9710>>>>>>>    
9710>>>>>>>    Function Validate_Value String sCode Returns Integer
9712>>>>>>>        Integer iRVal
9712>>>>>>>        Integer iDSO
9712>>>>>>>        Get Code_Load_Object  to iDSO
9713>>>>>>>        // we use standard validate, if code is blank, OR if
9713>>>>>>>        //   1. if no code DSO or the code DSO exists but is not busy.
9713>>>>>>>        //   2. AND it is not no-fill
9713>>>>>>>        //   3. AND it is static
9713>>>>>>>        // Else we find the record directly
9713>>>>>>>        // Note that the operation mode is busy during request_validate (the
9713>>>>>>>        // ddo does this). WHen operation mode is busy we must not use
9713>>>>>>>        // the code dso (must find manually).
9713>>>>>>>        If (sCode='' or ;            ( (iDSO=0 or Operation_Mode=0)    and ; // if no code DSO or DSO not busy            No_Fill_State(Self)=0 and ;            Static_State(Self) ) ) ;            Forward Get Validate_Value sCode to iRVal
9717>>>>>>>        Else If (sCode<>Current_Code(Self)) ;            Get Find_Value sCode to iRVal
9721>>>>>>>        Function_Return iRVal // OK
9722>>>>>>>    End_Function
9723>>>>>>>    
9723>>>>>>>    Procedure Initialize_File
9725>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
9725>>>>>>>        Get Code_Load_Object  to iDSO
9726>>>>>>>        Get Main_File         to iFile
9727>>>>>>>        Get Code_Field        to iCodeField
9728>>>>>>>        Get Description_Field to iDescField
9729>>>>>>>        Get Ordering          to iIndex
9730>>>>>>>        Get Type_Field        to iTypeField
9731>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Initialize_File to iDSO ;            iFile iIndex iCodeField iDescField ;            iTypeField (Type_Value(Self))
9734>>>>>>>        Else Begin
9735>>>>>>>            Clear iFile
9736>>>>>>>            // if Type exists, seed the type value
9736>>>>>>>            If iTypeField ;                Set_Field_Value iFile iTypeField to (Type_Value(Self))
9741>>>>>>>        End
9741>>>>>>>>
9741>>>>>>>    End_Procedure
9742>>>>>>>    
9742>>>>>>>    Function Find_Value String Code Returns Integer
9744>>>>>>>        Integer iFile iCodeField iDescField iDSO iIndex iTypeField
9744>>>>>>>        Get Code_Load_Object  to iDSO
9745>>>>>>>        Get Main_File         to iFile
9746>>>>>>>        Get Ordering          to iIndex
9747>>>>>>>        Get Code_Field        to iCodeField
9748>>>>>>>        Get Description_Field to iDescField
9749>>>>>>>        Get Type_Field        to iTypeField
9750>>>>>>>        Send Initialize_File
9751>>>>>>>        //
9751>>>>>>>        Set_Field_Value iFile iCodeField to Code
9754>>>>>>>        If (iDSO and Operation_Mode=0) ;            Send Request_Find to iDSO EQ iFile iIndex
9757>>>>>>>        Else ;            Vfind iFile iIndex EQ
9760>>>>>>>        If not (Found) ;            Function_Return 1
9763>>>>>>>        // Set properties Current_code and Current_Description
9763>>>>>>>        Send Store_Current_Data iFile iCodeField iDescField
9764>>>>>>>        Function_Return 0
9765>>>>>>>    End_Function
9766>>>>>>>    
9766>>>>>>>    // internal
9766>>>>>>>    Procedure Store_Current_Data Integer iFile Integer iCodeField Integer iDescField
9768>>>>>>>        String sVal
9768>>>>>>>        Get_Field_Value iFile iCodeField to sVal
9771>>>>>>>        Set Current_Code to (trim(sVal))
9772>>>>>>>        If iDescField Begin
9774>>>>>>>            Get_Field_Value iFile iDescField to sVal
9777>>>>>>>            Set Current_Description to (trim(sVal))
9778>>>>>>>        End
9778>>>>>>>>
9778>>>>>>>        Set Current_RowId to (GetRowId(iFile))
9779>>>>>>>    End_Procedure
9780>>>>>>>    
9780>>>>>>>    Function Next_Code_Record Returns Boolean
9782>>>>>>>        Integer iFile iCodeField iDescField iIndex
9782>>>>>>>        Integer iTypeField
9782>>>>>>>        String sTypeValue sFoundTypeValue
9782>>>>>>>        Boolean bFound
9782>>>>>>>        Handle hoDSO
9782>>>>>>>        Get Code_Load_Object  to hoDSO
9783>>>>>>>        Get Description_Field to iDescField
9784>>>>>>>        Get Code_Field        to iCodeField
9785>>>>>>>        Get Main_File         to iFile
9786>>>>>>>        
9786>>>>>>>        If hoDSO Begin
9788>>>>>>>            Get Next_Code_record of hoDSO to bFound
9789>>>>>>>        End
9789>>>>>>>>
9789>>>>>>>        Else Begin
9790>>>>>>>            Get Ordering to iIndex
9791>>>>>>>            Vfind iFile iIndex GT
9793>>>>>>>            Move (Found) to bFound
9794>>>>>>>            If bFound Begin
9796>>>>>>>                // if found see if we are at the end of the valid list of types
9796>>>>>>>                Get Type_Field to iTypeField
9797>>>>>>>                Get Type_Value to sTypeValue
9798>>>>>>>                If ((iTypeField<>0) and (sTypeValue<>"")) Begin
9800>>>>>>>                    Get_Field_Value iFile iTypeField to sFoundTypeValue
9803>>>>>>>                    Move (Trim(sTypeValue)=Trim(sFoundTypeValue)) to bFound
9804>>>>>>>                End
9804>>>>>>>>
9804>>>>>>>            End
9804>>>>>>>>
9804>>>>>>>        End
9804>>>>>>>>
9804>>>>>>>        If bFound Begin
9806>>>>>>>            Send Store_Current_Data iFile iCodeField iDescField
9807>>>>>>>        End
9807>>>>>>>>
9807>>>>>>>        Function_Return bFound
9808>>>>>>>    End_Function
9809>>>>>>>    
9809>>>>>>>    Procedure Fill_List
9811>>>>>>>        RowID riId
9811>>>>>>>        Boolean bFound
9811>>>>>>>        String sCode sDesc
9811>>>>>>>        If (Static_State(Self)=0 or No_Fill_State(Self)) ;            Procedure_Return
9814>>>>>>>        //
9814>>>>>>>        Send Delete_Data
9815>>>>>>>        Send Initialize_File
9816>>>>>>>        Get Next_Code_Record to bFound
9817>>>>>>>        While bFound
9821>>>>>>>            Get Current_Code        to sCode
9822>>>>>>>            Get Current_Description to sDesc
9823>>>>>>>            Get Current_RowId       to riId
9824>>>>>>>            Send Add_Table_Value sCode sDesc riId
9825>>>>>>>            Get Next_Code_Record to bFound
9826>>>>>>>        Loop
9827>>>>>>>>
9827>>>>>>>        Set Table_Loaded_State to True
9828>>>>>>>    End_Procedure
9829>>>>>>>    
9829>>>>>>>    Procedure Request_Fill_From_List Integer iObj Integer iMsg
9831>>>>>>>        Integer iItem
9831>>>>>>>        Integer iFile
9831>>>>>>>        RowID   riId
9831>>>>>>>        Boolean bFound
9831>>>>>>>        String sCode sDesc
9831>>>>>>>        
9831>>>>>>>        If (iObj=0 or iMsg=0) ;            Procedure_Return
9834>>>>>>>        
9834>>>>>>>        If (Static_State(Self) and No_Fill_State(Self)=0 ) ;            Forward Send Request_Fill_From_List iObj iMsg
9838>>>>>>>        Else Begin
9839>>>>>>>            Get Main_File to iFile
9840>>>>>>>            Send Initialize_File
9841>>>>>>>            Get Next_Code_Record to bFound
9842>>>>>>>            While bFound
9846>>>>>>>                Get Current_Code        to sCode
9847>>>>>>>                Get Current_Description to sDesc
9848>>>>>>>                Get Current_RowId       to riId
9849>>>>>>>                Send iMSG to iObj iItem sCode sDesc iFile riId
9850>>>>>>>                Increment iItem
9851>>>>>>>                Get Next_Code_Record to bFound
9852>>>>>>>            Loop
9853>>>>>>>>
9853>>>>>>>        End
9853>>>>>>>>
9853>>>>>>>    End_Procedure
9854>>>>>>>End_Class
9855>>>>>>>
9855>>>>>>>Use CodeLoad.pkg
Including file: codeload.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\codeload.pkg)
9855>>>>>>>>>// Interface:
9855>>>>>>>>>//
9855>>>>>>>>>//  Procedure Initialize_File Integer File# Integer Index# Integer Code# ;
9855>>>>>>>>>//                            Integer Desc# Integer Type# String Type
9855>>>>>>>>>//
9855>>>>>>>>>//      This initializes the data-set for finding. You MUST pass all five
9855>>>>>>>>>//      parameters here. They are:
9855>>>>>>>>>//          File#  -  main file to use
9855>>>>>>>>>//         Index#  - Index to use for finding
9855>>>>>>>>>//          Code#  - field number of the code
9855>>>>>>>>>//          Desc#  - field number of the code's description
9855>>>>>>>>>//          Type#  - field number of the constraining Type (0 if none)
9855>>>>>>>>>//           Type  - the constrain type value ('' = allow all records)
9855>>>>>>>>>//
9855>>>>>>>>>//      You MUST send this message before finding records. Alternately,
9855>>>>>>>>>//      you could set the individual properties and send rebuild_constraints
9855>>>>>>>>>//      and CLEAR to initalize the file (see code on how to do this).
9855>>>>>>>>>//
9855>>>>>>>>>//    Get Next_Code_record to ret_Int
9855>>>>>>>>>//
9855>>>>>>>>>//      Returns the next record number. 0 if no more. If record exists it
9855>>>>>>>>>//      sets the value of Current_Code and Crnt_Description.
9855>>>>>>>>>//
9855>>>>>>>>>//    Get Current_Code to Ret_String
9855>>>>>>>>>//    Get Crnt_Description to Ret_String
9855>>>>>>>>>//
9855>>>>>>>>>//      Returns the code and description of the last valid record found
9855>>>>>>>>>//      with the Next_Code_Record Message
9855>>>>>>>>>//
9855>>>>>>>>>//   Sample Usage:  This was created primarily to be used by the
9855>>>>>>>>>//                  radio-entry-form classes. In particular those using
9855>>>>>>>>>//                  the "code" look up file. Look at those packages if
9855>>>>>>>>>//                  you wish to use them yourself.
9855>>>>>>>>>//
9855>>>>>>>>>Use Data_Set.pkg
9855>>>>>>>>>
9855>>>>>>>>>Class Code_Loader_Data_Set is a DataSet
9856>>>>>>>>>    
9856>>>>>>>>>    Procedure Construct_Object Integer Img#
9858>>>>>>>>>        Forward Send Construct_Object Img#
9860>>>>>>>>>        // These should be set by the Initialize_File message
9860>>>>>>>>>        Property String  Type_Value           '' // assume no defaults.
9861>>>>>>>>>        Property Integer Type_Field           0  // These values should be
9862>>>>>>>>>        Property Integer Code_Field           0  // set by initialize_file
9863>>>>>>>>>        Property Integer Description_Field    0  //
9864>>>>>>>>>        
9864>>>>>>>>>        // These are SET by Next_Code_Record. You may GET their values
9864>>>>>>>>>        Property String  Current_Code         ''
9865>>>>>>>>>        Property String  Current_Description  ''
9866>>>>>>>>>    End_Procedure
9867>>>>>>>>>    
9867>>>>>>>>>    // If a Type exists (not a '') and there is a type field and a
9867>>>>>>>>>    // main_file constrain to the type. Else no constraints
9867>>>>>>>>>    Procedure OnConstrain
9869>>>>>>>>>        String sType
9869>>>>>>>>>        Integer iFile iField
9869>>>>>>>>>        Get Type_Value to sType
9870>>>>>>>>>        Get Main_File  to iFile
9871>>>>>>>>>        Get Type_Field to iField
9872>>>>>>>>>        If (sType<>'' and iFile<>0 and iField<>0) ;            Vconstrain iFile iField eq sType
9877>>>>>>>>>    End_Procedure
9878>>>>>>>>>    
9878>>>>>>>>>    //  This initializes the data-set for finding. You MUST pass all five
9878>>>>>>>>>    //  parameters here. They are:
9878>>>>>>>>>    //     File#  -  main file to use
9878>>>>>>>>>    //    Index#  - Index to use for finding
9878>>>>>>>>>    //     Code#  - field number of the code
9878>>>>>>>>>    //     Desc#  - field number of the code's description
9878>>>>>>>>>    //     Type#  - field number of the constraining Type (0 if none)
9878>>>>>>>>>    //      Type  - the constrain type value ('' = allow all records)
9878>>>>>>>>>    //
9878>>>>>>>>>    Procedure Initialize_File Integer File# Integer Index# Integer Code# ;            Integer Desc# Integer Type# String Type
9880>>>>>>>>>        // note: all params are required!
9880>>>>>>>>>        Set Main_File         to File#
9881>>>>>>>>>        Set Ordering          to Index#
9882>>>>>>>>>        Set Code_Field        to Code#
9883>>>>>>>>>        Set Description_Field to Desc#
9884>>>>>>>>>        Set Type_Field        to Type#
9885>>>>>>>>>        Set Type_Value        to Type
9886>>>>>>>>>        //
9886>>>>>>>>>        Send Rebuild_Constraints // set up constraints
9887>>>>>>>>>        Send Clear               // initialize the file
9888>>>>>>>>>    End_Procedure
9889>>>>>>>>>    
9889>>>>>>>>>    //  Find the next record: Return 0 if no record, 1 if record exists
9889>>>>>>>>>    //   if record exists set Current_Code and Current_Description
9889>>>>>>>>>    //
9889>>>>>>>>>    Function Next_Code_Record Returns Boolean
9891>>>>>>>>>        Integer iFile iField
9891>>>>>>>>>        String sValue
9891>>>>>>>>>        Send Request_Find GT (Main_File(Self)) (Ordering(Self))
9892>>>>>>>>>        If not (Found) ;            Function_Return False
9895>>>>>>>>>        // Set properties Current_code and Current_Description
9895>>>>>>>>>        Get Main_File to iFile
9896>>>>>>>>>        
9896>>>>>>>>>        Get Code_Field to iField
9897>>>>>>>>>        Get_Field_Value iFile iField to sValue
9900>>>>>>>>>        Set Current_Code to sValue
9901>>>>>>>>>        
9901>>>>>>>>>        Get Description_Field to iField
9902>>>>>>>>>        Get_Field_Value iFile iField to sValue
9905>>>>>>>>>        Set Current_Description to sValue
9906>>>>>>>>>        Function_Return True
9907>>>>>>>>>    End_Function
9908>>>>>>>>>    
9908>>>>>>>>>End_Class
9909>>>>>>>Use cCodeMaintOpen_Mixin.pkg
Including file: cCodeMaintOpen_Mixin.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCodeMaintOpen_Mixin.pkg)
9909>>>>>>>>>// Mixin class to support transistion support for CodeType and CodeMast files.
9909>>>>>>>>>// These files used to be in filelist and they used to reside at 207 and 208 and they
9909>>>>>>>>>// were always opened with "open as"
9909>>>>>>>>>// We want these to be in the filelist at 253 and 254. These open methods will attempt to open these files
9909>>>>>>>>>// as such. If these are old files (not in filelist or wrong number) they will get loaded with the old
9909>>>>>>>>>// open as - thus keeping this backwards compatible.
9909>>>>>>>>>// By adding to filelist, we can sort the files and we can open them as other database sources.
9909>>>>>>>>>Use VDFBase.pkg
9909>>>>>>>>>
9909>>>>>>>>>Declare_Datafile CodeType
Including file: CodeType.fd    (C:\Projects\DF18\DbUpdateFramework2.0\DDSrc\CodeType.fd)
9909>>>>>>>>>Declare_Datafile CodeMast
Including file: CodeMast.fd    (C:\Projects\DF18\DbUpdateFramework2.0\DDSrc\CodeMast.fd)
9909>>>>>>>>>Define C_Expected_CodeType_FileNumber for 253  // and the logical name must be CODETYPE
9909>>>>>>>>>Define C_Expected_CodeMast_FileNumber for 254  // and the logical name must be CODEMAST
9909>>>>>>>>>
9909>>>>>>>>>Class cCodeMaintOpen_Mixin is a Mixin
9910>>>>>>>>>    
9910>>>>>>>>>    Procedure OpenCodeMast
9912>>>>>>>>>        String sName
9912>>>>>>>>>        If (Codemast.File_number=C_Expected_CodeMast_FileNumber) Begin
9914>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of Codemast.File_number to sName
9917>>>>>>>>>            If (uppercase(trim(sName))="CODEMAST") Begin
9919>>>>>>>>>                Open CodeMast
9921>>>>>>>>>                Procedure_Return
9922>>>>>>>>>            End
9922>>>>>>>>>>
9922>>>>>>>>>        End
9922>>>>>>>>>>
9922>>>>>>>>>        Open "CodeMast" as Codemast.File_number
9924>>>>>>>>>    End_Procedure
9925>>>>>>>>>    
9925>>>>>>>>>    Procedure OpenCodeType
9927>>>>>>>>>        String sName
9927>>>>>>>>>        If (Codetype.File_number=C_Expected_CodeType_FileNumber) Begin
9929>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of CodeType.File_number to sName
9932>>>>>>>>>            If (uppercase(trim(sName))="CODETYPE") Begin
9934>>>>>>>>>                Open CodeType
9936>>>>>>>>>                Procedure_Return
9937>>>>>>>>>            End
9937>>>>>>>>>>
9937>>>>>>>>>        End
9937>>>>>>>>>>
9937>>>>>>>>>        Open "CodeType" as CodeType.File_number
9939>>>>>>>>>    End_Procedure
9940>>>>>>>>>    
9940>>>>>>>>>End_Class
9941>>>>>>>
9941>>>>>>>//
9941>>>>>>>//  This is the object we need for loading files.
9941>>>>>>>//
9941>>>>>>>Object Code_loader is a Code_loader_Data_Set no_Image
9943>>>>>>>End_Object
9944>>>>>>>
9944>>>>>>>
9944>>>>>>>Class CodeValidationTable is an FileValidationTable
9945>>>>>>>    
9945>>>>>>>    // supports opening of file in reserved filelist area.
9945>>>>>>>    Import_Class_Protocol cCodeMaintOpen_Mixin
9946>>>>>>>    
9946>>>>>>>    Procedure Construct_Object
9948>>>>>>>        Forward Send Construct_Object
9950>>>>>>>        
9950>>>>>>>        Send OpenCodeMast                       // methods supports w/ filelist (new) and without (old)
9951>>>>>>>        
9951>>>>>>>        Set Main_File to CodeMast.File_Number   // name of file is CODEMAST
9952>>>>>>>        Set Ordering to 1                       // Index 1: Types x Code
9953>>>>>>>        Set Type_Field to 1                     // Fld 1: Type
9954>>>>>>>        Set Code_Field to 2                     // Fld 2: Code
9955>>>>>>>        Set Description_Field to 3              // Fld 3: Description
9956>>>>>>>        Set Code_load_Object to (Code_Loader(Self))
9957>>>>>>>    End_Procedure
9958>>>>>>>    
9958>>>>>>>End_Class
9959>>>>>
9959>>>>>// Used to by DDOConstraintFindMeta to return constraint expression info in a friendlier fashion
9959>>>>>Struct tDDOConstraintFindMeta
9959>>>>>    Integer iJumpInSegments
9959>>>>>    Boolean bJumpOut
9959>>>>>    Boolean bPreRelate
9959>>>>>    Boolean bPostRelate
9959>>>>>End_Struct
9959>>>>>
9959>>>>>// used by webapp resynchs
9959>>>>>Struct tDDChangedParentInfo
9959>>>>>    Integer iTable
9959>>>>>    Boolean bSwitched
9959>>>>>End_Struct
9959>>>>>
9959>>>>>// used by webapp resynchs
9959>>>>>Struct tDDChangedInfo
9959>>>>>    Boolean bChanged
9959>>>>>    tDDChangedParentInfo[] ParentChanged
9959>>>>>    tDDChangedParentInfo[] ParentChanged
9959>>>>>End_Struct
9959>>>>>
9959>>>>>Enum_List
9959>>>>>    Define CONST_EXP_JUMPOUT     for 1
9959>>>>>    Define CONST_EXP_PRE_RELATE  for 2
9959>>>>>    Define CONST_EXP_POST_RELATE for 4
9959>>>>>End_Enum_List
9959>>>>>
9959>>>>>// Constraint Find Types
9959>>>>>Enum_List
9959>>>>>    Define CONST_VALUE for 0    // Constrain File.Field eq sValue
9959>>>>>    Define CONST_CHILD          // Constrain File Relates to iOtherFile
9959>>>>>    Define CONST_FIELD          // Constrain File.field eq OtherFile.OtherField
9959>>>>>    Define CONST_EXP            // Constrain File as (Expression) - expression is internal
9959>>>>>    Define CONST_RELATES        // Sames a CONST_CHILD - should never be used
9959>>>>>End_Enum_List
9959>>>>>
9959>>>>>// Constraint Find Modes
9959>>>>>Enum_List
9959>>>>>    Define CONST_LT for 0
9959>>>>>    Define CONST_LE for 1
9959>>>>>    Define CONST_EQ for 2
9959>>>>>    Define CONST_GE for 3
9959>>>>>    Define CONST_GT for 4
9959>>>>>    Define CONST_NE for 5
9959>>>>>    Define CONST_Matches for 6       // a matches not capable of a jump in e.g., "?A*"
9959>>>>>    Define CONST_Contains for 7      // a contains
9959>>>>>    Define CONST_MatchesJumpIn for 9 // a matches which is capable of a jump in e.g., "A*"
9959>>>>>    // note that BETWEEN is actually two constraints a GE and LE
9959>>>>>End_Enum_List
9959>>>>>
9959>>>>>// Struct used to DDOConstraints to return current constraints in an array
9959>>>>>Struct tConstraintDef
9959>>>>>    Integer eType // constraint Find type
9959>>>>>    Integer eMode // constrain file mode
9959>>>>>    Integer iFile
9959>>>>>    Integer iField
9959>>>>>    String sValue
9959>>>>>    Integer iOtherFile
9959>>>>>    Integer iOtherField
9959>>>>>End_Struct
9959>>>>>
9959>>>>>// values passed to OnPre/PostFind to indicate the operation type
9959>>>>>Enum_List
9959>>>>>    Define DDFindRequestFind    // request_find
9959>>>>>    Define DDFindFindByRowRec   // FindByRowId, Find_By_Recnum
9959>>>>>    Define DDFindRequestAssign  // Request_assign
9959>>>>>    Define DDFindClear          // Clear (note Clear_All doesn't do this)
9959>>>>>End_Enum_List
9959>>>>>
9959>>>>>
9959>>>>>// these are private
9959>>>>>Define DD_RememberLast for "_REMEMBER$LAST_"
9959>>>>>Use tDDRemembered.pkg
Including file: tDDRemembered.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\tDDRemembered.pkg)
9959>>>>>>>// DDRemember Struct used for DataDictionary Class
9959>>>>>>>
9959>>>>>>>// private
9959>>>>>>>
9959>>>>>>>Struct tDDRemembered
9959>>>>>>>    Integer iField // searches are performed on this segement - it must be first
9959>>>>>>>    String sDefault
9959>>>>>>>    String sLastValue
9959>>>>>>>End_Struct
9959>>>>>>>
9959>>>>>
9959>>>>>// Used to assign a global validation_object. This can be used for
9959>>>>>// automatic prompt object on non-relational validations (checks, validation_
9959>>>>>// tables, etc.)
9959>>>>>Integer DD_Global_Validation_Prompt_Object
9959>>>>>Move 0 to DD_Global_Validation_Prompt_Object
9960>>>>>
9960>>>>>// Used for Dso traversal marking - Private (do not use)
9960>>>>>Integer   DD_Current_Mark_Id
9960>>>>>Move 0 to DD_Current_Mark_Id
9961>>>>>
9961>>>>>// Used to validate DSO structures during Save and deletes
9961>>>>>Enumeration_List
9961>>>>>    Define DD_VALIDATE_STRUCTURE_ALWAYS // Validate each save/delete operation.
9961>>>>>    Define DD_VALIDATE_STRUCTURE_NEVER  // Never validate these operations.
9961>>>>>    Define DD_VALIDATE_STRUCTURE_ONCE   // Validate Once (first save or delete).
9961>>>>>End_Enumeration_List
9961>>>>>
9961>>>>>// Used as a start for error handing in DSOs. Only affects errors that go
9961>>>>>// through operation_not_allowed and Field_Error. Used by Error_Report_Mode
9961>>>>>Enumeration_List
9961>>>>>    Define DD_ERROR_REPORT              // Report Error on screen
9961>>>>>    Define DD_ERROR_NO_REPORT           // Show no Error..
9961>>>>>End_Enumeration_List
9961>>>>>
9961>>>>>Enumeration_List
9961>>>>>    Define DD_Lock_on_All             for  7  // 111
9961>>>>>    Define DD_Lock_on_New_Save_Delete for  5  // 101
9961>>>>>    Define DD_Lock_on_Delete          for  4  // 100
9961>>>>>    Define DD_Lock_on_Save            for  2  // 010
9961>>>>>    Define DD_Lock_on_New_Save        for  1  // 001
9961>>>>>End_Enumeration_List
9961>>>>>
9961>>>>>
9961>>>>>Define DD_DEFAULT_ERROR_NUMBER  for 999
9961>>>>>
9961>>>>>
9961>>>>>
9961>>>>>
9961>>>>>// The next replaces will be used to indicate default item-options
9961>>>>>// instead of a fieldnumber which is normally used.
9961>>>>>
9961>>>>>// these are the DD bits that pertain to DEO Item options.
9961>>>>>Define DD_DEO_MASK for (DD_NOENTER ior DD_SKIPFOUND ior DD_CAPSLOCK ior DD_ZERO_SUPPRESS ior DD_AUTORETURN ior DD_AUTOBACK ior DD_AUTOCLEAR)
9961>>>>>
9961>>>>>
9961>>>>>// Special parameter options that can get passed to Set Field_Options. The
9961>>>>>// purpose is to clear all fields or the remaining passed parameters. Normally,
9961>>>>>// these are not used so it does not matter if their interface is a bit odd.
9961>>>>>Enumeration_List
9961>>>>>    Define DD_CLEAR_FIELD_OPTIONS      for -1
9961>>>>>    Define DD_CLEAR_ALL_FIELD_OPTIONS  for -2
9961>>>>>End_Enumeration_List
9961>>>>>
9961>>>>>// used to keep track of extra server file information.
9961>>>>>Struct tDDServerInformation
9961>>>>>    Integer iParent             // parent file number
9961>>>>>    Boolean bAllowNullParent    // does this DD (child) allow a null parent
9961>>>>>    Integer bParentNoSwitchIfCommitted // does this DD (child) allow switching committed parents
9961>>>>>    Boolean bNoCascadeDelete           // when a child record exists should cascade delete stop the action
9961>>>>>    Boolean bCascadeDeleteNullTheParent // when a child record exists that is null parent allowed, should we delete or null the parent
9961>>>>>End_Struct
9961>>>>>
9961>>>>>Use DDExtFld.pkg // adds extended field/pointer support
Including file: DDExtFld.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DDExtFld.pkg)
9961>>>>>>>// This is used by the DataDictionary class and provides a method for
9961>>>>>>>// windows DDs (for now) to support local buffers for text and binary buffers.
9961>>>>>>>// Field objects are created within the DD by sending the message:
9961>>>>>>>// The DD interface is:
9961>>>>>>>//
9961>>>>>>>//      Get  Field_Object iField to hExtFieldObject
9961>>>>>>>//      Send DefineExtendedField iField
9961>>>>>>>//      Send DefineAllExtendedFields
9961>>>>>>>//      Send ExtendedFieldsUpdate bSave
9961>>>>>>>//      Send ExtendedFieldsRefresh bCleared
9961>>>>>>>//      Set  File_Field_Current_Pointer_Value iFile iField iLen to pValue
9961>>>>>>>//      Set  Field_Current_Pointer_Value iField iLen to pValue
9961>>>>>>>//      Set  File_Field_Pointer_Entry iFile iField iLen bShowErr to pValue
9961>>>>>>>//      Set  Field_Pointer_Entry iField iOpts iLen bShowErr to pValue
9961>>>>>>>//      Get  File_Field_Current_Pointer_Value iFile iField to pData
9961>>>>>>>//      Get  Field_Current_Pointer_Value iField to pData
9961>>>>>>>//
9961>>>>>>>// Once object is identified, the following interface can be used
9961>>>>>>>//      Get FieldPointer of hExtFieldObject to iMemoryPointer
9961>>>>>>>//      Get FieldLength  of hExtFieldObject to iLen
9961>>>>>>>//      Get File_Number  of hExtFieldObject to iFile
9961>>>>>>>//      Get Field_Number of hExtFieldObject to iFile
9961>>>>>>>//      Set Update_Save_State of hExtFieldObject to bState         // be careful!
9961>>>>>>>//      Set Update_Find_State of hExtFieldObject to bState         // be careful
9961>>>>>>>//      Set FieldRefresh_Save_State of hExtFieldObject to bState   // be careful
9961>>>>>>>//
9961>>>>>>>
9961>>>>>>>//
9961>>>>>>>//  DD structure:
9961>>>>>>>//       DD Object           (property Field_objects points to child)
9961>>>>>>>//           FieldObjects    (array of field#s and field objs)
9961>>>>>>>//              FieldObject1 (heap alloc for each field)
9961>>>>>>>//              FieldObjectn
9961>>>>>>>//
9961>>>>>>>
9961>>>>>>>//
9961>>>>>>>// This is used to create a single extended field object.
9961>>>>>>>//
9961>>>>>>>// Interface
9961>>>>>>>//      Get FieldPointer to iMemoryPointer
9961>>>>>>>//      Get FieldLength  to iLen
9961>>>>>>>//      Get File_Number  to iFile
9961>>>>>>>//      Get Field_Number to iFile
9961>>>>>>>//      get/Set Update_Save_State to bState         // be careful!
9961>>>>>>>//      get/Set Update_Find_State to bState         // be careful
9961>>>>>>>//      get/Set FieldRefresh_Save_State to bState   // be careful
9961>>>>>>>//      get/set FieldChangedState
9961>>>>>>>//      send defineField  iFile iField
9961>>>>>>>//      Send FieldUpdate  bSave
9961>>>>>>>//      Send FieldRefresh bCleared bClearFieldChange
9961>>>>>>>//      Set  Field_pEntry iOpts iLen to pValue
9961>>>>>>>//      Set  Field_pValue iLen to pValue
9961>>>>>>>//
9961>>>>>>>Use VDFBase.pkg
9961>>>>>>>
9961>>>>>>>Class FieldObject is a cObject
9962>>>>>>>    
9962>>>>>>>    Procedure Construct_Object
9964>>>>>>>        Forward Send construct_object
9966>>>>>>>        // these are all set by DefineField and should not be changed
9966>>>>>>>        Property Integer File_Number        0
9967>>>>>>>        Property Integer Field_Number       0
9968>>>>>>>        Property Integer FieldLength        0
9969>>>>>>>        
9969>>>>>>>        // maintained by object
9969>>>>>>>        Property UChar[] pFieldArray
9970>>>>>>>        
9970>>>>>>>        // these can be changed, with care, by the developer
9970>>>>>>>        Property Integer Update_Save_State  True
9971>>>>>>>        Property Integer Update_Find_State  False // usually no point for finds
9972>>>>>>>        Property Integer FieldRefresh_State True
9973>>>>>>>        
9973>>>>>>>        // hopefully never used
9973>>>>>>>        Property Address pLegacyFieldPointer       0
9974>>>>>>>        
9974>>>>>>>    End_Procedure
9975>>>>>>>    
9975>>>>>>>    Procedure Set FieldChangedState Integer bState
9977>>>>>>>        Integer iField
9977>>>>>>>        Get Field_Number to iField
9978>>>>>>>        Delegate Set Field_Changed_state iField to bState
9980>>>>>>>    End_Procedure
9981>>>>>>>    
9981>>>>>>>    Function FieldChangedState Returns Integer
9983>>>>>>>        Integer iField  bState
9983>>>>>>>        Get Field_Number to iField
9984>>>>>>>        Delegate Get Field_Changed_state iField to bState
9986>>>>>>>        Function_Return bState
9987>>>>>>>    End_Function
9988>>>>>>>    
9988>>>>>>>    // return the field option specified
9988>>>>>>>    Function IsSaveNoPut Returns Boolean
9990>>>>>>>        Integer iField
9990>>>>>>>        Boolean  bState
9990>>>>>>>        Get Field_Number to iField
9991>>>>>>>        Delegate Get FieldSaveNoPut iField to bState
9993>>>>>>>        Function_Return bState
9994>>>>>>>    End_Function
9995>>>>>>>    
9995>>>>>>>    // for object: define file, field, fieldlength and allocate heap memory
9995>>>>>>>    //             and set memory pointer
9995>>>>>>>    Procedure DefineField Integer iFile Integer iField
9997>>>>>>>        Integer iFldLen
9997>>>>>>>        Set File_Number  to iFile
9998>>>>>>>        Set Field_Number to iField
9999>>>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iFldLen
10002>>>>>>>        Set FieldLength  to iFldLen
10003>>>>>>>    End_Procedure
10004>>>>>>>    
10004>>>>>>>    // Move from the DD Buffer to the file buffer
10004>>>>>>>    Procedure FieldUpdate Integer bSave
10006>>>>>>>        Integer iFile iField iFieldLen
10006>>>>>>>        UChar[] FieldArray
10007>>>>>>>        Integer iType
10007>>>>>>>        Boolean bNoPut
10007>>>>>>>        
10007>>>>>>>        // if bSave, part of save which means only update if changed
10007>>>>>>>        // if not bsave, part of find. You usually would not update this. You
10007>>>>>>>        // don't index on these types of fields
10007>>>>>>>        If ( (bSave and Update_Save_State(Self) and FieldChangedState(Self)) or ;            (not(bSave) and Update_Find_state(Self) ) ) Begin
10009>>>>>>>            // if save, we must respect DD_NoPut
10009>>>>>>>            If (bSave) Begin
10011>>>>>>>                // we are looking at the DD's field buffer itemoptions for, which
10011>>>>>>>                // should be set appropriately before a save. This setting has any
10011>>>>>>>                // changes made to support dd_commit
10011>>>>>>>                Get IsSaveNoPut to bNoPut
10012>>>>>>>                If bNoPut Begin
10014>>>>>>>                    Procedure_Return
10015>>>>>>>                End
10015>>>>>>>>
10015>>>>>>>            End
10015>>>>>>>>
10015>>>>>>>            Get pFieldArray to FieldArray
10016>>>>>>>            Get File_Number to iFile
10017>>>>>>>            Get Field_Number to iField
10018>>>>>>>            If iFile Begin
10020>>>>>>>                Set_Field_Value iFile iField to FieldArray // LENGTH iFieldLen
10023>>>>>>>            End
10023>>>>>>>>
10023>>>>>>>        End
10023>>>>>>>>
10023>>>>>>>    End_Procedure
10024>>>>>>>    
10024>>>>>>>    // Move from File buffer to local DD Buffer
10024>>>>>>>    // bCleared determines if this is a find or a clear.
10024>>>>>>>    // bClearFieldChange determines if we should clear the FieldChangedState.
10024>>>>>>>    Procedure FieldRefresh Boolean bCleared Boolean bClearFieldChange
10026>>>>>>>        Integer iFile iField
10026>>>>>>>        Integer bOk
10026>>>>>>>        UChar[] FieldArray
10027>>>>>>>        If (FieldRefresh_state(Self)) Begin
10029>>>>>>>            //Get FieldPointer to pField
10029>>>>>>>            Get File_Number to iFile
10030>>>>>>>            Get Field_Number to iField
10031>>>>>>>            // move from file buffer to memory pointed to by pField
10031>>>>>>>            If (iFile) Begin
10033>>>>>>>                If not bCleared Begin
10035>>>>>>>                    Get_Field_Value iFile iField to FieldArray
10038>>>>>>>                End
10038>>>>>>>>
10038>>>>>>>                Set Field_UCValue to FieldArray
10039>>>>>>>            End
10039>>>>>>>>
10039>>>>>>>        End
10039>>>>>>>>
10039>>>>>>>        If bClearFieldChange Begin
10041>>>>>>>            Set FieldChangedstate to False
10042>>>>>>>        End
10042>>>>>>>>
10042>>>>>>>    End_Procedure
10043>>>>>>>    
10043>>>>>>>    Procedure Set Field_pEntry Integer iOpts Integer iLen Integer bShowErr Address pValue
10045>>>>>>>        Integer iFile iField iFldLen iMemLen
10045>>>>>>>        Integer bChanged
10045>>>>>>>        UChar[] FieldArray
10046>>>>>>>        
10046>>>>>>>        // currently we do nothing with bShowErr because we don't checkfor errors!
10046>>>>>>>        
10046>>>>>>>        // if No-enter or Displayonly, this shouldn't be changed. For now we will
10046>>>>>>>        // let NoPut through, since a user might need it for finding.
10046>>>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
10049>>>>>>>        
10049>>>>>>>        // maybe in the future
10049>>>>>>>        // Force a caplsock if required
10049>>>>>>>        //If (iOpts IAND DD_CAPSLOCK) Move (Uppercase(sValue)) to sValue
10049>>>>>>>        
10049>>>>>>>        Get File_Number  to iFile
10050>>>>>>>        Get Field_Number to iField
10051>>>>>>>        If (iFile) Begin
10053>>>>>>>            Get Is_pValueChanged iLen pValue to bChanged
10054>>>>>>>            If ( bChanged or (iOpts iand DD_FORCEPUT) ) Begin
10056>>>>>>>                Set Field_pValue iLen to pValue
10057>>>>>>>            End
10057>>>>>>>>
10057>>>>>>>            
10057>>>>>>>            
10057>>>>>>>            // Set changed state if changed and it is not No_put. This
10057>>>>>>>            // is an improvement on DEOs which would set changed-state for
10057>>>>>>>            // a no-put. This way, finds use the changed value but saves will
10057>>>>>>>            // not trigger a phony data loss
10057>>>>>>>            //If ( bChanged ) ;
10057>>>>>>>            If ( bChanged and not(iOpts iand DD_NOPUT) ) ;                Set FieldChangedState to True
10060>>>>>>>            
10060>>>>>>>            // The following is really highly unlikely!!!
10060>>>>>>>            // perform autofinds if needed. Note that required checking will occur as
10060>>>>>>>            // part of validation.
10060>>>>>>>            // We will only autofind if the field value is changed. This is consistent with
10060>>>>>>>            // DEOs which do not autofind on unchanged values. This provides optimizations
10060>>>>>>>            // when a parent record is already loaded.
10060>>>>>>>            If (bChanged or FieldChangedState(Self)) Begin
10062>>>>>>>                If (iOpts iand DD_AUTOFIND) ;                    Delegate Send File_Field_AutoFind iFile iField EQ
10066>>>>>>>                Else If (iOpts iand DD_AUTOFIND_GE) ;                    Delegate Send File_Field_AutoFind iFile iField GE
10071>>>>>>>            End
10071>>>>>>>>
10071>>>>>>>        End
10071>>>>>>>>
10071>>>>>>>        
10071>>>>>>>    End_Procedure
10072>>>>>>>    
10072>>>>>>>    // convert pointer to UChar[]
10072>>>>>>>    Function PointerToUCharArray Address pValue Integer iLen Returns UChar[]
10074>>>>>>>        UChar[] FieldArray
10075>>>>>>>        Boolean bOk
10075>>>>>>>        Move (ResizeArray(FieldArray,iLen)) to FieldArray
10076>>>>>>>        Move (MemCopy(AddressOf(FieldArray),pValue,iLen)) to bOK
10077>>>>>>>        Function_Return FieldArray
10078>>>>>>>    End_Function
10079>>>>>>>    
10079>>>>>>>    // Raw update of pValue
10079>>>>>>>    Procedure Set Field_UCValue UChar[] FieldArray
10081>>>>>>>        Set pFieldArray to FieldArray
10082>>>>>>>        Send DestroyLegacyFieldHeap
10083>>>>>>>    End_Procedure
10084>>>>>>>    
10084>>>>>>>    // Raw update of pValue
10084>>>>>>>    Procedure Set Field_pValue Integer iLen Address pValue
10086>>>>>>>        UChar[] FieldArray
10087>>>>>>>        Get PointerToUCharArray pValue iLen to FieldArray
10088>>>>>>>        Set Field_UCValue to FieldArray
10089>>>>>>>    End_Procedure
10090>>>>>>>    
10090>>>>>>>    Function Is_pValueChanged Integer iLen Address pValue Returns Boolean
10092>>>>>>>        Boolean bChanged
10092>>>>>>>        UChar[] FieldArray
10093>>>>>>>        Integer iFldLen
10093>>>>>>>        Get pFieldArray to FieldArray
10094>>>>>>>        Move (SizeOfArray(FieldArray)) to iFldLen
10095>>>>>>>        If (iLen <> SizeOfArray(FieldArray)) Begin
10097>>>>>>>            Move True to bChanged
10098>>>>>>>        End
10098>>>>>>>>
10098>>>>>>>        Else If (iLen) Begin // check for empty pointer
10101>>>>>>>            Move (MemCompare(AddressOf(FieldArray),pValue,iLen)) to bChanged
10102>>>>>>>        End
10102>>>>>>>>
10102>>>>>>>        Function_Return bChanged
10103>>>>>>>    End_Function
10104>>>>>>>    
10104>>>>>>>    // returns data as UChar array - best way to access the data
10104>>>>>>>    Function FieldArray Returns UChar[]
10106>>>>>>>        UChar[] FieldArray
10107>>>>>>>        Get pFieldArray to FieldArray
10108>>>>>>>        Function_Return FieldArray
10109>>>>>>>    End_Function
10110>>>>>>>    
10110>>>>>>>    // legacy method. Hopefully this is never called.
10110>>>>>>>    Function FieldPointer Returns Address
10112>>>>>>>        Address pValue pOldValue
10112>>>>>>>        Integer iLen
10112>>>>>>>        UChar[] FieldArray
10113>>>>>>>        Boolean bOk
10113>>>>>>>        Get pFieldArray to FieldArray
10114>>>>>>>        Move (SizeOfArray(FieldArray)) to iLen
10115>>>>>>>        Move (Alloc(iLen)) to pValue
10116>>>>>>>        Move (MemCopy(pValue,AddressOf(FieldArray),iLen)) to bOk
10117>>>>>>>        Send DestroyLegacyFieldHeap
10118>>>>>>>        Set pLegacyFieldPointer to pValue
10119>>>>>>>        Function_Return pValue
10120>>>>>>>    End_Function
10121>>>>>>>    
10121>>>>>>>    Procedure DestroyLegacyFieldHeap
10123>>>>>>>        Integer bOK
10123>>>>>>>        Address pField
10123>>>>>>>        Get pLegacyFieldPointer to pField
10124>>>>>>>        If (pField ) Begin
10126>>>>>>>            Move (Free(pField)) to bOk
10127>>>>>>>            Set pLegacyFieldPointer to 0
10128>>>>>>>        End
10128>>>>>>>>
10128>>>>>>>    End_Procedure
10129>>>>>>>    
10129>>>>>>>    // augment to release heap allocation
10129>>>>>>>    Procedure Destroy_Object
10131>>>>>>>        Send DestroyLegacyFieldHeap
10132>>>>>>>        Forward Send Destroy_object
10134>>>>>>>    End_Procedure
10135>>>>>>>    
10135>>>>>>>End_Class
10136>>>>>>>
10136>>>>>>>// This contains all extended field objects.
10136>>>>>>>// The array contains a list of all objects where item=field#
10136>>>>>>>// and item+1=field object.
10136>>>>>>>//
10136>>>>>>>// Interface is:
10136>>>>>>>//     Get Field_object iField to hFldObj
10136>>>>>>>//     Send DefineFieldObject iField
10136>>>>>>>//     Send ExtendedFieldsUpdate bSave
10136>>>>>>>//     Send ExtendedFieldsRefresh bCleared
10136>>>>>>>//
10136>>>>>>>Class FieldObjects is an Array
10137>>>>>>>    
10137>>>>>>>    // return object Id for iField. 0 if none.
10137>>>>>>>    Function Field_Object Integer iField Returns Integer
10139>>>>>>>        Integer iItm iCnt
10139>>>>>>>        Get Item_Count to iCnt
10140>>>>>>>        Move 0 to iItm
10141>>>>>>>        While iItm lt iCnt
10145>>>>>>>            If (Value(Self,iItm)=iField) ;                Function_Return (Value(Self,iItm+1))
10148>>>>>>>            Increment iItm
10149>>>>>>>            Increment iItm
10150>>>>>>>        Loop
10151>>>>>>>>
10151>>>>>>>        Function_Return 0
10152>>>>>>>    End_Function
10153>>>>>>>    
10153>>>>>>>    // define an extended object for field
10153>>>>>>>    Procedure DefineFieldObject Integer iField
10155>>>>>>>        Integer hFld
10155>>>>>>>        Integer iCnt  iFile
10155>>>>>>>        Boolean bInUse
10155>>>>>>>        Boolean bHasRecord
10155>>>>>>>        Delegate Get Main_File to iFile
10157>>>>>>>        Get Field_Object iField to hFld // this shouldn't exist yet
10158>>>>>>>        If not hFld Begin
10160>>>>>>>            Get Create U_FieldObject to hFld
10161>>>>>>>            Send DefineField to hFld iFile iField
10162>>>>>>>            Get Item_Count to iCnt          // add to array
10163>>>>>>>            Set Value  iCnt to iField   // Pos   = field#
10164>>>>>>>            Set Value  (iCnt+1) to hFld // Pos+1 = field object
10165>>>>>>>            Delegate Get In_Use_State to bInUse
10167>>>>>>>            If bInUse Begin
10169>>>>>>>                Delegate Send Refind_Records
10171>>>>>>>                Delegate Get HasRecord to bHasRecord
10173>>>>>>>                // updating the newly created field with the file buffer contents we don't
10173>>>>>>>                // want to change the field's changed state, which might have been set already.
10173>>>>>>>                Send FieldRefresh of hFld (not(bHasRecord)) False
10174>>>>>>>            End
10174>>>>>>>>
10174>>>>>>>        End
10174>>>>>>>>
10174>>>>>>>    End_Procedure
10175>>>>>>>    
10175>>>>>>>    // update all extended fields. Field buffer <-- DD buffer
10175>>>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
10177>>>>>>>        Integer iItm iCnt
10177>>>>>>>        Get Item_Count to iCnt
10178>>>>>>>        Move 0 to iItm
10179>>>>>>>        While iItm lt iCnt
10183>>>>>>>            Increment iItm
10184>>>>>>>            Send FieldUpdate to (Value(Self,iItm)) bSave
10185>>>>>>>            Increment iItm
10186>>>>>>>        Loop
10187>>>>>>>>
10187>>>>>>>    End_Procedure
10188>>>>>>>    
10188>>>>>>>    // refresh all extended fields. Field buffer --> DD buffer
10188>>>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
10190>>>>>>>        Integer iItm iCnt
10190>>>>>>>        Get Item_Count to iCnt
10191>>>>>>>        Move 0 to iItm
10192>>>>>>>        While iItm lt iCnt
10196>>>>>>>            Increment iItm
10197>>>>>>>            Send FieldRefresh to (Value(Self,iItm)) bCleared True
10198>>>>>>>            Increment iItm
10199>>>>>>>        Loop
10200>>>>>>>>
10200>>>>>>>    End_Procedure
10201>>>>>>>    
10201>>>>>>>    //
10201>>>>>>>    // these are sent from the child field object. We need to direct them
10201>>>>>>>    // to the DDO (the parent).
10201>>>>>>>    Procedure Set Field_Changed_State Integer iField Integer bState
10203>>>>>>>        Delegate Set Field_Changed_state iField to bState
10205>>>>>>>    End_Procedure
10206>>>>>>>    
10206>>>>>>>    Function Field_Changed_State Integer iField Returns Integer
10208>>>>>>>        Integer bState
10208>>>>>>>        Delegate Get Field_Changed_state iField to bState
10210>>>>>>>        Function_Return bState
10211>>>>>>>    End_Function
10212>>>>>>>    
10212>>>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iMode
10214>>>>>>>        Delegate Send File_field_AutoFind iFile iField iMode
10216>>>>>>>    End_Procedure
10217>>>>>>>    
10217>>>>>>>    Function FieldSaveNoPut Integer iField Returns Boolean
10219>>>>>>>        Boolean bIsCommited bNoPut
10219>>>>>>>        Delegate Get IsCommitted to bIsCommited
10221>>>>>>>        // we don't know if this is foreign or not (DDOs never do by themselves). We
10221>>>>>>>        // will test for regular. This should never be an issue as the DEO itself
10221>>>>>>>        // will be DisplayOnly as needed (we don't have indexed NoEnter=T/Noput=F issues)
10221>>>>>>>        Delegate Get FieldNoPut iField bIsCommited False to bNoPut
10223>>>>>>>        Function_Return bNoPut
10224>>>>>>>    End_Function
10225>>>>>>>    
10225>>>>>>>    Procedure Destroy_Object
10227>>>>>>>        Delegate Set Field_Objects to 0
10229>>>>>>>        Forward Send Destroy_object
10231>>>>>>>    End_Procedure
10232>>>>>>>    
10232>>>>>>>    
10232>>>>>>>End_Class
10233>>>>>// for text and binary. Must support Address Type
10233>>>>>
10233>>>>>
10233>>>>>// we need these from CLI.pkg for DAW drivers. These values must match what is defined
10233>>>>>// in cli.pkg
10233>>>>>Define DF_FILE_SQL_FILTER for 611
10233>>>>>Define DF_FILE_SQL_FILTER_ACTIVE for 624
10233>>>>>Define DF_FILE_SQL_FILTER_EQ for 636
10233>>>>>// same a CLI.pkg DF_FILE_TABLE_NAME but with a different name
10233>>>>>// used to avoid naming conflict. Must match cli.pkg df_file_table_name
10233>>>>>Define DF_FILE_SQL_TABLE_NAME for 609
10233>>>>>
10233>>>>>
10233>>>>>// Class helper for SQL/driver assistance.
10233>>>>>// This can only be used within a DataDictionary Class as it expects that
10233>>>>>// certain properties can be Get and Set via delegation.
10233>>>>>Class cDAWSQLDriverHelper is a cObject
10234>>>>>    
10234>>>>>    Function DriverIndex String sDriver Returns Integer
10236>>>>>        String  sCurrentDriver
10236>>>>>        Integer iNumberOfDrivers iDriver iCount
10236>>>>>        Move 0 to iDriver
10237>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
10240>>>>>        For iCount from 1 to iNumberOfDrivers
10246>>>>>>
10246>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
10249>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
10251>>>>>                Function_Return iCount
10252>>>>>            End
10252>>>>>>
10252>>>>>        Loop
10253>>>>>>
10253>>>>>        Function_Return 0
10254>>>>>    End_Function
10255>>>>>    
10255>>>>>    
10255>>>>>    // returns true if this table supports SQL filter interface
10255>>>>>    Function SupportsSQLFilters Returns Boolean
10257>>>>>        String sDriver
10257>>>>>        Integer iFile iDriver iConformance
10257>>>>>        Delegate Get Main_File to iFile
10259>>>>>        Get_Attribute DF_FILE_DRIVER of iFile to sDriver
10262>>>>>        Get DriverIndex sDriver to iDriver
10263>>>>>        If (iDriver) Begin
10265>>>>>            Get_Attribute DF_DRIVER_CONFORMANCE of iDriver to iConformance
10268>>>>>        End
10268>>>>>>
10268>>>>>        Function_Return (iConformance iand 4)
10269>>>>>    End_Function
10270>>>>>    
10270>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
10270>>>>>    
10270>>>>>    // Escape character to escape LIKE wildcards
10270>>>>>    
10270>>>>>    
10270>>>>>    Function SQLEscapedStr String sSQL Returns String
10272>>>>>        String sEscapedSQL
10272>>>>>        // Replace one single quote by 2 single quotes
10272>>>>>        Move (Replaces("'",sSQL,"''")) to sEscapedSQL
10273>>>>>        Function_Return sEscapedSQL
10274>>>>>    End_Function
10275>>>>>    
10275>>>>>    
10275>>>>>    Function SQLEscapeLikeWildcards String sSQL Returns String
10277>>>>>        
10277>>>>>        // Escape the wildcard characters than can be used in a LIKE
10277>>>>>        If (Pos("%",sSQL)) ;            Move (Replaces("%",sSQL,(SQL_LIKE_ESC + "%"))) to sSQL
10280>>>>>        If (Pos("_",sSQL)) ;            Move (Replaces("_",sSQL,(SQL_LIKE_ESC + "_"))) to sSQL
10283>>>>>        
10283>>>>>        Function_Return sSQL
10284>>>>>    End_Function
10285>>>>>    
10285>>>>>    
10285>>>>>    
10285>>>>>    // Creates an SQL Like Filter for this field and search target
10285>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
10287>>>>>        String sFilter sOrigFilter sField
10287>>>>>        Integer iFile
10287>>>>>        Integer iHasLikeEscape
10287>>>>>        
10287>>>>>        Delegate Get Main_File to iFile
10289>>>>>        Delegate Get psSQLFilter to sOrigFilter
10291>>>>>        Get SQLStrFieldName iField to sField
10292>>>>>        Get SQLEscapedStr sSearch to sSearch
10293>>>>>        
10293>>>>>        Move (Pos(SQL_LIKE_ESC,sSearch)) to iHasLikeEscape
10294>>>>>        If (not(iHasLikeEscape)) Begin
10296>>>>>            Get SQLEscapeLikeWildcards sSearch to sSearch
10297>>>>>        End
10297>>>>>>
10297>>>>>        
10297>>>>>        Move (sField + " LIKE '%" + sSearch + "%'") to sFilter
10298>>>>>        
10298>>>>>        If (not(iHasLikeEscape)) Begin
10300>>>>>            If (Pos(SQL_LIKE_ESC,sFilter)) Begin
10302>>>>>                Move (sFilter + " ESCAPE '" + SQL_LIKE_ESC + "' "  ) to sFilter
10303>>>>>            End
10303>>>>>>
10303>>>>>        End
10303>>>>>>
10303>>>>>        
10303>>>>>        Function_Return sFilter
10304>>>>>    End_Function
10305>>>>>    
10305>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
10305>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
10307>>>>>        If (sOrigFilter<>"" and sFilter<>"") Begin
10309>>>>>            Move ( "(" + sOrigFilter + ") AND " + sFilter) to sFilter
10310>>>>>        End
10310>>>>>>
10310>>>>>        Else If (sFilter="") Begin
10313>>>>>            Move sOrigFilter to sFilter
10314>>>>>        End
10314>>>>>>
10314>>>>>        Function_Return sFilter
10315>>>>>    End_Function
10316>>>>>    
10316>>>>>    // returns the name of the File and Field suitable for an SQL where statement ("Table"."Column")
10316>>>>>    Function SQLStrFileFieldName Integer iField Returns String
10318>>>>>        String sFile sField
10318>>>>>        Integer iFile
10318>>>>>        Get Main_File to iFile
10319>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
10322>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
10325>>>>>        Function_Return ('"' + sFile + '"' + '.' + '"' + sField + '"' ) 
10326>>>>>    End_Function
10327>>>>>
10327>>>>>    // returns the name of the Field suitable for an SQL where statement ("Column")
10327>>>>>    Function SQLStrFieldName Integer iField Returns String
10329>>>>>        String sField 
10329>>>>>        Integer iFile
10329>>>>>        Get Main_File to iFile
10330>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
10333>>>>>        
10333>>>>>        Function_Return ('"' + sField + '"' ) 
10334>>>>>    End_Function
10335>>>>>
10335>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement ("Schema"."Table"."Column")
10335>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
10337>>>>>        String sFile sField sSchema
10337>>>>>        Integer iFile
10337>>>>>        Get Main_File to iFile
10338>>>>>        Get_Attribute DF_FILE_SQL_TABLE_NAME of iFile to sFile
10341>>>>>        Get_Attribute DF_FIELD_NAME of iFile iField to sField
10344>>>>>        Get_Attribute DF_FILE_OWNER of iFile iField to sSchema
10347>>>>>        
10347>>>>>        If (Trim(sSchema) <> "")
10349>>>>>            Function_Return ('"' + sSchema + '"' + '.' + '"' + sFile + '"' + '.' + '"' + sField + '"' ) 
10350>>>>>        Else
10351>>>>>            Function_Return ('"' + sFile + '"' + '.' + '"' + sField + '"' ) 
10352>>>>>    End_Function
10353>>>>>
10353>>>>>
10353>>>>>
10353>>>>>    
10353>>>>>    // called before an SQL Filter find. Make sure that any global and table attributes are
10353>>>>>    // stored.
10353>>>>>    Procedure StoreDefaultSQLFilters
10355>>>>>        String sOldFilter
10355>>>>>        Boolean bOldFilterActive bOldFilterEQ
10355>>>>>        Integer iMain
10355>>>>>        Get Main_File to iMain
10356>>>>>        Get_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
10359>>>>>        Get_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
10362>>>>>        Get_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
10365>>>>>        Delegate Set psOldFilter to sOldFilter
10367>>>>>        Delegate Set pbOldFilterActive to bOldFilterActive
10369>>>>>        Delegate Set pbOldFilterEq to bOldFilterEQ
10371>>>>>    End_Procedure
10372>>>>>    
10372>>>>>    // called after an SQL find. Must restore the global and table SQL filter attributes
10372>>>>>    Procedure RestoreDefaultSQLFilters
10374>>>>>        String sOldFilter
10374>>>>>        Boolean bOldFilterActive bOldFilterEQ
10374>>>>>        Integer iMain
10374>>>>>        Delegate Get Main_File to iMain
10376>>>>>        Delegate Get psOldFilter to sOldFilter
10378>>>>>        Delegate Get pbOldFilterActive to bOldFilterActive
10380>>>>>        Delegate Get pbOldFilterEq to bOldFilterEQ
10382>>>>>        Set_Attribute DF_FILE_SQL_FILTER of iMain to sOldFilter
10385>>>>>        Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to bOldFilterActive
10388>>>>>        Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to bOldFilterEQ
10391>>>>>    End_Procedure
10392>>>>>    
10392>>>>>    // applies the passed SQL filter. If empty, it should make sure that no filter
10392>>>>>    // is applied. If non-empty it should set the filter active, set the filter string
10392>>>>>    // and make sure this is applied to all finds (including find EQ)
10392>>>>>    Procedure ApplySQLFilterStr String sFilter
10394>>>>>        Integer iMain
10394>>>>>        Delegate Get Main_File to iMain
10396>>>>>        If (sFilter<>"") Begin
10398>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to True
10401>>>>>            Set_Attribute DF_FILE_SQL_FILTER of iMain to sFilter
10404>>>>>            Set_Attribute DF_FILE_SQL_FILTER_EQ of iMain to True
10407>>>>>        End
10407>>>>>>
10407>>>>>        Else Begin
10408>>>>>            Set_Attribute DF_FILE_SQL_FILTER_ACTIVE of iMain to False
10411>>>>>        End
10411>>>>>>
10411>>>>>    End_Procedure
10412>>>>>    
10412>>>>>End_Class
10413>>>>>
10413>>>>>// Every data_set will have a object based on this class. It will hold
10413>>>>>// the values for the fields, the entry_options and the messages IDs of the
10413>>>>>// iEntry, iExit and iValidate messages for each field.
10413>>>>>// It is assumed that an object of this class will always be used as a
10413>>>>>// child object of a Data_Set object.
10413>>>>>//
10413>>>>>// Currently the fieldtypes Overlap, Text and Binary are *not* supported.
10413>>>>>//
10413>>>>>// ITEM-PROPERTY   ASSIGNED-FUNCTION
10413>>>>>//
10413>>>>>// Value           The value of the field. Will be updated whenever the
10413>>>>>//                 value of a field changes due to data-entry or a found
10413>>>>>//                 record.
10413>>>>>// Data_File       Contains the filenumber. Is the same for every item.
10413>>>>>// Data_Field      Contains the fieldnumber for the item. Is equal to the
10413>>>>>//                 items' itemnumber.
10413>>>>>// Item_Options    Used to store the standard item-options of a field.
10413>>>>>// Aux_Value       Used to store the foreign-item-options of a field.
10413>>>>>Class cRecordBuffer is an cDDBuffer
10414>>>>>    
10414>>>>>    // This procedure will be called from the Data_Set when the Main_File is
10414>>>>>    // being set. It will create an item for each field of the file in this
10414>>>>>    // object. Fields of the types DF_OVERLAP, DF_TEXT and DF_BINARY are
10414>>>>>    // currently not added.
10414>>>>>    Procedure Create_Items Integer iFile
10416>>>>>        Integer iField_Count iField
10416>>>>>        
10416>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iField_Count
10419>>>>>        Set Main_File to iFile
10420>>>>>        Send Delete_Data
10421>>>>>        Set Item_Count to (iField_Count+1)
10422>>>>>        For iField from 0 to iField_Count
10428>>>>>>
10428>>>>>            // will skip recnum (field 0) if non-recnum table
10428>>>>>            // will set to skip if binary, text or overlap
10428>>>>>            Set Data_Field iField to iField
10429>>>>>        Loop
10430>>>>>>
10430>>>>>    End_Procedure
10431>>>>>    
10431>>>>>    // when an alias is created, we want to clear any values that will not be applied to
10431>>>>>    // this alias DD such as prompt and zoom objects (which would point to the superclass master)
10431>>>>>    Procedure ReDefineAliasItems Integer iFile
10433>>>>>        Integer i iItems
10433>>>>>        
10433>>>>>        Set Main_File to iFile
10434>>>>>        Get item_count to iItems
10435>>>>>        For i from 0 to (iItems-1)
10441>>>>>>
10441>>>>>            Set Prompt_Object i to 0
10442>>>>>            Set Zoom_Object i to 0
10443>>>>>        Loop
10444>>>>>>
10444>>>>>    End_Procedure
10445>>>>>    
10445>>>>>    
10445>>>>>    // This procedure will be called from the parent Data_Set whenever the
10445>>>>>    // Data_Set changes its Current_Record property, or after a Save, Delete
10445>>>>>    // or Clear operation.
10445>>>>>    // We use this event to store the values of the fields in our local
10445>>>>>    // record buffer.
10445>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
10447>>>>>        Integer iMain_File
10447>>>>>        Integer iOldState
10447>>>>>        tDDRemembered[] DefaultValues
10447>>>>>        tDDRemembered[] DefaultValues
10448>>>>>        Boolean bRetain bInReSync
10448>>>>>        Integer iFld iFlds iIndex
10448>>>>>        Handle hoDD
10448>>>>>        
10448>>>>>        Get Parent to hoDD
10449>>>>>        Delegate Get Main_File to iMain_File
10451>>>>>        
10451>>>>>        If not (IsNullRowId(riNew)) ;            Send Entry_Display
10454>>>>>        Else Begin
10455>>>>>            
10455>>>>>            If (OPERATION_ORIGIN) Begin
10457>>>>>                // this gets set by webapp during a resync. During resyncs you don't want to rely
10457>>>>>                // on the values in the buffers (as they may not be yours) so you cannot do retain
10457>>>>>                // of rememberlast. Fortunately, you don't need to as this information is not
10457>>>>>                // needed during a resync.
10457>>>>>                Get pbInResync of operation_origin to bInResync
10458>>>>>            End
10458>>>>>>
10458>>>>>            
10458>>>>>            // if we have any 17.0 Remember last value items, we must add those items to our array
10458>>>>>            // only do this if this is the operation origin or a parent (i.e., skip if a child DDO)
10458>>>>>            // Also skip if a resync. See above
10458>>>>>            If ( not(bInReSync) and ;                ( (Operation_Origin=hoDD) or ;                ( OPERATION_ORIGIN and (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) ) Begin
10460>>>>>                Delegate Get pDDDefaults to DefaultValues
10462>>>>>                Move (SizeOfArray(DefaultValues)) to iFlds
10463>>>>>                For iFld from 0 to (iFlds-1)
10469>>>>>>
10469>>>>>                    Move (DefaultValues[iFld].sDefault=DD_RememberLast) to bRetain // if this is a dynamically assigned remember-last
10470>>>>>// I don't think this test is needed
10470>>>>>//              // if a parent DD and not allow-foreign we want to ignore this if this is not an indexed field (for autofind)
10470>>>>>//              If ( bRetain and (Operation_Origin<>hoDD) and not(Allow_Foreign_New_Save_State(hoDD))) Begin
10470>>>>>//                 Get_Attribute DF_FIELD_INDEX of iMain_File DefaultValues[iFld].iField to iIndex
10470>>>>>//                 Move (iIndex<>0) to bRetain
10470>>>>>//              End
10470>>>>>                    If bRetain Begin
10472>>>>>                        Get Value DefaultValues[iFld].iField to DefaultValues[iFld].sLastValue
10473>>>>>                    End
10473>>>>>>
10473>>>>>                    Else Begin
10474>>>>>                        Move '' to DefaultValues[iFld].sLastValue
10475>>>>>                    End
10475>>>>>>
10475>>>>>                Loop
10476>>>>>>
10476>>>>>                Delegate Set pDDDefaults to DefaultValues
10478>>>>>            End
10478>>>>>>
10478>>>>>            
10478>>>>>            // we must do this to make retains not set changed_state
10478>>>>>            Delegate Get Change_Disabled_State to iOldState
10480>>>>>            Delegate Set Change_Disabled_State to True
10482>>>>>            // if mode is anything other than clear we do a clear all (clear keeps retains, clear all does not)
10482>>>>>            // also do clear-all if the DDO is foreign.
10482>>>>>            
10482>>>>>            // If bInReSync, we never use retains as the buffer is not ours yet.
10482>>>>>            // The Entry_Clear, Entry_Clear_All parameter is bIgnoreRetains.
10482>>>>>            // When True retain and retain_all states are ignored and cleared.
10482>>>>>            If (Operation_mode=MODE_CLEARING and ;                ( (Operation_Origin=parent(Self)) or ;                (Which_data_set(Operation_Origin,iMain_File)<>0) ) ) Begin
10484>>>>>                Send Entry_Clear bInReSync
10485>>>>>            End
10485>>>>>>
10485>>>>>            Else Begin
10486>>>>>                Send Entry_Clear_all bInResync
10487>>>>>            End
10487>>>>>>
10487>>>>>            Delegate Set Change_Disabled_State to iOldState
10489>>>>>            Set Changed_State to False
10490>>>>>        End
10490>>>>>>
10490>>>>>    End_Procedure
10491>>>>>    
10491>>>>>    // Make sure to set the Changed_State of the Data_Set to TRUE when a
10491>>>>>    // field value changes and it's not during the Setting of the Defaults.
10491>>>>>    Procedure Set Changed_State Integer iState
10493>>>>>        Integer iNoChange
10493>>>>>        // Server.pkg in dso already knows this property
10493>>>>>        Delegate Get Change_disabled_State to iNoChange
10495>>>>>        If not iNoChange Begin
10497>>>>>            Forward Set Changed_State to iState
10499>>>>>            Delegate Set Changed_State to iState
10501>>>>>        End
10501>>>>>>
10501>>>>>    End_Procedure
10502>>>>>    
10502>>>>>End_Class
10503>>>>>
10503>>>>>
10503>>>>>// Objects of this class will be used to store all kinds of attributes
10503>>>>>// which belong to a field.
10503>>>>>//
10503>>>>>// FA_MIN_VALUE
10503>>>>>// Used to store the mininum value of field.
10503>>>>>//
10503>>>>>// FA_MAX_VALUE
10503>>>>>// Used to store the maximum value of a field.
10503>>>>>//
10503>>>>>// FA_CHECK_VALUE
10503>>>>>// Used to store a string which contains all possible values of a field.
10503>>>>>//
10503>>>>>// FA_CHECKBOX_TRUE
10503>>>>>// Used to store the TRUE value for a checkbox field
10503>>>>>//
10503>>>>>// FA_CHECKBOX_FALSE
10503>>>>>// Used to store the FALSE value of a checkbox field
10503>>>>>//
10503>>>>>// FA_TABLE_OBJECT
10503>>>>>// Stores object Id of a validation table.
10503>>>>>//
10503>>>>>// FA_ERROR_MESSAGE
10503>>>>>// Used to store a error text which will be shown to a user when a fields
10503>>>>>// value violates one of the rules defined for it.
10503>>>>>// This field may contain the special strings @MIN, @MAX and @CHECK. When
10503>>>>>// these are used, these will be replaced by the actual value of MIN_VALUE,
10503>>>>>// MAX_VALUE or CHECK_VALUE.
10503>>>>>//
10503>>>>>
10503>>>>>
10503>>>>>// Validation Types
10503>>>>>Enumeration_List
10503>>>>>    Define FA_VALIDATION_TYPE_NONE
10503>>>>>    Define FA_VALIDATION_TYPE_RANGE
10503>>>>>    Define FA_VALIDATION_TYPE_CHECK
10503>>>>>    Define FA_VALIDATION_TYPE_CHECKBOX
10503>>>>>    Define FA_VALIDATION_TYPE_TABLE
10503>>>>>End_Enumeration_List
10503>>>>>
10503>>>>>
10503>>>>>Class Field_Attributes is a Array
10504>>>>>    
10504>>>>>    Procedure Construct_Object
10506>>>>>        Forward Send Construct_Object
10508>>>>>        // Private: This replaces the use of arrays to get at this value. This
10508>>>>>        // allows us to find specific validation types (like checkboxes) more
10508>>>>>        // quickly than scanning an array
10508>>>>>        Property String Private.Validation_Types     ''
10509>>>>>    End_Procedure
10510>>>>>    
10510>>>>>    // Returns the extended validation type for the passed field.
10510>>>>>    Function Field_Validation_Type Integer iField Returns Integer
10512>>>>>        Integer iType
10512>>>>>        If iField ;            Move (mid(Private.Validation_Types(Self),1,iField)) to iType
10515>>>>>        Else ;            Move FA_VALIDATION_TYPE_NONE to iType
10517>>>>>        Function_Return iType
10518>>>>>    End_Function
10519>>>>>    
10519>>>>>    Procedure Set Field_Validation_Type Integer iField String sType
10521>>>>>        Integer iType
10521>>>>>        String sTypes
10521>>>>>        If iField Begin
10523>>>>>            Get Private.Validation_Types to sTypes
10524>>>>>            Set Private.Validation_Types to (Overstrike(sType, sTypes, iField))
10525>>>>>        End
10525>>>>>>
10525>>>>>    End_Procedure
10526>>>>>    
10526>>>>>    // Set any defaults required by this class when the main file is created.
10526>>>>>    // Create a string which contains all validation types. Set all to
10526>>>>>    // No extended validation type.
10526>>>>>    Procedure Create_Items
10528>>>>>        String  sType
10528>>>>>        Integer iCount
10528>>>>>        Delegate Get Field_Count to iCOunt
10530>>>>>        Move FA_VALIDATION_TYPE_NONE to sType
10531>>>>>        Set Private.Validation_Types to (Repeat(sType,iCount))
10532>>>>>    End_Procedure
10533>>>>>    
10533>>>>>    // Return field number of next field matching the passed validation type.
10533>>>>>    // Pass validation type and last position checked. Return 0 if no match
10533>>>>>    Function Next_Validation_Type String sType Integer iOffset Returns Integer
10535>>>>>        String sTypes
10535>>>>>        Integer iPos
10535>>>>>        Get Private.Validation_Types to sTypes
10536>>>>>        Move (Pos(sType, mid(sTypes,255,iOffset+1))) to iPos
10537>>>>>        If iPos ;            Add iOffset to iPos
10540>>>>>        Function_Return iPos
10541>>>>>    End_Function
10542>>>>>    
10542>>>>>    // This procedure will be called by the Extended_Data_Set to set the
10542>>>>>    // errornumber and message which will be triggered when it needs to.
10542>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
10544>>>>>        Integer iBase
10544>>>>>        Move (iField * FA_COUNT) to iBase
10545>>>>>        Set Value (iBase + FA_ERROR_NUMBER) to iErr
10546>>>>>        Set Value (iBase + FA_ERROR_MESSAGE) to sMsg
10547>>>>>    End_Procedure
10548>>>>>    
10548>>>>>    // Used to retreive the error number and message for a particular field
10548>>>>>    Function Field_Error_Number Integer iField Returns Integer
10550>>>>>        Integer iErr
10550>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_NUMBER)  to iErr
10551>>>>>        Function_Return iErr
10552>>>>>    End_Function
10553>>>>>    
10553>>>>>    Function Field_Error_Message Integer iField Returns String
10555>>>>>        String sValue
10555>>>>>        Get Value (iField*FA_COUNT + FA_ERROR_MESSAGE) to sValue
10556>>>>>        Function_Return sValue
10557>>>>>    End_Function
10558>>>>>    
10558>>>>>    
10558>>>>>    // This function manages the validation of a field against its extended
10558>>>>>    // validations.
10558>>>>>    Function Validate_Field Integer iField Returns Integer
10560>>>>>        Integer iType
10560>>>>>        Integer iResult
10560>>>>>        Get Field_Validation_Type iField to iType
10561>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Get Validate_Field_Range iField to iResult
10564>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Get Validate_Field_Check iField to iResult
10568>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Get Validate_Field_Checkbox iField to iResult
10572>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Validate_Field_Table iField to iResult
10576>>>>>        Function_Return iResult
10577>>>>>    End_Function
10578>>>>>    
10578>>>>>    // All extended validations know how to send callback messages (iMsg) to
10578>>>>>    // the calling object (iObj). This allows external lists to get filled w/
10578>>>>>    // the contents of a range. Used by combo boxes, spinners, etc.
10578>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
10580>>>>>        Integer iType
10580>>>>>        Integer iResult
10580>>>>>        Get Field_Validation_Type iField to iType
10581>>>>>        If (iType = FA_VALIDATION_TYPE_RANGE) ;            Send Field_Fill_List_Field_Range iField iObj iMsg
10584>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECK) ;            Send Field_Fill_List_Field_Check iField iObj iMsg
10588>>>>>        Else If (iType = FA_VALIDATION_TYPE_CHECKBOX) ;            Send Field_Fill_List_Field_Checkbox iField iObj iMsg
10592>>>>>        Else If (iType = FA_VALIDATION_TYPE_TABLE) ;            Send Field_Fill_List_Field_Table iField iObj iMsg
10596>>>>>    End_Procedure
10597>>>>>    
10597>>>>>    // Return the id of the validation table if one exists. Otherwise return
10597>>>>>    // a zero.
10597>>>>>    Function Field_Table_Object Integer iField Returns Integer
10599>>>>>        Integer iType
10599>>>>>        Integer iObj
10599>>>>>        Integer iBase
10599>>>>>        Move (iField * FA_COUNT) to iBase
10600>>>>>        Get Field_Validation_Type iField to iType
10601>>>>>        If (iType = FA_VALIDATION_TYPE_TABLE) ;            Get Value (iBase + FA_TABLE_OBJECT) to iObj
10604>>>>>        Function_Return iObj
10605>>>>>    End_Function
10606>>>>>    
10606>>>>>    // Procedure to set the range for a field. It will automatically set the
10606>>>>>    // validation type of the field as well.
10606>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
10608>>>>>        Integer iBase
10608>>>>>        Move (iField * FA_COUNT) to iBase
10609>>>>>        Set Value (iBase + FA_MIN_VALUE) to sMin
10610>>>>>        Set Value (iBase + FA_MAX_VALUE) to sMax
10611>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_RANGE
10612>>>>>    End_Procedure
10613>>>>>    
10613>>>>>    // Function to check a fields value agains a given check string.
10613>>>>>    Function Validate_Field_Range Integer iField Returns Integer
10615>>>>>        String  sMin
10615>>>>>        String  sMax
10615>>>>>        String  sValue
10615>>>>>        Integer iField_Type
10615>>>>>        Integer iResult
10615>>>>>        Integer iFile
10615>>>>>        Integer iBase
10615>>>>>        Move (iField * FA_COUNT) to iBase
10616>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
10617>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
10618>>>>>        Delegate Get Field_Current_Value iField to sValue
10620>>>>>        Delegate Get Main_File to iFile
10622>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
10625>>>>>        Move 0 to iResult
10626>>>>>        If (iField_Type=DF_ASCII) ;            Move (sValue < sMin or sValue > sMax) to iResult
10629>>>>>        Else If (iField_Type=DF_BCD) ;            Move (Number(sValue) < Number(sMin) or ;            Number(sValue) > Number(sMax)) to iResult
10633>>>>>        Else If (iField_Type=DF_DATE) ;            Move (Date(sValue) < Date(sMin) or Date(sValue) > Date(sMax)) to iResult
10637>>>>>        Else If (iField_Type=DF_DATETIME) ;            Move (Cast(sValue,DateTime) < Cast(sMin,DateTime) or Cast(sValue,DateTime) > Cast(sMax,DateTime)) to iResult
10641>>>>>        If iResult Begin
10643>>>>>            Delegate Send Field_Error iField DD_INVALID_RANGE sMin sMax
10645>>>>>            Function_Return 1
10646>>>>>        End
10646>>>>>>
10646>>>>>    End_Function
10647>>>>>    
10647>>>>>    // Callback to provide all valid value for this validation.
10647>>>>>    // Just call back with the two range values
10647>>>>>    Procedure Field_Fill_List_Field_Range Integer iField Integer iObj Integer iMsg
10649>>>>>        String  sMin
10649>>>>>        String  sMax
10649>>>>>        Integer iBase
10649>>>>>        Move (iField * FA_COUNT) to iBase
10650>>>>>        Get Value (iBase + FA_MIN_VALUE) to sMin
10651>>>>>        Get Value (iBase + FA_MAX_VALUE) to sMax
10652>>>>>        Send iMsg to iObj 0 sMin '' 0 (NullrowId())
10653>>>>>        Send iMsg to iObj 1 sMax '' 0 (NullrowId())
10654>>>>>    End_Procedure
10655>>>>>    
10655>>>>>    // Procedure to set the check for a field. It will automatically set the
10655>>>>>    // validation type of the field as well.
10655>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
10657>>>>>        Integer iBase
10657>>>>>        Move (iField * FA_COUNT) to iBase
10658>>>>>        Set Value (iBase + FA_CHECK_VALUE) to sCheck
10659>>>>>        //Set Value iBase to FA_VALIDATION_TYPE_CHECK
10659>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECK
10660>>>>>    End_Procedure
10661>>>>>    
10661>>>>>    // Function to check a fields value agains a given check string.
10661>>>>>    Function Validate_Field_Check Integer iField Returns Integer
10663>>>>>        String  sCheck
10663>>>>>        String  sValue
10663>>>>>        Integer iBase
10663>>>>>        Integer iPos
10663>>>>>        Integer iLength
10663>>>>>        Integer iResult
10663>>>>>        Integer iFile
10663>>>>>        Move (iField * FA_COUNT) to iBase
10664>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
10665>>>>>        Delegate Get Field_Current_Value iField to sValue
10667>>>>>        Delegate Get Main_File to iFile
10669>>>>>        Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
10672>>>>>        Move (Pad( sValue,iLength)) to sValue
10673>>>>>        // Replace the seperation characters with two of them so the user
10673>>>>>        // can't bypass the check by entering a seperation character.
10673>>>>>        Move (Replaces("|", sValue, "||")) to sValue
10674>>>>>        // Report an error if rules are violated.
10674>>>>>        Move (Pos( sValue, sCheck)) to iPos
10675>>>>>        If not iPos Begin
10677>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECK sCheck
10679>>>>>            Function_Return 1
10680>>>>>        End
10680>>>>>>
10680>>>>>    End_Function
10681>>>>>    
10681>>>>>    // Callback to provide all valid value for this validation.
10681>>>>>    // Call back with all valid check values
10681>>>>>    Procedure Field_Fill_List_Field_Check Integer iField Integer iObj Integer iMsg
10683>>>>>        String  sCheck
10683>>>>>        Integer iBase
10683>>>>>        Integer iPos
10683>>>>>        Integer iItem
10683>>>>>        Move (iField * FA_COUNT) to iBase
10684>>>>>        Get Value (iBase + FA_CHECK_VALUE) to sCheck
10685>>>>>        Append sCheck "|"
10686>>>>>        Move (Pos( "|", sCheck)) to iPos
10687>>>>>        While iPos
10691>>>>>            If (iPos > 1) Begin
10693>>>>>                Send iMsg to iObj iItem (Left(sCheck,iPos-1)) '' 0 (NullrowId())
10694>>>>>                Increment iItem
10695>>>>>            End
10695>>>>>>
10695>>>>>            Move (Mid( sCheck, 255, iPos+1))  to sCheck
10696>>>>>            Move (Pos( "|", sCheck)) to iPos
10697>>>>>        Loop
10698>>>>>>
10698>>>>>    End_Procedure
10699>>>>>    
10699>>>>>    // Procedure to set up a checkbox field. We will store the TRUE and FALSE
10699>>>>>    // Values in the extended array.
10699>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
10701>>>>>        Integer iBase
10701>>>>>        Move (iField * FA_COUNT) to iBase
10702>>>>>        Set Value (iBase + FA_CHECKBOX_TRUE) to sTrue
10703>>>>>        Set Value (iBase + FA_CHECKBOX_FALSE) to sFalse
10704>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_CHECKBOX
10705>>>>>    End_Procedure
10706>>>>>    
10706>>>>>    // Return the Value associated with the field and its select-state.
10706>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
10708>>>>>        Integer iBase
10708>>>>>        Integer iType
10708>>>>>        String sValue
10708>>>>>        Move (iField * FA_COUNT) to iBase
10709>>>>>        Get Field_Validation_Type iField to iType
10710>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move iState to sValue
10713>>>>>        Else ;            Get Value (iBase + If(iState,FA_CHECKBOX_TRUE,FA_CHECKBOX_FALSE));            to sValue
10715>>>>>        Function_Return sValue
10716>>>>>    End_Function
10717>>>>>    
10717>>>>>    // Return the select_state based on the passed value and field
10717>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
10719>>>>>        Integer iBase
10719>>>>>        Integer iType
10719>>>>>        String  sTrue
10719>>>>>        Integer iState
10719>>>>>        Integer iFile
10719>>>>>        Integer iField_Type
10719>>>>>        Move (iField * FA_COUNT) to iBase
10720>>>>>        Get Field_Validation_Type iField to iType
10721>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
10722>>>>>        If (iType <> FA_VALIDATION_TYPE_CHECKBOX) ;            Move (not(sValue=0 or sValue='')) to iState
10725>>>>>        Else Begin
10726>>>>>            Delegate Get Main_File to iFile
10728>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
10731>>>>>            If (iField_Type = DF_BCD) ;                Move (Number(sValue)=Number(sTrue)) to iState
10734>>>>>            Else ; // DF_ASCII                Move (sValue=sTrue) to iState
10736>>>>>        End
10736>>>>>>
10736>>>>>        Function_Return iState
10737>>>>>    End_Function
10738>>>>>    
10738>>>>>    
10738>>>>>    // Check that the buffer value is one of the two checkbox values.
10738>>>>>    Function Validate_Field_Checkbox Integer iField Returns Integer
10740>>>>>        String  sTrue
10740>>>>>        String  sFalse
10740>>>>>        String  sValue
10740>>>>>        Integer iField_Type
10740>>>>>        Integer iResult
10740>>>>>        Integer iFile
10740>>>>>        Integer iBase
10740>>>>>        Move (iField * FA_COUNT) to iBase
10741>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
10742>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
10743>>>>>        Delegate Get Field_Current_Value iField to sValue
10745>>>>>        Delegate Get Main_File to iFile
10747>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iField_Type
10750>>>>>        Move 0 to iResult
10751>>>>>        If (iField_Type = DF_BCD) ;            Move (Number(sValue)=Number(sTrue) or ;            Number(sValue)=Number(sFalse)) to iResult
10754>>>>>        Else ; // DF_ASCII            Move (sValue=sTrue or sValue=sFalse) to iResult
10756>>>>>        If not iResult Begin
10758>>>>>            Delegate Send Field_Error iField DD_INVALID_CHECKBOX sTrue sFalse
10760>>>>>            Function_Return 1
10761>>>>>        End
10761>>>>>>
10761>>>>>    End_Function
10762>>>>>    
10762>>>>>    // Callback to provide all valid value for this validation.
10762>>>>>    // Just call back with the two true and false values
10762>>>>>    Procedure Field_Fill_List_Field_Checkbox Integer iField Integer iObj Integer iMsg
10764>>>>>        String  sTrue
10764>>>>>        String  sFalse
10764>>>>>        Integer iBase
10764>>>>>        Move (iField * FA_COUNT) to iBase
10765>>>>>        Get Value (iBase + FA_CHECKBOX_TRUE) to sTrue
10766>>>>>        Get Value (iBase + FA_CHECKBOX_FALSE) to sFalse
10767>>>>>        Send iMsg to iObj 0 sTrue '' 0 (NullrowId())
10768>>>>>        Send iMsg to iObj 1 sFalse '' 0 (NullrowId())
10769>>>>>    End_Procedure
10770>>>>>    
10770>>>>>    // The object keeps track of a validation table object. This table object
10770>>>>>    // can be any type of object must at a minimum understand a small message
10770>>>>>    // protocol (see xvaltbl.pkg for info)
10770>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
10772>>>>>        Integer iBase
10772>>>>>        Move (iField * FA_COUNT) to iBase
10773>>>>>        Set Value (iBase + FA_TABLE_OBJECT) to iObj
10774>>>>>        Set Field_Validation_Type iField to FA_VALIDATION_TYPE_TABLE
10775>>>>>    End_Procedure
10776>>>>>    
10776>>>>>    // This valdates against a validation table if appropriate (if a table
10776>>>>>    // exists and the table's validate_State is T). It validates by passing
10776>>>>>    // the message validate_value to the validation table object
10776>>>>>    Function Validate_Field_Table Integer iField Returns Integer
10778>>>>>        Integer iBase
10778>>>>>        Integer iTableObj
10778>>>>>        String  sValue
10778>>>>>        Integer iResult
10778>>>>>        Move (iField * FA_COUNT) to iBase
10779>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
10780>>>>>        If (iTableObj and Validate_State(iTableObj) ) Begin
10782>>>>>            Delegate Get Field_Current_Value iField to sValue
10784>>>>>            Get Validate_Value of iTableOBj sValue to iResult
10785>>>>>            If iResult ;                Delegate Send Field_Error iField DD_INVALID_VALUE_TABLE
10789>>>>>        End
10789>>>>>>
10789>>>>>        Function_Return iResult
10790>>>>>    End_Function
10791>>>>>    
10791>>>>>    // Callback to provide all valid value for this validation.
10791>>>>>    // Pass the request on to the validation table. This is the most common
10791>>>>>    // use of this.
10791>>>>>    Procedure Field_Fill_List_Field_Table Integer iField Integer iObj Integer iMsg
10793>>>>>        Integer iBase
10793>>>>>        Integer iTableObj
10793>>>>>        Move (iField * FA_COUNT) to iBase
10794>>>>>        Get Value (iBase + FA_TABLE_OBJECT) to iTableObj
10795>>>>>        If iTableObj ;            Send Request_Fill_From_List to iTableObj iObj iMsg
10798>>>>>    End_Procedure
10799>>>>>    
10799>>>>>    // Often extended valditation types can provide automatic prompt
10799>>>>>    // objects. If the extended type supports a prompt object and there is
10799>>>>>    // a global validation_list object, we will use it
10799>>>>>    Function Prompt_Object Integer iField Returns Integer
10801>>>>>        Integer iType
10801>>>>>        Integer iObj
10801>>>>>        Get Field_Validation_Type iField to iType
10802>>>>>        If not (iType=FA_VALIDATION_TYPE_NONE or iType=FA_VALIDATION_TYPE_RANGE) ;            Move DD_Global_Validation_Prompt_Object to iObj
10805>>>>>        Function_Return iObj
10806>>>>>    End_Function
10807>>>>>    
10807>>>>>    
10807>>>>>End_Class
10808>>>>>
10808>>>>>
10808>>>>>
10808>>>>>// use to keep track of file field pairs such as system file file/field
10808>>>>>Struct tDDFileField
10808>>>>>    Integer iFile
10808>>>>>    Integer iField
10808>>>>>End_Struct
10808>>>>>
10808>>>>>Class Field_Mask_Array is an Array
10809>>>>>    
10809>>>>>    Function Array_Name Integer iField Integer iType Returns String
10811>>>>>        String sName
10811>>>>>        Move (iField*FMA_COUNT+iType) to iField
10812>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to sName
10815>>>>>        // sometimes an array value that is undefined returns a 0, we must change this to ''
10815>>>>>        If (sName = '0') ;            Move '' to sName
10818>>>>>        Function_Return sName
10819>>>>>    End_Function
10820>>>>>    
10820>>>>>    
10820>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
10822>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_TYPE) to iType
10823>>>>>    End_Procedure
10824>>>>>    
10824>>>>>    Function Field_Mask_Type Integer iField Returns Integer
10826>>>>>        Integer iType
10826>>>>>        Move (iField*FMA_COUNT+FMA_MASK_TYPE) to iField
10827>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iType
10830>>>>>        Function_Return iType
10831>>>>>    End_Function
10832>>>>>    
10832>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
10834>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iState
10835>>>>>    End_Procedure
10836>>>>>    
10836>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
10838>>>>>        Integer iState
10838>>>>>        Move (iField*FMA_COUNT+FMA_MASK_VALUE_STATE) to iField
10839>>>>>        If (Item_Count(Self)>iField) ;            Get value iField to iState
10842>>>>>        Function_Return iState
10843>>>>>    End_Function
10844>>>>>    
10844>>>>>    Procedure Set Field_Mask Integer iField String sMask
10846>>>>>        Set Value (iField*FMA_COUNT+FMA_MASK) to sMask
10847>>>>>    End_Procedure
10848>>>>>    
10848>>>>>    Function Field_Mask Integer iField Returns String
10850>>>>>        Function_Return (Array_Name(Self,iField,FMA_MASK))
10851>>>>>    End_Function
10852>>>>>    
10852>>>>>    Procedure Set Field_Label_Short Integer iField String sName
10854>>>>>        Set Value (iField*FMA_COUNT+FMA_SHORT_NAME) to sName
10855>>>>>    End_Procedure
10856>>>>>    
10856>>>>>    Function Field_Label_Short Integer iField Returns String
10858>>>>>        Function_Return (Array_Name(Self,iField,FMA_SHORT_NAME))
10859>>>>>    End_Function
10860>>>>>    
10860>>>>>    Procedure Set Field_Label_Long Integer iField String sName
10862>>>>>        Set Value (iField*FMA_COUNT+FMA_LONG_NAME) to sName
10863>>>>>    End_Procedure
10864>>>>>    
10864>>>>>    Function Field_Label_Long Integer iField Returns String
10866>>>>>        Function_Return (Array_Name(Self,iField,FMA_LONG_NAME))
10867>>>>>    End_Function
10868>>>>>    
10868>>>>>    Procedure Set Field_Class_Name Integer iField String sName
10870>>>>>        Set Value (iField*FMA_COUNT+FMA_CLASS_NAME) to sName
10871>>>>>    End_Procedure
10872>>>>>    
10872>>>>>    Function Field_Class_Name Integer iField Returns String
10874>>>>>        Function_Return (Array_Name(Self,iField,FMA_CLASS_NAME))
10875>>>>>    End_Function
10876>>>>>    
10876>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoPrompt
10878>>>>>        Set Value (iField*FMA_COUNT+FMA_WEBPROMPTOBJECT) to hoPrompt
10879>>>>>    End_Procedure
10880>>>>>    
10880>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
10882>>>>>        Function_Return (Array_Name(Self,iField,FMA_WEBPROMPTOBJECT))
10883>>>>>    End_Function
10884>>>>>    
10884>>>>>End_Class
10885>>>>>
10885>>>>>Class DataDictionary is a DataSet
10886>>>>>    
10886>>>>>    Procedure Construct_Object
10888>>>>>        Forward Send Construct_Object
10890>>>>>        
10890>>>>>        Property String  Existing_Key_Value                           ""
10891>>>>>        Property Integer Protect_Key_State                            True
10892>>>>>        
10892>>>>>        Property String  Key_Fields                                   ""
10893>>>>>        
10893>>>>>        // These are added to support the checking of DSO connections
10893>>>>>        // during deletes and saves. Only the first two properties are Public
10893>>>>>        Property Integer Validate_Save_Structure_Mode   DD_Validate_Structure_Once
10894>>>>>        Property Integer Validate_Delete_Structure_Mode DD_Validate_Structure_Once
10895>>>>>        Property Integer Save_Structure_Validated_State              False
10896>>>>>        Property Integer Cascade_Delete_Structure_Validated_State    False
10897>>>>>        Property Integer No_Cascade_Delete_Structure_Validated_State False
10898>>>>>        
10898>>>>>        Property Integer Last_Mark_Sequence_Id                       0
10899>>>>>        
10899>>>>>        // These are added for optimized traversal of
10899>>>>>        // entry-update and validation and maybe more
10899>>>>>        Property String  Visited_Fields          ""
10900>>>>>        Property Integer Visited_State           False
10901>>>>>        // means will be part of a downward delete (cascade deletable). This only has meaning
10901>>>>>        // when cascade_delete_state is True
10901>>>>>        Property Boolean DownDelete_State        False
10902>>>>>        
10902>>>>>        // these are set by the define_auto_increment, which is obsolete and has been replaced
10902>>>>>        // the Set Field_auto_increment method.
10902>>>>>        Property Integer Auto_Increment_Source_File  0
10903>>>>>        Property Integer Auto_Increment_Source_Field 0
10904>>>>>        Property Integer Auto_Increment_Dest_Field   0
10905>>>>>        
10905>>>>>        // used by the set Field_auto_increment method
10905>>>>>        // these are split into two arrays to make searching for the field easier
10905>>>>>        // the arrays should always be synched.
10905>>>>>        Property Integer[] pAutoIncrementFields
10906>>>>>        Property tDDFileField[] pAutoIncrementSysFileFields
10907>>>>>        
10907>>>>>        // Error Reporting Related
10907>>>>>        // If DD_Error_No_Report errors would be supressed (only ERR gets set)
10907>>>>>        Property Integer Error_Report_Mode           DD_Error_Report
10908>>>>>        
10908>>>>>        // During validation, this is the field being validated.
10908>>>>>        Property Integer Current_Validate_Field      0
10909>>>>>        
10909>>>>>        // when errors are redirected locally this maintains the original handler.
10909>>>>>        Property Integer Old_Error_Object_Id         0
10910>>>>>        
10910>>>>>        // Must be provided if local error handler is to be created
10910>>>>>        Property Integer Error_Processing_State      0
10911>>>>>        
10911>>>>>        // These should be changed most carefully and possible only and the
10911>>>>>        // DSO level. These allow you to defeat full field validation which
10911>>>>>        // makes it easier to corrupt data! Validate_DEO_Only_State limits
10911>>>>>        // save validation to DEOs (which is what data-sets have always done).
10911>>>>>        // Validate_foreign_File_State will skip validation under the following
10911>>>>>        // conditions: 1) DSO if for a parent (it did not originate the save).
10911>>>>>        //
10911>>>>>        Property Integer Validate_DEOs_Only_State    False
10912>>>>>        Property Integer Validate_Foreign_File_State True
10913>>>>>        // if set true, a field validation requested started with this
10913>>>>>        // DD will check all fields, even in an error is encountered
10913>>>>>        Property Integer Validate_All_Fields_State   False
10914>>>>>        
10914>>>>>        // If true, all entry updates will occur through the DD. Else
10914>>>>>        // saves occur through the DD and find occur through the DEOs
10914>>>>>        Property Integer EntryUpdateLocalState True // changed from false to true in 17.0
10915>>>>>        
10915>>>>>        // can be used by Refind_records method (remote refind of recs). Obsolete. Use Find_RowId
10915>>>>>        Property Integer Find_Record_Id 0
10916>>>>>        
10916>>>>>        // can be used by Refind_records method (remote refind of recs)
10916>>>>>        Property RowID Find_RowId (NullRowId())
10917>>>>>        // can be used by Refind_records method (remote refind of recs)
10917>>>>>        Property tDDChangedInfo pDDChangedInfo
10918>>>>>        
10918>>>>>        // Private: Id of field_objects container. This is not created until needed
10918>>>>>        Property Integer Field_Objects 0
10919>>>>>        
10919>>>>>        // Public: If set the DDO will never be foreign, allowing
10919>>>>>        // you to create new parents when a child is saved. This would
10919>>>>>        // normally only be set within the DDO and not the class. This would be
10919>>>>>        // used where a child table wants to save the parent (header) when the
10919>>>>>        // first child is saved. It would disable the foreign key and index
10919>>>>>        // find_Req and required settings (as well as any displayonly).
10919>>>>>        Property Integer Allow_Foreign_New_Save_State False
10920>>>>>        
10920>>>>>        Set pbDDAttach to True // set false to get (very) old attach_main_file_behavior
10921>>>>>        Set pbSmartRelate to True // Only relate if parent is attached via a DDO
10922>>>>>        
10922>>>>>        // If this is an alias file, this is the master file it is based on
10922>>>>>        Property Handle piMasterTable 0
10923>>>>>        
10923>>>>>        Property tDDServerInformation[] pServerInformation
10924>>>>>        
10924>>>>>        Property tDDRemembered[] pDDDefaults
10925>>>>>        
10925>>>>>        Property Boolean pbInSuperFind False
10926>>>>>        
10926>>>>>        // Create the local buffer.
10926>>>>>        Object Record_Buffer is a cRecordBuffer
10928>>>>>        End_Object
10929>>>>>        
10929>>>>>        // Create the extended field attributes array.
10929>>>>>        Object Field_Attributes is a Field_Attributes
10931>>>>>        End_Object
10932>>>>>        
10932>>>>>        // Create an array to maintain Status help values for each field
10932>>>>>        Object Statushelp_Array is an array
10934>>>>>        End_Object
10935>>>>>        
10935>>>>>        Object FieldMask_Array is an Field_Mask_array
10937>>>>>        End_Object
10938>>>>>        
10938>>>>>        
10938>>>>>        // keep track of all system/unknown files that must be set to
10938>>>>>        // default for smart file mode to work right.
10938>>>>>        Object System_File_obj is an Array
10940>>>>>        End_Object
10941>>>>>        
10941>>>>>        // used during Request_Validate
10941>>>>>        Property Handle[] pDDsWithFindReqErrors
10942>>>>>        
10942>>>>>        // Apply SQL filters in constrained finds
10942>>>>>        Property Boolean pbUseDDSQLFilters False
10943>>>>>        // If pbUseDDSQLFilters is true, this determines if the table global filter should be applied as well
10943>>>>>        Property Boolean pbApplyGlobalSQLFilters False
10944>>>>>        // Filter which will get applied before each DDO constrained find. If "", no filter is applied
10944>>>>>        Property String psSQLFilter ""
10945>>>>>        
10945>>>>>        // Old values for SQL Filters which are pushed and popped by StoreSQLDefaultFilters and RestoreSQLDefaultFilters
10945>>>>>        Property String psOldFilter ""
10946>>>>>        Property Boolean pbOldFilterActive
10947>>>>>        Property Boolean pbOldFilterEq
10948>>>>>        
10948>>>>>        // used to point to the composite child object that provides the SQL
10948>>>>>        // interfaces for a driver. This can be used with DAW drivers. Other drivers may require
10948>>>>>        // that you sub-class your DD and create a different object based on a custom class
10948>>>>>        Property Handle phoSQLHelper (Create(Self,RefClass(cDAWSQLDriverHelper)))
10949>>>>>        
10949>>>>>        
10949>>>>>        Property Handle pbInResync False
10950>>>>>        
10950>>>>>        Property Integer piPrimaryIndex -1      // Indicates the unique index used by the webapp view state system (-1 defaults to the primary key or recnum for embedded).
10951>>>>>        
10951>>>>>        Set Smart_FileMode_State to True  // extended DSOs should default to true
10952>>>>>        
10952>>>>>        Send Define_Fields // Developer Hook - define all field rules
10953>>>>>    End_Procedure
10954>>>>>    
10954>>>>>    // Returns 1 to indicate that this is a DD class.
10954>>>>>    Function Extended_DSO_State Returns Integer
10956>>>>>        Function_Return 1
10957>>>>>    End_Function
10958>>>>>    
10958>>>>>    
10958>>>>>    // Used to set up all XDS functions and rules. Called by construct_object
10958>>>>>    // and considered a bit more user friendly.
10958>>>>>    Procedure Define_Fields
10960>>>>>    End_Procedure
10961>>>>>    
10961>>>>>    
10961>>>>>    
10961>>>>>    // This message has been augmented to create a local recordbuffer for a
10961>>>>>    // file. We cannot do this earlier because we need the file to count the
10961>>>>>    // number of necessary fields.
10961>>>>>    Procedure Set Main_File Integer iFile
10963>>>>>        Integer iCurrent_File iMaster
10963>>>>>        Get piMasterTable to iMaster
10964>>>>>        If iMaster Begin
10966>>>>>            // is an alias condition
10966>>>>>            Forward Set Main_File to iFile
10968>>>>>            Send ReDefineAliasItems to (Record_Buffer(Self)) iFile
10969>>>>>        End
10969>>>>>>
10969>>>>>        Else If iFile Begin
10972>>>>>            Get Main_File to iCurrent_File
10973>>>>>            If (iCurrent_File and iCurrent_File <> iFile) Begin
10975>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_CANNOT_CHANGE_MAIN_FILE
10976>>>>>                Procedure_Return
10977>>>>>            End
10977>>>>>>
10977>>>>>            Forward Set Main_File to iFile
10979>>>>>            Send Create_Items to (Record_Buffer(Self)) iFile
10980>>>>>            Send Create_Items to (Field_Attributes(Self))
10981>>>>>        End
10981>>>>>>
10981>>>>>    End_Procedure
10982>>>>>    
10982>>>>>    // This procedure will update the Key_Fields property to include or
10982>>>>>    // excluded the fieldnumber passed in the list of fieldnumbers which make
10982>>>>>    // up an keyvalue.
10982>>>>>    Procedure Set Key_Field_State Integer iField Integer iState
10984>>>>>        String  sKeys
10984>>>>>        Set Key_Field_State of Record_Buffer iField to iState
10985>>>>>        Get Key_Fields to sKeys
10986>>>>>        Set Key_Fields to (Overstrike(If(iState, "X", " "), sKeys, iField))
10987>>>>>    End_Procedure
10988>>>>>    
10988>>>>>    // Will return TRUE if the field passed has been defined as a key.
10988>>>>>    Function Key_Field_State Integer iField Returns Integer
10990>>>>>        Integer iState
10990>>>>>        Get Key_Field_State of Record_Buffer iField to iState
10991>>>>>        Function_Return iState
10992>>>>>    End_Function
10993>>>>>    
10993>>>>>    // Returns complete key value.
10993>>>>>    Function Key_Value Returns String
10995>>>>>        String  sKeys
10995>>>>>        String  sKey_Value
10995>>>>>        String  sValue
10995>>>>>        Integer iField
10995>>>>>        Get Key_Fields to sKeys
10996>>>>>        Move "" to sKey_Value
10997>>>>>        Repeat
10997>>>>>>
10997>>>>>            Move (Pos( "X",sKeys)) to iField
10998>>>>>            If iField Begin
11000>>>>>                Get Field_Current_Value iField to sValue
11001>>>>>                Append sKey_Value sValue
11002>>>>>                Move (Overstrike(" ", sKeys, iField)) to sKeys
11003>>>>>            End
11003>>>>>>
11003>>>>>        Until not iField
11005>>>>>        Function_Return sKey_Value
11006>>>>>    End_Function
11007>>>>>    
11007>>>>>    // This procedure will be called whenever the Data_Set changes its
11007>>>>>    // Current_Record property, or after a Save, Delete or Clear operation.
11007>>>>>    // We send this message to the Record_Buffer object to update its values.
11007>>>>>    Procedure New_Current_Record Integer iOld Integer iNew
11009>>>>>        // does nothing, but exists if developer is using this for some purpose. Is called after
11009>>>>>        // OnNewCurrentRecord (if recnum based table)
11009>>>>>    End_Procedure
11010>>>>>    
11010>>>>>    Procedure OnNewCurrentRecord RowID riOld RowID riNew
11012>>>>>        Integer iObj
11012>>>>>        Integer iOldst
11012>>>>>        Integer iFoc
11012>>>>>        Integer iIsExt
11012>>>>>        Forward Send OnNewCurrentRecord riOld riNew
11014>>>>>        Move (Record_Buffer(Self)) to iObj
11015>>>>>        If iObj Begin
11017>>>>>            Send OnNewCurrentRecord of iObj riOld riNew
11018>>>>>            // must also refresh all defined extended fields
11018>>>>>            Send ExtendedFieldsRefresh (IsNullRowId(riNew)) // pass bCleared (true if a clear)
11019>>>>>            Get Focus of Desktop to iFoc
11020>>>>>            Get Extended_DEO_State of iFoc to iIsExt     // if focus is deo item
11021>>>>>            If iIsExt Begin                               // disable the state so
11023>>>>>                Get Entry_Refresh_State of iFoc to iOldSt // value will come
11024>>>>>                Set Entry_Refresh_State of iFoc to True   // from Local buffer.
11025>>>>>            End
11025>>>>>>
11025>>>>>            Set Existing_Key_Value to (Key_Value(Self))
11026>>>>>            If iIsExt ;                Set Entry_Refresh_State of iFoc to iOldSt
11029>>>>>            // Only set defaults when the record is new
11029>>>>>            If (IsNullRowId(riNew)) ;                Send Prepare_Default_Values
11032>>>>>        End
11032>>>>>>
11032>>>>>    End_Procedure
11033>>>>>    
11033>>>>>    // Shuts off change mode and sends initialize_default_values which is
11033>>>>>    // a user hook routine.
11033>>>>>    Procedure Prepare_Default_Values
11035>>>>>        Integer iOldState
11035>>>>>        Get Change_disabled_State to iOldState
11036>>>>>        Set Change_disabled_State to True
11037>>>>>        Send Private_Field_Defaults
11038>>>>>        // set defaults if this is the main DDO or the DDO is
11038>>>>>        // flagged as supporting saving new records when foreign (a parent)
11038>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self)) ;            Send Field_Defaults
11041>>>>>        Send AssignDynamicDefaults
11042>>>>>        Set Change_disabled_State to iOldState
11043>>>>>    End_Procedure
11044>>>>>    
11044>>>>>    // Set all checkbox fields to default to False data value.
11044>>>>>    Procedure Private_Field_Defaults
11046>>>>>        Integer iField
11046>>>>>        Repeat
11046>>>>>>
11046>>>>>            Get Next_Validation_Type of (Field_Attributes(Self)) ;                FA_VALIDATION_TYPE_CHECKBOX iField to iField
11047>>>>>            If (iField = 0) ;                Procedure_Return
11050>>>>>            Set Field_Select_State  iField to False
11051>>>>>            Set Field_Changed_State iField to True
11052>>>>>        Loop
11053>>>>>>
11053>>>>>    End_Procedure
11054>>>>>    
11054>>>>>    // Will be called after a clear operation to let the application
11054>>>>>    // programmer set the default values for the record. This should be done
11054>>>>>    // by sending SET Field_Current_Value.
11054>>>>>    Procedure Field_Defaults
11056>>>>>    End_Procedure
11057>>>>>    
11057>>>>>    // Pass type and string value and see if this is valid data for this
11057>>>>>    // type. Currently we check for numbers and dates. Return non-zero
11057>>>>>    // if invalid.
11057>>>>>    Function IsDataInvalid Integer iType String sValue Returns Integer
11059>>>>>        Date    dVal
11059>>>>>        DateTime dtVal
11059>>>>>        Number  nVal
11059>>>>>        Integer bOK
11059>>>>>        Boolean bInvalid
11059>>>>>        
11059>>>>>        Move False to bInvalid
11060>>>>>        If (iType=DF_BCD or iType=DF_DATE or iType=DF_DATETIME) Begin
11062>>>>>            If (iType=DF_DATE) Begin
11064>>>>>                MoveTrapErr sValue to dVal
11065>>>>>                Move (Err) to bInvalid
11066>>>>>            End
11066>>>>>>
11066>>>>>            Else If (iType=DF_DATETIME) Begin
11069>>>>>                MoveTrapErr sValue to dtVal
11070>>>>>                Move (Err) to bInvalid
11071>>>>>//          Move (not(IsDateValid(dtVal))) to bInvalid //jjt-uncomment when working
11071>>>>>            End
11071>>>>>>
11071>>>>>            Else Begin
11072>>>>>                MoveTrapErr sValue to nVal // this may gen an error.
11073>>>>>                Move (Err) to bInvalid
11074>>>>>            End
11074>>>>>>
11074>>>>>            Move False to Err
11075>>>>>        End
11075>>>>>>
11075>>>>>        Function_Return bInvalid
11076>>>>>    End_Function
11077>>>>>    
11077>>>>>    // Return 1 if the passed DEO is part of the DDs list of connected DEOs
11077>>>>>    // First check if server of DEO is this DD. If so, we are owned. If not
11077>>>>>    // we must check the DD's UI DEO list.
11077>>>>>    // The passed object MUST be a valid DEO or an error will occur.
11077>>>>>    Function IsDEOOwned Integer iDEO Returns Integer
11079>>>>>        Integer iMax iCount
11079>>>>>        // if DEOs server is same as current DD it is owned. This is the
11079>>>>>        // fast check
11079>>>>>        If (Server(iDEO)=Self) ;            Function_Return 1
11082>>>>>        // else see if the DEO is in the DD's DEO list
11082>>>>>        Get Data_Set_User_Interface_Count to iMax
11083>>>>>        Decrement iMax
11084>>>>>        For iCount from 0 to iMax
11090>>>>>>
11090>>>>>            If (Data_Set_User_Interface(Self,iCount)=iDEO) ;                Function_Return 1
11093>>>>>        Loop
11094>>>>>>
11094>>>>>        Function_Return 0
11095>>>>>    End_Function
11096>>>>>    
11096>>>>>    // This procedure changes the field value of the given field in the
11096>>>>>    // record-buffer object.
11096>>>>>    // It also sends Field_Value_Changed to notify every the attached DEOs.
11096>>>>>    // This has been optimized so this message is only sent when data is
11096>>>>>    // actually changed.
11096>>>>>    Procedure Set Field_Current_Value Integer iField String sValue
11098>>>>>        Integer iObj
11098>>>>>        String sOldVal
11098>>>>>        Integer iChanged
11098>>>>>        Integer iType
11098>>>>>        Integer iFile
11098>>>>>        Integer iFocObj
11098>>>>>        Integer iCrnt
11098>>>>>        Integer bInvalid
11098>>>>>        Integer iIdentity
11098>>>>>        Address pData
11098>>>>>        Integer iLen
11098>>>>>        
11098>>>>>        Get Main_File to iFile
11099>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
11102>>>>>        
11102>>>>>        // Overlap fields are not supported directly in DDs. It is expected
11102>>>>>        // that you will use the underlying fields instead
11102>>>>>        If (iType = DF_OVERLAP) Begin
11104>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
11105>>>>>            Procedure_Return
11106>>>>>        End
11106>>>>>>
11106>>>>>        
11106>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
11108>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
11109>>>>>            Move (Length(sValue)) to iLen // length to copy
11110>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
11111>>>>>            // will gen error if ext. field does not exist
11111>>>>>            Set Field_Current_Pointer_Value iField iLen to pData
11112>>>>>            Procedure_Return
11113>>>>>        End
11113>>>>>>
11113>>>>>        
11113>>>>>        
11113>>>>>        // If date or number, force conversion so any error is detected before
11113>>>>>        // the buffer is updated. We don't want the record buffer to contain
11113>>>>>        // invalid data
11113>>>>>        Get IsDataInvalid iType sValue to bInvalid
11114>>>>>        If bInvalid ;         // If an error occurred we have            Procedure_Return  // a bad number or a bad date. Do no more!
11117>>>>>        
11117>>>>>        Move (Record_Buffer(Self)) to iObj
11118>>>>>        Get Value of iObj iField to sOldVal
11119>>>>>        
11119>>>>>        Set Value of iObj iField to sValue
11120>>>>>        
11120>>>>>        // Augmented to handle non DF databases JJT
11120>>>>>        // Some tables may use some field other then recnum for their record identity.
11120>>>>>        // This will be dfrecnum or some other numeric field. When this happens the DD have
11120>>>>>        // to field buffers for the same value. When an update occurs from the DD to the DB buffer
11120>>>>>        // an update can occur twice. If the values are the same, this does not matter. Else the highest
11120>>>>>        // field value will get the update (not recnum). So if someone changes recnum but not its real field
11120>>>>>        // finding may not work right. The DD is updated when a record is found and the API keeps the two values
11120>>>>>        // the same. If the user changes recnum, the real field does not get changed. That is what we are fixing
11120>>>>>        // here. Note that: 1) this has no effect on Dataflex databases (or any DB that has a 0 field recnum).
11120>>>>>        // 2) this type of update is rarely seen anyway (you have to change just the recnum and perform an entry_update).
11120>>>>>        //
11120>>>>>        // if field is recnum and record identity is not 0, we must also update the other field.
11120>>>>>        If (iField=0) Begin
11122>>>>>            Get_Attribute DF_FILE_RECORD_IDENTITY of iFile to iIdentity
11125>>>>>            If (iIdentity>0) ;                Set Value of iObj iIdentity to sValue
11128>>>>>        End
11128>>>>>>
11128>>>>>        
11128>>>>>        // When data-sets are working they should not update the
11128>>>>>        // DEOs.
11128>>>>>        
11128>>>>>        // prior to vdf7, we stopped all operation modes of non-zero. We now allow
11128>>>>>        // validates to pass through and we have a new operation mode for this. This
11128>>>>>        // should be ok, since we already allowed navigation validation through - we just
11128>>>>>        // stopped request_validate validations.
11128>>>>>        If (Operation_Mode=0 or Operation_Mode=MODE_VALIDATING) Begin
11130>>>>>            If (iType=DF_BCD) ;                Move (Number(sValue)<>Number(sOldVal)) to iChanged
11133>>>>>            Else If (iType=DF_DATE) ;                Move (Date(sValue)<>Date(sOldVal)) to iChanged
11137>>>>>            Else If (iType=DF_DATETIME) ;                Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to iChanged
11141>>>>>            Else ;                Move (sValue<>sOldVal) to iChanged
11143>>>>>            // if changed, notify all DEOs of this change
11143>>>>>            If iChanged ;                Send Field_Value_Changed iField sValue
11146>>>>>            Else Begin
11147>>>>>                // If here the set value did not change the contents of the DD.
11147>>>>>                // However, it is possible that the current focus DEO may contain
11147>>>>>                // a different value than the one we are setting. In such a case
11147>>>>>                // we must re-synchronize the DEO. Only the one DEO can be affected
11147>>>>>                // because it is the current focus deo/item that can contain a value
11147>>>>>                // that is not yet updated in the DD. This fixes a bug where the
11147>>>>>                // iexit was setting a value which was different from what was in
11147>>>>>                // the DEO but was the same as the old DD value (iExit is called
11147>>>>>                // before the DD is re-synched with the DEO). This could happen
11147>>>>>                // also by sending this message directly with a different value in
11147>>>>>                // the DEO focus item.
11147>>>>>                Get Focus of Desktop to iFocObj
11148>>>>>                // similar logic to Get Field_Current_Value. We check that the DEO
11148>>>>>                // is extended, that entry_refresh is not disabled and that the
11148>>>>>                // DEO's server is this DD.
11148>>>>>                If ( Extended_DEO_State(iFocObj) and ;                    (Entry_Refresh_State(iFocObj)=0)) Begin
11150>>>>>                    Get Current_item of iFocObj to iCrnt
11151>>>>>                    // If Focus DEO has same file and field and it is not checkbox
11151>>>>>                    // we must set its value. Set local value directly sets the value
11151>>>>>                    // in the DEO item. If we used value we'd get recursion!
11151>>>>>                    If ( Data_File(iFocObj,iCrnt)=iFile and ;                        Data_Field(iFocObj,iCrnt)=iField and ;                        IsDEOOwned(Self,iFocObj) and ;                        Checkbox_item_State(iFocObj,iCrnt)=0 ) ;                        Send File_Field_Value_Changed to iFocObj iFile iField sValue True
11154>>>>>                    //Set Local_Value of iFocObj iCrnt to sValue
11154>>>>>                End
11154>>>>>>
11154>>>>>            End
11154>>>>>>
11154>>>>>        End
11154>>>>>>
11154>>>>>    End_Procedure
11155>>>>>    
11155>>>>>    // Sets Field_Current_Value and Sets Field_Changed_State for passed field.
11155>>>>>    Procedure Set Field_Changed_Value Integer iField String sValue
11157>>>>>        Set Field_Changed_State iField to True
11158>>>>>        Set Field_Current_Value iField to sValue
11159>>>>>    End_Procedure
11160>>>>>    
11160>>>>>    
11160>>>>>    // This should only be set by a DEO that is changing a NoPut value. This should only happen when NoEnter=F
11160>>>>>    // for indexed findable noput deos. With foreign-field noputs we may store the value and update them
11160>>>>>    // for finds but we don't want them for saves. The cDDBuffer class handles this but it needs to
11160>>>>>    // know if this was a DEO NoPut update. DDOs have always allowed you to directly update foreign NoPut
11160>>>>>    // fields when the change did not come from a DEO.
11160>>>>>    Procedure Set Field_NoPutValueChangedByDeo Integer iField Boolean bChange
11162>>>>>        Set Item_ChangedByDeo of Record_Buffer iField to bChange
11163>>>>>    End_Procedure
11164>>>>>    
11164>>>>>    Procedure Set File_Field_NoPutValueChangedByDeo Integer iFile Integer iField Boolean bChange
11166>>>>>        Integer iDSO
11166>>>>>        Get Data_set iFile to iDSO
11167>>>>>        If iDSO Begin
11169>>>>>            Set Field_NoPutValueChangedByDeo of iDSO iField to bChange
11170>>>>>        End
11170>>>>>>
11170>>>>>    End_Procedure
11171>>>>>    
11171>>>>>    // Returns the value from the record buffer for the field of which the
11171>>>>>    // fieldnumber has been passed.
11171>>>>>    // If the file/field requested is the focus file/field the use the DEO's
11171>>>>>    // value.
11171>>>>>    Function Field_Current_Value Integer iField Returns String
11173>>>>>        Integer iType
11173>>>>>        Integer iFile
11173>>>>>        String  sValue
11173>>>>>        Integer iFoc
11173>>>>>        Integer iCrnt
11173>>>>>        Integer iStrSize
11173>>>>>        Integer iFldSize iVoid
11173>>>>>        UChar[] UCData
11174>>>>>        
11174>>>>>        Get Focus of desktop to iFoc
11175>>>>>        Get Main_File to iFile
11176>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
11179>>>>>        
11179>>>>>        // Overlap fields are not supported directly in DDs. It is expected
11179>>>>>        // that you will use the underlying fields instead
11179>>>>>        If (iType=DF_OVERLAP) Begin
11181>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
11182>>>>>            Function_Return ''
11183>>>>>        End
11183>>>>>>
11183>>>>>        
11183>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if overlap, text or binary direct to pointer
11185>>>>>            Get Field_Current_UCAValue iField to UCData
11186>>>>>            
11186>>>>>            // we assume a string is passed here. If we return to a string the
11186>>>>>            // pointer message will convert this to a string. First check that max string
11186>>>>>            // length is ok for this field.
11186>>>>>            Get_Argument_Size to iStrSize
11187>>>>>            Move (SizeOfArray(UCData)) to iFldSize
11188>>>>>            // check that the string size is large enough to hold the value
11188>>>>>            If (iStrSize < iFldSize) Begin
11190>>>>>                Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_TOO_BIG
11191>>>>>            End
11191>>>>>>
11191>>>>>            Else Begin
11192>>>>>                Move (UCharArrayToString(UCData)) to sValue
11193>>>>>            End
11193>>>>>>
11193>>>>>            // This function has always returned the value as a 0 delimited string.
11193>>>>>            // Therefore trim at first zero. This means that you should not use this method
11193>>>>>            // with Binary types as embedded zeros will cause a truncation.
11193>>>>>            Move (CString(sValue)) to sValue
11194>>>>>            Function_Return sValue
11195>>>>>        End
11195>>>>>>
11195>>>>>        
11195>>>>>        // This was extended to also make sure that the focus's server
11195>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
11195>>>>>        // file/field being the right file/field but for a different view.
11195>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
11195>>>>>        // ddos have the information they need from the deos. During a refresh we don't
11195>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
11195>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
11195>>>>>        // DEO field, so the buffer is always correct.
11195>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
11197>>>>>            Get Current_item of iFoc to iCrnt
11198>>>>>            If ( Data_File(iFoc,iCrnt)=iFile and Data_Field(iFoc,iCrnt)=iField and ;                IsDEOOwned(Self,iFoc) and ;                (Checkbox_item_State(iFoc,iCrnt)=0) ) Begin
11200>>>>>                Get Data_Value of iFoc iCrnt to sValue
11201>>>>>            End
11201>>>>>>
11201>>>>>            Else Begin
11202>>>>>                Get Value of (Record_Buffer(Self)) iField to sValue
11203>>>>>            End
11203>>>>>>
11203>>>>>        End
11203>>>>>>
11203>>>>>        Else Begin
11204>>>>>            Get Value of (Record_Buffer(Self)) iField to sValue
11205>>>>>        End
11205>>>>>>
11205>>>>>        
11205>>>>>        // cast value to the proper datatype
11205>>>>>        If (iType=DF_BCD) Begin
11207>>>>>            Function_Return (Number(sValue))
11208>>>>>        End
11208>>>>>>
11208>>>>>        Else If (iType=DF_DATE) Begin
11211>>>>>            Function_Return (Date(sValue))
11212>>>>>        End
11212>>>>>>
11212>>>>>        Else If (iType=DF_DATETIME) Begin
11215>>>>>            Function_Return (Cast(sValue,DateTime))
11216>>>>>        End
11216>>>>>>
11216>>>>>        // else return as string
11216>>>>>        Function_Return sValue
11217>>>>>    End_Function
11218>>>>>    
11218>>>>>    // This sets a default value without setting the DSO's changed_State
11218>>>>>    Procedure Set Field_Default_Value Integer iField String sValue
11220>>>>>        Integer iOldState
11220>>>>>        Get Change_disabled_State to iOldState
11221>>>>>        Set Change_disabled_State to True
11222>>>>>        Set Field_Changed_Value iField to sValue
11223>>>>>        Set Change_disabled_State to iOldState
11224>>>>>    End_Procedure
11225>>>>>    
11225>>>>>    Procedure Set File_Field_default_Value Integer iFile Integer iField String sValue
11227>>>>>        Integer iDSO
11227>>>>>        Get Data_set iFile to iDSO
11228>>>>>        If iDSO ;            Set Field_default_Value of iDSO iField to sValue
11231>>>>>    End_Procedure
11232>>>>>    
11232>>>>>    // Methods to set and get the value of a field. When set all DSOs and
11232>>>>>    // DEOs are notified.
11232>>>>>    Procedure Set File_Field_Current_Value Integer iFile Integer iField String sValue
11234>>>>>        Integer iDSO
11234>>>>>        Get Data_set iFile to iDSO
11235>>>>>        If iDSO ;            Set Field_Current_Value of iDSO iField to sValue
11238>>>>>    End_Procedure
11239>>>>>    
11239>>>>>    Procedure Set File_Field_Changed_Value Integer iFile Integer iField String sValue
11241>>>>>        Integer iDSO
11241>>>>>        Get Data_set iFile to iDSO
11242>>>>>        If iDSO ;            Set Field_Changed_Value of iDSO iField to sValue
11245>>>>>    End_Procedure
11246>>>>>    
11246>>>>>    Function File_Field_Current_Value Integer iFile Integer iField Returns String
11248>>>>>        Integer iDSO
11248>>>>>        String sValue
11248>>>>>        Get Data_set iFile to iDSO
11249>>>>>        If iDSO ;            Get Field_Current_Value of iDSO iField to sValue
11252>>>>>        Function_Return sValue
11253>>>>>    End_Function
11254>>>>>    
11254>>>>>    // This procedure will notify every attached DEO that the value of a
11254>>>>>    // field has been changed. Every DEO needs to update its value to reflect
11254>>>>>    // the new value.
11254>>>>>    Procedure Field_Value_Changed Integer iField String sValue
11256>>>>>        Integer iMax
11256>>>>>        Integer iCount
11256>>>>>        Integer iDEO
11256>>>>>        Integer iMain_File
11256>>>>>        Integer iNoChange
11256>>>>>        Get Change_Disabled_State to iNoChange
11257>>>>>        Get Main_File to iMain_File
11258>>>>>        Get Data_Set_User_Interface_Count to iMax
11259>>>>>        Decrement iMax
11260>>>>>        For iCount from 0 to iMax
11266>>>>>>
11266>>>>>            Get Data_Set_User_Interface iCount to iDEO
11267>>>>>            If (Extended_DEO_State(iDEO) ) Begin
11269>>>>>                Send File_Field_Value_Changed to iDEO iMain_File iField sValue iNoChange
11270>>>>>            End
11270>>>>>>
11270>>>>>        Loop
11271>>>>>>
11271>>>>>    End_Procedure
11272>>>>>    
11272>>>>>    // Gets/Sets Field_Changed_State of the passed field. Will Set Changed_
11272>>>>>    // state if appropriate (if change_disabled_state is false)
11272>>>>>    Function Field_Changed_State Integer iField Returns Integer
11274>>>>>        Function_Return ;            (Item_Changed_State(Record_Buffer(Self), iField))
11275>>>>>    End_Function
11276>>>>>    
11276>>>>>    
11276>>>>>    // Handle NoPut here. If the field is noput set the field_changed_State but do not set the
11276>>>>>    // DD's changed_state. As of 17.0, we changed the rule so that noput DEOs always update the DD.
11276>>>>>    // They set the field_Current_value and they set the field_changed_state. If noput they will
11276>>>>>    // not set changed_state. This now makes windows and web consistent.
11276>>>>>    Procedure Set Field_Changed_State Integer iField Integer iState
11278>>>>>        Boolean bNoPut bOldSt bIsCommitted
11278>>>>>        
11278>>>>>        Get Field_Option iField DD_NOPUT to bNoPut
11279>>>>>        If not bNoPut Begin // if not noput, see if this is a committed and therefore noput
11281>>>>>            Get IsCommitted iField to bIsCommitted
11282>>>>>            If bIsCommitted Begin
11284>>>>>                Get IsFieldCommitted iField to bNoPut
11285>>>>>            End
11285>>>>>>
11285>>>>>        End
11285>>>>>>
11285>>>>>        
11285>>>>>        If bNoPut Begin
11287>>>>>            Get Change_disabled_State to bOldSt
11288>>>>>            Set Change_disabled_State to True
11289>>>>>        End
11289>>>>>>
11289>>>>>        
11289>>>>>        Set Item_Changed_State of (Record_Buffer(Self)) iField to iState
11290>>>>>        // the cDDBuffer class item_changed_state does not attempt to set
11290>>>>>        // changed_state, so we do it here. This will allow for future
11290>>>>>        // greater flexibilities.
11290>>>>>        If (iState) Begin
11292>>>>>            Set Changed_State of (Record_Buffer(Self)) to True
11293>>>>>        End
11293>>>>>>
11293>>>>>        If bNoPut Begin
11295>>>>>            Set Change_disabled_State to bOldSt
11296>>>>>        End
11296>>>>>>
11296>>>>>        
11296>>>>>    End_Procedure
11297>>>>>    
11297>>>>>    // As above, but passes both file and field
11297>>>>>    Function File_Field_Changed_State Integer iFile Integer iField Returns Integer
11299>>>>>        Integer iDSO
11299>>>>>        Get Data_Set iFile to iDSO
11300>>>>>        If iDSO ;            Function_Return (Field_Changed_State(iDSO, iField))
11303>>>>>    End_Function
11304>>>>>    
11304>>>>>    Procedure Set File_Field_Changed_State Integer iFile Integer iField Integer iState
11306>>>>>        Integer iDSO
11306>>>>>        Get Data_Set iFile to iDSO
11307>>>>>        If iDSO ;            Set Field_Changed_State of iDSO iField to iState
11310>>>>>    End_Procedure
11311>>>>>    
11311>>>>>    // This simulates entering a value into a field from a keyboard. Pass the
11311>>>>>    // Field and DD Options and the value. It is up to you to pass the proper
11311>>>>>    // DD options. This is normally sent by File_Field_Entry and you are
11311>>>>>    // advised to use that message and not this one.
11311>>>>>    Procedure Set Field_Entry Integer iField Integer iOpts Integer bShowErr String sValue
11313>>>>>        Integer iFile
11313>>>>>        Integer iType
11313>>>>>        Integer bChanged
11313>>>>>        Integer bInvalid
11313>>>>>        Integer hObj
11313>>>>>        String sOldVal
11313>>>>>        Address pData
11313>>>>>        Integer iLen
11313>>>>>        
11313>>>>>        Get Main_File to iFile
11314>>>>>        
11314>>>>>        // if No-enter or Displayonly, this shouldn't be changed. We will
11314>>>>>        // let NoPut through, since a user might need it for finding.
11314>>>>>        If (iOpts iand DD_NOENTER) ;            Procedure_Return
11317>>>>>        
11317>>>>>        // Force a caplsock if required
11317>>>>>        If (iOpts iand DD_CAPSLOCK) ;            Move (Uppercase(sValue)) to sValue
11320>>>>>        
11320>>>>>        // If date or number, force conversion so any error is detected before
11320>>>>>        // the buffer is updated. We don't want the record buffer to contain
11320>>>>>        // invalid data
11320>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
11323>>>>>        
11323>>>>>        // Overlap fields are not supported directly in DDs. It is expected
11323>>>>>        // that you will use the underlying fields instead
11323>>>>>        If (iType = DF_OVERLAP) Begin
11325>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
11326>>>>>            Procedure_Return
11327>>>>>        End
11327>>>>>>
11327>>>>>        
11327>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin // if text or binary direct to pointer
11329>>>>>            Move sValue to sValue // intentional code: make sure passed sValue is a really string
11330>>>>>            Move (Length(sValue)) to iLen // length to copy
11331>>>>>            Move (AddressOf(sValue)) to pData   // first byte of string
11332>>>>>            // will gen error if ext. field does not exist
11332>>>>>            Set Field_Pointer_Entry iField iOpts iLen bShowErr to pData
11333>>>>>            Procedure_Return
11334>>>>>        End
11334>>>>>>
11334>>>>>        
11334>>>>>        Get IsDataInvalid iType sValue to bInvalid
11335>>>>>        If bInvalid Begin     // If an error occurred we have
11337>>>>>            If bShowErr ;                Send Data_set_error iField (If(iType=DF_DATE or iType=DF_DATETIME, DFERR_ENTER_VALID_DATE, DFERR_BAD_ENTRY)) ;                (" ("-sValue-")")
11340>>>>>            Procedure_Return  // a bad number or a bad date. Do no more!
11341>>>>>        End
11341>>>>>>
11341>>>>>        // update the value only if the value is changed.
11341>>>>>        Move (Record_Buffer(Self)) to hObj
11342>>>>>        Get Value of hObj iField to sOldVal
11343>>>>>        If (iType=DF_BCD) ;            Move (Number(sValue)<>Number(sOldVal)) to bChanged
11346>>>>>        Else If (iType=DF_DATE) ;            Move (Date(sValue)<>Date(sOldVal)) to bChanged
11350>>>>>        Else If (iType=DF_DATETIME) ;            Move (Cast(sValue,DateTime)<>Cast(sOldVal,DateTime)) to bChanged
11354>>>>>        Else ;            Move (sValue<>sOldVal) to bChanged
11356>>>>>        
11356>>>>>        // if changed or force put, update the value.
11356>>>>>        If ( bChanged or (iOpts iand DD_FORCEPUT) ) ;            Set Field_Current_Value iField to sValue
11359>>>>>        
11359>>>>>        // Set changed state if changed. This is an improvement on DEOs which would set changed-state for
11359>>>>>        // a no-put. Set Field_Changed_State will not set Changed_state if it is noput
11359>>>>>        If ( bChanged) Begin
11361>>>>>            Set Field_Changed_State iField to True
11362>>>>>            // if noput (but not noenter) we must tell the DDO that this should not be
11362>>>>>            // updated during a save.
11362>>>>>            If (iOpts iand DD_NOPUT) Begin
11364>>>>>                Set Field_NoPutValueChangedByDeo iField to True
11365>>>>>            End
11365>>>>>>
11365>>>>>        End
11365>>>>>>
11365>>>>>        
11365>>>>>        // perform autofinds if needed. Note that required checking will occur as
11365>>>>>        // part of validation.
11365>>>>>        // We will only autofind if the field value is changed. This is consistent with
11365>>>>>        // DEOs which do not autofind on unchanged values. This provides optimizations
11365>>>>>        // when a parent record is already loaded.
11365>>>>>        If (bChanged or Field_Changed_state(Self,iField)) Begin
11367>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
11367>>>>>            // testing is important and make sure we test for exact bit match. Must first
11367>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
11367>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Send File_Field_AutoFind iFile iField GE
11370>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) ;                Send File_Field_AutoFind iFile iField EQ
11374>>>>>        End
11374>>>>>>
11374>>>>>        
11374>>>>>    End_Procedure
11375>>>>>    
11375>>>>>    // This returns file-field options for a Field_Entry type of environment.
11375>>>>>    // It will strip autofind from main-file DDs but leave foreign field alone.
11375>>>>>    // This is needed for Field_entry. Otherwise adding a field value to an autofind
11375>>>>>    // for save or find causes an autofind to trigger first which either causes the
11375>>>>>    // wrong rec to save or for a double find.
11375>>>>>    Function File_Field_Entry_Options Integer iFile Integer iField Returns Integer
11377>>>>>        Integer iOpts
11377>>>>>        // this will get the appropriate field and foreign field opts
11377>>>>>        Get File_Field_Options iFile iField to iOpts
11378>>>>>        // If the main file (not foreign) we will strip autofind. Autofind should not
11378>>>>>        // be an automatic part of main file entry while it should with foreign fields.
11378>>>>>        If (iFile=Main_File(Self)) Begin
11380>>>>>            // note that autofind is 1 and _ge is 100000001 (8th bit set). So order of
11380>>>>>            // testing is important and make sure we test for exact bit match. Must first
11380>>>>>            // test _GE and the EQ (because EQ bit is part of GE)
11380>>>>>            If ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ;                Move (iOpts - DD_AUTOFIND_GE) to iOpts
11383>>>>>            Else If ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND)  ;                Move (iOpts - DD_AUTOFIND)    to iOpts
11387>>>>>        End
11387>>>>>>
11387>>>>>        Function_Return iOpts
11388>>>>>    End_Function
11389>>>>>    
11389>>>>>    // This simulates entering a value into a field from a keyboard. The DD
11389>>>>>    // receiving this message determines if it is Main or Foreign (just like
11389>>>>>    // server). It will do an uppercase, will respect No_Enter and DisplayOnly
11389>>>>>    // and will do a autofind if required. It does not do a field validation.
11389>>>>>    Procedure Set File_Field_Entry Integer iFile Integer iField Integer bShowErr String sValue
11391>>>>>        Integer iOpts
11391>>>>>        Integer hDD
11391>>>>>        Get Data_Set iFile to hDD
11392>>>>>        If hDD Begin
11394>>>>>            // this will get the appropriate field and foreign field opts
11394>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
11395>>>>>            Set Field_Entry of hDD iField iOpts bShowErr to sValue
11396>>>>>        End
11396>>>>>>
11396>>>>>    End_Procedure
11397>>>>>    
11397>>>>>    // return object ID of extended field, 0 if none
11397>>>>>    Function Field_Object Integer iField Returns Integer
11399>>>>>        Integer hoFlds hoField
11399>>>>>        Boolean bAutoAssign
11399>>>>>        Get Field_Objects to hoFlds
11400>>>>>        If hoFlds Begin
11402>>>>>            Get Field_Object of hoFlds iField to hoField
11403>>>>>        End
11403>>>>>>
11403>>>>>        If not hoField Begin
11405>>>>>            Send DefineExtendedField iField // will create field_objects and Field_Object as needed
11406>>>>>            Get Field_Objects to hoFlds
11407>>>>>            Get Field_Object of hoFlds iField to hoField
11408>>>>>        End
11408>>>>>>
11408>>>>>        Function_Return hoField
11409>>>>>    End_Function
11410>>>>>    
11410>>>>>    // This is the same as Field_entry except the value is passed via a
11410>>>>>    // pointer. If data-type is extended (text/binary) it will use and an
11410>>>>>    // extended field object to handle this. If date/number/string we will
11410>>>>>    // convert this to a string and use Field_Entry. It is the caller's
11410>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
11410>>>>>    // If an extended Field object is needed and not defined, an error is
11410>>>>>    // returned. If pointer is null, assume empty string passed (this is a
11410>>>>>    // change as of 8.3 - it used to ignore null pointers)
11410>>>>>    Procedure Set Field_Pointer_Entry Integer iField Integer iOpts Integer iLen Integer bShowErr Address pData
11412>>>>>        Integer hFld
11412>>>>>        String  sValue
11412>>>>>        Integer iFile
11412>>>>>        Integer iType
11412>>>>>        
11412>>>>>        Get Main_file to iFile
11413>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
11416>>>>>        
11416>>>>>        // Overlap fields are not supported directly in DDs. It is expected
11416>>>>>        // that you will use the underlying fields instead
11416>>>>>        If (iType = DF_OVERLAP) ;            Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_OVERLAP_ERROR
11419>>>>>        Else If (iType=DF_TEXT or iType=DF_BINARY) Begin
11422>>>>>            Get Field_Object iField to hFld // the object that handles this large text
11423>>>>>            If hFld ;                Set Field_pEntry of hFld iOpts iLen bShowErr to pData
11426>>>>>            Else ;                Send Data_set_Error iField DFERR_PROGRAM  DD_EXTENDED_FIELD_NOT_DEFINED
11428>>>>>        End
11428>>>>>>
11428>>>>>        Else Begin
11429>>>>>            // if number,date or string convert the pointer data to
11429>>>>>            // string data and do a normal entry with it.
11429>>>>>            Move pData to sValue // create string from pointer data
11430>>>>>            Set Field_Entry iField iOpts bShowErr to sValue
11431>>>>>        End
11431>>>>>>
11431>>>>>    End_Procedure
11432>>>>>    
11432>>>>>    // This is the same as File_Field_entry except the value is passed via a
11432>>>>>    // pointer. See Field_Pointer_Entry for more on this
11432>>>>>    Procedure Set File_Field_Pointer_Entry Integer iFile Integer iField Integer iLen Integer bShowErr Address pData
11434>>>>>        Integer iOpts
11434>>>>>        Integer hDD
11434>>>>>        Get Data_Set iFile to hDD
11435>>>>>        If hDD Begin
11437>>>>>            // this will get the appropriate field and foreign field opts
11437>>>>>            Get File_Field_Entry_Options iFile iField to iOpts
11438>>>>>            Set Field_Pointer_Entry of hDD iField iOpts iLen bShowErr to pData
11439>>>>>        End
11439>>>>>>
11439>>>>>    End_Procedure
11440>>>>>    
11440>>>>>    // This is the same as Field_Current_Value except the value is passed via
11440>>>>>    // a pointer. If data-type is extended (text/binary) it will use and an
11440>>>>>    // extended field object to handle this. If date/number/string we will
11440>>>>>    // convert this to a string and use Field_Entry. It is the caller's
11440>>>>>    // responsibility to pass a valid pointer to valid data...else !@#$%^&^
11440>>>>>    // If an extended Field object is needed and not defined, an error is
11440>>>>>    // returned. If pointer is null, assume empty string passed (this is a
11440>>>>>    // change as of 8.3 - it used to ignore null pointers)
11440>>>>>    Procedure Set Field_Current_Pointer_Value Integer iField Integer iLen Address pData
11442>>>>>        Integer hFld
11442>>>>>        String  sValue
11442>>>>>        Integer iFile iType iCrnt
11442>>>>>        Handle iFocObj
11442>>>>>        Boolean bChanged
11442>>>>>        
11442>>>>>        Get Main_file to iFile
11443>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iType
11446>>>>>        
11446>>>>>        // Overlap fields are not supported directly in DDs. It is expected
11446>>>>>        // that you will use the underlying fields instead
11446>>>>>        If (iType = DF_OVERLAP) Begin
11448>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_OVERLAP_ERROR
11449>>>>>            Procedure_Return
11450>>>>>        End
11450>>>>>>
11450>>>>>        
11450>>>>>        If (iType<>DF_TEXT and iType<>DF_BINARY) Begin
11452>>>>>            // if number,date or string convert the pointer data to
11452>>>>>            // string data and do a normal entry with it.
11452>>>>>            Move pData to sValue // create string from pointer data
11453>>>>>            Set Field_Current_Value iField to sValue
11454>>>>>            Procedure_Return
11455>>>>>        End
11455>>>>>>
11455>>>>>        
11455>>>>>        Get Field_Object iField to hFld // the object that handles this large text
11456>>>>>        If not hFld Begin
11458>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
11459>>>>>            Procedure_Return
11460>>>>>        End
11460>>>>>>
11460>>>>>        
11460>>>>>        Get Is_pValueChanged of hFld iLen pData to bChanged
11461>>>>>        If bChanged Begin
11463>>>>>            Set Field_pValue of hFld iLen to pData
11464>>>>>            Send Field_Pointer_Value_Changed iField pData
11465>>>>>        End
11465>>>>>>
11465>>>>>        Else Begin
11466>>>>>            // If here the set value did not change the contents of the DD.
11466>>>>>            // However, it is possible that the current focus DEO may contain
11466>>>>>            // a different value than the one we are setting. In such a case
11466>>>>>            // we must re-synchronize the DEO. Only the one DEO can be affected
11466>>>>>            // because it is the current focus deo/item that can contain a value
11466>>>>>            // that is not yet updated in the DD. This fixes a bug where the
11466>>>>>            // iexit was setting a value which was different from what was in
11466>>>>>            // the DEO but was the same as the old DD value (iExit is called
11466>>>>>            // before the DD is re-synched with the DEO). This could happen
11466>>>>>            // also by sending this message directly with a different value in
11466>>>>>            // the DEO focus item.
11466>>>>>            Get Focus of Desktop to iFocObj
11467>>>>>            // similar logic to Get Field_Pointer_Current_Value. We check that the DEO
11467>>>>>            // is extended, that entry_refresh is not disabled and that the
11467>>>>>            // DEO's server is this DD.
11467>>>>>            If ( Extended_DEO_State(iFocObj) and (Entry_Refresh_State(iFocObj)=0)) Begin
11469>>>>>                // If Focus DEO has same file and field and it is not checkbox
11469>>>>>                // we must set its value. Set local value directly sets the value
11469>>>>>                // in the DEO item. If we used value we'd get recursion!
11469>>>>>                Get Current_item of iFocObj to iCrnt
11470>>>>>                If ( Data_File(iFocObj,iCrnt)=iFile and ;                    Data_Field(iFocObj,iCrnt)=iField and ;                    IsDEOOwned(Self,iFocObj) ) Begin
11472>>>>>                    Send File_Field_Pointer_Value_Changed to iFocObj iFile iField pData True
11473>>>>>                End
11473>>>>>>
11473>>>>>            End
11473>>>>>>
11473>>>>>        End
11473>>>>>>
11473>>>>>    End_Procedure
11474>>>>>    
11474>>>>>    // This is never called but it needed for the compiler. Required for apps DDs that don't compile in a DEO interface
11474>>>>>    Procedure File_Field_Pointer_Value_Changed Integer iFile Integer iField Address pValue Integer iChangeDisabled
11476>>>>>    End_Procedure
11477>>>>>    
11477>>>>>    Procedure Field_Pointer_Value_Changed Integer iField Address pValue
11479>>>>>        Integer iMax
11479>>>>>        Integer iCount
11479>>>>>        Integer iDEO
11479>>>>>        Integer iMain_File
11479>>>>>        Integer iNoChange
11479>>>>>        Get Change_Disabled_State to iNoChange
11480>>>>>        Get Main_File to iMain_File
11481>>>>>        Get Data_Set_User_Interface_Count to iMax
11482>>>>>        Decrement iMax
11483>>>>>        For iCount from 0 to iMax
11489>>>>>>
11489>>>>>            Get Data_Set_User_Interface iCount to iDEO
11490>>>>>            If (Extended_DEO_State(iDEO) ) Begin
11492>>>>>                Send File_Field_Pointer_Value_Changed to iDEO iMain_File iField pValue iNoChange
11493>>>>>            End
11493>>>>>>
11493>>>>>        Loop
11494>>>>>>
11494>>>>>    End_Procedure
11495>>>>>    
11495>>>>>    // This is the same as File_Field_Current_Value except the value is passed
11495>>>>>    // via a pointer. See Field_current_Pointer_Value for more on this
11495>>>>>    Procedure Set File_Field_Current_Pointer_Value Integer iFile Integer iField Integer iLen Address pData
11497>>>>>        Integer hDD
11497>>>>>        Get Data_Set iFile to hDD
11498>>>>>        If hDD ;            Set Field_Current_Pointer_Value of hDD iField iLen to pData
11501>>>>>    End_Procedure
11502>>>>>    
11502>>>>>    // This returns the data pointer to the extended field. At this point
11502>>>>>    // this is the data. Be careful if you change the data, be even more
11502>>>>>    // careful if you change the pointer (don't do it!!!!)
11502>>>>>    Function Field_Current_Pointer_Value Integer iField Returns Address
11504>>>>>        Integer hFld
11504>>>>>        Handle iFoc
11504>>>>>        
11504>>>>>        Get Field_Object iField to hFld // the object that handles this large text
11505>>>>>        If not hFld Begin
11507>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
11508>>>>>            Function_Return 0
11509>>>>>        End
11509>>>>>>
11509>>>>>        
11509>>>>>        
11509>>>>>        // This was extended to also make sure that the focus's server
11509>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
11509>>>>>        // file/field being the right file/field but for a different view.
11509>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
11509>>>>>        // ddos have the information they need from the deos. During a refresh we don't
11509>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
11509>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
11509>>>>>        // DEO field, so the buffer is always correct.
11509>>>>>        Get Focus of Desktop to iFoc
11510>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
11512>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
11514>>>>>                Send Update_Focus_Field
11515>>>>>            End
11515>>>>>>
11515>>>>>        End
11515>>>>>>
11515>>>>>        
11515>>>>>        Function_Return (FieldPointer(hFld))
11516>>>>>    End_Function
11517>>>>>    
11517>>>>>    
11517>>>>>    Function Field_Current_UCAValue Integer iField Returns UChar[]
11519>>>>>        Integer hFld
11519>>>>>        Handle iFoc
11519>>>>>        UChar[] Data
11520>>>>>        
11520>>>>>        Get Field_Object iField to hFld // the object that handles this large text
11521>>>>>        If not hFld Begin
11523>>>>>            Send Data_set_Error iField DFERR_PROGRAM DD_EXTENDED_FIELD_NOT_DEFINED
11524>>>>>            Function_Return 0
11525>>>>>        End
11525>>>>>>
11525>>>>>        
11525>>>>>        
11525>>>>>        // This was extended to also make sure that the focus's server
11525>>>>>        // is this DD. This prevent the (very unlikely) case of a focus
11525>>>>>        // file/field being the right file/field but for a different view.
11525>>>>>        // 12.1: Also check operation mode, if within an operation assume that the
11525>>>>>        // ddos have the information they need from the deos. During a refresh we don't
11525>>>>>        // the data to be taken from a DEO - the DD buffer has the information you want. Note that
11525>>>>>        // we also changed all methods that set operation_mode to update the DD with the current
11525>>>>>        // DEO field, so the buffer is always correct.
11525>>>>>        Get Focus of Desktop to iFoc
11526>>>>>        If ( (OPERATION_MODE=MODE_WAITING) and ;            Extended_DEO_State(iFoc) and (Entry_Refresh_State(iFoc)=0) ) Begin
11528>>>>>            If ( Data_File(iFoc,0)=Main_File(Self) and Data_Field(iFoc,0)=iField and ;                IsDEOOwned(Self,iFoc) ) Begin
11530>>>>>                Send Update_Focus_Field
11531>>>>>            End
11531>>>>>>
11531>>>>>        End
11531>>>>>>
11531>>>>>        Get FieldArray of hFld to Data
11532>>>>>        Function_Return Data
11533>>>>>    End_Function
11534>>>>>    
11534>>>>>    Function File_Field_Current_Pointer_Value Integer iFile Integer iField Returns Address
11536>>>>>        Address pValue
11536>>>>>        Integer hDD
11536>>>>>        Get Data_Set iFile to hDD
11537>>>>>        If hDD Begin
11539>>>>>            Get Field_Current_Pointer_Value of hDD iField to pValue // return pointer to first byte of
11540>>>>>            Function_Return pValue                                  // data
11541>>>>>        End
11541>>>>>>
11541>>>>>    End_Function
11542>>>>>    
11542>>>>>    Procedure Set Field_Current_UCAValue Integer iField UChar[] Data
11544>>>>>        Set Field_Current_Pointer_Value iField (SizeOfArray(Data)) to (AddressOf(Data))
11545>>>>>    End_Procedure
11546>>>>>    
11546>>>>>    Procedure Set File_Field_Current_UCAValue Integer iFile Integer iField UChar[] Data
11548>>>>>        Integer hDD
11548>>>>>        Get Data_Set iFile to hDD
11549>>>>>        If hDD Begin
11551>>>>>            Set Field_Current_UCAValue of hDD iField to Data
11552>>>>>        End
11552>>>>>>
11552>>>>>    End_Procedure
11553>>>>>    
11553>>>>>    Function File_Field_Current_UCAValue Integer iFile Integer iField Returns UChar[]
11555>>>>>        UChar[] UCValue
11556>>>>>        Handle hDD
11556>>>>>        Get Data_Set iFile to hDD
11557>>>>>        If hDD Begin
11559>>>>>            Get Field_Current_UCAValue of hDD iField to UCValue // return pointer to first byte of
11560>>>>>            Function_Return UCValue                              // data
11561>>>>>        End
11561>>>>>>
11561>>>>>    End_Function
11562>>>>>    
11562>>>>>    // Create an extended field object for the passed field. .
11562>>>>>    // If field already exists, do nothing. This should only be used with
11562>>>>>    // text and binary fields.
11562>>>>>    Procedure DefineExtendedField Integer iField
11564>>>>>        Integer hFlds
11564>>>>>        Get Field_Objects to hFlds // this may not be created yet.
11565>>>>>        If not hFlds Begin         // if not created, create extended-fields wrapper
11567>>>>>            Object ExtendedFieldObjects is a FieldObjects
11569>>>>>                Move Self to hFlds
11570>>>>>            End_Object
11571>>>>>            Set Field_Objects to hFlds
11572>>>>>        End
11572>>>>>>
11572>>>>>        Send DefineFieldObject to hFlds iField
11573>>>>>    End_Procedure
11574>>>>>    
11574>>>>>    // create extended DD fields for all text and binary files
11574>>>>>    Procedure DefineAllExtendedFields
11576>>>>>        Integer iCount iType iField iFile
11576>>>>>        Get Main_file to iFile
11577>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iCount
11580>>>>>        For iField from 1 to iCount
11586>>>>>>
11586>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to iType
11589>>>>>            If (iType=DF_TEXT or iType=DF_BINARY) ; // if text or binary                Send DefineExtendedField iField
11592>>>>>        Loop
11593>>>>>>
11593>>>>>    End_Procedure
11594>>>>>    
11594>>>>>    // Update Extended fields to FileBuffer.  DD-Fields ---> FileBuffer
11594>>>>>    // Private
11594>>>>>    Procedure ExtendedFieldsUpdate Integer bSave
11596>>>>>        Integer hFlds
11596>>>>>        Get Field_Objects to hFlds
11597>>>>>        If hFlds ;            Send ExtendedFieldsUpdate to hFlds bSave
11600>>>>>    End_Procedure
11601>>>>>    
11601>>>>>    // Refresh Extended field from FileBuffer.  DD-Fields <--- FileBuffer
11601>>>>>    // Private
11601>>>>>    Procedure ExtendedFieldsRefresh Boolean bCleared
11603>>>>>        Integer hFlds
11603>>>>>        Get Field_Objects to hFlds
11604>>>>>        If hFlds ;            Send ExtendedFieldsRefresh to hFlds bCleared
11607>>>>>    End_Procedure
11608>>>>>    
11608>>>>>    // This procedure can be used to set the Item_Options of a field. This can
11608>>>>>    // be passed any number of arguments.
11608>>>>>    // Support the following special first parameters:
11608>>>>>    //      DD_CLEAR_FIELD_OPTIONS     - clear all following passed otpions
11608>>>>>    //      DD_CLEAR_ALL_FIELD_OPTIONS - clear all options
11608>>>>>    Procedure Set Field_Options Integer iField Integer iArg1 // plus unknown arguments
11610>>>>>        Integer iObj
11610>>>>>        Integer iOptions
11610>>>>>        Integer iOption
11610>>>>>        Integer iArg
11610>>>>>        Integer iClear
11610>>>>>        Integer iType
11610>>>>>        Move (Record_Buffer(Self)) to iObj
11611>>>>>        Get Item_Options of iObj iField to iOptions
11612>>>>>        //
11612>>>>>        For iArg from 2 to Num_Arguments
11618>>>>>>
11618>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
11619>>>>>            
11619>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
11622>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
11626>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
11630>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
11632>>>>>        Loop
11633>>>>>>
11633>>>>>        //
11633>>>>>        //Get_Attribute DF_FIELD_TYPE of (Main_File(self)) iField to iType
11633>>>>>        //If (iType=DF_TEXT or iType=DF_BINARY) ;            // if text of binary
11633>>>>>        //    Move (iOptions iOR DD_DISPLAYONLY) to iOptions // make sure DO is set
11633>>>>>        
11633>>>>>        Set Item_Options of iObj iField to iOptions
11634>>>>>    End_Procedure
11635>>>>>    
11635>>>>>    // This function returns all the item_options which have been set for
11635>>>>>    // a field. The value from the Record_Buffer object will be binary or'ed
11635>>>>>    // with constand Default_Item_Options and the DD_AUTOCLEAR constants when
11635>>>>>    // the Autoclear_State of the field has been set.
11635>>>>>    // Keep in mind that Autoclear is *not* kept in the Item_Options
11635>>>>>    // property.
11635>>>>>    Function Field_Options Integer iField Returns Integer
11637>>>>>        Function_Return (Item_Options(Record_Buffer(Self), iField))
11638>>>>>    End_Function
11639>>>>>    
11639>>>>>    Function Field_Option Integer iField Integer iOption Returns Integer
11641>>>>>        Integer iOptions
11641>>>>>        Integer iState
11641>>>>>        Get Item_Options of (Record_Buffer(Self)) iField to iOptions
11642>>>>>        // All bits must match for it to be True (e.g., displayonly requires noput & noenter)
11642>>>>>        Move ((iOptions iand iOption)=iOption) to iState
11643>>>>>        Function_Return iState
11644>>>>>    End_Function
11645>>>>>    
11645>>>>>    
11645>>>>>    Procedure Set Foreign_Field_Options Integer iField Integer iArg1 // Integer iOption
11647>>>>>        Integer iObj
11647>>>>>        Integer iOptions
11647>>>>>        Integer iOption
11647>>>>>        Integer iArg
11647>>>>>        Integer iClear
11647>>>>>        
11647>>>>>        
11647>>>>>        Move (Record_Buffer(Self)) to iObj
11648>>>>>        Get Aux_Value of iObj iField to iOptions
11649>>>>>        //
11649>>>>>        For iArg from 2 to Num_Arguments
11655>>>>>>
11655>>>>>            Move iArg& to iOption // tricky way to parse passed arguments
11656>>>>>            If (iOption = DD_CLEAR_ALL_FIELD_OPTIONS) ;                Move 0 to iOptions
11659>>>>>            Else If (iOption = DD_CLEAR_FIELD_OPTIONS) ;                Move 1 to iClear
11663>>>>>            Else If not iClear ;                Move (iOptions ior iOption) to iOptions
11667>>>>>            Else ; // only unset bits already set! Note multiple bits can be passed                Move (iOptions - (iOptions iand iOption)) to iOptions
11669>>>>>        Loop
11670>>>>>>
11670>>>>>        //
11670>>>>>        Set Aux_Value of iObj iField to iOptions
11671>>>>>    End_Procedure
11672>>>>>    
11672>>>>>    Function Foreign_Field_Options Integer iField Returns Integer
11674>>>>>        Integer iOpts
11674>>>>>        Get ForeignFieldOptions of Record_Buffer iField to iOpts
11675>>>>>        Function_Return iOpts
11676>>>>>    End_Function
11677>>>>>    
11677>>>>>    Procedure Set Foreign_Field_Option Integer iField Integer iOption Integer bSet
11679>>>>>        If bSet Begin
11681>>>>>            Set Foreign_Field_Options iField to iOption
11682>>>>>        End
11682>>>>>>
11682>>>>>        Else Begin
11683>>>>>            Set Foreign_Field_Options iField to DD_CLEAR_FIELD_OPTIONS iOption
11684>>>>>        End
11684>>>>>>
11684>>>>>    End_Procedure
11685>>>>>    
11685>>>>>    Function Foreign_Field_Option Integer iField Integer iOption Returns Integer
11687>>>>>        Integer iOptions
11687>>>>>        Integer iState
11687>>>>>        Get Foreign_Field_Options iField to iOptions
11688>>>>>        Move ((iOptions iand iOption)=iOption) to iState
11689>>>>>        Function_Return iState
11690>>>>>    End_Function
11691>>>>>    
11691>>>>>    // This procedure is being used by DEOs when they need to copy the item-
11691>>>>>    // options from the Data_Set. When the filenumber being passed is not
11691>>>>>    // equal to the Main_File of this Data_Set, then the Foreign_Field_Options
11691>>>>>    // will be applied.
11691>>>>>    Function File_Field_Options Integer iFile Integer iField Returns Integer
11693>>>>>        Integer iDSO
11693>>>>>        Integer iMain_File
11693>>>>>        Integer iOpts
11693>>>>>        Integer iRB
11693>>>>>        Integer iType
11693>>>>>        Get Main_File to iMain_File
11694>>>>>        If (iFile <> iMain_File) ;            Get Data_Set iFile to iDSO
11697>>>>>        Else ;            Move Self to iDSO
11699>>>>>        If iDSO Begin
11701>>>>>            Get Field_Options of iDSO iField to iOpts
11702>>>>>            // we consider the item to be foreign if the DDO main file is different than the one
11702>>>>>            // passed and we do not allow foreign (parent) new records to be saved.
11702>>>>>            If (iFile<>iMain_File and Allow_Foreign_New_Save_State(iDSO)=0) ; // Add Foreign_Field_Options                Move (iOpts ior Foreign_Field_Options(iDSO, iField)) to iOpts
11705>>>>>            Function_Return iOpts
11706>>>>>        End
11706>>>>>>
11706>>>>>    End_Function
11707>>>>>    
11707>>>>>    
11707>>>>>    // Procedure to set the message to be sent on item entry.
11707>>>>>    Procedure Set Field_Entry_msg Integer iField Integer iMsg
11709>>>>>        Set Item_Entry_MSG of (Record_Buffer(Self)) iField to iMsg
11710>>>>>    End_Procedure
11711>>>>>    
11711>>>>>    // Function to return the message to be sent on item entry.
11711>>>>>    Function Field_Entry_msg Integer iField Returns Integer
11713>>>>>        Function_Return (Item_Entry_MSG(Record_Buffer(Self), iField))
11714>>>>>    End_Function
11715>>>>>    
11715>>>>>    
11715>>>>>    // Procedure to send the message to be sent on item exit.
11715>>>>>    Procedure Set Field_Exit_msg Integer iField Integer iMsg
11717>>>>>        Set Item_Exit_MSG of (Record_Buffer(Self)) iField to iMsg
11718>>>>>    End_Procedure
11719>>>>>    
11719>>>>>    // Function to return the message to be set on item exit.
11719>>>>>    Function Field_Exit_msg Integer iField Returns Integer
11721>>>>>        Function_Return (Item_Exit_MSG(Record_Buffer(Self), iField))
11722>>>>>    End_Function
11723>>>>>    
11723>>>>>    // Procedure to set the message to be sent on item validation.
11723>>>>>    Procedure Set Field_Validate_msg Integer iField Integer iMsg
11725>>>>>        Set Item_Validate_MSG of (Record_Buffer(Self)) iField to iMsg
11726>>>>>    End_Procedure
11727>>>>>    
11727>>>>>    // Function to return the message to be set on item validation.
11727>>>>>    Function Field_Validate_msg Integer iField Returns Integer
11729>>>>>        Function_Return (Item_Validate_MSG(Record_Buffer(Self), iField))
11730>>>>>    End_Function
11731>>>>>    
11731>>>>>    
11731>>>>>    // Used to Get/Set the Prompt_Object for a Field.
11731>>>>>    Procedure Set Field_Prompt_Object Integer iField Integer iObj
11733>>>>>        Set Prompt_Object of (Record_Buffer(Self)) iField to iObj
11734>>>>>    End_Procedure
11735>>>>>    
11735>>>>>    Function Field_Prompt_Object Integer iField Returns Integer
11737>>>>>        Integer iObj
11737>>>>>        Get Prompt_Object of (Record_Buffer(Self)) iField to iObj
11738>>>>>        If (iObj = 0) ;            Get Prompt_Object of (Field_Attributes(Self)) iField to iObj
11741>>>>>        Function_Return iObj
11742>>>>>    End_Function
11743>>>>>    
11743>>>>>    Procedure Set Field_Zoom_Object Integer iField Integer iObj
11745>>>>>        Set Zoom_Object of (Record_Buffer(Self)) iField to iObj
11746>>>>>    End_Procedure
11747>>>>>    
11747>>>>>    Function Field_Zoom_Object Integer iField Returns Integer
11749>>>>>        Function_Return (Zoom_Object(Record_Buffer(Self), iField))
11750>>>>>    End_Function
11751>>>>>    
11751>>>>>    
11751>>>>>    Procedure Set Field_WebPrompt_Object Integer iField Handle hoObj
11753>>>>>        Set Field_WebPrompt_Object of FieldMask_Array iField to hoObj
11754>>>>>    End_Procedure
11755>>>>>    
11755>>>>>    Function Field_WebPrompt_Object Integer iField Returns Handle
11757>>>>>        Handle hoPrompt
11757>>>>>        Get Field_WebPrompt_Object of FieldMask_Array iField to hoPrompt
11758>>>>>        Function_Return hoPrompt
11759>>>>>    End_Function
11760>>>>>    
11760>>>>>    
11760>>>>>    // Used to Get/Set the Prompt_Object for a Field.
11760>>>>>    Function File_Field_Prompt_Object Integer iFile Integer iField Returns Integer
11762>>>>>        Integer iObj
11762>>>>>        Get File_Field_Property iFile iField GET_Field_Prompt_Object to iObj
11763>>>>>        Function_Return iObj
11764>>>>>    End_Function
11765>>>>>    
11765>>>>>    Function File_Field_Zoom_Object Integer iFile Integer iField Returns Integer
11767>>>>>        Integer iObj
11767>>>>>        Get File_Field_Property iFile iField GET_Field_Zoom_Object to iObj
11768>>>>>        Function_Return iObj
11769>>>>>    End_Function
11770>>>>>    
11770>>>>>    Function File_Field_WebPrompt_Object Integer iFile Integer iField Returns Handle
11772>>>>>        Handle hoPrompt
11772>>>>>        Get File_Field_Property iFile iField GET_Field_WebPrompt_Object to hoPrompt
11773>>>>>        Function_Return hoPrompt
11774>>>>>    End_Function
11775>>>>>    
11775>>>>>    // Return the extended validation type for this field.
11775>>>>>    Function Field_Validation_Type Integer iField Returns Integer
11777>>>>>        Integer iType
11777>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField ;            to iType
11778>>>>>        Function_Return iType
11779>>>>>    End_Function
11780>>>>>    
11780>>>>>    // Procedure to define a valid value range for a field.
11780>>>>>    Procedure Set Field_Value_Range Integer iField String sMin String sMax
11782>>>>>        Set Field_Value_Range of (Field_Attributes(Self)) iField ;            to sMin sMax
11783>>>>>    End_Procedure
11784>>>>>    
11784>>>>>    
11784>>>>>    // Procedure to define a validate table for a field.
11784>>>>>    Procedure Set Field_Value_Table Integer iField Integer iObj
11786>>>>>        Set Field_Value_Table of (Field_Attributes(Self)) iField ;            to iObj
11787>>>>>    End_Procedure
11788>>>>>    
11788>>>>>    // This provides a callback to the calling object (iObj) by passing this
11788>>>>>    // object the message iMsg for each item in the table. Note this works for
11788>>>>>    // all extended validation types (range, check, etc.)
11788>>>>>    Procedure Field_Fill_List Integer iField Integer iObj Integer iMsg
11790>>>>>        Send Field_Fill_list to (Field_Attributes(Self)) ;            iField iObj iMsg
11791>>>>>    End_Procedure
11792>>>>>    
11792>>>>>    Procedure File_Field_Fill_List Integer iFile Integer iField ;            Integer iObj Integer iMsg
11794>>>>>        Integer iDSO
11794>>>>>        Get Data_set iFile to iDSO
11795>>>>>        If iDSO ;            Send Field_Fill_list to iDSO iField iObj iMsg
11798>>>>>    End_Procedure
11799>>>>>    
11799>>>>>    // Returns the ID if any of the validation table for this object.
11799>>>>>    Function Field_Table_Object Integer iField Returns Integer
11801>>>>>        Integer iRval
11801>>>>>        Get Field_Table_Object of (Field_Attributes(Self)) iField to iRVal
11802>>>>>        Function_Return iRVal
11803>>>>>    End_Function
11804>>>>>    
11804>>>>>    Function File_Field_Table_Object Integer iFile Integer iField Returns Integer
11806>>>>>        Integer iDSO
11806>>>>>        Get Data_set iFile to iDSO
11807>>>>>        If iDSO ;            Function_Return (Field_Table_Object(iDSO,iField))
11810>>>>>    End_Function
11811>>>>>    
11811>>>>>    // Returns code description value for the passed string for the
11811>>>>>    // passed validation table object. Normally use field_value_description
11811>>>>>    Function Validation_Table_Description Integer iObj String sVal Returns String
11813>>>>>        String sDesc
11813>>>>>        If iObj ;            Get Find_Code_Description of iObj sVal to sDesc
11816>>>>>        Function_Return sDesc
11817>>>>>    End_Function
11818>>>>>    
11818>>>>>    // Returns the description value for the field's code value. This only
11818>>>>>    // works if you have a validation table - else it returns the field value
11818>>>>>    Function Field_Current_Description Integer iField Returns String
11820>>>>>        String sDesc
11820>>>>>        String sVal
11820>>>>>        Integer iObj
11820>>>>>        Get Field_Current_Value iField to sVal
11821>>>>>        Get Field_Table_Object iField to iObj
11822>>>>>        If iObj Begin
11824>>>>>            Get Validation_Table_Description iObj sVal to sDesc
11825>>>>>            If (sDesc="") ;                Move sVal to sDesc // if desc is blank, use value
11828>>>>>        End
11828>>>>>>
11828>>>>>        Else ;            Move sVal to sDesc
11830>>>>>        Function_Return sDesc
11831>>>>>    End_Function
11832>>>>>    
11832>>>>>    Function File_Field_Current_Description Integer iFile Integer iField Returns String
11834>>>>>        Integer iDSO
11834>>>>>        Get Data_set iFile to iDSO
11835>>>>>        If iDSO ;            Function_Return (Field_Current_Description(iDSO,iField))
11838>>>>>    End_Function
11839>>>>>    
11839>>>>>    // Required Messaging to Support Checkbox items in DEOs
11839>>>>>    //  Defines a field as a two item field and defines True and False values
11839>>>>>    Procedure Set Field_CheckBox_Values Integer iField String sTrue String sFalse
11841>>>>>        Set Field_CheckBox_Values of (Field_Attributes(Self)) iField ;            to sTrue sFalse
11842>>>>>    End_Procedure
11843>>>>>    
11843>>>>>    //    Returns a field's select_State based on the pased value
11843>>>>>    Function Field_Value_Select_State Integer iField String sValue Returns Integer
11845>>>>>        Function_Return (Field_Value_Select_State(Field_Attributes(Self),iField,sValue))
11846>>>>>    End_Function
11847>>>>>    
11847>>>>>    //    Returns a field's select_State based on the DD buffer contents
11847>>>>>    Function Field_Select_State Integer iField Returns Integer
11849>>>>>        String sValue
11849>>>>>        Get Field_Current_Value iField to sValue
11850>>>>>        Function_Return (Field_Value_Select_State(Self,iField,sValue))
11851>>>>>    End_Function
11852>>>>>    
11852>>>>>    //   Returns a file/field' select_State based on contents of DD buffer
11852>>>>>    Function File_Field_Select_State Integer iFile Integer iField Returns Integer
11854>>>>>        Integer iDSO
11854>>>>>        Get Data_set iFile to iDSO
11855>>>>>        If iDSO ;            Function_Return (Field_Select_State(iDSO,iField))
11858>>>>>    End_Function
11859>>>>>    
11859>>>>>    //   Returns a file/field' select_State based on passed value
11859>>>>>    Function File_Field_Value_Select_State Integer iFile Integer iField ;            String sValue Returns Integer
11861>>>>>        Integer iDSO
11861>>>>>        Get Data_set iFile to iDSO
11862>>>>>        If iDSO ;            Function_Return (Field_Value_Select_State(iDSO,iField,sValue))
11865>>>>>    End_Function
11866>>>>>    
11866>>>>>    // get the actual database value that corresponds to the boolean value
11866>>>>>    // passed.
11866>>>>>    Function Field_CheckBox_Value Integer iField Integer iState Returns String
11868>>>>>        Function_Return (Field_Checkbox_Value(Field_Attributes(Self),iField,iState))
11869>>>>>    End_Function
11870>>>>>    
11870>>>>>    Function File_Field_CheckBox_Value Integer iFile Integer iField Integer iState Returns String
11872>>>>>        Integer iDSO
11872>>>>>        Get Data_set iFile to iDSO
11873>>>>>        If iDSO ;            Function_Return (Field_Checkbox_Value(iDSO,iField,iState))
11876>>>>>    End_Function
11877>>>>>    
11877>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
11877>>>>>    Procedure Set Field_Select_State Integer iField Integer iState
11879>>>>>        String sValue
11879>>>>>        Get Field_Checkbox_Value iField iState to sValue
11880>>>>>        Set Field_Current_Value iField to sValue
11881>>>>>    End_Procedure
11882>>>>>    
11882>>>>>    // Set the buffer's value based on the state passed. This notifies DEOs
11882>>>>>    // if needed (set Field_Current_Value does this). First finds proper file
11882>>>>>    // DSO
11882>>>>>    Procedure Set File_Field_Select_State Integer iFile Integer iField Integer iState
11884>>>>>        Integer iDSO
11884>>>>>        Get Data_set iFile to iDSO
11885>>>>>        If iDSO ;            Set Field_Select_State of iDSO iField to iState
11888>>>>>    End_Procedure
11889>>>>>    
11889>>>>>    // Procedure to define a check string for a field.
11889>>>>>    Procedure Set Field_Value_Check Integer iField String sCheck
11891>>>>>        Set Field_Value_Check of (Field_Attributes(Self)) iField ;            to sCheck
11892>>>>>    End_Procedure
11893>>>>>    
11893>>>>>    // This function will be called indirectly by DEOs when an item is being
11893>>>>>    // entered, exited or needs validation. The first argument holds the
11893>>>>>    // fieldnumber for the field and the second holds the id of the message
11893>>>>>    // which can be send to retrieve the message which needs to be send for
11893>>>>>    // this Field/Event combination. The value of the second argument can be
11893>>>>>    // GET_Field_Entry_MSG, GET_Field_Exit_MSG or GET_Field_Validate_MSG.
11893>>>>>    Function Exec_Field_Message Integer iField Integer iMsg_ID Returns Integer
11895>>>>>        Integer iMsg
11895>>>>>        Integer iResult
11895>>>>>        String  sValue
11895>>>>>        Get iMsg_ID iField to iMsg
11896>>>>>        If iMsg Begin
11898>>>>>            Get Field_Current_Value iField to sValue
11899>>>>>            Get iMsg iField sValue to iResult
11900>>>>>        End
11900>>>>>>
11900>>>>>        Function_Return iResult
11901>>>>>    End_Function
11902>>>>>    
11902>>>>>    
11902>>>>>    // This function will be called from within DEOs when an item is being
11902>>>>>    // entered, exited or needs validation. The first argument holds the
11902>>>>>    // file number, the second argument holds the field and the third
11902>>>>>    // holds the id of the message  which can be send to retrieve the message
11902>>>>>    // which needs to be send for this File/Field/Event combination.
11902>>>>>    // The value of the second argument can be  GET_Field_Entry_MSG,
11902>>>>>    // GET_Field_Exit_MSG or GET_Field_Validate_MSG.
11902>>>>>    // This will redirect to the proper data-set object.
11902>>>>>    Function Exec_File_Field_Message Integer iFile Integer iField Integer iMsg_ID Returns Integer
11904>>>>>        Integer iDSO
11904>>>>>        Integer iResult
11904>>>>>        Get Data_set iFile to iDSO
11905>>>>>        If iDSO ;            Get Exec_Field_Message of iDSO iField iMsg_ID to iResult
11908>>>>>        Function_Return iResult
11909>>>>>    End_Function
11910>>>>>    
11910>>>>>    // Find the data-set whose main_file is the same as File#. The message
11910>>>>>    // Which_data_set includes updating parent files, we will throw those out.
11910>>>>>    // This has been augmented to search down the DDO tree if we do not find
11910>>>>>    // the DD with our quick C Which_Data_set search
11910>>>>>    Function Data_Set Integer iFile Returns Integer
11912>>>>>        Integer iTmp
11912>>>>>        Integer iDSO
11912>>>>>        Get Main_File to iTmp
11913>>>>>        If (iTmp = iFile) ;            Function_Return Self
11916>>>>>        Get Which_Data_Set iFile to iDSO
11917>>>>>        If iDSO Begin
11919>>>>>            // check that DS's main-file is the File (and not a parent file)
11919>>>>>            Get Main_File of iDSO to iTmp
11920>>>>>            If (iTmp = iFile) ;                Function_Return iDSO
11923>>>>>        End
11923>>>>>>
11923>>>>>        
11923>>>>>        // This really should have succeeded by now. If not we need to do a
11923>>>>>        // downward sweep looking for DD. This will be a slower process since it
11923>>>>>        // involves flex level DDO structure traversal. We should very rarely ever
11923>>>>>        // get to this point. If we do, it takes longer!
11923>>>>>        
11923>>>>>        // Unlike other traversals we will mark and check in a single
11923>>>>>        // step.
11923>>>>>        // This Mark_Id creates a sequence Id for this clear. This way
11923>>>>>        // DSOs only get cleared one time during this process.
11923>>>>>        Send IncrementCurrentMarkId
11924>>>>>        Get Private.Data_set iFile to iDSO // this does the recursive downward search
11925>>>>>        Function_Return iDSO
11926>>>>>    End_Function
11927>>>>>    
11927>>>>>    Function Private.Data_Set Integer iFile Returns Integer
11929>>>>>        Integer iMax
11929>>>>>        Integer iDSO hDD
11929>>>>>        Integer iCount
11929>>>>>        
11929>>>>>        If (iFile=Main_file(Self)) ;            Function_Return Self
11932>>>>>        
11932>>>>>        // We are only looking at sequence ID.
11932>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
11933>>>>>        
11933>>>>>        // recurse Down first, since we already tried upward direction.
11933>>>>>        Get Data_Set_Client_Count to iMax
11934>>>>>        Decrement iMax
11935>>>>>        For iCount from 0 to iMax
11941>>>>>>
11941>>>>>            Get Data_Set_Client iCount to iDSO
11942>>>>>            // If already cleared during this sequence...do nothing
11942>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
11944>>>>>                Get Private.Data_Set of iDSO iFile to hDD
11945>>>>>                If hDD ;                    Function_Return hDD // when found...get out
11948>>>>>            End
11948>>>>>>
11948>>>>>        Loop
11949>>>>>>
11949>>>>>        // recurse up server list next. We do this 2nd because it is
11949>>>>>        // the less likely path for success.
11949>>>>>        Get Data_Set_Server_Count to iMax
11950>>>>>        Decrement iMax
11951>>>>>        For iCount from 0 to iMax
11957>>>>>>
11957>>>>>            Get Data_Set_Server iCount to iDSO
11958>>>>>            // If already cleared during this sequence...do nothing
11958>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) Begin
11960>>>>>                Get Private.Data_Set of iDSO iFile to hDD
11961>>>>>                If hDD ;                    Function_Return hDD // when found...get out
11964>>>>>            End
11964>>>>>>
11964>>>>>        Loop
11965>>>>>>
11965>>>>>        Function_Return 0 // if here, our traversal has failed.
11966>>>>>    End_Function
11967>>>>>    
11967>>>>>    // These methods can be used to set/get a field property in a flexible
11967>>>>>    // way. The first two argument are the file- and fieldnumber followed by
11967>>>>>    // the ID of the message that should be send. The last argument should
11967>>>>>    // be the value to set or the variable to store the value in.
11967>>>>>    Procedure Set File_Field_Property Integer iFile Integer iField Integer iMsg String sValue
11969>>>>>        Integer iDSO
11969>>>>>        Get Data_Set iFile to iDSO
11970>>>>>        If iDSO Begin
11972>>>>>            Set iMsg of iDSO iField to sValue
11973>>>>>            Procedure_Return sValue
11974>>>>>        End
11974>>>>>>
11974>>>>>    End_Procedure
11975>>>>>    
11975>>>>>    Function File_Field_Property Integer iFile Integer iField Integer iMsg Returns Integer
11977>>>>>        Integer iDSO
11977>>>>>        String  sValue
11977>>>>>        Get Data_Set iFile to iDSO
11978>>>>>        If iDSO Begin
11980>>>>>            Get iMsg of iDSO iField to sValue
11981>>>>>            Function_Return sValue
11982>>>>>        End
11982>>>>>>
11982>>>>>    End_Function
11983>>>>>    
11983>>>>>    // This procedure will return the number of fields in the object
11983>>>>>    Function Field_Count Returns Integer
11985>>>>>        Function_Return (Item_Count(Record_Buffer(Self)) - 1)
11986>>>>>    End_Function
11987>>>>>    
11987>>>>>    // This procedure will clear all flags in the visited_fields string so
11987>>>>>    // that all field will be validated on the next requests.
11987>>>>>    Procedure Clear_Visited_Fields
11989>>>>>        // this clears field visitation marks
11989>>>>>        Set Visited_Fields to (Repeat(" ", Field_Count(Self)))
11990>>>>>    End_Procedure
11991>>>>>    
11991>>>>>    // Private.Initialize_Visited
11991>>>>>    // This procedure will be called when validations (and perhaps other
11991>>>>>    // events) is requested. It clears the visited marks and then proceeds
11991>>>>>    // to clear the marks up the server tree.
11991>>>>>    // This is passed two parameters: Up_and_down, If true upward and downward
11991>>>>>    // initialize. If Clear_Fields also clear the field string
11991>>>>>    Procedure Private.Initialize_Visited Integer Up_and_Down Integer Clear_Fields
11993>>>>>        Integer iMax
11993>>>>>        Integer iDSO
11993>>>>>        Integer iCount
11993>>>>>        
11993>>>>>        // recurse up server list first. Only recurse up
11993>>>>>        Get Data_Set_Server_Count to iMax
11994>>>>>        Decrement iMax
11995>>>>>        For iCount from 0 to iMax
12001>>>>>>
12001>>>>>            Get Data_Set_Server iCount to iDSO
12002>>>>>            // If already cleared during this sequence...do nothing
12002>>>>>            If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                Send Private.Initialize_Visited to iDSO False Clear_Fields
12005>>>>>        Loop
12006>>>>>>
12006>>>>>        
12006>>>>>        If Clear_Fields ;            Send Clear_Visited_Fields // clear all markers in this object
12009>>>>>        // this clears the visited mark for the entire object
12009>>>>>        Set Visited_State to False
12010>>>>>        Set DownDelete_State to False
12011>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id
12012>>>>>        
12012>>>>>        // If Up_and_Down recurse Down server list
12012>>>>>        If Up_and_Down Begin
12014>>>>>            Get Data_Set_Client_Count to iMax
12015>>>>>            Decrement iMax // **EK** This line was missing
12016>>>>>            For iCount from 0 to iMax
12022>>>>>>
12022>>>>>                Get Data_Set_Client iCount to iDSO
12023>>>>>                // If already cleared during this sequence...do nothing
12023>>>>>                If (Last_Mark_Sequence_id(iDSO)<>DD_Current_mark_id) ;                    Send Private.Initialize_Visited to iDSO True Clear_Fields
12026>>>>>            Loop
12027>>>>>>
12027>>>>>        End
12027>>>>>>
12027>>>>>    End_Procedure
12028>>>>>    
12028>>>>>    
12028>>>>>    // Clears Visited marks and (maybe) field visited marks in all required
12028>>>>>    // DSOs. If Up_and_Down is TRUE DSOs are marked up and Down (delete style)
12028>>>>>    // propagation. If False, DSOs are marked up (save style). This does not
12028>>>>>    // have a mode to mark ALL DSOs in a structure. (Not needed so far).
12028>>>>>    // If Clear_Fields is T the field string marker is also cleared.
12028>>>>>    // The method of using the global integer DD_Current_Mark_ID is an opt-
12028>>>>>    // imizer. This is private - do not tamper with it!
12028>>>>>    // Note that Intialize_Visited does not always Clear all DDOs in the structure. When
12028>>>>>    // Up_and_Down is true, it is marking all DDOs that will participate in a cascade delete
12028>>>>>    // which may not be all DDOs in the structure. If you want to initialize all DDOs use InitializeAllVisited
12028>>>>>    Procedure Initialize_Visited Integer Up_and_Down Integer Clear_Fields
12030>>>>>        Send IncrementCurrentMarkId
12031>>>>>        Send Private.Initialize_Visited Up_and_Down Clear_Fields
12032>>>>>    End_Procedure
12033>>>>>    
12033>>>>>    Procedure InitializeAllVisited2
12035>>>>>        Integer iMax iCount
12035>>>>>        Handle hoDSO
12035>>>>>        
12035>>>>>        Set Visited_State to False
12036>>>>>        Set Last_Mark_Sequence_id to DD_Current_mark_id // marks this as visited
12037>>>>>        
12037>>>>>        // recurse up server list.
12037>>>>>        Get Data_Set_Server_Count to iMax
12038>>>>>        For iCount from 0 to (iMax-1)
12044>>>>>>
12044>>>>>            Get Data_Set_Server iCount to hoDSO
12045>>>>>            // If already cleared during this sequence...do nothing
12045>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 of hoDSO
12048>>>>>        Loop
12049>>>>>>
12049>>>>>        
12049>>>>>        // recurse down client list.
12049>>>>>        Get Data_Set_Client_Count to iMax
12050>>>>>        For iCount from 0 to (iMax-1)
12056>>>>>>
12056>>>>>            Get Data_Set_Client iCount to hoDSO
12057>>>>>            // If already cleared during this sequence...do nothing
12057>>>>>            If (Last_Mark_Sequence_id(hoDSO)<>DD_Current_mark_id) ;                Send InitializeAllVisited2 to hoDSO
12060>>>>>        Loop
12061>>>>>>
12061>>>>>    End_Procedure
12062>>>>>    
12062>>>>>    // clears visited flag for *all* ddos in the structure.
12062>>>>>    Procedure InitializeAllVisited
12064>>>>>        Send IncrementCurrentMarkId
12065>>>>>        Send InitializeAllVisited2
12066>>>>>    End_Procedure
12067>>>>>    
12067>>>>>    
12067>>>>>    // Internal recursive message to check file connections. Called from
12067>>>>>    // Valid_connections only. Private message
12067>>>>>    Function Private.Valid_Structure Integer Up_And_Down Returns Integer
12069>>>>>        Integer iRval iCount iMax
12069>>>>>        Handle iDSO iPDSO
12069>>>>>        Integer iPMax iPCount iPMain
12069>>>>>        Boolean bUpDown bNull bCascadeNull bDown
12069>>>>>        
12069>>>>>        // Check Current Connections
12069>>>>>        Get Valid_Servers to iRval           // always check servers
12070>>>>>        If (iRval=0 and Up_and_Down) ;       // check Clients if required            Get Valid_Clients to iRval
12073>>>>>        Set Visited_State to True
12074>>>>>        
12074>>>>>        // Ask Server data-sets to check their server connections
12074>>>>>        If not iRval Begin // check up
12076>>>>>            Get Data_Set_Server_Count to iMax
12077>>>>>            Decrement iMax
12078>>>>>            For iCount from 0 to iMax
12084>>>>>>
12084>>>>>                Get Data_Set_Server iCount to iDSO
12085>>>>>                If not (Visited_state(iDSO)) ;                    Get Private.Valid_Structure of iDSO False to iRVal
12088>>>>>            Until iRval
12090>>>>>        End
12090>>>>>>
12090>>>>>        
12090>>>>>        // If required, Ask Clients to check their server and client connections
12090>>>>>        //
12090>>>>>        If (iRval=0 and Up_and_Down) Begin // check down
12092>>>>>            Get Data_Set_Client_Count to iMax
12093>>>>>            Decrement iMax
12094>>>>>            For iCount from 0 to iMax
12100>>>>>>
12100>>>>>                Get Data_Set_Client iCount to iDSO
12101>>>>>                If not (Visited_state(iDSO)) Begin
12103>>>>>                    Get Data_Set_Server_Count of iDSO to iPMax
12104>>>>>                    // test if all deletable parents for a non parent null allowed/cascade delete null
12104>>>>>                    For iPCount from 0 to (iPMax-1)
12110>>>>>>
12110>>>>>                        Get Data_Set_Server of iDSO iPCount to iPDSO
12111>>>>>                        Get DownDelete_State of iPDSO to bDown
12112>>>>>                        If (bDown) Begin
12114>>>>>                            Get Main_File of iPDSO to iPMain
12115>>>>>                            Get IsNullParentAllowed of iDSO iPMain to bNull
12116>>>>>                            Get IsCascadeDeleteNull of iDSO iPMain to bCascadeNull
12117>>>>>                            Move (not(bNull) or not(bCascadeNull)) to bUpDown
12118>>>>>                        End
12118>>>>>>
12118>>>>>                    Until bUpDown
12120>>>>>                    Get Private.Valid_Structure of iDSO bUpDown to iRVal
12121>>>>>                End
12121>>>>>>
12121>>>>>            Until iRval
12123>>>>>        End
12123>>>>>>
12123>>>>>        
12123>>>>>        Function_Return iRVal
12124>>>>>        
12124>>>>>    End_Function
12125>>>>>    
12125>>>>>    // Validate data-set updating connections against required connections
12125>>>>>    // Pass: Up_and_down=T if we should check Server and Client connections
12125>>>>>    //                  =F is we only check servers
12125>>>>>    // Ret: 0 if ok, Missing File# if not ok.
12125>>>>>    // Up_And_Down should be true when testing for cascade delete structures and
12125>>>>>    // false when testing for save / delete-no-cascade structures
12125>>>>>    Function Valid_Structure Integer Up_And_Down Returns Integer
12127>>>>>        Send Initialize_Visited Up_and_Down False // False=don't clear field marks
12128>>>>>        If (Up_And_Down) Begin
12130>>>>>            Send MarkDDOsForCascadeDelete
12131>>>>>        End
12131>>>>>>
12131>>>>>        Function_Return (Private.Valid_Structure(Self,Up_and_Down))
12132>>>>>    End_Function
12133>>>>>    
12133>>>>>    // mark all DDOs which are part of this deletes cascade delete tree
12133>>>>>    // mark this and all clients as Downward deletable. This includes
12133>>>>>    // cacscade delete and cascade set to null (not for cascade_delete_state=F)
12133>>>>>    Procedure MarkDDOsForCascadeDelete
12135>>>>>        Integer iMax  iCount
12135>>>>>        Boolean bDown
12135>>>>>        Handle hoDDO
12135>>>>>        Set DownDelete_State to True
12136>>>>>        Get Data_Set_Client_Count to iMax
12137>>>>>        For iCount from 0 to (iMax-1)
12143>>>>>>
12143>>>>>            Get Data_Set_Client iCount to hoDDO
12144>>>>>            Get DownDelete_State of hoDDO to bDown
12145>>>>>            If not bDown Begin // circular DDO test - never do this
12147>>>>>                Send MarkDDOsForCascadeDelete of hoDDO
12148>>>>>            End
12148>>>>>>
12148>>>>>        Loop
12149>>>>>>
12149>>>>>    End_Procedure
12150>>>>>    
12150>>>>>    
12150>>>>>    // This function will execute the validation message for each field within
12150>>>>>    // this object. If DoAllFG is true all items are validated. If false
12150>>>>>    // only unvisited items are checked.
12150>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
12150>>>>>    // do something with the possible cascade of errors
12150>>>>>    // if the err returns DFERR_ENTER_VALID_REC_ID we will not continue
12150>>>>>    // the validation (the other fields will be bad). This works best if the
12150>>>>>    // findreq appears as one of the first fields in the file (which is almost
12150>>>>>    // always the case
12150>>>>>    Function Validate_Fields Integer DoAllFg Integer bNoStop Returns Integer
12152>>>>>        Integer iRetval
12152>>>>>        Integer iMax
12152>>>>>        Integer iCount
12152>>>>>        Integer iFile
12152>>>>>        Integer iErr
12152>>>>>        String  sVS
12152>>>>>        Get Visited_Fields to sVS
12153>>>>>        Get Field_Count to iMax
12154>>>>>        Get Main_File to iFile
12155>>>>>        For iCount from 1 to iMax
12161>>>>>>
12161>>>>>            If (DoAllFG or Mid(sVS, 1, iCount)=" ") Begin
12163>>>>>                Get Validate_Field iCount to iErr
12164>>>>>                If iErr Begin
12166>>>>>                    Move iErr to iRetVal
12167>>>>>                    // error occurred. If not no-stop or the error is
12167>>>>>                    // a findreq error - we are done.
12167>>>>>                    If (not(bNoStop) or iRetVal=DFERR_ENTER_VALID_REC_ID) ;                        Function_Return iRetVal
12170>>>>>                End
12170>>>>>>
12170>>>>>            End
12170>>>>>>
12170>>>>>        Loop
12171>>>>>>
12171>>>>>        Function_Return iRetval
12172>>>>>    End_Function
12173>>>>>    
12173>>>>>    // 17.0 - added support for null-parents. If null parents allowed, req lets it through
12173>>>>>    Function Validate_Required Integer iField Returns Integer
12175>>>>>        Boolean bNull bErr
12175>>>>>        
12175>>>>>        Move (trim(Field_Current_Value(Self,iField))='') to bErr
12176>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTRY_REQUIRED ""
12179>>>>>        Function_Return bErr
12180>>>>>    End_Function
12181>>>>>    
12181>>>>>    // return true if we should skip validation for this field. This can happen with Null allowed parents.
12181>>>>>    // if this is foreign, new and has no changes and is null allowed we will skip.
12181>>>>>    Function SkipValidate Integer iField Returns Boolean
12183>>>>>        Boolean bSkip bFieldChanged bEmpty
12183>>>>>        String sValue
12183>>>>>        
12183>>>>>        If (OPERATION_ORIGIN<>Self and not(HasRecord(Self)) and not(changed_state(Self))) Begin
12185>>>>>            // We must also check field_changed_state and only skip if this is not changed.
12185>>>>>            Get Field_Changed_State iField to bFieldChanged
12186>>>>>            // Retain and remember may set field_changed_state to true even when empty. If this field is changed
12186>>>>>            // but its value is empty we assume it is a candidate for Null checking, so we will set field-changed to false
12186>>>>>            If bFieldChanged Begin
12188>>>>>                Get Field_Current_Value iField to sValue
12189>>>>>                Get IsEmptyField iField sValue to bEmpty
12190>>>>>                If bEmpty Begin
12192>>>>>                    Move False to bFieldChanged
12193>>>>>                End
12193>>>>>>
12193>>>>>            End
12193>>>>>>
12193>>>>>            If (not(bFieldChanged)) Begin
12195>>>>>                // we must find the child that points to this DD, starting with operation_origin. If a child
12195>>>>>                // is found, it will be in array position 1 (0 is self, 1 is child)
12195>>>>>                Get IsNullParentOrAncestor to bSkip
12196>>>>>            End
12196>>>>>>
12196>>>>>        End
12196>>>>>>
12196>>>>>        Function_Return bSkip
12197>>>>>    End_Function
12198>>>>>    
12198>>>>>    
12198>>>>>    // This will tell us if this DD can be treated as either a null parent
12198>>>>>    // or an ancestor of a null parent. This should only be called for a DD
12198>>>>>    // that is a candidate for this meaning that it does not have a change.
12198>>>>>    // We will test if its child allows this parent to be null or if this
12198>>>>>    // is in the path of an allowed null parent. We assume that parents of
12198>>>>>    // null parents will also be null. This is used to test if validations are
12198>>>>>    // needed.
12198>>>>>    Function IsNullParentOrAncestor Returns Boolean
12200>>>>>        Handle[] hoDDs
12201>>>>>        Integer i iSize iMain
12201>>>>>        Boolean bNullAllowed
12201>>>>>        // gets an array where 0 is self, 1 is parent, 2 is grandparent, and the
12201>>>>>        // last item is the operation_origin.
12201>>>>>        Send DDOServerPath of operation_origin Self (&hoDDs)
12202>>>>>        Move (SizeOfArray(hoDDs)) to iSize
12203>>>>>        If (iSize) Begin
12205>>>>>            // see if the immediate child allows this to be null.
12205>>>>>            Get Main_File to iMain
12206>>>>>            Get IsNullParentAllowed of hoDDs[1] iMain to bNullAllowed
12207>>>>>            
12207>>>>>            // if null not allowed, see if this is an ancestor to a null allowed
12207>>>>>            // parent where all DDs in this path are unchanged. For example:
12207>>>>>            // G.DD <- P.DD <- C.DD where we C.DD allows P.DD to be null and we
12207>>>>>            // want to test if G.DD needs validation
12207>>>>>            Move 1 to i
12208>>>>>            While (not(bNullAllowed) and (i+1<iSize) and not(changed_state(hoDDs[i])) )
12212>>>>>                Get Main_File of hoDDs[i] to iMain
12213>>>>>                Get IsNullParentAllowed of hoDDs[i+1] iMain to bNullAllowed
12214>>>>>                Increment i
12215>>>>>            Loop
12216>>>>>>
12216>>>>>            
12216>>>>>        End
12216>>>>>>
12216>>>>>        Function_Return bNullAllowed
12217>>>>>    End_Function
12218>>>>>    
12218>>>>>    
12218>>>>>    Function Validate_FindReq Integer iField Returns Integer
12220>>>>>        Integer bErr iOpts
12220>>>>>        // if no current record, we have not found the required record.
12220>>>>>        Move (not(HasRecord(Self))) to bErr
12221>>>>>        // We also need to check if the field is changed. If the field is changed and this
12221>>>>>        // is an autofind field, this indicates that an autofind was attempted and failed. We
12221>>>>>        // can't jut rely on current_record because a failed autofind restores the old current
12221>>>>>        // record. For this to work, DEOs must set the DD field's changed_state to true on
12221>>>>>        // no-put fields (dd_deomx.pkg was changed to do this).
12221>>>>>        If (not(bErr) and field_changed_state(Self,iField)) Begin
12223>>>>>            Get Field_Options iField to iOpts
12224>>>>>            Move ( ((iOpts iand DD_AUTOFIND)=DD_AUTOFIND) or ;                ((iOpts iand DD_AUTOFIND_GE)=DD_AUTOFIND_GE) ) ;                to bErr
12225>>>>>        End
12225>>>>>>
12225>>>>>        If bErr ;            Send Data_set_Error iField DFERR_ENTER_VALID_REC_ID ""
12228>>>>>        Function_Return bErr
12229>>>>>    End_Function
12230>>>>>    
12230>>>>>    // This function will be called to validate a field.
12230>>>>>    // mark field currently being validated
12230>>>>>    // Altered to Check DD options (required, findreq)
12230>>>>>    Function Validate_Field Integer iField Returns Integer
12232>>>>>        Integer iResult
12232>>>>>        Integer iMsg
12232>>>>>        Integer iObj
12232>>>>>        String  sValue
12232>>>>>        Integer iFile
12232>>>>>        Integer iOpts iMain
12232>>>>>        Boolean bSkipValidate
12232>>>>>        Handle[] hoDDs
12233>>>>>        
12233>>>>>        Set Current_Validate_Field to iField
12234>>>>>        
12234>>>>>        // test if we should skip validation on this field
12234>>>>>        Get SkipValidate iField to bSkipValidate
12235>>>>>        
12235>>>>>        If (not(bSkipValidate)) Begin
12237>>>>>            
12237>>>>>            Move (Record_Buffer(Self)) to iObj
12238>>>>>            Get Main_File to iFile
12239>>>>>            
12239>>>>>            // Check for DD option failures: required, find_required
12239>>>>>            // "File_field" gets regular and foreign fields as needed
12239>>>>>            //Get File_Field_Options iFile iField to iOpts
12239>>>>>            Get Field_Options iField to iOpts  // get reg options
12240>>>>>            // if this is not the DDO that started the validation, we will assume that
12240>>>>>            // this is foreign. Operation_origin is set in Request_Validate
12240>>>>>            // If foreign (as defined above) and we do not allow new saves when
12240>>>>>            // foreign, we will consider this to be foreign and add foreign options
12240>>>>>            If (Operation_Origin<>Self and ;                Allow_Foreign_New_Save_State(Self)=0)  ;                Move (iOpts ior Foreign_Field_Options(Self, iField)) to iOpts
12243>>>>>            
12243>>>>>            
12243>>>>>            // Check for FindReq first. If it fails, set iResult to DFERR_ENTER_VALID_REC_ID so
12243>>>>>            // the calling function knows that a findreq failed. Always do this validation first
12243>>>>>            If (iOpts iand DD_FINDREQ) ;                Get Validate_FindReq  iField to iResult
12246>>>>>            If iResult Begin
12248>>>>>                Send AddDDHasFindReqError
12249>>>>>                Move DFERR_ENTER_VALID_REC_ID to iResult
12250>>>>>            End
12250>>>>>>
12250>>>>>            Else Begin
12251>>>>>                
12251>>>>>                If (iOpts iand DD_REQUIRED) ;                    Get Validate_Required iField to iResult
12254>>>>>                
12254>>>>>                If (iResult=0) Begin
12256>>>>>                    // First execute the user defined validation message
12256>>>>>                    Get Item_Validate_MSG of iObj iField to iMsg
12257>>>>>                    If iMsg Begin
12259>>>>>                        Get Field_Current_Value iField to sValue
12260>>>>>                        Get iMsg iField sValue to iResult
12261>>>>>                    End
12261>>>>>>
12261>>>>>                End
12261>>>>>>
12261>>>>>                
12261>>>>>                // Check for keys
12261>>>>>                If (iResult=0 and Key_Field_State(Self, iField)) ;                    Get Validate_Key_Field iField to iResult
12264>>>>>                
12264>>>>>                // Do extended validations
12264>>>>>                If (iResult=0) ;                    Get Validate_Field of (Field_Attributes(Self)) iField to iResult
12267>>>>>            End
12267>>>>>>
12267>>>>>        End
12267>>>>>>
12267>>>>>        
12267>>>>>        Set Current_Validate_Field to 0
12268>>>>>        // Mark this field being validated
12268>>>>>        Get Visited_Fields to sValue
12269>>>>>        Set Visited_Fields to (Overstrike("X", sValue, iField))
12270>>>>>        
12270>>>>>        Function_Return iResult
12271>>>>>        
12271>>>>>    End_Function
12272>>>>>    
12272>>>>>    
12272>>>>>    // This function will be called to validate a field.
12272>>>>>    Function File_Field_Validate_Field Integer iFile Integer iField Returns Integer
12274>>>>>        Integer iDSO
12274>>>>>        Integer iResult
12274>>>>>        Integer hOldOrigin
12274>>>>>        Get Data_Set iFile to iDSO
12275>>>>>        If not iDSO ;            Function_Return 0
12278>>>>>        
12278>>>>>        // This function is only called by the DEOs.
12278>>>>>        // It is possible for validate_item when called as part of
12278>>>>>        // request_validate to get called more than once
12278>>>>>        // when a field is foreign (it is attached to both its DDO and the
12278>>>>>        // child-main ddo). This makes sure the validation is only called once.
12278>>>>>        // (vdf7 change: previously we set OpMode to Mode_Saving and checked that, now we have
12278>>>>>        // a mode just for request_validate).
12278>>>>>        If (Operation_Mode=MODE_VALIDATING and ;         // if from request_validate            Mid(Visited_Fields(iDSO), 1, iField)="X" ) ; // and already marked            Function_Return 0                         // skip it
12281>>>>>        
12281>>>>>        Move Operation_origin to hOldOrigin
12282>>>>>        
12282>>>>>        // if from request_validate operation_origin will be set and should not
12282>>>>>        // be reset here.
12282>>>>>        If (OPERATION_ORIGIN=0) Begin
12284>>>>>            Move Self to Operation_Origin
12285>>>>>        End
12285>>>>>>
12285>>>>>        
12285>>>>>        Get Validate_Field of iDSO iField to iResult
12286>>>>>        Move hOldOrigin to Operation_Origin
12287>>>>>        Function_Return iResult
12288>>>>>    End_Function
12289>>>>>    
12289>>>>>    // This function will be called to check if a key has been changed.
12289>>>>>    Function Validate_Key_Field Integer iField Returns Integer
12291>>>>>        String  sOld_Value
12291>>>>>        String  sNew_Value
12291>>>>>        String  sKeys
12291>>>>>        Integer iState
12291>>>>>        Boolean bMultiKeys
12291>>>>>        Get Protect_Key_State to iState
12292>>>>>        If iState Begin
12294>>>>>            Get Key_Value to sNew_Value
12295>>>>>            // Only check existing records.
12295>>>>>            If (HasRecord(Self)) Begin
12297>>>>>                Get Existing_Key_Value to sOld_Value
12298>>>>>                If (sNew_Value <> sOld_Value) Begin
12300>>>>>                    // we have an error. If there is only one key field we know
12300>>>>>                    // where the field is and we can report that field. If we have
12300>>>>>                    // multiple key fields, we don't really know where the offending key change
12300>>>>>                    // is, so we will not report a field.
12300>>>>>                    Get Key_Fields to sKeys
12301>>>>>                    Move (Pos("X",sKeys)<>RightPos("X",sKeys)) to bMultiKeys
12302>>>>>                    Send Data_set_Error (If(bMultiKeys, -1, iField)) 0 DD_TEXT_NO_KEY_CHANGE_ALLOWED
12303>>>>>                    Function_Return 1
12304>>>>>                End
12304>>>>>>
12304>>>>>            End
12304>>>>>>
12304>>>>>        End
12304>>>>>>
12304>>>>>    End_Function
12305>>>>>    
12305>>>>>    
12305>>>>>    // During request_validate process tell us if this DD has had a find_request error. This
12305>>>>>    // is handled by the DD that originated the request_validate. Very private
12305>>>>>    Function DDHasFindReqError Returns Boolean
12307>>>>>        Handle[] DDsWithFindReqErrors
12308>>>>>        Integer iIndex
12308>>>>>        If (OPERATION_ORIGIN) Begin
12310>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
12311>>>>>            Move (SearchArray(Self,DDsWithFindReqErrors)) to iIndex
12312>>>>>            Function_Return (iIndex<>-1)
12313>>>>>        End
12313>>>>>>
12313>>>>>    End_Function
12314>>>>>    
12314>>>>>    // During a request_validate a find_request error has occurred. Add this DD
12314>>>>>    // to list of DDs that have this error. This is handled by the DD that
12314>>>>>    // originated the request_validate.  Very private
12314>>>>>    Procedure AddDDHasFindReqError
12316>>>>>        Handle[] DDsWithFindReqErrors
12317>>>>>        If (OPERATION_ORIGIN) Begin
12319>>>>>            Get pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
12320>>>>>            Move Self to DDsWithFindReqErrors[SizeOfArray(DDsWithFindReqErrors)]
12321>>>>>            Set pDDsWithFindReqErrors of OPERATION_ORIGIN to DDsWithFindReqErrors
12322>>>>>        End
12322>>>>>>
12322>>>>>    End_Procedure
12323>>>>>    
12323>>>>>    // This function will execute the validation message for each field of the
12323>>>>>    // data set and all of its parents in parent first order.
12323>>>>>    // Pass: DoALLFg bNoStop
12323>>>>>    // Added bNoStop, If true, all items are validated. It is up to you to
12323>>>>>    // do something with the possible cascade of errors
12323>>>>>    Function Validate_Data_Sets Integer DoAllFg Integer bNoStop Returns Integer
12325>>>>>        Integer iDSO
12325>>>>>        Integer iRetval
12325>>>>>        Integer iCount
12325>>>>>        Integer iMax
12325>>>>>        Integer bErr
12325>>>>>        Boolean bDDHasFindReqError
12325>>>>>        // ShowLn "Validate_Data_Sets in Data_Set in " (Name(self))
12325>>>>>        // Validate if not foreign, or foreign new saves allowed, or
12325>>>>>        // foreign validation is supported (it normally is)
12325>>>>>        If (Operation_Origin=Self or ;            Allow_Foreign_New_Save_State(Self) or ;            Validate_Foreign_File_State(Self)) Begin
12327>>>>>            
12327>>>>>            If (bNoStop) Begin
12329>>>>>                // if do all, it is possible that this DD as a find-req error. If so there is no
12329>>>>>                // need to look for more errors in this DD or its parents. This makes the do all checking
12329>>>>>                // a little more intelligent and doesn't return a bunch of errors when it is not needed
12329>>>>>                Get DDHasFindReqError to bDDHasFindReqError
12330>>>>>            End
12330>>>>>>
12330>>>>>            
12330>>>>>            If (not(bDDHasFindReqError)) Begin
12332>>>>>                Get Data_Set_Server_Count to iMax
12333>>>>>                Decrement iMax
12334>>>>>                For iCount from 0 to iMax
12340>>>>>>
12340>>>>>                    Get Data_Set_Server iCount to iDSO
12341>>>>>                    If not (Visited_state(iDSO)) Begin
12343>>>>>                        Get Validate_Data_Sets of iDSO DoAllFg bNoStop to bErr
12344>>>>>                        If bErr Begin
12346>>>>>                            Move bErr to iRetVal
12347>>>>>                            If bNoStop ;                                Move 0 to bErr
12350>>>>>                        End
12350>>>>>>
12350>>>>>                    End
12350>>>>>>
12350>>>>>                Until bErr
12352>>>>>                If not bErr Begin
12354>>>>>                    Get Validate_Fields DoAllFg bNoStop to bErr
12355>>>>>                    If bErr ;                        Move bErr to iRetVal
12358>>>>>                End
12358>>>>>>
12358>>>>>            End
12358>>>>>>
12358>>>>>        End
12358>>>>>>
12358>>>>>        Set Visited_State to True
12359>>>>>        Function_Return iRetval
12360>>>>>    End_Function
12361>>>>>    
12361>>>>>    // This tests the DDO and all "up" DDOs to see if a switched parent / commit test even needs to be
12361>>>>>    // tested. This is called by the top ValidateSwitchedCommittedParents to see if a switch parent test
12361>>>>>    // even needs to be applied before it has to refinds records.
12361>>>>>    // Return true is there is nothing to test (i.e., the shortcut worked).
12361>>>>>    Function IsCommittedRecursiveUpParentChangeAllowed Returns Boolean
12363>>>>>        Boolean bAllowed bCommitted bVisited bHasRecord
12363>>>>>        Integer iServers iSrvr iParent
12363>>>>>        Handle hoSrvr
12363>>>>>        
12363>>>>>        
12363>>>>>        // optimization. We only test committed parents if one parent does not allow changing committed records.
12363>>>>>        // This avoids extra finds and relates when not needed
12363>>>>>        Set Visited_State to True
12364>>>>>        Get Data_Set_Server_Count to iServers
12365>>>>>        Get IsCommitted to bCommitted
12366>>>>>        Move 0 to iSrvr
12367>>>>>        Move True to bAllowed
12368>>>>>        While (iSrvr<iServers and bAllowed)
12372>>>>>            Get Data_Set_Server iSrvr to hoSrvr
12373>>>>>            Get Main_File of hoSrvr to iParent
12374>>>>>            // if committed and parent change not allowed, we are done
12374>>>>>            If (bCommitted) Begin
12376>>>>>                Get IsCommittedParentChangeAllowed iParent to bAllowed
12377>>>>>            End
12377>>>>>>
12377>>>>>            // if still allowed, check all parents
12377>>>>>            If (bAllowed) Begin
12379>>>>>                Get Visited_State of hoSrvr to bVisited
12380>>>>>                If not bVisited Begin
12382>>>>>                    Get IsCommittedRecursiveUpParentChangeAllowed of hoSrvr to bAllowed
12383>>>>>                End
12383>>>>>>
12383>>>>>            End
12383>>>>>>
12383>>>>>            Increment iSrvr
12384>>>>>        Loop
12385>>>>>>
12385>>>>>        Function_Return bAllowed
12386>>>>>    End_Function
12387>>>>>    
12387>>>>>    
12387>>>>>    // special validate-save check for changed committed parent. If the record is committed
12387>>>>>    // and it has a switched parent and this is not allowed, we have an error. This should rarely happen because the
12387>>>>>    // DEOs should guard aginst this. This is a recursive routine that requires special attention the first time through.
12387>>>>>    // When called from the we must refind the original record and all original parents. This way we can compare these parent
12387>>>>>    // rowids to the DD row id (if different, they've changed). At the end we must restore the DD records. Because this takes time
12387>>>>>    // we only even do this if this is committed and there is a chance that there are changed parents
12387>>>>>    
12387>>>>>    Function ValidateSwitchedCommittedParents Boolean bTop Returns Boolean
12389>>>>>        Integer iServers iSrvr iMain iParent iPMain
12389>>>>>        Handle hoSrvr
12389>>>>>        RowID riCrnt riParent riPCrnt
12389>>>>>        Boolean bChanged bCommitted bAllowed bErr bParentChanged bVisited
12389>>>>>        Boolean bHasRecord bPHasRecord bFound
12389>>>>>        
12389>>>>>        
12389>>>>>        // Shortcut optimization. This tests for any committed DDO with a parent that doesn't allow a switch
12389>>>>>        // return true if there is any reason to actually test any DDO up the tree for a parent change
12389>>>>>        If bTop Begin
12391>>>>>            // init visited nodes, these will be tested and set in IsCommittedRecursiveUpParentChangeAllowed
12391>>>>>            Send Initialize_Visited False False //false=up only, true=clear fields
12392>>>>>            Get IsCommittedRecursiveUpParentChangeAllowed to bAllowed
12393>>>>>            If bAllowed Begin
12395>>>>>                Function_Return False // if all are allowed, we have nothing to test - its ok
12396>>>>>            End
12396>>>>>>
12396>>>>>        End
12396>>>>>>
12396>>>>>        
12396>>>>>        Get Main_File to iMain
12397>>>>>        Get CurrentRowId to riCrnt
12398>>>>>        Get Data_Set_Server_Count to iServers
12399>>>>>        Get HasRecord to bHasRecord
12400>>>>>        
12400>>>>>        If (bHasRecord and (bTop or not(IsSameRowID(GetRowID(iMain),riCrnt))) ) Begin
12402>>>>>            // this refinds the main record and, most importantly, relates all original parents on up
12402>>>>>            // We now have the original parents which we can test to see if they are changed.
12402>>>>>            Get ReadByRowIdEx iMain riCrnt to bFound
12403>>>>>            If not bFound Begin
12405>>>>>                Error DFERR_CANT_REFIND_RECORD
12406>>>>>>
12406>>>>>                Function_Return True
12407>>>>>            End
12407>>>>>>
12407>>>>>        End
12407>>>>>>
12407>>>>>        
12407>>>>>        If (bTop) Begin
12409>>>>>            // If at start, init visited nodes, these will be tested and set during recursive calls to this function
12409>>>>>            Send Initialize_Visited False False // false=up only, true=clear fields
12410>>>>>        End
12410>>>>>>
12410>>>>>        
12410>>>>>        Set Visited_State to True
12411>>>>>        Get IsCommitted to bCommitted
12412>>>>>        If bCommitted Begin
12414>>>>>            // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
12414>>>>>            // First see any any of the parents are changed.
12414>>>>>            Get Parent_Changed_State to bChanged
12415>>>>>            If bChanged Begin
12417>>>>>                // Parent_Changed_State tells us a parent is changed but not which one. Look at each child to see if it is changed.
12417>>>>>                Move 0 to iSrvr
12418>>>>>                While (iSrvr<iServers and not(bErr))
12422>>>>>                    Get Data_Set_Server iSrvr to hoSrvr
12423>>>>>                    Get Main_File of hoSrvr to iParent
12424>>>>>                    Get CurrentRowId of hoSrvr to riParent
12425>>>>>                    Move (not(IsSameRowID(GetRowID(iParent),riParent))) to bParentChanged // is parent changed?
12426>>>>>                    If bParentChanged Begin
12428>>>>>                        Get IsCommittedParentChangeAllowed iParent to bAllowed // is changing committed parent allowed?
12429>>>>>                        If not bAllowed Begin
12431>>>>>                            Move True to bErr
12432>>>>>                            If bErr Begin
12434>>>>>                                Send Data_Set_Error of hoSrvr -1 0 DD_CANNOT_SWITCH_PARENT
12435>>>>>                            End
12435>>>>>>
12435>>>>>                        End
12435>>>>>>
12435>>>>>                    End
12435>>>>>>
12435>>>>>                    Increment iSrvr
12436>>>>>                Loop
12437>>>>>>
12437>>>>>            End
12437>>>>>>
12437>>>>>        End
12437>>>>>>
12437>>>>>        
12437>>>>>        // no error in immediate we must continue this check up the parent tree.
12437>>>>>        Move 0 to iSrvr
12438>>>>>        While (iSrvr<iServers and not(bErr))
12442>>>>>            Get Data_Set_Server iSrvr to hoSrvr
12443>>>>>            Get Visited_State of hoSrvr to bVisited
12444>>>>>            If (not(bVisited)) Begin
12446>>>>>                
12446>>>>>                // if new record, we need to refind parent records from here since you cannot
12446>>>>>                // have done a find/relate on a new record.
12446>>>>>                If (not(bHasRecord)) Begin
12448>>>>>                    Get HasRecord of hoSrvr to bPHasRecord
12449>>>>>                    If (bPHasRecord) Begin
12451>>>>>                        Get Main_File of hoSrvr to iPMain
12452>>>>>                        Get CurrentRowId of hoSrvr to riPCrnt
12453>>>>>                        If (not(IsNullRowID(riPCrnt))) Begin
12455>>>>>                            Get ReadByRowIdEx of hoSrvr iPMain riPCrnt to bFound
12456>>>>>                            If not bFound Begin
12458>>>>>                                Error DFERR_CANT_REFIND_RECORD
12459>>>>>>
12459>>>>>                                Function_Return True
12460>>>>>                            End
12460>>>>>>
12460>>>>>                        End
12460>>>>>>
12460>>>>>                    End
12460>>>>>>
12460>>>>>                End
12460>>>>>>
12460>>>>>                
12460>>>>>                Get ValidateSwitchedCommittedParents of hoSrvr False to bErr // call recursively up the parent tree
12461>>>>>            End
12461>>>>>>
12461>>>>>            Increment iSrvr
12462>>>>>        Loop
12463>>>>>>
12463>>>>>        
12463>>>>>        If bTop Begin // if back to the top, make sure our buffers are correct.
12465>>>>>            Send Refind_Records
12466>>>>>        End
12466>>>>>>
12466>>>>>        
12466>>>>>        Function_Return bErr
12467>>>>>    End_Function
12468>>>>>    
12468>>>>>    Procedure Entry_Update_Data_Sets Integer iFile Integer iAll
12470>>>>>        
12470>>>>>        Handle hoBuff hoDSO
12470>>>>>        Boolean bCommit bIsFind bVisited bIsForeign
12470>>>>>        Integer iMax iCount iItems iOpts iChanges
12470>>>>>        
12470>>>>>        
12470>>>>>        Move record_buffer to hoBuff
12471>>>>>        Move (OPERATION_MODE<>MODE_SAVING) to bIsFind
12472>>>>>        
12472>>>>>        // first recurse to all parent ddos
12472>>>>>        Get Data_Set_Server_Count to iMax
12473>>>>>        Decrement iMax
12474>>>>>        For iCount from 0 to iMax
12480>>>>>>
12480>>>>>            Get Data_Set_Server iCount to hoDSO
12481>>>>>            Get Visited_State of hoDSO to bVisited
12482>>>>>            If not (bVisited) Begin
12484>>>>>                Send Entry_Update_Data_Sets to hoDSO iFile iAll
12485>>>>>            End
12485>>>>>>
12485>>>>>        Loop
12486>>>>>>
12486>>>>>        
12486>>>>>        // if find, we only do this if the main file is the same as the find file
12486>>>>>        If (not(bIsFind) or iFile=Main_File(Self)) Begin
12488>>>>>            If (not(bIsFind)) Begin
12490>>>>>                // if a save, we care if it is committed.
12490>>>>>                Get IsCommitted to bCommit
12491>>>>>            End
12491>>>>>>
12491>>>>>            
12491>>>>>            // pass if Find (True) or save (False). We only care about commit on saves
12491>>>>>            // The setting of bIsForeign is an approximation. Foreign is really a DEO and and not
12491>>>>>            // a DD concept - in fact, at this point we don't really know. For example, a save in a header/dtl
12491>>>>>            // detail DEO (ordrdtl grid)has header DEOs that are not really foreign. This test errs on the side
12491>>>>>            // of assuming it's foreign. This would cause problems with incorrect parent NoPuts except we also
12491>>>>>            // set a flag, Field_NoPutValueChangedByDeo, when a field is changed via a NoPut DEO. The DD will still update
12491>>>>>            // foreign NoPuts unless this field flag is set.
12491>>>>>            Move (OPERATION_ORIGIN<>Self and Allow_Foreign_New_Save_State(Self)=0) to bIsForeign
12492>>>>>            Send Entry_Update of hoBuff bIsFind (If(bCommit,1,0) + If(bIsForeign,2,0))
12493>>>>>            
12493>>>>>            // also move data from extended dd fields to buffer
12493>>>>>            Send ExtendedFieldsUpdate (not(bIsFind))
12494>>>>>        End
12494>>>>>>
12494>>>>>        Set Visited_State to True
12495>>>>>        
12495>>>>>    End_Procedure
12496>>>>>    
12496>>>>>    // is this field NoPut based passed Commit and Foreign flags.
12496>>>>>    Function FieldNoPut Integer iField Boolean bIsCommited Boolean bIsForeign Returns Boolean
12498>>>>>        Boolean bNoPut
12498>>>>>        // this uses runtime logic - the same use for moving DD Buffer to Field Buffer
12498>>>>>        Get IsFieldDDNoPut of Record_Buffer iField (If(bIsCommited,1,0) + If(bIsForeign,2,0)) to bNoPut
12499>>>>>        Function_Return bNoPut
12500>>>>>    End_Function
12501>>>>>    
12501>>>>>    
12501>>>>>    // Check that Server data-sets exist for all required server file numbers
12501>>>>>    Function Valid_Servers Returns Integer
12503>>>>>        Integer iRval
12503>>>>>        Integer iCount
12503>>>>>        Integer iMax
12503>>>>>        Integer iDSO
12503>>>>>        Integer iPos
12503>>>>>        Integer iFile
12503>>>>>        String  sFiles
12503>>>>>        
12503>>>>>        // First assemble a string of all server file#s in ','##',' format
12503>>>>>        Move ',' to sFiles
12504>>>>>        Get Data_Set_Server_Count to iMax
12505>>>>>        Decrement iMax
12506>>>>>        For iCount from 0 to iMax
12512>>>>>>
12512>>>>>            Get Data_Set_Server iCount to iDSO
12513>>>>>            Move ( sFiles + String(Main_file(iDSO)) + ",") to sFiles
12514>>>>>        Loop
12515>>>>>>
12515>>>>>        
12515>>>>>        // Make sure each required File exists
12515>>>>>        Get Server_File_Count to iMax
12516>>>>>        Decrement iMax
12517>>>>>        For iCount from 0 to iMax
12523>>>>>>
12523>>>>>            Get Server_File iCount to iFile
12524>>>>>            Move (Pos ( ','+String(iFile)+',' , sFiles)) to iPos
12525>>>>>            If (iPos = 0) ;                Move iFile to iRVal
12528>>>>>        Until iRval
12530>>>>>        Function_Return iRVal
12531>>>>>    End_Function
12532>>>>>    
12532>>>>>    
12532>>>>>    // Check that Client data-sets exist for all required Client file numbers
12532>>>>>    Function Valid_Clients Returns Integer
12534>>>>>        Integer iRval
12534>>>>>        Integer iCount
12534>>>>>        Integer iMax
12534>>>>>        Integer iDSO
12534>>>>>        Integer iPos
12534>>>>>        Integer iFile
12534>>>>>        String  sFiles
12534>>>>>        
12534>>>>>        // First assemble a string of all Client file#s in ','##',' format
12534>>>>>        Move ',' to sFiles
12535>>>>>        Get Data_Set_Client_Count to iMax
12536>>>>>        Decrement iMax
12537>>>>>        For iCount from 0 to iMax
12543>>>>>>
12543>>>>>            Get Data_Set_Client iCount to iDSO
12544>>>>>            Move ( sFiles + String(Main_file(iDSO))+",") to sFiles
12545>>>>>        Loop
12546>>>>>>
12546>>>>>        
12546>>>>>        // Make sure each required File exists
12546>>>>>        Get Client_File_Count to iMax
12547>>>>>        Decrement iMax
12548>>>>>        For iCount from 0 to iMax
12554>>>>>>
12554>>>>>            Get Client_File iCount to iFile
12555>>>>>            Move (Pos( ','+String(iFile)+',', sFiles)) to iPos
12556>>>>>            If (iPos = 0) ;                Move iFile to iRVal
12559>>>>>        Until iRval
12561>>>>>        Function_Return iRVal
12562>>>>>    End_Function
12563>>>>>    
12563>>>>>    
12563>>>>>    // Validates save updating connections. If error returns file# that is
12563>>>>>    // expected and missing. If no error Set Validated_Save_connectio_State
12563>>>>>    // indicating that the connection validation has occurred and is ok
12563>>>>>    Function Validate_Save_Structure Integer ForceFg Returns Integer
12565>>>>>        Integer iRval
12565>>>>>        Integer iMode
12565>>>>>        If not ForceFg Begin
12567>>>>>            Get Validate_Save_Structure_Mode to iMode
12568>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and ;                Save_Structure_Validated_state(Self)=0 ) ) ;                to ForceFg
12569>>>>>        End
12569>>>>>>
12569>>>>>        If ForceFg Begin
12571>>>>>            Get Valid_Structure False to iRval
12572>>>>>            If (iRVal = 0) ;                Set Save_Structure_Validated_State to True
12575>>>>>        End
12575>>>>>>
12575>>>>>        Function_Return iRVal
12576>>>>>    End_Function
12577>>>>>    
12577>>>>>    // Validates Delete Structure. If cascade_state is true this must check
12577>>>>>    // up and down the tree. If no cascade_state just check up the tree.  If
12577>>>>>    // Ok, set Validated_Delete_no_Cascade_Connection_State and and or
12577>>>>>    // Validated_Delete_Cascade_Connection_State
12577>>>>>    // Pass: ForceFg - if TRUE force the validation.
12577>>>>>    Function Validate_Delete_Structure Integer ForceFg Returns Integer
12579>>>>>        Integer iCascade
12579>>>>>        Integer iMode
12579>>>>>        Integer iSt
12579>>>>>        Integer iRval
12579>>>>>        Get Cascade_delete_State to iCascade
12580>>>>>        If not ForceFg Begin
12582>>>>>            Get Validate_Delete_Structure_Mode to iMode
12583>>>>>            If (iMode=DD_VALIDATE_STRUCTURE_ONCE and iCascade );                Get Cascade_Delete_Structure_Validated_state to iSt
12586>>>>>            Else ;                Get No_Cascade_Delete_Structure_Validated_state to iSt
12588>>>>>            Move ( iMode=DD_VALIDATE_STRUCTURE_ALWAYS or ;                (iMode=DD_VALIDATE_STRUCTURE_ONCE and iSt=0) ) to ForceFg
12589>>>>>        End
12589>>>>>>
12589>>>>>        
12589>>>>>        If ForceFg Begin
12591>>>>>            Get Valid_Structure iCascade to iRval
12592>>>>>            If (iRval = 0) Begin
12594>>>>>                Set No_Cascade_Delete_Structure_Validated_State to True
12595>>>>>                If iCascade ;                    Set Cascade_Delete_Structure_Validated_State to True
12598>>>>>            End
12598>>>>>>
12598>>>>>        End
12598>>>>>>
12598>>>>>        Function_Return iRval
12599>>>>>    End_Function
12600>>>>>    
12600>>>>>    
12600>>>>>    // This procedure will be called whenever the Data_Set wants its DEOs to
12600>>>>>    // write their values to the record buffer. The value of OPERATION_MODE
12600>>>>>    // determines if this is for finding an record or before saving a record.
12600>>>>>    // We use this event to tell our Record_Buffer to update the
12600>>>>>    // global record buffer.
12600>>>>>    // Modified to visit all server DSOs
12600>>>>>    // Note that this is only sent to the DSO starting the operation.
12600>>>>>    // We must manually send this to all server data-sets ourselves
12600>>>>>    // Note that during a DSO save this will get passed iFile=0 and iAll=3
12600>>>>>    // Changed to Support EntryUpdateLocalState (private)
12600>>>>>    // as of 17.0, EntryUpdateLocalState is True which means that entry_updates
12600>>>>>    // for finds now through the DD Buffer (saves always did).
12600>>>>>    Procedure Request_Entry_Update Integer iFile Integer iAll
12602>>>>>        If ((Operation_Mode=MODE_SAVING and iAll=3) or (EntryUpdateLocalState(Self)) ) Begin //3=dso save
12604>>>>>            If (OPERATION_MODE=MODE_WAITING) Begin
12606>>>>>                // we will only not be in an operation if we are doing a find with EntryUpdateLocalState
12606>>>>>                // set to true. In such a case make this a finding. I am not this is actually needed
12606>>>>>                Send Update_Focus_Field_For_Operation MODE_FINDING
12607>>>>>            End
12607>>>>>>
12607>>>>>            Else Begin
12608>>>>>                // if here we already have an operation_mode so there is no need to do anything special
12608>>>>>                Send Update_Focus_Field // Make sure buffer has latest focus item changes
12609>>>>>            End
12609>>>>>>
12609>>>>>            Send Initialize_Visited False False // Clear up, do not clear fields
12610>>>>>            Send Entry_Update_Data_Sets iFile iAll
12611>>>>>        End
12611>>>>>>
12611>>>>>        Forward Send Request_Entry_Update iFile iAll
12613>>>>>    End_Procedure
12614>>>>>    
12614>>>>>    
12614>>>>>    
12614>>>>>    // Forces the focus field to get update its value with the data-set.
12614>>>>>    // This insures that the DSO and DEO contain the same values.
12614>>>>>    Procedure Update_Focus_Field
12616>>>>>        Integer iFocObj
12616>>>>>        Get Focus of desktop to iFocObj
12617>>>>>        If (Extended_DEO_State(iFocObj)) ;            Send Update_Focus_Field to iFocObj
12620>>>>>    End_Procedure
12621>>>>>    
12621>>>>>    // very internal. Used to set Operation_mode and Operation_origin before the
12621>>>>>    // update. A developer can use this in the DEO to know what state the update is in.
12621>>>>>    // This was created because a DEO value change will trigger an OnChange event and you
12621>>>>>    // can look at this and know that this is part of a DD operation.
12621>>>>>    // This is *only* called by the DD operations in this class and the change is made for as
12621>>>>>    // small of a period as possible.
12621>>>>>    Procedure Update_Focus_Field_For_Operation Integer iOperationMode
12623>>>>>        Integer iOldMode iOldOrigin
12623>>>>>        
12623>>>>>        Move OPERATION_MODE to iOldMode
12624>>>>>        Move OPERATION_ORIGIN to iOldOrigin
12625>>>>>        Move iOperationMode to OPERATION_MODE
12626>>>>>        Move Self to OPERATION_ORIGIN
12627>>>>>        Send Update_Focus_Field
12628>>>>>        Move iOldMode to OPERATION_MODE
12629>>>>>        Move iOldOrigin to OPERATION_ORIGIN
12630>>>>>    End_Procedure
12631>>>>>    
12631>>>>>    
12631>>>>>    // Augment to validate all field values that do not get
12631>>>>>    // validated as part of the item validation process. The advantage
12631>>>>>    // of item validation (over only field validation) is that an error
12631>>>>>    // returns you to the offending item.
12631>>>>>    Function Request_Validate Returns Integer
12633>>>>>        Integer iRetval iOldOrigin iOldMode iRetVal2
12633>>>>>        Handle[] DDsWithFindReqErrors
12634>>>>>        
12634>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
12636>>>>>            Send Update_Focus_Field_For_Operation MODE_VALIDATING // added 12.1/15.1
12637>>>>>        End
12637>>>>>>
12637>>>>>        Move Operation_Origin to iOldOrigin
12638>>>>>        Move Self to Operation_Origin
12639>>>>>        Move Operation_Mode to iOldMode
12640>>>>>        // clear all find req DD markers at the origin of the validate request. When request validates occur
12640>>>>>        // they will get added to this array and can be tested to see of such an error has occurred.
12640>>>>>        Set pDDsWithFindReqErrors to DDsWithFindReqErrors
12641>>>>>        // Prior to VDF7, we set this to Mode_Saving. We now have a special mode just for request_validate.
12641>>>>>        // We do this because:
12641>>>>>        //   1) because it is useful (more detail never hurts) and
12641>>>>>        //   2) we will allow set_field_current_value to update when mode_validation is set
12641>>>>>        Move MODE_VALIDATING to Operation_Mode
12642>>>>>        Send Initialize_Visited False True //false=up only, true=clear fields
12643>>>>>        Forward Get Request_Validate to iRetval // normal deo validate
12645>>>>>        // If DEO validation failed, do not validate other fields unless Validate_All_Fields is set
12645>>>>>        If ( (iRetval=0 or (Validate_All_Fields_State(Self))) and Validate_DEOs_Only_State(Self)=0) Begin
12647>>>>>            Get Validate_Data_Sets False (Validate_All_Fields_State(Self)) to iRetval2
12648>>>>>            Move (iRetval or iRetVal2) to iRetval
12649>>>>>        End
12649>>>>>>
12649>>>>>        
12649>>>>>        If (iRetval=0) Begin
12651>>>>>            Get ValidateSwitchedCommittedParents True to iRetval
12652>>>>>        End
12652>>>>>>
12652>>>>>        
12652>>>>>        Move iOldMode   to Operation_Mode
12653>>>>>        Move iOldOrigin to Operation_Origin
12654>>>>>        Function_Return iRetval
12655>>>>>    End_Function
12656>>>>>    
12656>>>>>    Function Request_Validate_All Returns Integer
12658>>>>>        Integer bOld iRetVal
12658>>>>>        Get Validate_All_Fields_State to bOld
12659>>>>>        Set Validate_All_Fields_State to True
12660>>>>>        Get request_validate to iretVal
12661>>>>>        Set Validate_All_Fields_State to bOld
12662>>>>>        Function_Return iRetval
12663>>>>>    End_Function
12664>>>>>    
12664>>>>>    
12664>>>>>    
12664>>>>>    // Like Item_find except entry-update is forced through the DD, not DEO
12664>>>>>    Procedure File_Field_Find Integer iFindMode Integer iFile Integer iField ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
12666>>>>>        Integer bOld
12666>>>>>        Get EntryUpdateLocalState to bOld
12667>>>>>        Set EntryUpdateLocalState to True
12668>>>>>        Send Item_Find iFindMode iFile iField bEntUpdt bShowErr bDfrd
12669>>>>>        Set EntryUpdateLocalState to bOld
12670>>>>>    End_Procedure
12671>>>>>    
12671>>>>>    // Autofind for requestd file, field and mode.
12671>>>>>    //    If mode not passed, EQ is assummed
12671>>>>>    Procedure File_Field_AutoFind Integer iFile Integer iField Integer iFindMode
12673>>>>>        Integer eMode
12673>>>>>        If iFile  Begin
12675>>>>>            // if no 3rd argument, default to autofind
12675>>>>>            Move (If(Num_Arguments<3,EQ,iFindMode)) to eMode
12676>>>>>            Send File_Field_Find eMode iFile iField True False False
12677>>>>>        End
12677>>>>>>
12677>>>>>    End_Procedure
12678>>>>>    
12678>>>>>    // Autofind in default mode (does not set changed states). Can be used
12678>>>>>    // within Clear and Clear_all to autofind parents. Parent values can be
12678>>>>>    // maintained using retainAll option
12678>>>>>    Procedure File_Field_Default_AutoFind Integer iFile Integer iField
12680>>>>>        Integer iOldState
12680>>>>>        Handle  hoDD
12680>>>>>        Get Data_set iFile to hoDD
12681>>>>>        If hoDD Begin
12683>>>>>            Get Change_disabled_State of hoDD to iOldState
12684>>>>>            Set Change_disabled_State of hoDD to True
12685>>>>>            Send File_Field_AutoFind  of hoDD iFile iField EQ
12686>>>>>            Set Change_disabled_State of hoDD to iOldState
12687>>>>>            Set changed_state to False
12688>>>>>        End
12688>>>>>>
12688>>>>>    End_Procedure
12689>>>>>    
12689>>>>>    // File_Index_find
12689>>>>>    // Like item_find except you pass the index you want to find with and
12689>>>>>    // ent-update occurs through DDO buffers not deo buffers.
12689>>>>>    // This is currently private and is only used by web-applications
12689>>>>>    Procedure File_Index_Find Integer iFindMode Integer iFile Integer iIndex ;            Integer bEntUpdt  Integer bShowErr Integer bDfrd
12691>>>>>        Integer bOld
12691>>>>>        RowID riRec
12691>>>>>        Integer wasChanged hDD iOldStat
12691>>>>>        Boolean bOk
12691>>>>>        
12691>>>>>        Get Data_Set iFile to hDD
12692>>>>>        If (hDD=0) Begin
12694>>>>>            Error DFERR_PROGRAM C_$CannotFindDD
12695>>>>>>
12695>>>>>            Procedure_Return
12696>>>>>        End
12696>>>>>>
12696>>>>>        
12696>>>>>        Get EntryUpdateLocalState to bOld
12697>>>>>        Set EntryUpdateLocalState to True
12698>>>>>        
12698>>>>>        //  'hold' buffer to prepare for entry_update
12698>>>>>        Move (getRowId(iFile)) to riRec
12699>>>>>        Get_Attribute DF_FILE_STATUS of iFile to iOldStat
12702>>>>>        Set_Attribute DF_FILE_STATUS of iFile to DF_FILE_INACTIVE
12705>>>>>        
12705>>>>>        If bEntUpdt Begin
12707>>>>>            Send Request_Entry_Update to hDD iFile 1  //entUpdt all DEOs as required
12708>>>>>            
12708>>>>>            //
12708>>>>>            // we really only need to know if any segment of the index changed
12708>>>>>            // but since we don't have field-changed flags, we look at the
12708>>>>>            // whole recbuf - this is consistent with 2.3b and 3.0 non-dataset
12708>>>>>            // behavior.
12708>>>>>            //
12708>>>>>            Move (iOldStat<>DF_FILE_INACTIVE) to wasChanged
12709>>>>>            If not wasChanged ;                Get_Attribute DF_FILE_CHANGED of iFile to wasChanged
12714>>>>>            If not wasChanged ;                Constrained_Clear iFindMode iFile by iIndex
12719>>>>>            
12719>>>>>        End
12719>>>>>>
12719>>>>>        Move False to Err
12720>>>>>        If bDfrd ;            Send Request_Read iFindMode iFile iIndex
12723>>>>>        Else ;            Send Request_Find iFindMode iFile iIndex
12725>>>>>        If (not(Found) and  not(err)) Begin
12727>>>>>            // refind original record (or leave it cleared if not record)
12727>>>>>            Move (FindByRowId(iFile,riRec)) to bOk
12728>>>>>            
12728>>>>>            If bShowErr ;                Error (If(iFindMode<2, DFERR_FIND_PRIOR_BEG_OF_FILE, DFERR_FIND_PAST_END_OF_FILE))
12731>>>>>            Move False to Err
12732>>>>>        End
12732>>>>>>
12732>>>>>        Set EntryUpdateLocalState to bOld
12733>>>>>    End_Procedure
12734>>>>>    
12734>>>>>    // This does a refind of all records based on the contents of the
12734>>>>>    // refine_record_id property.
12734>>>>>    // This would be used after clearing the DDs and loading the local rencum
12734>>>>>    // buffer with recnums. This can be used by remote DEOs (BPOs).
12734>>>>>    //
12734>>>>>    // Find all existing records. This must be done in bottom-up, breadth
12734>>>>>    // first order. i.e., Start with the passed DD, find it and then find for
12734>>>>>    // parents. Only find if the record is non-zero and it is different than
12734>>>>>    // the current_record.
12734>>>>>    // This order will allow us to support changed parents.
12734>>>>>    // Don't use this if you do not understand what it does.
12734>>>>>    // Private.Find_Records is a helper. We will keep this private because
12734>>>>>    // it is rather specialized and only used by WebApp.
12734>>>>>    Procedure Find_Records
12736>>>>>        Send Initialize_Visited False False // Clear up, do not clear fields
12737>>>>>        Send Private.Find_Records           // refind all records in upward sweep
12738>>>>>    End_Procedure
12739>>>>>    
12739>>>>>    
12739>>>>>    Procedure Private.Find_Records
12741>>>>>        Integer hPrnt
12741>>>>>        Integer iMax
12741>>>>>        Integer iCount
12741>>>>>        RowID riRec
12741>>>>>        Integer iRec iMain
12741>>>>>        // works with both recId and rowId. Only one should ever be set.
12741>>>>>        // find(clear) record, if needed
12741>>>>>        Get Main_File to iMain
12742>>>>>        // assume that either Find_rowId or Find_record_id has a value - never both
12742>>>>>        // also assume Find_record_id only has values when you are using a recnum table
12742>>>>>        Get Find_RowId to riRec
12743>>>>>        If not (IsNullRowId(riRec)) Begin
12745>>>>>            If not (IsSameRowId(riRec, CurrentRowId(Self) ) ) Begin
12747>>>>>                Send FindByRowId iMain riRec // find an Relate all parents
12748>>>>>            End
12748>>>>>>
12748>>>>>            Set Find_rowid to (NullRowId())  // reset refind rec back to zero.
12749>>>>>        End
12749>>>>>>
12749>>>>>        Else Begin
12750>>>>>            // if this has a recnum, it better be a recnum table or an error will occur.
12750>>>>>            // This is not being tested for a recnum table on purpose. If someone is setting Find_record_id
12750>>>>>            // on a non-recnum table, they doing something wrong. An Error will be a good thing.
12750>>>>>            Get Find_Record_Id to iRec
12751>>>>>            If iRec Begin
12753>>>>>                If (iRec<>Current_record(Self)) Begin
12755>>>>>                    Send Find_By_Recnum iMain iRec // find an Relate all parents
12756>>>>>                End
12756>>>>>>
12756>>>>>                Set Find_record_id to 0 // reset refind rec back to zero.
12757>>>>>            End
12757>>>>>>
12757>>>>>        End
12757>>>>>>
12757>>>>>        Set Visited_State to True
12758>>>>>        
12758>>>>>        // recurse and do the same to all parent files
12758>>>>>        // in almost all cases, there will be no new finding here since the relate has
12758>>>>>        // found the records. If the record is different than the relate, we have
12758>>>>>        // a switched parent state (should_save will be set appropriately).
12758>>>>>        Get Data_Set_Server_Count to iMax
12759>>>>>        Decrement iMax
12760>>>>>        For iCount from 0 to iMax
12766>>>>>>
12766>>>>>            Get Data_Set_Server iCount to hPrnt
12767>>>>>            If not (Visited_state(hPrnt)) ;                Send Private.Find_Records to hPrnt
12770>>>>>        Loop
12771>>>>>>
12771>>>>>    End_Procedure
12772>>>>>    
12772>>>>>    // This Mark_Id creates a sequence Id for this clear. This way
12772>>>>>    // DDOs only get cleared one time during this process.
12772>>>>>    Procedure IncrementCurrentMarkId
12774>>>>>        If (DD_Current_Mark_ID>65536) Begin
12776>>>>>            Move 0 to DD_Current_Mark_id
12777>>>>>        End
12777>>>>>>
12777>>>>>        Increment DD_Current_Mark_id
12778>>>>>    End_Procedure
12779>>>>>    
12779>>>>>    
12779>>>>>    // private use by new webapp framework as of 18.2.
12779>>>>>    // pass bStart as True if this is the start of the resynch.
12779>>>>>    Function ReSyncRecords Boolean bStart Returns Handle
12781>>>>>        RowID riRowId riCrnt
12781>>>>>        Boolean bOk bOldReSync bVisited
12781>>>>>        Handle hoOtherDDO hoBadDDO hoBadPrntDDO
12781>>>>>        Integer iMax iCount iMain
12781>>>>>
12781>>>>>        If bStart Begin
12783>>>>>            Send InitializeAllVisited
12784>>>>>        End
12784>>>>>>
12784>>>>>        
12784>>>>>        // we want depth first traversal. Make sure children are handled before parents
12784>>>>>        // Recursively traverse Children, Find by RowId, Recursively traverse Parents
12784>>>>>        // Use visited_state logic to avoid multiple visits caused by diamond DDO strutures
12784>>>>>        
12784>>>>>        //mark first so we don't visit this coming back up.
12784>>>>>        Set Visited_State to True
12785>>>>>        
12785>>>>>        // traverse downward first
12785>>>>>        Get Data_Set_Client_Count to iMax
12786>>>>>        For iCount from 0 to (iMax-1)
12792>>>>>>
12792>>>>>            Get Data_Set_Client iCount to hoOtherDDO
12793>>>>>            Get Visited_State of hoOtherDDO to bVisited
12794>>>>>            If not bVisited Begin
12796>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
12797>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
12799>>>>>                    Move hoBadPrntDDO to hoBadDDO
12800>>>>>                End
12800>>>>>>
12800>>>>>            End
12800>>>>>>
12800>>>>>        Loop
12801>>>>>>
12801>>>>>        
12801>>>>>        // Find record for DD. It might already be correct if child has already
12801>>>>>        // related it in. If not correct after a relate, this has been switched by this
12801>>>>>        // user or switched by another user, in which case it will be swtitched back
12801>>>>>        // (DDOs have always worked this way).
12801>>>>>        Get Find_RowId to riRowId
12802>>>>>        Get Main_File to iMain
12803>>>>>        Get CurrentRowId to riCrnt
12804>>>>>        If ( not(IsSameRowId(riRowID, riCrnt)) ) Begin
12806>>>>>            Get pbInReSync to bOldReSync
12807>>>>>            Set pbInReSync to True
12808>>>>>            
12808>>>>>            If (IsNullRowId(riRowID)) Begin
12810>>>>>                Send Clear
12811>>>>>            End
12811>>>>>>
12811>>>>>            Else Begin
12812>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
12813>>>>>                If not bOk Begin
12815>>>>>                    Move Self to hoBadDDO
12816>>>>>                End
12816>>>>>>
12816>>>>>            End
12816>>>>>>
12816>>>>>            Set pbInReSync to bOldReSync
12817>>>>>        End
12817>>>>>>
12817>>>>>        
12817>>>>>        // finally traverse to parents
12817>>>>>        Get Data_Set_Server_Count to iMax
12818>>>>>        For iCount from 0 to (iMax-1)
12824>>>>>>
12824>>>>>            Get Data_Set_Server iCount to hoOtherDDO
12825>>>>>            Get Visited_State of hoOtherDDO to bVisited
12826>>>>>            If not bVisited Begin
12828>>>>>                Get ReSyncRecords of hoOtherDDO False to hoBadPrntDDO
12829>>>>>                If (hoBadPrntDDO and not(hoBadDDO)) Begin
12831>>>>>                    Move hoBadPrntDDO to hoBadDDO
12832>>>>>                End
12832>>>>>>
12832>>>>>            End
12832>>>>>>
12832>>>>>        Loop
12833>>>>>>
12833>>>>>        
12833>>>>>        If bStart Begin
12835>>>>>            Send InitializeAllVisited
12836>>>>>            Send ResetChangedStates
12837>>>>>        End
12837>>>>>>
12837>>>>>        
12837>>>>>        Function_Return hoBadDDO
12838>>>>>    End_Function
12839>>>>>    
12839>>>>>
12839>>>>>    Procedure ResetChangedStates
12841>>>>>        Boolean bVisited
12841>>>>>        Handle hoOtherDDO
12841>>>>>        Integer iMax iCount
12841>>>>>        tDDChangedInfo DDChangedInfo
12841>>>>>        tDDChangedInfo DDChangedInfo
12841>>>>>                
12841>>>>>        // we want depth first traversal.
12841>>>>>        //mark first so we don't visit this coming back up.
12841>>>>>        Set Visited_State to True
12842>>>>>        
12842>>>>>        // traverse downward first
12842>>>>>        Get Data_Set_Client_Count to iMax
12843>>>>>        For iCount from 0 to (iMax-1)
12849>>>>>>
12849>>>>>            Get Data_Set_Client iCount to hoOtherDDO
12850>>>>>            Get Visited_State of hoOtherDDO to bVisited
12851>>>>>            If not bVisited Begin
12853>>>>>                Send ResetChangedStates of hoOtherDDO
12854>>>>>            End
12854>>>>>>
12854>>>>>        Loop
12855>>>>>>
12855>>>>>        
12855>>>>>        // Set changed states for this DDO
12855>>>>>        Get pDDChangedInfo to DDChangedInfo
12856>>>>>        Set Changed_State to False // clears changed_state and parent_changed_states            
12857>>>>>        Set Changed_State to DDChangedInfo.bChanged            
12858>>>>>        For iCount from 0 to (SizeOfArray(DDChangedInfo.ParentChanged)-1)
12864>>>>>>
12864>>>>>            Send SetParentDDOSwitched DDChangedInfo.ParentChanged[iCount].iTable DDChangedInfo.ParentChanged[iCount].bSwitched
12865>>>>>        Loop
12866>>>>>>
12866>>>>>        
12866>>>>>        // finally traverse to parents
12866>>>>>        Get Data_Set_Server_Count to iMax
12867>>>>>        For iCount from 0 to (iMax-1)
12873>>>>>>
12873>>>>>            Get Data_Set_Server iCount to hoOtherDDO
12874>>>>>            Get Visited_State of hoOtherDDO to bVisited
12875>>>>>            If not bVisited Begin
12877>>>>>                Send ResetChangedStates of hoOtherDDO
12878>>>>>            End
12878>>>>>>
12878>>>>>        Loop
12879>>>>>>
12879>>>>>        
12879>>>>>    End_Procedure
12880>>>>>
12880>>>>>    // private use by new webapp framework (pre 18.2)
12880>>>>>    Function ReSyncRecord Returns Boolean
12882>>>>>        RowID riRowId
12882>>>>>        Boolean bOk bOldReSync
12882>>>>>        Handle hPrnt
12882>>>>>        Integer iMax iCount iMain
12882>>>>>        
12882>>>>>        Get pbInReSync to bOldReSync
12883>>>>>        
12883>>>>>        Get Find_RowId to riRowId
12884>>>>>        Get Main_File to iMain
12885>>>>>        If not (IsSameRowId(riRowID, CurrentRowId(Self) ) ) Begin
12887>>>>>            If (IsNullRowId(riRowID)) Begin
12889>>>>>                Set pbInReSync to True
12890>>>>>                Send Clear
12891>>>>>                Set pbInReSync to bOldReSync
12892>>>>>            End
12892>>>>>>
12892>>>>>            Else Begin
12893>>>>>                Set pbInReSync to True
12894>>>>>                Get FindByRowIdExNoAutoFill iMain riRowId to bOk
12895>>>>>                Set pbInReSync to bOldReSync
12896>>>>>                If not bOk Begin
12898>>>>>                    Function_Return False
12899>>>>>                End
12899>>>>>>
12899>>>>>            End
12899>>>>>>
12899>>>>>            
12899>>>>>            // check that the relate found all the parent records we expect.
12899>>>>>            // This should be correct unless a parent has been switched. Constrained
12899>>>>>            // parents, by definition, should already be correct. See **Note** below
12899>>>>>            Get Data_Set_Server_Count to iMax
12900>>>>>            For iCount from 0 to (iMax-1)
12906>>>>>>
12906>>>>>                Get Data_Set_Server iCount to hPrnt
12907>>>>>                If (Constrain_File(Self)<>Main_File(hPrnt) and ;                    not (IsSameRowID(Find_RowId(hPrnt),CurrentRowId(hPrnt)))) Begin
12909>>>>>                    // the parent is either wrong or not processed yet. Either way
12909>>>>>                    // make it right.
12909>>>>>                    Get ReSyncRecord of hPrnt to bOk
12910>>>>>                    If not bOk Begin
12912>>>>>                        Function_Return False
12913>>>>>                    End
12913>>>>>>
12913>>>>>                End
12913>>>>>>
12913>>>>>            Loop
12914>>>>>>
12914>>>>>        End
12914>>>>>>
12914>>>>>        
12914>>>>>        Function_Return True
12915>>>>>    End_Function
12916>>>>>    
12916>>>>>    // **Note** - dealing with changed parents and diamonds during a resync.
12916>>>>>    // If there is not a relates-to contraint between DD and child it is possible
12916>>>>>    // that the child find's relate will change the just found parent DD.
12916>>>>>    // Assuming this is not a structure bug, it means the parent is changed parent and that
12916>>>>>    // change must occur after the child record has been found and related. Therefore we add
12916>>>>>    // check after each child find to see if an parent is incorrect. If it is, either it is a
12916>>>>>    // switched parent or we haven't processed it yet. If the record is fine it
12916>>>>>    // just does nothing. For example (where *=relates-to):
12916>>>>>    //     W
12916>>>>>    //   */  \*
12916>>>>>    //   X    Y
12916>>>>>    //    \  /*
12916>>>>>    //     Z
12916>>>>>    // Assume you found a Z and changed its parent X.
12916>>>>>    // The refind order can be: WXZY or WYZX
12916>>>>>    // If WXZY the refound parent will be lost because Z will relate after the X
12916>>>>>    // find and replace it with the original parent. To control this we add this check
12916>>>>>    // after child Z has done its work. We only need to do this when child DDOs exist
12916>>>>>    // that are not constrained. This can change the order that DDOs are resynced but it
12916>>>>>    // should not matter.
12916>>>>>    
12916>>>>>    
12916>>>>>    
12916>>>>>    // Private use by new webapp framework
12916>>>>>    Procedure ReSyncClearAll
12918>>>>>        Boolean bOldReSync
12918>>>>>        Get pbInReSync to bOldReSync
12919>>>>>        // we need this to stop RememberLast and retains. We don't want those during a resyc clear
12919>>>>>        Set pbInReSync to True
12920>>>>>        Send Clear_All
12921>>>>>        Set pbInReSync to bOldReSync
12922>>>>>    End_Procedure
12923>>>>>    
12923>>>>>    // returns table name for error display. By default it returns the logical name
12923>>>>>    // can be augmented to return other information
12923>>>>>    Function ErrorMessageTableName Integer iTable Returns String
12925>>>>>        String sTable
12925>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTable
12928>>>>>        Function_Return sTable
12929>>>>>    End_Function
12930>>>>>    
12930>>>>>    
12930>>>>>    // Augmented to test updating connections.
12930>>>>>    // If error report it.
12930>>>>>    Procedure Request_Save
12932>>>>>        Integer iRval
12932>>>>>        String sTable
12932>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
12934>>>>>            Send Update_Focus_Field_For_Operation MODE_SAVING // added in 12.1/15.1
12935>>>>>            Get Validate_Save_Structure False to iRval
12936>>>>>            If iRval Begin
12938>>>>>                Get ErrorMessageTableName iRval to sTable
12939>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
12940>>>>>                Send Data_Set_Error -1 DFERR_PROGRAM DD_INVALID_SAVE_STRUCTURE sTable
12941>>>>>                Procedure_Return
12942>>>>>            End
12942>>>>>>
12942>>>>>        End
12942>>>>>>
12942>>>>>        Forward Send Request_Save
12944>>>>>    End_Procedure
12945>>>>>    
12945>>>>>    // Augmented to test updating connections.
12945>>>>>    // If error report it.
12945>>>>>    Procedure Request_Delete
12947>>>>>        Integer iRval
12947>>>>>        String sTable
12947>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
12949>>>>>            Send Update_Focus_Field_For_Operation MODE_DELETING // added to 12.1/15.1
12950>>>>>            Get Validate_Delete_Structure False to iRval
12951>>>>>            If iRval Begin
12953>>>>>                Get ErrorMessageTableName iRval to sTable
12954>>>>>                Move (String(iRval) * "(" - sTable -")") to sTable
12955>>>>>                Send data_Set_Error -1 DFERR_PROGRAM DD_INVALID_DELETE_STRUCTURE sTable
12956>>>>>                Procedure_Return
12957>>>>>            End
12957>>>>>>
12957>>>>>        End
12957>>>>>>
12957>>>>>        Forward Send Request_Delete
12959>>>>>    End_Procedure
12960>>>>>    
12960>>>>>    // Set status-line help for the passed field. This could have been named
12960>>>>>    // Set Field_Status_Help but this keeps this message interface consistent
12960>>>>>    // with the rest of DF for windows.
12960>>>>>    Procedure Set Status_Help Integer iField String sVal
12962>>>>>        Set Value of (StatusHelp_Array(Self)) iField to sVal
12963>>>>>    End_Procedure
12964>>>>>    
12964>>>>>    // Get status-line help for the passed field. This could have been named
12964>>>>>    // Get Field_Status_Help but this keeps this message interface consistent
12964>>>>>    // with the rest of DF for windows.
12964>>>>>    Function Status_Help Integer iField Returns String
12966>>>>>        String sHelp
12966>>>>>        Integer iObj
12966>>>>>        Move (StatusHelp_Array(Self)) to iObj
12967>>>>>        If (Item_Count(iObj)>iField) Begin
12969>>>>>            Get value of iObj iField to sHelp
12970>>>>>            If (sHelp = '0') ;                Move '' to shelp
12973>>>>>        End
12973>>>>>>
12973>>>>>        Function_Return shelp
12974>>>>>    End_Function
12975>>>>>    
12975>>>>>    // Get status-line help for the passed file and field. This is called
12975>>>>>    // by DEOs (or any other object) that needs help for a particular file
12975>>>>>    // and field.
12975>>>>>    Function File_Field_Status_Help Integer iFile Integer iField Returns String
12977>>>>>        Integer iDSO
12977>>>>>        String sValue
12977>>>>>        Get Data_set iFile to iDSO
12978>>>>>        If iDSO ;            Get Status_Help of iDSO iField to sValue
12981>>>>>        Function_Return sValue
12982>>>>>    End_Function
12983>>>>>    
12983>>>>>    // Allows user to set a mask type. Legal value is any of the current mask
12983>>>>>    // window types. 0 Means undefined.
12983>>>>>    Procedure Set Field_Mask_Type Integer iField Integer iType
12985>>>>>        Set Field_Mask_Type of (FieldMask_Array(Self)) iField to iType
12986>>>>>    End_Procedure
12987>>>>>    
12987>>>>>    Function Field_Mask_Type Integer iField Returns Integer
12989>>>>>        Function_Return (Field_Mask_Type(FieldMask_Array(Self),iField))
12990>>>>>    End_Function
12991>>>>>    
12991>>>>>    Function File_Field_Mask_Type Integer iFile Integer iField Returns Integer
12993>>>>>        Integer iDSO
12993>>>>>        Get Data_set iFile to iDSO
12994>>>>>        If iDSO ;            Function_Return (Field_Mask_Type(iDSO,iField))
12997>>>>>    End_Function
12998>>>>>    
12998>>>>>    // If TRUE the value returned by DEO will contain mask characters.
12998>>>>>    // Currently not supported.
12998>>>>>    Procedure Set Field_Mask_Value_State Integer iField Integer iState
13000>>>>>        Set Field_Mask_Value_State of (FieldMask_Array(Self)) iField to iState
13001>>>>>    End_Procedure
13002>>>>>    
13002>>>>>    Function Field_Mask_Value_State Integer iField Returns Integer
13004>>>>>        Function_Return (Field_Mask_Value_State(FieldMask_Array(Self),iField))
13005>>>>>    End_Function
13006>>>>>    
13006>>>>>    Function File_Field_Mask_Value_State Integer iFile Integer iField Returns Integer
13008>>>>>        Integer iDSO
13008>>>>>        Get Data_set iFile to iDSO
13009>>>>>        If iDSO ;            Function_Return (Field_Mask_Value_State(iDSO,iField))
13012>>>>>    End_Function
13013>>>>>    
13013>>>>>    // Allows user to set a mask strinng. Legal value is any of the current
13013>>>>>    // masks. Note an empty string with a valid mask type implies that the
13013>>>>>    // system should figure it out by itself.
13013>>>>>    Procedure Set Field_Mask Integer iField String sMask
13015>>>>>        Set Field_Mask of (FieldMask_Array(Self)) iField to sMask
13016>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Mask_Changed iField sMask
13019>>>>>    End_Procedure
13020>>>>>    
13020>>>>>    Function Field_Mask Integer iField Returns String
13022>>>>>        Function_Return (Field_Mask(FieldMask_Array(Self),iField))
13023>>>>>    End_Function
13024>>>>>    
13024>>>>>    Function File_Field_Mask Integer iFile Integer iField Returns String
13026>>>>>        Integer iDSO
13026>>>>>        String sValue
13026>>>>>        Get Data_set iFile to iDSO
13027>>>>>        If iDSO ;            Get Field_Mask of iDSO iField to sValue
13030>>>>>        Function_Return sValue
13031>>>>>    End_Function
13032>>>>>    
13032>>>>>    // Short for field. This is normally used by grid headers.
13032>>>>>    Procedure Set Field_Label_Short Integer iField String sName
13034>>>>>        Set Field_Label_Short of (FieldMask_Array(Self)) iField to sName
13035>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 0 sName
13038>>>>>    End_Procedure
13039>>>>>    
13039>>>>>    Function Field_Label_Short Integer iField Returns String
13041>>>>>        Function_Return (Field_Label_Short(FieldMask_Array(Self),iField))
13042>>>>>    End_Function
13043>>>>>    
13043>>>>>    Function File_Field_Label_Short Integer iFile Integer iField Returns String
13045>>>>>        Integer iDSO
13045>>>>>        String sValue
13045>>>>>        Get Data_set iFile to iDSO
13046>>>>>        If iDSO ;            Get Field_Label_Short of iDSO iField to sValue
13049>>>>>        Function_Return sValue
13050>>>>>    End_Function
13051>>>>>    
13051>>>>>    // Full Name for field. This is normally used by form labels
13051>>>>>    Procedure Set Field_Label_Long Integer iField String sName
13053>>>>>        Set Field_Label_Long of (FieldMask_Array(Self)) iField to sName
13054>>>>>        If (Data_Set_User_Interface_Count(Self)) ;            Send Field_Label_Changed iField 1 sName
13057>>>>>    End_Procedure
13058>>>>>    
13058>>>>>    Function Field_Label_Long Integer iField Returns String
13060>>>>>        Function_Return (Field_Label_Long(FieldMask_Array(Self),iField))
13061>>>>>    End_Function
13062>>>>>    
13062>>>>>    Function File_Field_Label_Long Integer iFile Integer iField Returns String
13064>>>>>        Integer iDSO
13064>>>>>        String sValue
13064>>>>>        Get Data_set iFile to iDSO
13065>>>>>        If iDSO ;            Get Field_Label_Long of iDSO iField to sValue
13068>>>>>        Function_Return sValue
13069>>>>>    End_Function
13070>>>>>    
13070>>>>>    // This is not really a DD attribute (it is in the API) but it is
13070>>>>>    // appropriate to be accessed from the DD
13070>>>>>    Function Field_Label_Tag Integer iField Returns String
13072>>>>>        String sName
13072>>>>>        Integer iFile
13072>>>>>        Get Main_File to iFile
13073>>>>>        If iFile ;            Get_Attribute DF_FIELD_NAME of iFile iField to sName
13078>>>>>        Function_Return sName
13079>>>>>    End_Function
13080>>>>>    
13080>>>>>    Function SmartCase String sName Returns String
13082>>>>>        Integer iPos iNewPos
13082>>>>>        String sRight
13082>>>>>        Move (Replaces("_",lowercase(sName)," ")) to sName
13083>>>>>        Move (Trim (Replaces(".",sName," "))) to sName
13084>>>>>        Move 1 to iPos
13085>>>>>        Repeat
13085>>>>>>
13085>>>>>            Move (mid(sName,255,iPos+1)) to sRight
13086>>>>>            Move (left(sName,iPos-1) + Uppercase(mid(sName,1,iPos)) + sRight) to sName
13087>>>>>            Move (Pos( " ", sRight)) to iNewPos
13088>>>>>            If (iNewPos = 0) ;                Break
13091>>>>>            Add (iNewPos+1) to iPos
13092>>>>>        Loop
13093>>>>>>
13093>>>>>        Function_Return sName
13094>>>>>    End_Function
13095>>>>>    
13095>>>>>    Enumeration_List
13095>>>>>        Define DD_LABEL_SHORT
13095>>>>>        Define DD_LABEL_LONG
13095>>>>>        Define DD_LABEL_TAG
13095>>>>>    End_Enumeration_List
13095>>>>>    
13095>>>>>    // Handy function to get the label for a field. Three "types" are
13095>>>>>    // supported:
13095>>>>>    // DD_LABEL_SHORT  use short, if none use long, if none use smart tag
13095>>>>>    // DD_LABEL_LONG   use long, if none use smart tag
13095>>>>>    // DD_LABEL_TAG    use smart tag
13095>>>>>    // If you want an explicit field name use oneof the other messages.
13095>>>>>    Function Field_Label Integer iField Integer iType Returns String
13097>>>>>        Integer iServer
13097>>>>>        String sValue
13097>>>>>        If (iType = DD_LABEL_SHORT) ;  // 0 = Short            Get Field_Label_Short iField to sValue
13100>>>>>        If (iType = DD_LABEL_LONG or (iType=DD_LABEL_SHORT and sValue='')) ;            Get Field_Label_Long iField to sValue
13103>>>>>        If (iType = DD_LABEL_TAG or sValue="") Begin
13105>>>>>            Get Field_Label_Tag iField to sValue
13106>>>>>            Get SmartCase sValue to sValue
13107>>>>>        End
13107>>>>>>
13107>>>>>        Function_Return sValue
13108>>>>>    End_Function
13109>>>>>    
13109>>>>>    Function File_Field_Label Integer iFile Integer iField Integer iType Returns String
13111>>>>>        Integer iDSO
13111>>>>>        String sValue
13111>>>>>        Get Data_set iFile to iDSO
13112>>>>>        If iDSO ;            Get Field_Label of iDSO iField iType to sValue
13115>>>>>        Function_Return sValue
13116>>>>>    End_Function
13117>>>>>    
13117>>>>>    // Normally this will not be used by a running program. However, it
13117>>>>>    // could be possible to create classes dynamically at runtime, in which
13117>>>>>    // case these messages could be useful. No File_Field is provided. If the
13117>>>>>    // person knows enough to create dynamic classes they can find the DD.
13117>>>>>    Procedure Set Field_Class_Name Integer iField String sName
13119>>>>>        Set Field_Class_Name of (FieldMask_Array(Self)) iField to sName
13120>>>>>    End_Procedure
13121>>>>>    
13121>>>>>    Function Field_Class_Name Integer iField Returns String
13123>>>>>        Function_Return (Field_Class_Name(FieldMask_Array(Self),iField))
13124>>>>>    End_Function
13125>>>>>    
13125>>>>>    // This procedure should be used to set a specific error number and
13125>>>>>    // message for a particular field. This can be used with the Field_error
13125>>>>>    // message to generate this error during a validation.
13125>>>>>    Procedure Set Field_Error Integer iField Integer iErr String sMsg
13127>>>>>        Set Field_Error of (Field_Attributes(Self)) iField to iErr sMsg
13128>>>>>    End_Procedure
13129>>>>>    
13129>>>>>    // Used to retreive the error number and message for a particular field
13129>>>>>    Function Field_Error_Number Integer iField Returns Integer
13131>>>>>        Function_Return (Field_Error_Number(Field_Attributes(Self),iField))
13132>>>>>    End_Function
13133>>>>>    
13133>>>>>    Function Field_Error_Message Integer iField Returns String
13135>>>>>        Function_Return (Field_Error_Message(Field_Attributes(Self),iField))
13136>>>>>    End_Function
13137>>>>>    
13137>>>>>    // This procedure is used to declare an error on a standard field
13137>>>>>    // validation violation like Range or Check.
13137>>>>>    // Can pass 1 to 4 params:
13137>>>>>    // iField -                  Standard usage. Generates field as defined
13137>>>>>    //                           for this field. If field=-1, General error
13137>>>>>    // iField SDefault           If no field error mess (or field=-1) use
13137>>>>>    //                           the default message
13137>>>>>    // iField sDefault sParam1 {sParam2} Replace occurances of @PARAM1 and
13137>>>>>    //                           @PARAM2 in text with these values
13137>>>>>    Procedure Field_Error Integer iField String sDefault ;            String sParam1 String sParam2
13139>>>>>        Integer iErr
13139>>>>>        String  sMess
13139>>>>>        If (iField >= 0) Begin
13141>>>>>            Get Field_Error_Number  iField to iErr
13142>>>>>            Get Field_Error_Message iField to sMess
13143>>>>>        End
13143>>>>>>
13143>>>>>        If (sMess="" and Num_Arguments>1) ;            Move sDefault to sMess
13146>>>>>        If (Num_Arguments = 4) ;            Send Data_Set_Error iField iErr sMess sParam1 sParam2
13149>>>>>        Else If (Num_Arguments = 3) ;            Send Data_Set_Error iField iErr sMess sParam1
13153>>>>>        Else ;            Send Data_Set_Error iField iErr sMess
13155>>>>>    End_Procedure
13156>>>>>    
13156>>>>>    // Procedure Data_Set_Error
13156>>>>>    // This procedure is used to declare a data-set error. Pass error number
13156>>>>>    // and optional error message text.
13156>>>>>    // If iErr is 0, use the default error number.
13156>>>>>    // sParam1 and sParam2 are optional. If passed they are used as text
13156>>>>>    // replacements for @PARAM1 and @PARAM2.
13156>>>>>    // We pass iField (even though we don't use it) so that augmentations
13156>>>>>    // could support error logging down to a field level. If a non-field error
13156>>>>>    // is required the developer should pass negative values (e.g., -1)
13156>>>>>    // This will redirect errors locally if not already redirected
13156>>>>>    //
13156>>>>>    // Altered to additionally support %1 %2 replacements as well as
13156>>>>>    // replacements for @PARAM1 and @PARAM2. (vdf8.2)
13156>>>>>    Procedure Data_set_error Integer iField Integer iErr String sMess ;            String sParam1 String sParam2
13158>>>>>        Integer iOldField
13158>>>>>        Get Current_validate_field to iOldField
13159>>>>>        If (iField <> 0) ;            Set Current_Validate_field to iField
13162>>>>>        
13162>>>>>        If (iErr = 0) ; // if no error is passes, used a default error            Move DD_DEFAULT_ERROR_NUMBER to iErr
13165>>>>>        
13165>>>>>        If (sMess > "") Begin
13167>>>>>            
13167>>>>>            // Support message replacements.. Up to two values
13167>>>>>            // altered to support @Param1/2 and %1 %2 messages
13167>>>>>            If (Num_Arguments>3) Begin
13169>>>>>                Move (Replaces("@PARAM1", sMess, sParam1)) to sMess
13170>>>>>                If (Num_Arguments>4) Begin
13172>>>>>                    Move (Replaces("@PARAM2", sMess, sParam2)) to sMess
13173>>>>>                    Move (SFormat(sMess,sParam1,sParam2)) to sMess
13174>>>>>                End
13174>>>>>>
13174>>>>>                Else Begin
13175>>>>>                    Move (SFormat(sMess,sParam1)) to sMess
13176>>>>>                End
13176>>>>>>
13176>>>>>            End
13176>>>>>>
13176>>>>>            Move Self to ghoErrorSource
13177>>>>>            Error iErr sMess
13178>>>>>>
13178>>>>>            Move 0 to ghoErrorSource
13179>>>>>        End
13179>>>>>>
13179>>>>>        Else ;            Send Operation_Not_Allowed iErr
13181>>>>>        Set Current_validate_field to iOldField
13182>>>>>        Move True to Err // make sure Err is still set
13183>>>>>    End_Procedure
13184>>>>>    
13184>>>>>    // Augment to support Error_Report_Mode. Allows errors without error mess
13184>>>>>    // This will redirect errors locally if not already redirected
13184>>>>>    Procedure Operation_Not_Allowed Integer iErr
13186>>>>>        Integer bOK
13186>>>>>        Move Self to ghoErrorSource
13187>>>>>        Forward Send Operation_Not_Allowed iErr
13189>>>>>        Move 0 to ghoErrorSource
13190>>>>>    End_Procedure
13191>>>>>    
13191>>>>>    // Local error handler. When errors are redirected to the DD this proce-
13191>>>>>    // dure handles the errors. If error_report_mode is NO-report it sets
13191>>>>>    // the err indicator and returns. Else it redirects the error to the
13191>>>>>    // main error handler first moving its ID to ghoErrorSource. This way the
13191>>>>>    // handler knows who sent this message and will get additional error info
13191>>>>>    // by calling Get Extended_error_message
13191>>>>>    Procedure Error_Report Integer iError Integer iLine String ErrMsg
13193>>>>>        Integer hoErrId
13193>>>>>        Integer bRedirect
13193>>>>>        If (Error_Processing_State(Self)) ;  // this prevents recursion            Procedure_Return
13196>>>>>        Set Error_Processing_State to True
13197>>>>>        
13197>>>>>        // if no report mode, just set the err indicator to true.
13197>>>>>        If (Error_Report_Mode(Self)=DD_ERROR_NO_REPORT) ;            Move True to Err
13200>>>>>        Else Begin
13201>>>>>            Get Old_error_object_id to hoErrId  // the original error handler
13202>>>>>            If hoErrId Begin
13204>>>>>                Move (ghoErrorSource=0) to bRedirect
13205>>>>>                If bRedirect ;                    Move Self to ghoErrorSource // error handler can use this
13208>>>>>                Move hoErrID to Error_object_id
13209>>>>>                Send Error_Report to hoErrId iError iLine ErrMsg
13210>>>>>                Move Self to Error_object_id
13211>>>>>                If bRedirect ;                    Move 0 to ghoErrorSource
13214>>>>>            End
13214>>>>>>
13214>>>>>            Else ;                Send error_report of desktop iError iLine ErrMsg
13216>>>>>            //else forward send error_report iError iLine ErrMsg
13216>>>>>        End
13216>>>>>>
13216>>>>>        Set Error_Processing_State to False
13217>>>>>    End_Procedure
13218>>>>>    
13218>>>>>    // This is called (by the system error handler) to get additional informa-
13218>>>>>    // tion about the error. Returns a multi line string with each line
13218>>>>>    // separated by a "\n". Return the file number, name, and if possible
13218>>>>>    // the field number and name.
13218>>>>>    Function Extended_Error_Message Returns String
13220>>>>>        String sExtMess
13220>>>>>        String sFile
13220>>>>>        Integer iFile iField
13220>>>>>        Get main_file to iFile
13221>>>>>        Get Current_Validate_Field to iField
13222>>>>>        Get ErrorMessageTableName iFile to sFile
13223>>>>>        Move (DD_FILE_TEXT* String(iFile) * "-" * sFile) to sExtMess
13224>>>>>        If (iField > 0) ;            Append sExtMess "\n" ;            (DD_FIELD_TEXT* String(iField) * "-" * Field_Label(Self,iField,DD_LABEL_LONG))
13228>>>>>        Set Current_Validate_Field to 0
13229>>>>>        Function_Return sExtMess
13230>>>>>    End_Function
13231>>>>>    
13231>>>>>    Function Extended_Error_File Returns Integer
13233>>>>>        Function_Return (Main_File(Self))
13234>>>>>    End_Function
13235>>>>>    
13235>>>>>    Function Extended_Error_Field Returns Integer
13237>>>>>        Function_Return (Current_Validate_Field(Self))
13238>>>>>    End_Function
13239>>>>>    
13239>>>>>    
13239>>>>>    // The following messages are used to control smart file mode exception
13239>>>>>    // handling. The message "Send Add_system_File file# Fg" allows you to
13239>>>>>    // add system files (or any other files not known to the dso structure)
13239>>>>>    // within define_fields. This allows you to not have to augment the msg
13239>>>>>    // reset_filemodes_for_lock. The only truly public messages here are
13239>>>>>    // Add_system_file and Remove_system_File (which s/b rarely used).
13239>>>>>    
13239>>>>>    // Adds a system file for smart_file_mode handling. A second optional
13239>>>>>    // parameter may be passed to determine of the sys file should only be
13239>>>>>    // locked during a new save (and not during a delete or a save of an
13239>>>>>    // existing record). It is expected that this will be the only public
13239>>>>>    // message used to control smart filemode. All of the remaining sys file
13239>>>>>    // messages are considered advanced.
13239>>>>>    Procedure Add_System_File Integer iFile Integer iLock_Mode
13241>>>>>        Integer iobj iCnt iMode
13241>>>>>        If (Num_arguments = 1) ;            Move DD_Lock_on_All to iMode
13244>>>>>        Else ;            Move iLock_Mode     to iMode
13246>>>>>        Move (system_file_obj(Self)) to iObj
13247>>>>>        Get Item_Count  of iObj to iCnt
13248>>>>>        Set Array_Value of iObj iCnt to iFile
13249>>>>>        Increment iCnt
13250>>>>>        Set Array_Value of iObj iCnt to iMode
13251>>>>>    End_Procedure
13252>>>>>    
13252>>>>>    // Return number of system files
13252>>>>>    Function System_File_Count Returns Integer
13254>>>>>        Function_Return (Item_Count(System_File_Obj(Self))/2)
13255>>>>>    End_Function
13256>>>>>    
13256>>>>>    // Returns system file number for passed item.
13256>>>>>    Function System_File_Number Integer iItem Returns Integer
13258>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2))
13259>>>>>    End_Function
13260>>>>>    
13260>>>>>    // Returns system flag to determine if file is only used during a new
13260>>>>>    // save (and not during an exiting save or a delete).
13260>>>>>    Function System_File_Lock_Mode Integer iItem Returns Integer
13262>>>>>        Function_Return (Integer_Value(System_File_Obj(Self),iItem*2+1))
13263>>>>>    End_Function
13264>>>>>    
13264>>>>>    // Removes a system_file for smart_file_Mode handling. This remvoes the
13264>>>>>    // first occurance of the file (S/b the only occurance). We assume that
13264>>>>>    // this will be rarely used.
13264>>>>>    Procedure Remove_System_File Integer iFile
13266>>>>>        Integer iobj iCnt iItmCnt
13266>>>>>        Get System_file_Count to iItmCnt
13267>>>>>        Decrement iItmCnt
13268>>>>>        For iCnt from 0 to iItmCnt
13274>>>>>>
13274>>>>>            If (System_File_Number(Self,iCnt)=iFile) Begin
13276>>>>>                Move (system_file_obj(Self)) to iObj
13277>>>>>                Move (iCnt*2) to iCnt
13278>>>>>                Send Delete_Item to iObj iCnt
13279>>>>>                Send Delete_Item to iObj iCnt
13280>>>>>                Procedure_Return
13281>>>>>            End
13281>>>>>>
13281>>>>>        Loop
13282>>>>>>
13282>>>>>    End_Procedure
13283>>>>>    
13283>>>>>    // These set messages, add_client_file, add_server_file and add_system_file
13283>>>>>    // were added to more easily support visual DD class modeling. They do the
13283>>>>>    // same thing the Send counterpart messages do
13283>>>>>    
13283>>>>>    Procedure Set Add_Client_File Integer iFile
13285>>>>>        Send Add_Client_File iFile
13286>>>>>    End_Procedure
13287>>>>>    
13287>>>>>    Procedure Set Add_Server_File Integer iFile
13289>>>>>        Send Add_Server_File iFile
13290>>>>>    End_Procedure
13291>>>>>    
13291>>>>>    Procedure Set Add_System_File Integer iFile Integer iLock_Mode
13293>>>>>        // allow no arguments because the old message allowed this
13293>>>>>        If (Num_arguments=1) Begin
13295>>>>>            Send Add_System_File iFile
13296>>>>>        End
13296>>>>>>
13296>>>>>        Else Begin
13297>>>>>            Send Add_System_File iFile iLock_Mode
13298>>>>>        End
13298>>>>>>
13298>>>>>    End_Procedure
13299>>>>>    
13299>>>>>    // The Set Field_Auto_Increment method replaces the need to use the Define_Auto_Incrmement
13299>>>>>    // command. This models more easily and it supports multiple auto-increment fields
13299>>>>>    Procedure Set Field_Auto_Increment Integer iField Integer iSysFile Integer iSysField
13301>>>>>        Integer[] AutoIncFields
13302>>>>>        tDDFileField[] SysFileFields
13302>>>>>        tDDFileField[] SysFileFields
13303>>>>>        Integer iIndex
13303>>>>>        
13303>>>>>        If (iField=0 or (iSysFile<>0 and iSysField=0)) Begin
13305>>>>>            Error DFERR_PROGRAM "Auto-increment source or destination field is 0"
13306>>>>>>
13306>>>>>            Procedure_Return
13307>>>>>        End
13307>>>>>>
13307>>>>>        // setting the sysfile to 0 is valid. It can be used to clear an existing sysfile
13307>>>>>        If (iSysFile=0) Begin
13309>>>>>            Move 0 to iSysField
13310>>>>>        End
13310>>>>>>
13310>>>>>        Get pAutoIncrementFields to AutoIncFields
13311>>>>>        Get pAutoIncrementSysFileFields to SysFileFields
13312>>>>>        // the destination field array is a list of fields that have auto-incr info. There
13312>>>>>        // can only be zero or one entry per field arranged in no defined order.
13312>>>>>        // see if field is already defined. If not add this to the end.
13312>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
13313>>>>>        If (iIndex=-1) Begin
13315>>>>>            Move (SizeOfArray(SysFileFields)) to iIndex
13316>>>>>        End
13316>>>>>>
13316>>>>>        Move iField    to AutoIncFields[iIndex]
13317>>>>>        Move iSysFile  to SysFileFields[iIndex].iFile
13318>>>>>        Move iSysField to SysFileFields[iIndex].iField
13319>>>>>        Set pAutoIncrementFields to AutoIncFields
13320>>>>>        Set pAutoIncrementSysFileFields to SysFileFields
13321>>>>>    End_Procedure
13322>>>>>    
13322>>>>>    // Get auto-increment system file/field value for a field. There really should be no
13322>>>>>    // reason to ever need this. Field is returned byref
13322>>>>>    Function Field_Auto_Increment Integer iField Integer ByRef iSysField Returns Integer
13324>>>>>        Integer iSysFile
13324>>>>>        Integer[] AutoIncFields
13325>>>>>        tDDFileField[] SysFileFields
13325>>>>>        tDDFileField[] SysFileFields
13326>>>>>        Integer iIndex
13326>>>>>        
13326>>>>>        Get pAutoIncrementFields to AutoIncFields
13327>>>>>        Move (SearchArray(iField,AutoIncFields)) to iIndex
13328>>>>>        If (iIndex>-1) Begin
13330>>>>>            Get pAutoIncrementSysFileFields to SysFileFields
13331>>>>>            Move SysFileFields[iIndex].iFile to iSysFile
13332>>>>>            Move SysFileFields[iIndex].iField to iSysField
13333>>>>>        End
13333>>>>>>
13333>>>>>        Else Begin
13334>>>>>            Move 0 to iSysFile
13335>>>>>            Move 0 to iSysField
13336>>>>>        End
13336>>>>>>
13336>>>>>        Function_Return iSysFile
13337>>>>>    End_Function
13338>>>>>    
13338>>>>>    
13338>>>>>    // Augmented to set any system files defined via the Add_System_file
13338>>>>>    // message. This allows us to hide this procedure for the vast majority
13338>>>>>    // of cases.
13338>>>>>    Procedure Reset_Filemodes_For_Lock
13340>>>>>        Boolean bNewRec
13340>>>>>        Integer  iItmCnt iCnt iMode iFile
13340>>>>>        Integer iMain iMaster iOpts
13340>>>>>        Handle hoDD
13340>>>>>        
13340>>>>>        Forward Send Reset_Filemodes_for_lock
13342>>>>>        
13342>>>>>        Get System_File_Count to iItmCnt
13343>>>>>        If iItmCnt Begin
13345>>>>>            Move (not(HasRecord(Self))) to bNewRec
13346>>>>>            Decrement iItmCnt
13347>>>>>            For iCnt from 0 to iItmCnt
13353>>>>>>
13353>>>>>                Get System_File_Number         iCnt to iFile
13354>>>>>                Get System_File_Lock_Mode iCnt to iMode
13355>>>>>                If ( (iMode=DD_Lock_on_All) or ;                    (Operation_Mode=MODE_DELETING and (iMode iand DD_Lock_on_Delete) ) or ;                    (Operation_Mode=MODE_SAVING and ( (iMode iand DD_Lock_on_Save) or ;                    ( (iMode iand DD_Lock_on_New_Save) and bNewRec) ) ) ) Begin
13357>>>>>                    Set_Attribute DF_FILE_MODE of iFile to DF_FILEMODE_DEFAULT
13360>>>>>                End
13360>>>>>>
13360>>>>>            Loop
13361>>>>>>
13361>>>>>        End
13361>>>>>>
13361>>>>>        
13361>>>>>        // augment to support DD magnaged alias tables.
13361>>>>>        // If an alias, set the alias to the proper alias no locks only if
13361>>>>>        // the master file is actually part of this DDO structure. This allows you
13361>>>>>        // to use alias files without the master being present (or even open). This will work without needing
13361>>>>>        // to set the Master|Alias DF_FILE_ALIAS attributes. If the file is master and part of the DDO structure
13361>>>>>        // it will already have its No_locks attribute cleared. If not part of the DD, its not needed.
13361>>>>>        //
13361>>>>>        Get MasterForAlias to iMaster
13362>>>>>        If iMaster Begin
13364>>>>>            Get Main_File to iMain
13365>>>>>            Get Data_Set iMaster to hoDD // is the master in the DD structure
13366>>>>>            If hoDD Begin
13368>>>>>                Get_Attribute DF_FILE_MODE of iMain to iOpts
13371>>>>>                Set_Attribute DF_FILE_MODE of iMain to (iOpts ior DF_FILEMODE_NO_LOCKS)
13374>>>>>                // note this will be reset to what it was when the transaction ends
13374>>>>>            End
13374>>>>>>
13374>>>>>        End
13374>>>>>>
13374>>>>>        
13374>>>>>    End_Procedure
13375>>>>>    
13375>>>>>    // Augmented to handle auto-increment fields if defined. The value from
13375>>>>>    // the auto-incre sys file is incremented, saved and moved to the new
13375>>>>>    // record. As of 17.0 this is no longer in Creating, which is called after
13375>>>>>    // AutoIncrement.
13375>>>>>    Procedure AutoIncrement
13377>>>>>        Integer iSrcFile iSrcField i iAutoFields
13377>>>>>        Integer iDestFile iDestField
13377>>>>>        Number nNum
13377>>>>>        Integer[] AutoIncFields
13378>>>>>        tDDFileField[] AutoIncSysFileFields
13378>>>>>        tDDFileField[] AutoIncSysFileFields
13379>>>>>        Handle hoOwner
13379>>>>>        
13379>>>>>        Forward Send AutoIncrement
13381>>>>>        
13381>>>>>        // this supports the older Define_Auto_Increment logic. Only one is supported
13381>>>>>        // this is exists for backwards compatibility
13381>>>>>        Get Auto_Increment_Source_File to iSrcFile
13382>>>>>        If iSrcFile Begin // do we have auto increment?
13384>>>>>            Get Auto_Increment_Source_Field  to iSrcField
13385>>>>>            Get Auto_Increment_Dest_Field    to iDestField
13386>>>>>            If (iSrcField and iDestField) Begin  // just in case of error
13388>>>>>                Get Main_file to iDestFile
13389>>>>>                Get_Field_Value iSrcFile iSrcField to nNum
13392>>>>>                Move (nNum+1) to nNum
13393>>>>>                Set_Field_Value iSrcFile  iSrcField  to nNum
13396>>>>>                Set_Field_Value iDestFile iDestField to nNum
13399>>>>>                // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
13399>>>>>                // if the DD is not a parent file, it is a sysfile and we must save it
13399>>>>>                Get Which_Data_Set iSrcFile to hoOwner
13400>>>>>                If not hoOwner Begin
13402>>>>>                    SaveRecord iSrcFile
13403>>>>>                End
13403>>>>>>
13403>>>>>            End
13403>>>>>>
13403>>>>>        End
13403>>>>>>
13403>>>>>        // this supports the newer set syntax which support multiple fields. It is expected that you will
13403>>>>>        // use one syntax of the other, not both. If you use the old syntax, you cannot use the new one
13403>>>>>        Else Begin
13404>>>>>            Get pAutoIncrementFields to AutoIncFields
13405>>>>>            Move (SizeOfArray(AutoIncFields)) to iAutoFields
13406>>>>>            If (iAutoFields>0) Begin
13408>>>>>                Get pAutoIncrementSysFileFields to AutoIncSysFileFields
13409>>>>>                Get Main_file to iDestFile
13410>>>>>                For i from 0 to (iAutoFields-1)
13416>>>>>>
13416>>>>>                    // it is legal to set the sysfile to 0, this means it has been cleared and is not used
13416>>>>>                    If (AutoIncSysFileFields[i].iFile>0) Begin
13418>>>>>                        // we assume both the fields are valid and that they've already been tested when added
13418>>>>>                        Get_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
13421>>>>>                        Move (nNum+1) to nNum
13422>>>>>                        Set_Field_Value AutoIncSysFileFields[i].iFile AutoIncSysFileFields[i].iField to nNum
13425>>>>>                        Set_Field_Value iDestFile AutoIncFields[i] to nNum
13428>>>>>                        // if the file's DD is a parent file in the structure, this will get saved as part of normal operations
13428>>>>>                        // if the DD is not a parent file, it is a sysfile and we must save it
13428>>>>>                        Get Which_Data_Set AutoIncSysFileFields[i].iFile to hoOwner
13429>>>>>                        If not hoOwner Begin
13431>>>>>                            SaveRecord AutoIncSysFileFields[i].iFile
13432>>>>>                        End
13432>>>>>>
13432>>>>>                    End
13432>>>>>>
13432>>>>>                Loop
13433>>>>>>
13433>>>>>            End
13433>>>>>>
13433>>>>>        End
13433>>>>>>
13433>>>>>        
13433>>>>>    End_Procedure
13434>>>>>    
13434>>>>>    // Augmented to fix a bug in the data-set C code. When a record is saved
13434>>>>>    // as part of a delete operation OnNewCurrentRecord is not called. It
13434>>>>>    // should be. We will do this in flex code for now.
13434>>>>>    Procedure Save_Main_File
13436>>>>>        RowID riRec
13436>>>>>        Integer iRec iMain
13436>>>>>        Boolean bRecnumTable bChanged
13436>>>>>        
13436>>>>>        Get Main_File to iMain
13437>>>>>        Get_Attribute DF_FILE_CHANGED of iMain to bChanged
13440>>>>>        If bChanged Begin
13442>>>>>            Send OnSaveRecord // OnSaveRecord sent if there is something to save
13443>>>>>        End
13443>>>>>>
13443>>>>>        
13443>>>>>        Forward Send Save_Main_File
13445>>>>>        
13445>>>>>        If (Operation_Mode = MODE_DELETING) Begin  // during a delete the crnt
13447>>>>>            Get CurrentRowId to riRec             // rec of parents do not change
13448>>>>>            Send OnNewCurrentRecord riRec riRec  // so old and new are the same.
13449>>>>>            // for backwards compatibility reasons, we also send new_current_record if appropriate
13449>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of iMain to bRecnumTable
13452>>>>>            If (bRecnumTable) Begin
13454>>>>>                Get_Field_Value iMain 0 to iRec
13457>>>>>                Send New_Current_Record iRec iRec
13458>>>>>            End
13458>>>>>>
13458>>>>>        End
13458>>>>>>
13458>>>>>    End_Procedure
13459>>>>>    
13459>>>>>    // Augmented to not clear if a system-file. The auto-latching of views
13459>>>>>    // may cause a sys file DD to get cleared. This corrects this. This really
13459>>>>>    // belongs in Data_set (C) but we will not risk this for now.
13459>>>>>    Procedure Clear_Main_File
13461>>>>>        Integer iFile iIsSys
13461>>>>>        Get Main_File to iFile
13462>>>>>        If iFile Begin
13464>>>>>            Get_Attribute DF_FILE_IS_SYSTEM_FILE of iFile to iIsSys
13467>>>>>            If iIsSys ;                Procedure_Return
13470>>>>>        End
13470>>>>>>
13470>>>>>        Forward Send Clear_main_file
13472>>>>>    End_Procedure
13473>>>>>    
13473>>>>>    // Executes a request_find on the mainfile. This is easier that having to
13473>>>>>    // pass file number all the time. Useful for batch operations.
13473>>>>>    // If Index is 0, use find_by_recnum (it handles a recnum of 0 better)
13473>>>>>    Procedure Find Integer iMode Integer iIndex
13475>>>>>        Integer iFile
13475>>>>>        Integer iRec
13475>>>>>        Get Main_file to iFile
13476>>>>>        If (iIndex<>0 or iMode<>EQ) ;            Send request_find iMode iFile iIndex
13479>>>>>        Else Begin
13480>>>>>            // this would never happen with row ID
13480>>>>>            Get_Field_Value iFile 0 to iRec // get recnum value
13483>>>>>            Send find_by_recnum iFile iRec
13484>>>>>        End
13484>>>>>>
13484>>>>>    End_Procedure
13485>>>>>    
13485>>>>>    // So many people make the mistake of using requeset_clear and request_
13485>>>>>    // clear_all that will support these are alteratives to clear and
13485>>>>>    // clear_all. The preferred messages remain Clear and Clear_all.
13485>>>>>    // This would not work if you nested DEOs within DSOs (no-one does).
13485>>>>>    Procedure Request_Clear
13487>>>>>        Send Clear
13488>>>>>    End_Procedure
13489>>>>>    
13489>>>>>    Procedure Request_Clear_All
13491>>>>>        Send Clear_All
13492>>>>>    End_Procedure
13493>>>>>    
13493>>>>>    // we want changed_state to always go through the
13493>>>>>    // Record_buffer object. From there it is sent to
13493>>>>>    // here. So if state or RB does not match we must
13493>>>>>    // send to the RB object...it will delegate to here
13493>>>>>    
13493>>>>>    Procedure Set Changed_State Integer bState
13495>>>>>        Integer hRB
13495>>>>>        Move (record_buffer(Self)) to hRB
13496>>>>>        If (hRB and changed_state(hRB)<>bState) ;            Set changed_state of hRB to bState
13499>>>>>        Else ;            Forward Set changed_state to bState
13502>>>>>    End_Procedure
13503>>>>>    
13503>>>>>    // this lets us use the new attach logic
13503>>>>>    
13503>>>>>    // This is a smarter attach than the normal attach command. It only attaches data from a parent
13503>>>>>    // if 1) the DDO parent is connected to the structure and 2) if there is a record to attach. It will
13503>>>>>    // not attach empty records into a child. This should make the finding (and saving) more sensible when
13503>>>>>    // partial DD structures are used. For example, often a report does not all of the parent DDOs - however if
13503>>>>>    // they are not provided, finding can get messed up because blank data is being moved into the child before a
13503>>>>>    // find. This has been a problem since 3.0. This should just make it go away.
13503>>>>>    // as of 17.0, we get the related field info through the local DSO if needed
13503>>>>>    
13503>>>>>    // as if 18.1 this is only called when there is an attachable relationship. This gives us a chance to do any
13503>>>>>    // customizations and to cancel the attach. We've left this to the flex level so we can fine tune attaches.
13503>>>>>    Function ShouldFieldAttach Integer iField Handle hoRelDD Returns Boolean
13505>>>>>        Boolean bDoAttach bChanged
13505>>>>>        Integer iFile iStat iRelFile iType
13505>>>>>        String sValue
13505>>>>>        
13505>>>>>        Get Main_File to iFile
13506>>>>>        Get Main_File of hoRelDD to iRelFile
13507>>>>>        
13507>>>>>        // before we attach check if Find mode and relfile is new and unchanged..if so skip.
13507>>>>>        // If operation_mode is 0, this is probably a Find (item_find sends attach_main_file for some reason).
13507>>>>>        Move True to bDoAttach
13508>>>>>        If (Operation_mode=MODE_FINDING or OPERATION_MODE=0) Begin
13510>>>>>            // we can test the file status to see if we have a record or not. If we have a record, we attach
13510>>>>>            Get_Attribute DF_FILE_STATUS  of iRelFile to iStat
13513>>>>>            If (iStat=DF_FILE_INACTIVE) Begin
13515>>>>>                // if no record, we need to look for changes. We can't just look at the file's changed state because the DD
13515>>>>>                // may have set defaults, which have been moved to the buffer. We should be able to check the DD's changed state
13515>>>>>                // because this is not set with default values. When doing a find entry_update this should be ok. If this were
13515>>>>>                // a save, this would cause problems (but this is not a save). Prior to 17.0 this was not an issue with windows
13515>>>>>                // applications because find entry_updates were done at the DEO level (unlike web applications).
13515>>>>>                Get Changed_State of hoRelDD to bChanged
13516>>>>>                Move bChanged to bDoAttach
13517>>>>>                
13517>>>>>                // special Triumph workaround for Item_Find with blank inner segment. They were counting on the item_find attach_main_file
13517>>>>>                // which would slip through the "no-attach on find when parent is empty optimization". This was needed to force a string segment
13517>>>>>                // that was "" to get filled with spaces from the parent field. The child field was set to "" because of a constrained_clear
13517>>>>>                // in Item_find. This workaround is as narrow as possible. If an item_find attach_main_file (operation_mode=0) and this is
13517>>>>>                // an empty parent (bOk was just set to False), and the field is DF_Ascii and the child value is empty (no trailing spaces)
13517>>>>>                // then force an attach. Since the parent should be "", we can just Set_Field_value to "", which fills the field buffer.
13517>>>>>                // There is no real logic as to why this is being done other than to make it work like it used to with the least
13517>>>>>                // amount of side-effects.
13517>>>>>                If (not(bDoAttach) and OPERATION_MODE=0) Begin
13519>>>>>                    Get_Attribute DF_FIELD_TYPE of iFile iField to iType
13522>>>>>                    If (iType=DF_ASCII) Begin
13524>>>>>                        Get_Field_Value iFile iField to sValue
13527>>>>>                        // if no spaces, this probably was cleared via constrained_clear in Item_Find. We should update
13527>>>>>                        If (Ascii(Left(sValue,1))=0) Begin
13529>>>>>                            Set_Field_Value iFile iField to ""
13532>>>>>                        End
13532>>>>>>
13532>>>>>                    End
13532>>>>>>
13532>>>>>                End
13532>>>>>>
13532>>>>>                
13532>>>>>            End
13532>>>>>>
13532>>>>>        End
13532>>>>>>
13532>>>>>        Function_Return bDoAttach
13533>>>>>    End_Function
13534>>>>>    
13534>>>>>    // Notify all DEOs that a mask has changed.
13534>>>>>    //        this message is sent by set Field_Mask
13534>>>>>    Procedure Field_Mask_Changed Integer iField String sMask
13536>>>>>        Integer i iDEOs iDEO
13536>>>>>        Integer iMain_File
13536>>>>>        Get Main_File to iMain_File
13537>>>>>        Get Data_Set_User_Interface_Count to iDEOs
13538>>>>>        Decrement iDEOs
13539>>>>>        For i from 0 to iDEOs
13545>>>>>>
13545>>>>>            Get Data_Set_User_Interface i to iDEO
13546>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Mask_Changed to iDEO ;                iMain_File iField sMask
13549>>>>>        Loop
13550>>>>>>
13550>>>>>    End_Procedure
13551>>>>>    
13551>>>>>    // Notify all DEOs that a label has changed.
13551>>>>>    //   This message is sent by Set Field_Label_long & Field_Label_Short
13551>>>>>    Procedure Field_label_Changed Integer iField Boolean bLong String sLabel
13553>>>>>        Integer i iDEOs iDEO
13553>>>>>        Integer iMain_File
13553>>>>>        Get Main_File to iMain_File
13554>>>>>        Get Data_Set_User_Interface_Count to iDEOs
13555>>>>>        Decrement iDEOs
13556>>>>>        For i from 0 to iDEOs
13562>>>>>>
13562>>>>>            Get Data_Set_User_Interface i to iDEO
13563>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Label_Changed to iDEO ;                iMain_File iField bLong sLabel
13566>>>>>        Loop
13567>>>>>>
13567>>>>>    End_Procedure
13568>>>>>    
13568>>>>>    // Notify all DEOs that a field option has changed.
13568>>>>>    //   This message is sent by Set Field_Option
13568>>>>>    Procedure Field_Option_Changed Integer iField Integer iOptions Boolean bClear
13570>>>>>        Integer i iDEOs iDEO
13570>>>>>        Integer iMain_File
13570>>>>>        Get Main_File to iMain_File
13571>>>>>        Get Data_Set_User_Interface_Count to iDEOs
13572>>>>>        Decrement iDEOs
13573>>>>>        For i from 0 to iDEOs
13579>>>>>>
13579>>>>>            Get Data_Set_User_Interface i to iDEO
13580>>>>>            If (Extended_DEO_State(iDEO)) ;                Send File_Field_Option_Changed of iDEO ;                iMain_File iField iOptions bClear
13583>>>>>        Loop
13584>>>>>>
13584>>>>>    End_Procedure
13585>>>>>    
13585>>>>>    
13585>>>>>    //   Set, clear or toggle a field option
13585>>>>>    //   Multiple options can be passed as an expression
13585>>>>>    //   (e.g. Set Field_option 2 (dd_Retain IOR dd_NoEnter).
13585>>>>>    //   Unlike set Field_options this notifies DEOs of changes
13585>>>>>    // supports setting and clearing. e.g.:
13585>>>>>    //    Set Field_Option Field Customer.Name DD_NoEnter to True
13585>>>>>    // This new syntax is now the recommended syntax but the older syntax without
13585>>>>>    // the last parameter is supported (where true is the default). The old syntax is
13585>>>>>    // only supported for compatibility. This means that Field_Option_Clear should
13585>>>>>    // also be replaced with Field_Option
13585>>>>>    Procedure Set Field_Option Integer iField Integer iOption Boolean bSet
13587>>>>>        Boolean bSetTrue
13587>>>>>        Move (If(num_arguments>2, bSet, True)) to bSetTrue // support for old deprecated syntax
13588>>>>>        If bSetTrue Begin
13590>>>>>            Set Field_options iField to iOption
13591>>>>>        End
13591>>>>>>
13591>>>>>        Else Begin
13592>>>>>            Set Field_options iField to DD_CLEAR_FIELD_OPTIONS iOption
13593>>>>>        End
13593>>>>>>
13593>>>>>        If (Data_Set_User_Interface_Count(Self)) Begin
13595>>>>>            Send Field_Option_Changed iField iOption (not(bSetTrue))
13596>>>>>        End
13596>>>>>>
13596>>>>>    End_Procedure
13597>>>>>    
13597>>>>>    Procedure Set File_Field_Option Integer iFile Integer iField Integer iOption Boolean bSet
13599>>>>>        Handle hoDD
13599>>>>>        Boolean bSetTrue
13599>>>>>        Move (If(num_arguments>3, bSet, True)) to bSetTrue // support for old deprecated syntax
13600>>>>>        Get Data_set iFile to hoDD
13601>>>>>        If hoDD Begin
13603>>>>>            Set Field_Option of hoDD iField iOption to bSetTrue
13604>>>>>        End
13604>>>>>>
13604>>>>>        
13604>>>>>    End_Procedure
13605>>>>>    
13605>>>>>    Procedure Set Field_Option_Clear Integer iField Integer iOptions
13607>>>>>        Set Field_Option iField iOptions to False
13608>>>>>    End_Procedure
13609>>>>>    
13609>>>>>    Procedure Set File_Field_Option_Clear Integer iFile Integer iField Integer iOptions
13611>>>>>        Set File_Field_Option iFile iField iOptions to False
13612>>>>>    End_Procedure
13613>>>>>    
13613>>>>>    Procedure Set Field_Option_Toggle Integer iField Integer iOption
13615>>>>>        Integer iOldOption
13615>>>>>        Get Field_Options iField to iOldOption
13616>>>>>        // if old and new have overlapping bits, we assume clear
13616>>>>>        Set Field_Option iField iOption to ((iOldOption iand iOption)=0)
13617>>>>>    End_Procedure
13618>>>>>    
13618>>>>>    Procedure Set File_Field_Option_Toggle Integer iFile Integer iField Integer iOption
13620>>>>>        Handle hoDD
13620>>>>>        Get Data_set iFile to hoDD
13621>>>>>        If hoDD ;            Set Field_Option_Toggle of hoDD iField to iOption
13624>>>>>    End_Procedure
13625>>>>>    
13625>>>>>    // This returns the main index for a field. This replaces the DSO message Field_Main_index which
13625>>>>>    // should no longer be used by DDOs. The old message has the problem that the DDO or DSO using
13625>>>>>    // this message may not be the owner of the field. So augmenting the owner DDO did not insure that
13625>>>>>    // all requests for this index would go through it. Now you can augment Field_Index and always
13625>>>>>    // be sure that any DDO requesting an index for a file (via file_field_index) will always go to
13625>>>>>    // the owner object.
13625>>>>>    Function Field_Index Integer iField Returns Integer
13627>>>>>        Integer iFile iIndex iOrder
13627>>>>>        // ordering takes precendence
13627>>>>>        Get ordering to iOrder
13628>>>>>        If (iOrder>=0);            Move iOrder to iIndex  //ordering takes precedence over main index
13631>>>>>        Else Begin
13632>>>>>            Get Main_file to iFile
13633>>>>>            Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex // main index field
13636>>>>>            If (iIndex=0 and iField>0) ; // If field is not recnum and there is no index, the                Move -1 to iIndex        // field has no main index
13639>>>>>        End
13639>>>>>>
13639>>>>>        Function_Return iIndex
13640>>>>>    End_Function
13641>>>>>    
13641>>>>>    // In all cases, this message should be sent instead of Field_Main_Index. If
13641>>>>>    // augmentation was used in Field_Main_Index, use Field_Index to insure the owner object
13641>>>>>    // is called.
13641>>>>>    
13641>>>>>    Function File_Field_Index Integer iFile Integer iField Returns Integer
13643>>>>>        Integer iIndex
13643>>>>>        Handle hoDD
13643>>>>>        Get Data_set iFile to hoDD
13644>>>>>        If (hoDD) ;            Get Field_Index of hoDD iField to iIndex
13647>>>>>        Else ;            Move -1 to iIndex
13649>>>>>        Function_Return iIndex
13650>>>>>    End_Function
13651>>>>>    
13651>>>>>    // 12/1 change: Make sure all of the major DD operations update the DD with the value in
13651>>>>>    // the focus field. After the actual find, save, clar or delete, the DD buffer contains information that
13651>>>>>    // is not yet reflected in the DEOs (before refresh is called) we want to make sure that we
13651>>>>>    // don't try to get data from the DEO. Get Field_Current_Value now checks if operation_mode is
13651>>>>>    // non-zero. If it is, it always gets from the DD buffer.
13651>>>>>    
13651>>>>>    Procedure Clear
13653>>>>>        Boolean bOpOk
13653>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
13654>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
13656>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARING
13657>>>>>        End
13657>>>>>>
13657>>>>>        If (bOpOk) Begin
13659>>>>>            Send OnPreFind DDFindClear
13660>>>>>        End
13660>>>>>>
13660>>>>>        Forward Send Clear
13662>>>>>        If (bOpOk) Begin
13664>>>>>            Send DefaultParentAutofinds
13665>>>>>            Send OnPostFind DDFindClear True
13666>>>>>        End
13666>>>>>>
13666>>>>>    End_Procedure
13667>>>>>    
13667>>>>>    Procedure Clear_All
13669>>>>>        Boolean bOpOk
13669>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
13670>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
13672>>>>>            Send Update_Focus_Field_For_Operation MODE_CLEARINGALL
13673>>>>>        End
13673>>>>>>
13673>>>>>        Forward Send clear_all
13675>>>>>        If (bOpOk) Begin
13677>>>>>            Send DefaultParentAutofinds
13678>>>>>        End
13678>>>>>>
13678>>>>>    End_Procedure
13679>>>>>    
13679>>>>>    Procedure Request_Assign Integer iFile
13681>>>>>        Handle hoDD
13681>>>>>        Boolean bFound
13681>>>>>        Boolean bOpOk
13681>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
13682>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
13684>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
13685>>>>>        End
13685>>>>>>
13685>>>>>        
13685>>>>>        If (bOpOk) Begin
13687>>>>>            If (num_arguments=0 or iFile=0) Begin
13689>>>>>                Move Self to hoDD
13690>>>>>            End
13690>>>>>>
13690>>>>>            Else Begin
13691>>>>>                Get Data_Set iFile to hoDD
13692>>>>>            End
13692>>>>>>
13692>>>>>            If hoDD Begin
13694>>>>>                Send OnPreFind of hoDD DDFindRequestAssign
13695>>>>>            End
13695>>>>>>
13695>>>>>        End
13695>>>>>>
13695>>>>>        
13695>>>>>        If (num_arguments=0) Begin
13697>>>>>            Forward Send Request_Assign
13699>>>>>        End
13699>>>>>>
13699>>>>>        Else Begin
13700>>>>>            Forward Send Request_Assign iFile
13702>>>>>        End
13702>>>>>>
13702>>>>>        
13702>>>>>        If (bOpOk) Begin
13704>>>>>            If (hoDD) Begin
13706>>>>>                Move (Found) to bFound
13707>>>>>                Send OnPostFind of hoDD DDFindRequestAssign bFound
13708>>>>>                Move bFound to Found
13709>>>>>            End
13709>>>>>>
13709>>>>>        End
13709>>>>>>
13709>>>>>    End_Procedure
13710>>>>>    
13710>>>>>    
13710>>>>>    Procedure Find_By_Recnum Integer iFile Integer iRecord
13712>>>>>        Handle hoDD
13712>>>>>        Boolean bFound
13712>>>>>        Boolean bOpOk
13712>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
13713>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
13714>>>>>        
13714>>>>>        If (bOpOk) Begin
13716>>>>>            Get Data_Set iFile to hoDD
13717>>>>>            If hoDD Begin
13719>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
13720>>>>>            End
13720>>>>>>
13720>>>>>        End
13720>>>>>>
13720>>>>>        
13720>>>>>        Forward Send Find_By_Recnum iFile iRecord
13722>>>>>        
13722>>>>>        If (bOpOk) Begin
13724>>>>>            If (hoDD) Begin
13726>>>>>                Move (Found) to bFound
13727>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
13728>>>>>                Move bFound to Found
13729>>>>>            End
13729>>>>>>
13729>>>>>        End
13729>>>>>>
13729>>>>>    End_Procedure
13730>>>>>    
13730>>>>>    Procedure FindByRowId Integer iFile RowID riRowId
13732>>>>>        Handle hoDD
13732>>>>>        Boolean bFound
13732>>>>>        Boolean bOpOk
13732>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
13733>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
13734>>>>>        
13734>>>>>        If (bOpOk) Begin
13736>>>>>            Get Data_Set iFile to hoDD
13737>>>>>            If hoDD Begin
13739>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
13740>>>>>            End
13740>>>>>>
13740>>>>>        End
13740>>>>>>
13740>>>>>        
13740>>>>>        Forward Send FindByRowId iFile riRowId
13742>>>>>        
13742>>>>>        If (bOpOk) Begin
13744>>>>>            If (hoDD) Begin
13746>>>>>                Move (Found) to bFound
13747>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
13748>>>>>                Move bFound to Found
13749>>>>>            End
13749>>>>>>
13749>>>>>        End
13749>>>>>>
13749>>>>>    End_Procedure
13750>>>>>    
13750>>>>>    Function FindByRowIdEx Integer iFile RowID riRowId Returns Boolean
13752>>>>>        Handle hoDD
13752>>>>>        Boolean bFound bSuccess
13752>>>>>        Boolean bOpOk
13752>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
13753>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
13754>>>>>        
13754>>>>>        If (bOpOk) Begin
13756>>>>>            Get Data_Set iFile to hoDD
13757>>>>>            If hoDD Begin
13759>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
13760>>>>>            End
13760>>>>>>
13760>>>>>        End
13760>>>>>>
13760>>>>>        
13760>>>>>        Forward Get FindByRowIdEx iFile riRowId to bSuccess
13762>>>>>        
13762>>>>>        If (bOpOk) Begin
13764>>>>>            If (hoDD) Begin
13766>>>>>                Move (Found) to bFound
13767>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
13768>>>>>                Move bFound to Found
13769>>>>>            End
13769>>>>>>
13769>>>>>        End
13769>>>>>>
13769>>>>>        Function_Return bSuccess
13770>>>>>    End_Function
13771>>>>>    
13771>>>>>    Function FindByRowIdExNoAutoFill Integer iFile RowID riRowId Returns Boolean
13773>>>>>        Handle hoDD
13773>>>>>        Boolean bFound bSuccess
13773>>>>>        Boolean bOpOk
13773>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
13774>>>>>        Send Update_Focus_Field_For_Operation MODE_FINDING
13775>>>>>        
13775>>>>>        If (bOpOk) Begin
13777>>>>>            Get Data_Set iFile to hoDD
13778>>>>>            If hoDD Begin
13780>>>>>                Send OnPreFind of hoDD DDFindFindByRowRec
13781>>>>>            End
13781>>>>>>
13781>>>>>        End
13781>>>>>>
13781>>>>>        
13781>>>>>        Forward Get FindByRowIdExNoAutoFill iFile riRowId to bSuccess
13783>>>>>        
13783>>>>>        If (bOpOk) Begin
13785>>>>>            If (hoDD) Begin
13787>>>>>                Move (Found) to bFound
13788>>>>>                Send OnPostFind of hoDD DDFindFindByRowRec bFound
13789>>>>>                Move bFound to Found
13790>>>>>            End
13790>>>>>>
13790>>>>>        End
13790>>>>>>
13790>>>>>        Function_Return bSuccess
13791>>>>>    End_Function
13792>>>>>    
13792>>>>>    
13792>>>>>    Procedure Request_Find Integer eFindMode Integer iFile Integer iIndex
13794>>>>>        Handle hoDD
13794>>>>>        Boolean bFound
13794>>>>>        Boolean bOpOk
13794>>>>>        Move (OPERATION_MODE=MODE_WAITING or OPERATION_MODE=MODE_VALIDATING) to bOpOk
13795>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
13797>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
13798>>>>>        End
13798>>>>>>
13798>>>>>        
13798>>>>>        If (bOpOk) Begin
13800>>>>>            Get Data_Set iFile to hoDD
13801>>>>>            If hoDD Begin
13803>>>>>                Send OnPreFind of hoDD DDFindRequestFind
13804>>>>>            End
13804>>>>>>
13804>>>>>        End
13804>>>>>>
13804>>>>>        
13804>>>>>        Forward Send Request_Find eFindMode iFile iIndex
13806>>>>>        
13806>>>>>        If (bOpOk) Begin
13808>>>>>            If (hoDD) Begin
13810>>>>>                Move (Found) to bFound
13811>>>>>                Send OnPostFind of hoDD DDFindRequestFind bFound
13812>>>>>                Move bFound to Found
13813>>>>>            End
13813>>>>>>
13813>>>>>        End
13813>>>>>>
13813>>>>>    End_Procedure
13814>>>>>    
13814>>>>>    Procedure OnPreFind Integer eMessage
13816>>>>>    End_Procedure
13817>>>>>    
13817>>>>>    Procedure OnPostFind Integer eMessage Boolean bFound
13819>>>>>    End_Procedure
13820>>>>>    
13820>>>>>    
13820>>>>>    
13820>>>>>    Procedure Request_Superfind Integer eFindMode Integer iFile Integer iField
13822>>>>>        Boolean bInSuperFind
13822>>>>>        // we need to set pbInSuperFind so Entry_update in the DEOs will know that
13822>>>>>        // they should perform an entry_update. Superfind entry_updates have never gone through
13822>>>>>        // the DD's field buffer.
13822>>>>>        Get pbInSuperFind to bInSuperFind
13823>>>>>        Set pbInSuperFind to True
13824>>>>>        If (OPERATION_MODE=MODE_WAITING) Begin
13826>>>>>            Send Update_Focus_Field_For_Operation MODE_FINDING
13827>>>>>        End
13827>>>>>>
13827>>>>>        Forward Send Request_Superfind eFindMode iFile iField
13829>>>>>        Set pbInSuperFind to bInSuperFind
13830>>>>>    End_Procedure
13831>>>>>    
13831>>>>>    // Augmented to return true if a non-constrained parent DD has a change. This way
13831>>>>>    // Should_Save_row only filters changes in a consrained parent.
13831>>>>>    
13831>>>>>    Function Should_Save_Row Returns Boolean
13833>>>>>        Boolean bShouldSaveRow bShouldSave bRelatesToConstraint
13833>>>>>        Integer iServers iServer iServerFile
13833>>>>>        Handle hoServerDD
13833>>>>>        Forward Get Should_Save_Row to bShouldSaveRow // will be true if this DD is changed or has a changed parent.
13835>>>>>        Get Should_Save to bShouldSave // will be true if there is a change anywhere up the entire save structure
13836>>>>>        If (not(bShouldSaveRow) and bShouldSave) Begin
13838>>>>>            // If here we have a changed in an server but not the this DD. We need a further refinement. If the server
13838>>>>>            // change is in a constrained server, we don't consider this a change because you can switch rows without losing
13838>>>>>            // data (with RT changes made for 17.0).
13838>>>>>            Get Data_Set_Server_Count to iServers
13839>>>>>            For iServer from 0 to (iServers-1)
13845>>>>>>
13845>>>>>                Get Data_Set_Server iServer to hoServerDD
13846>>>>>                Get Should_Save of hoServerDD to bShouldSave
13847>>>>>                If bShouldSave Begin
13849>>>>>                    Get Main_File of hoServerDD to iServerFile
13850>>>>>                    Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
13851>>>>>                    If not bRelatesToConstraint Begin
13853>>>>>                        Function_Return True
13854>>>>>                    End
13854>>>>>>
13854>>>>>                End
13854>>>>>>
13854>>>>>            Loop
13855>>>>>>
13855>>>>>        End
13855>>>>>>
13855>>>>>        Function_Return bShouldSaveRow
13856>>>>>    End_Function
13857>>>>>    
13857>>>>>    // returns true if any relates-to constraining server needs a save. Normally there will be
13857>>>>>    // one or zero related-to parents. If Should_Save_Row returns false it is possible that there
13857>>>>>    // is a change up the relates-to constrained branch. If so, this will return True. This can be
13857>>>>>    // used to better determine the changed status of your DDO sructure
13857>>>>>    Function ShouldSaveConstrainedToServer Returns Boolean
13859>>>>>        Boolean bShouldSave bRelatesToConstraint
13859>>>>>        Integer iServers iServer iServerFile
13859>>>>>        Handle hoServerDD
13859>>>>>        Get Data_Set_Server_Count to iServers
13860>>>>>        For iServer from 0 to (iServers-1)
13866>>>>>>
13866>>>>>            Get Data_Set_Server iServer to hoServerDD
13867>>>>>            Get Main_File of hoServerDD to iServerFile
13868>>>>>            Get IsRelatesToConstrained iServerFile to bRelatesToConstraint
13869>>>>>            If bRelatesToConstraint Begin
13871>>>>>                Get Should_Save of hoServerDD to bShouldSave
13872>>>>>                If bShouldSave Begin
13874>>>>>                    Function_Return True
13875>>>>>                End
13875>>>>>>
13875>>>>>            End
13875>>>>>>
13875>>>>>        Loop
13876>>>>>>
13876>>>>>        Function_Return False
13877>>>>>    End_Function
13878>>>>>    
13878>>>>>    Function FindServerInformationElement Integer iFile Returns Integer
13880>>>>>        tDDServerInformation[] ServerInformation
13880>>>>>        tDDServerInformation[] ServerInformation
13881>>>>>        tDDServerInformation ServerSearch
13881>>>>>        tDDServerInformation ServerSearch
13881>>>>>        Integer iIndex
13881>>>>>        Move iFile to ServerSearch.iParent
13882>>>>>        Get pServerInformation to ServerInformation
13883>>>>>        Function_Return (SearchArray(ServerSearch,ServerInformation))
13884>>>>>    End_Function
13885>>>>>    
13885>>>>>    Procedure AddServerData Integer iFile Integer eParam Boolean bValue
13887>>>>>        tDDServerInformation[] ServerInformation
13887>>>>>        tDDServerInformation[] ServerInformation
13888>>>>>        Integer iIndex
13888>>>>>        Handle hoDDO
13888>>>>>        
13888>>>>>        Get pServerInformation to ServerInformation
13889>>>>>        Get FindServerInformationElement iFile to iIndex
13890>>>>>        If (iIndex=-1) Begin
13892>>>>>            Move (SizeOfArray(ServerInformation)) to iIndex
13893>>>>>            Move iFile to ServerInformation[iIndex].iParent
13894>>>>>            // defaults must always be false!
13894>>>>>            Move False to ServerInformation[iIndex].bParentNoSwitchIfCommitted
13895>>>>>            Move False to ServerInformation[iIndex].bAllowNullParent
13896>>>>>            Move False to ServerInformation[iIndex].bNoCascadeDelete
13897>>>>>            Move False to ServerInformation[iIndex].bCascadeDeleteNullTheParent
13898>>>>>        End
13898>>>>>>
13898>>>>>        
13898>>>>>        If (eParam=0) Begin
13900>>>>>            If (bValue<>ServerInformation[iIndex].bAllowNullParent) Begin
13902>>>>>                Move bValue to ServerInformation[iIndex].bAllowNullParent
13903>>>>>                Send AdjustDeleteValidateStructure iFile
13904>>>>>            End
13904>>>>>>
13904>>>>>        End
13904>>>>>>
13904>>>>>        Else If (eParam=1) Begin
13907>>>>>            Move bValue to ServerInformation[iIndex].bParentNoSwitchIfCommitted
13908>>>>>        End
13908>>>>>>
13908>>>>>        Else If (eParam=2) Begin
13911>>>>>            Move bValue to ServerInformation[iIndex].bNoCascadeDelete
13912>>>>>        End
13912>>>>>>
13912>>>>>        Else Begin // (3)
13913>>>>>            If (bValue<>ServerInformation[iIndex].bCascadeDeleteNullTheParent) Begin
13915>>>>>                Move bValue to ServerInformation[iIndex].bCascadeDeleteNullTheParent
13916>>>>>                Send AdjustDeleteValidateStructure iFile
13917>>>>>            End
13917>>>>>>
13917>>>>>        End
13917>>>>>>
13917>>>>>        Set pServerInformation to ServerInformation
13918>>>>>    End_Procedure
13919>>>>>    
13919>>>>>    Function GetServerData Integer iFile Integer eParam Returns Boolean
13921>>>>>        Boolean bValue
13921>>>>>        tDDServerInformation[] ServerInformation
13921>>>>>        tDDServerInformation[] ServerInformation
13922>>>>>        Integer iIndex
13922>>>>>        Get pServerInformation to ServerInformation
13923>>>>>        Get FindServerInformationElement iFile to iIndex
13924>>>>>        // when not found in array, we want to make sure that we return false. Therefore
13924>>>>>        // false should always be the default.
13924>>>>>        If (iIndex<>-1) Begin
13926>>>>>            If (eParam=0) Begin
13928>>>>>                Move ServerInformation[iIndex].bAllowNullParent to bValue
13929>>>>>            End
13929>>>>>>
13929>>>>>            Else If (eParam=1) Begin
13932>>>>>                Move ServerInformation[iIndex].bParentNoSwitchIfCommitted to bValue
13933>>>>>            End
13933>>>>>>
13933>>>>>            Else If (eParam=2) Begin
13936>>>>>                Move ServerInformation[iIndex].bNoCascadeDelete to bValue
13937>>>>>            End
13937>>>>>>
13937>>>>>            Else Begin
13938>>>>>                Move ServerInformation[iIndex].bCascadeDeleteNullTheParent to bValue
13939>>>>>            End
13939>>>>>>
13939>>>>>        End
13939>>>>>>
13939>>>>>        Function_Return bValue
13940>>>>>    End_Function
13941>>>>>    
13941>>>>>    Procedure AdjustDeleteValidateStructure2
13943>>>>>        Integer iCount i
13943>>>>>        Handle hoDDO
13943>>>>>        Boolean bVisited
13943>>>>>        Set Visited_State to True
13944>>>>>        Set Cascade_Delete_Structure_Validated_State to False
13945>>>>>        Get Data_Set_Server_Count to iCount
13946>>>>>        For i from 0 to (iCount-1)
13952>>>>>>
13952>>>>>            Get Data_Set_Server i to hoDDO
13953>>>>>            Get Visited_State of hoDDO to bVisited
13954>>>>>            If (not(bVisited)) Begin
13956>>>>>                Send AdjustDeleteValidateStructure2 of hoDDO
13957>>>>>            End
13957>>>>>>
13957>>>>>        Loop
13958>>>>>>
13958>>>>>    End_Procedure
13959>>>>>    
13959>>>>>    // This is called in the unlikely case that NullParent/CascadeNull are set dynamically. It
13959>>>>>    // tells the parent DDO to recheck its validate-delete structure and it tells all ancestors of
13959>>>>>    // this parent to do the same. If called while DDOs are being created (via a class setting) there
13959>>>>>    // will not be a connected parent for iFile, which is fine.
13959>>>>>    Procedure AdjustDeleteValidateStructure Integer iFile
13961>>>>>        Handle hoDDO
13961>>>>>        Get Which_Data_Set iFile to hoDDO
13962>>>>>        If hoDDO Begin
13964>>>>>            Send Initialize_Visited of hoDDO False False
13965>>>>>            Send AdjustDeleteValidateStructure2 of hoDDO
13966>>>>>        End
13966>>>>>>
13966>>>>>    End_Procedure
13967>>>>>    
13967>>>>>    // Used to add a null parent to the list of parents that allow this
13967>>>>>    Procedure Set ParentNullAllowed Integer iParent Boolean bAllowed
13969>>>>>        Send AddServerData iParent 0 bAllowed
13970>>>>>    End_Procedure
13971>>>>>    
13971>>>>>    // returns true if null parent allowed for this parent file
13971>>>>>    Function ParentNullAllowed Integer iParent Returns Boolean
13973>>>>>        Boolean bValue
13973>>>>>        Get GetServerData iParent 0 to bValue
13974>>>>>        Function_Return bValue
13975>>>>>    End_Function
13976>>>>>    
13976>>>>>    // returns true if null parent allowed for this parent file. This is the function
13976>>>>>    // that can be used for augmentation. This is the methid that is called by the runtime
13976>>>>>    // to determine if a null parent is allowed
13976>>>>>    Function IsNullParentAllowed Integer iServer Returns Boolean
13978>>>>>        Boolean bAllowed
13978>>>>>        Get ParentNullAllowed iServer to bAllowed
13979>>>>>        Function_Return bAllowed
13980>>>>>    End_Function
13981>>>>>    
13981>>>>>    Procedure Set ParentNoSwitchIfCommitted Integer iParent Boolean bAllowed
13983>>>>>        Send AddServerData iParent 1 bAllowed
13984>>>>>    End_Procedure
13985>>>>>    
13985>>>>>    Function ParentNoSwitchIfCommitted Integer iParent Returns Boolean
13987>>>>>        Boolean bValue
13987>>>>>        Get GetServerData iParent 1 to bValue
13988>>>>>        Function_Return bValue
13989>>>>>    End_Function
13990>>>>>    
13990>>>>>    
13990>>>>>    Procedure Set CascadeDeleteAllowed Integer iParent Boolean bAllowed
13992>>>>>        Send AddServerData iParent 2 (not(bAllowed))
13993>>>>>    End_Procedure
13994>>>>>    
13994>>>>>    Function CascadeDeleteAllowed Integer iParent Returns Boolean
13996>>>>>        Boolean bValue
13996>>>>>        Get GetServerData iParent 2 to bValue // note that False=allowed
13997>>>>>        Function_Return (not(bValue))
13998>>>>>    End_Function
13999>>>>>    
13999>>>>>    Function IsCascadeDeleteAllowed Integer iServer Returns Boolean
14001>>>>>        Boolean bAllowed
14001>>>>>        Get CascadeDeleteAllowed iServer to bAllowed
14002>>>>>        Function_Return bAllowed
14003>>>>>    End_Function
14004>>>>>    
14004>>>>>    Procedure Set CascadeDeleteNull Integer iParent Boolean bAllowed
14006>>>>>        Send AddServerData iParent 3 bAllowed
14007>>>>>    End_Procedure
14008>>>>>    
14008>>>>>    Function CascadeDeleteNull Integer iParent Returns Boolean
14010>>>>>        Boolean bValue
14010>>>>>        Get GetServerData iParent 3 to bValue
14011>>>>>        Function_Return bValue
14012>>>>>    End_Function
14013>>>>>    
14013>>>>>    Function IsCascadeDeleteNull Integer iServer Returns Boolean
14015>>>>>        Boolean bAllowed
14015>>>>>        Get CascadeDeleteNull iServer to bAllowed
14016>>>>>        Function_Return bAllowed
14017>>>>>    End_Function
14018>>>>>    
14018>>>>>    // return an array with the server path from this DD to passed top. The top will be
14018>>>>>    // in 0 and its child in 1, grand-child in 2, etc. If empty, no path was found. To start
14018>>>>>    // this process the byref hoDDs array MUST be empty
14018>>>>>    Procedure DDOServerPath Handle hoTop Handle[] ByRef hoDDs
14020>>>>>        Handle hoServer
14020>>>>>        Integer iServers iServer
14020>>>>>        If (hoTop=Self) Begin
14022>>>>>            Move Self to hoDDs[SizeOfArray(hoDDs)]
14023>>>>>            Procedure_Return
14024>>>>>        End
14024>>>>>>
14024>>>>>        Get Data_Set_Server_Count to iServers
14025>>>>>        For iServer from 0 to (iServers-1)
14031>>>>>>
14031>>>>>            Get Data_Set_Server iServer to hoServer
14032>>>>>            Send DDOServerPath of hoServer hoTop (&hoDDs)
14033>>>>>            If (SizeOfArray(hoDDs)) Begin
14035>>>>>                Move Self to hoDDs[SizeOfArray(hoDDs)]
14036>>>>>                Procedure_Return
14037>>>>>            End
14037>>>>>>
14037>>>>>        Loop
14038>>>>>>
14038>>>>>    End_Procedure
14039>>>>>    
14039>>>>>    // returns True if the value passed can be considered empty for this field.
14039>>>>>    Function IsEmptyField Integer iField String sValue Returns Boolean
14041>>>>>        Integer iFile iDataType iValidationType
14041>>>>>        Number nNum
14041>>>>>        Boolean bInvalid bChecked
14041>>>>>        Get Main_File to iFile
14042>>>>>        Get_Attribute DF_FIELD_TYPE of iFile iField to iDataType
14045>>>>>        Get IsDataInvalid iDataType sValue to bInvalid
14046>>>>>        If bInvalid Begin
14048>>>>>            Function_Return True
14049>>>>>        End
14049>>>>>>
14049>>>>>        
14049>>>>>        // DDs set checkbox fields to the False value as default. We must test its select_state
14049>>>>>        Get Field_Validation_Type of (Field_Attributes(Self)) iField to iValidationType
14050>>>>>        If (iValidationType=FA_VALIDATION_TYPE_CHECKBOX) Begin
14052>>>>>            Get Field_Select_State iField to bChecked
14053>>>>>            If not bChecked Begin
14055>>>>>                Function_Return True
14056>>>>>            End
14056>>>>>>
14056>>>>>        End
14056>>>>>>
14056>>>>>        
14056>>>>>        If ((iDataType=DF_BCD or iDataType=DF_DATE) and (Number(sValue)=0)) Begin
14058>>>>>            Move "" to sValue
14059>>>>>        End
14059>>>>>>
14059>>>>>        Else If (iDataType=DF_DATETIME and IsNullDateTime(cast(sValue,DateTime))) Begin
14062>>>>>            Move "" to sValue
14063>>>>>        End
14063>>>>>>
14063>>>>>        Function_Return (sValue="")
14064>>>>>    End_Function
14065>>>>>    
14065>>>>>    
14065>>>>>    // is the record committed
14065>>>>>    Function IsCommitted Returns Boolean
14067>>>>>        Boolean bHasRecord
14067>>>>>        Get HasRecord to bHasRecord
14068>>>>>        Function_Return bHasRecord
14069>>>>>    End_Function
14070>>>>>    
14070>>>>>    // is the field committed. It assumes the record is already committed
14070>>>>>    Function IsFieldCommitted Integer iField Returns Boolean
14072>>>>>        Boolean bIsCommitted
14072>>>>>        Get Field_Option iField DD_COMMIT to bIsCommitted
14073>>>>>        Function_Return bIsCommitted
14074>>>>>    End_Function
14075>>>>>    
14075>>>>>    // is a parent change allowed for this parent server.
14075>>>>>    Function IsCommittedParentChangeAllowed Integer iServer Returns Boolean
14077>>>>>        Boolean bNoSwitch
14077>>>>>        Get ParentNoSwitchIfCommitted iServer to bNoSwitch
14078>>>>>        Function_Return (not(bNoSwitch))
14079>>>>>    End_Function
14080>>>>>    
14080>>>>>    // Are we allowed to find with this file when it is used as a parent?
14080>>>>>    // Check all child DDOs and see if any are committed and do not allow switching parents when committed.
14080>>>>>    //  The rules for each child are switching is ok If:
14080>>>>>    // 1. the child is not committed,
14080>>>>>    // 2. it has a relates-to constraint (Find will change child which is ok)
14080>>>>>    // 3. if IsCommittedParentChangeAllowed allowed.
14080>>>>>    //
14080>>>>>    Function AllowParentFind Returns Boolean
14082>>>>>        Integer iClients iClient iMain
14082>>>>>        Handle hoChild
14082>>>>>        Boolean bIsCommitted
14082>>>>>        Get Data_Set_Client_Count to iClients
14083>>>>>        For iClient from 0 to (iClients-1)
14089>>>>>>
14089>>>>>            Get Data_Set_Client iClient to hoChild
14090>>>>>            Get IsCommitted of hoChild to bIsCommitted
14091>>>>>            If bIsCommitted Begin
14093>>>>>                Get Main_File to iMain
14094>>>>>                Get IsRelatesToConstrained of hoChild iMain to bIsCommitted
14095>>>>>                If not bIsCommitted Begin
14097>>>>>                    Get IsCommittedParentChangeAllowed of hoChild iMain to bIsCommitted
14098>>>>>                    If (not(bIsCommitted)) Begin
14100>>>>>                        Function_Return False
14101>>>>>                    End
14101>>>>>>
14101>>>>>                End
14101>>>>>>
14101>>>>>            End
14101>>>>>>
14101>>>>>        Loop
14102>>>>>>
14102>>>>>        Function_Return True
14103>>>>>    End_Function
14104>>>>>    
14104>>>>>    // aumgented to do nothing if there is no index (instead of annoying error message) and
14104>>>>>    // to do nothing if a find is not allowed because it is a no switch parent of a committed child.
14104>>>>>    Procedure Item_Find Integer eFindMode ;            Integer iFile Integer iField ;            Integer bDoEntryUpdate Integer bShowFindErr Integer bDeferred
14106>>>>>        
14106>>>>>        Integer iIndex iMain
14106>>>>>        Handle  hoOwner
14106>>>>>        Boolean bOk
14106>>>>>        
14106>>>>>        Get File_Field_Index iFile iField to iIndex
14107>>>>>        If (iIndex=-1)  Begin
14109>>>>>            Procedure_Return
14110>>>>>        End
14110>>>>>>
14110>>>>>        Get Main_File to iMain
14111>>>>>        If (iMain<>iFile) Begin
14113>>>>>            Get Which_Data_Set iFile to hoOwner
14114>>>>>            If hoOwner Begin
14116>>>>>                Get AllowParentFind of hoOwner to bOk
14117>>>>>                If not bOk Begin
14119>>>>>                    Procedure_Return
14120>>>>>                End
14120>>>>>>
14120>>>>>            End
14120>>>>>>
14120>>>>>        End
14120>>>>>>
14120>>>>>        
14120>>>>>        If not bDeferred Begin
14122>>>>>            Send Refind_Records // make sure the buffers are correct before the find
14123>>>>>        End
14123>>>>>>
14123>>>>>        
14123>>>>>        Forward Send Item_Find eFindMode iFile iField bDoEntryUpdate bShowFindErr bDeferred
14125>>>>>    End_Procedure
14126>>>>>    
14126>>>>>    
14126>>>>>    Function Field_CommitNoEnterOnIndex Integer iField Returns Boolean
14128>>>>>        Function_Return False
14129>>>>>    End_Function
14130>>>>>    
14130>>>>>    // Return the committed options for this field based on the committed status or this record,
14130>>>>>    // the committed status of the field and whether, if committed, it should be noput or noput+noenter
14130>>>>>    Function File_Field_Committed_Options Integer iFile Integer iField Returns Integer
14132>>>>>        Boolean bIsCommitted bNoEnter
14132>>>>>        Integer iNewOpts iIndex
14132>>>>>        Handle hoOwner
14132>>>>>        
14132>>>>>        Get Which_Data_Set iFile to hoOwner
14133>>>>>        If not hoOwner ;            Function_Return 0
14136>>>>>        
14136>>>>>        Get File_Field_Index iFile iField to iIndex
14137>>>>>        Get IsCommitted of hoOwner iField to bIsCommitted
14138>>>>>        If bIsCommitted Begin
14140>>>>>            Get IsFieldCommitted of hoOwner iField to bIsCommitted
14141>>>>>            If bIsCommitted Begin
14143>>>>>                Move True to bNoEnter
14144>>>>>                If (iIndex<>-1) Begin
14146>>>>>                    Get Field_CommitNoEnterOnIndex iField to bNoEnter
14147>>>>>                End
14147>>>>>>
14147>>>>>                // if committed, it is noput and, if non-indexed, also noenter
14147>>>>>                Move (If(bNoEnter,DD_DISPLAYONLY,DD_NOPUT)) to iNewOpts
14148>>>>>            End
14148>>>>>>
14148>>>>>        End
14148>>>>>>
14148>>>>>        // if a finding parent field, we want to know if you are allowed to switch parents as we will assume
14148>>>>>        // that this field is used for finding.
14148>>>>>        If (hoOwner<>Self and iIndex>-1) Begin
14150>>>>>            Get AllowParentFind of hoOwner to bIsCommitted
14151>>>>>            If not bIsCommitted Begin
14153>>>>>                Move DD_DISPLAYONLY to iNewOpts
14154>>>>>            End
14154>>>>>>
14154>>>>>        End
14154>>>>>>
14154>>>>>        
14154>>>>>        Function_Return iNewOpts
14155>>>>>    End_Function
14156>>>>>    
14156>>>>>    // Returns the current field-field options based on regular options, foreign field status
14156>>>>>    // plus committed record status
14156>>>>>    Function File_Field_DynamicEntryOptions Integer iFile Integer iField Returns Integer
14158>>>>>        Integer iCOpts iFOpts
14158>>>>>        If (iFile=0) Begin
14160>>>>>            Function_Return 0
14161>>>>>        End
14161>>>>>>
14161>>>>>        Get File_Field_Options iFile iField to iFOpts            // regular options (handles regular and foreign)
14162>>>>>        Get File_Field_Committed_Options iFile iField to iCOpts  // possible NoPut, NoEnter additions
14163>>>>>        Function_Return (iFOpts ior iCOpts)
14164>>>>>    End_Function
14165>>>>>    
14165>>>>>    Function DDRememberedFieldIndex Integer iField Returns Integer
14167>>>>>        tDDRemembered[] DefaultValues
14167>>>>>        tDDRemembered[] DefaultValues
14168>>>>>        tDDRemembered SearchItem
14168>>>>>        tDDRemembered SearchItem
14168>>>>>        Integer iIndex
14168>>>>>        Get pDDDefaults to DefaultValues
14169>>>>>        Move iField to SearchItem.iField
14170>>>>>        Move (SearchArray(SearchItem,DefaultValues)) to iIndex
14171>>>>>        Function_Return iIndex
14172>>>>>    End_Function
14173>>>>>    
14173>>>>>    // Interface used to set or clear a dynamic default (remembered) value for a DD field. If the
14173>>>>>    // value passed is empty ("" or as empty as defined by the data-type) it is cleared. If the value
14173>>>>>    // is DD_RememberLast, it will use the last value before a clear as the default, else it uses the
14173>>>>>    // passed value as the default
14173>>>>>    Procedure Set Field_RememberedValue Integer iField String sValue
14175>>>>>        tDDRemembered[] DefaultValues
14175>>>>>        tDDRemembered[] DefaultValues
14176>>>>>        Integer iIndex
14176>>>>>        Boolean bNull
14176>>>>>        Get DDRememberedFieldIndex iField to iIndex
14177>>>>>        Get pDDDefaults to DefaultValues
14178>>>>>        If (sValue<>DD_RememberLast) Begin // if it is rememberlast, we know it is not null
14180>>>>>            Get IsEmptyField iField sValue to bNull
14181>>>>>        End
14181>>>>>>
14181>>>>>        If (not(bNull)) Begin
14183>>>>>            If (iIndex=-1) Begin
14185>>>>>                Move (SizeOfArray(DefaultValues)) to iIndex
14186>>>>>                Move iField to DefaultValues[iIndex].iField
14187>>>>>            End
14187>>>>>>
14187>>>>>            Move sValue to DefaultValues[iIndex].sDefault
14188>>>>>            Set pDDDefaults to DefaultValues
14189>>>>>        End
14189>>>>>>
14189>>>>>        Else If  (iIndex<>-1) Begin
14192>>>>>            Set pDDDefaults to (RemoveFromArray(DefaultValues,iIndex))
14193>>>>>        End
14193>>>>>>
14193>>>>>    End_Procedure
14194>>>>>    
14194>>>>>    // get the remembered value as per rules above
14194>>>>>    Function Field_RememberedValue Integer iField Returns String
14196>>>>>        tDDRemembered[] DefaultValues
14196>>>>>        tDDRemembered[] DefaultValues
14197>>>>>        Integer iIndex
14197>>>>>        Get DDRememberedFieldIndex iField to iIndex
14198>>>>>        If (iIndex<>-1) Begin
14200>>>>>            Get pDDDefaults to DefaultValues
14201>>>>>            Function_Return DefaultValues[iIndex].sDefault
14202>>>>>        End
14202>>>>>>
14202>>>>>        Function_Return ''
14203>>>>>    End_Function
14204>>>>>    
14204>>>>>    Procedure AssignDynamicDefaults
14206>>>>>        Integer iField iFields iFile
14206>>>>>        tDDRemembered[] DefaultValues
14206>>>>>        tDDRemembered[] DefaultValues
14207>>>>>        Boolean bMain
14207>>>>>        String sValue
14207>>>>>        
14207>>>>>        Get Main_File to iFile
14208>>>>>        Get pDDDefaults to DefaultValues
14209>>>>>        Move (SizeOfArray(DefaultValues)) to iFields
14210>>>>>        For iField from 0 to (iFields-1)
14216>>>>>>
14216>>>>>            If ( DefaultValues[iField].sDefault<>"") Begin
14218>>>>>                If (DefaultValues[iField].sDefault=DD_RememberLast) Begin
14220>>>>>                    Move DefaultValues[iField].sLastValue to sValue
14221>>>>>                End
14221>>>>>>
14221>>>>>                Else Begin
14222>>>>>                    Move DefaultValues[iField].sDefault to sValue
14223>>>>>                End
14223>>>>>>
14223>>>>>                Set Field_Changed_Value DefaultValues[iField].iField to sValue
14224>>>>>            End
14224>>>>>>
14224>>>>>        Loop
14225>>>>>>
14225>>>>>    End_Procedure
14226>>>>>    
14226>>>>>    // Clears all remembered defaults for this DD.
14226>>>>>    Procedure ClearRememberedDefaults
14228>>>>>        tDDRemembered[] DefaultValues
14228>>>>>        tDDRemembered[] DefaultValues
14229>>>>>        Set pDDDefaults to DefaultValues
14230>>>>>    End_Procedure
14231>>>>>    
14231>>>>>    Procedure PrivateClearAllRememberedDefaults
14233>>>>>        Integer iCount iMax
14233>>>>>        Handle hoDD
14233>>>>>        Boolean bVisisted
14233>>>>>        
14233>>>>>        Set Visited_State to True
14234>>>>>        
14234>>>>>        Get Data_Set_Server_Count to iMax
14235>>>>>        Decrement iMax
14236>>>>>        For iCount from 0 to iMax
14242>>>>>>
14242>>>>>            Get Data_Set_Server iCount to hoDD
14243>>>>>            Get Visited_State of hoDD to bVisisted
14244>>>>>            If not (bVisisted) Begin
14246>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
14247>>>>>            End
14247>>>>>>
14247>>>>>        Loop
14248>>>>>>
14248>>>>>        
14248>>>>>        Send ClearRememberedDefaults
14249>>>>>        
14249>>>>>        Get Data_Set_Client_Count to iMax
14250>>>>>        Decrement iMax
14251>>>>>        For iCount from 0 to iMax
14257>>>>>>
14257>>>>>            Get Data_Set_Client iCount to hoDD
14258>>>>>            Get Visited_State of hoDD to bVisisted
14259>>>>>            If not (bVisisted) Begin
14261>>>>>                Send PrivateClearAllRememberedDefaults of hoDD
14262>>>>>            End
14262>>>>>>
14262>>>>>        Loop
14263>>>>>>
14263>>>>>        
14263>>>>>    End_Procedure
14264>>>>>    
14264>>>>>    // Clears all remembered defaults for all DDs in this structure.
14264>>>>>    Procedure ClearAllRememberedDefaults
14266>>>>>        Send InitializeAllVisited
14267>>>>>        Send PrivateClearAllRememberedDefaults
14268>>>>>    End_Procedure
14269>>>>>    
14269>>>>>    // This is called after a clear or clear all is sent to this DD. It does autofinds as needed
14269>>>>>    // for any parent DDs. It does this if the parent is not a relates to contraining parent, if
14269>>>>>    // a field has an index, it has a changed value and it is autofind or autofind_ge.
14269>>>>>    Procedure DefaultParentAutofinds
14271>>>>>        Integer i iServers iField iFields iFile iIndex iOpts
14271>>>>>        Boolean bDoAutoFind bRelates bIsEmptyField
14271>>>>>        String sValue
14271>>>>>        Handle hoServer
14271>>>>>        Get Data_Set_Server_Count to iServers
14272>>>>>        For i from 0 to (iServers-1)
14278>>>>>>
14278>>>>>            Get Data_Set_Server i to hoServer
14279>>>>>            Get Main_File of hoServer to iFile
14280>>>>>            Get IsRelatesToConstrained iFile to bRelates
14281>>>>>            // never autofind on a relates-to constraining parent
14281>>>>>            If not (bRelates) Begin
14283>>>>>                
14283>>>>>                Get Field_Count of hoServer to iFields
14284>>>>>                Move False to bDoAutoFind
14285>>>>>                Move 1 to iField
14286>>>>>                While (not(bDoAutoFind) and (iField<=iFields))
14290>>>>>                    Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
14293>>>>>                    If (iIndex>0) Begin
14295>>>>>                        Get Field_Changed_State of hoServer iField to bDoAutoFind
14296>>>>>                        If bDoAutoFind Begin
14298>>>>>                            Get Field_Current_Value of hoServer iField to sValue
14299>>>>>                            Get IsEmptyField of hoServer iField sValue to bIsEmptyField
14300>>>>>                            Move (not(bIsEmptyField)) to bDoAutoFind
14301>>>>>                            If bDoAutoFind Begin
14303>>>>>                                Get File_Field_Options iFile iField to iOpts
14304>>>>>                                // if this is a retain or retainall we don't do this because we want
14304>>>>>                                // to maintain backwards compatibility
14304>>>>>                                Move ( (iOpts iand DD_AUTOFIND or iOpts iand DD_AUTOFIND_GE) and ;                                    not( iOpts iand DD_RETAIN or iOpts iand DD_RETAINALL) ) to bDoAutoFind
14305>>>>>                                If bDoAutoFind Begin
14307>>>>>                                    Send File_Field_Default_AutoFind iFile iField
14308>>>>>                                    Set Changed_State to False // clears parent changed state
14309>>>>>                                End
14309>>>>>>
14309>>>>>                            End
14309>>>>>>
14309>>>>>                        End
14309>>>>>>
14309>>>>>                    End
14309>>>>>>
14309>>>>>                    Increment iField
14310>>>>>                Loop
14311>>>>>>
14311>>>>>                
14311>>>>>                // Only check for grandparent autofinds if this parent did not do a an autofind
14311>>>>>                // Doing an autofind on an autofind parent's parent is just too confusing
14311>>>>>                If not bDoAutoFind Begin
14313>>>>>                    Send DefaultParentAutofinds of hoServer
14314>>>>>                End
14314>>>>>>
14314>>>>>            End
14314>>>>>>
14314>>>>>        Loop
14315>>>>>>
14315>>>>>    End_Procedure
14316>>>>>    
14316>>>>>    // Set this DD to be an alias, passing the file number of the alias
14316>>>>>    // This can only be called once per instance and the Main_File must already have been set
14316>>>>>    // most likely in a superclass.
14316>>>>>    // This sets Main_File to the alias, stores the original master file (accessed via MasterForAlias).
14316>>>>>    // It also clears all existing relatonships. Normally we expect the alias class to set
14316>>>>>    // sets pbUseDDRelates and pbNoCascadeDeleteStrict to true. We don't do that automatically so that
14316>>>>>    // the Studio's property panel will show the correct values. When an alias is defined using the
14316>>>>>    // studio it will set these two properties.
14316>>>>>    // This means you must set any required relationships yourself
14316>>>>>    Procedure Set Alias_File Integer iTable
14318>>>>>        Integer iMain iMaster iFieldsM iFieldsA
14318>>>>>        Get Main_File to iMain
14319>>>>>        Get MasterForAlias to iMaster
14320>>>>>        
14320>>>>>        If (iTable=0 and iMaster) Begin
14322>>>>>            Error DFERR_PROGRAM "Cannot unset alias table"
14323>>>>>>
14323>>>>>            Procedure_Return
14324>>>>>        End
14324>>>>>>
14324>>>>>        If (iTable=iMain) Begin
14326>>>>>            Error DFERR_PROGRAM "Cannot set alias table to self"
14327>>>>>>
14327>>>>>            Procedure_Return
14328>>>>>        End
14328>>>>>>
14328>>>>>        If (iMaster) Begin
14330>>>>>            Error DFERR_PROGRAM "Cannot redefine alias table"
14331>>>>>>
14331>>>>>            Procedure_Return
14332>>>>>        End
14332>>>>>>
14332>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iMain to iFieldsM
14335>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iFieldsA
14338>>>>>        If (iFieldsA<>iFieldsM) Begin
14340>>>>>            Error DFERR_PROGRAM "Alias and Master file are not based on the same table"
14341>>>>>>
14341>>>>>            Procedure_Return
14342>>>>>        End
14342>>>>>>
14342>>>>>        
14342>>>>>        Set piMasterTable to iMain
14343>>>>>        Set Main_File to iTable
14344>>>>>        Send DefineAsAlias
14345>>>>>    End_Procedure
14346>>>>>    
14346>>>>>    Procedure DefineAsAlias
14348>>>>>        Integer i iFile
14348>>>>>        
14348>>>>>        // We expect he developer to set these properties to True
14348>>>>>        //Set pbUseDDRelates to True
14348>>>>>        //Set pbNoCascadeDeleteStrict to True
14348>>>>>        
14348>>>>>        Send ClearDDRelates
14349>>>>>        Get Client_File_Count to i
14350>>>>>        While i
14354>>>>>            Decrement i
14355>>>>>            Get Client_File i to iFile
14356>>>>>            Send Remove_Client_File iFile
14357>>>>>        Loop
14358>>>>>>
14358>>>>>        Get Server_File_Count to i
14359>>>>>        While i
14363>>>>>            Decrement i
14364>>>>>            Get Server_File i to iFile
14365>>>>>            Send Remove_Server_File iFile
14366>>>>>        Loop
14367>>>>>>
14367>>>>>    End_Procedure
14368>>>>>    
14368>>>>>    Function MasterForAlias Returns Integer
14370>>>>>        Integer iMaster
14370>>>>>        Get piMasterTable to iMaster
14371>>>>>        Function_Return iMaster
14372>>>>>    End_Function
14373>>>>>    
14373>>>>>    Function IsAlias Returns Boolean
14375>>>>>        Integer iMaster
14375>>>>>        Get piMasterTable to iMaster
14376>>>>>        Function_Return (iMaster<>0)
14377>>>>>    End_Function
14378>>>>>    
14378>>>>>    
14378>>>>>    Procedure OnSaveRecord
14380>>>>>    End_Procedure
14381>>>>>    
14381>>>>>    Procedure StoreDefaultSQLFilters
14383>>>>>        Handle hoSQLHelper
14383>>>>>        Get phoSQLHelper to hoSQLHelper
14384>>>>>        Send StoreDefaultSQLFilters of hoSQLHelper
14385>>>>>    End_Procedure
14386>>>>>    
14386>>>>>    Procedure RestoreDefaultSQLFilters
14388>>>>>        Handle hoSQLHelper
14388>>>>>        Get phoSQLHelper to hoSQLHelper
14389>>>>>        Send RestoreDefaultSQLFilters of hoSQLHelper
14390>>>>>    End_Procedure
14391>>>>>    
14391>>>>>    Procedure ApplySQLFilterStr String sFilter
14393>>>>>        Handle hoSQLHelper
14393>>>>>        Get phoSQLHelper to hoSQLHelper
14394>>>>>        Send ApplySQLFilterStr of hoSQLHelper sFilter
14395>>>>>    End_Procedure
14396>>>>>    
14396>>>>>    
14396>>>>>    Procedure ApplySQLFilter
14398>>>>>        String sNewFilter sOldFilter
14398>>>>>        Boolean bApplyGlobalSQLFilters bOldFilterActive
14398>>>>>        Handle hoSQLHelper
14398>>>>>        Get phoSQLHelper to hoSQLHelper
14399>>>>>        Get psSQLFilter to sNewFilter
14400>>>>>        // if we have am active  table filter we can either ignore it or and it to the where clause
14400>>>>>        // pbApplyGlobalSQLFilters determines what to do.
14400>>>>>        Get pbApplyGlobalSQLFilters to bApplyGlobalSQLFilters
14401>>>>>        Get pbOldFilterActive to bOldFilterActive
14402>>>>>        If (bApplyGlobalSQLFilters and bOldFilterActive) Begin
14404>>>>>            Get psOldFilter to sOldFilter
14405>>>>>            Get SQLStrAppend sOldFilter sNewFilter to sNewFilter
14406>>>>>        End
14406>>>>>>
14406>>>>>        Send ApplySQLFilterStr of hoSQLHelper sNewFilter
14407>>>>>    End_Procedure
14408>>>>>    
14408>>>>>    Procedure Data_Set_PreFind
14410>>>>>        Boolean bUseDDSQLFilters
14410>>>>>        String sOldDDFilter
14410>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
14411>>>>>        If bUseDDSQLFilters Begin
14413>>>>>            
14413>>>>>            Send StoreDefaultSQLFilters
14414>>>>>            
14414>>>>>            // this can get called during cascade deletes. In such a case we will
14414>>>>>            // never explicitly not apply an SQL filters because it could violate relational integrity
14414>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
14416>>>>>                Get psSQLFilter to sOldDDFilter
14417>>>>>                Set psSQLFilter to "" // make sure there is no filter applied
14418>>>>>            End
14418>>>>>>
14418>>>>>            
14418>>>>>            Send ApplySQLFilter
14419>>>>>            
14419>>>>>            If (OPERATION_MODE=MODE_DELETING) Begin
14421>>>>>                Set psSQLFilter to sOldDDFilter
14422>>>>>            End
14422>>>>>>
14422>>>>>        End
14422>>>>>>
14422>>>>>    End_Procedure
14423>>>>>    
14423>>>>>    Procedure Data_Set_PostFind
14425>>>>>        Boolean bUseDDSQLFilters
14425>>>>>        Get pbUseDDSQLFilters to bUseDDSQLFilters
14426>>>>>        If bUseDDSQLFilters Begin
14428>>>>>            Send RestoreDefaultSQLFilters
14429>>>>>        End
14429>>>>>>
14429>>>>>    End_Procedure
14430>>>>>    
14430>>>>>    
14430>>>>>    // returns active constraints in atConstraintDef array.
14430>>>>>    // Should be called after constraints are built
14430>>>>>    // typically right after Rebuild_Constraints
14430>>>>>    
14430>>>>>    Function DDOConstraints Returns tConstraintDef[]
14432>>>>>        tConstraintDef[] Constraints
14432>>>>>        tConstraintDef[] Constraints
14433>>>>>        Integer i iCount i1
14433>>>>>        Get DATA_SET_CONSTRAINT_COUNT to iCount
14434>>>>>        For i from 0 to (iCount-1)
14440>>>>>>
14440>>>>>            Get DATA_SET_CONSTRAINT_INFO i 0 to i1 // type / mode
14441>>>>>            Move (Hi(i1)) to  Constraints[i].eType
14442>>>>>            Move (Low(i1)) to  Constraints[i].eMode
14443>>>>>            Get DATA_SET_CONSTRAINT_INFO i 1 to i1 // file / field
14444>>>>>            Move (Hi(i1)) to  Constraints[i].iFile
14445>>>>>            Move (Low(i1)) to  Constraints[i].iField
14446>>>>>            Get DATA_SET_CONSTRAINT_INFO i 2 to i1 // other file /field
14447>>>>>            Move (Hi(i1)) to  Constraints[i].iOtherFile
14448>>>>>            Move (Low(i1)) to  Constraints[i].iOtherField
14449>>>>>            Get DATA_SET_CONSTRAINT_INFO_Value i  to Constraints[i].sValue
14450>>>>>        Loop
14451>>>>>>
14451>>>>>        Function_Return Constraints
14452>>>>>    End_Function
14453>>>>>    
14453>>>>>    // returns constraint finding information about the current find. This tells us what kinds
14453>>>>>    // of constraint find "expressions" are used. This will actually do a cosntrained find
14453>>>>>    // initialization much like Establish_Find_Direction, which means it can change the values in
14453>>>>>    // the file buffer to assist with a jump-in.
14453>>>>>    Function DDOConstraintFindMeta Integer eMode Integer iOrder Returns tDDOConstraintFindMeta
14455>>>>>        tDDOConstraintFindMeta FindMeta
14455>>>>>        tDDOConstraintFindMeta FindMeta
14455>>>>>        Integer i
14455>>>>>        Get Data_Set_Constraint_Exps eMode iOrder to i
14456>>>>>        Move (Hi(i)) to FindMeta.iJumpInSegments
14457>>>>>        Move (i iand CONST_EXP_JUMPOUT) to FindMeta.bJumpOut
14458>>>>>        Move (i iand CONST_EXP_PRE_RELATE) to FindMeta.bPreRelate
14459>>>>>        Move (i iand CONST_EXP_POST_RELATE) to FindMeta.bPostRelate
14460>>>>>        Function_Return FindMeta
14461>>>>>    End_Function
14462>>>>>    
14462>>>>>    // this tells you if the current find or read requires a relate to evaluate the DF constraint.
14462>>>>>    // If false you could use this to set no_relate_state to false for the find/read process and then
14462>>>>>    // restore it when complete. Be careful using this.
14462>>>>>    Function DDOConstraintNeedsRelate Integer iOrder Returns Boolean
14464>>>>>        tDDOConstraintFindMeta FindMeta
14464>>>>>        tDDOConstraintFindMeta FindMeta
14464>>>>>        Get DDOConstraintFindMeta (GE) iOrder to FindMeta
14465>>>>>        Function_Return FindMeta.bPostRelate
14466>>>>>    End_Function
14467>>>>>    
14467>>>>>    // returns true if this table supports SQL filter interface
14467>>>>>    Function SupportsSQLFilters Returns Boolean
14469>>>>>        Boolean bSupports
14469>>>>>        Handle hoSQLHelper
14469>>>>>        Get phoSQLHelper to hoSQLHelper
14470>>>>>        Get SupportsSQLFilters of hoSQLHelper to bSupports
14471>>>>>        Function_Return bSupports
14472>>>>>    End_Function
14473>>>>>    
14473>>>>>    // SQL Helper functions that return SQL Filters strings that can be used in a where clause
14473>>>>>    
14473>>>>>    // Creates an SQL Like Filter for this field and search target
14473>>>>>    Function SQLStrLike Integer iField String sSearch Returns String
14475>>>>>        String sFilter
14475>>>>>        Handle hoSQLHelper
14475>>>>>        Get phoSQLHelper to hoSQLHelper
14476>>>>>        Get SQLStrLike of hoSQLHelper iField sSearch to sFilter
14477>>>>>        Function_Return sFilter
14478>>>>>    End_Function
14479>>>>>    
14479>>>>>    // Appends two Filters with an AND clause. Both or either can be empty
14479>>>>>    Function SQLStrAppend String sOrigFilter String sFilter Returns String
14481>>>>>        Handle hoSQLHelper
14481>>>>>        Get phoSQLHelper to hoSQLHelper
14482>>>>>        Get SQLStrAppend of hoSQLHelper sOrigFilter sFilter to sFilter
14483>>>>>        Function_Return sFilter
14484>>>>>    End_Function
14485>>>>>    
14485>>>>>    // returns the name of the File and Field suitable for an SQL where statement
14485>>>>>    Function SQLStrFileFieldName Integer iField Returns String
14487>>>>>        String sName
14487>>>>>        Handle hoSQLHelper
14487>>>>>        Get phoSQLHelper to hoSQLHelper
14488>>>>>        Get SQLStrFileFieldName of hoSQLHelper iField to sName
14489>>>>>        Function_Return sName
14490>>>>>    End_Function
14491>>>>>
14491>>>>>    // returns the name of the Field suitable for an SQL where statement
14491>>>>>    Function SQLStrFieldName Integer iField Returns String
14493>>>>>        String sName
14493>>>>>        Handle hoSQLHelper
14493>>>>>        Get phoSQLHelper to hoSQLHelper
14494>>>>>        Get SQLStrFieldName of hoSQLHelper iField to sName
14495>>>>>        Function_Return sName
14496>>>>>    End_Function
14497>>>>>
14497>>>>>    // returns the name of the Schema and File and Field suitable for an SQL where statement
14497>>>>>    Function SQLStrSchemaFileFieldName Integer iField Returns String
14499>>>>>        String sName
14499>>>>>        Handle hoSQLHelper
14499>>>>>        Get phoSQLHelper to hoSQLHelper
14500>>>>>        Get SQLStrFileFieldName of hoSQLHelper iField to sName
14501>>>>>        Function_Return sName
14502>>>>>    End_Function
14503>>>>>
14503>>>>>    
14503>>>>>    // creates escaped SQL string by replacing single quote with two single quotes
14503>>>>>    Function SQLEscapedStr String sSQL Returns String
14505>>>>>        Handle hoSQLHelper
14505>>>>>        Get phoSQLHelper to hoSQLHelper
14506>>>>>        Get SQLEscapedStr of hoSQLHelper sSQL to sSQL
14507>>>>>        Function_Return sSQL
14508>>>>>    End_Function
14509>>>>>    
14509>>>>>    // Returns:
14509>>>>>    //       The record id string based on piPrimaryIndex.
14509>>>>>    Function PrimaryRecordId Returns String
14511>>>>>        Integer iIndex iFile iSegments iSegment iField
14511>>>>>        String sVal sId
14511>>>>>        
14511>>>>>        Get Main_File to iFile
14512>>>>>        Get piPrimaryIndex to iIndex
14513>>>>>        
14513>>>>>        If (iIndex < 0) Begin
14515>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
14518>>>>>        End
14518>>>>>>
14518>>>>>        
14518>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
14521>>>>>        For iSegment from 1 to iSegments
14527>>>>>>
14527>>>>>            Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
14530>>>>>            
14530>>>>>            Get_Field_Value iFile iField to sVal
14533>>>>>            Move (Trim(sVal)) to sVal
14534>>>>>            
14534>>>>>            //  Encode join sign for multi segment indexes
14534>>>>>            If (iSegments > 1) Begin
14536>>>>>                Move (Replaces("_", sVal, "~5F~")) to sVal
14537>>>>>            End
14537>>>>>>
14537>>>>>            
14537>>>>>            If (iSegment = 1) Begin
14539>>>>>                Move sVal to sId
14540>>>>>            End
14540>>>>>>
14540>>>>>            Else Begin
14541>>>>>                Move (sId + "_" + sVal) to sId
14542>>>>>            End
14542>>>>>>
14542>>>>>            
14542>>>>>        Loop
14543>>>>>>
14543>>>>>        
14543>>>>>        Function_Return sId
14544>>>>>    End_Function
14545>>>>>    
14545>>>>>    
14545>>>>>    // Finds a record on the global buffer based on the record id.
14545>>>>>    //
14545>>>>>    // Params:
14545>>>>>    //       sRecordId   Record id generated by PrimaryRecordId.
14545>>>>>    Function FindByPrimaryRecordId String sRecordId Returns Boolean
14547>>>>>        Integer iIndex iFile iSegments iSegment iField
14547>>>>>        String[] aValues
14548>>>>>        String sVal
14548>>>>>        Boolean bTrapped
14548>>>>>        
14548>>>>>        Get Main_File to iFile
14549>>>>>        Get piPrimaryIndex to iIndex
14550>>>>>        
14550>>>>>        If (iIndex < 0) Begin
14552>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iFile to iIndex
14555>>>>>        End
14555>>>>>>
14555>>>>>        
14555>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iIndex to iSegments
14558>>>>>        
14558>>>>>        If (iSegments > 1) Begin
14560>>>>>            Move (StrSplitToArray(sRecordId, "_")) to aValues
14561>>>>>        End
14561>>>>>>
14561>>>>>        Else Begin
14562>>>>>            Move sRecordId to aValues[0]
14563>>>>>        End
14563>>>>>>
14563>>>>>        
14563>>>>>        If (iSegments = SizeOfArray(aValues)) Begin
14565>>>>>            Clear iFile
14566>>>>>            
14566>>>>>            Send Ignore_Error of Error_Object_Id 56
14567>>>>>            Send Ignore_Error of Error_Object_Id 11
14568>>>>>            
14568>>>>>            For iSegment from 1 to iSegments
14574>>>>>>
14574>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iIndex iSegment to iField
14577>>>>>                
14577>>>>>                Move aValues[iSegment - 1] to sVal
14578>>>>>                If (iSegments > 1) Begin
14580>>>>>                    Move (Replaces("~5F~", sVal, "_")) to sVal
14581>>>>>                End
14581>>>>>>
14581>>>>>                
14581>>>>>                Set_Field_Value iFile iField to sVal
14584>>>>>            Loop
14585>>>>>>
14585>>>>>            Send Trap_Error of Error_Object_Id 56
14586>>>>>            Send Trap_Error of Error_Object_Id 11
14587>>>>>            
14587>>>>>            Vfind iFile iIndex EQ
14589>>>>>            
14589>>>>>            Function_Return (Found)
14590>>>>>        End
14590>>>>>>
14590>>>>>        
14590>>>>>        Function_Return False
14591>>>>>    End_Function
14592>>>>>    
14592>>>>>    // Converts a RecordId to a RowId by finding it on the global buffer.
14592>>>>>    //
14592>>>>>    // Params:
14592>>>>>    //       sRecordId   Record id based on piPrimaryIndex.
14592>>>>>    //       rRowId      (ByRef) Will be filled with the rowid.
14592>>>>>    // Returns:
14592>>>>>    //       True if the record id was valid.
14592>>>>>    Function RecordIdToRowId String sRecordId RowID ByRef rRowId Returns Boolean
14594>>>>>        Boolean bFound
14594>>>>>        
14594>>>>>        Get FindByPrimaryRecordId sRecordId to bFound
14595>>>>>        If (bFound) Begin
14597>>>>>            Move (GetRowID(Main_File(Self))) to rRowId
14598>>>>>        End
14598>>>>>>
14598>>>>>        Else Begin
14599>>>>>            Move (NullRowID()) to rRowId
14600>>>>>        End
14600>>>>>>
14600>>>>>        
14600>>>>>        Function_Return bFound
14601>>>>>    End_Function
14602>>>>>    
14602>>>>>    // Converts a RowId into a record ID. Note that it performs a find on the global buffer.
14602>>>>>    //
14602>>>>>    // Params:
14602>>>>>    //       riRowId     RowID.
14602>>>>>    // Returns:
14602>>>>>    //       Record id based on piPrimaryIndex.
14602>>>>>    Function RowIdToRecordId RowID riRowId Returns String
14604>>>>>        Boolean bFound
14604>>>>>        String sRecId
14604>>>>>        
14604>>>>>        If (not(IsNullRowID(riRowId))) Begin
14606>>>>>            Move (FindByRowID(Main_File(Self), riRowId)) to bFound
14607>>>>>            
14607>>>>>            If (bFound) Begin
14609>>>>>                Get PrimaryRecordId to sRecId
14610>>>>>            End
14610>>>>>>
14610>>>>>        End
14610>>>>>>
14610>>>>>        
14610>>>>>        Function_Return sRecId
14611>>>>>    End_Function
14612>>>>>End_Class
14613>>>>>
14613>>>>>// This message will be send as a notification message from an
14613>>>>>// Extended_Data_Set whenever a fieldvalue has been changed.
14613>>>>>// It has been defined FOR cUIObject or Desktop  here so that attached
14613>>>>>// DEO which do not know anything about Extended_Data_Sets don't get
14613>>>>>// frustrated.
14613>>>>>// All focusable objects and DEOs must understand this. This should be
14613>>>>>// changed at some point in the future.
14613>>>>>Function Extended_DEO_State for cUIObject Returns Integer
14615>>>>>End_Function
14616>>>>>
14616>>>>>
14616>>>>>// this command is now obsolete. use Set Field_auto_increment
14616>>>>>
14616>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\DUFStatusPanel.pkg)
14616>>>>>// StatPnl.pkg - creates the standard status_panel object.
14616>>>>>//
14616>>>>>//
14616>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
14616>>>>>// invoke the standard status panel. The standard has always been that the package name
14616>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
14616>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
14616>>>>>// prior revisions has been replace with status panel that is part of the application.
14616>>>>>// This should work much better and faster than the old sentinel based solution.
14616>>>>>// While the way this operates has changed, the interface has not and therefore this should work
14616>>>>>// with most applications.
14616>>>>>//
14616>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
14616>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
14616>>>>>// a cleaner more robust interface.
14616>>>>>//
14616>>>>>//
14616>>>>>// Compatibility Note:
14616>>>>>//
14616>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
14616>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
14616>>>>>//
14616>>>>>// If for some reason you application will not work using this as a replacement for the old status
14616>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
14616>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
14616>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
14616>>>>>//
14616>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
14616>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
14616>>>>>//
14616>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
14616>>>>>// can still access the new object via the ghoStatusPanel handle.
14616>>>>>//
14616>>>>>//
14616>>>>>// Creating your own Status Panel objects
14616>>>>>//
14616>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
14616>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
14616>>>>>// with a different file and object name and direct your status panel request to the new object.
14616>>>>>//
14616>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
14616>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
14616>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
14616>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
14616>>>>>// e.g.
14616>>>>>//       Procedure UpdateStatusBar
14616>>>>>//           Send DoAdvance of oProgressBar
14616>>>>>//           Send ProcessEvents
14616>>>>>//       End_Procedure
14616>>>>>//
14616>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
14616>>>>>// messages this will be done for you.
14616>>>>>//
14616>>>>>// the standard Interface for status panels are:
14616>>>>>//
14616>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
14616>>>>>// Send Start_StatusPanel      - start the status panel
14616>>>>>// Send Stop_StatusPanel       - stop the status panel
14616>>>>>// Send Update_StatusPanel     - update the status panel's action area
14616>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
14616>>>>>//
14616>>>>>// Get/Set Caption_Text - updates the caption bar
14616>>>>>// Get/Set Title_Text   - updates the title area
14616>>>>>// Get/Set Message_Text - updates the Message area
14616>>>>>// Get/Set Action_Text  - updates the action area
14616>>>>>// Get/Set Button_Text  - updates the button area
14616>>>>>//
14616>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
14616>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
14616>>>>>//
14616>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
14616>>>>>Use cProcessStatusPanel.pkg
Including file: cProcessStatusPanel.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cProcessStatusPanel.pkg)
14616>>>>>>>// cProcessStatusPanel.pkg
14616>>>>>>>//
14616>>>>>>>// Class used to create StatusPanels.
14616>>>>>>>//
14616>>>>>>>// This class does not provide any of the inner objects that make up a status panel. Instead an
14616>>>>>>>// interface is provided that is used to update the various areas of status panel. At this level,
14616>>>>>>>// those areas (title area, message area, action area, button area) are logical. You create the
14616>>>>>>>// physical objects at the object level and then bind these objects to the interface.
14616>>>>>>>// Take a look at StatPnl.pkg to see how this is used.
14616>>>>>>>//
14616>>>>>>>// the standard Interface for status panels are:
14616>>>>>>>//
14616>>>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
14616>>>>>>>// Send Start_StatusPanel      - start the status panel
14616>>>>>>>// Send Stop_StatusPanel       - stop the status panel
14616>>>>>>>// Send Update_StatusPanel     - update the status panel's action area
14616>>>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
14616>>>>>>>//
14616>>>>>>>// Get/Set Caption_Text - updates the caption bar
14616>>>>>>>// Get/Set Title_Text   - updates the title area
14616>>>>>>>// Get/Set Message_Text - updates the Message area
14616>>>>>>>// Get/Set Action_Text  - updates the action area
14616>>>>>>>// Get/Set Button_Text  - updates the button area
14616>>>>>>>//
14616>>>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
14616>>>>>>>// Send EnableCancelButton - code must be provided in the cancel button object to enable/disable cancel button
14616>>>>>>>//
14616>>>>>>>
14616>>>>>>>Use cStatusPanel.pkg
Including file: cStatusPanel.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cStatusPanel.pkg)
14616>>>>>>>>>// This is an abstract class that can be used to create status panels. The interface at this level
14616>>>>>>>>>// is very simple. You can start, stop, request a cancel and allow the object to paint.
14616>>>>>>>>>//
14616>>>>>>>>>// Look at cProcessStatusPanel.pkg to see how this is used.
14616>>>>>>>>>
14616>>>>>>>>>Use Windows.pkg
14616>>>>>>>>>
14616>>>>>>>>>
14616>>>>>>>>>
14616>>>>>>>>>
14616>>>>>>>>>Class cStatusPanel is a FloatingPanel
14617>>>>>>>>>    
14617>>>>>>>>>    Procedure Construct_Object
14619>>>>>>>>>        Forward Send Construct_object
14621>>>>>>>>>        
14621>>>>>>>>>        Property Boolean pbCancel False
14622>>>>>>>>>        
14622>>>>>>>>>        Set Extended_Window_Style to WS_EX_DLGMODALFRAME True // kills sysmenu as long as there is no icon
14623>>>>>>>>>        Set Icon to '' // this must be cleared so there will be no icon
14624>>>>>>>>>        Set locate_mode to CENTER_ON_PANEL
14625>>>>>>>>>        Set Border_Style  to Border_Dialog
14626>>>>>>>>>        // should be scoped so it will not try to change the focus if there is no focusable button inside
14626>>>>>>>>>        Set Scope_State to True
14627>>>>>>>>>        
14627>>>>>>>>>        On_Key KEXIT_APPLICATION Send Close_Panel
14628>>>>>>>>>    End_Procedure
14629>>>>>>>>>    
14629>>>>>>>>>    // this is private and required. Never send this.
14629>>>>>>>>>    Procedure Deactivate_Group
14631>>>>>>>>>        If (Active_State(Self)) Begin
14633>>>>>>>>>            Send SuspendGUI of Desktop False
14634>>>>>>>>>        End
14634>>>>>>>>>>
14634>>>>>>>>>        Forward Send Deactivate_Group
14636>>>>>>>>>    End_Procedure
14637>>>>>>>>>    
14637>>>>>>>>>    // Send this message to stop the panel
14637>>>>>>>>>    Procedure Deactivate
14639>>>>>>>>>        If (Active_State(Self)) Begin
14641>>>>>>>>>            Send SuspendGUI of Desktop False
14642>>>>>>>>>        End
14642>>>>>>>>>>
14642>>>>>>>>>        Forward Send Deactivate
14644>>>>>>>>>    End_Procedure
14645>>>>>>>>>    
14645>>>>>>>>>    // Send this message to start the panel
14645>>>>>>>>>    Procedure Activate
14647>>>>>>>>>        If not (Active_State(Self)) Begin
14649>>>>>>>>>            Set pbCancel to False
14650>>>>>>>>>            Send SuspendGUI of Desktop True
14651>>>>>>>>>        End
14651>>>>>>>>>>
14651>>>>>>>>>        Forward Send Activate
14653>>>>>>>>>    End_Procedure
14654>>>>>>>>>    
14654>>>>>>>>>    // This allows the panel to paint when used in a tight loop, which is what status panels are
14654>>>>>>>>>    // used for. Any time you update the panel or wish to check for a cancel, you should call this.
14654>>>>>>>>>    Procedure ProcessEvents
14656>>>>>>>>>        If (Active_State(Self)) Begin
14658>>>>>>>>>            Send PumpMsgQueue of Desktop
14659>>>>>>>>>        End
14659>>>>>>>>>>
14659>>>>>>>>>    End_Procedure
14660>>>>>>>>>    
14660>>>>>>>>>    // note close panel does not actually close the panel. It just sets pbCancel to True, informing the
14660>>>>>>>>>    // process using this that it wants to close. It is then up the process close the panel.
14660>>>>>>>>>    Procedure Close_Panel
14662>>>>>>>>>        Set pbCancel to True
14663>>>>>>>>>    End_Procedure
14664>>>>>>>>>    
14664>>>>>>>>>End_Class
14665>>>>>>>
14665>>>>>>>
14665>>>>>>>
14665>>>>>>>Class cProcessStatusPanel is a cStatusPanel
14666>>>>>>>    
14666>>>>>>>    Procedure Construct_Object
14668>>>>>>>        Forward Send Construct_object
14670>>>>>>>        // determines if panel can be canceled
14670>>>>>>>        Property Boolean Allow_Cancel_State True
14671>>>>>>>    End_Procedure
14672>>>>>>>    
14672>>>>>>>    // Any of the properties that change the text of a status panel must also send
14672>>>>>>>    // ProcessEvents which allows the panel to process painting messages. The ProcessEvents
14672>>>>>>>    // is essential when using status panels within a tight loop
14672>>>>>>>    
14672>>>>>>>    Procedure Set Caption_text String sText
14674>>>>>>>        Set Label to sText
14675>>>>>>>        Send ProcessEvents
14676>>>>>>>    End_Procedure
14677>>>>>>>    
14677>>>>>>>    Function Caption_Text Returns String
14679>>>>>>>        Function_Return (Label(Self))
14680>>>>>>>    End_Function
14681>>>>>>>    
14681>>>>>>>    Procedure Set Message_Text String sText
14683>>>>>>>        Send ProcessEvents
14684>>>>>>>    End_Procedure
14685>>>>>>>    
14685>>>>>>>    Function Message_Text Returns String
14687>>>>>>>    End_Function
14688>>>>>>>    
14688>>>>>>>    Procedure Set Action_Text String sText
14690>>>>>>>        Send ProcessEvents
14691>>>>>>>    End_Procedure
14692>>>>>>>    
14692>>>>>>>    Function Action_Text Returns String
14694>>>>>>>    End_Function
14695>>>>>>>    
14695>>>>>>>    Procedure Set Button_Text String sText
14697>>>>>>>        Send ProcessEvents
14698>>>>>>>    End_Procedure
14699>>>>>>>    
14699>>>>>>>    Function Button_Text Returns String
14701>>>>>>>    End_Function
14702>>>>>>>    
14702>>>>>>>    Procedure Set Title_Text String sText
14704>>>>>>>        Send ProcessEvents
14705>>>>>>>    End_Procedure
14706>>>>>>>    
14706>>>>>>>    Function Title_Text Returns String
14708>>>>>>>    End_Function
14709>>>>>>>    
14709>>>>>>>    // initializes values for caption, title & message
14709>>>>>>>    Procedure Initialize_StatusPanel String sCaption String sTitle String sMessage
14711>>>>>>>        Set Caption_text to sCaption
14712>>>>>>>        Set Title_Text   to sTitle
14713>>>>>>>        Set Message_Text to sMessage
14714>>>>>>>    End_Procedure
14715>>>>>>>    
14715>>>>>>>    // update the status panel's action area
14715>>>>>>>    Procedure Update_StatusPanel String sAction
14717>>>>>>>        Set Action_Text to sAction
14718>>>>>>>    End_Procedure
14719>>>>>>>    
14719>>>>>>>    // stop the status panel
14719>>>>>>>    Procedure Close_Panel
14721>>>>>>>        If (Allow_cancel_state(Self)) Begin
14723>>>>>>>            Forward Send Close_Panel
14725>>>>>>>        End
14725>>>>>>>>
14725>>>>>>>    End_Procedure
14726>>>>>>>    
14726>>>>>>>    // Code must be provided in the cancel button object to enable/disable cancel button
14726>>>>>>>    Procedure EnableCancelButton Boolean bEnable
14728>>>>>>>    End_Procedure
14729>>>>>>>    
14729>>>>>>>    // check for cancel (if cancel or pbCancel is set, close the panel)
14729>>>>>>>    Function Check_StatusPanel Returns Integer
14731>>>>>>>        Boolean bCancel
14731>>>>>>>        If (Active_state(Self)) Begin
14733>>>>>>>            Send ProcessEvents
14734>>>>>>>            Get pbCancel to bCancel
14735>>>>>>>            If bCancel Begin
14737>>>>>>>                Send Stop_StatusPanel // the old status panel removed this when canceled.
14738>>>>>>>            End
14738>>>>>>>>
14738>>>>>>>        End
14738>>>>>>>>
14738>>>>>>>        Function_Return (If(bCancel, MSG_CANCEL, 0)) // the old check status panel returns msg_cancel
14739>>>>>>>    End_Function
14740>>>>>>>    
14740>>>>>>>    // start the status panel
14740>>>>>>>    Procedure Start_StatusPanel
14742>>>>>>>        If not (Active_state(Self)) Begin
14744>>>>>>>            Send EnableCancelButton (Allow_cancel_state(Self))
14745>>>>>>>            Send Activate
14746>>>>>>>        End
14746>>>>>>>>
14746>>>>>>>    End_Procedure
14747>>>>>>>    
14747>>>>>>>    // stop the status panel
14747>>>>>>>    Procedure Stop_StatusPanel
14749>>>>>>>        If (Active_state(Self)) Begin
14751>>>>>>>            Send Deactivate
14752>>>>>>>        End
14752>>>>>>>>
14752>>>>>>>    End_Procedure
14753>>>>>>>    
14753>>>>>>>End_Class
14754>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJSkinFramework.pkg)
14754>>>>>>>Use windows.pkg
14754>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJComSkinFramework.pkg)
14754>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v18.3.0\Bin\Codejock.SkinFramework.v18.3.0.ocx
14754>>>>>>>>>Use FlexCom20.pkg
Including file: FlexCOM20.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\FlexCOM20.pkg)
14754>>>>>>>>>>>// Full Flexcom support for automation (cComAutomationObject),
14754>>>>>>>>>>>// activeX (cComActiveXControl and document objects (cComDocumentObject)
14754>>>>>>>>>>>Use FlexCOM20_Base.pkg // defines basic flexcom symbols and class cComAutomationObject
Including file: FlexCOM20_Base.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\FlexCOM20_Base.pkg)
14754>>>>>>>>>>>>>// Flexcom support for automation (cComAutomationObject).
14754>>>>>>>>>>>>>// If you want activeX and document objects use FlexCom20.pkg
14754>>>>>>>>>>>>>Use VdfBase.pkg
14754>>>>>>>>>>>>>Use ComTypes.pkg
Including file: ComTypes.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\ComTypes.pkg)
14754>>>>>>>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Variant.pkg)
14754>>>>>>>>>>>>>>>>>Use ui
14754>>>>>>>>>>>>>>>>>Use errornum.inc
14754>>>>>>>>>>>>>>>>>
14754>>>>>>>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
14754>>>>>>>>>>>>>>>>>
14754>>>>>>>>>>>>>>>>>
14754>>>>>>>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
14755>>>>>>>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
14756>>>>>>>>>>>>>>>>>
14756>>>>>>>>>>>>>>>>>// Returns the character length of the variant string. 
14756>>>>>>>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
14758>>>>>>>>>>>>>>>>>    Address aVariant
14758>>>>>>>>>>>>>>>>>    Integer iLen iType
14758>>>>>>>>>>>>>>>>>
14758>>>>>>>>>>>>>>>>>    Move (AddressOf(bStr)) to aVariant
14759>>>>>>>>>>>>>>>>>    Move (DeRefW(aVariant,0)) to iType
14760>>>>>>>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
14762>>>>>>>>>>>>>>>>>        Function_Return 0
14763>>>>>>>>>>>>>>>>>    End
14763>>>>>>>>>>>>>>>>>>
14763>>>>>>>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
14765>>>>>>>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
14766>>>>>>>>>>>>>>>>>>
14766>>>>>>>>>>>>>>>>>        Function_Return 0
14767>>>>>>>>>>>>>>>>>    End
14767>>>>>>>>>>>>>>>>>>
14767>>>>>>>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(aVariant,8))) to iLen
14768>>>>>>>>>>>>>>>>>    Function_Return iLen
14769>>>>>>>>>>>>>>>>>End_Function
14770>>>>>>>>>>>>>>>>>
14770>>>>>>>>>>>>>>>>>
14770>>>>>>>>>>>>>>>>>// returns true if char string in the buffer can fit into a string
14770>>>>>>>>>>>>>>>>>Function ValidStringBufferLength Global Address aData Returns Boolean
14772>>>>>>>>>>>>>>>>>    Integer iMax
14772>>>>>>>>>>>>>>>>>    Get_Argument_Size to iMax
14773>>>>>>>>>>>>>>>>>    Function_Return (CStringLength(aData)<=iMax)
14774>>>>>>>>>>>>>>>>>End_Function
14775>>>>>>>>>>>>>>>>>    
14775>>>>>>>>>>>>>>>
14775>>>>>>>>>>>>>>>
14775>>>>>>>>>>>>>
14775>>>>>>>>>>>>>
14775>>>>>>>>>>>>>
14775>>>>>>>>>>>>>//Enumerations for the peAutoCreate property
14775>>>>>>>>>>>>>//acNoAutoCreate - Do not automatically instantiate the COM object upon VDF object creation.
14775>>>>>>>>>>>>>//You must manually instantiate the COM object using CreateComObject. This is the default
14775>>>>>>>>>>>>>//for cComAutomation.
14775>>>>>>>>>>>>>Define acNoAutoCreate for 0
14775>>>>>>>>>>>>>//acAutoCreate - Automatically instantiate the COM object upon VDF object creation.
14775>>>>>>>>>>>>>//You won't need to manually instantiate the COM object. This is the default
14775>>>>>>>>>>>>>//for cComActiveXControl
14775>>>>>>>>>>>>>Define acAutoCreate for 1
14775>>>>>>>>>>>>>//acDeferredAutoCreate - Automatically instantiate the COM object during Page_Object,
14775>>>>>>>>>>>>>//and automatically destroy the COM object during Page_Delete. Use this setting only
14775>>>>>>>>>>>>>//if acAutoCreate causes problems.
14775>>>>>>>>>>>>>Define acDeferredAutoCreate for 2
14775>>>>>>>>>>>>>
14775>>>>>>>>>>>>>Class cComAutomationObject is a DFComAutomationObject
14776>>>>>>>>>>>>>    Procedure Construct_Object
14778>>>>>>>>>>>>>        Forward Send Construct_Object
14780>>>>>>>>>>>>>        Send RegisterComEvents
14781>>>>>>>>>>>>>    End_Procedure
14782>>>>>>>>>>>>>    
14782>>>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
14782>>>>>>>>>>>>>    Procedure RegisterComEvents
14784>>>>>>>>>>>>>    End_Procedure
14785>>>>>>>>>>>>>    
14785>>>>>>>>>>>>>    // Attach the DF object to com automation object via progId.
14785>>>>>>>>>>>>>    // returns: Boolean bSuccess if Ok, If not ok, pcComObject is set to null
14785>>>>>>>>>>>>>    Function AttachActiveObject Returns Boolean
14787>>>>>>>>>>>>>        String sProgId
14787>>>>>>>>>>>>>        Variant vComObject
14787>>>>>>>>>>>>>        Boolean bSuccess
14787>>>>>>>>>>>>>        Get psProgID to sProgId
14788>>>>>>>>>>>>>        Get ComActiveObject sProgId to vComObject
14789>>>>>>>>>>>>>        Set pvComObject to vComObject
14790>>>>>>>>>>>>>        Move (not(IsNullComObject(vComObject))) to bSuccess // success of variant is not null
14791>>>>>>>>>>>>>        Function_Return bSuccess
14792>>>>>>>>>>>>>    End_Function
14793>>>>>>>>>>>>>    
14793>>>>>>>>>>>>>    // returns true if the control is created.
14793>>>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
14795>>>>>>>>>>>>>        Variant vComObject
14795>>>>>>>>>>>>>        Get pvComObject to vComObject
14796>>>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
14797>>>>>>>>>>>>>    End_Function
14798>>>>>>>>>>>>>    
14798>>>>>>>>>>>>>End_Class
14799>>>>>>>>>>>>>
14799>>>>>>>>>>>>>
14799>>>>>>>>>>>
14799>>>>>>>>>>>Use Windows.pkg
14799>>>>>>>>>>>
14799>>>>>>>>>>>Class cComDocumentObject is a DFComDocumentObject
14800>>>>>>>>>>>
14800>>>>>>>>>>>
14800>>>>>>>>>>>    Procedure Construct_Object
14802>>>>>>>>>>>        Forward Send Construct_Object
14804>>>>>>>>>>>        Send RegisterComEvents
14805>>>>>>>>>>>        Send Define_Standard_Object_Mixin
14806>>>>>>>>>>>        Send Define_Shadow_Mixin
14807>>>>>>>>>>>    End_Procedure
14808>>>>>>>>>>>
14808>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
14809>>>>>>>>>>>    Import_Class_Protocol Shadow_Mixin
14810>>>>>>>>>>>
14810>>>>>>>>>>>    
14810>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
14810>>>>>>>>>>>    Procedure RegisterComEvents
14812>>>>>>>>>>>    End_Procedure
14813>>>>>>>>>>>    
14813>>>>>>>>>>>    // returns true if the control is created.
14813>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
14815>>>>>>>>>>>        Variant vComObject
14815>>>>>>>>>>>        Get pvComObject to vComObject
14816>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
14817>>>>>>>>>>>    End_Function
14818>>>>>>>>>>>
14818>>>>>>>>>>>
14818>>>>>>>>>>>End_Class
14819>>>>>>>>>>>
14819>>>>>>>>>>>Class cComActiveXControl is a DFComActiveXControl
14820>>>>>>>>>>>
14820>>>>>>>>>>>    Procedure Construct_Object
14822>>>>>>>>>>>        Forward Send Construct_Object
14824>>>>>>>>>>>        Send RegisterComEvents
14825>>>>>>>>>>>
14825>>>>>>>>>>>
14825>>>>>>>>>>>        Send Define_Standard_Object_Mixin
14826>>>>>>>>>>>        Send Define_Single_Item_Navigate_Mixin
14827>>>>>>>>>>>        Send Define_Dflabel_Mixin
14828>>>>>>>>>>>
14828>>>>>>>>>>>        // internal: set true object is notified that the OCX value has changed.
14828>>>>>>>>>>>        Property Boolean pbPrivateControlChanging False
14829>>>>>>>>>>>        // Class sets this true when making a local (externally triggered) change. This is
14829>>>>>>>>>>>        // set when a Set Value change is made to prevent recursion
14829>>>>>>>>>>>        Property Boolean pbPrivateControlRefresh False
14830>>>>>>>>>>>        
14830>>>>>>>>>>>        // added to eumlate a single item form support
14830>>>>>>>>>>>        Property Boolean pbPrivateItem_Changed_State False
14831>>>>>>>>>>>        
14831>>>>>>>>>>>        // This keeps track of value, even when control is not created
14831>>>>>>>>>>>        Property String psPrivateValue ''
14832>>>>>>>>>>>        
14832>>>>>>>>>>>        // If set true, then the control will attempt to bind the value property in the object to the
14832>>>>>>>>>>>        // comValue in the control. It will try to keep these values in synch at all times. This allows a
14832>>>>>>>>>>>        // control to be used as a Form style value control. the default is true. Even when true if the
14832>>>>>>>>>>>        // get/set ComValue methods are not set up to do anything, this will do nothing.
14832>>>>>>>>>>>        Property Boolean pbBindValue True
14833>>>>>>>>>>>        
14833>>>>>>>>>>>    End_Procedure
14834>>>>>>>>>>>    
14834>>>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
14834>>>>>>>>>>>    Procedure RegisterComEvents
14836>>>>>>>>>>>    End_Procedure
14837>>>>>>>>>>>
14837>>>>>>>>>>>    
14837>>>>>>>>>>>    // returns true if the control is created.
14837>>>>>>>>>>>    Function IsComObjectCreated Returns Boolean
14839>>>>>>>>>>>        Variant vComObject
14839>>>>>>>>>>>        Get pvComObject to vComObject
14840>>>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
14841>>>>>>>>>>>    End_Function
14842>>>>>>>>>>>    
14842>>>>>>>>>>>
14842>>>>>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
14843>>>>>>>>>>>    Import_Class_Protocol Single_Item_Navigate_Mixin
14844>>>>>>>>>>>    Import_Class_Protocol Dflabel_Mixin
14845>>>>>>>>>>>
14845>>>>>>>>>>>    // added to eumlate a single item form support
14845>>>>>>>>>>>    Function Item_Count Returns Integer
14847>>>>>>>>>>>        Function_Return 1
14848>>>>>>>>>>>    End_Function
14849>>>>>>>>>>>    
14849>>>>>>>>>>>    // added to eumlate a single item form support
14849>>>>>>>>>>>    Procedure Set Item_Changed_State Integer iItem Integer iState
14851>>>>>>>>>>>        Set pbPrivateItem_changed_state to iState
14852>>>>>>>>>>>        If (iState and changed_state(Self)=False) ;            Set changed_state to True
14855>>>>>>>>>>>    End_Procedure
14856>>>>>>>>>>>    
14856>>>>>>>>>>>    Function Item_Changed_State Integer iItem Returns Integer
14858>>>>>>>>>>>        Function_Return (pbPrivateItem_changed_state(Self))
14859>>>>>>>>>>>    End_Function
14860>>>>>>>>>>>    
14860>>>>>>>>>>>    
14860>>>>>>>>>>>    // augment to set the label's appearance
14860>>>>>>>>>>>    Procedure Shadow_Display
14862>>>>>>>>>>>        Forward Send Shadow_display
14864>>>>>>>>>>>        Send Label_Shadow_Display
14865>>>>>>>>>>>    End_Procedure
14866>>>>>>>>>>>    
14866>>>>>>>>>>>    // Created to simulate get/Set value.
14866>>>>>>>>>>>    Procedure Set Value Integer iItem String sVal
14868>>>>>>>>>>>        If not (pbPrivateControlChanging(Self)) ;            Send OnRefreshControl sVal
14871>>>>>>>>>>>        Set psPrivateValue to sVal
14872>>>>>>>>>>>        Send OnChange
14873>>>>>>>>>>>        //Set changed_state to True
14873>>>>>>>>>>>        Set item_changed_state 0 to True
14874>>>>>>>>>>>    End_Procedure
14875>>>>>>>>>>>    
14875>>>>>>>>>>>    Function Value Integer iItem Returns String
14877>>>>>>>>>>>        Function_Return (psPrivateValue(Self))
14878>>>>>>>>>>>        //function_return (Controlvalue(self))
14878>>>>>>>>>>>    End_Function
14879>>>>>>>>>>>    
14879>>>>>>>>>>>    Procedure OnChange
14881>>>>>>>>>>>    End_Procedure
14882>>>>>>>>>>>    
14882>>>>>>>>>>>    
14882>>>>>>>>>>>    // It is expected that the sub-class will provide functionality
14882>>>>>>>>>>>    // for these messages. This gets and sets the value of the actual
14882>>>>>>>>>>>    // window control. These should only be used to synchronize the window
14882>>>>>>>>>>>    // control and the DF side. Do not use for any other purpose.
14882>>>>>>>>>>>    Procedure Set ControlValue String sVal
14884>>>>>>>>>>>    End_Procedure
14885>>>>>>>>>>>    
14885>>>>>>>>>>>    Function ControlValue Returns String
14887>>>>>>>>>>>    End_Function
14888>>>>>>>>>>>    
14888>>>>>>>>>>>    Procedure OnCreate
14890>>>>>>>>>>>        // if we are binding value to comValue, do so upon creation
14890>>>>>>>>>>>        If (pbBindValue(Self)) ;            Set ControlValue to (Value(Self))
14893>>>>>>>>>>>        Forward Send OnCreate
14895>>>>>>>>>>>    End_Procedure
14896>>>>>>>>>>>    
14896>>>>>>>>>>>    // Notification that the control's value has been changed
14896>>>>>>>>>>>    // externally by the program (via set value). Use to synchronize
14896>>>>>>>>>>>    // OCX control value.
14896>>>>>>>>>>>    Procedure OnRefreshControl String sVal
14898>>>>>>>>>>>        Boolean bOld
14898>>>>>>>>>>>        If (pbBindValue(Self) and pbPrivateControlChanging(Self)=0 and IsComObjectCreated(Self)) Begin
14900>>>>>>>>>>>            Get pbPrivateControlRefresh to bOld
14901>>>>>>>>>>>            Set pbPrivateControlRefresh to True
14902>>>>>>>>>>>            Set ControlValue to sval
14903>>>>>>>>>>>            Set pbPrivateControlRefresh to bOld
14904>>>>>>>>>>>        End
14904>>>>>>>>>>>>
14904>>>>>>>>>>>    End_Procedure
14905>>>>>>>>>>>    
14905>>>>>>>>>>>    // notification that the control has changed its value. Used to
14905>>>>>>>>>>>    // synchronize the object with the change.
14905>>>>>>>>>>>    Procedure OnControlValueChanged
14907>>>>>>>>>>>        String sVal
14907>>>>>>>>>>>        Boolean bOld
14907>>>>>>>>>>>        If (pbBindValue(Self) and pbPrivateControlRefresh(Self)=0) Begin
14909>>>>>>>>>>>            Get pbPrivateControlChanging to bOld
14910>>>>>>>>>>>            Set pbPrivateControlChanging to True
14911>>>>>>>>>>>            Get ControlValue to sVal
14912>>>>>>>>>>>            Set Value to sVal
14913>>>>>>>>>>>            Set Item_Changed_State 0 to True
14914>>>>>>>>>>>            Set pbPrivateControlChanging to bOld
14915>>>>>>>>>>>        End
14915>>>>>>>>>>>>
14915>>>>>>>>>>>    End_Procedure
14916>>>>>>>>>>>    
14916>>>>>>>>>>>    Procedure Delete_Data
14918>>>>>>>>>>>        Forward Send Delete_Data
14920>>>>>>>>>>>        Set Value to ''
14921>>>>>>>>>>>        Set Changed_state to False
14922>>>>>>>>>>>        Set Item_changed_state 0 to False
14923>>>>>>>>>>>    End_Procedure
14924>>>>>>>>>>>
14924>>>>>>>>>>>
14924>>>>>>>>>>>End_Class
14925>>>>>>>>>>>
14925>>>>>>>>>>>
14925>>>>>>>>>
14925>>>>>>>>>// Changes to Imported package
14925>>>>>>>>>//     OLEXTPxx to XTPxx
14925>>>>>>>>>//     OLExtpxx to xtpxx
14925>>>>>>>>>//     OLESkinFramework to SkinFramework
14925>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
14925>>>>>>>>>//     cCom classes to cCJ
14925>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
14925>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
14925>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
14925>>>>>>>>>//     Use statements as noted below (classes moved to these files)
14925>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
14925>>>>>>>>>
14925>>>>>>>>>// These have been extracted from this class and moved into seperate packages
14925>>>>>>>>>// because other Codejock classes use these.
14925>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
Including file: cCJColorManager.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJColorManager.pkg)
14925>>>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v18.3.0\Bin\Codejock.CommandBars.v18.3.0.ocx
14925>>>>>>>>>>>Use FlexCom20.pkg
14925>>>>>>>>>>>
14925>>>>>>>>>>>Define XTPColorManagerColor for Integer
14925>>>>>>>>>>>    Define STDCOLOR_BACKGROUND for 1
14925>>>>>>>>>>>    Define STDCOLOR_ACTIVECAPTION for 2
14925>>>>>>>>>>>    Define STDCOLOR_INACTIVECAPTION for 3
14925>>>>>>>>>>>    Define STDCOLOR_MENU for 4
14925>>>>>>>>>>>    Define STDCOLOR_WINDOW for 5
14925>>>>>>>>>>>    Define STDCOLOR_WINDOWFRAME for 6
14925>>>>>>>>>>>    Define STDCOLOR_MENUTEXT for 7
14925>>>>>>>>>>>    Define STDCOLOR_WINDOWTEXT for 8
14925>>>>>>>>>>>    Define STDCOLOR_CAPTIONTEXT for 9
14925>>>>>>>>>>>    Define STDCOLOR_ACTIVEBORDER for 10
14925>>>>>>>>>>>    Define STDCOLOR_INACTIVEBORDER for 11
14925>>>>>>>>>>>    Define STDCOLOR_APPWORKSPACE for 12
14925>>>>>>>>>>>    Define STDCOLOR_HIGHLIGHT for 13
14925>>>>>>>>>>>    Define STDCOLOR_HIGHLIGHTTEXT for 14
14925>>>>>>>>>>>    Define STDCOLOR_BTNFACE for 15
14925>>>>>>>>>>>    Define STDCOLOR_BTNSHADOW for 16
14925>>>>>>>>>>>    Define STDCOLOR_GRAYTEXT for 17
14925>>>>>>>>>>>    Define STDCOLOR_BTNTEXT for 18
14925>>>>>>>>>>>    Define STDCOLOR_INACTIVECAPTIONTEXT for 19
14925>>>>>>>>>>>    Define STDCOLOR_BTNHIGHLIGHT for 20
14925>>>>>>>>>>>    Define STDCOLOR_3DDKSHADOW for 21
14925>>>>>>>>>>>    Define STDCOLOR_3DLIGHT for 22
14925>>>>>>>>>>>    Define STDCOLOR_INFOTEXT for 23
14925>>>>>>>>>>>    Define STDCOLOR_INFOBK for 24
14925>>>>>>>>>>>    Define STDCOLOR_HOTLIGHT for 26
14925>>>>>>>>>>>    Define STDCOLOR_GRADIENTACTIVECAPTION for 27
14925>>>>>>>>>>>    Define STDCOLOR_GRADIENTINACTIVECAPTION for 28
14925>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_FACE for 30
14925>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT for 31
14925>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_BORDER for 32
14925>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_PUSHED for 33
14925>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_CHECKED for 36
14925>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_CHECKED_BORDER for 37
14925>>>>>>>>>>>    Define XPCOLOR_ICONSHADDOW for 34
14925>>>>>>>>>>>    Define XPCOLOR_GRAYTEXT for 35
14925>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_GRIPPER for 38
14925>>>>>>>>>>>    Define XPCOLOR_SEPARATOR for 39
14925>>>>>>>>>>>    Define XPCOLOR_DISABLED for 40
14925>>>>>>>>>>>    Define XPCOLOR_MENUBAR_FACE for 41
14925>>>>>>>>>>>    Define XPCOLOR_MENUBAR_EXPANDED for 42
14925>>>>>>>>>>>    Define XPCOLOR_MENUBAR_BORDER for 43
14925>>>>>>>>>>>    Define XPCOLOR_MENUBAR_TEXT for 44
14925>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_TEXT for 45
14925>>>>>>>>>>>    Define XPCOLOR_TOOLBAR_TEXT for 46
14925>>>>>>>>>>>    Define XPCOLOR_PUSHED_TEXT for 47
14925>>>>>>>>>>>    Define XPCOLOR_TAB_INACTIVE_BACK for 48
14925>>>>>>>>>>>    Define XPCOLOR_TAB_INACTIVE_TEXT for 49
14925>>>>>>>>>>>    Define XPCOLOR_HIGHLIGHT_PUSHED_BORDER for 50
14925>>>>>>>>>>>    Define XPCOLOR_3DFACE for 51
14925>>>>>>>>>>>    Define XPCOLOR_3DSHADOW for 52
14925>>>>>>>>>>>    Define XPCOLOR_FRAME for 54
14925>>>>>>>>>>>    Define XPCOLOR_SPLITTER_FACE for 55
14925>>>>>>>>>>>    Define XPCOLOR_LABEL for 56
14925>>>>>>>>>>>    Define XPCOLOR_STATICFRAME for 57
14925>>>>>>>>>>>
14925>>>>>>>>>>>Define XTPCurrentSystemTheme for Integer
14925>>>>>>>>>>>    // No known theme in use
14925>>>>>>>>>>>    Define xtpSystemThemeUnknown for 0
14925>>>>>>>>>>>    // Blue theme in use
14925>>>>>>>>>>>    Define xtpSystemThemeBlue for 1
14925>>>>>>>>>>>    // Olive theme in use
14925>>>>>>>>>>>    Define xtpSystemThemeOlive for 2
14925>>>>>>>>>>>    // Silver theme in use
14925>>>>>>>>>>>    Define xtpSystemThemeSilver for 3
14925>>>>>>>>>>>    // Silver theme in use
14925>>>>>>>>>>>    Define xtpSystemThemeRoyale for 4
14925>>>>>>>>>>>    // Silver theme in use
14925>>>>>>>>>>>    Define xtpSystemThemeAero for 5
14925>>>>>>>>>>>    // Use OS theme.
14925>>>>>>>>>>>    Define xtpSystemThemeAuto for 6
14925>>>>>>>>>>>
14925>>>>>>>>>>>
14925>>>>>>>>>>>// CLSID: {C0DE1830-DE43-4B56-BCEB-E14B825CF245}
14925>>>>>>>>>>>Class cCJIColorManager is a Mixin
14926>>>>>>>>>>>
14926>>>>>>>>>>>    Function ComSystemTheme Returns XTPCurrentSystemTheme
14928>>>>>>>>>>>        XTPCurrentSystemTheme retVal
14928>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_I4 to retVal
14929>>>>>>>>>>>        Function_Return retVal
14930>>>>>>>>>>>    End_Function
14931>>>>>>>>>>>
14931>>>>>>>>>>>    Procedure Set ComSystemTheme XTPCurrentSystemTheme value
14933>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_I4 to value
14934>>>>>>>>>>>    End_Procedure
14935>>>>>>>>>>>
14935>>>>>>>>>>>    Function ComEnableLunaBlueForRoyaleTheme Returns Boolean
14937>>>>>>>>>>>        Boolean retVal
14937>>>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 4 OLE_VT_BOOL to retVal
14938>>>>>>>>>>>        Function_Return retVal
14939>>>>>>>>>>>    End_Function
14940>>>>>>>>>>>
14940>>>>>>>>>>>    Procedure Set ComEnableLunaBlueForRoyaleTheme Boolean value
14942>>>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 4 OLE_VT_BOOL to value
14943>>>>>>>>>>>    End_Procedure
14944>>>>>>>>>>>
14944>>>>>>>>>>>    Function ComColor XTPColorManagerColor llIndex Returns OLE_COLOR
14946>>>>>>>>>>>        Handle hDispatchDriver
14946>>>>>>>>>>>        OLE_COLOR retVal
14946>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
14947>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
14948>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
14949>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_I4 to retVal
14950>>>>>>>>>>>        Function_Return retVal
14951>>>>>>>>>>>    End_Function
14952>>>>>>>>>>>
14952>>>>>>>>>>>    Procedure ComSetColor XTPColorManagerColor llIndex OLE_COLOR llColor
14954>>>>>>>>>>>        Handle hDispatchDriver
14954>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
14955>>>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
14956>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
14957>>>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llColor
14958>>>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
14959>>>>>>>>>>>    End_Procedure
14960>>>>>>>>>>>
14960>>>>>>>>>>>    Function ComGetCurrentSystemTheme Returns XTPCurrentSystemTheme
14962>>>>>>>>>>>        Handle hDispatchDriver
14962>>>>>>>>>>>        XTPCurrentSystemTheme retVal
14962>>>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
14963>>>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_I4 to retVal
14964>>>>>>>>>>>        Function_Return retVal
14965>>>>>>>>>>>    End_Function
14966>>>>>>>>>>>End_Class
14967>>>>>>>>>>>
14967>>>>>>>>>>>// CoClass
14967>>>>>>>>>>>// CLSID: {C0DE1830-F3FE-46E7-BB64-DB033F439F8B}
14967>>>>>>>>>>>Class cCJColorManager is a cComAutomationObject
14968>>>>>>>>>>>    Import_Class_Protocol cCJIColorManager
14969>>>>>>>>>>>
14969>>>>>>>>>>>    Procedure Construct_Object
14971>>>>>>>>>>>        Forward Send Construct_Object
14973>>>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
14974>>>>>>>>>>>    End_Procedure
14975>>>>>>>>>>>End_Class
14976>>>>>>>>>>>
14976>>>>>>>>>
14976>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
14976>>>>>>>>>    Define xtpSkinApplyMetrics for 1
14976>>>>>>>>>    Define xtpSkinApplyFrame for 2
14976>>>>>>>>>    Define xtpSkinApplyColors for 4
14976>>>>>>>>>    Define xtpSkinApplyMenus for 8
14976>>>>>>>>>
14976>>>>>>>>>// CLSID: {C0DE1830-28D7-4F2C-87A7-7266367B4655}
14976>>>>>>>>>// Dispatch interface for SkinFramework Control
14976>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
14977>>>>>>>>>
14977>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
14979>>>>>>>>>        SkinFrameworkApplyOptions retVal
14979>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
14980>>>>>>>>>        Function_Return retVal
14981>>>>>>>>>    End_Function
14982>>>>>>>>>
14982>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
14984>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
14985>>>>>>>>>    End_Procedure
14986>>>>>>>>>
14986>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
14988>>>>>>>>>        Boolean retVal
14988>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
14989>>>>>>>>>        Function_Return retVal
14990>>>>>>>>>    End_Function
14991>>>>>>>>>
14991>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
14993>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
14994>>>>>>>>>    End_Procedure
14995>>>>>>>>>
14995>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
14997>>>>>>>>>        Boolean retVal
14997>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
14998>>>>>>>>>        Function_Return retVal
14999>>>>>>>>>    End_Function
15000>>>>>>>>>
15000>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
15002>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
15003>>>>>>>>>    End_Procedure
15004>>>>>>>>>
15004>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
15006>>>>>>>>>        Handle hDispatchDriver
15006>>>>>>>>>        Boolean retVal
15006>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15007>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
15008>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
15009>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
15010>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
15011>>>>>>>>>        Function_Return retVal
15012>>>>>>>>>    End_Function
15013>>>>>>>>>
15013>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
15015>>>>>>>>>        Handle hDispatchDriver
15015>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15016>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15017>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
15018>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
15019>>>>>>>>>    End_Procedure
15020>>>>>>>>>
15020>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
15022>>>>>>>>>        Handle hDispatchDriver
15022>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15023>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
15024>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
15025>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
15026>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
15027>>>>>>>>>    End_Procedure
15028>>>>>>>>>
15028>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
15030>>>>>>>>>        Handle hDispatchDriver
15030>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15031>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15032>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
15033>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
15034>>>>>>>>>    End_Procedure
15035>>>>>>>>>
15035>>>>>>>>>    Procedure ComRemoveAllWindows
15037>>>>>>>>>        Handle hDispatchDriver
15037>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15038>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
15039>>>>>>>>>    End_Procedure
15040>>>>>>>>>
15040>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
15042>>>>>>>>>        Handle hDispatchDriver
15042>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15043>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
15044>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
15045>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
15046>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
15047>>>>>>>>>    End_Procedure
15048>>>>>>>>>
15048>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
15050>>>>>>>>>        Handle hDispatchDriver
15050>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15051>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15052>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
15053>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
15054>>>>>>>>>    End_Procedure
15055>>>>>>>>>
15055>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
15057>>>>>>>>>        Handle hDispatchDriver
15057>>>>>>>>>        Variant retVal
15057>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15058>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
15059>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
15060>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
15061>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
15062>>>>>>>>>        Function_Return retVal
15063>>>>>>>>>    End_Function
15064>>>>>>>>>
15064>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
15066>>>>>>>>>        Handle hDispatchDriver
15066>>>>>>>>>        Variant retVal
15066>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15067>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15068>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
15069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
15070>>>>>>>>>        Function_Return retVal
15071>>>>>>>>>    End_Function
15072>>>>>>>>>
15072>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
15074>>>>>>>>>        Handle hDispatchDriver
15074>>>>>>>>>        OLE_COLOR retVal
15074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15075>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15076>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
15077>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
15078>>>>>>>>>        Function_Return retVal
15079>>>>>>>>>    End_Function
15080>>>>>>>>>
15080>>>>>>>>>    Procedure ComExcludeModule String llModuleName
15082>>>>>>>>>        Handle hDispatchDriver
15082>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15083>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15084>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
15085>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
15086>>>>>>>>>    End_Procedure
15087>>>>>>>>>
15087>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
15089>>>>>>>>>        Handle hDispatchDriver
15089>>>>>>>>>        Variant retVal
15089>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15090>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
15091>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
15092>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
15093>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
15094>>>>>>>>>        Function_Return retVal
15095>>>>>>>>>    End_Function
15096>>>>>>>>>
15096>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
15098>>>>>>>>>        Handle hDispatchDriver
15098>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15099>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
15100>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
15101>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
15102>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
15103>>>>>>>>>    End_Procedure
15104>>>>>>>>>
15104>>>>>>>>>    Procedure ComAboutBox
15106>>>>>>>>>        Handle hDispatchDriver
15106>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15107>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
15108>>>>>>>>>    End_Procedure
15109>>>>>>>>>End_Class
15110>>>>>>>>>
15110>>>>>>>>>// CLSID: {C0DE1830-4463-4030-B324-AC6A8075FEC8}
15110>>>>>>>>>// Event interface for SkinFramework Control
15110>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
15111>>>>>>>>>
15111>>>>>>>>>    Procedure RegisterComEvents
15113>>>>>>>>>    End_Procedure
15114>>>>>>>>>End_Class
15115>>>>>>>>>
15115>>>>>>>>>// CoClass
15115>>>>>>>>>// ProgID: Codejock.SkinFramework.18.3.0
15115>>>>>>>>>// CLSID: {C0DE1830-2217-42EE-B1B0-82C890431F17}
15115>>>>>>>>>// SkinFramework Control
15115>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
15116>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
15117>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
15118>>>>>>>>>
15118>>>>>>>>>    Procedure Construct_Object
15120>>>>>>>>>        Forward Send Construct_Object
15122>>>>>>>>>        Set psProgID to "{C0DE1830-2217-42EE-B1B0-82C890431F17}"
15123>>>>>>>>>        Set psEventId to "{C0DE1830-4463-4030-B324-AC6A8075FEC8}"
15124>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2018 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v18.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
15125>>>>>>>>>        Set peAutoCreate to acAutoCreate
15126>>>>>>>>>    End_Procedure
15127>>>>>>>>>End_Class
15128>>>>>>>>>
15128>>>>>>>>>// CLSID: {C0DE1830-CA9A-4AA9-8601-0AB7F551AA3D}
15128>>>>>>>>>// SkinFramework Global Settings
15128>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
15129>>>>>>>>>
15129>>>>>>>>>    Function ComLicense Returns String
15131>>>>>>>>>        String retVal
15131>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
15132>>>>>>>>>        Function_Return retVal
15133>>>>>>>>>    End_Function
15134>>>>>>>>>
15134>>>>>>>>>    Procedure Set ComLicense String value
15136>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
15137>>>>>>>>>    End_Procedure
15138>>>>>>>>>
15138>>>>>>>>>    Function ComTitle Returns String
15140>>>>>>>>>        String retVal
15140>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
15141>>>>>>>>>        Function_Return retVal
15142>>>>>>>>>    End_Function
15143>>>>>>>>>
15143>>>>>>>>>    Procedure Set ComTitle String value
15145>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
15146>>>>>>>>>    End_Procedure
15147>>>>>>>>>
15147>>>>>>>>>    Function ComVersion Returns String
15149>>>>>>>>>        Handle hDispatchDriver
15149>>>>>>>>>        String retVal
15149>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15150>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
15151>>>>>>>>>        Function_Return retVal
15152>>>>>>>>>    End_Function
15153>>>>>>>>>
15153>>>>>>>>>    Function ComUnicode Returns Boolean
15155>>>>>>>>>        Handle hDispatchDriver
15155>>>>>>>>>        Boolean retVal
15155>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15156>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
15157>>>>>>>>>        Function_Return retVal
15158>>>>>>>>>    End_Function
15159>>>>>>>>>
15159>>>>>>>>>    Function ComOcxPath Returns String
15161>>>>>>>>>        Handle hDispatchDriver
15161>>>>>>>>>        String retVal
15161>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15162>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
15163>>>>>>>>>        Function_Return retVal
15164>>>>>>>>>    End_Function
15165>>>>>>>>>End_Class
15166>>>>>>>>>
15166>>>>>>>>>// CoClass
15166>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.18.3.0
15166>>>>>>>>>// CLSID: {C0DE1830-F744-4373-B38D-29CE83EF0EE5}
15166>>>>>>>>>// SkinFramework Global Settings
15166>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
15167>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
15168>>>>>>>>>
15168>>>>>>>>>    Procedure Construct_Object
15170>>>>>>>>>        Forward Send Construct_Object
15172>>>>>>>>>        Set psProgID to "{C0DE1830-F744-4373-B38D-29CE83EF0EE5}"
15173>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
15174>>>>>>>>>    End_Procedure
15175>>>>>>>>>End_Class
15176>>>>>>>>>
15176>>>>>>>>>// CLSID: {C0DE1830-1038-498E-A936-361F08B4C4AA}
15176>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
15177>>>>>>>>>
15177>>>>>>>>>    Function ComColorScheme Returns String
15179>>>>>>>>>        String retVal
15179>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
15180>>>>>>>>>        Function_Return retVal
15181>>>>>>>>>    End_Function
15182>>>>>>>>>
15182>>>>>>>>>    Procedure Set ComColorScheme String value
15184>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
15185>>>>>>>>>    End_Procedure
15186>>>>>>>>>
15186>>>>>>>>>    Function ComFontSize Returns String
15188>>>>>>>>>        String retVal
15188>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
15189>>>>>>>>>        Function_Return retVal
15190>>>>>>>>>    End_Function
15191>>>>>>>>>
15191>>>>>>>>>    Procedure Set ComFontSize String value
15193>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
15194>>>>>>>>>    End_Procedure
15195>>>>>>>>>
15195>>>>>>>>>    Function ComIniFileName Returns String
15197>>>>>>>>>        String retVal
15197>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
15198>>>>>>>>>        Function_Return retVal
15199>>>>>>>>>    End_Function
15200>>>>>>>>>
15200>>>>>>>>>    Procedure Set ComIniFileName String value
15202>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
15203>>>>>>>>>    End_Procedure
15204>>>>>>>>>End_Class
15205>>>>>>>>>
15205>>>>>>>>>// CLSID: {C0DE1830-4834-499E-95B4-30E0C3F43A10}
15205>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
15206>>>>>>>>>
15206>>>>>>>>>    Function ComName Returns String
15208>>>>>>>>>        String retVal
15208>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
15209>>>>>>>>>        Function_Return retVal
15210>>>>>>>>>    End_Function
15211>>>>>>>>>
15211>>>>>>>>>    Procedure Set ComName String value
15213>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
15214>>>>>>>>>    End_Procedure
15215>>>>>>>>>
15215>>>>>>>>>    Function ComPath Returns String
15217>>>>>>>>>        String retVal
15217>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
15218>>>>>>>>>        Function_Return retVal
15219>>>>>>>>>    End_Function
15220>>>>>>>>>
15220>>>>>>>>>    Procedure Set ComPath String value
15222>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
15223>>>>>>>>>    End_Procedure
15224>>>>>>>>>
15224>>>>>>>>>    Function ComCount Returns Integer
15226>>>>>>>>>        Handle hDispatchDriver
15226>>>>>>>>>        Integer retVal
15226>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15227>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
15228>>>>>>>>>        Function_Return retVal
15229>>>>>>>>>    End_Function
15230>>>>>>>>>
15230>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
15232>>>>>>>>>        Handle hDispatchDriver
15232>>>>>>>>>        Variant retVal
15232>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15233>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15234>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
15235>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
15236>>>>>>>>>        Function_Return retVal
15237>>>>>>>>>    End_Function
15238>>>>>>>>>
15238>>>>>>>>>    Function Com_NewEnum Returns Variant
15240>>>>>>>>>        Handle hDispatchDriver
15240>>>>>>>>>        Variant retVal
15240>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15241>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
15242>>>>>>>>>        Function_Return retVal
15243>>>>>>>>>    End_Function
15244>>>>>>>>>End_Class
15245>>>>>>>>>
15245>>>>>>>>>// CLSID: {C0DE1830-FB37-4B08-A2B9-F6F8B253D697}
15245>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
15246>>>>>>>>>
15246>>>>>>>>>    Function ComCount Returns Integer
15248>>>>>>>>>        Handle hDispatchDriver
15248>>>>>>>>>        Integer retVal
15248>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15249>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
15250>>>>>>>>>        Function_Return retVal
15251>>>>>>>>>    End_Function
15252>>>>>>>>>
15252>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
15254>>>>>>>>>        Handle hDispatchDriver
15254>>>>>>>>>        Variant retVal
15254>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15255>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15256>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
15257>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
15258>>>>>>>>>        Function_Return retVal
15259>>>>>>>>>    End_Function
15260>>>>>>>>>
15260>>>>>>>>>    Function Com_NewEnum Returns Variant
15262>>>>>>>>>        Handle hDispatchDriver
15262>>>>>>>>>        Variant retVal
15262>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15263>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
15264>>>>>>>>>        Function_Return retVal
15265>>>>>>>>>    End_Function
15266>>>>>>>>>End_Class
15267>>>>>>>>>
15267>>>>>>>>>// CLSID: {C0DE1830-C56F-43C0-BCF1-8193B35FE4C4}
15267>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
15268>>>>>>>>>
15268>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
15270>>>>>>>>>        Handle hDispatchDriver
15270>>>>>>>>>        OLE_COLOR retVal
15270>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
15271>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
15272>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
15273>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
15274>>>>>>>>>        Function_Return retVal
15275>>>>>>>>>    End_Function
15276>>>>>>>>>End_Class
15277>>>>>>>Use cApplication.pkg
15277>>>>>>>
15277>>>>>>>Struct tSkinInformation
15277>>>>>>>    String sName     // description of the skin
15277>>>>>>>    String sSkinfile // file path. Can be relative or full
15277>>>>>>>    String sSkinIni  // section name
15277>>>>>>>End_Struct
15277>>>>>>>
15277>>>>>>>
15277>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
15278>>>>>>>    
15278>>>>>>>    Procedure Construct_Object
15280>>>>>>>        Forward Send Construct_Object
15282>>>>>>>        
15282>>>>>>>        Property String psSkinFile ""
15283>>>>>>>        Property String psSkinIni ""
15284>>>>>>>        Property Boolean pbLoadPreference False
15285>>>>>>>        
15285>>>>>>>        Set peAutoCreate to acAutoCreate
15286>>>>>>>        
15286>>>>>>>        Move Self to ghoSkinFramework
15287>>>>>>>    End_Procedure
15288>>>>>>>    
15288>>>>>>>    // return the default skin path, which is the programs directory.
15288>>>>>>>    // This requires an application object.
15288>>>>>>>    // If you want to different skin path, override this.
15288>>>>>>>    Function SkinPath Returns String
15290>>>>>>>        String sPath sPaths
15290>>>>>>>        Handle hoWorkspace
15290>>>>>>>        If ghoApplication Begin
15292>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
15293>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
15294>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
15295>>>>>>>        End
15295>>>>>>>>
15295>>>>>>>        Else Begin
15296>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
15297>>>>>>>>
15297>>>>>>>        End
15297>>>>>>>>
15297>>>>>>>        Function_Return sPath
15298>>>>>>>    End_Function
15299>>>>>>>    
15299>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
15299>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
15299>>>>>>>    Function SkinQFile Returns String
15301>>>>>>>        String sFile sPath sSep
15301>>>>>>>        Boolean bQualified
15301>>>>>>>        Get psSkinFile to sFile
15302>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
15304>>>>>>>            Get SkinPath to sPath
15305>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
15306>>>>>>>            Move (sPath - sSep - sFile) to sFile
15307>>>>>>>        End
15307>>>>>>>>
15307>>>>>>>        Function_Return sFile
15308>>>>>>>    End_Function
15309>>>>>>>    
15309>>>>>>>    // defines the default VDF window class mapping.
15309>>>>>>>    Procedure OnAddVDFWindowClasses
15311>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
15312>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
15313>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
15314>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
15315>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
15316>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
15317>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
15318>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
15319>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
15320>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
15321>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
15322>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
15323>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
15324>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
15325>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
15326>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
15327>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
15328>>>>>>>        // External class
15328>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
15329>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
15330>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
15331>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
15332>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
15333>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
15334>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
15335>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
15336>>>>>>>    End_Procedure
15337>>>>>>>    
15337>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
15337>>>>>>>    Procedure OnAddCustomWindowClasses
15339>>>>>>>    End_Procedure
15340>>>>>>>    
15340>>>>>>>    // called when object is created during end_construct_object.
15340>>>>>>>    Procedure OnCreate
15342>>>>>>>        Integer iOpts
15342>>>>>>>        Boolean bUseWindowsFont
15342>>>>>>>        Forward Send OnCreate
15344>>>>>>>        
15344>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
15344>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
15344>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
15345>>>>>>>        If bUseWindowsFont Begin
15347>>>>>>>            Get ComApplyOptions to iOpts
15348>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
15349>>>>>>>        End
15349>>>>>>>>
15349>>>>>>>        
15349>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
15349>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
15349>>>>>>>        // and this was the suggested workaround.
15349>>>>>>>        Set ComAutoApplyNewThreads to False
15350>>>>>>>        
15350>>>>>>>        Send OnAddVDFWindowClasses
15351>>>>>>>        Send OnAddCustomWindowClasses
15352>>>>>>>        
15352>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
15352>>>>>>>        If (pbLoadPreference(Self)) Begin
15354>>>>>>>            Send LoadSkinPreference
15355>>>>>>>        End
15355>>>>>>>>
15355>>>>>>>        // if a skin file name exists, we apply the skin.
15355>>>>>>>        If (psSkinFile(Self)<>"") Begin
15357>>>>>>>            Send ApplySkin
15358>>>>>>>        End
15358>>>>>>>>
15358>>>>>>>    End_Procedure
15359>>>>>>>    
15359>>>>>>>    // called by framework as part of application exit.
15359>>>>>>>    Procedure Broadcast_Notify_Exit_Application
15361>>>>>>>        Send Notify_Exit_Application
15362>>>>>>>    End_Procedure
15363>>>>>>>    
15363>>>>>>>    Procedure Notify_Exit_Application
15365>>>>>>>        If (pbLoadPreference(Self)) Begin
15367>>>>>>>            Send SaveSkinPreference
15368>>>>>>>        End
15368>>>>>>>>
15368>>>>>>>    End_Procedure
15369>>>>>>>    
15369>>>>>>>    Procedure NotifyPreApplySkin
15371>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
15373>>>>>>>    End_Procedure
15374>>>>>>>    
15374>>>>>>>    Procedure NotifyPostApplySkin
15376>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
15378>>>>>>>    End_Procedure
15379>>>>>>>    
15379>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
15379>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
15379>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
15381>>>>>>>        tSkinInformation[] Skins
15381>>>>>>>        tSkinInformation[] Skins
15382>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
15382>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
15382>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
15382>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
15382>>>>>>>        Integer iPos iDfltLen
15382>>>>>>>        Boolean bUseRelativePath
15382>>>>>>>        
15382>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
15383>>>>>>>        
15383>>>>>>>        Get SkinPath to sDefaultPath
15384>>>>>>>        If (sPath="") Begin
15386>>>>>>>            Move sDefaultPath to sPath
15387>>>>>>>        End
15387>>>>>>>>
15387>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
15388>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
15389>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
15390>>>>>>>        
15390>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
15391>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
15393>>>>>>>            
15393>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
15394>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
15395>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
15396>>>>>>>            
15396>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
15397>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
15398>>>>>>>            
15398>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
15404>>>>>>>>
15404>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
15405>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
15406>>>>>>>                
15406>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
15407>>>>>>>                
15407>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
15413>>>>>>>>
15413>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
15414>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
15415>>>>>>>                    
15415>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
15416>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
15417>>>>>>>                    If bUseRelativePath Begin
15419>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
15420>>>>>>>                        If iPos Begin
15422>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
15423>>>>>>>                            While (Left(sSkinFile,1)=sSep)
15427>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
15428>>>>>>>                            Loop
15429>>>>>>>>
15429>>>>>>>                        End
15429>>>>>>>>
15429>>>>>>>                    End
15429>>>>>>>>
15429>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
15430>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
15431>>>>>>>                    
15431>>>>>>>                    Increment iArrayItem
15432>>>>>>>                Loop
15433>>>>>>>>
15433>>>>>>>            Loop
15434>>>>>>>>
15434>>>>>>>            
15434>>>>>>>            Send Destroy of hSkinDescriptions
15435>>>>>>>            Send Destroy of hSkinDescription
15436>>>>>>>            Send Destroy of hSkinIniFile
15437>>>>>>>            
15437>>>>>>>        End
15437>>>>>>>>
15437>>>>>>>        Function_Return Skins
15438>>>>>>>    End_Function
15439>>>>>>>    
15439>>>>>>>    // Save the skin preference. This requires an application object.
15439>>>>>>>    // Only do this if the application object allows it.
15439>>>>>>>    // This is called during startup if pbLoadPreference is True
15439>>>>>>>    // Suitable for override
15439>>>>>>>    Procedure SaveSkinPreference
15441>>>>>>>        String sSkin sIni
15441>>>>>>>        If ghoApplication Begin
15443>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
15445>>>>>>>                Get psSkinFile to sSkin
15446>>>>>>>                Get psSkinIni to sIni
15447>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
15448>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
15449>>>>>>>            End
15449>>>>>>>>
15449>>>>>>>        End
15449>>>>>>>>
15449>>>>>>>        Else Begin
15450>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
15451>>>>>>>>
15451>>>>>>>        End
15451>>>>>>>>
15451>>>>>>>    End_Procedure
15452>>>>>>>    
15452>>>>>>>    // Load the skin preference. This requires an application object.
15452>>>>>>>    // Only do this if the application object allows it.
15452>>>>>>>    // This is called during startup if pbLoadPreference is True
15452>>>>>>>    // Suitable for override
15452>>>>>>>    Procedure LoadSkinPreference
15454>>>>>>>        String sSkin sIni
15454>>>>>>>        Boolean bExists
15454>>>>>>>        If ghoApplication Begin
15456>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
15458>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
15459>>>>>>>                If bExists Begin
15461>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
15462>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
15463>>>>>>>                    Set psSkinFile to sSkin
15464>>>>>>>                    Set psSkinIni to sIni
15465>>>>>>>                End
15465>>>>>>>>
15465>>>>>>>            End
15465>>>>>>>>
15465>>>>>>>        End
15465>>>>>>>>
15465>>>>>>>        Else Begin
15466>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
15467>>>>>>>>
15467>>>>>>>        End
15467>>>>>>>>
15467>>>>>>>    End_Procedure
15468>>>>>>>    
15468>>>>>>>    // Can be called to apply the current skin.
15468>>>>>>>    Procedure ApplySkin
15470>>>>>>>        Boolean bOk
15470>>>>>>>        String sSkin sIni
15470>>>>>>>        If (IsComObjectCreated(Self)) Begin
15472>>>>>>>            Get SkinQFile to sSkin
15473>>>>>>>            Get psSkinIni to sIni
15474>>>>>>>            
15474>>>>>>>            Send NotifyPreApplySkin
15475>>>>>>>            // when skins are used we don't want to use built in Visual Styles
15475>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
15476>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
15477>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
15479>>>>>>>                // if not ok, no skin was appied. Enable visual styles
15479>>>>>>>                Send EnableVisualStyles of Desktop True
15480>>>>>>>            End
15480>>>>>>>>
15480>>>>>>>            Send NotifyPostApplySkin
15481>>>>>>>        End
15481>>>>>>>>
15481>>>>>>>    End_Procedure
15482>>>>>>>    
15482>>>>>>>    
15482>>>>>>>End_Class
15483>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cProgressBar.pkg)
15483>>>>>>>Use Windows.pkg
15483>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWinControl.pkg)
15483>>>>>>>>>Use Windows.pkg
15483>>>>>>>>>
15483>>>>>>>>>// Key State Masks for Mouse Messages
15483>>>>>>>>>
15483>>>>>>>>>Define MK_LBUTTON  for |CI$0001
15483>>>>>>>>>Define MK_RBUTTON  for |CI$0002
15483>>>>>>>>>Define MK_SHIFT    for |CI$0004
15483>>>>>>>>>Define MK_CONTROL  for |CI$0008
15483>>>>>>>>>Define MK_MBUTTON  for |CI$0010
15483>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
15483>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
15483>>>>>>>>>
15483>>>>>>>>>Enum_List // Mouse Key Flags
15483>>>>>>>>>    Define mkLeft    for MK_LBUTTON
15483>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
15483>>>>>>>>>    Define mkRight   for MK_RBUTTON
15483>>>>>>>>>    Define mkX1      for MK_XBUTTON1
15483>>>>>>>>>    Define mkX2      for MK_XBUTTON2
15483>>>>>>>>>    Define mkShift   for MK_SHIFT
15483>>>>>>>>>    Define mkControl for MK_CONTROL
15483>>>>>>>>>End_Enum_List
15483>>>>>>>>>
15483>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
15483>>>>>>>>>    Define mbLeft
15483>>>>>>>>>    Define mbMiddle
15483>>>>>>>>>    Define mbRight
15483>>>>>>>>>    Define mbX1
15483>>>>>>>>>    Define mbX2
15483>>>>>>>>>End_Enum_List
15483>>>>>>>>>
15483>>>>>>>>>Class cWinControl is a DfBaseControl
15484>>>>>>>>>    Procedure Construct_Object
15486>>>>>>>>>        Forward Send Construct_Object
15488>>>>>>>>>        Property Integer private_pbEnabled True
15489>>>>>>>>>        Property Integer private_pbVisible True
15490>>>>>>>>>    End_Procedure
15491>>>>>>>>>    
15491>>>>>>>>>    Procedure End_Construct_Object
15493>>>>>>>>>        Forward Send End_Construct_Object
15495>>>>>>>>>        
15495>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
15496>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
15497>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
15498>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
15499>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
15500>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
15501>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
15502>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
15503>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
15504>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
15505>>>>>>>>>    End_Procedure
15506>>>>>>>>>    
15506>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
15508>>>>>>>>>        //Intentionally cancelled
15508>>>>>>>>>    End_Procedure
15509>>>>>>>>>    
15509>>>>>>>>>    Procedure Command Integer wParam Integer lParam
15511>>>>>>>>>        //Intentionally cancelled
15511>>>>>>>>>    End_Procedure
15512>>>>>>>>>    
15512>>>>>>>>>    Procedure DoRecreateWindow
15514>>>>>>>>>        // Recreates the window
15514>>>>>>>>>        If (Window_Handle(Self)) Begin
15516>>>>>>>>>            // attempt to do this without disturbing the focus tree.
15516>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
15517>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
15518>>>>>>>>>        End
15518>>>>>>>>>>
15518>>>>>>>>>    End_Procedure
15519>>>>>>>>>    
15519>>>>>>>>>    Procedure DoUpdateWindow
15521>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
15521>>>>>>>>>        Handle hWnd
15521>>>>>>>>>        
15521>>>>>>>>>        Get Window_Handle to hWnd
15522>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
15525>>>>>>>>>    End_Procedure
15526>>>>>>>>>    
15526>>>>>>>>>    Procedure Page Integer iState
15528>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
15529>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
15530>>>>>>>>>        Forward Send Page iState
15532>>>>>>>>>    End_Procedure
15533>>>>>>>>>    
15533>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
15535>>>>>>>>>        Integer x y eButton
15535>>>>>>>>>        
15535>>>>>>>>>        Move (Hi(lParam))  to y
15536>>>>>>>>>        Move (Low(lParam)) to x
15537>>>>>>>>>        
15537>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
15538>>>>>>>>>    End_Procedure
15539>>>>>>>>>    
15539>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
15541>>>>>>>>>        Integer x y eButton
15541>>>>>>>>>        
15541>>>>>>>>>        Move (Hi(lParam))  to y
15542>>>>>>>>>        Move (Low(lParam)) to x
15543>>>>>>>>>        
15543>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
15544>>>>>>>>>    End_Procedure
15545>>>>>>>>>    
15545>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
15547>>>>>>>>>        Integer x y eButton
15547>>>>>>>>>        
15547>>>>>>>>>        Move (Hi(lParam))  to y
15548>>>>>>>>>        Move (Low(lParam)) to x
15549>>>>>>>>>        
15549>>>>>>>>>        Send OnMouseUp mbRight x y wParam
15550>>>>>>>>>    End_Procedure
15551>>>>>>>>>    
15551>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
15553>>>>>>>>>        Integer x y eButton fKeys
15553>>>>>>>>>        
15553>>>>>>>>>        Move (Hi(lParam))  to y
15554>>>>>>>>>        Move (Low(lParam)) to x
15555>>>>>>>>>        
15555>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
15556>>>>>>>>>    End_Procedure
15557>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
15559>>>>>>>>>        Integer x y eButton
15559>>>>>>>>>        
15559>>>>>>>>>        Move (Hi(lParam))  to y
15560>>>>>>>>>        Move (Low(lParam)) to x
15561>>>>>>>>>        
15561>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
15562>>>>>>>>>    End_Procedure
15563>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
15565>>>>>>>>>        Integer x y eButton
15565>>>>>>>>>        
15565>>>>>>>>>        Move (Hi(lParam))  to y
15566>>>>>>>>>        Move (Low(lParam)) to x
15567>>>>>>>>>        
15567>>>>>>>>>        Send OnMouseDown mbRight x y wParam
15568>>>>>>>>>    End_Procedure
15569>>>>>>>>>    
15569>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
15571>>>>>>>>>        Integer x y eButton
15571>>>>>>>>>        
15571>>>>>>>>>        Move (Hi(lParam))  to y
15572>>>>>>>>>        Move (Low(lParam)) to x
15573>>>>>>>>>        
15573>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
15574>>>>>>>>>    End_Procedure
15575>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
15577>>>>>>>>>        Integer x y eButton
15577>>>>>>>>>        
15577>>>>>>>>>        Move (Hi(lParam))  to y
15578>>>>>>>>>        Move (Low(lParam)) to x
15579>>>>>>>>>        
15579>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
15580>>>>>>>>>    End_Procedure
15581>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
15583>>>>>>>>>        Integer x y eButton
15583>>>>>>>>>        
15583>>>>>>>>>        Move (Hi(lParam))  to y
15584>>>>>>>>>        Move (Low(lParam)) to x
15585>>>>>>>>>        
15585>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
15586>>>>>>>>>    End_Procedure
15587>>>>>>>>>    
15587>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
15589>>>>>>>>>        Integer x y eButton
15589>>>>>>>>>        
15589>>>>>>>>>        Move (Hi(lParam))  to y
15590>>>>>>>>>        Move (Low(lParam)) to x
15591>>>>>>>>>        
15591>>>>>>>>>        Send OnMouseMove x y wParam
15592>>>>>>>>>    End_Procedure
15593>>>>>>>>>    
15593>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
15595>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
15595>>>>>>>>>        //String sButton
15595>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
15595>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
15595>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
15595>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
15595>>>>>>>>>        
15595>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
15595>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
15595>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
15595>>>>>>>>>    End_Procedure
15596>>>>>>>>>    
15596>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
15598>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
15598>>>>>>>>>        //String sButton
15598>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
15598>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
15598>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
15598>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
15598>>>>>>>>>        
15598>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
15598>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
15598>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
15598>>>>>>>>>    End_Procedure
15599>>>>>>>>>    
15599>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
15601>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
15601>>>>>>>>>        //String sButton
15601>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
15601>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
15601>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
15601>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
15601>>>>>>>>>        
15601>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
15601>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
15601>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
15601>>>>>>>>>    End_Procedure
15602>>>>>>>>>    
15602>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
15604>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
15604>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
15604>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
15604>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
15604>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
15604>>>>>>>>>        
15604>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
15604>>>>>>>>>    End_Procedure
15605>>>>>>>>>    
15605>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
15607>>>>>>>>>        Handle hWnd
15607>>>>>>>>>        
15607>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
15609>>>>>>>>>            Set private_pbEnabled to bEnabled
15610>>>>>>>>>            Get Window_Handle to hWnd
15611>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
15614>>>>>>>>>        End
15614>>>>>>>>>>
15614>>>>>>>>>    End_Procedure
15615>>>>>>>>>    Function pbEnabled Returns Boolean
15617>>>>>>>>>        Function_Return (private_pbEnabled(Self))
15618>>>>>>>>>    End_Function
15619>>>>>>>>>    
15619>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
15621>>>>>>>>>        Handle  hWnd
15621>>>>>>>>>        Integer iVoid
15621>>>>>>>>>        
15621>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
15623>>>>>>>>>            Set private_pbVisible to bVisible
15624>>>>>>>>>            Get Window_Handle to hWnd
15625>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
15628>>>>>>>>>        End
15628>>>>>>>>>>
15628>>>>>>>>>    End_Procedure
15629>>>>>>>>>    Function pbVisible Returns Boolean
15631>>>>>>>>>        Function_Return (private_pbVisible(Self))
15632>>>>>>>>>    End_Function
15633>>>>>>>>>    
15633>>>>>>>>>End_Class
15634>>>>>>>Use CommCtrl.pkg
15634>>>>>>>
15634>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
15634>>>>>>>Class cProgressBar is a cWinControl
15635>>>>>>>    
15635>>>>>>>    Procedure Construct_Object
15637>>>>>>>        Forward Send Construct_Object
15639>>>>>>>        Property Integer private_piMinimum
15640>>>>>>>        Property Integer private_piMaximum   100
15641>>>>>>>        Property Integer private_piAdvanceBy 10
15642>>>>>>>        Property Integer private_piPosition
15643>>>>>>>        Property Integer private_pbVertical  False
15644>>>>>>>        Property Integer private_pbSmooth    False
15645>>>>>>>        Property Integer private_piBackColor clDefault
15646>>>>>>>        Property Integer private_piBarColor  clDefault
15647>>>>>>>        
15647>>>>>>>        Send Define_ToolTip_Support_Mixin
15648>>>>>>>        
15648>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
15649>>>>>>>        Set Focus_Mode to NonFocusable
15650>>>>>>>        Set Skip_State to True
15651>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
15652>>>>>>>    End_Procedure
15653>>>>>>>    
15653>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
15654>>>>>>>    
15654>>>>>>>    Procedure Set piMinimum Integer iMin
15656>>>>>>>        Integer iMax
15656>>>>>>>        
15656>>>>>>>        Set private_piMinimum to iMin
15657>>>>>>>        Get private_piMaximum to iMax
15658>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
15659>>>>>>>    End_Procedure
15660>>>>>>>    Function piMinimum Returns Integer
15662>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
15665>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
15667>>>>>>>    End_Function
15668>>>>>>>    
15668>>>>>>>    Procedure Set piMaximum Integer iMax
15670>>>>>>>        Integer iMin
15670>>>>>>>        
15670>>>>>>>        Set private_piMaximum to iMax
15671>>>>>>>        Get private_piMinimum to iMin
15672>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
15673>>>>>>>    End_Procedure
15674>>>>>>>    Function piMaximum Returns Integer
15676>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
15679>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
15681>>>>>>>    End_Function
15682>>>>>>>    
15682>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
15684>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
15685>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
15686>>>>>>>    End_Procedure
15687>>>>>>>    Function piAdvanceBy Returns Integer
15689>>>>>>>        Function_Return (private_piAdvanceBy(Self))
15690>>>>>>>    End_Function
15691>>>>>>>    
15691>>>>>>>    Procedure Set piPosition Integer iPos
15693>>>>>>>        Set private_piPosition to iPos
15694>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
15695>>>>>>>    End_Procedure
15696>>>>>>>    
15696>>>>>>>    Function piPosition Returns Integer
15698>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
15701>>>>>>>        Else;            Function_Return (private_piPosition(Self))
15703>>>>>>>    End_Function
15704>>>>>>>    
15704>>>>>>>    Procedure Set pbVertical Boolean bVertical
15706>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
15708>>>>>>>            Set private_pbVertical to bVertical
15709>>>>>>>            Send DoRecreateWindow
15710>>>>>>>        End
15710>>>>>>>>
15710>>>>>>>    End_Procedure
15711>>>>>>>    
15711>>>>>>>    Function pbVertical Returns Boolean
15713>>>>>>>        Function_Return (private_pbVertical(Self))
15714>>>>>>>    End_Function
15715>>>>>>>    
15715>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
15717>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
15719>>>>>>>            Set private_pbSmooth to bSmooth
15720>>>>>>>            Send DoRecreateWindow
15721>>>>>>>        End
15721>>>>>>>>
15721>>>>>>>    End_Procedure
15722>>>>>>>    Function pbSmooth Returns Boolean
15724>>>>>>>        Function_Return (private_pbSmooth(Self))
15725>>>>>>>    End_Function
15726>>>>>>>    
15726>>>>>>>    Procedure Set piBackColor Integer rgbColor
15728>>>>>>>        Set private_piBackColor to rgbColor
15729>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
15730>>>>>>>    End_Procedure
15731>>>>>>>    Function piBackColor Returns Integer
15733>>>>>>>        Function_Return (private_piBackColor(Self))
15734>>>>>>>    End_Function
15735>>>>>>>    
15735>>>>>>>    Procedure Set piBarColor Integer rgbColor
15737>>>>>>>        Set private_piBarColor to rgbColor
15738>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
15739>>>>>>>    End_Procedure
15740>>>>>>>    Function piBarColor Returns Integer
15742>>>>>>>        Function_Return (private_piBarColor(Self))
15743>>>>>>>    End_Function
15744>>>>>>>    
15744>>>>>>>    Procedure DoAdvance
15746>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
15747>>>>>>>    End_Procedure
15748>>>>>>>    
15748>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
15750>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
15751>>>>>>>    End_Procedure
15752>>>>>>>    
15752>>>>>>>    Procedure private_DoInitWindow
15754>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
15755>>>>>>>        Set piBackColor to (private_piBackColor(Self))
15756>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
15757>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
15758>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
15759>>>>>>>        Set piPosition  to (private_piPosition(Self))
15760>>>>>>>    End_Procedure
15761>>>>>>>    
15761>>>>>>>    Procedure Page_Object Integer iState
15763>>>>>>>        Handle hWnd
15763>>>>>>>        
15763>>>>>>>        Get Window_Handle to hWnd
15764>>>>>>>        If (hWnd=0 and iState) Begin
15766>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
15767>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
15768>>>>>>>            Forward Send Page_Object True
15770>>>>>>>        End
15770>>>>>>>>
15770>>>>>>>        Else ;            Forward Send Page_Object iState
15773>>>>>>>        
15773>>>>>>>        // Handle tooltip support....
15773>>>>>>>        If (iState = 0) Begin
15775>>>>>>>            Send RequestDeleteToolTip
15776>>>>>>>        End
15776>>>>>>>>
15776>>>>>>>        Else Begin
15777>>>>>>>            Send RequestAddToolTip
15778>>>>>>>        End
15778>>>>>>>>
15778>>>>>>>    End_Procedure
15779>>>>>>>    
15779>>>>>>>    Procedure Page Integer iState
15781>>>>>>>        Forward Send Page iState
15783>>>>>>>        If (iState =1);            Send private_DoInitWindow
15786>>>>>>>    End_Procedure
15787>>>>>>>    
15787>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
15787>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
15787>>>>>>>    // is implemented in a mixin class.
15787>>>>>>>    Procedure RequestAddToolTip
15789>>>>>>>        Send AddToolTip
15790>>>>>>>    End_Procedure
15791>>>>>>>    
15791>>>>>>>    
15791>>>>>>>    // Called by Page_Object. Handles tooltip removal.
15791>>>>>>>    Procedure RequestDeleteToolTip
15793>>>>>>>        Send DeleteToolTip
15794>>>>>>>    End_Procedure
15795>>>>>>>End_Class
15796>>>>>Use Windows.pkg
15796>>>>>
15796>>>>>    Global_Variable Handle ghoStatusPanel // will contain the ID of the global StatusPanel object
15796>>>>>
15796>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
15796>>>>>
15796>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
15796>>>>>
15796>>>>>Object Status_Panel is a cProcessStatusPanel
15798>>>>>    Set Size to 148 222
15799>>>>>    Set Border_Style to Border_Dialog
15800>>>>>//    Set Sysmenu_Icon to False
15800>>>>>//    Set Icon to "DbUpdateFrameworkdf19.ico" 
15800>>>>>    Set Icon to "Default.ico"
15801>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
15802>>>>>
15802>>>>>    Property Boolean Cancel_Button_Visible_State True
15804>>>>>
15804>>>>>    Procedure Activate
15807>>>>>        Integer iSizeBefore
15807>>>>>        Get GuiSize to iSizeBefore
15808>>>>>        Forward Send Activate
15810>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
15811>>>>>    End_Procedure
15812>>>>>
15812>>>>>    Procedure End_Construct_Object
15815>>>>>        Forward Send End_Construct_Object
15817>>>>>        Set Label of oTitleTxt      to ""
15818>>>>>        Set Label of oTableNameTxt  to ""
15819>>>>>        Set Label of oMessageTxt    to ""
15820>>>>>        Set Label of oActionTxt     to ""
15821>>>>>    End_Procedure
15822>>>>>
15822>>>>>    Object oTitleTxt is a TextBox
15824>>>>>        Set Location to 5 21
15825>>>>>        Set Size to 8 179
15826>>>>>        Set Auto_Size_State to False
15827>>>>>        Set Justification_Mode  to jMode_Center
15828>>>>>        Set Label to "This is the Title Text"
15829>>>>>    End_Object
15830>>>>>
15830>>>>>    Object oTableNameTxt is a TextBox
15832>>>>>        Set Size to 19 204
15833>>>>>        Set Location to 18 9
15834>>>>>        Set Auto_Size_State to False
15835>>>>>        Set Justification_Mode to JMode_Left
15836>>>>>        Set Label to "This is the TableName Text"
15837>>>>>    End_Object
15838>>>>>
15838>>>>>    Object oMessageTxt is a TextBox
15840>>>>>        Set Location to 39 9
15841>>>>>        Set Size to 19 204
15842>>>>>        Set Auto_Size_State to False
15843>>>>>        Set Justification_Mode to JMode_Left
15844>>>>>        Set Label to "This is the Message text"
15845>>>>>    End_Object
15846>>>>>
15846>>>>>    Object oActionTxt is a TextBox
15848>>>>>        Set Size to 16 204
15849>>>>>        Set Location to 60 9
15850>>>>>        Set Auto_Size_State to False
15851>>>>>        Set Justification_Mode to JMode_Left
15852>>>>>        Set Label to "This is the Action Text"
15853>>>>>    End_Object
15854>>>>>
15854>>>>>    Object oStopButton is a Button
15856>>>>>        Set Location to 120 82
15857>>>>>        Set Label to C_$Cancel
15858>>>>>
15858>>>>>        Procedure OnClick
15861>>>>>            Send Close_panel
15862>>>>>        End_Procedure
15863>>>>>
15863>>>>>    End_Object
15864>>>>>
15864>>>>>    Object oPercentage_tb is a TextBox
15866>>>>>        Set Location to 74 196
15867>>>>>        Set Size to 10 25
15868>>>>>//        Set Label to "% Done"
15868>>>>>    End_Object
15869>>>>>
15869>>>>>    Object oCopyRight is a TextBox
15871>>>>>        Set Location to 137 21
15872>>>>>        Set Size to 9 197
15873>>>>>        Set FontPointHeight to 8
15874>>>>>        Set Auto_Size_State to False
15875>>>>>        Set Justification_Mode  to jMode_Center
15876>>>>>        Set Label to "Copyright 2001-2019 RDC Tools International"
15877>>>>>    End_Object
15878>>>>>
15878>>>>>    Object oProgressBar is a cProgressBar
15880>>>>>        Set Size to 10 179
15881>>>>>        Set Location to 83 22
15882>>>>>        Set pbVisible to True // default
15883>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
15884>>>>>    End_Object
15885>>>>>
15885>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
15888>>>>>        Set pbVisible of ghoProgressBar to bVisible
15889>>>>>    End_Procedure
15890>>>>>
15890>>>>>    Function Progress_Bar_Visible_State Returns Boolean
15893>>>>>        Boolean bVisible
15893>>>>>        Get pbVisible of ghoProgressBar to bVisible
15894>>>>>        Function_Return (bVisible)
15895>>>>>    End_Function
15896>>>>>
15896>>>>>    Object oProgressBarOverall is a cProgressBar
15898>>>>>        Set Size to 10 179
15899>>>>>        Set Location to 104 22
15900>>>>>        Set pbVisible to True // default
15901>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
15902>>>>>    End_Object
15903>>>>>
15903>>>>>    Object oOverallProgress_tb is a TextBox
15905>>>>>        Set Size to 10 65
15906>>>>>        Set Location to 95 24
15907>>>>>        Set Label to "Overall Progress"
15908>>>>>    End_Object
15909>>>>>
15909>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
15912>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
15913>>>>>    End_Procedure
15914>>>>>
15914>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
15917>>>>>        Boolean bVisible
15917>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
15918>>>>>        Function_Return (bVisible)
15919>>>>>    End_Function
15920>>>>>
15920>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
15920>>>>>    // objects defined within this instance of the status panel.
15920>>>>>
15920>>>>>    // note: all of the messages that change text should be forwarded
15920>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
15920>>>>>
15920>>>>>    Procedure Set Message_Text String sText
15923>>>>>        Set Label of oMessageTxt to sText
15924>>>>>        Forward Set Message_Text to sText
15926>>>>>    End_Procedure
15927>>>>>
15927>>>>>    Function Message_Text Returns String
15930>>>>>        Function_Return (Label(oMessageTxt))
15931>>>>>    End_Function
15932>>>>>
15932>>>>>    Procedure Set Action_Text String sText
15935>>>>>        Set Label of oActionTxt to sText
15936>>>>>        Forward Set Action_Text to sText
15938>>>>>    End_Procedure
15939>>>>>
15939>>>>>    Function Action_Text Returns String
15942>>>>>        Function_Return (Label(oActionTxt))
15943>>>>>    End_Function
15944>>>>>
15944>>>>>    Procedure Set Button_Text String sText
15947>>>>>        Set Label of oStopButton to sText
15948>>>>>        Forward Set Button_Text to sText
15950>>>>>    End_Procedure
15951>>>>>
15951>>>>>    Function Button_Text Returns String
15954>>>>>        Function_Return (Label(oStopButton))
15955>>>>>    End_Function
15956>>>>>
15956>>>>>    Procedure Set Title_Text String sText
15959>>>>>        Set Label of oTitleTxt to sText
15960>>>>>        Forward Set Title_Text to sText
15962>>>>>    End_Procedure
15963>>>>>
15963>>>>>    Function Title_Text Returns String
15966>>>>>        Function_Return (Label(oTitleTxt))
15967>>>>>    End_Function
15968>>>>>
15968>>>>>    Procedure Set TableName_Text String sText
15971>>>>>        Set Label of oTableNameTxt to sText
15972>>>>>    End_Procedure
15973>>>>>
15973>>>>>    Function TableName_Text Returns String
15976>>>>>        Function_Return (Label(oTableNameTxt))
15977>>>>>    End_Function
15978>>>>>
15978>>>>>    Procedure Set License_Text String sText
15981>>>>>//        Set Label of oLicense_txt to sText
15981>>>>>    End_Procedure
15982>>>>>
15982>>>>>    // gets called when status panel is activated passing whether a button
15982>>>>>    // should appear
15982>>>>>    Procedure EnableCancelButton Boolean bEnable
15985>>>>>        Boolean bVisible
15985>>>>>        Get Cancel_Button_Visible_State to bVisible
15986>>>>>        If (bEnable = False) Begin
15988>>>>>            Set Visible_State of oStopButton to bVisible
15989>>>>>        End
15989>>>>>>
15989>>>>>        Set Enabled_State of oStopButton to bEnable
15990>>>>>    End_Procedure
15991>>>>>
15991>>>>>    Procedure Reset_StatusPanel
15994>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
15995>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
15996>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
15997>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
15998>>>>>    End_Procedure
15999>>>>>
15999>>>>>//    Object oProgressBar is a cProgressBar
15999>>>>>//        Move Self to ghoProgressBar
15999>>>>>//        Set Location to 1 25
15999>>>>>//        Set Size to 9 173
15999>>>>>//        Set piMinimum        to 0
15999>>>>>//        Set piMaximum        to 2000
15999>>>>>//        Set piAdvanceBy      to 100
15999>>>>>//        Set pbSmooth to True
15999>>>>>//
15999>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
15999>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
15999>>>>>//        // color will show correctly.
15999>>>>>//        Procedure Page Integer iPageObject
15999>>>>>//            Handle hWin
15999>>>>>//            Forward Send Page iPageObject
15999>>>>>//            If (ghoSkinFramework <> 0) Begin
15999>>>>>//                Get Window_Handle to hWin
15999>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
15999>>>>>//            End
15999>>>>>//        End_Procedure
15999>>>>>//    End_Object
15999>>>>>
15999>>>>>End_Object
16000>>>>>
16000>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateHandler.inc)
16000>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
16000>>>>>//
16000>>>>>Use VdfBase.pkg
16000>>>>>Use cApplication.pkg
16000>>>>>Use seq_chnl.pkg
16000>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\Libraries\vwin32fh\vWin32fh.pkg)
16000>>>>>>>// This code is part of VDF GUIdance
16000>>>>>>>// Visit us @ http://www.vdf-guidance.com
16000>>>>>>>// e-Mail us @ info@vdf-guidance.com
16000>>>>>>>// VDF GUIdance is a mutual project of
16000>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
16000>>>>>>>// Wil van Antwerpen  - Antwise Solutions
16000>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
16000>>>>>>>//
16000>>>>>>>//
16000>>>>>>>// *** Windows 32bit file handling wrapper class ***
16000>>>>>>>//
16000>>>>>>>
16000>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
16000>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
16000>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
16000>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
16000>>>>>>>//
16000>>>>>>>// The used naming-convention is:
16000>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
16000>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
16000>>>>>>>//
16000>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
16000>>>>>>>// of DataAccess in the future.
16000>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
16000>>>>>>>//
16000>>>>>>>// mm-dd-yyyy Author Description
16000>>>>>>>//
16000>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
16000>>>>>>>//                   vGetWindowsDirectory
16000>>>>>>>//
16000>>>>>>>//                   vGetTempFileName
16000>>>>>>>//                   vGetTempPath
16000>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
16000>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
16000>>>>>>>//                   error in your application anyways. Changed this for:
16000>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
16000>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
16000>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
16000>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
16000>>>>>>>//                   It is renamed too avoid this.
16000>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
16000>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
16000>>>>>>>//                   Removed the local keyword in the variable declarations
16000>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
16000>>>>>>>//                   created file-open dialog
16000>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
16000>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
16000>>>>>>>//                   This has now been taken care of.
16000>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
16000>>>>>>>//                   These declarations are now included from the vWin32fh header file.
16000>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
16000>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
16000>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
16000>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
16000>>>>>>>//                   One can however restore to the old way of handling by simply calling the
16000>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
16000>>>>>>>//                   filehandling operations
16000>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
16000>>>>>>>//                   as well as the StringFromRightOfChar function.
16000>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
16000>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
16000>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
16000>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
16000>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
16000>>>>>>>//                   extended characters are treated ok too.
16000>>>>>>>//                   Reported by Flemming from
16000>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
16000>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
16000>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
16000>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
16000>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
16000>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
16000>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
16000>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
16000>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
16000>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
16000>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
16000>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
16000>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
16000>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
16000>>>>>>>
16000>>>>>>>//Use Case.mac
16000>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
Including file: File_dlg.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\File_dlg.pkg)
16000>>>>>>>>>Use Windows.pkg
16000>>>>>>>>>Use GlobalFunctionsProcedures.pkg
16000>>>>>>>>>
16000>>>>>>>>>External_Function GetOpenFileName "GetOpenFileNameA" Comdlg32.DLL Pointer OpenStruct Returns Integer
16001>>>>>>>>>External_Function GetSaveFileName "GetSaveFileNameA" Comdlg32.DLL Pointer OpenStruct Returns Integer
16002>>>>>>>>>
16002>>>>>>>>>Struct TOpenFileName
16002>>>>>>>>>    DWord    lStructSize          // length, in bytes, of the structure.
16002>>>>>>>>>    Handle   hwndOwner            // Handle to the window that owns the dialog box.
16002>>>>>>>>>    Handle   hInstance            // handle to a memory object containing a dialog box template.
16002>>>>>>>>>    Pointer  lpstrFilter          // pointer to a buffer containing pairs of null-terminated filter strings.
16002>>>>>>>>>    Pointer  lpstrCustomFilter    // Pointer to a static buffer that contains a pair of null-terminated filter strings for preserving the filter pattern chosen by the user.
16002>>>>>>>>>    DWord    nMaxCustFilter       // size, in chars, of the buffer identified by lpstrCustomFilter.
16002>>>>>>>>>    DWord    nFilterIndex         // index of the currently selected filter
16002>>>>>>>>>    Pointer  lpstrFile            // Pointer to a buffer that contains the file name(s)
16002>>>>>>>>>    DWord    nMaxFile             // Size, in CHARs, of the buffer pointed to by lpstrFile.
16002>>>>>>>>>    Pointer  lpstrFileTitle       // Pointer to a buffer that receives the file name and extension
16002>>>>>>>>>    DWord    nMaxFileTitle        // size, in CHARs, of the buffer pointed to by lpstrFileTitle
16002>>>>>>>>>    Pointer  lpstrInitialDir      // Pointer to a NULL terminated string that can specify the initial directory.
16002>>>>>>>>>    Pointer  lpstrTitle           // Pointer to a string to be placed in the title bar of the dialog box.
16002>>>>>>>>>    DWord    ofnFlags             // set of bit flags you can use to initialize the dialog box.
16002>>>>>>>>>    Short    nFileOffset          // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name in the string pointed to by lpstrFile.
16002>>>>>>>>>    Short    nFileExtension       // Specifies the zero-based offset, in TCHARs, from the beginning of the path to the file name extension in the string pointed to by lpstrFile.
16002>>>>>>>>>    Pointer  lpstrDefExt          // Pointer to a buffer that contains the default extension.
16002>>>>>>>>>    Longptr  lCustData            // Specifies application-defined data that the system passes to the hook procedure identified by the lpfnHook member.
16002>>>>>>>>>    Pointer  lpfnHook             // Pointer to a hook procedure.
16002>>>>>>>>>    Pointer  lpTemplateName       // Pointer to a null-terminated string that names a dialog template resource in the module identified by the hInstance member.
16002>>>>>>>>>    Pointer  lpvReserved          // Reserved
16002>>>>>>>>>    DWord    dwReserved           // Reserved
16002>>>>>>>>>    DWord    FlagsEx              // A set of bit flags you can use to initialize the dialog box.
16002>>>>>>>>>End_Struct
16002>>>>>>>>>
16002>>>>>>>>>
16002>>>>>>>>>Class AbstractFileDialog is a cObject
16003>>>>>>>>>    
16003>>>>>>>>>    Procedure Construct_Object
16005>>>>>>>>>        Forward Send Construct_Object
16007>>>>>>>>>        
16007>>>>>>>>>        Property String  Filter_String
16008>>>>>>>>>        Property String  Initial_Folder
16009>>>>>>>>>        Property String  File_Name
16010>>>>>>>>>        Property String  File_Title
16011>>>>>>>>>        Property String  Dialog_Caption
16012>>>>>>>>>        Property Integer Filter_Index          1
16013>>>>>>>>>        Property Integer HideReadOnly_State    False
16014>>>>>>>>>        Property Integer TickReadOnly_State    False
16015>>>>>>>>>        Property Integer AllowReadOnly_State   True
16016>>>>>>>>>        Property Integer FileMustExist_State   True
16017>>>>>>>>>        Property Integer PathMustExist_State   True
16018>>>>>>>>>        Property Integer CreatePrompt_State    True
16019>>>>>>>>>        Property Integer ShowFileTitle_State   False
16020>>>>>>>>>        Property Integer OverwritePrompt_State False
16021>>>>>>>>>        Property Integer NoChangeDir_State     False
16022>>>>>>>>>        
16022>>>>>>>>>        Property Boolean Private_MultiSelect_State False
16023>>>>>>>>>        
16023>>>>>>>>>        Property String[] Private_Selected_Files
16024>>>>>>>>>        
16024>>>>>>>>>        Property Integer PrivateExternal_msg
16025>>>>>>>>>        
16025>>>>>>>>>        //Set Focus_Mode To No_Activate
16025>>>>>>>>>    End_Procedure
16026>>>>>>>>>    
16026>>>>>>>>>    Function OwnerHandle Returns Handle
16028>>>>>>>>>        Handle hWnd
16028>>>>>>>>>        Handle hoObj
16028>>>>>>>>>        Get Focus of desktop to hoObj // start with the focus
16029>>>>>>>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
16030>>>>>>>>>        Function_Return hWnd
16031>>>>>>>>>    End_Function
16032>>>>>>>>>    
16032>>>>>>>>>    
16032>>>>>>>>>    Function Show_Dialog Returns Integer // bool
16034>>>>>>>>>        Handle hWnd
16034>>>>>>>>>        Integer bOK iFilter iFlags bHideRO bTickRO bFileExist bPathExist iMsg
16034>>>>>>>>>        Integer icInitDir bCreatePrompt bOverwritePrompt bAllowReadOnly
16034>>>>>>>>>        Integer iPos iCount
16034>>>>>>>>>        Integer bNoChangeDir
16034>>>>>>>>>        Pointer lpsFileTitle lpsFileName lpsFilter lpsInitDir
16034>>>>>>>>>        Pointer lpsTitle lpsDefExt
16034>>>>>>>>>        String sFileName sFileTitle sFilter sInitDir sTitle sDefExt
16034>>>>>>>>>        Pointer lpOpenFileData
16034>>>>>>>>>        Boolean bMultiSelect
16034>>>>>>>>>        String[] sFiles
16035>>>>>>>>>        TOpenFileName OpenFileData
16035>>>>>>>>>        TOpenFileName OpenFileData
16035>>>>>>>>>        
16035>>>>>>>>>        //Delegate Get Container_Handle To hWnd
16035>>>>>>>>>        Get OwnerHandle to hWnd
16036>>>>>>>>>        
16036>>>>>>>>>        If (ShowFileTitle_State(Self)) Begin
16038>>>>>>>>>            Get File_Title to sFileName
16039>>>>>>>>>        End
16039>>>>>>>>>>
16039>>>>>>>>>        
16039>>>>>>>>>        Get private_MultiSelect_State to bMultiSelect
16040>>>>>>>>>        
16040>>>>>>>>>        Get Initial_Folder        to sInitDir
16041>>>>>>>>>        Get Dialog_Caption        to sTitle
16042>>>>>>>>>        Get Filter_String         to sFilter
16043>>>>>>>>>        Get HideReadOnly_State    to bHideRO
16044>>>>>>>>>        Get TickReadOnly_State    to bTickRO
16045>>>>>>>>>        Get FileMustExist_State   to bFileExist
16046>>>>>>>>>        Get PathMustExist_State   to bPathExist
16047>>>>>>>>>        Get CreatePrompt_State    to bCreatePrompt
16048>>>>>>>>>        Get OverwritePrompt_State to bOverwritePrompt
16049>>>>>>>>>        Get AllowReadOnly_State   to bAllowReadOnly
16050>>>>>>>>>        Get NoChangeDir_State     to bNoChangeDir
16051>>>>>>>>>        Get Filter_Index          to iFilter
16052>>>>>>>>>        
16052>>>>>>>>>        Move (sFilter + Character(0) + Character(0)) to sFilter
16053>>>>>>>>>        Move (ToAnsi(sFilter)) to sFilter
16054>>>>>>>>>        Move (Replaces('|', sFilter, Character(0))) to sFilter
16055>>>>>>>>>        
16055>>>>>>>>>        Append sInitDir   (character(0))
16056>>>>>>>>>        Append sFileTitle (Repeat(character(0),32000))
16057>>>>>>>>>        Append sFileName  (Repeat(character(0),32000))
16058>>>>>>>>>        Append sTitle     (Repeat(character(0),255))
16059>>>>>>>>>        Append sDefExt    (character(0))
16060>>>>>>>>>        
16060>>>>>>>>>        Move (ToAnsi(sInitDir)) to sInitDir
16061>>>>>>>>>        Move (ToAnsi(sFileName)) to sFileName
16062>>>>>>>>>        Move (ToAnsi(sTitle)) to sTitle
16063>>>>>>>>>        
16063>>>>>>>>>        Move (AddressOf(sInitDir))   to lpsInitDir
16064>>>>>>>>>        Move (AddressOf(sFileName))  to lpsFileName
16065>>>>>>>>>        Move (AddressOf(sFileTitle)) to lpsFileTitle
16066>>>>>>>>>        Move (AddressOf(sTitle))     to lpsTitle
16067>>>>>>>>>        Move (AddressOf(sDefExt))    to lpsDefExt
16068>>>>>>>>>        Move (AddressOf(sFilter))    to lpsFilter
16069>>>>>>>>>        
16069>>>>>>>>>        
16069>>>>>>>>>        If (bMultiSelect) Begin
16071>>>>>>>>>            Move (OFN_EXPLORER + OFN_ALLOWMULTISELECT) to iFlags  // Multi-select!
16072>>>>>>>>>        End
16072>>>>>>>>>>
16072>>>>>>>>>        
16072>>>>>>>>>        If bFileExist ;            Move (iFlags + OFN_FILEMUSTEXIST)    to iFlags
16075>>>>>>>>>        If bPathExist ;            Move (iFlags + OFN_PATHMUSTEXIST)    to iFlags
16078>>>>>>>>>        If bHideRO ;            Move (iFlags + OFN_HIDEREADONLY)     to iFlags
16081>>>>>>>>>        If bTickRO ;            Move (iFlags + OFN_READONLY)         to iFlags
16084>>>>>>>>>        If bCreatePrompt ;            Move (iFlags + OFN_CREATEPROMPT)     to iFlags
16087>>>>>>>>>        If bOverwritePrompt ;            Move (iFlags + OFN_OVERWRITEPROMPT)  to iFlags
16090>>>>>>>>>        If not bAllowReadOnly ;            Move (iFlags + OFN_NOREADONLYRETURN) to iFlags
16093>>>>>>>>>        If bNoChangeDir ;            Move (iFlags + OFN_NOCHANGEDIR)      to iFlags
16096>>>>>>>>>        
16096>>>>>>>>>        Move (SizeOfType(TOpenFileName)) to OpenFileData.lStructSize
16097>>>>>>>>>        Move hWnd         to OpenFileData.hWndOwner
16098>>>>>>>>>        Move iFilter      to OpenFileData.nFilterIndex
16099>>>>>>>>>        Move lpsFileName  to OpenFileData.lpstrFile
16100>>>>>>>>>        
16100>>>>>>>>>        If (sInitDir <> '') Begin
16102>>>>>>>>>            Move lpsInitDir    to OpenFileData.lpstrInitialDir
16103>>>>>>>>>        End
16103>>>>>>>>>>
16103>>>>>>>>>        
16103>>>>>>>>>        If (sTitle <> '') Begin
16105>>>>>>>>>            Move lpsTitle      to OpenFileData.lpstrTitle
16106>>>>>>>>>        End
16106>>>>>>>>>>
16106>>>>>>>>>        
16106>>>>>>>>>        Move 32000             to OpenFileData.nMaxFileTitle
16107>>>>>>>>>        Move 32000             to OpenFileData.nMaxFile
16108>>>>>>>>>        Move lpsFileTitle      to OpenFileData.lpstrFileTitle
16109>>>>>>>>>        Move iFlags            to OpenFileData.ofnFlags
16110>>>>>>>>>        Move lpsFilter         to OpenFileData.lpstrFilter
16111>>>>>>>>>        Move lpsDefExt         to OpenFileData.lpstrDefExt
16112>>>>>>>>>        
16112>>>>>>>>>        Move (AddressOf(OpenFileData)) to lpOpenFileData
16113>>>>>>>>>        
16113>>>>>>>>>        Get PrivateExternal_msg to iMsg
16114>>>>>>>>>        If (iMsg = Get_GetOpenFileName) ;            Move (GetOpenFileName(lpOpenFileData)) to bOK
16117>>>>>>>>>        If (iMsg = Get_GetSaveFileName) ;            Move (GetSaveFileName(lpOpenFileData)) to bOK
16120>>>>>>>>>        
16120>>>>>>>>>        If bOK Begin
16122>>>>>>>>>            Move OpenFileData.ofnFlags     to iFlags
16123>>>>>>>>>            Move OpenFileData.nFilterIndex to iFilter
16124>>>>>>>>>            Move OpenFileData.nFileOffset  to icInitDir
16125>>>>>>>>>            
16125>>>>>>>>>            Move (CString(Left(sFileName, icInitDir))) to sInitDir    // Trim trailing null
16126>>>>>>>>>            Set Initial_Folder     to (ToOEM(sInitDir))
16127>>>>>>>>>            
16127>>>>>>>>>            Set TickReadOnly_State to (iFlags iand OFN_READONLY)
16128>>>>>>>>>            Set Filter_Index       to iFilter
16129>>>>>>>>>            // Note that ToOEM only converts up to first null
16129>>>>>>>>>            Set File_Name          to (CString(ToOEM( sFileName )))
16130>>>>>>>>>            Set File_Title         to (CString(ToOEM( sFileTitle )))
16131>>>>>>>>>            
16131>>>>>>>>>            If (bMultiSelect) Begin
16133>>>>>>>>>                // If this is a multi-files dialog then parse out the array of selected files....
16133>>>>>>>>>                If (Right(sInitDir, 1) = "\") ;                    Move (Left(sInitDir, Length(sInitDir)-1)) to sInitDir     // Trim trailing :\". This is only there if 1 file was selected!
16136>>>>>>>>>                
16136>>>>>>>>>                // Get the null delimited string of file names into the sFiles array....
16136>>>>>>>>>                Move 0 to iCount
16137>>>>>>>>>                Move (Right(sFileName, Length(sFileName) - icInitDir)) to sFileName    // Strip the path info (we already have it)
16138>>>>>>>>>                
16138>>>>>>>>>                Repeat
16138>>>>>>>>>>
16138>>>>>>>>>                    // Get the next filename....
16138>>>>>>>>>                    Move (Pos(Character(0), sFileName)) to iPos   // Filenames are null delimeted
16139>>>>>>>>>                    
16139>>>>>>>>>                    If (iPos > 1) Begin
16141>>>>>>>>>                        Move (sInitDir + "\" + CString(Left(sFileName, iPos))) to sFiles[iCount]
16142>>>>>>>>>                        Move (ToOEM(sFiles[iCount])) to sFiles[iCount]
16143>>>>>>>>>                        Move (Right(sFileName, Length(sFileName) - iPos)) to sFileName
16144>>>>>>>>>                        Increment iCount
16145>>>>>>>>>                    End
16145>>>>>>>>>>
16145>>>>>>>>>                Until (iPos <= 1)
16147>>>>>>>>>            End
16147>>>>>>>>>>
16147>>>>>>>>>            Else Begin
16148>>>>>>>>>                Move (CString(ToOEM( sFileName ))) to sFiles[0]
16149>>>>>>>>>            End
16149>>>>>>>>>>
16149>>>>>>>>>            
16149>>>>>>>>>            Set private_Selected_Files to sFiles
16150>>>>>>>>>        End
16150>>>>>>>>>>
16150>>>>>>>>>        Function_Return (bOK)
16151>>>>>>>>>    End_Function
16152>>>>>>>>>End_Class
16153>>>>>>>>>
16153>>>>>>>>>Class OpenDialog is an AbstractFileDialog
16154>>>>>>>>>    Procedure Construct_Object
16156>>>>>>>>>        Forward Send Construct_Object
16158>>>>>>>>>        Set PrivateExternal_msg to get_GetOpenFileName
16159>>>>>>>>>    End_Procedure
16160>>>>>>>>>    
16160>>>>>>>>>    Procedure Set MultiSelect_State Boolean bState
16162>>>>>>>>>        Set private_MultiSelect_State to bState
16163>>>>>>>>>    End_Procedure
16164>>>>>>>>>    
16164>>>>>>>>>    Function MultiSelect_State Returns Boolean
16166>>>>>>>>>        Boolean bState
16166>>>>>>>>>        Get private_MultiSelect_State to bState
16167>>>>>>>>>        Function_Return bState
16168>>>>>>>>>    End_Function
16169>>>>>>>>>    
16169>>>>>>>>>    Function Selected_Files Returns String[]
16171>>>>>>>>>        String[] sFiles
16172>>>>>>>>>        Get private_Selected_Files to sFiles
16173>>>>>>>>>        Function_Return sFiles
16174>>>>>>>>>    End_Function
16175>>>>>>>>>End_Class
16176>>>>>>>>>
16176>>>>>>>>>Class SaveAsDialog is an AbstractFileDialog
16177>>>>>>>>>    Procedure Construct_Object
16179>>>>>>>>>        Forward Send Construct_Object
16181>>>>>>>>>        Set FileMustExist_State   to False
16182>>>>>>>>>        Set CreatePrompt_State    to False
16183>>>>>>>>>        Set ShowFileTitle_State   to True
16184>>>>>>>>>        Set OverwritePrompt_State to True
16185>>>>>>>>>        Set HideReadOnly_State    to True
16186>>>>>>>>>        Set PrivateExternal_msg to get_GetSaveFileName
16187>>>>>>>>>    End_Procedure
16188>>>>>>>>>End_Class
16189>>>>>>>>>
16189>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\Libraries\vwin32fh\cvFileDialogs.pkg)
16189>>>>>>>>>//***************************************************************************
16189>>>>>>>>>//*
16189>>>>>>>>>//* Class:        cvSaveAsDialog
16189>>>>>>>>>//* Package Name: cvFileDialogs.pkg
16189>>>>>>>>>//*
16189>>>>>>>>>//***************************************************************************
16189>>>>>>>>>
16189>>>>>>>>>Use File_dlg.pkg
16189>>>>>>>>>
16189>>>>>>>>>// *WvA: 13-01-1999 Created
16189>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
16189>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
16189>>>>>>>>>// file_name.
16189>>>>>>>>>Class cvSelectFile_Dialog Is An OpenDialog
16190>>>>>>>>>
16190>>>>>>>>>  Procedure Construct_Object Integer iImage_Id
16192>>>>>>>>>    Forward Send Construct_Object iImage_Id
16194>>>>>>>>>    Set HideReadOnly_State To True
16195>>>>>>>>>  End_Procedure // Construct_Object
16196>>>>>>>>>
16196>>>>>>>>>  Function SelectedFileName Returns String
16198>>>>>>>>>    String sFileName
16198>>>>>>>>>    Move "" To sFileName
16199>>>>>>>>>    If (Show_Dialog(Self)) Begin
16201>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
16202>>>>>>>>>    End
16202>>>>>>>>>>
16202>>>>>>>>>    Function_Return sFileName
16203>>>>>>>>>  End_Function // SelectedFileName
16204>>>>>>>>>End_Class // cvSelectFile_Dialog
16205>>>>>>>>>
16205>>>>>>>>>
16205>>>>>>>>>// *WvA: 13-01-1999 Created
16205>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
16205>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
16205>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
16205>>>>>>>>>//                   file-open dialog
16205>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
16207>>>>>>>>>  String sSelectedFile
16207>>>>>>>>>  Integer hoOpenFileDialog
16207>>>>>>>>>
16207>>>>>>>>>  Object oOpenFileDialog Is A cvSelectFile_Dialog
16209>>>>>>>>>
16209>>>>>>>>>    Set Dialog_Caption    To sCaptionText
16210>>>>>>>>>    Set Filter_String     To sSupportedFileTypes
16211>>>>>>>>>    Set Initial_Folder    To sInitialFolder
16212>>>>>>>>>
16212>>>>>>>>>    Move Self       To hoOpenFileDialog
16213>>>>>>>>>  End_Object // oOpenFileDialog
16214>>>>>>>>>
16214>>>>>>>>>  Get SelectedFileName Of hoOpenFileDialog To sSelectedFile
16215>>>>>>>>>  Send Destroy_Object To hoOpenFileDialog
16216>>>>>>>>>  Function_Return sSelectedFile
16217>>>>>>>>>End_Function // vSelect_File
16218>>>>>>>>>
16218>>>>>>>>>
16218>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
16219>>>>>>>>>
16219>>>>>>>>>  Procedure Construct_Object
16221>>>>>>>>>    Forward Send Construct_Object
16223>>>>>>>>>    Set HideReadOnly_State To True
16224>>>>>>>>>  End_Procedure // Construct_Object
16225>>>>>>>>>
16225>>>>>>>>>  Function SelectedFileName Returns String
16227>>>>>>>>>    String sFileName
16227>>>>>>>>>    Move "" To sFileName
16228>>>>>>>>>    If (Show_Dialog(Self)) Begin
16230>>>>>>>>>      Move (RTrim(File_Name(Self))) To sFileName
16231>>>>>>>>>    End
16231>>>>>>>>>>
16231>>>>>>>>>    Function_Return sFileName
16232>>>>>>>>>  End_Function // SelectedFileName
16233>>>>>>>>>
16233>>>>>>>>>End_Class // cvSaveAsDialog
16234>>>>>>>>>
16234>>>>>>>>>// Added optional default filename as suggested by Nils
16234>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
16236>>>>>>>>>  String sSelectedFile
16236>>>>>>>>>  Integer hoDialog
16236>>>>>>>>>
16236>>>>>>>>>  Move "" To sSelectedFile
16237>>>>>>>>>  Get Create U_cvSaveAsDialog To hoDialog
16238>>>>>>>>>  If (hoDialog) Begin
16240>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
16240>>>>>>>>>    Set Dialog_Caption    Of hoDialog To sCaptionText
16241>>>>>>>>>    Set Filter_String     Of hoDialog To sSupportedFileTypes
16242>>>>>>>>>    Set Initial_Folder    Of hoDialog To sInitialFolder
16243>>>>>>>>>    If (Num_Arguments = 4) Begin
16245>>>>>>>>>      Set File_Title        of hoDialog to sDefaultFileName
16246>>>>>>>>>    End
16246>>>>>>>>>>
16246>>>>>>>>>    Get SelectedFileName  Of hoDialog To sSelectedFile
16247>>>>>>>>>    Send Destroy Of hoDialog
16248>>>>>>>>>  End
16248>>>>>>>>>>
16248>>>>>>>>>  Function_Return sSelectedFile
16249>>>>>>>>>End_Function // vSelectSaveFile
16250>>>>>>>Use Seq_chnl.pkg
16250>>>>>>>
16250>>>>>>>Use windows.pkg
16250>>>>>>>Use Dll.pkg
16250>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF18\DbUpdateFramework2.0\Libraries\vwin32fh\vwin32fh.h)
16250>>>>>>>>>//TH-Header
16250>>>>>>>>>//*****************************************************************************************
16250>>>>>>>>>// Copyright (c)  2004 KURANT Project
16250>>>>>>>>>// All rights reserved.
16250>>>>>>>>>//
16250>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
16250>>>>>>>>>// $ProjectName : Windows 32 bits file handling
16250>>>>>>>>>// $Authors     : Wil van Antwerpen
16250>>>>>>>>>// $Created     : 19.02.2004  19:25
16250>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
16250>>>>>>>>>//
16250>>>>>>>>>// Contents:
16250>>>>>>>>>//  This file contains the Windows API external function call definitions and
16250>>>>>>>>>//  constants as they are used in the vWin32fh package.
16250>>>>>>>>>//*****************************************************************************************
16250>>>>>>>>>//TH-RevisionStart
16250>>>>>>>>>//TH-RevisionEnd
16250>>>>>>>>>
16250>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
16250>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
16250>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
16250>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
16250>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
16250>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
16250>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
16250>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
16250>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
16250>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
16250>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
16250>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
16250>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
16250>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
16250>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
16250>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
16250>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
16250>>>>>>>>>
16250>>>>>>>>>
16250>>>>>>>>>Define vMax_Path     For |CI260
16250>>>>>>>>>Define vMinChar      For |CI$80
16250>>>>>>>>>Define vMaxChar      For |CI$7F
16250>>>>>>>>>Define vMinShort     For |CI$8000
16250>>>>>>>>>Define vMaxShort     For |CI$7FFF
16250>>>>>>>>>Define vMinLong      For |CI$80000000
16250>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
16250>>>>>>>>>Define vMaxByte      For |CI$FF
16250>>>>>>>>>Define vMaxWord      For |CI$FFFF
16250>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
16250>>>>>>>>>
16250>>>>>>>>>
16250>>>>>>>>>
16250>>>>>>>>>// For FindFirstFile
16250>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
16250>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
16250>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
16250>>>>>>>>>
16250>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
16250>>>>>>>>>// the API-call ShellExecute is used.
16250>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
16250>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
16250>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
16250>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
16250>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
16250>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
16250>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
16250>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
16250>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
16250>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
16250>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
16250>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
16250>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
16250>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
16250>>>>>>>>>
16250>>>>>>>>>
16250>>>>>>>>>// C-Structure
16250>>>>>>>>>//typedef struct _browseinfo {
16250>>>>>>>>>//    HWND hwndOwner;
16250>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
16250>>>>>>>>>//    LPSTR pszDisplayName;
16250>>>>>>>>>//    LPCSTR lpszTitle;
16250>>>>>>>>>//    UINT ulFlags;
16250>>>>>>>>>//    BFFCALLBACK lpfn;
16250>>>>>>>>>//    LPARAM lParam;
16250>>>>>>>>>//    int iImage;
16250>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
16250>>>>>>>>>
16250>>>>>>>>>//declare C structure struct_browseinfo
16250>>>>>>>>>//as documented in MSDN under Windows Shell API
16250>>>>>>>>>Struct tvBrowseInfo
16250>>>>>>>>>  Handle    hWndOwner
16250>>>>>>>>>  Pointer   pIDLRoot
16250>>>>>>>>>  Pointer   pszDisplayName
16250>>>>>>>>>  Pointer   lpszTitle
16250>>>>>>>>>  dWord     ulFlags
16250>>>>>>>>>  Pointer   lpfnCallback
16250>>>>>>>>>  dWord     lParam
16250>>>>>>>>>  DWord     iImage
16250>>>>>>>>>End_Struct // tvBrowseInfo
16250>>>>>>>>>
16250>>>>>>>>>// Browsing for directory.
16250>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
16250>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
16250>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
16250>>>>>>>>>                                            // The callback function can set the status text by
16250>>>>>>>>>                                            // sending messages to the dialog box.
16250>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
16250>>>>>>>>>
16250>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
16250>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
16250>>>>>>>>>
16250>>>>>>>>>// message from browser
16250>>>>>>>>>//Define BFFM_INITIALIZED        1
16250>>>>>>>>>//Define BFFM_SELCHANGED         2
16250>>>>>>>>>
16250>>>>>>>>>// messages to browser
16250>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
16250>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
16250>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
16250>>>>>>>>>
16250>>>>>>>>>
16250>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
16251>>>>>>>>>
16251>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
16252>>>>>>>>>
16252>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
16253>>>>>>>>>
16253>>>>>>>>>
16253>>>>>>>>>
16253>>>>>>>>>
16253>>>>>>>>>Struct tvSecurity_attributes
16253>>>>>>>>>  DWord   nLength
16253>>>>>>>>>  Pointer lpDescriptor
16253>>>>>>>>>  Integer bInheritHandle
16253>>>>>>>>>End_Struct // tvSecurity_attributes
16253>>>>>>>>>
16253>>>>>>>>>//nLength:
16253>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
16253>>>>>>>>>// SECURITY_ATTRIBUTES structure.
16253>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
16253>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
16253>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
16253>>>>>>>>>//
16253>>>>>>>>>//lpSecurityDescriptor:
16253>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
16253>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
16253>>>>>>>>>// descriptor of the calling process.
16253>>>>>>>>>//
16253>>>>>>>>>//bInheritHandle:
16253>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
16253>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
16253>>>>>>>>>
16253>>>>>>>>>
16253>>>>>>>>>// BOOL CreateDirectory(
16253>>>>>>>>>//    LPCTSTR lpPathName,
16253>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
16253>>>>>>>>>//   );
16253>>>>>>>>>//
16253>>>>>>>>>// lpPathName
16253>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
16253>>>>>>>>>//  to be created.
16253>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
16253>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
16253>>>>>>>>>// lpSecurityAttributes
16253>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
16253>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
16253>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
16253>>>>>>>>>// Returns:
16253>>>>>>>>>//  If the function succeeds, the return value is nonzero.
16253>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
16253>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
16254>>>>>>>>>
16254>>>>>>>>>
16254>>>>>>>>>// lpPathName
16254>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
16254>>>>>>>>>//  to be removed.
16254>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
16254>>>>>>>>>// Returns:
16254>>>>>>>>>//  If the function succeeds, the return value is nonzero.
16254>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
16254>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
16255>>>>>>>>>
16255>>>>>>>>>
16255>>>>>>>>>
16255>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
16255>>>>>>>>>// executable file or a document file.
16255>>>>>>>>>//
16255>>>>>>>>>// Operation can be one of the following:
16255>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
16255>>>>>>>>>//            The file can be an executable file or a document file.
16255>>>>>>>>>//            The file can be a folder to open.
16255>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
16255>>>>>>>>>//            The file should be a document file. If the file is an executable file,
16255>>>>>>>>>//            the function opens the file, as if "open" had been specified.
16255>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
16255>>>>>>>>>//
16255>>>>>>>>>// Return Values:
16255>>>>>>>>>//
16255>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
16255>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
16255>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
16255>>>>>>>>>//
16255>>>>>>>>>// The following table lists these error values:
16255>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
16255>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
16255>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
16255>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
16255>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
16255>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
16255>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
16255>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
16255>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
16255>>>>>>>>>// Public Const SE_ERR_FNF = 2
16255>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
16255>>>>>>>>>// Public Const SE_ERR_OOM = 8
16255>>>>>>>>>// Public Const SE_ERR_PNF = 3
16255>>>>>>>>>// Public Const SE_ERR_SHARE = 26
16255>>>>>>>>>
16255>>>>>>>>>
16255>>>>>>>>>
16255>>>>>>>>>// Code to open the program that is associated with the selected file.
16255>>>>>>>>>//
16255>>>>>>>>>// External function call used in Procedure DoStartDocument
16255>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
16256>>>>>>>>>
16256>>>>>>>>>
16256>>>>>>>>>
16256>>>>>>>>>
16256>>>>>>>>>Define vFO_MOVE                For |CI$0001
16256>>>>>>>>>Define vFO_COPY                For |CI$0002
16256>>>>>>>>>Define vFO_DELETE              For |CI$0003
16256>>>>>>>>>Define vFO_RENAME              For |CI$0004
16256>>>>>>>>>
16256>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
16256>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
16256>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
16256>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
16256>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
16256>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
16256>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
16256>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
16256>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
16256>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
16256>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
16256>>>>>>>>>
16256>>>>>>>>>Struct tvShFileOpStruct
16256>>>>>>>>>  Handle  hWnd
16256>>>>>>>>>  Integer wFunc
16256>>>>>>>>>  Pointer pFrom
16256>>>>>>>>>  Pointer pTo
16256>>>>>>>>>  Short   fFlags
16256>>>>>>>>>  Short   fAnyOperationsAborted
16256>>>>>>>>>  Pointer hNameMappings
16256>>>>>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
16256>>>>>>>>>End_Struct // tvShFileOpStruct
16256>>>>>>>>>
16256>>>>>>>>>// hwnd
16256>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
16256>>>>>>>>>
16256>>>>>>>>>// wFunc
16256>>>>>>>>>//   Operation to perform. This member can be one of the following values:
16256>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
16256>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
16256>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
16256>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
16256>>>>>>>>>
16256>>>>>>>>>// pFrom
16256>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
16256>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
16256>>>>>>>>>
16256>>>>>>>>>// pTo
16256>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
16256>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
16256>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
16256>>>>>>>>>//   double null-terminated.
16256>>>>>>>>>
16256>>>>>>>>>// fAnyOperationsAborted
16256>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
16256>>>>>>>>>//   were completed or FALSE otherwise.
16256>>>>>>>>>
16256>>>>>>>>>
16256>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
16256>>>>>>>>>// This can be a file or a folder.
16256>>>>>>>>>// With thanks to Andrew S Kaplan
16256>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
16257>>>>>>>>>
16257>>>>>>>>>
16257>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
16257>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
16258>>>>>>>>>
16258>>>>>>>>>
16258>>>>>>>>>
16258>>>>>>>>>// Courtesy Of Vincent Oorsprong
16258>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
16258>>>>>>>>>//   Pointer lpPathName ;
16258>>>>>>>>>//   Pointer lpPrefixString ;
16258>>>>>>>>>//   Integer uUnique ;
16258>>>>>>>>>//   Pointer lpTempFileName ;
16258>>>>>>>>>//   Returns Integer
16258>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
16258>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
16259>>>>>>>>>
16259>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
16260>>>>>>>>>
16260>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
16261>>>>>>>>>                  
16261>>>>>>>>>// from:
16261>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
16261>>>>>>>>>//
16261>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
16261>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
16261>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
16261>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
16261>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
16261>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
16261>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
16261>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
16261>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
16261>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
16261>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
16261>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
16261>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
16261>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
16261>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
16261>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
16261>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
16261>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
16261>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
16261>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
16261>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
16261>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
16261>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
16261>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
16261>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
16261>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
16261>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
16261>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
16261>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
16261>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
16261>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
16261>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
16261>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
16261>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
16261>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
16261>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
16261>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
16261>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
16261>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
16261>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
16261>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
16261>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
16261>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
16261>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
16261>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
16261>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
16261>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
16261>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
16261>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
16261>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
16261>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
16261>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
16261>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
16261>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
16261>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
16261>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
16261>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
16261>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
16261>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
16261>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
16261>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
16261>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
16261>>>>>>>>>
16261>>>>>>>>>
16261>>>>>>>>>//HRESULT SHGetFolderPath(
16261>>>>>>>>>//    HWND hwndOwner,
16261>>>>>>>>>//    int nFolder,
16261>>>>>>>>>//    HANDLE hToken,
16261>>>>>>>>>//    DWORD dwFlags,
16261>>>>>>>>>//    LPTSTR pszPath
16261>>>>>>>>>//);
16261>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
16261>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
16261>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
16261>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
16261>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
16261>>>>>>>>>//
16261>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
16262>>>>>>>>>
16262>>>>>>>>>
16262>>>>>>>>>
16262>>>>>>>>>Struct tvWin32FindData
16262>>>>>>>>> Dword            dwFileAttributes
16262>>>>>>>>> Dword            ftCreationLowDateTime
16262>>>>>>>>> Dword            ftCreationHighDateTime
16262>>>>>>>>> dword            ftLastAccessLowDateTime
16262>>>>>>>>> Dword            ftLastAccessHighDateTime
16262>>>>>>>>> Dword            ftLastWriteLowDateTime
16262>>>>>>>>> Dword            ftLastWriteHighDateTime
16262>>>>>>>>> Dword            nFileSizeHigh
16262>>>>>>>>> Dword            nFileSizeLow
16262>>>>>>>>> Dword            dwReserved0
16262>>>>>>>>> Dword            dwReserved1
16262>>>>>>>>> UChar[vMax_Path] cFileName
16262>>>>>>>>> UChar[14]        cAlternateFileName
16262>>>>>>>>>End_Struct // tvWin32_Find_Data
16262>>>>>>>>>
16262>>>>>>>>>// Courtesy Of Vincent Oorsprong
16262>>>>>>>>>// lpFileName      : address of name of file to search for
16262>>>>>>>>>// lpFindFileData  : address of returned information
16262>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
16263>>>>>>>>>
16263>>>>>>>>>// Courtesy Of Vincent Oorsprong
16263>>>>>>>>>// hFindFile       : handle of search
16263>>>>>>>>>// lpFindFileData  : address of structure for data on found file
16263>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
16264>>>>>>>>>  
16264>>>>>>>>>//
16264>>>>>>>>>// Unicode equivalents
16264>>>>>>>>>//
16264>>>>>>>>>// lpFileName      : address of name of file to search for
16264>>>>>>>>>// lpFindFileData  : address of returned information
16264>>>>>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
16265>>>>>>>>>
16265>>>>>>>>>// hFindFile       : handle of search
16265>>>>>>>>>// lpFindFileData  : address of structure for data on found file
16265>>>>>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
16266>>>>>>>>>
16266>>>>>>>>>
16266>>>>>>>>>// Courtesy Of Vincent Oorsprong
16266>>>>>>>>>//  hFindFile      : file search handle
16266>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
16267>>>>>>>>>
16267>>>>>>>>>
16267>>>>>>>>>
16267>>>>>>>>>Struct tvFileTime
16267>>>>>>>>>  DWord dwLowDateTime
16267>>>>>>>>>  DWord dwHighDateTime
16267>>>>>>>>>End_Struct
16267>>>>>>>>>
16267>>>>>>>>>
16267>>>>>>>>>Struct tvSystemTime
16267>>>>>>>>>  UShort wYear
16267>>>>>>>>>  UShort wMonth
16267>>>>>>>>>  UShort wDayOfWeek
16267>>>>>>>>>  UShort wDay
16267>>>>>>>>>  UShort wHour
16267>>>>>>>>>  UShort wMinute
16267>>>>>>>>>  UShort wSecond
16267>>>>>>>>>  UShort wMilliSeconds
16267>>>>>>>>>End_Struct
16267>>>>>>>>>
16267>>>>>>>>>
16267>>>>>>>>>// Courtesy Of Vincent Oorsprong
16267>>>>>>>>>//  lpFileTime     : pointer to file time to convert
16267>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
16267>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
16268>>>>>>>>>
16268>>>>>>>>>// Courtesy Of Vincent Oorsprong
16268>>>>>>>>>// This function formats the time in a picture-string passed
16268>>>>>>>>>//
16268>>>>>>>>>// Picture      Meaning
16268>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
16268>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
16268>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
16268>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
16268>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
16268>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
16268>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
16268>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
16268>>>>>>>>>//    t         One character time marker string, such as A or P
16268>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
16268>>>>>>>>>//
16268>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
16268>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
16268>>>>>>>>>
16268>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
16269>>>>>>>>>
16269>>>>>>>>>
16269>>>>>>>>>// Courtesy Of Vincent Oorsprong
16269>>>>>>>>>// This function formats the date in a picture-string passed
16269>>>>>>>>>//
16269>>>>>>>>>// Picture      Meaning
16269>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
16269>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
16269>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
16269>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
16269>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
16269>>>>>>>>>//              value associated with the specified locale.
16269>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
16269>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
16269>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
16269>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
16269>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
16269>>>>>>>>>//              associated with the specified locale.
16269>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
16269>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
16269>>>>>>>>>//    yyyy      Year represented hy full four digits.
16269>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
16269>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
16269>>>>>>>>>//              does not have an associated era or period string.
16269>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
16269>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
16269>>>>>>>>>
16269>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
16270>>>>>>>>>
16270>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
16270>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
16270>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
16270>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
16270>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
16270>>>>>>>>>
16270>>>>>>>>>//  Date Flags for GetDateFormatW.
16270>>>>>>>>>//
16270>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
16270>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
16270>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
16270>>>>>>>>>
16270>>>>>>>>>
16270>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
16271>>>>>>>>>
16271>>>>>>>>>
16271>>>>>>>>>// **WvA: 20-02-2004
16271>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
16271>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
16271>>>>>>>>>// incorrectly into an unsigned integer.
16271>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
16271>>>>>>>>>// It does smell a bit fishy though
16271>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
16271>>>>>>>>>
16271>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
16271>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
16271>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
16271>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
16271>>>>>>>>>
16271>>>>>>>>>// Possible errors that can be returned by the shellformat function
16271>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
16271>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
16271>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
16271>>>>>>>>>                                                
16271>>>>>>>>>
16271>>>>>>>>> // Courtesy Of Steve Walter,
16271>>>>>>>>> // USA Software, Inc
16271>>>>>>>>> // Format a disk
16271>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
16271>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
16272>>>>>>>>>
16272>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
16272>>>>>>>>>
16272>>>>>>>>>// SHCreateDirectoryEx
16272>>>>>>>>>
16272>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
16272>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
16272>>>>>>>>>//
16272>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
16272>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
16272>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
16272>>>>>>>>>//
16272>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
16272>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
16272>>>>>>>>>//        ERROR_CANCELLED.
16272>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
16272>>>>>>>>>
16272>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
16272>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
16272>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
16272>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
16272>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
16272>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
16272>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
16272>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
16272>>>>>>>>>
16272>>>>>>>>>//        int SHCreateDirectoryEx(
16272>>>>>>>>>//            HWND hwnd,
16272>>>>>>>>>//            LPCTSTR pszPath,
16272>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
16272>>>>>>>>>//        );
16272>>>>>>>>>
16272>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
16273>>>>>>>>>
16273>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
16274>>>>>>>
16274>>>>>>>
16274>>>>>>>
16274>>>>>>>
16274>>>>>>>
16274>>>>>>>
16274>>>>>>>//
16274>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
16274>>>>>>>// If sStopChar has no occurences in the string an empty string is
16274>>>>>>>// returned.
16274>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
16276>>>>>>>  String  sRetVal
16276>>>>>>>  String  sChar
16276>>>>>>>  Integer iLength
16276>>>>>>>  Integer iPos
16276>>>>>>>  Boolean bStopChar
16276>>>>>>>  Move "" To sRetval
16277>>>>>>>  Move (Length(sFrom)) To iLength
16278>>>>>>>  If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
16280>>>>>>>    Move iLength   To iPos
16281>>>>>>>    Move (False)   To bStopChar
16282>>>>>>>    While Not bStopChar
16286>>>>>>>      Move (Mid(sFrom,1,iPos)) To sChar
16287>>>>>>>      Decrement iPos
16288>>>>>>>      If ((sChar=sStopChar) Or (iPos<1)) Begin
16290>>>>>>>        Move (True) To bStopChar
16291>>>>>>>      End
16291>>>>>>>>
16291>>>>>>>      Else Begin
16292>>>>>>>        Move (sChar+sRetVal) To sRetVal
16293>>>>>>>      End
16293>>>>>>>>
16293>>>>>>>    Loop
16294>>>>>>>>
16294>>>>>>>  End
16294>>>>>>>>
16294>>>>>>>  Function_Return sRetVal
16295>>>>>>>End_Function
16296>>>>>>>
16296>>>>>>>
16296>>>>>>>// Pre:  sFileName contains the complete path of the file.
16296>>>>>>>// Post: returns the complete path of the file.
16296>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
16296>>>>>>>Function ParseFolderName Global String sFileName Returns String
16298>>>>>>>  String sFile
16298>>>>>>>  String sFolderName
16298>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
16298>>>>>>>  MOve "" To sFolderName
16299>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
16300>>>>>>>  If sDirSep In sFileName Begin
16302>>>>>>>    Move (StringFromRightOfChar(sFileName,sDirSep)) To sFile
16303>>>>>>>    Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
16304>>>>>>>  End
16304>>>>>>>>
16304>>>>>>>  Else If ":" In sFileName Begin
16307>>>>>>>    Move (StringFromRightOfChar(sFileName,":")) To sFile
16308>>>>>>>    Move (Replace(sFile,sFileName,"")) To sFolderName
16309>>>>>>>  End
16309>>>>>>>>
16309>>>>>>>  Function_Return sFolderName
16310>>>>>>>End_Function
16311>>>>>>>
16311>>>>>>>
16311>>>>>>>// Pre:  sFileName contains the complete path of the file.
16311>>>>>>>// post: The returned filename has it's path removed, but will have a extension
16311>>>>>>>Function ParseFileName Global String sFileName Returns String
16313>>>>>>>  String sFolderName
16313>>>>>>>  String sDirSep // this is "\" for windows, or "/" for unix
16313>>>>>>>
16313>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep
16314>>>>>>>  Get ParseFolderName sFileName To sFolderName
16315>>>>>>>  If (sFolderName <> "") ;    Move (Replace(sFolderName,sFileName,"")) To sFileName
16318>>>>>>>  Move (Replace(sDirSep,sFileName,"")) To sFileName
16319>>>>>>>  Function_Return sFilename
16320>>>>>>>End_Function
16321>>>>>>>
16321>>>>>>>
16321>>>>>>>// Pre:  sFileName may contain the complete path of the file.
16321>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
16321>>>>>>>//       return "bak" as the extension and not "gif"
16321>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
16321>>>>>>>//       such as "html" or "java"
16321>>>>>>>Function ParseFileExtension Global String sFileName Returns String
16323>>>>>>>  String  sFileExtension
16323>>>>>>>  Get ParseFileName sFileName To sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
16324>>>>>>>  Get StringFromRightOfChar sFileName "." To sFileExtension
16325>>>>>>>  Function_Return sFileExtension
16326>>>>>>>End_Function
16327>>>>>>>
16327>>>>>>>
16327>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
16327>>>>>>>
16327>>>>>>>
16327>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
16329>>>>>>>  String sMessage
16329>>>>>>>  Case Begin
16329>>>>>>>    Case (iErrorID = vERROR_FILE_NOT_FOUND)
16331>>>>>>>      Move CS_DDE_ERR_FILE_NOT_FOUND To sMessage
16332>>>>>>>      Case Break
16333>>>>>>>    Case (iErrorID = vERROR_PATH_NOT_FOUND)
16336>>>>>>>      Move CS_DDE_ERR_PATH_NOT_FOUND To sMessage
16337>>>>>>>      Case Break
16338>>>>>>>    Case (iErrorID = vERROR_BAD_FORMAT)
16341>>>>>>>      Move CS_DDE_ERR_BAD_FORMAT To sMessage
16342>>>>>>>      Case Break
16343>>>>>>>    Case (iErrorID = vSE_ERR_ACCESSDENIED)
16346>>>>>>>      Move CS_DDE_ERR_ACCESSDENIED To sMessage
16347>>>>>>>      Case Break
16348>>>>>>>    Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
16351>>>>>>>      Move CS_DDE_ERR_ASSOCINCOMPLETE To sMessage
16352>>>>>>>      Case Break
16353>>>>>>>    Case (iErrorID = vSE_ERR_DDEBUSY)
16356>>>>>>>      Move CS_DDE_ERR_DDEBUSY To sMessage
16357>>>>>>>      Case Break
16358>>>>>>>    Case (iErrorID = vSE_ERR_DDEFAIL)
16361>>>>>>>      Move CS_DDE_ERR_DDEFAIL To sMessage
16362>>>>>>>      Case Break
16363>>>>>>>    Case (iErrorID = vSE_ERR_DDETIMEOUT)
16366>>>>>>>      Move CS_DDE_ERR_DDETIMEOUT To sMessage
16367>>>>>>>      Case Break
16368>>>>>>>    Case (iErrorID = vSE_ERR_DLLNOTFOUND)
16371>>>>>>>      Move CS_DDE_ERR_DLLNOTFOUND To sMessage
16372>>>>>>>      Case Break
16373>>>>>>>    Case (iErrorID = vSE_ERR_NOASSOC)
16376>>>>>>>      Move CS_DDE_ERR_NOASSOC To sMessage
16377>>>>>>>      Case Break
16378>>>>>>>    Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
16381>>>>>>>      Move CS_DDE_ERR_OOM To sMessage
16382>>>>>>>      Case Break
16383>>>>>>>    Case (iErrorID = vSE_ERR_PNF)
16386>>>>>>>      Move CS_DDE_ERR_PNF To sMessage
16387>>>>>>>      Case Break
16388>>>>>>>    Case (iErrorID = vSE_ERR_SHARE)
16391>>>>>>>      Move CS_DDE_ERR_SHARE To sMessage
16392>>>>>>>      Case Break
16393>>>>>>>    Case Else
16393>>>>>>>      Move CS_DDE_ERR_UNKNOWN_LINE1 To sMessage
16394>>>>>>>      Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) To sMessage
16395>>>>>>>      Case Break
16396>>>>>>>  Case End
16396>>>>>>>  Function_Return sMessage
16397>>>>>>>End_Function
16398>>>>>>>
16398>>>>>>>
16398>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
16400>>>>>>>  String sMessage
16400>>>>>>>  Get DDE_Error_To_String iErrorID To sMessage
16401>>>>>>>  Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
16402>>>>>>>  Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
16403>>>>>>>End_Procedure
16404>>>>>>>
16404>>>>>>>
16404>>>>>>>// Does the directory exist? - No = false, Yes = True
16404>>>>>>>// This also works with UNC path encoding and wildcards
16404>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
16406>>>>>>>  Boolean bFolderExists
16406>>>>>>>  Boolean bStop
16406>>>>>>>  String  sFolder sTmp
16406>>>>>>>  Integer iCh
16406>>>>>>>
16406>>>>>>>  // 2013-09-29 NGS Check for empty folder name and convert to ANSI
16406>>>>>>>  Move (ToANSI(Trim(sFolderName))) to sFolderName
16407>>>>>>>  If (sFolderName = "") Begin
16409>>>>>>>    Function_Return False
16410>>>>>>>  End
16410>>>>>>>>
16410>>>>>>>
16410>>>>>>>  Move True  To bFolderExists
16411>>>>>>>  Move False To bStop
16412>>>>>>>  Move "dir:" To sFolder
16413>>>>>>>  Append sFolder sFolderName
16414>>>>>>>  Get Seq_New_Channel To iCh  // get free channel for input
16415>>>>>>>  Direct_Input Channel iCh sFolder
16417>>>>>>>    Repeat
16417>>>>>>>>
16417>>>>>>>      Readln Channel iCh sTmp
16419>>>>>>>      Move (SeqEof) To bStop
16420>>>>>>>      If (Trim(sTmp)="") Begin
16422>>>>>>>        Move False To bFolderExists
16423>>>>>>>      End
16423>>>>>>>>
16423>>>>>>>      Else Begin
16424>>>>>>>        Move True To bFolderExists
16425>>>>>>>        Move True To bStop
16426>>>>>>>      End
16426>>>>>>>>
16426>>>>>>>    Until (bStop)
16428>>>>>>>  Close_Input Channel iCh
16430>>>>>>>  Send Seq_Release_Channel iCh
16431>>>>>>>  Function_Return bFolderExists
16432>>>>>>>End_Function
16433>>>>>>>
16433>>>>>>>
16433>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
16433>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
16435>>>>>>>  String sFolder sTitle sPath
16435>>>>>>>  Pointer lpItemIdList
16435>>>>>>>  Integer iFolderSelected iRetval
16435>>>>>>>  tvBrowseInfo BrowseInfo
16435>>>>>>>  tvBrowseInfo BrowseInfo
16435>>>>>>>
16435>>>>>>>  Move "" To sPath
16436>>>>>>>  If (sDialogTitle<>"") Begin
16438>>>>>>>    Move sDialogTitle To sTitle
16439>>>>>>>    // Torben Lund suggested converting the string with toansi. Doing it like that
16439>>>>>>>    // disables showing some commonly used ascii characters like ascii 137 ()
16439>>>>>>>    // These chars are correctly shown if no toansi is used.
16439>>>>>>>    // I can imagine that he wanted to path to be ANSI, but as long as it isa just
16439>>>>>>>    // selected it will always be valid.
16439>>>>>>>    Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
16440>>>>>>>  End
16440>>>>>>>>
16440>>>>>>>
16440>>>>>>>  Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
16441>>>>>>>
16441>>>>>>>  // Torben Lund added line below. Move handle of focus object to structure before
16441>>>>>>>  // calling function. Otherwise, the folderdialog will be started as a seperate task.
16441>>>>>>>  Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
16442>>>>>>>
16442>>>>>>>  // null 128 chars into var (make space)
16442>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
16443>>>>>>>
16443>>>>>>>  // select folder
16443>>>>>>>  Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
16444>>>>>>>  // get selected folder name
16444>>>>>>>  Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
16445>>>>>>>
16445>>>>>>>  // release memory resources that are used by the ItemIdList
16445>>>>>>>  Move (vWin32_CoTaskMemFree(lpItemIdList)) To iRetval
16446>>>>>>>
16446>>>>>>>  If (iFolderSelected<>0) Begin
16448>>>>>>>    Move (CString(sFolder)) To sPath
16449>>>>>>>  End
16449>>>>>>>>
16449>>>>>>>  Function_Return  sPath
16450>>>>>>>End_Function
16451>>>>>>>
16451>>>>>>>
16451>>>>>>>// returns 0 if the folder is created.
16451>>>>>>>//         1 if the API-call returned an error.
16451>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
16453>>>>>>>  String  sFolder
16453>>>>>>>  Integer iRetval bFolderCreated
16453>>>>>>>  tvSecurity_attributes SA
16453>>>>>>>  tvSecurity_attributes SA
16453>>>>>>>
16453>>>>>>>  Move False to bFolderCreated
16454>>>>>>>
16454>>>>>>>  // null MAX_PATH chars into var (make space)
16454>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
16455>>>>>>>
16455>>>>>>>  If (sNewFolder <> "") Begin
16457>>>>>>>
16457>>>>>>>    Move (SizeOfType(tvSecurity_attributes)) To SA.nLength
16458>>>>>>>    Move  0  To SA.lpDescriptor
16459>>>>>>>    Move  1  To SA.bInheritHandle
16460>>>>>>>
16460>>>>>>>    //
16460>>>>>>>    Move (sNewFolder+"") to sFolder
16461>>>>>>>    Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
16462>>>>>>>  End
16462>>>>>>>>
16462>>>>>>>
16462>>>>>>>  If (bFolderCreated=false) Begin
16464>>>>>>>     Move 1 to iRetVal
16465>>>>>>>  End
16465>>>>>>>>
16465>>>>>>>  Function_Return iRetVal
16466>>>>>>>End_Function
16467>>>>>>>
16467>>>>>>>
16467>>>>>>>// **WvA: 03-02-2002 Function created.
16467>>>>>>>// With this function one can remove a directory.
16467>>>>>>>// returns 0 if the folder is removed.
16467>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
16467>>>>>>>//         2 if the folder did not exist
16467>>>>>>>//         3 if the sFolder parameter passed is equal to ""
16467>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
16469>>>>>>>  Boolean bRemoved bExists
16469>>>>>>>  String  sPath
16469>>>>>>>  Integer iRetval
16469>>>>>>>
16469>>>>>>>  Move 0     To iRetVal
16470>>>>>>>  Move False To bRemoved
16471>>>>>>>  Move (Trim(sFolder)) To sFolder
16472>>>>>>>  If (sFolder="") Begin
16474>>>>>>>    Move 3 To iRetVal
16475>>>>>>>  End
16475>>>>>>>>
16475>>>>>>>  If (vFolderExists(sFolder)=False) Begin
16477>>>>>>>    Move 2 To iRetVal
16478>>>>>>>  End
16478>>>>>>>>
16478>>>>>>>  If (iRetVal=0) Begin
16480>>>>>>>    // null MAX_PATH chars into var (make space)
16480>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) To sPath
16481>>>>>>>    //
16481>>>>>>>    Move (Insert(sFolder,sPath,1)) To sPath
16482>>>>>>>    Move (vWin32_RemoveDirectory(AddressOf(sPath))) To bRemoved
16483>>>>>>>  End
16483>>>>>>>>
16483>>>>>>>
16483>>>>>>>  If (iRetVal=0 And bRemoved=False) Begin
16485>>>>>>>    Move 1 To iRetVal
16486>>>>>>>  End
16486>>>>>>>>
16486>>>>>>>  Function_Return iRetVal
16487>>>>>>>End_Function
16488>>>>>>>
16488>>>>>>>
16488>>>>>>>
16488>>>>>>>// This function informs the user that he entered a yet unknown folder and
16488>>>>>>>// asks if he/she wants to create the folder (Yes/No)
16488>>>>>>>// Choice: "Yes" - this creates the folder
16488>>>>>>>//                 if successful, the function returns false
16488>>>>>>>//                 else it will be true.
16488>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
16488>>>>>>>//                 For example: to stop a save
16488>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
16488>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
16488>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
16490>>>>>>>  Integer bIsNotValid
16490>>>>>>>  Integer iUsers_Choice
16490>>>>>>>  String  sMessage
16490>>>>>>>
16490>>>>>>>  If (vFolderExists(sFolderName) Eq 0) Begin
16492>>>>>>>    Move "The folder '" To sMessage
16493>>>>>>>    Append sMessage sFolderName
16494>>>>>>>    Append sMessage "' does not yet exist,\n"
16495>>>>>>>    Append sMessage "Do you want to create it now?"
16496>>>>>>>    Get YesNo_Box sMessage "Confirm" MB_DefButton1 To iUsers_Choice
16497>>>>>>>    Case Begin
16497>>>>>>>      Case (iUsers_Choice = MBR_Yes)
16499>>>>>>>        Move (vCreateDirectory(sFolderName)) To bIsNotValid
16500>>>>>>>        If bIsNotValid Begin
16502>>>>>>>          Move "An error occurred while trying to create folder '" To sMessage
16503>>>>>>>          Append sMessage sFolderName "'.\n\n"
16505>>>>>>>          Send Info_Box sMessage "Info"
16506>>>>>>>          End
16506>>>>>>>>
16506>>>>>>>        Case Break
16507>>>>>>>      Case (iUsers_Choice = MBR_No)
16510>>>>>>>        Move dfTrue To bIsNotValid // Cancel the save
16511>>>>>>>        Case Break
16512>>>>>>>    Case End
16512>>>>>>>  End
16512>>>>>>>>
16512>>>>>>>  Function_Return bIsNotValid
16513>>>>>>>End_Function
16514>>>>>>>
16514>>>>>>>
16514>>>>>>>// This will perform an operation on a file (e.g. open) with the application
16514>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
16514>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
16514>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath Boolean bShCmd
16516>>>>>>>  Handle  hInstance hWnd
16516>>>>>>>  Boolean bShowCmd      
16516>>>>>>>  Integer iShowCmd
16516>>>>>>>  
16516>>>>>>>  Move False to bShowCmd
16517>>>>>>>  If (num_arguments > 4) Begin
16519>>>>>>>    Move bShCmd to bShowCmd
16520>>>>>>>  End             
16520>>>>>>>>
16520>>>>>>>  If (bShowCmd = True) Begin
16522>>>>>>>    Move 1 to iShowCmd
16523>>>>>>>  End                 
16523>>>>>>>>
16523>>>>>>>  Else Begin
16524>>>>>>>    Move 0 to iShowCmd
16525>>>>>>>  End
16525>>>>>>>>
16525>>>>>>>  // remove any leading/trailing spaces in the string
16525>>>>>>>  Move (Trim(sDocument)) To sDocument
16526>>>>>>>  Move (Trim(sPath))     To sPath
16527>>>>>>>  // Make the strings readable for windows API, by converting them to null-terminated
16527>>>>>>>  Append sOperation   (Character(0))
16528>>>>>>>  Append sDocument    (Character(0))
16529>>>>>>>  Append sParameters  (Character(0))
16530>>>>>>>  Append sPath        (Character(0))
16531>>>>>>>
16531>>>>>>>  Get Window_Handle To hWnd
16532>>>>>>>  Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), ;             AddressOf(sParameters), AddressOf(sPath), iShowCmd)) to hInstance
16533>>>>>>>  If (hInstance <= 32) Begin
16535>>>>>>>    Send vDDE_Error_Handler hInstance
16536>>>>>>>  End
16536>>>>>>>>
16536>>>>>>>End_Procedure
16537>>>>>>>
16537>>>>>>>
16537>>>>>>>Class cShellFileOperations Is a Array
16538>>>>>>>
16538>>>>>>>  Procedure Construct_Object
16540>>>>>>>    Forward Send Construct_Object
16542>>>>>>>    Property Integer piDeleteFlags        0
16543>>>>>>>    Property Integer piCopyFlags          0
16544>>>>>>>    Property Integer piMoveFlags          0
16545>>>>>>>    Property Integer piRenameFlags        0
16546>>>>>>>
16546>>>>>>>    Set piDeleteFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
16547>>>>>>>    Set piCopyFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
16548>>>>>>>    Set piMoveFlags   To (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
16549>>>>>>>    Set piRenameFlags To (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
16550>>>>>>>  End_Procedure
16551>>>>>>>
16551>>>>>>>
16551>>>>>>>  // This function uses the shell API to perform a file operation on the
16551>>>>>>>  // files supplied.
16551>>>>>>>  //
16551>>>>>>>  Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
16553>>>>>>>    Integer  iRetVal
16553>>>>>>>    Integer  iUserAbort
16553>>>>>>>    tvShFileOpStruct FOS
16553>>>>>>>    tvShFileOpStruct FOS
16553>>>>>>>
16553>>>>>>>    Move (ToAnsi(sSource)+Character(0)+Character(0))      To sSource
16554>>>>>>>    Move (ToAnsi(sDestination)+Character(0)+Character(0)) To sDestination
16555>>>>>>>
16555>>>>>>>    If (eOperation <> vFO_DELETE) Begin
16557>>>>>>>      Move (AddressOf(sDestination)) To FOS.pTo
16558>>>>>>>    End
16558>>>>>>>>
16558>>>>>>>
16558>>>>>>>    Move eOperation           To FOS.wFunc
16559>>>>>>>    Move (AddressOf(sSource)) To FOS.pFrom
16560>>>>>>>    Move iFlags               To FOS.fFlags
16561>>>>>>>
16561>>>>>>>    Move (vWin32_SHFileOperation(AddressOf(FOS))) To iRetVal
16562>>>>>>>    Move FOS.fAnyOperationsAborted To iUserAbort
16563>>>>>>>    If (iUserAbort <> 0) Begin
16565>>>>>>>      Move 80 To iRetVal  // file Operation Aborted by USER
16566>>>>>>>    End
16566>>>>>>>>
16566>>>>>>>    Function_Return (iRetVal)
16567>>>>>>>  End_Function
16568>>>>>>>
16568>>>>>>>
16568>>>>>>>  Function sfoDeleteFile String sFileName Returns Integer
16570>>>>>>>    Integer  iRetVal
16570>>>>>>>    Integer  iFlags
16570>>>>>>>
16570>>>>>>>    Get piDeleteFlags To iFlags
16571>>>>>>>    Get FileOperation sFileName "" vFO_DELETE iFlags To iRetVal
16572>>>>>>>    Function_Return iRetVal
16573>>>>>>>  End_Function
16574>>>>>>>
16574>>>>>>>
16574>>>>>>>  Function sfoCopyFile String sSource String sDestination Returns Integer
16576>>>>>>>    Integer  iRetVal
16576>>>>>>>    Integer  iFlags
16576>>>>>>>
16576>>>>>>>    Get piCopyFlags To iFlags
16577>>>>>>>    Get FileOperation sSource sDestination vFO_COPY iFlags To iRetVal
16578>>>>>>>    Function_Return iRetVal
16579>>>>>>>  End_Function
16580>>>>>>>
16580>>>>>>>
16580>>>>>>>  Function sfoMoveFile String sSource String sDestination Returns Integer
16582>>>>>>>    Integer  iRetVal
16582>>>>>>>    Integer  iFlags
16582>>>>>>>
16582>>>>>>>    Get piMoveFlags To iFlags
16583>>>>>>>    Get FileOperation sSource sDestination vFO_MOVE iFlags To iRetVal
16584>>>>>>>    Function_Return iRetVal
16585>>>>>>>  End_Function
16586>>>>>>>
16586>>>>>>>
16586>>>>>>>  // Rename a file or folder
16586>>>>>>>  // Returns a nonzero value if the operation failed.
16586>>>>>>>  Function sfoRenameFile String sSource String sDestination Returns Integer
16588>>>>>>>    Integer  iRetVal
16588>>>>>>>    Integer  iFlags
16588>>>>>>>
16588>>>>>>>    Get piRenameFlags To iFlags
16589>>>>>>>    Get FileOperation sSource sDestination vFO_RENAME iFlags To iRetVal
16590>>>>>>>    Function_Return iRetVal
16591>>>>>>>  End_Function
16592>>>>>>>
16592>>>>>>>  // Courtesy Of Steve Walter
16592>>>>>>>  // Requires Windows 2000 and up according to msdn but it was
16592>>>>>>>  //  in fact available before that as an unpublished API call
16592>>>>>>>  //  a little google search shows that this was already available
16592>>>>>>>  //  in windows 95 and NT
16592>>>>>>>  //
16592>>>>>>>  // The format is controlled by the dialog interface.
16592>>>>>>>  // That is, the user must click the OK button To actually Begin the format
16592>>>>>>>  // the format cannot be started programmatically.
16592>>>>>>>  // An alternative to this functionality would be to use a controlpanel
16592>>>>>>>  //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
16592>>>>>>>  //
16592>>>>>>>  // hWnd = The windows handle of the object from which the format Function
16592>>>>>>>  //        is called.
16592>>>>>>>  // To Get this,
16592>>>>>>>  //          use:  Get Window_Handle Of <object>
16592>>>>>>>  //          For instance, in this app, we're going to use the Report_Panel:
16592>>>>>>>  //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
16592>>>>>>>  //
16592>>>>>>>  // sDrive = The drive letter. At this moment only A and B are valid
16592>>>>>>>  //
16592>>>>>>>  // iOptions = Format options.
16592>>>>>>>  //  SHFMT_OPT_DEFAULT = Quick format
16592>>>>>>>  //  SHFMT_OPT_FULL    = Full Format
16592>>>>>>>  //  SHFMT_OPT_SYSONLY = System only
16592>>>>>>>  //  3                 = Full format with system. (unsupported)
16592>>>>>>>  //
16592>>>>>>>  // Return Values:
16592>>>>>>>  //  SHFMT_ERROR    = Error on format or no drive specified.
16592>>>>>>>  //  SHFMT_CANCEL   = Format cancelled by user.
16592>>>>>>>  //  SHFMT_NOFORMAT = Drive is not formatable.
16592>>>>>>>  //
16592>>>>>>>  //
16592>>>>>>>  // *** ATTENTION: This function has been disabled as it doesn't
16592>>>>>>>  //                seem to work, i must have made a silly mistake
16592>>>>>>>  //                somewhere.
16592>>>>>>>  //
16592>>>>>>>  Function sfoFormatDisk String sDrive Integer iOptions Returns DWORD
16594>>>>>>>    Handle   hWnd
16594>>>>>>>    Integer  iObj
16594>>>>>>>    DWORD    dwReturnVal
16594>>>>>>>    Integer iDrive
16594>>>>>>>
16594>>>>>>>    Function_Return 1 // STOP HERE
16595>>>>>>>
16595>>>>>>>    Move (Trim(sDrive)) To sDrive
16596>>>>>>>    If ( sDrive <> '' ) Begin
16598>>>>>>>      If ( sDrive Contains ':' ) ;        Move (Replace(':',sDrive,'')) To sDrive
16601>>>>>>>      If (Not( 'AB' Contains sDrive )) ;        Function_Return (SHFMT_NOFORMAT)
16604>>>>>>>      If ( sDrive = 'A' ) ;        Move 0 To iDrive
16607>>>>>>>      Else If ( sDrive = 'B' ) ;        Move 1 To iDrive
16611>>>>>>>      // Window_Handle Of Desktop equals to 0
16611>>>>>>>
16611>>>>>>>      Get focus Of desktop To iObj
16612>>>>>>>      If (iObj>desktop) ;          Get Container_Handle Of iObj To hWnd
16615>>>>>>>      While (hWnd=0 And iObj<>Desktop)
16619>>>>>>>          Get Parent Of iObj To iObj
16620>>>>>>>          Get Container_Handle Of iObj To hWnd
16621>>>>>>>      Loop
16622>>>>>>>>
16622>>>>>>>
16622>>>>>>>      //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
16622>>>>>>>      Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) To dwReturnVal
16623>>>>>>>    End
16623>>>>>>>>
16623>>>>>>>    Else Begin
16624>>>>>>>      Move (SHFMT_ERROR) To dwReturnVal
16625>>>>>>>    End
16625>>>>>>>>
16625>>>>>>>    Function_Return dwReturnVal
16626>>>>>>>  End_Function
16627>>>>>>>
16627>>>>>>>  //Example:
16627>>>>>>>  // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
16627>>>>>>>  //                                          mode.
16627>>>>>>>
16627>>>>>>>End_Class
16628>>>>>>>
16628>>>>>>>
16628>>>>>>>Object oShellFileOperations Is a cShellFileOperations
16630>>>>>>>End_Object
16631>>>>>>>
16631>>>>>>>
16631>>>>>>>// Restore to the old way of working with the shell file operations.
16631>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
16631>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
16631>>>>>>>Procedure vWin32fhCompatibilityMode
16633>>>>>>>  Integer hoSFO
16633>>>>>>>  Integer iFlags
16633>>>>>>>
16633>>>>>>>  Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) To iFlags
16634>>>>>>>  Move (oShellFileOperations(Self)) To hoSFO
16635>>>>>>>
16635>>>>>>>  Set piDeleteFlags Of hoSFO To iFlags
16636>>>>>>>  Set piCopyFlags   Of hoSFO To iFlags
16637>>>>>>>  Set piMoveFlags   Of hoSFO To iFlags
16638>>>>>>>  Set piRenameFlags Of hoSFO To iFlags
16639>>>>>>>End_Procedure
16640>>>>>>>
16640>>>>>>>
16640>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
16642>>>>>>>  Integer  iRetVal
16642>>>>>>>
16642>>>>>>>  Get sfoDeleteFile Of (oShellFileOperations(Self)) sFileName To iRetVal
16643>>>>>>>  Function_Return iRetVal
16644>>>>>>>End_Function
16645>>>>>>>
16645>>>>>>>
16645>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
16647>>>>>>>  Integer  iRetVal
16647>>>>>>>
16647>>>>>>>  Get sfoCopyFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
16648>>>>>>>  Function_Return iRetVal
16649>>>>>>>End_Function
16650>>>>>>>
16650>>>>>>>
16650>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
16652>>>>>>>  Integer  iRetVal
16652>>>>>>>
16652>>>>>>>  Get sfoMoveFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
16653>>>>>>>  Function_Return iRetVal
16654>>>>>>>End_Function
16655>>>>>>>
16655>>>>>>>
16655>>>>>>>// Rename a file or folder
16655>>>>>>>// Returns a nonzero value if the operation failed.
16655>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
16657>>>>>>>  Integer  iRetVal
16657>>>>>>>
16657>>>>>>>  Get sfoRenameFile Of (oShellFileOperations(Self)) sSource sDestination To iRetVal
16658>>>>>>>  Function_Return iRetVal
16659>>>>>>>End_Function
16660>>>>>>>
16660>>>>>>>
16660>>>>>>>
16660>>>>>>>Function vGetWindowsDirectory Returns String
16662>>>>>>>  String  sDirectory
16662>>>>>>>  Integer iVoid
16662>>>>>>>
16662>>>>>>>  Move (ZeroString(vMAX_PATH)) To sDirectory
16663>>>>>>>  Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) To iVoid
16664>>>>>>>  Function_Return (CString(sDirectory))
16665>>>>>>>End_Function
16666>>>>>>>
16666>>>>>>>Function vGetTempPath Returns String
16668>>>>>>>  Integer iRetval
16668>>>>>>>  String  sTempPath
16668>>>>>>>
16668>>>>>>>  Move (ZeroString(vMAX_PATH)) to sTempPath
16669>>>>>>>  Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
16670>>>>>>>  Function_Return (Cstring(sTempPath))
16671>>>>>>>End_Function
16672>>>>>>>
16672>>>>>>>
16672>>>>>>>// Courtesy of Marco Kuipers
16672>>>>>>>Function vMakeTempFile Returns String
16674>>>>>>>    Integer iRetval
16674>>>>>>>    String  sTempPath
16674>>>>>>>    String  sTempFileName
16674>>>>>>>    String  sPrefixString
16674>>>>>>>
16674>>>>>>>    Get vGetTempPath to sTempPath
16675>>>>>>>    If (sTempPath = "") Begin
16677>>>>>>>      Get vGetWindowsDirectory to sTempPath  // first fallback
16678>>>>>>>      If (sTempPath<>"") ;        Move (sTempPath+"\Temp\") to sTempPath
16681>>>>>>>    End
16681>>>>>>>>
16681>>>>>>>
16681>>>>>>>    If (sTempPath = "") Begin
16683>>>>>>>      // second fallback we really do not want to get here as to be fair using current folder as temp
16683>>>>>>>      // makes little sense. Leaving this in as it was old behavior.
16683>>>>>>>      Get_Current_Directory to sTempPath
16684>>>>>>>    End
16684>>>>>>>>
16684>>>>>>>
16684>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
16685>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
16687>>>>>>>      Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
16688>>>>>>>>
16688>>>>>>>    End
16688>>>>>>>>
16688>>>>>>>
16688>>>>>>>    Move (ZeroString(vMax_Path)) to sTempFileName
16689>>>>>>>    Move ("tmp"+character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
16690>>>>>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
16691>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
16693>>>>>>>      //Get ShowLastError to iRetval
16693>>>>>>>      Move "" to sTempFileName
16694>>>>>>>    End
16694>>>>>>>>
16694>>>>>>>
16694>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
16695>>>>>>>End_Function
16696>>>>>>>
16696>>>>>>>
16696>>>>>>>// This function creates a uniquely named temporary file in folder sPath
16696>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
16696>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
16696>>>>>>>// does not take care of that.
16696>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
16698>>>>>>>    Integer iCnt
16698>>>>>>>    Integer iRetVal
16698>>>>>>>    String sTempFileName
16698>>>>>>>
16698>>>>>>>    Move (ToAnsi(sPath)+Character(0))   To sPath
16699>>>>>>>    Move (ToAnsi(sPrefix)+Character(0)) To sPrefix
16700>>>>>>>    Move (pad("", vMAX_PATH)) To sTempFileName
16701>>>>>>>
16701>>>>>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, ;                                    AddressOf(sTempFileName))) To iRetVal
16702>>>>>>>    Move (Trim(Cstring(sTempFileName))) To sTempFileName
16703>>>>>>>    Function_Return sTempFileName
16704>>>>>>>End_Function
16705>>>>>>>
16705>>>>>>>//
16705>>>>>>>// Get a specific shell folder for example to get the desktop folder
16705>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
16705>>>>>>>//
16705>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
16707>>>>>>>  String  sFolder
16707>>>>>>>  Integer iVoid
16707>>>>>>>  Handle  hWnd
16707>>>>>>>
16707>>>>>>>  Move (Window_Handle(focus(desktop))) To hWnd
16708>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) To sFolder
16709>>>>>>>  Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) To iVoid
16710>>>>>>>  Function_Return (CString(sFolder))
16711>>>>>>>End_Function
16712>>>>>>>
16712>>>>>>>
16712>>>>>>>
16712>>>>>>>// Courtesy Of Vincent Oorsprong
16712>>>>>>>Function vConvertFileDateTime Global Dword dwLowDateTime Dword dwHighDateTime Returns String
16714>>>>>>>  String  sFormattedTime sFormattedDate
16714>>>>>>>  String  sFileDateTime
16714>>>>>>>  Integer iSuccess iLenCcTime iDataLength iLenCcDate
16714>>>>>>>  tvFileTime   FileTime
16714>>>>>>>  tvFileTime   FileTime
16714>>>>>>>  tvSystemTime SystemTime
16714>>>>>>>  tvSystemTime SystemTime
16714>>>>>>>
16714>>>>>>>  Move "" To sFileDateTime
16715>>>>>>>  Move dwLowDateTime  To FileTime.dwLowDateTime
16716>>>>>>>  Move dwHighDateTime To FileTime.dwHighDateTime
16717>>>>>>>
16717>>>>>>>  Move 0 To SystemTime.wYear
16718>>>>>>>
16718>>>>>>>  Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) To iSuccess
16719>>>>>>>  If (iSuccess = 1) Begin
16721>>>>>>>    Move (ZeroString(255))        To sFormattedTime
16722>>>>>>>    Move (Length(sFormattedTime)) To iLenCcTime
16723>>>>>>>    Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, ;                             AddressOf(sFormattedTime), iLenCcTime)) To iDataLength
16724>>>>>>>    Move (ZeroString(255))        To sFormattedDate
16725>>>>>>>    Move (Length(sFormattedDate)) To iLenCcDate
16726>>>>>>>    Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, ;                             AddressOf(sFormattedDate), iLenCcDate)) To iDataLength
16727>>>>>>>    Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) To sFileDateTime
16728>>>>>>>  End
16728>>>>>>>>
16728>>>>>>>  Function_Return sFileDateTime
16729>>>>>>>End_Function
16730>>>>>>>
16730>>>>>>>
16730>>>>>>>// **WvA:
16730>>>>>>>// A windows replacement for the standard function FileExists.
16730>>>>>>>// This version will also return (true) for a file when it is open by an application.
16730>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
16730>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
16730>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
16730>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
16732>>>>>>>  String  sDirSep
16732>>>>>>>  Handle  hFindFile
16732>>>>>>>  Integer iVoid
16732>>>>>>>  tvWin32FindData FindData
16732>>>>>>>  tvWin32FindData FindData
16732>>>>>>>
16732>>>>>>>  Move vINVALID_HANDLE_VALUE To hFindFile
16733>>>>>>>  Move (ToANSI(trim(sFilePathMask))) To sFilePathMask
16734>>>>>>>
16734>>>>>>>  If (length(sFilePathMask)>0) Begin
16736>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
16736>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
16737>>>>>>>    While (Right(sFilePathMask, 1) = sDirSep)
16741>>>>>>>      Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
16742>>>>>>>    Loop
16743>>>>>>>>
16743>>>>>>>
16743>>>>>>>    Move 0 To FindData.dwReserved0        // initialize the variable so we can get an address from it.
16744>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) To hFindFile
16745>>>>>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
16746>>>>>>>  End
16746>>>>>>>>
16746>>>>>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
16747>>>>>>>End_Function
16748>>>>>>>
16748>>>>>>>//
16748>>>>>>>// WideChar version of the function, do not use, it's an experiment
16748>>>>>>>//
16748>>>>>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
16750>>>>>>>  Handle  hFindFile
16750>>>>>>>  Integer iVoid
16750>>>>>>>  tvWin32FindData FindData
16750>>>>>>>  tvWin32FindData FindData
16750>>>>>>>
16750>>>>>>>  Move vINVALID_HANDLE_VALUE To hFindFile
16751>>>>>>>
16751>>>>>>>  If (length(sFilePathMask)>0) Begin
16753>>>>>>>
16753>>>>>>>    Move 0 To FindData.dwReserved0        // initialize the variable so we can get an address from it.
16754>>>>>>>    Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) To hFindFile
16755>>>>>>>    Move (vWin32_FindClose (hFindFile)) To iVoid
16756>>>>>>>  End
16756>>>>>>>>
16756>>>>>>>  Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
16757>>>>>>>End_Function
16758>>>>>>>
16758>>>>>>>
16758>>>>>>>
16758>>>>>>>// **WvA
16758>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
16758>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
16758>>>>>>>// The folder may contain a drive letter or UNC encoding.
16758>>>>>>>Function vFolderFormat Global String sFolderName Returns String
16760>>>>>>>  String sDirSep
16760>>>>>>>  Move (sysconf(SYSCONF_DIR_SEPARATOR)) To sDirSep  // normally \ (backslash)
16761>>>>>>>  Move (Trim(sFolderName)) To sFolderName
16762>>>>>>>  If (Right(sFolderName,1)<>sDirSep) Begin
16764>>>>>>>    Move (sFolderName+sDirSep) To sFolderName
16765>>>>>>>  End
16765>>>>>>>>
16765>>>>>>>  Function_Return sFolderName
16766>>>>>>>End_Function
16767>>>>>>>
16767>>>>>>>//
16767>>>>>>>// Returns the amount of files in the folder (if it exists)
16767>>>>>>>// Returns -1 if folder doesn't exist.
16767>>>>>>>// The files "." and ".." are not counted.
16767>>>>>>>//
16767>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
16769>>>>>>>  Boolean bFound
16769>>>>>>>  Handle  hFindFile
16769>>>>>>>  Integer iCount  iVoid
16769>>>>>>>  Integer iSuccess
16769>>>>>>>  String  sFileName
16769>>>>>>>  tvWin32FindData FindData
16769>>>>>>>  tvWin32FindData FindData
16769>>>>>>>
16769>>>>>>>  Move -1 To iCount
16770>>>>>>>  Get vFolderFormat sFolderName To sFolderName
16771>>>>>>>  Move (sFolderName+"*") To sFolderName // match any filename in the folder
16772>>>>>>>  Move 0 To FindData.dwReserved0        // initialize the variable so we can get an address from it.
16773>>>>>>>  Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) To hFindFile
16774>>>>>>>  Move (hFindFile<>vINVALID_HANDLE_VALUE) To bFound
16775>>>>>>>  If (bFound) Begin
16777>>>>>>>    Move 0 To iCount
16778>>>>>>>  End
16778>>>>>>>>
16778>>>>>>>  While (bFound)
16782>>>>>>>    Increment iCount
16783>>>>>>>    Move (UCharArrayToString(FindData.cFileName)) To sFileName
16784>>>>>>>    If (sFileName="." or sFileName="..") ;       Decrement iCount
16787>>>>>>>    Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) To iSuccess
16788>>>>>>>    Move (iSuccess<>0) To bFound
16789>>>>>>>  Loop
16790>>>>>>>>
16790>>>>>>>  Move (vWin32_FindClose (hFindFile)) To iVoid
16791>>>>>>>  Function_Return iCount
16792>>>>>>>End_Function
16793>>>>>>>
16793>>>>>>>
16793>>>>>>>//
16793>>>>>>>// Gets the parent path of the currently supplied path
16793>>>>>>>// Returns "" when we are at the root folder.
16793>>>>>>>//
16793>>>>>>>Function vParentPath Global String sPath Returns String
16795>>>>>>>  String sStrip
16795>>>>>>>
16795>>>>>>>  Move (Trim(sPath)) To sPath
16796>>>>>>>  If (Right(sPath,1)="\") Begin
16798>>>>>>>    Move (Left(sPath,Length(sPath)-1)) To sPath
16799>>>>>>>  End
16799>>>>>>>>
16799>>>>>>>  If (Pos("\",sPath)) Begin
16801>>>>>>>    Move (StringFromRightOfChar(sPath,"\")) To sStrip
16802>>>>>>>    Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
16803>>>>>>>  End
16803>>>>>>>>
16803>>>>>>>  Else Begin
16804>>>>>>>    Move "" To sPath
16805>>>>>>>  End
16805>>>>>>>>
16805>>>>>>>  Function_Return sPath
16806>>>>>>>End_Function
16807>>>>>>>
16807>>>>>>>// Create the folder, including intermediate directories.
16807>>>>>>>// Don't panic if the folder already exists.
16807>>>>>>>// Michael Mullan June 2009.
16807>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
16809>>>>>>>  String  sFolder sSA
16809>>>>>>>  Integer iRetval iFolderCreated
16809>>>>>>>  tvSecurity_attributes SA
16809>>>>>>>  tvSecurity_attributes SA
16809>>>>>>>
16809>>>>>>>  Move 0 to iFolderCreated
16810>>>>>>>
16810>>>>>>>  // null MAX_PATH chars into var (make space)
16810>>>>>>>  Move (Repeat(Character(0), vMAX_PATH)) to sFolder
16811>>>>>>>  If (sNewFolder <> "") Begin
16813>>>>>>>
16813>>>>>>>    Move (SizeOfType(tvSecurity_attributes)) To SA.nLength
16814>>>>>>>    Move  0  To SA.lpDescriptor
16815>>>>>>>    Move  1  To SA.bInheritHandle
16816>>>>>>>
16816>>>>>>>    //
16816>>>>>>>    Move (sNewFolder+"") to sFolder
16817>>>>>>>    Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
16818>>>>>>>  End
16818>>>>>>>>
16818>>>>>>>
16818>>>>>>>  If (iFolderCreated <> 0) Begin
16820>>>>>>>    Move 1 to iRetVal
16821>>>>>>>    Case Begin
16821>>>>>>>      Case (iFolderCreated = 161)
16823>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
16824>>>>>>>>
16824>>>>>>>        Case Break
16825>>>>>>>      Case (iFolderCreated = 206)
16828>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
16829>>>>>>>>
16829>>>>>>>        Case Break
16830>>>>>>>      Case (iFolderCreated = 3)
16833>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
16834>>>>>>>>
16834>>>>>>>        Case Break
16835>>>>>>>      Case (iFolderCreated = 80)
16838>>>>>>>        Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
16839>>>>>>>        Case Break
16840>>>>>>>      Case (iFolderCreated = 183)
16843>>>>>>>        Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
16844>>>>>>>        Case Break
16845>>>>>>>      Case (iFolderCreated = 1223)
16848>>>>>>>        Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
16849>>>>>>>>
16849>>>>>>>        Case Break
16850>>>>>>>      Case Else
16850>>>>>>>        Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
16851>>>>>>>>
16851>>>>>>>    Case End
16851>>>>>>>  End
16851>>>>>>>>
16851>>>>>>>  Function_Return iRetVal
16852>>>>>>>End_Function
16853>>>>>>>
16853>>>>>>>
16853>>>>>>>Function vWin32_APIFileSize Global string sFileName returns integer
16855>>>>>>>  DWord   dwFileSizeHigh dwFileSizeLow
16855>>>>>>>  Integer iFileSize iVoid
16855>>>>>>>  Handle  hFindFile
16855>>>>>>>  tvWin32FindData FindData
16855>>>>>>>  tvWin32FindData FindData
16855>>>>>>>
16855>>>>>>>  Move (sFileName+"") To sFileName
16856>>>>>>>  Move 0 To FindData.dwReserved0        // initialize the variable so we can get an address from it.
16857>>>>>>>  Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
16858>>>>>>>  If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
16860>>>>>>>    Move FindData.nFileSizeHigh To dwFileSizeHigh
16861>>>>>>>    Move FindData.nFileSizeLow  To dwFileSizeLow
16862>>>>>>>  End
16862>>>>>>>>
16862>>>>>>>  Move (vWin32_FindClose (hFindFile)) to iVoid
16863>>>>>>>  Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
16864>>>>>>>
16864>>>>>>>  Function_return iFileSize
16865>>>>>>>End_Function
16866>>>>>>>
16866>>>>>>>//
16866>>>>>>>// Based on code in Peter Crook's Browse folder workspace
16866>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
16866>>>>>>>//
16866>>>>>>>//=============================================================================
16866>>>>>>>// Verifies that a path is a valid directory.
16866>>>>>>>//
16866>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
16866>>>>>>>//
16866>>>>>>>// Parameters:
16866>>>>>>>//      sPath - Address of the path to verify.
16866>>>>>>>//=============================================================================
16866>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
16868>>>>>>>   Integer iResult
16868>>>>>>>   Boolean bRetVal
16868>>>>>>>
16868>>>>>>>   Move false To bRetVal
16869>>>>>>>   Move (ToAnsi(sPath) - Character (0)) to sPath
16870>>>>>>>   Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
16871>>>>>>>   If (iResult<>0) ;     Move True To bRetVal
16874>>>>>>>
16874>>>>>>>   Function_Return bRetVal
16875>>>>>>>End_Function
16876>>>>>>>
16876>>>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\DUFLanguageConstants.inc)
16876>>>>>>>//
16876>>>>>>>// *** The Database Update Framework Include file ***
16876>>>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
16876>>>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
16876>>>>>>>//
16876>>>>>>>//
16876>>>>>>>Use LanguageText.Pkg
16876>>>>>>>
16876>>>>>>>// *** cSQLConnectionsIniFile Class Language Constants ***
16876>>>>>>>//
16876>>>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
16876>>>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>// *** cSQLConnectionsHandler Class Language Constants ***
16876>>>>>>>//
16876>>>>>>>    Define CS_DUF_SetupErrorcConnection  for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
16876>>>>>>>    Define CS_DUF_CannotLoginToServer    for "Could not login to the database server. Can't continue. Program will now exit."
16876>>>>>>>    Define CS_DUF_ErrorText              for "\n\nError Text:"
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>// *** cDbUpdateFunctionLibrary Class Language Constants ***
16876>>>>>>>//
16876>>>>>>>    Define CS_SQLConnectError       for "SQL error. Could not connect to the SQL database manager"
16876>>>>>>>    Define CS_SQLAttachError        for "Could not attach to the database:"
16876>>>>>>>    Define CS_SQLDeletingIndex      for "Deleting index"
16876>>>>>>>    Define CS_SQLCopyingData        for "Copying data"
16876>>>>>>>    Define CS_SQLCreatingIndex      for "Creating index"
16876>>>>>>>    Define CS_DUF_LoginToDbServerFailed for  "Login failed to the database server. The following connect string was used:\n"
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>// *** cDbUpdateVersion Class Language Constants ***
16876>>>>>>>//
16876>>>>>>>    Define CS_UpdateVersion     for "Updating database"
16876>>>>>>>    Define CS_UpdateFromVersion for "from version"
16876>>>>>>>    Define CS_UpdateToVersion   for "to version:"
16876>>>>>>>    Define CS_DbUpdateTableMissing for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>// *** cDbUpdateHandler.inc Class Language Constants ***
16876>>>>>>>//
16876>>>>>>>    Define CS_DatabaseInUseShort  for "There are others using the application/database. Are you sure you still want to update the database?"
16876>>>>>>>    Define CS_DatabaseNeedsUpdate for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
16876>>>>>>>    Define CS_HeaderUpdateText    for "Important!"
16876>>>>>>>    Define CS_DatabaseInUseText   for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
16876>>>>>>>    Define CS_WorkingHeaderText   for "Working!"
16876>>>>>>>    Define CS_WorkingUpdateText   for "The database is being updated. Please wait..."
16876>>>>>>>    Define CS_DatabaseUpdatedText for "Ready! The database was updated."
16876>>>>>>>    Define CS_DatabaseCheckedText for "Ready! The database was checked but no updates was needed."
16876>>>>>>>    Define CS_DbUpdatedErrorText  for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
16876>>>>>>>    Define CS_UpdateInProgressTxt for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>>>
16876>>>>>
16876>>>>>Struct tDbVersionInfo
16876>>>>>    Number nVersionNumber
16876>>>>>    Handle hObject
16876>>>>>End_Struct
16876>>>>>
16876>>>>>Struct tDbUpdateError
16876>>>>>    Number nUpdateVersion
16876>>>>>    Integer iError
16876>>>>>    String  sErrorText
16876>>>>>    Integer iErrorLine
16876>>>>>    Boolean bError  
16876>>>>>    Handle  hTable
16876>>>>>    Integer iField
16876>>>>>    Boolean bShortFormat
16876>>>>>End_Struct
16876>>>>>
16876>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
16876>>>>>//  DF_FILE_IS_MASTER if master
16876>>>>>//  DF_FILE_IS_ALIAS if alias
16876>>>>>Struct tDbUpdateHandlerMasterAlias
16876>>>>>    Handle hTable
16876>>>>>    Integer iMode
16876>>>>>End_Struct
16876>>>>>
16876>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
16876>>>>>Enumeration_List
16876>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
16876>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
16876>>>>>End_Enumeration_List
16876>>>>>
16876>>>>>    Define DATAFLEX_ID for "DATAFLEX"
16876>>>>>
16876>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
16876>>>>>// communicate with the object from anywhere in a program.
16876>>>>>    Global_Variable Handle ghoDbUpdateHandler
16876>>>>>
16876>>>>>// NOTE: If the DbVersion table should _not_ be used and you
16876>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
16876>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
16876>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
16876>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
16876>>>>>//    Declare_Datafile DbVersion
16876>>>>>//#ENDIF
16876>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateLogFile.pkg)
16876>>>>>//****************************************************************************
16876>>>>>// $Module type: Class
16876>>>>>// $Module name: cDbUpdateLogFile
16876>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
16876>>>>>// Web-site    : http://www.rdctools.com
16876>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
16876>>>>>//
16876>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
16876>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
16876>>>>>//               that this class is to change; each developer can decide if the errors instead
16876>>>>>//               should be saved to a database table, or something entirely different.
16876>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
16876>>>>>//
16876>>>>>// $Rev History:
16876>>>>>//    2016-10-05  Module header created
16876>>>>>//****************************************************************************
16876>>>>>Use UI
16876>>>>>Use vWin32fh.pkg
16876>>>>>
16876>>>>>
16876>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
16876>>>>>
16876>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
16876>>>>>
16876>>>>>Class cDbUpdateLogFile is a cObject
16877>>>>>
16877>>>>>    Procedure Construct_Object
16879>>>>>        Forward Send Construct_Object
16881>>>>>
16881>>>>>        // Error handling:
16881>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
16882>>>>>        Property Integer piChannel -1
16883>>>>>
16883>>>>>        // This property is set by the cDbUpdateHandler object,
16883>>>>>        // when the update process starts.
16883>>>>>        Property DateTime pdtUpdateStart
16884>>>>>
16884>>>>>        // Gets set to False if the log contains data
16884>>>>>        Property Boolean pbEmptyLogFile True
16885>>>>>        
16885>>>>>        // Gets set to True after the error log header text
16885>>>>>        // has been written.
16885>>>>>        Property Boolean pbHeaderWritten False
16886>>>>>
16886>>>>>        // If all activities should be logged- not just errors.
16886>>>>>        Property Boolean pbVerboseState False
16887>>>>>
16887>>>>>        // File name for the error log where all errors
16887>>>>>        // after a run is written to (appended).
16887>>>>>        // It is saved in the Data folder.
16887>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
16888>>>>>        // If this property is set to "" in object code, the
16888>>>>>        // "shell" command parameter will be used to let Windows decide
16888>>>>>        // with which program to open the logfile.
16888>>>>>        Property String psEditorProgram ""
16889>>>>>
16889>>>>>        Property Boolean pbUseDataTableLog False
16890>>>>>
16890>>>>>        // If true an error will be written to file immediately when
16890>>>>>        // it occurs. This can be handy if a large update generates a lots
16890>>>>>        // of errors and the application crasches before finished, thus
16890>>>>>        // the errors will not be written.
16890>>>>>        Property Boolean pbQuickWrite True
16891>>>>>    End_Procedure
16892>>>>>
16892>>>>>    Procedure End_Construct_Object
16894>>>>>        Forward Send End_Construct_Object
16896>>>>>
16896>>>>>    End_Procedure
16897>>>>>
16897>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
16899>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
16899>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
16901>>>>>        Boolean bQuickWrite bShortFormat
16901>>>>>        Integer iSize
16901>>>>>        Handle hCurrentTable
16901>>>>>        Integer iCurrentField
16901>>>>>        
16901>>>>>        Move False to bShortFormat
16902>>>>>        If (num_arguments > 5) Begin
16904>>>>>            Move bShortFormatIn to bShortFormat
16905>>>>>        End
16905>>>>>>
16905>>>>>        // Only do once.
16905>>>>>        If (pbHeaderWritten(Self) = False) Begin
16907>>>>>            Send WriteHeaderData
16908>>>>>            Set pbHeaderWritten to True
16909>>>>>        End
16909>>>>>>
16909>>>>>
16909>>>>>        Get Private.phCurrentTable to hCurrentTable
16910>>>>>        Get Private.piCurrentField to iCurrentField
16911>>>>>
16911>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
16912>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
16913>>>>>        Move nVersion      to DbUpdateErrorArray[iSize].nUpdateVersion
16914>>>>>        Move iError        to DbUpdateErrorArray[iSize].iError
16915>>>>>        Move iErrorLine    to DbUpdateErrorArray[iSize].iErrorLine
16916>>>>>        Move True          to DbUpdateErrorArray[iSize].bError
16917>>>>>        Move sErrorText    to DbUpdateErrorArray[iSize].sErrorText
16918>>>>>        Move hCurrentTable to DbUpdateErrorArray[iSize].hTable
16919>>>>>        Move iCurrentField to DbUpdateErrorArray[iSize].iField  
16920>>>>>        Move bShortFormat  to DbUpdateErrorArray[iSize].bShortFormat
16921>>>>>
16921>>>>>        If (bError = False) Begin
16923>>>>>            Move False to DbUpdateErrorArray[iSize].bError
16924>>>>>        End
16924>>>>>>
16924>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
16925>>>>>
16925>>>>>        If (pbUseDataTableLog(Self) = True) Begin
16927>>>>>            If (pbQuickWrite(Self) = True) Begin
16929>>>>>                Send OnWriteRow_DataTable
16930>>>>>                // If we are writing error for error flush the
16930>>>>>                // error array when latest error has been written.
16930>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
16931>>>>>            End
16931>>>>>>
16931>>>>>            Procedure_Return
16932>>>>>        End
16932>>>>>>
16932>>>>>        Else Begin
16933>>>>>            If (pbQuickWrite(Self) = True) Begin
16935>>>>>                Send WriteErrorLog
16936>>>>>                // Flush the error log array
16936>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
16937>>>>>            End
16937>>>>>>
16937>>>>>        End
16937>>>>>>
16937>>>>>
16937>>>>>    End_Procedure
16938>>>>>
16938>>>>>    // Hook procedure for writing header text prior starting the update work to
16938>>>>>    // a database table. This does nothing by default.
16938>>>>>    // Don't forget to Open your "error log table" first (!) as all
16938>>>>>    // tables have been closed at this stage. Put anything
16938>>>>>    // you want to indicate that the update process is just started.
16938>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
16940>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
16942>>>>>    End_Procedure
16943>>>>>
16943>>>>>    Procedure OnWriteRow_DataTable
16945>>>>>        tDbUpdateError[] DbUpdateErrorArray
16945>>>>>        tDbUpdateError[] DbUpdateErrorArray
16946>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
16947>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
16949>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
16951>>>>>        End
16951>>>>>>
16951>>>>>    End_Procedure
16952>>>>>
16952>>>>>    Function psLogTextFileWithPath Returns String
16954>>>>>        String sPath sFileName sFullFileName
16954>>>>>        
16954>>>>>        Get psDataPathFirstPart to sPath
16955>>>>>        Get psLogTextFile to sFileName
16956>>>>>        Move (sPath + sFileName) to sFullFileName
16957>>>>>        Function_Return sFullFileName
16958>>>>>    End_Function                     
16959>>>>>    
16959>>>>>    Procedure WriteHeaderData
16961>>>>>        String sPath sFileName
16961>>>>>        Integer iCh iSize
16961>>>>>        Boolean bQuickWrite
16961>>>>>        DateTime dtUpdateStart
16961>>>>>
16961>>>>>        Move (CurrentDateTime()) to dtUpdateStart
16962>>>>>        If (pbUseDataTableLog(Self) = True) Begin
16964>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
16965>>>>>            Procedure_Return
16966>>>>>        End
16966>>>>>>
16966>>>>>
16966>>>>>        Get piChannel to iCh
16967>>>>>        If (iCh < 0) Begin
16969>>>>>            Get Seq_New_Channel to iCh
16970>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
16972>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
16973>>>>>>
16973>>>>>                Procedure_Return
16974>>>>>            End
16974>>>>>>
16974>>>>>            Set piChannel to iCh
16975>>>>>        End
16975>>>>>>
16975>>>>>
16975>>>>>        Get psLogTextFileWithPath to sFileName
16976>>>>>        Get vWin32_APIFileSize sFileName to iSize
16977>>>>>        Get pbQuickWrite to bQuickWrite
16978>>>>>        
16978>>>>>        If (bQuickWrite = True) Begin
16980>>>>>            Append_Output channel iCh sFileName
16982>>>>>                If (bQuickWrite = True) Begin
16984>>>>>                    If (iSize = 0) Begin
16986>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
16989>>>>>                        Set pbEmptyLogFile to False
16990>>>>>                    End
16990>>>>>>
16990>>>>>                    Writeln channel iCh
16992>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
16995>>>>>                End
16995>>>>>>
16995>>>>>            Close_Output channel iCh
16997>>>>>        End
16997>>>>>>
16997>>>>>    End_Procedure
16998>>>>>
16998>>>>>    // Returns the first datapath found in the psDataPath property.
16998>>>>>    // The returned path always ends with a "\"
16998>>>>>    Function psDataPathFirstPart Returns String
17000>>>>>        String sDataPath
17000>>>>>        Integer iCount
17000>>>>>
17000>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
17001>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
17002>>>>>        If (iCount > 1) Begin
17004>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
17005>>>>>        End
17005>>>>>>
17005>>>>>        If (sDataPath <> "") Begin
17007>>>>>            Get vFolderFormat sDataPath to sDataPath
17008>>>>>        End
17008>>>>>>
17008>>>>>
17008>>>>>        Function_Return sDataPath
17009>>>>>    End_Function
17010>>>>>
17010>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
17010>>>>>    Procedure WriteErrorLog
17012>>>>>        tDbUpdateError[] aDbUpdateErrorArray
17012>>>>>        tDbUpdateError[] aDbUpdateErrorArray
17013>>>>>        String sPath sFileName sErrorNo sVersion sErrorText sText
17013>>>>>        Integer iCount iSize iCh iError iErrorLine iField
17013>>>>>        Boolean bUseDataTable bQuickWrite bError
17013>>>>>        DateTime dtUpdateStart dtUpdateEnd
17013>>>>>        TimeSpan tsElapsed
17013>>>>>        Number nVersion                                  
17013>>>>>        Handle hTable
17013>>>>>
17013>>>>>        If (pbHeaderWritten(Self) = False) Begin
17015>>>>>            Send WriteHeaderData
17016>>>>>            Set pbHeaderWritten to True
17017>>>>>        End
17017>>>>>>
17017>>>>>
17017>>>>>        Get pbUseDataTableLog to bUseDataTable
17018>>>>>        If (bUseDataTable = True) Begin
17020>>>>>            Send OnWriteRow_DataTable
17021>>>>>            Procedure_Return
17022>>>>>        End
17022>>>>>>
17022>>>>>
17022>>>>>        Get piChannel to iCh
17023>>>>>        If (iCh < 0) Begin
17025>>>>>            Get Seq_New_Channel to iCh
17026>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
17028>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
17029>>>>>>
17029>>>>>                Procedure_Return
17030>>>>>            End
17030>>>>>>
17030>>>>>            Set piChannel to iCh
17031>>>>>        End
17031>>>>>>
17031>>>>>
17031>>>>>        Get psLogTextFileWithPath to sFileName
17032>>>>>
17032>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
17033>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
17034>>>>>        Decrement iSize
17035>>>>>
17035>>>>>        Get pdtUpdateStart to dtUpdateStart
17036>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
17038>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
17039>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
17040>>>>>        End
17040>>>>>>
17040>>>>>        Get pbQuickWrite to bQuickWrite
17041>>>>>
17041>>>>>        Append_Output channel iCh sFileName
17043>>>>>        If (bQuickWrite = True and iSize < 0) Begin
17045>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
17048>>>>>        End
17048>>>>>>
17048>>>>>        Else If (bQuickWrite = False) Begin
17051>>>>>            Writeln channel iCh
17053>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
17056>>>>>        End   
17056>>>>>>
17056>>>>>        If (iSize >= 0) Begin
17058>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
17060>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
17063>>>>>            End
17063>>>>>>
17063>>>>>        End
17063>>>>>>
17063>>>>>
17063>>>>>        For iCount from 0 to iSize  
17069>>>>>>
17069>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
17070>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
17071>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
17072>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
17073>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
17074>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
17075>>>>>            
17075>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
17076>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
17078>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
17079>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table.Field:" * String(hTable) + "." + String(iField) + ")") to sText
17080>>>>>            End
17080>>>>>>
17080>>>>>            Else Begin
17081>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
17082>>>>>                Move (sVersion + "   " + sErrorText) to sText
17083>>>>>            End
17083>>>>>>
17083>>>>>            Writeln channel iCh sText
17086>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
17088>>>>>                Writeln channel iCh
17090>>>>>            End
17090>>>>>>
17090>>>>>        Loop
17091>>>>>>
17091>>>>>        Close_Output channel iCh
17093>>>>>
17093>>>>>        Send Seq_Release_Channel iCh
17094>>>>>        Set piChannel to -1
17095>>>>>
17095>>>>>    End_Procedure
17096>>>>>
17096>>>>>    // The character to pad is optional. If nothing, spaces are used.
17096>>>>>    // Example:
17096>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
17096>>>>>    //  or:
17096>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
17096>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
17096>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
17098>>>>>        String sChar
17098>>>>>
17098>>>>>        If (Num_Arguments >= 3) Begin
17100>>>>>            Move sOptChar to sChar
17101>>>>>        End
17101>>>>>>
17101>>>>>        Else Begin
17102>>>>>            Move " " to sChar
17103>>>>>        End
17103>>>>>>
17103>>>>>
17103>>>>>        While (Length(sString) < iLength)
17107>>>>>            Move (sChar + sString) to sString
17108>>>>>        Loop
17109>>>>>>
17109>>>>>
17109>>>>>        Function_Return sString
17110>>>>>    End_Function
17111>>>>>
17111>>>>>    Procedure ShowErrorLog
17113>>>>>        String sPath sFileName sEditorProgram
17113>>>>>        Boolean bExists
17113>>>>>
17113>>>>>        Get psLogTextFileWithPath to sFileName
17114>>>>>        Get vFilePathExists sFileName to bExists
17115>>>>>        If (bExists = True) Begin
17117>>>>>            Get psEditorProgram to sEditorProgram
17118>>>>>            If (sEditorProgram <> "") Begin
17120>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
17121>>>>>            End
17121>>>>>>
17121>>>>>            Else Begin
17122>>>>>                Runprogram Shell Background sFileName
17123>>>>>            End
17123>>>>>>
17123>>>>>        End
17123>>>>>>
17123>>>>>        Else Begin
17124>>>>>            Send Info_Box ("Could not locate the log file:\n\n" + String(sFileName))
17125>>>>>        End
17125>>>>>>
17125>>>>>    End_Procedure
17126>>>>>
17126>>>>>End_Class
17127>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateVersion.pkg)
17127>>>>>//****************************************************************************
17127>>>>>// $Module type: Class
17127>>>>>// $Module name: cDbUpdateVersion
17127>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
17127>>>>>// Web-site    : http://www.rdctools.com
17127>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
17127>>>>>//
17127>>>>>// Description : Child class to cDbUpdateHandler.
17127>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
17127>>>>>//               Set the pnVersionNumber to a version number.
17127>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
17127>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
17127>>>>>//               Place your code in the "OnUpdate" event that alters the database.
17127>>>>>//
17127>>>>>// $Rev History:
17127>>>>>//    2016-09-27  Module header created
17127>>>>>//****************************************************************************
17127>>>>>Use UI
17127>>>>>Use DUFLanguageConstants.inc
17127>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary.pkg)
17127>>>>>>>//****************************************************************************
17127>>>>>>>// $Module type: Class
17127>>>>>>>// $Module name: cDbUpdateFunctionLibrary
17127>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
17127>>>>>>>// Web-site    : http://www.rdctools.com
17127>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
17127>>>>>>>//
17127>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
17127>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
17127>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
17127>>>>>>>//               with the help of Sql-scripts.
17127>>>>>>>//
17127>>>>>>>// $Rev History:
17127>>>>>>>//    2014-09-05  Module header created
17127>>>>>>>//
17127>>>>>>>//****************************************************************************
17127>>>>>>>Use cApplication.pkg
17127>>>>>>>Use seq_chnl.pkg
17127>>>>>>>Use GlobalFunctionsProcedures.pkg
17127>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
17127>>>>>>>Use Dfcursor.pkg
Including file: Dfcursor.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dfcursor.pkg)
17127>>>>>>>>>//  create a desktop object named Cursor_control that understands
17127>>>>>>>>>//   Send Cursor_Wait to (cursor_Control(self))
17127>>>>>>>>>//            creates hourclass cursor
17127>>>>>>>>>//   Send Cursor_ready to (cursor_Control(self))
17127>>>>>>>>>//            restores regular cursor
17127>>>>>>>>>//
17127>>>>>>>>>Use Cursor.pkg
Including file: Cursor.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Cursor.pkg)
17127>>>>>>>>>>>Use Windows.pkg
17127>>>>>>>>>>>Use WinUser.pkg
17127>>>>>>>>>>>
17127>>>>>>>>>>>// Standard Cursor IDs
17127>>>>>>>>>>>
17127>>>>>>>>>>>
17127>>>>>>>>>>>
17127>>>>>>>>>>>
17127>>>>>>>>>>>
17127>>>>>>>>>>>Class CursorShape is a DFBaseToolPanel //BasicPanel
17128>>>>>>>>>>>    
17128>>>>>>>>>>>    Procedure Construct_Object
17130>>>>>>>>>>>        Property Handle ClassCursorHandle 0
17131>>>>>>>>>>>        Set Visible_State to False
17132>>>>>>>>>>>        Set Size to 1 1
17133>>>>>>>>>>>    End_Procedure
17134>>>>>>>>>>>    
17134>>>>>>>>>>>    Procedure Set Cursor Integer CursorType
17136>>>>>>>>>>>        Handle CursorID hWnd
17136>>>>>>>>>>>        Longptr retval lpCursorType
17136>>>>>>>>>>>        Get Window_Handle to hWnd
17137>>>>>>>>>>>        If (CursorType = 0) Begin
17139>>>>>>>>>>>            Send Release_Mouse_Capture
17140>>>>>>>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, ClassCursorHandle(Self))) to retval
17141>>>>>>>>>>>            Set ClassCursorHandle to 0
17142>>>>>>>>>>>            Send Page_Object False
17143>>>>>>>>>>>        End
17143>>>>>>>>>>>>
17143>>>>>>>>>>>        Else Begin
17144>>>>>>>>>>>            Send Page_Object True
17145>>>>>>>>>>>            Get Window_Handle to hWnd
17146>>>>>>>>>>>            If (ClassCursorHandle(Self) = 0) ;                Set ClassCursorHandle to (GetClassLongPtr(hWnd, GCL_HCURSOR))
17149>>>>>>>>>>>            
17149>>>>>>>>>>>            Move CursorType to lpCursorType    // Move to Longptr type to avoid conversion from integer to pointer in the next line
17150>>>>>>>>>>>            Move (LoadCursor(0,lpCursorType)) to CursorID
17151>>>>>>>>>>>            
17151>>>>>>>>>>>            Move (SetClassLongPtr(hWnd, GCL_HCURSOR, CursorID )) to retval
17152>>>>>>>>>>>            Move (SetCursor(CursorID)) to retval
17153>>>>>>>>>>>            Send Set_Mouse_Capture
17154>>>>>>>>>>>        End
17154>>>>>>>>>>>>
17154>>>>>>>>>>>    End_Procedure
17155>>>>>>>>>>>    
17155>>>>>>>>>>>    Procedure Mouse_Up
17157>>>>>>>>>>>        Handle retval
17157>>>>>>>>>>>        Send Set_Mouse_Capture
17158>>>>>>>>>>>        Move (SetCursor(GetClassLongPtr(Window_Handle(Self), GCL_HCURSOR))) to retval
17159>>>>>>>>>>>    End_Procedure
17160>>>>>>>>>>>    
17160>>>>>>>>>>>    Procedure Cursor_Wait
17162>>>>>>>>>>>        Set cursor to IDC_WAIT
17163>>>>>>>>>>>    End_Procedure
17164>>>>>>>>>>>    
17164>>>>>>>>>>>    Procedure Cursor_Ready
17166>>>>>>>>>>>        Set cursor to 0
17167>>>>>>>>>>>    End_Procedure
17168>>>>>>>>>>>    
17168>>>>>>>>>>>    
17168>>>>>>>>>>>End_Class
17169>>>>>>>>>
17169>>>>>>>>>Object Cursor_Control is a CursorShape
17171>>>>>>>>>End_Object
17172>>>>>>>>>
17172>>>>>>>Use DUFStatusPanel.pkg
17172>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
17172>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
17172>>>>>>>>>//
17172>>>>>>>>>// We need to create a mixin class for the library.
17172>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
17172>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
17172>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
17172>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
17172>>>>>>>>>//
17172>>>>>>>>>Use VdfBase.pkg
17172>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinUuid.pkg)
17172>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
17173>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
17174>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
17175>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
17176>>>>>>>>>>>
17176>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
17176>>>>>>>>>>>Function RandomHexUUID Global Returns String
17178>>>>>>>>>>>    Address pUUID pUUIDStr
17178>>>>>>>>>>>    Integer iRetval iOffset iChar
17178>>>>>>>>>>>    String sUUID sKey
17178>>>>>>>>>>>    
17178>>>>>>>>>>>    Move (Alloc(16)) to pUUID
17179>>>>>>>>>>>    
17179>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
17180>>>>>>>>>>>    
17180>>>>>>>>>>>    If (iRetval = 0) Begin
17182>>>>>>>>>>>        Move 0 to pUUIDStr
17183>>>>>>>>>>>        
17183>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
17184>>>>>>>>>>>        If (iRetval = 0) Begin
17186>>>>>>>>>>>            Move pUUIDStr to sUUID
17187>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
17188>>>>>>>>>>>            
17188>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
17189>>>>>>>>>>>        End
17189>>>>>>>>>>>>
17189>>>>>>>>>>>    End
17189>>>>>>>>>>>>
17189>>>>>>>>>>>    
17189>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
17190>>>>>>>>>>>    
17190>>>>>>>>>>>    Function_Return sUUID
17191>>>>>>>>>>>End_Function
17192>>>>>>>>>>>
17192>>>>>>>>>>>
17192>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
17192>>>>>>>>>>>Function SeqHexUUID Global Returns String
17194>>>>>>>>>>>    Address pUUID pUUIDStr
17194>>>>>>>>>>>    Integer iRetval iOffset iChar
17194>>>>>>>>>>>    String sUUID sKey
17194>>>>>>>>>>>    
17194>>>>>>>>>>>    Move (Alloc(16)) to pUUID
17195>>>>>>>>>>>    
17195>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
17196>>>>>>>>>>>    
17196>>>>>>>>>>>    If (iRetval = 0) Begin
17198>>>>>>>>>>>        Move 0 to pUUIDStr
17199>>>>>>>>>>>        
17199>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
17200>>>>>>>>>>>        If (iRetval = 0) Begin
17202>>>>>>>>>>>            Move pUUIDStr to sUUID
17203>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
17204>>>>>>>>>>>            
17204>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
17205>>>>>>>>>>>        End
17205>>>>>>>>>>>>
17205>>>>>>>>>>>    End
17205>>>>>>>>>>>>
17205>>>>>>>>>>>    
17205>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
17206>>>>>>>>>>>    
17206>>>>>>>>>>>    Function_Return sUUID
17207>>>>>>>>>>>End_Function
17208>>>>>>>>>Use cli.pkg
Including file: cli.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cli.pkg)
17208>>>>>>>>>>>//                                                              
17208>>>>>>>>>>>//   CLI specific functionality. There are several connectivity kits     
17208>>>>>>>>>>>//   based on  SQL/92 CLI. Those are:                                    
17208>>>>>>>>>>>//    - ODBC_DRV  The Data Access CK for ODBC                            
17208>>>>>>>>>>>//    - DB2_DRV   The Data Access CK for DB2                             
17208>>>>>>>>>>>//    - MSSQLDRV  The Data Access CK for Microsoft SQL Server            
17208>>>>>>>>>>>//                                                                       
17208>>>>>>>>>>>//   This package defines the common functionality for all CLI based     
17208>>>>>>>>>>>//   drivers.                                                            
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_FILE_TABLE_CHARACTER_FORMAT   for 601
17208>>>>>>>>>>>Define DF_FILE_MAX_ROWS_FETCHED         for 602
17208>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX_TRIGGER    for 604      // Replaced by DF_FILE_GENERATE_RECORD_ID_METHOD !
17208>>>>>>>>>>>Define DF_FILE_TRANSLATE_OEM_TO_ANSI    for 606      // Deprecated !!! Only defined for decent error reporting
17208>>>>>>>>>>>Define DF_FILE_REFIND_AFTER_SAVE        for 608
17208>>>>>>>>>>>Define DF_FILE_TABLE_NAME               for 609
17208>>>>>>>>>>>Define DF_FILE_GET_RID_AFTER_CREATE     for 610
17208>>>>>>>>>>>Define DF_FILE_SQL_FILTER               for 611
17208>>>>>>>>>>>Define DF_FILE_USE_DUMMY_ZERO_DATE      for 612
17208>>>>>>>>>>>Define DF_FILE_GENERATE_RECORD_ID_METHOD for 614
17208>>>>>>>>>>>Define DF_FILE_DUMMY_UPDATE_COLUMN      for 616
17208>>>>>>>>>>>Define DF_FILE_FETCH_ALL_COLUMNS        for 620
17208>>>>>>>>>>>Define DF_FILE_DATABASE_ID              for 622
17208>>>>>>>>>>>Define DF_FILE_SQL_FILTER_ACTIVE        for 624
17208>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS     for 626
17208>>>>>>>>>>>Define DF_FILE_BLOCK_SIZE               for 628
17208>>>>>>>>>>>Define DF_FILE_JIT_BINDING              for 630
17208>>>>>>>>>>>Define DF_FILE_FINDCACHE_HITS           for 632
17208>>>>>>>>>>>Define DF_FILE_FINDCACHE_TIMEOUTS       for 634
17208>>>>>>>>>>>Define DF_FILE_SQL_FILTER_EQ            for 636
17208>>>>>>>>>>>Define DF_FILE_RESTRUCTURE_INT_ONLY     for 638
17208>>>>>>>>>>>Define DF_FILE_ALLOWED_STRUCTURE_CHANGES for 640
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_FIELD_STORE_TIME              for 702
17208>>>>>>>>>>>Define DF_FIELD_TIME                    for 703
17208>>>>>>>>>>>Define DF_FIELD_IS_NULL                 for 704
17208>>>>>>>>>>>Define DF_FIELD_NULL_ALLOWED            for 706
17208>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE           for 707
17208>>>>>>>>>>>Define DF_FIELD_FETCH_STATE             for 708
17208>>>>>>>>>>>Define DF_FIELD_READ_ONLY               for 710
17208>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME        for 711
17208>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE             for 712
17208>>>>>>>>>>>Define DF_FIELD_NO_OEM_ANSI_TRANSLATE   for 714
17208>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN           for 716
17208>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA   for 717
17208>>>>>>>>>>>Define DF_FIELD_NATIVE_SIZE             for 718
17208>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE    for 719
17208>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN   for 721
17208>>>>>>>>>>>Define DF_FIELD_IS_IDENTITY             for 722
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_INDEX_NAME                    for 801
17208>>>>>>>>>>>Define DF_INDEX_UNIQUE                  for 802
17208>>>>>>>>>>>Define DF_INDEX_ON_BACKEND              for 804
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_INDEX_CLUSTERED               for 806
17208>>>>>>>>>>>Define DF_INDEX_SQL_PRIMARY_KEY         for 808
17208>>>>>>>>>>>Define DF_INDEX_SQL_TYPE                for 810
17208>>>>>>>>>>>Define DF_INDEX_NUMBER                  for 812
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_DATABASE_LOCK_STATE                    for 1001
17208>>>>>>>>>>>Define DF_DATABASE_ID                            for 1002
17208>>>>>>>>>>>Define DF_DATABASE_MYSQLTABLETYPE                for 1003
17208>>>>>>>>>>>Define DF_DATABASE_NUMBER_TYPES                  for 1004
17208>>>>>>>>>>>Define DF_DATABASE_TYPE_NAME                     for 1005
17208>>>>>>>>>>>Define DF_DATABASE_TYPE_ID                       for 1006
17208>>>>>>>>>>>Define DF_DATABASE_TYPE_CREATE_PARAMS            for 1007
17208>>>>>>>>>>>Define DF_DATABASE_TYPE_AUTOINC                  for 1008
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_ASCII         for 1009
17208>>>>>>>>>>>Define DF_DATABASE_TYPE_UNSIGNED                 for 1010
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_NUMERIC       for 1011
17208>>>>>>>>>>>Define DF_DATABASE_TYPE_MAXSIZE                  for 1012
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATE          for 1013
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_ASCII        for 1014
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_TEXT          for 1015
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_NUMERIC      for 1016
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_BINARY        for 1017
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATE         for 1018
17208>>>>>>>>>>>Define DF_DATABASE_DUMMY_ZERO_DATE_VALUE         for 1019
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_TEXT         for 1020
17208>>>>>>>>>>>Define DF_DATABASE_DUPREC_STATE                  for 1021
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_BINARY       for 1022
17208>>>>>>>>>>>Define DF_DATABASE_MAX_ACTIVE_STATEMENTS         for 1024
17208>>>>>>>>>>>Define DF_DATABASE_DRIVER_DECIMAL_SEPARATOR      for 1026
17208>>>>>>>>>>>Define DF_DATABASE_DRIVER_THOUSANDS_SEPARATOR    for 1028
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_DATABASE_DRIVER_DATE_FORMAT            for 1030
17208>>>>>>>>>>>Define DF_DATABASE_DRIVER_DATE_SEPARATOR         for 1032
17208>>>>>>>>>>>Define DF_DATABASE_IGNORE_UCASE_SUPPORT          for 1034
17208>>>>>>>>>>>Define DF_DATABASE_INDEX_CREATE                  for 1036
17208>>>>>>>>>>>Define DF_DATABASE_INDEX_DROP                    for 1038
17208>>>>>>>>>>>Define DF_DATABASE_INDEX_ASC                     for 1040
17208>>>>>>>>>>>Define DF_DATABASE_INDEX_DESC                    for 1042
17208>>>>>>>>>>>Define DF_DATABASE_COLUMN_CREATE_DEFAULTCLAUSE   for 1044
17208>>>>>>>>>>>Define DF_DATABASE_DUPREC_ERRORNUMBER            for 1046
17208>>>>>>>>>>>Define DF_DATABASE_USE_IDENTITY_TYPE             for 1048
17208>>>>>>>>>>>Define DF_DATABASE_NUMBER_NATIVE_LOCKERRORS      for 1050
17208>>>>>>>>>>>Define DF_DATABASE_NATIVE_LOCKERROR              for 1052
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_MAX_ROWS              for 1054
17208>>>>>>>>>>>Define DF_DATABASE_IGNORE_WARNINGS               for 1056
17208>>>>>>>>>>>Define DF_DATABASE_USE_DF_LOCKERROR              for 1058
17208>>>>>>>>>>>Define DF_DATABASE_FIND_CACHE_TIMEOUT            for 1060
17208>>>>>>>>>>>Define DF_DATABASE_JIT_TRESHOLD                  for 1062
17208>>>>>>>>>>>Define DF_DATABASE_TRUNCATE_BINARY_ZEROES        for 1064
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DEFAULT_DATETIME      for 1065
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_NULLABLE_DATETIME     for 1066
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATE_TO_ODBCTYPE         for 1068
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_ODBCTYPE     for 1070
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFASCII_TO_ODBCTYPE        for 1072
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_ODBCTYPE         for 1074
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_ODBCTYPE       for 1076
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1078
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATE_TO_SQLTYPE         for 1069
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFDATETIME_TO_SQLTYPE     for 1071
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFASCII_TO_SQLTYPE        for 1073
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFTEXT_TO_SQLTYPE         for 1075
17208>>>>>>>>>>>Define DF_DATABASE_MAP_DFBINARY_TO_SQLTYPE       for 1077
17208>>>>>>>>>>>Define DF_DATABASE_DEFAULT_DATABASE              for 1079
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_ASCII           for 1101
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_ASCII          for 1102
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_NUMERIC         for 1103
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_NUMERIC        for 1104
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATE            for 1105
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATE           for 1106
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_TEXT            for 1107
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_TEXT           for 1108
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_BINARY          for 1109
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_BINARY         for 1110
17208>>>>>>>>>>>Define DF_DRIVER_DUMMY_ZERO_DATE_VALUE           for 1111
17208>>>>>>>>>>>Define DF_DRIVER_MAX_ACTIVE_STATEMENTS           for 1112
17208>>>>>>>>>>>Define DF_DRIVER_CACHE_PATH                      for 1113
17208>>>>>>>>>>>Define DF_DRIVER_DRIVER_DECIMAL_SEPARATOR        for 1114
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT  for 1115
17208>>>>>>>>>>>Define DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR      for 1116
17208>>>>>>>>>>>Define DF_DRIVER_APPLICATION_CHARACTER_FORMAT    for 1117
17208>>>>>>>>>>>Define DF_DRIVER_DRIVER_DATE_FORMAT              for 1118
17208>>>>>>>>>>>Define DF_DRIVER_LAST_ERROR_TEXT                 for 1119
17208>>>>>>>>>>>Define DF_DRIVER_DRIVER_DATE_SEPARATOR           for 1120
17208>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID                   for 1121
17208>>>>>>>>>>>Define DF_DRIVER_IGNORE_UCASE_SUPPORT            for 1122
17208>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID_STRING            for 1123
17208>>>>>>>>>>>Define DF_DRIVER_IGNORE_WARNINGS                 for 1124
17208>>>>>>>>>>>Define DF_DRIVER_USE_DF_LOCKERROR                for 1126
17208>>>>>>>>>>>Define DF_DRIVER_FIND_CACHE_TIMEOUT              for 1128
17208>>>>>>>>>>>Define DF_DRIVER_JIT_TRESHOLD                    for 1130
17208>>>>>>>>>>>Define DF_DRIVER_TRUNCATE_BINARY_ZEROES          for 1132
17208>>>>>>>>>>>Define DF_DRIVER_ERROR_DEBUG_MODE                for 1134
17208>>>>>>>>>>>Define DF_DRIVER_USE_CACHE                       for 1136
17208>>>>>>>>>>>Define DF_DRIVER_REPORT_CACHE_ERRORS             for 1138
17208>>>>>>>>>>>Define DF_DRIVER_USE_CACHE_EXPIRATION            for 1140
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE     for 1142
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING  for 1144
17208>>>>>>>>>>>Define DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS     for 1146
17208>>>>>>>>>>>Define DF_DRIVER_SILENT_LOGIN                    for 1148
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_MAP_TO_RECNUM           for 1150
17208>>>>>>>>>>>Define DF_DRIVER_CONNECTION_ID_OPTIONS           for 1152
17208>>>>>>>>>>>Define DF_DRIVER_NUMBER_CONNECTION_IDS           for 1154
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_DEFAULT_DATETIME        for 1155
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_NULLABLE_DATETIME       for 1156
17208>>>>>>>>>>>Define DF_DRIVER_MATCH_CLIENT_SERVER_VERSION     for 1158
17208>>>>>>>>>>>Define DF_DRIVER_SQLSERVER_CLIENT_VERSION        for 1160
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE          for 1168
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE      for 1170
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE         for 1172
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE          for 1174
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE        for 1176
17208>>>>>>>>>>>Define DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA for 1178
17208>>>>>>>>>>>Define DF_DRIVER_LOGIN_ON_OPEN                   for 1180
17208>>>>>>>>>>>Define DF_DRIVER_MINIMUM_CLIENT_VERSION          for 1182
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATE_TO_SQLTYPE           for 1169
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE       for 1171
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFASCII_TO_SQLTYPE          for 1173
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE           for 1175
17208>>>>>>>>>>>Define DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE         for 1177
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Replacement for logical column number that indicates all columns
17208>>>>>>>>>>>Define DF_ALL_COLUMNS for -1
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Possible DF_FILE_GENERATE_RECORD_ID_METHOD values
17208>>>>>>>>>>>Define RIM_NONE            for 0
17208>>>>>>>>>>>Define RIM_IDENTITY_COLUMN for 1
17208>>>>>>>>>>>Define RIM_DISPENSER_TABLE for 2
17208>>>>>>>>>>>Define RIM_EXTERNAL        for 3
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Possible DF_FIELD_READ_ONLY values
17208>>>>>>>>>>>Define RO_NO            for 0
17208>>>>>>>>>>>Define RO_IGNORECHANGE  for 1
17208>>>>>>>>>>>Define RO_ACCEPTCHANGE  for 2
17208>>>>>>>>>>>Define RO_ERRORONCHANGE for 3
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Possible DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA values
17208>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_UNKNOWN    for 0
17208>>>>>>>>>>>// Define MAP_DF_TO_SQL_TYPE_CK5        for 1
17208>>>>>>>>>>>// Define MAP_DF_TO_SQL_TYPE_CK6        for 2
17208>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2000    for 3
17208>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2005    for 4
17208>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2008    for 5
17208>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_SQL2012    for 6
17208>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_LEGACY  for 7
17208>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_DB2_10      for 8
17208>>>>>>>>>>>Define MAP_DF_TO_SQL_TYPE_ODBC_SCHEMA for 9
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values are defined in Mssqldrv.pkg
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Possible SQL Column type values
17208>>>>>>>>>>>//      SQL Server specific types defined in mssqldrv.pkg
17208>>>>>>>>>>>//      DB2 specific typesm defined in db2_drv.pkg
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define SQL_UNKNOWN_TYPE   for    0
17208>>>>>>>>>>>Define SQL_CHAR           for    1
17208>>>>>>>>>>>Define SQL_NUMERIC        for    2
17208>>>>>>>>>>>Define SQL_DECIMAL        for    3
17208>>>>>>>>>>>Define SQL_INTEGER        for    4
17208>>>>>>>>>>>Define SQL_SMALLINT       for    5
17208>>>>>>>>>>>Define SQL_FLOAT          for    6
17208>>>>>>>>>>>Define SQL_REAL           for    7
17208>>>>>>>>>>>Define SQL_DOUBLE         for    8
17208>>>>>>>>>>>Define SQL_DATETIME       for    9
17208>>>>>>>>>>>Define SQL_VARCHAR        for   12
17208>>>>>>>>>>>Define SQL_TYPE_DATE      for   91
17208>>>>>>>>>>>Define SQL_TYPE_TIME      for   92
17208>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP for   93
17208>>>>>>>>>>>
17208>>>>>>>>>>>Define SQL_DATE           for    9
17208>>>>>>>>>>>Define SQL_INTERVAL       for   10
17208>>>>>>>>>>>Define SQL_TIME           for   10
17208>>>>>>>>>>>Define SQL_TIMESTAMP      for   11
17208>>>>>>>>>>>Define SQL_LONGVARCHAR    for  (-1)
17208>>>>>>>>>>>Define SQL_BINARY         for  (-2)
17208>>>>>>>>>>>Define SQL_VARBINARY      for  (-3)
17208>>>>>>>>>>>Define SQL_LONGVARBINARY  for  (-4)
17208>>>>>>>>>>>Define SQL_BIGINT         for  (-5)
17208>>>>>>>>>>>Define SQL_TINYINT        for  (-6)
17208>>>>>>>>>>>Define SQL_BIT            for  (-7)
17208>>>>>>>>>>>Define SQL_WCHAR          for  (-8)
17208>>>>>>>>>>>Define SQL_WVARCHAR       for  (-9)
17208>>>>>>>>>>>Define SQL_WLONGVARCHAR   for (-10)
17208>>>>>>>>>>>Define SQL_GUID           for (-11)
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Possible DF_INDEX_SQL_TYPE values
17208>>>>>>>>>>>Define DF_INDEX_CLIENT      for  1
17208>>>>>>>>>>>Define DF_INDEX_SERVER      for  2
17208>>>>>>>>>>>Define DF_INDEX_SERVER_ONLY for  3
17208>>>>>>>>>>>Define DF_INDEX_TEMPORARY   for  4
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Possible DF_FILE_ALLOWED_STRUCTURE_CHANGES values
17208>>>>>>>>>>>Define ALL_TABLE_CHANGES_ALLOWED            for  0
17208>>>>>>>>>>>Define ONLY_TABLE_INT_FILE_CHANGES_ALLOWED  for  1
17208>>>>>>>>>>>Define NO_TABLE_CHANGES_ALLOWED             for  2
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Driver level attributes
17208>>>>>>>>>>>Define DRVR_TOKEN_BASE                       for 1000
17208>>>>>>>>>>>Define DRVR_ATTRIBUTE_START                  for (DRVR_TOKEN_BASE + 19)
17208>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_ASCII           for (DRVR_ATTRIBUTE_START)
17208>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_NUMERIC         for (DRVR_ATTRIBUTE_START +  1)
17208>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_DATE            for (DRVR_ATTRIBUTE_START +  2)
17208>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_TEXT            for (DRVR_ATTRIBUTE_START +  3)
17208>>>>>>>>>>>Define DRVR_DEFAULT_NULLABLE_BINARY          for (DRVR_ATTRIBUTE_START +  4)
17208>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_ASCII            for (DRVR_ATTRIBUTE_START +  5)
17208>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_NUMERIC          for (DRVR_ATTRIBUTE_START +  6)
17208>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_DATE             for (DRVR_ATTRIBUTE_START +  7)
17208>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_TEXT             for (DRVR_ATTRIBUTE_START +  8)
17208>>>>>>>>>>>Define DRVR_DEFAULT_DEFAULT_BINARY           for (DRVR_ATTRIBUTE_START +  9)
17208>>>>>>>>>>>Define DRVR_MAX_ACTIVE_STATEMENTS            for (DRVR_ATTRIBUTE_START + 10)
17208>>>>>>>>>>>Define DRVR_ERROR_DEBUG_MODE                 for (DRVR_ATTRIBUTE_START + 11)
17208>>>>>>>>>>>Define DRVR_DRIVER_DECIMAL_SEPARATOR         for (DRVR_ATTRIBUTE_START + 12)
17208>>>>>>>>>>>Define DRVR_DRIVER_THOUSANDS_SEPARATOR       for (DRVR_ATTRIBUTE_START + 13)
17208>>>>>>>>>>>Define DRVR_DRIVER_DATE_FORMAT               for (DRVR_ATTRIBUTE_START + 14)
17208>>>>>>>>>>>Define DRVR_DRIVER_DATE_SEPARATOR            for (DRVR_ATTRIBUTE_START + 15)
17208>>>>>>>>>>>Define DRVR_USE_CACHE                        for (DRVR_ATTRIBUTE_START + 16)
17208>>>>>>>>>>>Define DRVR_REPORT_CACHE_ERRORS              for (DRVR_ATTRIBUTE_START + 17)
17208>>>>>>>>>>>Define DRVR_CACHE_PATH                       for (DRVR_ATTRIBUTE_START + 18)
17208>>>>>>>>>>>Define DRVR_USE_CACHE_EXPIRATION             for (DRVR_ATTRIBUTE_START + 19)
17208>>>>>>>>>>>Define DRVR_DEFAULT_TABLE_CHARACTER_FORMAT   for (DRVR_ATTRIBUTE_START + 20)
17208>>>>>>>>>>>Define DRVR_APPLICATION_CHARACTER_FORMAT     for (DRVR_ATTRIBUTE_START + 21)
17208>>>>>>>>>>>Define DRVR_DUMMY_ZERO_DATE_VALUE            for (DRVR_ATTRIBUTE_START + 22)
17208>>>>>>>>>>>Define DRVR_DEFAULT_USE_DUMMY_ZERO_DATE      for (DRVR_ATTRIBUTE_START + 23)
17208>>>>>>>>>>>Define DRVR_IGNORE_UCASE_SUPPORT             for (DRVR_ATTRIBUTE_START + 24)
17208>>>>>>>>>>>Define DRVR_LASTERRORTEXTLENGTH              for (DRVR_ATTRIBUTE_START + 25)
17208>>>>>>>>>>>Define DRVR_LASTERRORTEXT                    for (DRVR_ATTRIBUTE_START + 26)
17208>>>>>>>>>>>Define DRVR_DEFAULTRECORDIDHIDING            for (DRVR_ATTRIBUTE_START + 35)
17208>>>>>>>>>>>Define DRVR_REPORTACTIVECOLUMNERRORS         for (DRVR_ATTRIBUTE_START + 36)
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Error Number constants
17208>>>>>>>>>>>Define CLIERR_GENERAL_ERROR                       for 12289
17208>>>>>>>>>>>Define CLIERR_CANT_INITIALIZE                     for 12290
17208>>>>>>>>>>>Define CLIERR_CANT_DEINITIALIZE                   for 12291
17208>>>>>>>>>>>Define CLIERR_BAD_OR_NO_PRIMARY_INDEX_SPECIFIED   for 12292
17208>>>>>>>>>>>Define CLIERR_LOGIN_UNSUCCESSFUL                  for 12293
17208>>>>>>>>>>>Define CLIERR_LOGOUT_UNSUCCESSFUL                 for 12294
17208>>>>>>>>>>>Define CLIERR_TABLE_NOT_IN_CONNECTION             for 12295
17208>>>>>>>>>>>Define CLIERR_NULL_VALUE_NOT_ALLOWED              for 12296
17208>>>>>>>>>>>Define CLIERR_SEGMENT_NUMBER_RANGE                for 12297
17208>>>>>>>>>>>Define CLIERR_INDEX_NUMBER_RANGE                  for 12298
17208>>>>>>>>>>>Define CLIERR_LOGIN_ATTRIBUTE_MUST_BE_SET         for 12299
17208>>>>>>>>>>>Define CLIERR_PHYSICAL_NAME_MUST_BE_SET           for 12300
17208>>>>>>>>>>>Define CLIERR_INVALID_REGISTRATION_FILE           for 12301
17208>>>>>>>>>>>Define CLIERR_LICENSE_EXPIRED                     for 12302
17208>>>>>>>>>>>Define CLIERR_DEADLOCK_OR_TIMEOUT                 for 12303
17208>>>>>>>>>>>Define CLIERR_SQL_ERROR                           for 12304
17208>>>>>>>>>>>Define CLIERR_SQLINVALID_CLI_STMT_HANDLE          for 12305
17208>>>>>>>>>>>Define CLIERR_SQLINVALID_CLI_CONN_HANDLE          for 12306
17208>>>>>>>>>>>Define CLIERR_SQLINVALID_DRIVER_ID                for 12307
17208>>>>>>>>>>>Define CLIERR_SQLINVALID_BIND_FILE                for 12308
17208>>>>>>>>>>>Define CLIERR_SQLINVALID_COLUMN                   for 12309
17208>>>>>>>>>>>Define CLIERR_SQLINVALID_ATTRIBUTE                for 12310
17208>>>>>>>>>>>Define CLIERR_SQLINVALID_BUFFER                   for 12311
17208>>>>>>>>>>>Define CLIERR_INVALID_CONFIGURATION_KEYWORD       for 12312
17208>>>>>>>>>>>Define CLIERR_NOUNIQUEINDEX                       for 12313
17208>>>>>>>>>>>Define CLIERR_UCSEGMENT_NOT_SUPPORTED             for 12314
17208>>>>>>>>>>>Define CLIERR_FIELDREADONLY                       for 12315
17208>>>>>>>>>>>Define CLIERR_DBPROPERROR                         for 12316
17208>>>>>>>>>>>Define CLIERR_CANTSETRECNUMINACTIVE               for 12317
17208>>>>>>>>>>>Define CLIERR_CANTCHANGEINACTIVECOLUMN            for 12318
17208>>>>>>>>>>>Define CLIERR_FIELDISINACTIVE                     for 12319
17208>>>>>>>>>>>Define CLIERR_NOT_INSTALLED                       for 12320
17208>>>>>>>>>>>Define CLIERR_CANT_FIND_TERMLIST                  for 12321
17208>>>>>>>>>>>Define CLIERR_CANT_READ_TERMLIST                  for 12322
17208>>>>>>>>>>>Define CLIERR_MAX_USERS_EXCEEDED                  for 12323
17208>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_ERROR               for 12324
17208>>>>>>>>>>>Define CLIERR_CANT_INIT_USER_COUNT                for 12325
17208>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_NOT_FOUND           for 12326
17208>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_CANT_READ           for 12327
17208>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_CANT_DECRYPT        for 12328
17208>>>>>>>>>>>Define CLIERR_USER_COUNT_FILE_BAD_VERSION         for 12329
17208>>>>>>>>>>>Define CLIERR_CANTCREATE_RECNUMISZERO             for 12330
17208>>>>>>>>>>>Define CLIERR_CANTGETCOLUMNINFO                   for 12331
17208>>>>>>>>>>>Define CLIERR_INVALIDDATABASEHANDLE               for 12332
17208>>>>>>>>>>>Define CLIERR_TYPENUMBEROUTOFRANGE                for 12333
17208>>>>>>>>>>>Define CLIERR_LOCKERRORNUMBEROUTOFRANGE           for 12334
17208>>>>>>>>>>>Define CLIERR_CONNECTIONIDOUTOFRANGE              for 12335
17208>>>>>>>>>>>Define CLIERR_CONNECTIONIDNOTFOUND                for 12336
17208>>>>>>>>>>>Define CLIERR_RELATIONOUTOFRANGE                  for 12337
17208>>>>>>>>>>>Define CLIERR_NOTANEXPRESSEDITION                 for 12338
17208>>>>>>>>>>>Define CLIERR_INVALID_CONFIGURATION_VALUE         for 12339
17208>>>>>>>>>>>Define CLIERR_NOCLIENTSERVERVERSIONMATCH          for 12340
17208>>>>>>>>>>>Define CLIERR_CONNECTIONIDALREADYEXISTS           for 12341
17208>>>>>>>>>>>Define CLIERR_INVALIDCONNECTSTRINGOPENOPTION      for 12342
17208>>>>>>>>>>>Define CLIERR_DATABASECONNECTIONLOST              for 12343
17208>>>>>>>>>>>Define CLIERR_STRUCTURECHANGENOTALLOWED           for 12344
17208>>>>>>>>>>>Define CLIERR_MINIMUMCLIENTVERSIONNOTFOUND        for 12345
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Call driver Function identifiers
17208>>>>>>>>>>>Define CLI_CONSTRAINT             for 10000
17208>>>>>>>>>>>Define CLI_SETDRIVERATTRIBUTE     for 10001
17208>>>>>>>>>>>Define CLI_GETDRIVERATTRIBUTE     for 10002
17208>>>>>>>>>>>Define CLI_BROWSECONNECT          for 10003
17208>>>>>>>>>>>Define CLI_DATASOURCES            for 10004
17208>>>>>>>>>>>Define CLI_CKREVISION             for 10005
17208>>>>>>>>>>>Define CLI_INITDATASOURCES        for 10006
17208>>>>>>>>>>>Define CLI_ENUMERATE_TABLES       for 10007
17208>>>>>>>>>>>Define CLI_TABLENAME              for 10008
17208>>>>>>>>>>>Define CLI_TABLESCHEMA            for 10009
17208>>>>>>>>>>>Define CLI_TABLETYPE              for 10010
17208>>>>>>>>>>>Define CLI_TABLECOMMENT           for 10011
17208>>>>>>>>>>>Define CLI_ENUMERATE_COLUMNS      for 10012
17208>>>>>>>>>>>Define CLI_COLUMNNAME             for 10013
17208>>>>>>>>>>>Define CLI_DUMPSTATUS             for 10014
17208>>>>>>>>>>>Define CLI_READCONFIGURATION      for 10015
17208>>>>>>>>>>>Define CLI_GETDBATTRIBUTE0        for 10016
17208>>>>>>>>>>>Define CLI_GETDBATTRIBUTE         for 10017
17208>>>>>>>>>>>Define CLI_GETREGNAME             for 10018
17208>>>>>>>>>>>Define CLI_GETSERIALNUM           for 10019
17208>>>>>>>>>>>Define CLI_GETMAXUSERS            for 10020
17208>>>>>>>>>>>Define CLI_BCP                    for 10021
17208>>>>>>>>>>>Define CLI_DROPINDICES            for 10022
17208>>>>>>>>>>>Define CLI_CREATEINDICES          for 10023
17208>>>>>>>>>>>Define CLI_REDIRECTCONNECTION     for 10024
17208>>>>>>>>>>>Define CLI_CREATECONNECTIONID     for 10025
17208>>>>>>>>>>>Define CLI_DELETECONNECTIONID     for 10026
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Init data source types
17208>>>>>>>>>>>Define SQL_FETCH_ALL     for  2
17208>>>>>>>>>>>Define SQL_FETCH_USER    for 31
17208>>>>>>>>>>>Define SQL_FETCH_SYSTEM  for 32
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Dummy strings used in the commands
17208>>>>>>>>>>>String  CLI$StrDummy 255
17208>>>>>>>>>>>Integer CLI$IntDummy
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>//   Setup a constraint for a file.                                    
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>// Set or get an attribute at driver level. These attributes, when set,
17208>>>>>>>>>>>// will be set for the remainder of the session or until set again. To 
17208>>>>>>>>>>>// permanently set driver level attributes change the driver           
17208>>>>>>>>>>>// configuration file.                                                 
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>
17208>>>>>>>>>>>// An instance of this class can be used as a broker object to
17208>>>>>>>>>>>// call several CLI releated methods.                         
17208>>>>>>>>>>>
17208>>>>>>>>>>>//Class cCLIHandler is a cObject
17208>>>>>>>>>>>Class cCLIHandler is an Array
17209>>>>>>>>>>>    
17209>>>>>>>>>>>    Procedure Construct_Object 
17211>>>>>>>>>>>        Forward Send Construct_object 
17213>>>>>>>>>>>        
17213>>>>>>>>>>>        Property String  psDriverID        ""
17214>>>>>>>>>>>    End_Procedure
17215>>>>>>>>>>>    
17215>>>>>>>>>>>    
17215>>>>>>>>>>>    
17215>>>>>>>>>>>    // The revsion of a CLI Connectivity Kit
17215>>>>>>>>>>>    Function CKRevision Returns String
17217>>>>>>>>>>>        String  sDriverID
17217>>>>>>>>>>>        String  sRevision
17217>>>>>>>>>>>        String  sVoid
17217>>>>>>>>>>>        Integer iRetval
17217>>>>>>>>>>>        
17217>>>>>>>>>>>        Get psDriverID to sDriverID
17218>>>>>>>>>>>        If (sDRiverID <> "") Begin
17220>>>>>>>>>>>            Move (Repeat(" ", 255)) to sRevision
17221>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
17226>>>>>>>>>>>        End
17226>>>>>>>>>>>>
17226>>>>>>>>>>>        
17226>>>>>>>>>>>        Function_Return sRevision
17227>>>>>>>>>>>    End_Function
17228>>>>>>>>>>>    
17228>>>>>>>>>>>    
17228>>>>>>>>>>>    
17228>>>>>>>>>>>    // Extarct the Nth part of a a.b.c.d revsion string.
17228>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
17228>>>>>>>>>>>    //
17228>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
17230>>>>>>>>>>>        Integer iPartRev
17230>>>>>>>>>>>        Integer iCurrentPart
17230>>>>>>>>>>>        Integer iSeparatorPos
17230>>>>>>>>>>>        
17230>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
17233>>>>>>>>>>>        
17233>>>>>>>>>>>        Move 0 to iCurrentPart
17234>>>>>>>>>>>        Repeat
17234>>>>>>>>>>>>
17234>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
17235>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
17237>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
17238>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
17239>>>>>>>>>>>                Increment iCurrentPart
17240>>>>>>>>>>>            End
17240>>>>>>>>>>>>
17240>>>>>>>>>>>            Else If (sRevision <> "") Begin
17243>>>>>>>>>>>                Move sRevision to iPartRev
17244>>>>>>>>>>>                Move "" to sRevision
17245>>>>>>>>>>>                Increment iCurrentPart
17246>>>>>>>>>>>            End
17246>>>>>>>>>>>>
17246>>>>>>>>>>>            Else ;                Move -1 to iPartRev
17248>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
17250>>>>>>>>>>>        
17250>>>>>>>>>>>        Function_Return iPartRev
17251>>>>>>>>>>>    End_Function
17252>>>>>>>>>>>    
17252>>>>>>>>>>>    
17252>>>>>>>>>>>    
17252>>>>>>>>>>>    // Returns the major revision of the CK
17252>>>>>>>>>>>    //
17252>>>>>>>>>>>    Function CKMajorRevision Returns Integer
17254>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 1, CKRevision(Self)))
17255>>>>>>>>>>>    End_Function
17256>>>>>>>>>>>    
17256>>>>>>>>>>>    
17256>>>>>>>>>>>    
17256>>>>>>>>>>>    // Returns the minor revision of the CK
17256>>>>>>>>>>>    //
17256>>>>>>>>>>>    Function CKMinorRevision Returns Integer
17258>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 2, CKRevision(Self)))
17259>>>>>>>>>>>    End_Function
17260>>>>>>>>>>>    
17260>>>>>>>>>>>    
17260>>>>>>>>>>>    
17260>>>>>>>>>>>    // Returns the release revision of the CK
17260>>>>>>>>>>>    //
17260>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
17262>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 3, CKRevision(Self)))
17263>>>>>>>>>>>    End_Function
17264>>>>>>>>>>>    
17264>>>>>>>>>>>    
17264>>>>>>>>>>>    
17264>>>>>>>>>>>    // Returns the major revision of the CK
17264>>>>>>>>>>>    //
17264>>>>>>>>>>>    Function CKBuildRevision Returns Integer
17266>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Self, 4, CKRevision(Self)))
17267>>>>>>>>>>>    End_Function
17268>>>>>>>>>>>    
17268>>>>>>>>>>>    
17268>>>>>>>>>>>    
17268>>>>>>>>>>>    // Determines if the CK conforms to a passed minimal revsion.
17268>>>>>>>>>>>    //
17268>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
17270>>>>>>>>>>>        If (iMajor < CKMajorRevision(Self)) ;            Function_Return (True)
17273>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Self)) Begin
17276>>>>>>>>>>>            If (iMinor < CKMinorRevision(Self)) ;                Function_Return (True)
17279>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Self)) Begin
17282>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Self)) ;                    Function_Return (True)
17285>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Self) and iBuild <= CKBuildRevision(Self)) ;                    Function_Return (True)
17289>>>>>>>>>>>            End
17289>>>>>>>>>>>>
17289>>>>>>>>>>>        End
17289>>>>>>>>>>>>
17289>>>>>>>>>>>        
17289>>>>>>>>>>>        Function_Return (False)
17290>>>>>>>>>>>    End_Function
17291>>>>>>>>>>>    
17291>>>>>>>>>>>    
17291>>>>>>>>>>>    
17291>>>>>>>>>>>    // Returns the Connectiivty Kit registration name.
17291>>>>>>>>>>>    //
17291>>>>>>>>>>>    Function RegistrationName Returns String
17293>>>>>>>>>>>        String  sRegistration
17293>>>>>>>>>>>        String  sDRiverId
17293>>>>>>>>>>>        String  sVoid
17293>>>>>>>>>>>        Integer iRetval
17293>>>>>>>>>>>        
17293>>>>>>>>>>>        Get psDriverID to sDriverID
17294>>>>>>>>>>>        If (sDRiverID <> "") Begin
17296>>>>>>>>>>>            Move (Repeat(" ", 255)) to sRegistration
17297>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETREGNAME Callback 0 Passing sRegistration sVoid 0 Result iRetval
17302>>>>>>>>>>>        End
17302>>>>>>>>>>>>
17302>>>>>>>>>>>        
17302>>>>>>>>>>>        Function_Return sRegistration
17303>>>>>>>>>>>    End_Function
17304>>>>>>>>>>>    
17304>>>>>>>>>>>    // Returns the Connectiivty Kit serial number.
17304>>>>>>>>>>>    //
17304>>>>>>>>>>>    Function SerialNumber Returns Integer
17306>>>>>>>>>>>        String  sDRiverId
17306>>>>>>>>>>>        String  sVoid
17306>>>>>>>>>>>        Integer iRetval
17306>>>>>>>>>>>        
17306>>>>>>>>>>>        Get psDriverID to sDriverID
17307>>>>>>>>>>>        If (sDRiverID <> "") Begin
17309>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETSERIALNUM Callback 0 Passing sVoid sVoid 0 Result iRetval
17314>>>>>>>>>>>        End
17314>>>>>>>>>>>>
17314>>>>>>>>>>>        
17314>>>>>>>>>>>        Function_Return iRetval
17315>>>>>>>>>>>    End_Function
17316>>>>>>>>>>>    
17316>>>>>>>>>>>    
17316>>>>>>>>>>>    // Returns the Connectiivty Kit maximum number of users.
17316>>>>>>>>>>>    //
17316>>>>>>>>>>>    Function MaxUsers Returns Integer
17318>>>>>>>>>>>        String  sDRiverId
17318>>>>>>>>>>>        String  sVoid
17318>>>>>>>>>>>        Integer iRetval
17318>>>>>>>>>>>        
17318>>>>>>>>>>>        Get psDriverID to sDriverID
17319>>>>>>>>>>>        If (sDRiverID <> "") Begin
17321>>>>>>>>>>>            Call_Driver 0 sDRiverID Function CLI_GETMAXUSERS Callback 0 Passing sVoid sVoid 0 Result iRetval
17326>>>>>>>>>>>        End
17326>>>>>>>>>>>>
17326>>>>>>>>>>>        
17326>>>>>>>>>>>        Function_Return iRetval
17327>>>>>>>>>>>    End_Function
17328>>>>>>>>>>>    
17328>>>>>>>>>>>    
17328>>>>>>>>>>>    
17328>>>>>>>>>>>    // Dump the current status of the drver in the passed disk file.
17328>>>>>>>>>>>    //
17328>>>>>>>>>>>    Procedure DumpStatus String sFileName
17330>>>>>>>>>>>        String  sVoid
17330>>>>>>>>>>>        String  sDriverID
17330>>>>>>>>>>>        Integer iVoid
17330>>>>>>>>>>>        
17330>>>>>>>>>>>        Get psDriverID to sDriverID
17331>>>>>>>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_DUMPSTATUS Callback 0 Passing sFileName sVoid iVoid Result iVoid
17338>>>>>>>>>>>    End_Procedure
17339>>>>>>>>>>>    
17339>>>>>>>>>>>    
17339>>>>>>>>>>>    
17339>>>>>>>>>>>    // Reset all driver level configurable attributes to the
17339>>>>>>>>>>>    // default value and then reread the configuration.
17339>>>>>>>>>>>    //
17339>>>>>>>>>>>    Procedure ReadConfiguration
17341>>>>>>>>>>>        String  sVoid
17341>>>>>>>>>>>        String  sDriverID
17341>>>>>>>>>>>        Integer iVoid
17341>>>>>>>>>>>        
17341>>>>>>>>>>>        Get psDriverID to sDriverID
17342>>>>>>>>>>>        If (sDriverID <> "") ;            Call_Driver 0 sDriverID Function CLI_READCONFIGURATION Callback 0 Passing sVoid sVoid iVoid Result iVoid
17349>>>>>>>>>>>    End_Procedure
17350>>>>>>>>>>>    
17350>>>>>>>>>>>    
17350>>>>>>>>>>>    
17350>>>>>>>>>>>    // Convert a text to the corresponding
17350>>>>>>>>>>>    // Generate_Record_ID_Method attribute value
17350>>>>>>>>>>>    //
17350>>>>>>>>>>>    Function TextToRIMValue String sText Returns Integer
17352>>>>>>>>>>>        If (sText = "None") ;            Function_Return RIM_NONE
17355>>>>>>>>>>>        Else If (sText = "Identity Column") ;            Function_Return RIM_IDENTITY_COLUMN
17359>>>>>>>>>>>        Else If (sText = "Dispenser Table") ;            Function_Return RIM_DISPENSER_TABLE
17363>>>>>>>>>>>        Else If (sText = "External") ;            Function_Return RIM_EXTERNAL
17367>>>>>>>>>>>    End_Function
17368>>>>>>>>>>>    
17368>>>>>>>>>>>    
17368>>>>>>>>>>>    
17368>>>>>>>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
17368>>>>>>>>>>>    // corresponding text.
17368>>>>>>>>>>>    //
17368>>>>>>>>>>>    Function RIMValueToText Integer iAttrValue Returns String
17370>>>>>>>>>>>        If (iAttrValue = RIM_NONE) ;            Function_Return "None"
17373>>>>>>>>>>>        Else If (iAttrValue = RIM_IDENTITY_COLUMN) ;            Function_Return "Identity Column"
17377>>>>>>>>>>>        Else If (iAttrValue = RIM_DISPENSER_TABLE) ;            Function_Return "Dispenser Table"
17381>>>>>>>>>>>        Else If (iAttrValue = RIM_EXTERNAL) ;            Function_Return "External"
17385>>>>>>>>>>>    End_Function
17386>>>>>>>>>>>    
17386>>>>>>>>>>>    
17386>>>>>>>>>>>    
17386>>>>>>>>>>>    // Convert a text to the corresponding
17386>>>>>>>>>>>    // Generate_Record_ID_Method attribute value
17386>>>>>>>>>>>    //
17386>>>>>>>>>>>    Function TextToROValue String sText Returns Integer
17388>>>>>>>>>>>        If (sText = "No") ;            Function_Return RO_NO
17391>>>>>>>>>>>        Else If (sText = "Ignore Change") ;            Function_Return RO_IGNORECHANGE
17395>>>>>>>>>>>        Else If (sText = "Accept Change") ;            Function_Return RO_ACCEPTCHANGE
17399>>>>>>>>>>>        Else If (sText = "Error On Change") ;            Function_Return RO_ERRORONCHANGE
17403>>>>>>>>>>>    End_Function
17404>>>>>>>>>>>    
17404>>>>>>>>>>>    
17404>>>>>>>>>>>    
17404>>>>>>>>>>>    // Convert a Generate_Record_ID_Method attribute value to the
17404>>>>>>>>>>>    // corresponding text.
17404>>>>>>>>>>>    //
17404>>>>>>>>>>>    Function ROValueToText Integer iAttrValue Returns String
17406>>>>>>>>>>>        If (iAttrValue = RO_NO) ;            Function_Return "No"
17409>>>>>>>>>>>        Else If (iAttrValue = RO_IGNORECHANGE) ;            Function_Return "Ignore Change"
17413>>>>>>>>>>>        Else If (iAttrValue = RO_ACCEPTCHANGE) ;            Function_Return "Accept Change"
17417>>>>>>>>>>>        Else If (iAttrValue = RO_ERRORONCHANGE) ;            Function_Return "Error On Change"
17421>>>>>>>>>>>    End_Function
17422>>>>>>>>>>>    
17422>>>>>>>>>>>    
17422>>>>>>>>>>>    
17422>>>>>>>>>>>    // Return the text f the last error geneated by the driver.
17422>>>>>>>>>>>    //
17422>>>>>>>>>>>    Function LastDriverError Returns String
17424>>>>>>>>>>>        String  sDriverID
17424>>>>>>>>>>>        String  sLastError
17424>>>>>>>>>>>        String  sLastErrorLength
17424>>>>>>>>>>>        Integer iLastErrorLength
17424>>>>>>>>>>>        Integer iVoid
17424>>>>>>>>>>>        
17424>>>>>>>>>>>        // Initialize
17424>>>>>>>>>>>        Move "" to sLastError
17425>>>>>>>>>>>        
17425>>>>>>>>>>>        Get psDriverID to sDriverID
17426>>>>>>>>>>>        If (sDriverID <> "") Begin
17428>>>>>>>>>>>            // Get the text of the last error
17428>>>>>>>>>>>            Move (Repeat(Character(" "), 14)) to sLastErrorlength
17429>>>>>>>>>>>            Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastErrorLength iVoid DRVR_LASTERRORTEXTLENGTH Result iVoid
17434>>>>>>>>>>>            Move (Left(sLastErrorLength, Pos(Character(0), sLastErrorLength) - 1)) to iLastErrorLength
17435>>>>>>>>>>>            
17435>>>>>>>>>>>            If (iLastErrorLength > 0) Begin
17437>>>>>>>>>>>                Move (Repeat(Character(" "), iLastErrorLength + 1)) to sLastError
17438>>>>>>>>>>>                Call_Driver 0 sDriverID Function CLI_GETDRIVERATTRIBUTE Callback 0 Passing sLastError iVoid DRVR_LASTERRORTEXT Result iVoid
17443>>>>>>>>>>>                Move (Left(sLastError, Pos(Character(0), sLastError) - 1)) to sLastError
17444>>>>>>>>>>>            End
17444>>>>>>>>>>>>
17444>>>>>>>>>>>        End
17444>>>>>>>>>>>>
17444>>>>>>>>>>>        
17444>>>>>>>>>>>        Function_Return sLastError
17445>>>>>>>>>>>    End_Function
17446>>>>>>>>>>>    
17446>>>>>>>>>>>    
17446>>>>>>>>>>>    
17446>>>>>>>>>>>    // Enumerate the tables in a database
17446>>>>>>>>>>>    //
17446>>>>>>>>>>>    Function EnumerateTables String sLogin Returns Integer
17448>>>>>>>>>>>        String  sDriver
17448>>>>>>>>>>>        String  sVoid
17448>>>>>>>>>>>        Integer iNumTables
17448>>>>>>>>>>>        Integer iVoid
17448>>>>>>>>>>>        
17448>>>>>>>>>>>        Get psDriverID to sDriver
17449>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_TABLES Callback 0 Passing sLogin sVoid iVoid Result iNumTables
17456>>>>>>>>>>>        
17456>>>>>>>>>>>        Function_Return iNumTables
17457>>>>>>>>>>>    End_Function
17458>>>>>>>>>>>    
17458>>>>>>>>>>>    
17458>>>>>>>>>>>    
17458>>>>>>>>>>>    // Returns the name of the table enumerated at the given position
17458>>>>>>>>>>>    //
17458>>>>>>>>>>>    Function TableName Integer iIndex Returns String
17460>>>>>>>>>>>        String  sDriver
17460>>>>>>>>>>>        String  sTableName
17460>>>>>>>>>>>        String  sVoid
17460>>>>>>>>>>>        Integer iVoid
17460>>>>>>>>>>>        
17460>>>>>>>>>>>        Get psDriverID to sDriver
17461>>>>>>>>>>>        If (sDriver <> "") Begin
17463>>>>>>>>>>>            Move (Repeat(" ", 255)) to sTableName
17464>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLENAME Callback 0 Passing sTableName sVoid iIndex Result iVoid
17469>>>>>>>>>>>        End
17469>>>>>>>>>>>>
17469>>>>>>>>>>>        
17469>>>>>>>>>>>        Function_Return sTableName
17470>>>>>>>>>>>    End_Function
17471>>>>>>>>>>>    
17471>>>>>>>>>>>    
17471>>>>>>>>>>>    
17471>>>>>>>>>>>    // Returns the name of the schema of the table enumerated at the given position
17471>>>>>>>>>>>    //
17471>>>>>>>>>>>    Function SchemaName Integer iIndex Returns String
17473>>>>>>>>>>>        String  sDriver
17473>>>>>>>>>>>        String  sSchemaName
17473>>>>>>>>>>>        String  sVoid
17473>>>>>>>>>>>        Integer iVoid
17473>>>>>>>>>>>        
17473>>>>>>>>>>>        Get psDriverID to sDriver
17474>>>>>>>>>>>        If (sDriver <> "") Begin
17476>>>>>>>>>>>            Move (Repeat(" ", 255)) to sSchemaName
17477>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLESCHEMA Callback 0 Passing sSchemaName sVoid iIndex Result iVoid
17482>>>>>>>>>>>        End
17482>>>>>>>>>>>>
17482>>>>>>>>>>>        
17482>>>>>>>>>>>        Function_Return sSchemaName
17483>>>>>>>>>>>    End_Function
17484>>>>>>>>>>>    
17484>>>>>>>>>>>    // Returns the type of the table enumerated at the given position.
17484>>>>>>>>>>>    // Types can be "TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
17484>>>>>>>>>>>    // "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
17484>>>>>>>>>>>    Function TableType Integer iIndex Returns String
17486>>>>>>>>>>>        String  sDriver
17486>>>>>>>>>>>        String  sTableType
17486>>>>>>>>>>>        String  sVoid
17486>>>>>>>>>>>        Integer iVoid
17486>>>>>>>>>>>        
17486>>>>>>>>>>>        Get psDriverID to sDriver
17487>>>>>>>>>>>        If (sDriver <> "") Begin
17489>>>>>>>>>>>            Move (Repeat(" ", 25)) to sTableType
17490>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLETYPE Callback 0 Passing sTableType sVoid iIndex Result iVoid
17495>>>>>>>>>>>        End
17495>>>>>>>>>>>>
17495>>>>>>>>>>>        
17495>>>>>>>>>>>        Function_Return sTableType
17496>>>>>>>>>>>    End_Function
17497>>>>>>>>>>>    
17497>>>>>>>>>>>    
17497>>>>>>>>>>>    // Returns the comment of the table enumerated at the given position
17497>>>>>>>>>>>    //
17497>>>>>>>>>>>    Function TableComment Integer iIndex Returns String
17499>>>>>>>>>>>        String  sDriver
17499>>>>>>>>>>>        String  sTableComment
17499>>>>>>>>>>>        String  sVoid
17499>>>>>>>>>>>        Integer iVoid
17499>>>>>>>>>>>        
17499>>>>>>>>>>>        Get psDriverID to sDriver
17500>>>>>>>>>>>        If (sDriver <> "") Begin
17502>>>>>>>>>>>            Move (Repeat(" ", 1024)) to sTableComment
17503>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_TABLECOMMENT Callback 0 Passing sTableComment sVoid iIndex Result iVoid
17508>>>>>>>>>>>        End
17508>>>>>>>>>>>>
17508>>>>>>>>>>>        
17508>>>>>>>>>>>        Function_Return sTableComment
17509>>>>>>>>>>>    End_Function
17510>>>>>>>>>>>    
17510>>>>>>>>>>>    // Enumerate the columns in a table
17510>>>>>>>>>>>    //
17510>>>>>>>>>>>    Function EnumerateColumns String sLogin String sTableName Returns Integer
17512>>>>>>>>>>>        String  sDriver
17512>>>>>>>>>>>        Integer iNumColumns
17512>>>>>>>>>>>        Integer iVoid
17512>>>>>>>>>>>        
17512>>>>>>>>>>>        Get psDriverID to sDriver
17513>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDriver Function CLI_ENUMERATE_COLUMNS Callback 0 Passing sLogin sTablename iVoid Result iNumColumns
17520>>>>>>>>>>>        
17520>>>>>>>>>>>        Function_Return iNumColumns
17521>>>>>>>>>>>    End_Function
17522>>>>>>>>>>>    
17522>>>>>>>>>>>    
17522>>>>>>>>>>>    
17522>>>>>>>>>>>    // Returns the name of the column enumerated at the given position
17522>>>>>>>>>>>    //
17522>>>>>>>>>>>    Function ColumnName Integer iIndex Returns String
17524>>>>>>>>>>>        String  sDriver
17524>>>>>>>>>>>        String  sColumnName
17524>>>>>>>>>>>        String  sVoid
17524>>>>>>>>>>>        Integer iVoid
17524>>>>>>>>>>>        
17524>>>>>>>>>>>        Get psDriverID to sDriver
17525>>>>>>>>>>>        If (sDriver <> "") Begin
17527>>>>>>>>>>>            Move (Repeat(" ", 255)) to sColumnName
17528>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_COLUMNNAME Callback 0 Passing sColumnName sVoid iIndex Result iVoid
17533>>>>>>>>>>>        End
17533>>>>>>>>>>>>
17533>>>>>>>>>>>        
17533>>>>>>>>>>>        Function_Return sColumnName
17534>>>>>>>>>>>    End_Function
17535>>>>>>>>>>>    
17535>>>>>>>>>>>    // Convert a DataFlex date to a SQL date using the dummy zero date value.
17535>>>>>>>>>>>    //
17535>>>>>>>>>>>    Function CLIDFDateToSQLDate String sDriver Date dDFDate Returns String
17537>>>>>>>>>>>        
17537>>>>>>>>>>>        Integer iDriverIndex
17537>>>>>>>>>>>        
17537>>>>>>>>>>>        String sSQLDate
17537>>>>>>>>>>>        Integer iOrgDateFmt
17537>>>>>>>>>>>        Integer iOrgDateSep
17537>>>>>>>>>>>        
17537>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
17537>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
17540>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
17543>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
17546>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
17549>>>>>>>>>>>        
17549>>>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
17551>>>>>>>>>>>            // Return the dummy zero date
17551>>>>>>>>>>>            Get DriverIndex sDriver to iDriverIndex
17552>>>>>>>>>>>            If (iDriverIndex <> 0) Begin
17554>>>>>>>>>>>                Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sSQLDate
17557>>>>>>>>>>>            End
17557>>>>>>>>>>>>
17557>>>>>>>>>>>            Else Begin
17558>>>>>>>>>>>                Move '0001-01-01' to sSQLDate
17559>>>>>>>>>>>            End
17559>>>>>>>>>>>>
17559>>>>>>>>>>>        End
17559>>>>>>>>>>>>
17559>>>>>>>>>>>        Else Begin
17560>>>>>>>>>>>            Move dDFDate to sSQLDate
17561>>>>>>>>>>>        End
17561>>>>>>>>>>>>
17561>>>>>>>>>>>        
17561>>>>>>>>>>>        // Change date format back to original
17561>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
17564>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
17567>>>>>>>>>>>        
17567>>>>>>>>>>>        Function_Return sSQLDate
17568>>>>>>>>>>>    End_Function
17569>>>>>>>>>>>    
17569>>>>>>>>>>>    
17569>>>>>>>>>>>    
17569>>>>>>>>>>>    // Convert a SQL date to a DataFlex date using the dummy zero date value.
17569>>>>>>>>>>>    Function CLISQLDateToDFDate String sDriver String sSQLDate Returns Date
17571>>>>>>>>>>>        
17571>>>>>>>>>>>        Integer iDriverIndex
17571>>>>>>>>>>>        
17571>>>>>>>>>>>        Date dDFDate
17571>>>>>>>>>>>        String sDummyDateValue
17571>>>>>>>>>>>        Integer iOrgDateFmt
17571>>>>>>>>>>>        Integer iOrgDateSep
17571>>>>>>>>>>>        
17571>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
17571>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
17574>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
17577>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
17580>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
17583>>>>>>>>>>>        
17583>>>>>>>>>>>        // We only need to convert if the date is the dummy zero date value
17583>>>>>>>>>>>        Get DriverIndex sDriver to iDriverIndex
17584>>>>>>>>>>>        If (iDriverIndex <> 0) Begin
17586>>>>>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyDateValue
17589>>>>>>>>>>>        End
17589>>>>>>>>>>>>
17589>>>>>>>>>>>        Else Begin
17590>>>>>>>>>>>            Move '0001-01-01' to sDummyDateValue
17591>>>>>>>>>>>        End
17591>>>>>>>>>>>>
17591>>>>>>>>>>>        If (sDummyDateValue = sSQLDate) ;            Move 0 to dDFDate
17594>>>>>>>>>>>        Else ;            Move sSQLDate to dDFDate
17596>>>>>>>>>>>        
17596>>>>>>>>>>>        // Change date format back to original
17596>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
17599>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
17602>>>>>>>>>>>        
17602>>>>>>>>>>>        Function_Return dDFDate
17603>>>>>>>>>>>    End_Function
17604>>>>>>>>>>>    
17604>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
17606>>>>>>>>>>>        
17606>>>>>>>>>>>        String  sCurrentDriver
17606>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
17606>>>>>>>>>>>        
17606>>>>>>>>>>>        Move 0 to iDriver
17607>>>>>>>>>>>        
17607>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
17610>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
17616>>>>>>>>>>>>
17616>>>>>>>>>>>            
17616>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
17619>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
17621>>>>>>>>>>>                Move iCount to iDriver
17622>>>>>>>>>>>            End
17622>>>>>>>>>>>>
17622>>>>>>>>>>>        Loop
17623>>>>>>>>>>>>
17623>>>>>>>>>>>        
17623>>>>>>>>>>>        Function_Return iDriver
17624>>>>>>>>>>>        
17624>>>>>>>>>>>    End_Function
17625>>>>>>>>>>>    
17625>>>>>>>>>>>    
17625>>>>>>>>>>>    // Redirect an exisitng connection. The existing connection
17625>>>>>>>>>>>    // will point to another database but all tables will stay
17625>>>>>>>>>>>    // open!
17625>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
17627>>>>>>>>>>>        String  sDriver
17627>>>>>>>>>>>        String  sVoid
17627>>>>>>>>>>>        Integer iResult
17627>>>>>>>>>>>        Integer iVoid
17627>>>>>>>>>>>        
17627>>>>>>>>>>>        Get psDriverID to sDriver
17628>>>>>>>>>>>        If (sDriver <> "") Begin
17630>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sOldConnection sNewConnection iVoid Result iResult
17635>>>>>>>>>>>        End
17635>>>>>>>>>>>>
17635>>>>>>>>>>>        Function_Return iResult
17636>>>>>>>>>>>    End_Function
17637>>>>>>>>>>>    
17637>>>>>>>>>>>    // Redirect a connection of a connection ID
17637>>>>>>>>>>>    // sConnectionId must contain a valid ConnectionId ("DFCONNID=MyID")
17637>>>>>>>>>>>    // sConnectString must contain a valid connectstring ("SERVER=MyServer;DATABASE=MyDatabase;UID=MyName;PWD=MyPassword")
17637>>>>>>>>>>>    //
17637>>>>>>>>>>>    // RedirectIDConnectString will redirect from the old connection (Server/Database the connectionId currently points to)
17637>>>>>>>>>>>    // to the new connection (Server/Database specified in sConnectString)
17637>>>>>>>>>>>    // All opened tables will be moved from old connection to new connection. (Tables must have identical structure in both connections)
17637>>>>>>>>>>>    //
17637>>>>>>>>>>>    // If bKeepLoggedIn = false, the new connection will be logged in, the old connection will be logged out
17637>>>>>>>>>>>    // If bKeepLoggedIn = true, connections will remain open and re-used on next redirectIdConnection
17637>>>>>>>>>>>    //
17637>>>>>>>>>>>    // Returns:
17637>>>>>>>>>>>    //     0 when the redirection was successful.
17637>>>>>>>>>>>    //     1 if the connection ID does not exist or can not be found.
17637>>>>>>>>>>>    //     2 login into the new connection failed.
17637>>>>>>>>>>>    //
17637>>>>>>>>>>>    Function RedirectIdConnectString String sConnectionId String sConnectString Boolean bKeepLoggedIn Returns Integer
17639>>>>>>>>>>>        String  sDriver
17639>>>>>>>>>>>        String  sVoid
17639>>>>>>>>>>>        Integer iResult
17639>>>>>>>>>>>        
17639>>>>>>>>>>>        Integer iOption
17639>>>>>>>>>>>        
17639>>>>>>>>>>>        // iOption
17639>>>>>>>>>>>        // 0 = RedirectConnection
17639>>>>>>>>>>>        // 1 = RedirectIdConnectString
17639>>>>>>>>>>>        // 2 = RedirectIdConnectStringKeepLoggedIn
17639>>>>>>>>>>>        If (bKeepLoggedIn) Begin
17641>>>>>>>>>>>            Move 2 to iOption
17642>>>>>>>>>>>        End
17642>>>>>>>>>>>>
17642>>>>>>>>>>>        Else Begin
17643>>>>>>>>>>>            Move 1 to iOption
17644>>>>>>>>>>>        End
17644>>>>>>>>>>>>
17644>>>>>>>>>>>        
17644>>>>>>>>>>>        Get psDriverID to sDriver
17645>>>>>>>>>>>        If (sDriver <> "") Begin
17647>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_REDIRECTCONNECTION Callback 0 Passing sConnectionId sConnectString iOption Result iResult
17652>>>>>>>>>>>        End
17652>>>>>>>>>>>>
17652>>>>>>>>>>>        Function_Return iResult
17653>>>>>>>>>>>    End_Function
17654>>>>>>>>>>>    
17654>>>>>>>>>>>    
17654>>>>>>>>>>>    // Create a DataFlex side connection id that can be used later on.
17654>>>>>>>>>>>    //
17654>>>>>>>>>>>    Function CreateConnectionID String sID String sConnStr Integer iOpt Returns Integer
17656>>>>>>>>>>>        String  sDriver
17656>>>>>>>>>>>        Integer iResult
17656>>>>>>>>>>>        Integer iOptions
17656>>>>>>>>>>>        
17656>>>>>>>>>>>        Get psDriverID to sDriver
17657>>>>>>>>>>>        If (Num_Arguments = 2) ;            Move 0 to iOptions
17660>>>>>>>>>>>        Else ;            Move iOpt to iOptions
17662>>>>>>>>>>>        If (sDriver <> "") Begin
17664>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_CREATECONNECTIONID Callback 0 Passing sID sConnStr iOptions Result iResult
17669>>>>>>>>>>>        End
17669>>>>>>>>>>>>
17669>>>>>>>>>>>        Function_Return iResult
17670>>>>>>>>>>>    End_Function
17671>>>>>>>>>>>    
17671>>>>>>>>>>>    
17671>>>>>>>>>>>    
17671>>>>>>>>>>>    // Delete a DataFlex side connection id.
17671>>>>>>>>>>>    //
17671>>>>>>>>>>>    Function DeleteConnectionID String sID Integer iIndex Returns Integer
17673>>>>>>>>>>>        String  sDriver
17673>>>>>>>>>>>        Integer iResult
17673>>>>>>>>>>>        String sVoid
17673>>>>>>>>>>>        
17673>>>>>>>>>>>        Get psDriverID to sDriver
17674>>>>>>>>>>>        If (sDriver <> "") Begin
17676>>>>>>>>>>>            Call_Driver 0 sDriver Function CLI_DELETECONNECTIONID Callback 0 Passing sID sVoid iIndex Result iResult
17681>>>>>>>>>>>        End
17681>>>>>>>>>>>>
17681>>>>>>>>>>>        Function_Return iResult
17682>>>>>>>>>>>    End_Function
17683>>>>>>>>>>>    
17683>>>>>>>>>>>End_Class
17684>>>>>>>>>Use sql.pkg
Including file: sql.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\sql.pkg)
17684>>>>>>>>>>>// Embedded SQL classes for use with Data Access Worldwide CLI    
17684>>>>>>>>>>>// Connectivty Kits.                                              
17684>>>>>>>>>>>Use CLI.pkg
17684>>>>>>>>>>>
17684>>>>>>>>>>>// Global storage for results
17684>>>>>>>>>>>Integer SQLResult
17684>>>>>>>>>>>
17684>>>>>>>>>>>// Embedded SQL function constants
17684>>>>>>>>>>>Define FUNC_SQLCONNECT             for 1000000
17684>>>>>>>>>>>Define FUNC_SQLFILECONNECT         for 1000001
17684>>>>>>>>>>>Define FUNC_SQLDISCONNECT          for 1000002
17684>>>>>>>>>>>Define FUNC_SQLOPEN                for 1000003
17684>>>>>>>>>>>Define FUNC_SQLCLOSE               for 1000004
17684>>>>>>>>>>>Define FUNC_SQLPREPARE             for 1000005
17684>>>>>>>>>>>Define FUNC_SQLEXECUTE             for 1000006
17684>>>>>>>>>>>Define FUNC_SQLEXECDIRECT          for 1000007
17684>>>>>>>>>>>Define FUNC_SQLFETCH               for 1000008
17684>>>>>>>>>>>Define FUNC_SQLCOLUMNINFO          for 1000009
17684>>>>>>>>>>>Define FUNC_SQLCOLUMNVALUE         for 1000010
17684>>>>>>>>>>>Define FUNC_SQLBINDFILE            for 1000011
17684>>>>>>>>>>>Define FUNC_SQLGETDATA             for 1000012
17684>>>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIBLEN  for 1000013
17684>>>>>>>>>>>Define FUNC_SQLCOLSTRINGATTRIB     for 1000014
17684>>>>>>>>>>>Define FUNC_SQLCOLINTATTRIB        for 1000015
17684>>>>>>>>>>>Define FUNC_SQLSTMTINTATTRIB       for 1000016
17684>>>>>>>>>>>Define FUNC_SQLSETPROCNAME         for 1000017
17684>>>>>>>>>>>Define FUNC_SQLSETPROCARG          for 1000018
17684>>>>>>>>>>>Define FUNC_SQLCALL                for 1000019
17684>>>>>>>>>>>Define FUNC_SQLGETPROCARGLEN       for 1000020
17684>>>>>>>>>>>Define FUNC_SQLGETPROCARG          for 1000021
17684>>>>>>>>>>>Define FUNC_SQLGETPROCRETVALLEN    for 1000022
17684>>>>>>>>>>>Define FUNC_SQLGETPROCRETVAL       for 1000023
17684>>>>>>>>>>>Define FUNC_SQLNEXTRESULTSET       for 1000024
17684>>>>>>>>>>>Define FUNC_SQLBUFFERSTATUS        for 1000025
17684>>>>>>>>>>>Define FUNC_SQLSETPROCSCHEMA       for 1000026
17684>>>>>>>>>>>Define FUNC_SQLGETMESSAGE          for 1000027
17684>>>>>>>>>>>Define FUNC_SQLSETSTMTINTATTRIB    for 1000028
17684>>>>>>>>>>>
17684>>>>>>>>>>>// Embedded SQL statement attribute constants
17684>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
17684>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
17684>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
17684>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
17684>>>>>>>>>>>Define SQLSTMTATTRIB_CURSOR_TYPE    for 5
17684>>>>>>>>>>>
17684>>>>>>>>>>>// Embedded SQL possible values for SQLSTMTATTRIB_CURSOR_TYPE
17684>>>>>>>>>>>Define SQL_CURSOR_FORWARD_ONLY      for 0
17684>>>>>>>>>>>Define SQL_CURSOR_KEYSET_DRIVEN     for 1
17684>>>>>>>>>>>Define SQL_CURSOR_DYNAMIC           for 2
17684>>>>>>>>>>>Define SQL_CURSOR_STATIC            for 3
17684>>>>>>>>>>>
17684>>>>>>>>>>>
17684>>>>>>>>>>>// Embedded SQL column attribute constants
17684>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
17684>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
17684>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
17684>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
17684>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
17684>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
17684>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
17684>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
17684>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
17684>>>>>>>>>>>
17684>>>>>>>>>>>
17684>>>>>>>>>>>// Types used for conversion with ConvertToXml
17684>>>>>>>>>>>Define esqlTime      for 8
17684>>>>>>>>>>>Define esqlDatetime  for 9
17684>>>>>>>>>>>
17684>>>>>>>>>>>// Global variables holding last executed embedded SQL connection and statement handles.
17684>>>>>>>>>>>Integer giLastSQLhdbc
17684>>>>>>>>>>>Integer giLastSQLhstmt
17684>>>>>>>>>>>
17684>>>>>>>>>>>Move -1 to giLastSQLhdbc
17685>>>>>>>>>>>Move -1 to giLastSQLhstmt
17686>>>>>>>>>>>
17686>>>>>>>>>>>Struct tSQLColumn
17686>>>>>>>>>>>    Integer iSQLType
17686>>>>>>>>>>>    Integer iSQLSize
17686>>>>>>>>>>>    Integer iSQLPrecision
17686>>>>>>>>>>>    Integer iVariableDataType
17686>>>>>>>>>>>End_Struct
17686>>>>>>>>>>>
17686>>>>>>>>>>>// Statement object for embedded sql                           
17686>>>>>>>>>>>//   An object is created for each statement. These will be children    
17686>>>>>>>>>>>//   of cSQLConnection objects which manage the create and destruction  
17686>>>>>>>>>>>//   of these.                                                          
17686>>>>>>>>>>>
17686>>>>>>>>>>>Class cSQLStatement is a cObject
17687>>>>>>>>>>>    
17687>>>>>>>>>>>    Procedure Construct_object
17689>>>>>>>>>>>        Forward Send Construct_object
17691>>>>>>>>>>>        
17691>>>>>>>>>>>        Property Handle  phCLIStatementHandle   0
17692>>>>>>>>>>>        Property Handle  phCLIConnectionHandle  0
17693>>>>>>>>>>>        Property String  psDriverID             ""
17694>>>>>>>>>>>        
17694>>>>>>>>>>>        Property Integer piLastColumn      0
17695>>>>>>>>>>>        Property Integer piLastArgument    0
17696>>>>>>>>>>>        Property Integer piBindFile        0
17697>>>>>>>>>>>        Property Integer piColumnCount     0
17698>>>>>>>>>>>        
17698>>>>>>>>>>>        // Allocated buffer for SQLColumnValue.
17698>>>>>>>>>>>        // Allocated size is size of the largest (not variable length) column
17698>>>>>>>>>>>        Property String  psMaxColValue     ""
17699>>>>>>>>>>>        
17699>>>>>>>>>>>        // True if there is at least 1 column with a variable length data type
17699>>>>>>>>>>>        Property Integer piHasVariableDataType  0
17700>>>>>>>>>>>        
17700>>>>>>>>>>>        // Max size of buffer for variable length data. Default 16000
17700>>>>>>>>>>>        Property Integer piMaxVariableBufferLength 16000
17701>>>>>>>>>>>        
17701>>>>>>>>>>>        // Allocated buffer for SQLGetData.
17701>>>>>>>>>>>        Property String  psVariableBuffer  ""
17702>>>>>>>>>>>        
17702>>>>>>>>>>>        // Allocated size of psVariableBuffer
17702>>>>>>>>>>>        Property Integer piVariableBufferLength 0
17703>>>>>>>>>>>        
17703>>>>>>>>>>>        // Stores column properties of a result set.
17703>>>>>>>>>>>        Property tSQLColumn[] paSQLColumns
17704>>>>>>>>>>>        
17704>>>>>>>>>>>        // piFetchResult is set by SQLFetchRowValues and SQLFetchResultSetValues
17704>>>>>>>>>>>        //   0    = Fetch returned no data.
17704>>>>>>>>>>>        //   <> 0 = Row fetched
17704>>>>>>>>>>>        Property Integer piFetchResult     0
17705>>>>>>>>>>>        
17705>>>>>>>>>>>        
17705>>>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
17706>>>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
17707>>>>>>>>>>>        
17707>>>>>>>>>>>    End_Procedure
17708>>>>>>>>>>>    
17708>>>>>>>>>>>    // Store basic information about the statement.
17708>>>>>>>>>>>    Procedure StoreStatementInfo Handle hCLIStatementHandle String sDrvrId Handle hCLIConnectionHandle
17710>>>>>>>>>>>        
17710>>>>>>>>>>>        Set phCLIStatementHandle   to hCLIStatementHandle
17711>>>>>>>>>>>        Set phCLIConnectionHandle  to hCLIConnectionHandle
17712>>>>>>>>>>>        Set psDriverID             to sDrvrId
17713>>>>>>>>>>>        
17713>>>>>>>>>>>    End_Procedure
17714>>>>>>>>>>>    
17714>>>>>>>>>>>    
17714>>>>>>>>>>>    // Destroy the cSQLStatement object
17714>>>>>>>>>>>    Procedure DestroySQLStatement
17716>>>>>>>>>>>        Send Destroy
17717>>>>>>>>>>>    End_Procedure
17718>>>>>>>>>>>    
17718>>>>>>>>>>>    // Handle an error that has occurred while checking properties.
17718>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
17720>>>>>>>>>>>        Integer iErrHandle
17720>>>>>>>>>>>        Integer iErrNum
17720>>>>>>>>>>>        String  sLocationInfo
17720>>>>>>>>>>>        
17720>>>>>>>>>>>        // Get the DataFlex statement identifier
17720>>>>>>>>>>>        Move Self to iErrHandle
17721>>>>>>>>>>>        
17721>>>>>>>>>>>        // Determine error number
17721>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
17724>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
17728>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
17732>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
17734>>>>>>>>>>>        
17734>>>>>>>>>>>        // Create location ifnormation
17734>>>>>>>>>>>        Move "[" to sLocationInfo
17735>>>>>>>>>>>        If (sOriginMsg <> "") Begin
17737>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
17738>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
17739>>>>>>>>>>>        End
17739>>>>>>>>>>>>
17739>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
17740>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
17741>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
17742>>>>>>>>>>>        
17742>>>>>>>>>>>        // Generate the error
17742>>>>>>>>>>>        Error iErrNum sLocationInfo
17743>>>>>>>>>>>>
17743>>>>>>>>>>>    End_Procedure
17744>>>>>>>>>>>    
17744>>>>>>>>>>>    // Handle general error not related to the properties
17744>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
17746>>>>>>>>>>>        Integer iErrHandle
17746>>>>>>>>>>>        String  sLocationInfo
17746>>>>>>>>>>>        
17746>>>>>>>>>>>        // Get the DataFlex statement identifier
17746>>>>>>>>>>>        Move Self to iErrHandle
17747>>>>>>>>>>>        
17747>>>>>>>>>>>        // Create location information
17747>>>>>>>>>>>        Move "[" to sLocationInfo
17748>>>>>>>>>>>        If (sOriginMsg <> "") Begin
17750>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
17751>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
17752>>>>>>>>>>>        End
17752>>>>>>>>>>>>
17752>>>>>>>>>>>        If (sErrtext <> "") Begin
17754>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
17755>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
17756>>>>>>>>>>>        End
17756>>>>>>>>>>>>
17756>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
17757>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
17758>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
17759>>>>>>>>>>>        
17759>>>>>>>>>>>        // Generate the error
17759>>>>>>>>>>>        Error iErrNum sLocationInfo
17760>>>>>>>>>>>>
17760>>>>>>>>>>>    End_Procedure
17761>>>>>>>>>>>    
17761>>>>>>>>>>>    // Handle an illegal attribute error
17761>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
17763>>>>>>>>>>>        Integer bReport
17763>>>>>>>>>>>        
17763>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
17766>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
17769>>>>>>>>>>>    End_Procedure
17770>>>>>>>>>>>    
17770>>>>>>>>>>>    // Check if a column number is legal
17770>>>>>>>>>>>    Function SQLPrivateColumnIsLegal Integer ihdbc String sDrvrId Integer ihstmt Integer iCol Returns Integer
17772>>>>>>>>>>>        Integer bLegal
17772>>>>>>>>>>>        Integer iNumColumns
17772>>>>>>>>>>>        
17772>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
17773>>>>>>>>>>>        If (iCol > 0 and iCol <= iNumColumns) ;            Move DFTRUE to bLegal
17776>>>>>>>>>>>        Else ;            Move DFFALSE to bLegal
17778>>>>>>>>>>>        
17778>>>>>>>>>>>        Function_Return bLegal
17779>>>>>>>>>>>    End_Function
17780>>>>>>>>>>>    
17780>>>>>>>>>>>    
17780>>>>>>>>>>>    
17780>>>>>>>>>>>    // Close a statement and free all alllocated resources
17780>>>>>>>>>>>    Procedure SQLClose
17782>>>>>>>>>>>        Integer ihdbc
17782>>>>>>>>>>>        Integer ihstmt
17782>>>>>>>>>>>        Integer iVoid
17782>>>>>>>>>>>        String  sDrvrId
17782>>>>>>>>>>>        String  sEmpty
17782>>>>>>>>>>>        
17782>>>>>>>>>>>        // Initialize
17782>>>>>>>>>>>        Move "" to sEmpty
17783>>>>>>>>>>>        
17783>>>>>>>>>>>        // Get the cli handles
17783>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
17784>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
17785>>>>>>>>>>>        Get psDriverId            to sDrvrId
17786>>>>>>>>>>>        
17786>>>>>>>>>>>        // Free the CLI handle
17786>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
17788>>>>>>>>>>>            // Call the driver function to close
17788>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCLOSE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
17793>>>>>>>>>>>            
17793>>>>>>>>>>>            Move -1 to giLastSQLhstmt
17794>>>>>>>>>>>            // Free the DataFlex handle
17794>>>>>>>>>>>            Send DestroySQLStatement
17795>>>>>>>>>>>        End
17795>>>>>>>>>>>>
17795>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLClose"
17797>>>>>>>>>>>    End_Procedure
17798>>>>>>>>>>>    
17798>>>>>>>>>>>    // Prepare a statement for execution
17798>>>>>>>>>>>    Procedure SQLPrepare String sStatement
17800>>>>>>>>>>>        Integer ihdbc
17800>>>>>>>>>>>        Integer ihstmt
17800>>>>>>>>>>>        Integer iVoid
17800>>>>>>>>>>>        String  sDrvrId
17800>>>>>>>>>>>        
17800>>>>>>>>>>>        // Get the cli handles
17800>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
17801>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
17802>>>>>>>>>>>        Get psDriverId            to sDrvrId
17803>>>>>>>>>>>        
17803>>>>>>>>>>>        // Prepare
17803>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
17805>>>>>>>>>>>            // Call the driver function to prepare
17805>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLPREPARE ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
17810>>>>>>>>>>>            Set piLastArgument to 0
17811>>>>>>>>>>>
17811>>>>>>>>>>>        End
17811>>>>>>>>>>>>
17811>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrepare"
17813>>>>>>>>>>>    End_Procedure
17814>>>>>>>>>>>    
17814>>>>>>>>>>>    Procedure SQLGetStatementAttributes
17816>>>>>>>>>>>        Integer ihdbc ihstmt iNumColumns iCol iMaxSize
17816>>>>>>>>>>>        String sMaxValue
17816>>>>>>>>>>>        tSQLColumn[] aSQLColumns
17816>>>>>>>>>>>        tSQLColumn[] aSQLColumns
17817>>>>>>>>>>>        
17817>>>>>>>>>>>        Integer iSqlType
17817>>>>>>>>>>>        Integer iSQLSize
17817>>>>>>>>>>>        Integer iSQLprecision
17817>>>>>>>>>>>        Integer iVariableDataType
17817>>>>>>>>>>>        
17817>>>>>>>>>>>        String  sDrvrId
17817>>>>>>>>>>>        
17817>>>>>>>>>>>        Integer iHasVariableDataType
17817>>>>>>>>>>>        
17817>>>>>>>>>>>        Move 0 to iHasVariableDataType
17818>>>>>>>>>>>        
17818>>>>>>>>>>>        
17818>>>>>>>>>>>        // Get the cli handles
17818>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
17819>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
17820>>>>>>>>>>>        Get psDriverId            to sDrvrId
17821>>>>>>>>>>>        
17821>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
17822>>>>>>>>>>>        
17822>>>>>>>>>>>        Set piColumnCount to iNumColumns
17823>>>>>>>>>>>        
17823>>>>>>>>>>>        // Fill columns array
17823>>>>>>>>>>>        For iCol from 1 to iNumColumns
17829>>>>>>>>>>>>
17829>>>>>>>>>>>            Move 0 to iVariableDataType
17830>>>>>>>>>>>            
17830>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SQLTYPE ihdbc sDrvrId ihstmt to iSQLType
17831>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_SIZE ihdbc sDrvrId ihstmt to iSQLSize
17832>>>>>>>>>>>            Get SQLPrivateColAttribute iCol SQLCOLATTRIB_PRECISION ihdbc sDrvrId ihstmt to iSQLPrecision
17833>>>>>>>>>>>            
17833>>>>>>>>>>>            If ( (iSQLType = SQL_LONGVARCHAR) or (iSQLType = SQL_WLONGVARCHAR) ) Begin
17835>>>>>>>>>>>                // text type
17835>>>>>>>>>>>                Move 1 to iVariableDataType
17836>>>>>>>>>>>            End
17836>>>>>>>>>>>>
17836>>>>>>>>>>>            Else Begin
17837>>>>>>>>>>>                If (sDrvrId = "MSSQLDRV") Begin
17839>>>>>>>>>>>                    // SQL Server varchar(max) and nvarchar(max) types return Size = 0
17839>>>>>>>>>>>                    If ( ((iSQLType = SQL_VARCHAR) and (iSQLSize = 0) ) or ;                        ((iSQLType = SQL_WVARCHAR) and (iSQLSize = 0) ) ) Begin
17841>>>>>>>>>>>                        
17841>>>>>>>>>>>                        Move 1 to iVariableDataType
17842>>>>>>>>>>>                    End
17842>>>>>>>>>>>>
17842>>>>>>>>>>>                End
17842>>>>>>>>>>>>
17842>>>>>>>>>>>            End
17842>>>>>>>>>>>>
17842>>>>>>>>>>>            
17842>>>>>>>>>>>            Move iSqlType           to aSQLColumns[iCol].iSQLType
17843>>>>>>>>>>>            Move iSQLSize           to aSQLColumns[iCol].iSQLSize
17844>>>>>>>>>>>            Move iSQLPrecision      to aSQLColumns[iCol].iSQLPrecision
17845>>>>>>>>>>>            Move iVariableDataType  to aSQLColumns[iCol].iVariableDataType
17846>>>>>>>>>>>            
17846>>>>>>>>>>>            If (not(iVariableDataType)) Begin
17848>>>>>>>>>>>                If (iSQLSize > iMaxSize) Begin
17850>>>>>>>>>>>                    Move iSQLSize to iMaxSize
17851>>>>>>>>>>>                End
17851>>>>>>>>>>>>
17851>>>>>>>>>>>            End
17851>>>>>>>>>>>>
17851>>>>>>>>>>>            Else Begin
17852>>>>>>>>>>>                Move 1 to iHasVariableDataType
17853>>>>>>>>>>>            End
17853>>>>>>>>>>>>
17853>>>>>>>>>>>            
17853>>>>>>>>>>>        Loop
17854>>>>>>>>>>>>
17854>>>>>>>>>>>        
17854>>>>>>>>>>>        Move (Repeat(' ', iMaxSize + 3)) to sMaxValue
17855>>>>>>>>>>>        Set psMaxColValue to sMaxValue
17856>>>>>>>>>>>        
17856>>>>>>>>>>>        Set paSQLColumns   to aSQLColumns
17857>>>>>>>>>>>        Set piHasVariableDataType to iHasVariableDataType
17858>>>>>>>>>>>        
17858>>>>>>>>>>>    End_Procedure
17859>>>>>>>>>>>    
17859>>>>>>>>>>>    // Execute a prepared statement
17859>>>>>>>>>>>    Procedure SQLExecute
17861>>>>>>>>>>>        Integer ihdbc
17861>>>>>>>>>>>        Integer ihstmt
17861>>>>>>>>>>>        Integer iVoid
17861>>>>>>>>>>>        String  sDrvrId
17861>>>>>>>>>>>        String  sEmpty
17861>>>>>>>>>>>        
17861>>>>>>>>>>>        // Initialize
17861>>>>>>>>>>>        Move "" to sEmpty
17862>>>>>>>>>>>        
17862>>>>>>>>>>>        // Get the cli handles
17862>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
17863>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
17864>>>>>>>>>>>        Get psDriverId            to sDrvrId
17865>>>>>>>>>>>        
17865>>>>>>>>>>>        // Execute
17865>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
17867>>>>>>>>>>>            // Call the driver function to execute
17867>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECUTE ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
17872>>>>>>>>>>>            Send SQLGetStatementAttributes
17873>>>>>>>>>>>            Set piLastArgument to 0
17874>>>>>>>>>>>        End
17874>>>>>>>>>>>>
17874>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecute"
17876>>>>>>>>>>>    End_Procedure
17877>>>>>>>>>>>    
17877>>>>>>>>>>>    
17877>>>>>>>>>>>    
17877>>>>>>>>>>>    // Prepare and execute a statement
17877>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
17879>>>>>>>>>>>        Integer ihdbc
17879>>>>>>>>>>>        Integer ihstmt
17879>>>>>>>>>>>        Integer iVoid
17879>>>>>>>>>>>        String  sDrvrId
17879>>>>>>>>>>>        
17879>>>>>>>>>>>        // Get the cli handles
17879>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
17880>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
17881>>>>>>>>>>>        Get psDriverId            to sDrvrId
17882>>>>>>>>>>>        
17882>>>>>>>>>>>        // ExecDirect
17882>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
17884>>>>>>>>>>>            // Call the driver function to execdirect
17884>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLEXECDIRECT ;                Callback Self ;                Passing ihdbc sStatement ihstmt ;                Result iVoid
17889>>>>>>>>>>>            Send SQLGetStatementAttributes
17890>>>>>>>>>>>        End
17890>>>>>>>>>>>>
17890>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLExecDirect"
17892>>>>>>>>>>>    End_Procedure
17893>>>>>>>>>>>    
17893>>>>>>>>>>>    // Fetch the next row
17893>>>>>>>>>>>    // Returns  : 0   = No more data
17893>>>>>>>>>>>    //<>0 = Success
17893>>>>>>>>>>>    Function SQLFetch Returns Integer
17895>>>>>>>>>>>        Integer ihdbc
17895>>>>>>>>>>>        Integer ihstmt
17895>>>>>>>>>>>        Integer iResult
17895>>>>>>>>>>>        String  sDrvrId
17895>>>>>>>>>>>        String  sEmpty
17895>>>>>>>>>>>        
17895>>>>>>>>>>>        // Initialize
17895>>>>>>>>>>>        Move "" to sEmpty
17896>>>>>>>>>>>        Move 0  to iResult
17897>>>>>>>>>>>        
17897>>>>>>>>>>>        // Get the cli handles
17897>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
17898>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
17899>>>>>>>>>>>        Get psDriverId            to sDrvrId
17900>>>>>>>>>>>        
17900>>>>>>>>>>>        // Fetch
17900>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
17902>>>>>>>>>>>            Move False to Err
17903>>>>>>>>>>>            
17903>>>>>>>>>>>            // Call the driver function to fetch
17903>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
17908>>>>>>>>>>>            
17908>>>>>>>>>>>            // If something went wrong, adjust the result
17908>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
17911>>>>>>>>>>>            
17911>>>>>>>>>>>            Set piLastcolumn to 0
17912>>>>>>>>>>>        End
17912>>>>>>>>>>>>
17912>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetch"
17914>>>>>>>>>>>        
17914>>>>>>>>>>>        Function_Return iResult
17915>>>>>>>>>>>    End_Function
17916>>>>>>>>>>>    
17916>>>>>>>>>>>    // Fetch the next row and return an array with all column values
17916>>>>>>>>>>>    // Returns  : Array of strings with all column values
17916>>>>>>>>>>>    // Sets piFetchResult property
17916>>>>>>>>>>>    //   0    = No more data
17916>>>>>>>>>>>    //   <> 0 = Success
17916>>>>>>>>>>>    Function SQLFetchRowValues Returns String[]
17918>>>>>>>>>>>        
17918>>>>>>>>>>>        String[] asValues
17919>>>>>>>>>>>        
17919>>>>>>>>>>>        tSQLColumn[] aSQLColumns
17919>>>>>>>>>>>        tSQLColumn[] aSQLColumns
17920>>>>>>>>>>>        
17920>>>>>>>>>>>        Integer ihdbc
17920>>>>>>>>>>>        Integer ihstmt
17920>>>>>>>>>>>        Integer iResult iVoid
17920>>>>>>>>>>>        Integer iColCount iCol
17920>>>>>>>>>>>        String  sDrvrId
17920>>>>>>>>>>>        String  sEmpty
17920>>>>>>>>>>>        String  sResult
17920>>>>>>>>>>>        String  sVariableResult
17920>>>>>>>>>>>        Integer iHasVariableDataType
17920>>>>>>>>>>>        Integer iLen
17920>>>>>>>>>>>        Integer iVariableBufferLength
17920>>>>>>>>>>>        
17920>>>>>>>>>>>        // Initialize
17920>>>>>>>>>>>        Move "" to sEmpty
17921>>>>>>>>>>>        Move 0  to iResult
17922>>>>>>>>>>>        
17922>>>>>>>>>>>        // Get the cli handles
17922>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
17923>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
17924>>>>>>>>>>>        Get psDriverId            to sDrvrId
17925>>>>>>>>>>>        
17925>>>>>>>>>>>        Get paSQLColumns to aSQLColumns
17926>>>>>>>>>>>        Get piColumnCount to iColCount
17927>>>>>>>>>>>        Get piHasVariableDataType to iHasVariableDataType
17928>>>>>>>>>>>        
17928>>>>>>>>>>>        If (iHasVariableDataType) Begin
17930>>>>>>>>>>>            
17930>>>>>>>>>>>            Get piVariableBufferLength      to iVariableBufferLength
17931>>>>>>>>>>>            Get piMaxVariableBufferLength   to iLen
17932>>>>>>>>>>>            
17932>>>>>>>>>>>            If (iLen > iVariableBufferLength) Begin
17934>>>>>>>>>>>                // Allocate
17934>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sVariableResult
17935>>>>>>>>>>>                
17935>>>>>>>>>>>                Set piVariableBufferLength to iLen
17936>>>>>>>>>>>                Set psVariableBuffer       to sVariableResult
17937>>>>>>>>>>>                
17937>>>>>>>>>>>                Get piVariableBufferLength to iVariableBufferLength
17938>>>>>>>>>>>            End
17938>>>>>>>>>>>>
17938>>>>>>>>>>>        End
17938>>>>>>>>>>>>
17938>>>>>>>>>>>        
17938>>>>>>>>>>>        // Fetch
17938>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
17940>>>>>>>>>>>            Move (False) to Err
17941>>>>>>>>>>>            
17941>>>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
17941>>>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
17941>>>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
17941>>>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
17943>>>>>>>>>>>                // Setup function arguments
17943>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
17948>>>>>>>>>>>                Move ihstmt to giLastSQLhstmt
17949>>>>>>>>>>>                Move ihdbc to giLastSQLhdbc
17950>>>>>>>>>>>            End
17950>>>>>>>>>>>>
17950>>>>>>>>>>>            
17950>>>>>>>>>>>            // Call the driver function to fetch
17950>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback 0 Passing ihdbc sEmpty ihstmt Result iResult
17955>>>>>>>>>>>            
17955>>>>>>>>>>>            // If something went wrong, adjust the result
17955>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
17958>>>>>>>>>>>            
17958>>>>>>>>>>>            If (iResult) Begin
17960>>>>>>>>>>>                For iCol from 1 to iColCount
17966>>>>>>>>>>>>
17966>>>>>>>>>>>                    
17966>>>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
17968>>>>>>>>>>>                        Get psMaxColValue to sResult
17969>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE Callback 0 Passing sResult sEmpty iCol Result iVoid
17974>>>>>>>>>>>                        
17974>>>>>>>>>>>                        Move sResult to asValues[iCol - 1]
17975>>>>>>>>>>>                    End
17975>>>>>>>>>>>>
17975>>>>>>>>>>>                    Else Begin
17976>>>>>>>>>>>                        Get psVariableBuffer       to sVariableResult
17977>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing sVariableResult iCol iVariableBufferLength ;                            Result iVoid
17982>>>>>>>>>>>                        
17982>>>>>>>>>>>                        Move sVariableResult to asValues[iCol - 1]
17983>>>>>>>>>>>                    End
17983>>>>>>>>>>>>
17983>>>>>>>>>>>                    
17983>>>>>>>>>>>                Loop
17984>>>>>>>>>>>>
17984>>>>>>>>>>>            End
17984>>>>>>>>>>>>
17984>>>>>>>>>>>        End
17984>>>>>>>>>>>>
17984>>>>>>>>>>>        Else Begin
17985>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchRowValues"
17986>>>>>>>>>>>        End
17986>>>>>>>>>>>>
17986>>>>>>>>>>>        
17986>>>>>>>>>>>        Set piFetchResult to iResult
17987>>>>>>>>>>>        
17987>>>>>>>>>>>        Function_Return asValues
17988>>>>>>>>>>>        
17988>>>>>>>>>>>    End_Function
17989>>>>>>>>>>>    
17989>>>>>>>>>>>    // Fetch a complete result set.
17989>>>>>>>>>>>    // Returns  : 2-dimensional array of strings with result set
17989>>>>>>>>>>>    // Sets piFetchResult property
17989>>>>>>>>>>>    //   0    = No more data
17989>>>>>>>>>>>    //   <> 0 = Success
17989>>>>>>>>>>>    Function SQLFetchResultsetValues Returns String[][]
17991>>>>>>>>>>>        
17991>>>>>>>>>>>        String[][] asValues
17992>>>>>>>>>>>        
17992>>>>>>>>>>>        Integer ihdbc ihstmt iResult iVoid iColCount iCol iRow
17992>>>>>>>>>>>        String sDrvrId sEmpty sResult sMax
17992>>>>>>>>>>>        
17992>>>>>>>>>>>        tSQLColumn[] aSQLColumns
17992>>>>>>>>>>>        tSQLColumn[] aSQLColumns
17993>>>>>>>>>>>        String  sVariableResult
17993>>>>>>>>>>>        Integer iHasVariableDataType
17993>>>>>>>>>>>        Integer iLen
17993>>>>>>>>>>>        Integer iVariableBufferLength
17993>>>>>>>>>>>        
17993>>>>>>>>>>>        // Initialize
17993>>>>>>>>>>>        Move "" to sEmpty
17994>>>>>>>>>>>        Move 0  to iResult
17995>>>>>>>>>>>        
17995>>>>>>>>>>>        // Get the cli handles
17995>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
17996>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
17997>>>>>>>>>>>        Get psDriverId            to sDrvrId
17998>>>>>>>>>>>        
17998>>>>>>>>>>>        // Fetch
17998>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18000>>>>>>>>>>>            Move False to Err
18001>>>>>>>>>>>            
18001>>>>>>>>>>>            // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
18001>>>>>>>>>>>            // in the next FUNC_SQLCOLUMNVALUE call.
18001>>>>>>>>>>>            // If hdbc and hstmt have not changed since the last call we don't have to set it.
18001>>>>>>>>>>>            If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
18003>>>>>>>>>>>                // Setup function arguments
18003>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO Callback 0 Passing ihdbc iCol ihstmt Result iVoid
18008>>>>>>>>>>>                Move ihstmt to giLastSQLhstmt
18009>>>>>>>>>>>                Move ihdbc to giLastSQLhdbc
18010>>>>>>>>>>>            End
18010>>>>>>>>>>>>
18010>>>>>>>>>>>            
18010>>>>>>>>>>>            
18010>>>>>>>>>>>            Get paSQLColumns to aSQLColumns
18011>>>>>>>>>>>            Get piColumnCount to iColCount
18012>>>>>>>>>>>            Get piHasVariableDataType to iHasVariableDataType
18013>>>>>>>>>>>            If (iHasVariableDataType) Begin
18015>>>>>>>>>>>                Get piVariableBufferLength      to iVariableBufferLength
18016>>>>>>>>>>>                Get piMaxVariableBufferLength   to iLen
18017>>>>>>>>>>>                If (iLen > iVariableBufferLength) Begin
18019>>>>>>>>>>>                    // Allocate
18019>>>>>>>>>>>                    Move (Repeat(' ', iLen)) to sVariableResult
18020>>>>>>>>>>>                    
18020>>>>>>>>>>>                    Set piVariableBufferLength to iLen
18021>>>>>>>>>>>                    Set psVariableBuffer       to sVariableResult
18022>>>>>>>>>>>                    
18022>>>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
18023>>>>>>>>>>>                End
18023>>>>>>>>>>>>
18023>>>>>>>>>>>                Else Begin
18024>>>>>>>>>>>                    Set psVariableBuffer       to sVariableResult
18025>>>>>>>>>>>                End
18025>>>>>>>>>>>>
18025>>>>>>>>>>>            End
18025>>>>>>>>>>>>
18025>>>>>>>>>>>            
18025>>>>>>>>>>>            Get psMaxColValue to sMax
18026>>>>>>>>>>>            
18026>>>>>>>>>>>            // Call the driver function to fetch
18026>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
18031>>>>>>>>>>>            If (Err) ;                Move 0 to iResult
18034>>>>>>>>>>>            
18034>>>>>>>>>>>            While (iResult <> 0)
18038>>>>>>>>>>>                
18038>>>>>>>>>>>                For iCol from 1 to (iColCount)
18044>>>>>>>>>>>>
18044>>>>>>>>>>>                    
18044>>>>>>>>>>>                    If (not(aSQLColumns[iCol].iVariableDataType)) Begin
18046>>>>>>>>>>>                        Move sMax to sResult
18047>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                            Callback 0 ;                            Passing sResult sEmpty iCol ;                            Result iVoid
18052>>>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
18053>>>>>>>>>>>                    End
18053>>>>>>>>>>>>
18053>>>>>>>>>>>                    Else Begin
18054>>>>>>>>>>>                        //Variable data
18054>>>>>>>>>>>                        Move sVariableResult to sResult
18055>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                            Callback 0 ;                            Passing sResult iCol iVariableBufferLength ;                            Result iVoid
18060>>>>>>>>>>>                        
18060>>>>>>>>>>>                        Move sResult to asValues[iRow][iCol - 1]
18061>>>>>>>>>>>                    End
18061>>>>>>>>>>>>
18061>>>>>>>>>>>                Loop
18062>>>>>>>>>>>>
18062>>>>>>>>>>>                
18062>>>>>>>>>>>                Increment iRow
18063>>>>>>>>>>>                
18063>>>>>>>>>>>                // Call the driver function to fetch
18063>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLFETCH Callback Self Passing ihdbc sEmpty ihstmt Result iResult
18068>>>>>>>>>>>                If (Err) ;                    Move 0 to iResult
18071>>>>>>>>>>>                
18071>>>>>>>>>>>            Loop
18072>>>>>>>>>>>>
18072>>>>>>>>>>>            
18072>>>>>>>>>>>        End
18072>>>>>>>>>>>>
18072>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLFetchResultsetValues"
18074>>>>>>>>>>>        
18074>>>>>>>>>>>        Set piFetchResult to iResult
18075>>>>>>>>>>>        
18075>>>>>>>>>>>        Function_Return asValues
18076>>>>>>>>>>>    End_Function
18077>>>>>>>>>>>    
18077>>>>>>>>>>>    // Get the next column
18077>>>>>>>>>>>    Function SQLNextColumn Returns String
18079>>>>>>>>>>>        Integer iCol
18079>>>>>>>>>>>        String  sResult
18079>>>>>>>>>>>        
18079>>>>>>>>>>>        Get piLastColumn to iCol
18080>>>>>>>>>>>        Increment iCol
18081>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
18082>>>>>>>>>>>        Set piLastColumn to iCol
18083>>>>>>>>>>>        
18083>>>>>>>>>>>        Function_Return sResult
18084>>>>>>>>>>>    End_Function
18085>>>>>>>>>>>    
18085>>>>>>>>>>>    
18085>>>>>>>>>>>    // Returns the native type of a column
18085>>>>>>>>>>>    Function SQLColumnType Integer iCol Returns Integer
18087>>>>>>>>>>>        Integer ihdbc
18087>>>>>>>>>>>        Integer ihstmt
18087>>>>>>>>>>>        String  sDrvrId
18087>>>>>>>>>>>        Integer iSQLType
18087>>>>>>>>>>>        Integer iColumns
18087>>>>>>>>>>>        
18087>>>>>>>>>>>        tSQLColumn[] aSQLColumns
18087>>>>>>>>>>>        tSQLColumn[] aSQLColumns
18088>>>>>>>>>>>        
18088>>>>>>>>>>>        // Get the cli handles
18088>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18089>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18090>>>>>>>>>>>        Get psDriverId            to sDrvrId
18091>>>>>>>>>>>        
18091>>>>>>>>>>>        // Get the value
18091>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18093>>>>>>>>>>>            
18093>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
18094>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
18095>>>>>>>>>>>            
18095>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
18097>>>>>>>>>>>                Move aSQLColumns[iCol].iSQLType to iSQLType
18098>>>>>>>>>>>            End
18098>>>>>>>>>>>>
18098>>>>>>>>>>>            Else Begin
18099>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnType"
18100>>>>>>>>>>>            End
18100>>>>>>>>>>>>
18100>>>>>>>>>>>        End
18100>>>>>>>>>>>>
18100>>>>>>>>>>>        Else Begin
18101>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnType"
18102>>>>>>>>>>>        End
18102>>>>>>>>>>>>
18102>>>>>>>>>>>        
18102>>>>>>>>>>>        Function_Return iSQLType
18103>>>>>>>>>>>    End_Function
18104>>>>>>>>>>>    
18104>>>>>>>>>>>    // Returns the size (max length) of a column
18104>>>>>>>>>>>    Function SQLColumnSize Integer iCol Returns Integer
18106>>>>>>>>>>>        Integer ihdbc
18106>>>>>>>>>>>        Integer ihstmt
18106>>>>>>>>>>>        String  sDrvrId
18106>>>>>>>>>>>        Integer iSQLSize
18106>>>>>>>>>>>        Integer iColumns
18106>>>>>>>>>>>        
18106>>>>>>>>>>>        tSQLColumn[] aSQLColumns
18106>>>>>>>>>>>        tSQLColumn[] aSQLColumns
18107>>>>>>>>>>>        
18107>>>>>>>>>>>        // Get the cli handles
18107>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18108>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18109>>>>>>>>>>>        Get psDriverId            to sDrvrId
18110>>>>>>>>>>>        
18110>>>>>>>>>>>        // Get the value
18110>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18112>>>>>>>>>>>            
18112>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
18113>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
18114>>>>>>>>>>>            
18114>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
18116>>>>>>>>>>>                Move aSQLColumns[iCol].iSQLSize to iSQLSize
18117>>>>>>>>>>>            End
18117>>>>>>>>>>>>
18117>>>>>>>>>>>            Else Begin
18118>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnSize"
18119>>>>>>>>>>>            End
18119>>>>>>>>>>>>
18119>>>>>>>>>>>        End
18119>>>>>>>>>>>>
18119>>>>>>>>>>>        Else Begin
18120>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnSize"
18121>>>>>>>>>>>        End
18121>>>>>>>>>>>>
18121>>>>>>>>>>>        
18121>>>>>>>>>>>        Function_Return iSQLSize
18122>>>>>>>>>>>    End_Function
18123>>>>>>>>>>>    
18123>>>>>>>>>>>    //  Returns 1 for variable length datatypes.
18123>>>>>>>>>>>    //  For example SQL Server varchar(max) or text type
18123>>>>>>>>>>>    //  The data of variable length datatype columns should be retrieved with SQLGetData
18123>>>>>>>>>>>    Function SQLColumnVariableDatatype Integer iCol Returns Integer
18125>>>>>>>>>>>        Integer ihdbc
18125>>>>>>>>>>>        Integer ihstmt
18125>>>>>>>>>>>        String  sDrvrId
18125>>>>>>>>>>>        Integer iVariableDataType
18125>>>>>>>>>>>        Integer iColumns
18125>>>>>>>>>>>        
18125>>>>>>>>>>>        tSQLColumn[] aSQLColumns
18125>>>>>>>>>>>        tSQLColumn[] aSQLColumns
18126>>>>>>>>>>>        
18126>>>>>>>>>>>        // Get the cli handles
18126>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18127>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18128>>>>>>>>>>>        Get psDriverId            to sDrvrId
18129>>>>>>>>>>>        
18129>>>>>>>>>>>        // Get the value
18129>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18131>>>>>>>>>>>            
18131>>>>>>>>>>>            Get paSQLColumns   to aSQLColumns
18132>>>>>>>>>>>            Move (SizeOfArray(aSQLColumns)) to iColumns
18133>>>>>>>>>>>            
18133>>>>>>>>>>>            If (iCol >= 1 and iCol <= iColumns) Begin
18135>>>>>>>>>>>                Move aSQLColumns[iCol].iVariableDataType to iVariableDataType
18136>>>>>>>>>>>            End
18136>>>>>>>>>>>>
18136>>>>>>>>>>>            Else Begin
18137>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnVariableDatatype"
18138>>>>>>>>>>>            End
18138>>>>>>>>>>>>
18138>>>>>>>>>>>        End
18138>>>>>>>>>>>>
18138>>>>>>>>>>>        Else Begin
18139>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLColumnVariableDatatype"
18140>>>>>>>>>>>        End
18140>>>>>>>>>>>>
18140>>>>>>>>>>>        
18140>>>>>>>>>>>        Function_Return iVariableDataType
18141>>>>>>>>>>>    End_Function
18142>>>>>>>>>>>    
18142>>>>>>>>>>>    
18142>>>>>>>>>>>    // Return the value of a column in a fetched row of a given
18142>>>>>>>>>>>    // statement.
18142>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
18144>>>>>>>>>>>        Integer ihdbc
18144>>>>>>>>>>>        Integer ihstmt
18144>>>>>>>>>>>        String  sDrvrId
18144>>>>>>>>>>>        String  sResult
18144>>>>>>>>>>>        
18144>>>>>>>>>>>        Integer iVoid
18144>>>>>>>>>>>        Integer iColSize
18144>>>>>>>>>>>        Integer iColPrecision
18144>>>>>>>>>>>        String  sEmpty
18144>>>>>>>>>>>        Integer bLegalColumn
18144>>>>>>>>>>>        
18144>>>>>>>>>>>        // Initialize
18144>>>>>>>>>>>        Move "" to sResult
18145>>>>>>>>>>>        
18145>>>>>>>>>>>        // Get the cli handles
18145>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18146>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18147>>>>>>>>>>>        Get psDriverId            to sDrvrId
18148>>>>>>>>>>>        
18148>>>>>>>>>>>        // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
18148>>>>>>>>>>>        // in the next FUNC_SQLCOLUMNVALUE call.
18148>>>>>>>>>>>        // If hdbc and hstmt have not changed since the last call we don't have to set it.
18148>>>>>>>>>>>        If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
18150>>>>>>>>>>>            // Setup function arguments
18150>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback 0 ;                Passing ihdbc iCol ihstmt ;                Result iVoid
18155>>>>>>>>>>>            Move ihstmt to giLastSQLhstmt
18156>>>>>>>>>>>            Move ihdbc to giLastSQLhdbc
18157>>>>>>>>>>>        End
18157>>>>>>>>>>>>
18157>>>>>>>>>>>        
18157>>>>>>>>>>>        If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
18159>>>>>>>>>>>            Get psMaxColValue to sResult
18160>>>>>>>>>>>            // Call the driver function to get the value
18160>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNVALUE ;                Callback 0 ;                Passing sResult sEmpty iCol ;                Result iVoid
18165>>>>>>>>>>>        End
18165>>>>>>>>>>>>
18165>>>>>>>>>>>        Else Begin
18166>>>>>>>>>>>            Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLColumnValue"
18167>>>>>>>>>>>        End
18167>>>>>>>>>>>>
18167>>>>>>>>>>>        
18167>>>>>>>>>>>        Function_Return sResult
18168>>>>>>>>>>>        
18168>>>>>>>>>>>    End_Function
18169>>>>>>>>>>>    
18169>>>>>>>>>>>    // Add a file to the files used to place the statement result in.
18169>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
18171>>>>>>>>>>>        Integer ihdbc
18171>>>>>>>>>>>        Integer ihstmt
18171>>>>>>>>>>>        Integer iVoid
18171>>>>>>>>>>>        String  sDrvrId
18171>>>>>>>>>>>        String  sFileType
18171>>>>>>>>>>>        Integer bIsOpen
18171>>>>>>>>>>>        
18171>>>>>>>>>>>        // Get the cli handles
18171>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18172>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18173>>>>>>>>>>>        Get psDriverId            to sDrvrId
18174>>>>>>>>>>>        
18174>>>>>>>>>>>        // If a file number is not passed see if we can use the statement's
18174>>>>>>>>>>>        // default file number which is usually set with SetFileConnection
18174>>>>>>>>>>>        If (iFileNum = 0) Begin
18176>>>>>>>>>>>            Get piBindFile to iFileNum
18177>>>>>>>>>>>            If (iFileNum = 0) Begin
18179>>>>>>>>>>>                // Logic error, if 0 is passed as filenumber, piBindFile should be set.
18179>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_BIND_FILE "piBindFile should be set" "SQLBindFile"
18180>>>>>>>>>>>                
18180>>>>>>>>>>>                Move 0 to SQLResult
18181>>>>>>>>>>>                Procedure_Return
18182>>>>>>>>>>>            End
18182>>>>>>>>>>>>
18182>>>>>>>>>>>        End
18182>>>>>>>>>>>>
18182>>>>>>>>>>>        
18182>>>>>>>>>>>        // Bind the file
18182>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18184>>>>>>>>>>>            // Chek if the file is open
18184>>>>>>>>>>>            Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
18187>>>>>>>>>>>            If (bIsOpen) Begin
18189>>>>>>>>>>>                // Check if the file has the correct type
18189>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
18192>>>>>>>>>>>                If (sFileType = sDrvrId) Begin
18194>>>>>>>>>>>                    // Call the driver function to add a file to a statement
18194>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLBINDFILE ;                        Callback Self ;                        Passing ihdbc iFileNum ihstmt ;                        Result iVoid
18199>>>>>>>>>>>                End
18199>>>>>>>>>>>>
18199>>>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
18201>>>>>>>>>>>            End
18201>>>>>>>>>>>>
18201>>>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File not open (number =" * String(iFileNum) + ")") "SQLBindFile"
18203>>>>>>>>>>>        End
18203>>>>>>>>>>>>
18203>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLBindFile"
18205>>>>>>>>>>>    End_Procedure
18206>>>>>>>>>>>    
18206>>>>>>>>>>>    
18206>>>>>>>>>>>    
18206>>>>>>>>>>>    // Get data of a column.                                  
18206>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
18208>>>>>>>>>>>        Integer ihdbc
18208>>>>>>>>>>>        Integer ihstmt
18208>>>>>>>>>>>        Integer iVoid
18208>>>>>>>>>>>        Integer iColSize
18208>>>>>>>>>>>        Integer iResult
18208>>>>>>>>>>>        String  sDrvrId
18208>>>>>>>>>>>        String  sResult
18208>>>>>>>>>>>        String  sEmpty
18208>>>>>>>>>>>        Integer bLegalColumn
18208>>>>>>>>>>>        
18208>>>>>>>>>>>        Integer iVariableBufferLength
18208>>>>>>>>>>>        
18208>>>>>>>>>>>        // Initialize
18208>>>>>>>>>>>        Move "" to sEmpty
18209>>>>>>>>>>>        Move 0 to iResult
18210>>>>>>>>>>>        
18210>>>>>>>>>>>        // Get the cli handles
18210>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18211>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18212>>>>>>>>>>>        Get psDriverId            to sDrvrId
18213>>>>>>>>>>>        
18213>>>>>>>>>>>        // Get the data
18213>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18215>>>>>>>>>>>            // Check if the column exists
18215>>>>>>>>>>>            If (iCol >= 1 and iCol <= piColumnCount(Self)) Begin
18217>>>>>>>>>>>                If (iLen = 0) Begin
18219>>>>>>>>>>>                    Get SQLColumnValue iCol to sResult
18220>>>>>>>>>>>                End
18220>>>>>>>>>>>>
18220>>>>>>>>>>>                Else Begin
18221>>>>>>>>>>>                    // Add 1 for string terminator
18221>>>>>>>>>>>                    Move (iLen + 1) to iLen
18222>>>>>>>>>>>                    
18222>>>>>>>>>>>                    Get piVariableBufferLength to iVariableBufferLength
18223>>>>>>>>>>>                    If (iLen > iVariableBufferLength) Begin
18225>>>>>>>>>>>                        // Allocate
18225>>>>>>>>>>>                        Move (Repeat(' ', iLen)) to sResult
18226>>>>>>>>>>>                        
18226>>>>>>>>>>>                        Set piVariableBufferLength to iLen
18227>>>>>>>>>>>                        Set psVariableBuffer       to sResult
18228>>>>>>>>>>>                    End
18228>>>>>>>>>>>>
18228>>>>>>>>>>>                    Else Begin
18229>>>>>>>>>>>                        Get psVariableBuffer       to sResult
18230>>>>>>>>>>>                    End
18230>>>>>>>>>>>>
18230>>>>>>>>>>>                    
18230>>>>>>>>>>>                    
18230>>>>>>>>>>>                    // FUNC_SQLCOLUMNINFO will tell the driver which hdbc and hstmt to use
18230>>>>>>>>>>>                    // in the next FUNC_SQLCOLUMNVALUE call.
18230>>>>>>>>>>>                    // If hdbc and hstmt have not changed since the last call we don't have to set it.
18230>>>>>>>>>>>                    If (ihstmt <> giLastSQLhstmt or ihdbc <> giLastSQLhdbc) Begin
18232>>>>>>>>>>>                        // Setup function arguments
18232>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                            Callback 0 ;                            Passing ihdbc iCol ihstmt ;                            Result iVoid
18237>>>>>>>>>>>                        Move ihstmt to giLastSQLhstmt
18238>>>>>>>>>>>                        Move ihdbc to giLastSQLhdbc
18239>>>>>>>>>>>                    End
18239>>>>>>>>>>>>
18239>>>>>>>>>>>                    
18239>>>>>>>>>>>                    Move False to Err
18240>>>>>>>>>>>                    // Call the driver function to get the data
18240>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLGETDATA ;                        Callback Self ;                        Passing sResult iCol iLen ;                        Result iResult
18245>>>>>>>>>>>                    
18245>>>>>>>>>>>                    // If something went wrong, adjust the result
18245>>>>>>>>>>>                    If (Err) Begin
18247>>>>>>>>>>>                        Move 0 to iResult
18248>>>>>>>>>>>                    End
18248>>>>>>>>>>>>
18248>>>>>>>>>>>                End
18248>>>>>>>>>>>>
18248>>>>>>>>>>>            End
18248>>>>>>>>>>>>
18248>>>>>>>>>>>            Else Begin
18249>>>>>>>>>>>                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLGetData"
18250>>>>>>>>>>>            End
18250>>>>>>>>>>>>
18250>>>>>>>>>>>        End
18250>>>>>>>>>>>>
18250>>>>>>>>>>>        Else Begin
18251>>>>>>>>>>>            Send HandleError ihstmt ihdbc sDrvrId "SQLGetData"
18252>>>>>>>>>>>        End
18252>>>>>>>>>>>>
18252>>>>>>>>>>>        
18252>>>>>>>>>>>        // Fill global result
18252>>>>>>>>>>>        Move iResult to SQLResult
18253>>>>>>>>>>>        
18253>>>>>>>>>>>        Function_Return sResult
18254>>>>>>>>>>>    End_Function
18255>>>>>>>>>>>    
18255>>>>>>>>>>>    
18255>>>>>>>>>>>    
18255>>>>>>>>>>>    // Map a column name to a number, if the name id not found no
18255>>>>>>>>>>>    // error is generated the returned number will be 0 (zero) in
18255>>>>>>>>>>>    // that case
18255>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
18257>>>>>>>>>>>        Integer ihdbc
18257>>>>>>>>>>>        Integer ihstmt
18257>>>>>>>>>>>        Integer iNumColumns
18257>>>>>>>>>>>        Integer iColCount
18257>>>>>>>>>>>        Integer iColNum
18257>>>>>>>>>>>        String  sDrvrId
18257>>>>>>>>>>>        String  sCurColName
18257>>>>>>>>>>>        
18257>>>>>>>>>>>        // Get the cli handles
18257>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18258>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18259>>>>>>>>>>>        Get psDriverId            to sDrvrId
18260>>>>>>>>>>>        
18260>>>>>>>>>>>        // Get the number by looping through the column names
18260>>>>>>>>>>>        Move 0 to iColNum
18261>>>>>>>>>>>        Get SQLPrivateStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT ihdbc sDrvrId ihstmt to iNumColumns
18262>>>>>>>>>>>        For iColCount from 1 to iNumColumns
18268>>>>>>>>>>>>
18268>>>>>>>>>>>            Get SQLPrivateColAttribute iColCount SQLCOLATTRIB_LABEL ihdbc sDrvrId ihstmt to sCurColName
18269>>>>>>>>>>>            If (Uppercase(Trim(sColName)) = Uppercase(Trim(sCurColName))) ;                Move iColCount to iColNum
18272>>>>>>>>>>>            
18272>>>>>>>>>>>            If (iColNum) ;                Break
18275>>>>>>>>>>>        Loop
18276>>>>>>>>>>>>
18276>>>>>>>>>>>        
18276>>>>>>>>>>>        Function_Return iColNum
18277>>>>>>>>>>>    End_Function
18278>>>>>>>>>>>    
18278>>>>>>>>>>>    
18278>>>>>>>>>>>    // SQLStmtAttribute
18278>>>>>>>>>>>    // Moved to SQLGetStatementAttribute. 
18278>>>>>>>>>>>    // This function is still here for backward compatibility.
18278>>>>>>>>>>>
18278>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
18280>>>>>>>>>>>        String  sResult
18280>>>>>>>>>>>
18280>>>>>>>>>>>        Get SQLGetStmtAttribute iAttribId to sResult        
18281>>>>>>>>>>>        
18281>>>>>>>>>>>        Function_Return sResult
18282>>>>>>>>>>>    End_Function
18283>>>>>>>>>>>
18283>>>>>>>>>>> 
18283>>>>>>>>>>>   Function SQLGetStmtAttribute Integer iAttribId Returns String
18285>>>>>>>>>>>        Integer ihdbc
18285>>>>>>>>>>>        Integer ihstmt
18285>>>>>>>>>>>        String  sResult
18285>>>>>>>>>>>        String  sDrvrId
18285>>>>>>>>>>>        
18285>>>>>>>>>>>        // Initialize
18285>>>>>>>>>>>        Move "" to sResult
18286>>>>>>>>>>>        
18286>>>>>>>>>>>        // Get the cli handles
18286>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18287>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18288>>>>>>>>>>>        Get psDriverId            to sDrvrId
18289>>>>>>>>>>>        
18289>>>>>>>>>>>        // Get the attribute
18289>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateStmtAttribute iAttribId ihdbc sDrvrId ihstmt to sResult
18292>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetStmtAttribute"
18294>>>>>>>>>>>        
18294>>>>>>>>>>>        Function_Return sResult
18295>>>>>>>>>>>    End_Function
18296>>>>>>>>>>>
18296>>>>>>>>>>>    
18296>>>>>>>>>>>    Procedure SQLSetStmtAttribute Integer iAttribId String sAttribValue 
18298>>>>>>>>>>>
18298>>>>>>>>>>>        Integer ihdbc
18298>>>>>>>>>>>        Integer ihstmt
18298>>>>>>>>>>>        String  sDrvrId
18298>>>>>>>>>>>        
18298>>>>>>>>>>>        Integer iLen
18298>>>>>>>>>>>        Integer bLegalAttrib
18298>>>>>>>>>>>        Integer iVoid
18298>>>>>>>>>>>        Integer iAttribValue
18298>>>>>>>>>>>
18298>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18299>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18300>>>>>>>>>>>        Get psDriverId            to sDrvrId
18301>>>>>>>>>>>        
18301>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18303>>>>>>>>>>>            Case Begin
18303>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
18305>>>>>>>>>>>                    Move DFTRUE to bLegalAttrib
18306>>>>>>>>>>>                    Break
18307>>>>>>>>>>>                    
18307>>>>>>>>>>>                Case Else
18307>>>>>>>>>>>                    Move DFFALSE to bLegalAttrib
18308>>>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLSetStmtAttribute"
18309>>>>>>>>>>>            Case End
18309>>>>>>>>>>>
18309>>>>>>>>>>>            If (bLegalAttrib) Begin
18311>>>>>>>>>>>                If (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE) Begin
18313>>>>>>>>>>>                    
18313>>>>>>>>>>>                    Move sAttribValue to iAttribValue // Check numeric?
18314>>>>>>>>>>>                    Case Begin
18314>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_FORWARD_ONLY)
18316>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_DYNAMIC)
18319>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_KEYSET_DRIVEN)
18322>>>>>>>>>>>                        Case (iAttribValue = SQL_CURSOR_STATIC)
18325>>>>>>>>>>>                            Break
18326>>>>>>>>>>>                            
18326>>>>>>>>>>>                        Case Else
18326>>>>>>>>>>>                            Move DFFALSE to bLegalAttrib
18327>>>>>>>>>>>                            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE (SFormat("Invalid value for SQLSTMTATTRIB_CURSOR_TYPE: %1", iAttribValue)) "SQLSetStmtAttribute"
18328>>>>>>>>>>>
18328>>>>>>>>>>>                    Case End
18328>>>>>>>>>>>                End
18328>>>>>>>>>>>>
18328>>>>>>>>>>>            End
18328>>>>>>>>>>>>
18328>>>>>>>>>>>
18328>>>>>>>>>>>            
18328>>>>>>>>>>>            If (bLegalAttrib) Begin
18330>>>>>>>>>>>                
18330>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                    Callback Self ;                    Passing ihdbc iVoid ihstmt ;                    Result iVoid
18335>>>>>>>>>>>                
18335>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETSTMTINTATTRIB ;                    Callback Self ;                    Passing iAttribId iAttribValue 0 ;                    Result iVoid
18340>>>>>>>>>>>            End
18340>>>>>>>>>>>>
18340>>>>>>>>>>>        End
18340>>>>>>>>>>>>
18340>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
18342>>>>>>>>>>>        
18342>>>>>>>>>>>        
18342>>>>>>>>>>>        
18342>>>>>>>>>>>    End_Procedure
18343>>>>>>>>>>>    
18343>>>>>>>>>>>    
18343>>>>>>>>>>>    
18343>>>>>>>>>>>    Function SQLPrivateStmtAttribute Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
18345>>>>>>>>>>>        String  sResult
18345>>>>>>>>>>>        Integer iLen
18345>>>>>>>>>>>        Integer bLegalAttrib
18345>>>>>>>>>>>        
18345>>>>>>>>>>>        // Initialize
18345>>>>>>>>>>>        Move ""     to sResult
18346>>>>>>>>>>>        
18346>>>>>>>>>>>        // Get the attribute
18346>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18348>>>>>>>>>>>            Case Begin
18348>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
18350>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
18353>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
18356>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
18359>>>>>>>>>>>                Case (iAttribId = SQLSTMTATTRIB_CURSOR_TYPE)
18362>>>>>>>>>>>                    Move DFTRUE to bLegalAttrib
18363>>>>>>>>>>>                    Break
18364>>>>>>>>>>>                    
18364>>>>>>>>>>>                Case Else
18364>>>>>>>>>>>                    Move DFFALSE to bLegalAttrib
18365>>>>>>>>>>>                    Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateStmtAttribute"
18366>>>>>>>>>>>            Case End
18366>>>>>>>>>>>            
18366>>>>>>>>>>>            If (bLegalAttrib) Begin
18368>>>>>>>>>>>                // Setup function arguments
18368>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSTMTINTATTRIB ;                    Callback Self ;                    Passing ihdbc iAttribId ihstmt ;                    Result sResult
18373>>>>>>>>>>>            End
18373>>>>>>>>>>>>
18373>>>>>>>>>>>        End
18373>>>>>>>>>>>>
18373>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateStmtAttribute"
18375>>>>>>>>>>>        
18375>>>>>>>>>>>        Function_Return sResult
18376>>>>>>>>>>>    End_Function
18377>>>>>>>>>>>    
18377>>>>>>>>>>>    
18377>>>>>>>>>>>    
18377>>>>>>>>>>>    // Get a column's attribute
18377>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
18379>>>>>>>>>>>        Integer ihdbc
18379>>>>>>>>>>>        Integer ihstmt
18379>>>>>>>>>>>        String  sResult
18379>>>>>>>>>>>        String  sDrvrId
18379>>>>>>>>>>>        
18379>>>>>>>>>>>        // Initialize
18379>>>>>>>>>>>        Move "" to sResult
18380>>>>>>>>>>>        
18380>>>>>>>>>>>        // Get the cli handles
18380>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18381>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18382>>>>>>>>>>>        Get psDriverId            to sDrvrId
18383>>>>>>>>>>>        
18383>>>>>>>>>>>        // Get the attribute
18383>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") ;            Get SQLPrivateColAttribute iCol iAttribId ihdbc sDrvrId ihstmt to sResult
18386>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLColAttribute"
18388>>>>>>>>>>>        
18388>>>>>>>>>>>        Function_Return sResult
18389>>>>>>>>>>>    End_Function
18390>>>>>>>>>>>    
18390>>>>>>>>>>>    Function SQLPrivateColAttribute Integer iCol Integer iAttribId Integer ihdbc String sDrvrId Integer ihstmt Returns String
18392>>>>>>>>>>>        String  sResult
18392>>>>>>>>>>>        String  sEmpty
18392>>>>>>>>>>>        Integer bIsStringAttribute
18392>>>>>>>>>>>        Integer iLen
18392>>>>>>>>>>>        Integer iVoid
18392>>>>>>>>>>>        Integer bLegalAttrib
18392>>>>>>>>>>>        Integer bLegalColumn
18392>>>>>>>>>>>        
18392>>>>>>>>>>>        // Initialize
18392>>>>>>>>>>>        Move "" to sResult
18393>>>>>>>>>>>        Move "" to sEmpty
18394>>>>>>>>>>>        Move 0  to iLen
18395>>>>>>>>>>>        
18395>>>>>>>>>>>        // Get the attribute
18395>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18397>>>>>>>>>>>            Get SQLPrivateColumnIsLegal ihdbc sDrvrId ihstmt iCol to bLegalColumn
18398>>>>>>>>>>>            If (bLegalColumn) Begin
18400>>>>>>>>>>>                // Determine the atributes type
18400>>>>>>>>>>>                Case Begin
18400>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SIZE)
18402>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LENGTH)
18405>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_PRECISION)
18408>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
18411>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_NULLABLE)
18414>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_DFTYPE)
18417>>>>>>>>>>>                        Move DFFALSE to bIsStringAttribute
18418>>>>>>>>>>>                        Move DFTRUE to bLegalAttrib
18419>>>>>>>>>>>                        Break
18420>>>>>>>>>>>                        
18420>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_LABEL)
18423>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
18426>>>>>>>>>>>                    Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
18429>>>>>>>>>>>                        Move DFTRUE to bIsStringAttribute
18430>>>>>>>>>>>                        Move DFTRUE to bLegalAttrib
18431>>>>>>>>>>>                        Break
18432>>>>>>>>>>>                        
18432>>>>>>>>>>>                    Case Else
18432>>>>>>>>>>>                        Move DFFALSE to bLegalAttrib
18433>>>>>>>>>>>                        Send SQLIllegalAttribute ("Attribute is = " + String(iAttribId) + ")") "SQLPrivateColAttribute"
18434>>>>>>>>>>>                Case End
18434>>>>>>>>>>>                
18434>>>>>>>>>>>                If (bLegalAttrib) Begin
18436>>>>>>>>>>>                    // Setup function arguments
18436>>>>>>>>>>>                    Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                        Callback Self ;                        Passing ihdbc iCol ihstmt ;                        Result iVoid
18441>>>>>>>>>>>                    
18441>>>>>>>>>>>                    If (bIsStringAttribute) Begin
18443>>>>>>>>>>>                        // Call the driver function to get the data length
18443>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIBLEN ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result iLen
18448>>>>>>>>>>>                        
18448>>>>>>>>>>>                        If (iLen) Begin
18450>>>>>>>>>>>                            // Allocate
18450>>>>>>>>>>>                            Move (Repeat(' ', iLen)) to sResult
18451>>>>>>>>>>>                            
18451>>>>>>>>>>>                            // Call the driver function to get the name
18451>>>>>>>>>>>                            Call_Driver 0 sDrvrId Function FUNC_SQLCOLSTRINGATTRIB ;                                Callback Self ;                                Passing sResult sEmpty iAttribId ;                                Result iVoid
18456>>>>>>>>>>>                        End
18456>>>>>>>>>>>>
18456>>>>>>>>>>>                    End
18456>>>>>>>>>>>>
18456>>>>>>>>>>>                    Else Begin
18457>>>>>>>>>>>                        // get the attribute
18457>>>>>>>>>>>                        Call_Driver 0 sDrvrId Function FUNC_SQLCOLINTATTRIB ;                            Callback Self ;                            Passing sEmpty sEmpty iAttribId ;                            Result sResult
18462>>>>>>>>>>>                    End
18462>>>>>>>>>>>>
18462>>>>>>>>>>>                End
18462>>>>>>>>>>>>
18462>>>>>>>>>>>            End
18462>>>>>>>>>>>>
18462>>>>>>>>>>>            Else ;                Send StmtError CLIERR_SQLINVALID_COLUMN ("(Column number = " + String(iCol) + ")") "SQLPrivateColAttribute"
18464>>>>>>>>>>>        End
18464>>>>>>>>>>>>
18464>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLPrivateColAttribute"
18466>>>>>>>>>>>        
18466>>>>>>>>>>>        Function_Return sResult
18467>>>>>>>>>>>    End_Function
18468>>>>>>>>>>>    
18468>>>>>>>>>>>    
18468>>>>>>>>>>>    // Preapre for calling a stored procedure, pass the procedure name.
18468>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
18470>>>>>>>>>>>        Integer ihdbc
18470>>>>>>>>>>>        Integer ihstmt
18470>>>>>>>>>>>        String  sDrvrId
18470>>>>>>>>>>>        Integer iVoid
18470>>>>>>>>>>>        String  sSchema
18470>>>>>>>>>>>        String  sEmpty
18470>>>>>>>>>>>        
18470>>>>>>>>>>>        // Initialize
18470>>>>>>>>>>>        Move "" to sEmpty
18471>>>>>>>>>>>        
18471>>>>>>>>>>>        // Get the cli handles
18471>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18472>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18473>>>>>>>>>>>        Get psDriverId            to sDrvrId
18474>>>>>>>>>>>        
18474>>>>>>>>>>>        // Call the procedure
18474>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18476>>>>>>>>>>>            If (Num_Arguments >= 2) ;                Move sSchemaArg to sSchema
18479>>>>>>>>>>>            Else ;                Move "" to sSchema
18481>>>>>>>>>>>            
18481>>>>>>>>>>>            If (sSchema <> "") Begin
18483>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCSCHEMA ;                    Callback Self ;                    Passing ihdbc sSchema ihstmt ;                    Result iVoid
18488>>>>>>>>>>>            End
18488>>>>>>>>>>>>
18488>>>>>>>>>>>            
18488>>>>>>>>>>>            // Call the procedure
18488>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCNAME ;                Callback Self ;                Passing ihdbc sProcName ihstmt ;                Result iVoid
18493>>>>>>>>>>>            
18493>>>>>>>>>>>            Set piLastArgument to 0
18494>>>>>>>>>>>        End
18494>>>>>>>>>>>>
18494>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetProcedurename"
18496>>>>>>>>>>>    End_Procedure
18497>>>>>>>>>>>    
18497>>>>>>>>>>>    // Pass the next argument
18497>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
18499>>>>>>>>>>>        Integer iArgnum
18499>>>>>>>>>>>        
18499>>>>>>>>>>>        Get piLastArgument to iArgnum
18500>>>>>>>>>>>        Increment iArgnum
18501>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
18502>>>>>>>>>>>        Set piLastArgument to iArgnum
18503>>>>>>>>>>>    End_Procedure
18504>>>>>>>>>>>    
18504>>>>>>>>>>>    
18504>>>>>>>>>>>    
18504>>>>>>>>>>>    // Set the next argument
18504>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
18506>>>>>>>>>>>        Integer ihdbc
18506>>>>>>>>>>>        Integer ihstmt
18506>>>>>>>>>>>        String  sDrvrId
18506>>>>>>>>>>>        Integer iVoid
18506>>>>>>>>>>>        String  sEmpty
18506>>>>>>>>>>>        
18506>>>>>>>>>>>        // Initialize
18506>>>>>>>>>>>        Move "" to sEmpty
18507>>>>>>>>>>>        
18507>>>>>>>>>>>        // Get the cli handles
18507>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18508>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18509>>>>>>>>>>>        Get psDriverId            to sDrvrId
18510>>>>>>>>>>>        
18510>>>>>>>>>>>        // Call the procedure
18510>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18512>>>>>>>>>>>            // Pass the information
18512>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
18517>>>>>>>>>>>            
18517>>>>>>>>>>>            // Pass the argument
18517>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sArgument sEmpty 0 ;                Result iVoid
18522>>>>>>>>>>>        End
18522>>>>>>>>>>>>
18522>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetArgument"
18524>>>>>>>>>>>    End_Procedure
18525>>>>>>>>>>>    
18525>>>>>>>>>>>    Procedure SQLSetNextParameter String sParamValue Integer iParamType
18527>>>>>>>>>>>        Integer iParamNum 
18527>>>>>>>>>>>        Integer iType
18527>>>>>>>>>>>        
18527>>>>>>>>>>>        If (num_arguments < 2) Begin
18529>>>>>>>>>>>            Move typeString to iType
18530>>>>>>>>>>>        End
18530>>>>>>>>>>>>
18530>>>>>>>>>>>        Else Begin
18531>>>>>>>>>>>            Move iParamType to iType
18532>>>>>>>>>>>        End
18532>>>>>>>>>>>>
18532>>>>>>>>>>>        
18532>>>>>>>>>>>        Get piLastArgument to iParamNum
18533>>>>>>>>>>>        Increment iParamNum
18534>>>>>>>>>>>        Send SQLSetParameter iParamNum sParamValue iType
18535>>>>>>>>>>>        Set piLastArgument to iParamNum
18536>>>>>>>>>>>    End_Procedure
18537>>>>>>>>>>>
18537>>>>>>>>>>>    Procedure SQLSetParameter Integer iParamNum String sParamValue Integer iParamType
18539>>>>>>>>>>>        
18539>>>>>>>>>>>        Integer ihdbc
18539>>>>>>>>>>>        Integer ihstmt
18539>>>>>>>>>>>        String  sDrvrId
18539>>>>>>>>>>>        Integer iVoid
18539>>>>>>>>>>>        String  sEmpty
18539>>>>>>>>>>>        Integer iType
18539>>>>>>>>>>>        
18539>>>>>>>>>>>        If (num_arguments < 3) Begin
18541>>>>>>>>>>>            Move typeString to iType
18542>>>>>>>>>>>        End
18542>>>>>>>>>>>>
18542>>>>>>>>>>>        Else Begin
18543>>>>>>>>>>>            Move iParamType to iType
18544>>>>>>>>>>>        End
18544>>>>>>>>>>>>
18544>>>>>>>>>>>        
18544>>>>>>>>>>>        Case Begin
18544>>>>>>>>>>>            Case (iType = typeDate )    
18546>>>>>>>>>>>
18546>>>>>>>>>>>                If (sParamValue <> "") Begin
18548>>>>>>>>>>>                    ConvertToXml typeDate sParamValue to sParamValue
18549>>>>>>>>>>>                End
18549>>>>>>>>>>>>
18549>>>>>>>>>>>                
18549>>>>>>>>>>>                Break
18550>>>>>>>>>>>
18550>>>>>>>>>>>            Case (iType = typeDatetime )    
18553>>>>>>>>>>>
18553>>>>>>>>>>>                If (sParamValue <> "") Begin
18555>>>>>>>>>>>                    ConvertToXml esqlDatetime sParamValue to sParamValue
18556>>>>>>>>>>>                    Move (Replace('T',sParamValue,' ')) to sParamValue 
18557>>>>>>>>>>>                End
18557>>>>>>>>>>>>
18557>>>>>>>>>>>
18557>>>>>>>>>>>                Break
18558>>>>>>>>>>>
18558>>>>>>>>>>>            Case (iType = typeNumber )    
18561>>>>>>>>>>>
18561>>>>>>>>>>>                If (sParamValue <> "") Begin
18563>>>>>>>>>>>                    ConvertToXml typeNumber sParamValue to sParamValue
18564>>>>>>>>>>>                End
18564>>>>>>>>>>>>
18564>>>>>>>>>>>                
18564>>>>>>>>>>>                Break
18565>>>>>>>>>>>            
18565>>>>>>>>>>>            Case (iType = typeTime )    
18568>>>>>>>>>>>
18568>>>>>>>>>>>                If (sParamValue <> "") Begin
18570>>>>>>>>>>>                    ConvertToXml esqlTime sParamValue to sParamValue
18571>>>>>>>>>>>                End
18571>>>>>>>>>>>>
18571>>>>>>>>>>>                
18571>>>>>>>>>>>                Break
18572>>>>>>>>>>>                
18572>>>>>>>>>>>            Case Else
18572>>>>>>>>>>>                    // sParamValue is a string type or a type that must be passed as a string
18572>>>>>>>>>>>                    Break
18573>>>>>>>>>>>                
18573>>>>>>>>>>>        Case End
18573>>>>>>>>>>>        
18573>>>>>>>>>>>        
18573>>>>>>>>>>>        // Initialize
18573>>>>>>>>>>>        Move "" to sEmpty
18574>>>>>>>>>>>        
18574>>>>>>>>>>>        // Get the cli handles
18574>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18575>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18576>>>>>>>>>>>        Get psDriverId            to sDrvrId
18577>>>>>>>>>>>        
18577>>>>>>>>>>>        // Call the procedure
18577>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18579>>>>>>>>>>>            // Pass the information
18579>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iParamnum ihstmt ;                Result iVoid
18584>>>>>>>>>>>            
18584>>>>>>>>>>>            // Pass the argument
18584>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLSETPROCARG ;                Callback Self ;                Passing sParamValue sEmpty 0 ;                Result iVoid
18589>>>>>>>>>>>        End
18589>>>>>>>>>>>>
18589>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLSetParameter"
18591>>>>>>>>>>>    End_Procedure
18592>>>>>>>>>>>    
18592>>>>>>>>>>>    
18592>>>>>>>>>>>    // Call a stored procedure
18592>>>>>>>>>>>    Procedure SQLCall
18594>>>>>>>>>>>        Integer ihdbc
18594>>>>>>>>>>>        Integer ihstmt
18594>>>>>>>>>>>        String  sDrvrId
18594>>>>>>>>>>>        Integer iVoid
18594>>>>>>>>>>>        String  sEmpty
18594>>>>>>>>>>>        
18594>>>>>>>>>>>        // Initialize
18594>>>>>>>>>>>        Move "" to sEmpty
18595>>>>>>>>>>>        
18595>>>>>>>>>>>        // Get the cli handles
18595>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18596>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18597>>>>>>>>>>>        Get psDriverId            to sDrvrId
18598>>>>>>>>>>>        
18598>>>>>>>>>>>        // Call the procedure
18598>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18600>>>>>>>>>>>            // Call the procedure
18600>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCALL ;                Callback Self ;                Passing ihdbc sEmpty ihstmt ;                Result iVoid
18605>>>>>>>>>>>            
18605>>>>>>>>>>>            Send SQLGetStatementAttributes
18606>>>>>>>>>>>            Set piLastArgument to 0
18607>>>>>>>>>>>        End
18607>>>>>>>>>>>>
18607>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLCall"
18609>>>>>>>>>>>    End_Procedure
18610>>>>>>>>>>>    
18610>>>>>>>>>>>    
18610>>>>>>>>>>>    // Get the next argument
18610>>>>>>>>>>>    Function SQLGetNextArgument Returns String
18612>>>>>>>>>>>        Integer iArgnum
18612>>>>>>>>>>>        String  sResult
18612>>>>>>>>>>>        
18612>>>>>>>>>>>        Get piLastArgument to iArgnum
18613>>>>>>>>>>>        Increment iArgnum
18614>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
18615>>>>>>>>>>>        Set piLastArgument to iArgnum
18616>>>>>>>>>>>        
18616>>>>>>>>>>>        Function_Return sResult
18617>>>>>>>>>>>    End_Function
18618>>>>>>>>>>>    
18618>>>>>>>>>>>    
18618>>>>>>>>>>>    
18618>>>>>>>>>>>    // Get the specified argument from a procedure
18618>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
18620>>>>>>>>>>>        Integer ihdbc
18620>>>>>>>>>>>        Integer ihstmt
18620>>>>>>>>>>>        String  sDrvrId
18620>>>>>>>>>>>        Integer iVoid
18620>>>>>>>>>>>        String  sEmpty
18620>>>>>>>>>>>        String  sArgument
18620>>>>>>>>>>>        Integer iLen
18620>>>>>>>>>>>        
18620>>>>>>>>>>>        // Initialize
18620>>>>>>>>>>>        Move "" to sEmpty
18621>>>>>>>>>>>        Move "" to sArgument
18622>>>>>>>>>>>        
18622>>>>>>>>>>>        // Get the cli handles
18622>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18623>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18624>>>>>>>>>>>        Get psDriverId            to sDrvrId
18625>>>>>>>>>>>        
18625>>>>>>>>>>>        // Call the procedure
18625>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18627>>>>>>>>>>>            // Pass the information
18627>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iArgnum ihstmt ;                Result iVoid
18632>>>>>>>>>>>            
18632>>>>>>>>>>>            // Get the length
18632>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARGLEN ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result iLen
18637>>>>>>>>>>>            
18637>>>>>>>>>>>            If (iLen) Begin
18639>>>>>>>>>>>                // Allocate
18639>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sArgument
18640>>>>>>>>>>>                
18640>>>>>>>>>>>                // Pass the argument
18640>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCARG ;                    Callback Self ;                    Passing sArgument sEmpty 0 ;                    Result iVoid
18645>>>>>>>>>>>            End
18645>>>>>>>>>>>>
18645>>>>>>>>>>>        End
18645>>>>>>>>>>>>
18645>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetArgument"
18647>>>>>>>>>>>        
18647>>>>>>>>>>>        Function_Return sArgument
18648>>>>>>>>>>>    End_Function
18649>>>>>>>>>>>    
18649>>>>>>>>>>>    
18649>>>>>>>>>>>    // Get the return value of a stored function
18649>>>>>>>>>>>    Function SQLReturnValue Returns String
18651>>>>>>>>>>>        Integer ihdbc
18651>>>>>>>>>>>        Integer ihstmt
18651>>>>>>>>>>>        String  sDrvrId
18651>>>>>>>>>>>        Integer iVoid
18651>>>>>>>>>>>        String  sEmpty
18651>>>>>>>>>>>        String  sRetval
18651>>>>>>>>>>>        Integer iLen
18651>>>>>>>>>>>        
18651>>>>>>>>>>>        // Initialize
18651>>>>>>>>>>>        Move "" to sEmpty
18652>>>>>>>>>>>        Move "" to sRetval
18653>>>>>>>>>>>        
18653>>>>>>>>>>>        // Get the cli handles
18653>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18654>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18655>>>>>>>>>>>        Get psDriverId            to sDrvrId
18656>>>>>>>>>>>        
18656>>>>>>>>>>>        // Call the procedure
18656>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18658>>>>>>>>>>>            // Get the length
18658>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVALLEN ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iLen
18663>>>>>>>>>>>            
18663>>>>>>>>>>>            If (iLen) Begin
18665>>>>>>>>>>>                // Allocate
18665>>>>>>>>>>>                Move (Repeat(' ', iLen)) to sRetval
18666>>>>>>>>>>>                
18666>>>>>>>>>>>                // Pass the argument
18666>>>>>>>>>>>                Call_Driver 0 sDrvrId Function FUNC_SQLGETPROCRETVAL ;                    Callback Self ;                    Passing ihdbc sRetval ihstmt ;                    Result iVoid
18671>>>>>>>>>>>            End
18671>>>>>>>>>>>>
18671>>>>>>>>>>>        End
18671>>>>>>>>>>>>
18671>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLReturnValue"
18673>>>>>>>>>>>        
18673>>>>>>>>>>>        Function_Return sRetval
18674>>>>>>>>>>>    End_Function
18675>>>>>>>>>>>    
18675>>>>>>>>>>>    
18675>>>>>>>>>>>    // Switch to the next set
18675>>>>>>>>>>>    // Returns : 0   = No more result sets
18675>>>>>>>>>>>    //     <>0 = Switched to next set
18675>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
18677>>>>>>>>>>>        Integer ihdbc
18677>>>>>>>>>>>        Integer ihstmt
18677>>>>>>>>>>>        String  sDrvrId
18677>>>>>>>>>>>        Integer iResult
18677>>>>>>>>>>>        String  sEmpty
18677>>>>>>>>>>>        
18677>>>>>>>>>>>        // Initialize
18677>>>>>>>>>>>        Move "" to sEmpty
18678>>>>>>>>>>>        Move 0  to iResult
18679>>>>>>>>>>>        
18679>>>>>>>>>>>        // Get the cli handles
18679>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18680>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18681>>>>>>>>>>>        Get psDriverId            to sDrvrId
18682>>>>>>>>>>>        
18682>>>>>>>>>>>        // Call the procedure
18682>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18684>>>>>>>>>>>            // Get the length
18684>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLNEXTRESULTSET ;                Callback Self ;                Passing ihdbc sEmpty ihstmt  ;                Result iResult
18689>>>>>>>>>>>            
18689>>>>>>>>>>>            Send SQLGetStatementAttributes
18690>>>>>>>>>>>            Set piLastArgument to 0
18691>>>>>>>>>>>        End
18691>>>>>>>>>>>>
18691>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLNextResultSet"
18693>>>>>>>>>>>        
18693>>>>>>>>>>>        Function_Return iResult
18694>>>>>>>>>>>    End_Function
18695>>>>>>>>>>>    
18695>>>>>>>>>>>    
18695>>>>>>>>>>>    // Setup a file that will be acivated after a succesfull
18695>>>>>>>>>>>    //fetch on the statement
18695>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
18697>>>>>>>>>>>        Integer ihdbc
18697>>>>>>>>>>>        Integer ihstmt
18697>>>>>>>>>>>        String  sDrvrId
18697>>>>>>>>>>>        Integer iResult
18697>>>>>>>>>>>        Integer bIsOpen
18697>>>>>>>>>>>        Integer iVoid
18697>>>>>>>>>>>        String  sFileType
18697>>>>>>>>>>>        
18697>>>>>>>>>>>        // Check if file is open
18697>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
18700>>>>>>>>>>>        If (bIsOpen) Begin
18702>>>>>>>>>>>            // Get the cli handles
18702>>>>>>>>>>>            Get phCLIStatementHandle  to ihstmt
18703>>>>>>>>>>>            Get phCLIConnectionHandle to ihdbc
18704>>>>>>>>>>>            Get psDriverId            to sDrvrId
18705>>>>>>>>>>>            
18705>>>>>>>>>>>            // Call the procedure
18705>>>>>>>>>>>            If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18707>>>>>>>>>>>                // Check if the file has the correct type
18707>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sFileType
18710>>>>>>>>>>>                If (sFileType = sDrvrId) Begin
18712>>>>>>>>>>>                    // Setup the buffer
18712>>>>>>>>>>>                    Call_Driver iFileNum sDrvrId Function FUNC_SQLBUFFERSTATUS ;                        Callback Self ;                        Passing ihdbc bState ihstmt  ;                        Result iVoid
18717>>>>>>>>>>>                End
18717>>>>>>>>>>>>
18717>>>>>>>>>>>                Else ;                    Send StmtError CLIERR_SQLINVALID_BIND_FILE ("File" * String(iFileNum) * "type incompatible with statement ("  + sFileType + ")") "SQLBindFile"
18719>>>>>>>>>>>            End
18719>>>>>>>>>>>>
18719>>>>>>>>>>>            Else ;                Send HandleError ihstmt ihdbc sDrvrId "SQLFetchActivatesBuffer"
18721>>>>>>>>>>>        End
18721>>>>>>>>>>>>
18721>>>>>>>>>>>        Else ;            Send StmtError CLIERR_SQLINVALID_BUFFER ("File not open (number =" * String(iFileNum) + ")") "SQLFetchActivatesBuffer"
18723>>>>>>>>>>>    End_Procedure
18724>>>>>>>>>>>    
18724>>>>>>>>>>>    
18724>>>>>>>>>>>    
18724>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
18726>>>>>>>>>>>        Integer ihdbc
18726>>>>>>>>>>>        Integer ihstmt
18726>>>>>>>>>>>        String  sDrvrId
18726>>>>>>>>>>>        String  sMessage
18726>>>>>>>>>>>        Integer iVoid
18726>>>>>>>>>>>        
18726>>>>>>>>>>>        // Initialize
18726>>>>>>>>>>>        Move "" to sMessage
18727>>>>>>>>>>>        
18727>>>>>>>>>>>        // Get the cli handles
18727>>>>>>>>>>>        Get phCLIStatementHandle  to ihstmt
18728>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18729>>>>>>>>>>>        Get psDriverId            to sDrvrId
18730>>>>>>>>>>>        
18730>>>>>>>>>>>        // Call the procedure
18730>>>>>>>>>>>        If (ihstmt <> 0 and ihdbc <> 0 and sDrvrId <> "") Begin
18732>>>>>>>>>>>            // Setup function arguments
18732>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLCOLUMNINFO ;                Callback Self ;                Passing ihdbc iMessageNum ihstmt ;                Result iVoid
18737>>>>>>>>>>>            
18737>>>>>>>>>>>            Move (Repeat(' ', 1024)) to sMessage
18738>>>>>>>>>>>            // Get the length
18738>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLGETMESSAGE ;                Callback Self ;                Passing iVoid sMessage iVoid ;                Result iVoid
18743>>>>>>>>>>>        End
18743>>>>>>>>>>>>
18743>>>>>>>>>>>        Else ;            Send HandleError ihstmt ihdbc sDrvrId "SQLGetDiagRec"
18745>>>>>>>>>>>        
18745>>>>>>>>>>>        Function_Return sMessage
18746>>>>>>>>>>>    End_Function
18747>>>>>>>>>>>    
18747>>>>>>>>>>>    
18747>>>>>>>>>>>    
18747>>>>>>>>>>>    // Remove the component identifier from a diagnostic message
18747>>>>>>>>>>>    Function RemoveComponentIdentifier String sDiagMessage Returns String
18749>>>>>>>>>>>        While (Left(sDiagMessage, 1) = "[")
18753>>>>>>>>>>>            Move (Right(sDiagMessage, Length(sDiagMessage) - Pos("]", sDiagMessage))) to sDiagMessage
18754>>>>>>>>>>>        Loop
18755>>>>>>>>>>>>
18755>>>>>>>>>>>        
18755>>>>>>>>>>>        Function_Return sDiagMessage
18756>>>>>>>>>>>    End_Function
18757>>>>>>>>>>>    
18757>>>>>>>>>>>    
18757>>>>>>>>>>>    
18757>>>>>>>>>>>    // Convert a DataFlex date to a SQL Date. Use dummy zero dates.
18757>>>>>>>>>>>    Function DFDateToSQLDate Date dDFDate Integer iSQLType Returns String
18759>>>>>>>>>>>        
18759>>>>>>>>>>>        Integer iType
18759>>>>>>>>>>>        String  sSQLDate
18759>>>>>>>>>>>        Integer iOrgDateFmt
18759>>>>>>>>>>>        Integer iOrgDateSep
18759>>>>>>>>>>>        
18759>>>>>>>>>>>        String sDriverId
18759>>>>>>>>>>>        String sDummyZeroDate
18759>>>>>>>>>>>        String sDummyZeroDateMssqlDatetime
18759>>>>>>>>>>>        
18759>>>>>>>>>>>        // Change date format to military, SQL dates are military dates
18759>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
18762>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18765>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
18768>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
18771>>>>>>>>>>>        
18771>>>>>>>>>>>        // We only need to convert if the date is 0
18771>>>>>>>>>>>        If (Integer(dDFDate = 0)) Begin
18773>>>>>>>>>>>            
18773>>>>>>>>>>>            If (num_arguments < 2) Begin
18775>>>>>>>>>>>                Move SQL_TYPE_TIMESTAMP to iType
18776>>>>>>>>>>>            End
18776>>>>>>>>>>>>
18776>>>>>>>>>>>            Else Begin
18777>>>>>>>>>>>                Move iSQLType to iType
18778>>>>>>>>>>>            End
18778>>>>>>>>>>>>
18778>>>>>>>>>>>            
18778>>>>>>>>>>>            
18778>>>>>>>>>>>            Get psDriverID to sDriverId
18779>>>>>>>>>>>            Get psDummyZeroDate to sDummyZeroDate
18780>>>>>>>>>>>            
18780>>>>>>>>>>>            If ( (iType = SQL_TYPE_TIMESTAMP) and (sDriverID = 'MSSQLDRV') ) Begin
18782>>>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
18783>>>>>>>>>>>                Move sDummyZeroDateMssqlDatetime to sSQLDate
18784>>>>>>>>>>>            End
18784>>>>>>>>>>>>
18784>>>>>>>>>>>            Else Begin
18785>>>>>>>>>>>                Move sDummyZeroDate to sSQLDate
18786>>>>>>>>>>>            End
18786>>>>>>>>>>>>
18786>>>>>>>>>>>            
18786>>>>>>>>>>>        End
18786>>>>>>>>>>>>
18786>>>>>>>>>>>        Else Begin
18787>>>>>>>>>>>            Move dDFDate to sSQLDate
18788>>>>>>>>>>>        End
18788>>>>>>>>>>>>
18788>>>>>>>>>>>        
18788>>>>>>>>>>>        // Change date format back to original
18788>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
18791>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18794>>>>>>>>>>>        
18794>>>>>>>>>>>        Function_Return sSQLDate
18795>>>>>>>>>>>    End_Function
18796>>>>>>>>>>>    
18796>>>>>>>>>>>    
18796>>>>>>>>>>>    // Convert a SQL date to a DataFlex Date. Use dummy zero dates.
18796>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns Date
18798>>>>>>>>>>>        
18798>>>>>>>>>>>        Integer iType
18798>>>>>>>>>>>        Date    dDFDate
18798>>>>>>>>>>>        Integer iOrgDateFmt
18798>>>>>>>>>>>        Integer iOrgDateSep
18798>>>>>>>>>>>        
18798>>>>>>>>>>>        String  sDriverId
18798>>>>>>>>>>>        String  sDummyZeroDate
18798>>>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
18798>>>>>>>>>>>        
18798>>>>>>>>>>>        Get psDriverID to sDriverId
18799>>>>>>>>>>>        
18799>>>>>>>>>>>        Get psDummyZeroDate to sDummyZeroDate
18800>>>>>>>>>>>        Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
18801>>>>>>>>>>>        
18801>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
18804>>>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18807>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
18810>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
18813>>>>>>>>>>>        
18813>>>>>>>>>>>        Move (Left(sSQLDate,10)) to sSQLDate
18814>>>>>>>>>>>        
18814>>>>>>>>>>>        If ( (sSQLDate = sDummyZeroDate) or ;            ( (sDriverId = 'MSSQLDRV') and (sSQLDate = sDummyZeroDateMssqlDatetime) ) )  Begin
18816>>>>>>>>>>>            Move 0 to dDFDate
18817>>>>>>>>>>>        End
18817>>>>>>>>>>>>
18817>>>>>>>>>>>        Else Begin
18818>>>>>>>>>>>            Move sSQLDate to dDFDate
18819>>>>>>>>>>>        End
18819>>>>>>>>>>>>
18819>>>>>>>>>>>        
18819>>>>>>>>>>>        // Change date format back to original
18819>>>>>>>>>>>        Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
18822>>>>>>>>>>>        Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
18825>>>>>>>>>>>        
18825>>>>>>>>>>>        Function_Return dDFDate
18826>>>>>>>>>>>    End_Function
18827>>>>>>>>>>>    
18827>>>>>>>>>>>End_Class
18828>>>>>>>>>>>
18828>>>>>>>>>>>
18828>>>>>>>>>>>// Connection object for embedded SQL                          
18828>>>>>>>>>>>// This provides the ability to create a connection for a driver.     
18828>>>>>>>>>>>// It will contain child statement objects                            
18828>>>>>>>>>>>
18828>>>>>>>>>>>Class cSQLConnection is a cObject
18829>>>>>>>>>>>    
18829>>>>>>>>>>>    Procedure Construct_object
18831>>>>>>>>>>>        Forward Send Construct_object
18833>>>>>>>>>>>        
18833>>>>>>>>>>>        Property Integer phCLIConnectionHandle       0
18834>>>>>>>>>>>        
18834>>>>>>>>>>>        Property String  psDriverID        ""
18835>>>>>>>>>>>        Property Integer piBindFile        0
18836>>>>>>>>>>>        
18836>>>>>>>>>>>        Property String psDummyZeroDate              '0001-01-01'
18837>>>>>>>>>>>        Property String psDummyZeroDateMssqlDatetime '1753-01-01'
18838>>>>>>>>>>>        
18838>>>>>>>>>>>    End_Procedure
18839>>>>>>>>>>>    
18839>>>>>>>>>>>    
18839>>>>>>>>>>>    
18839>>>>>>>>>>>    // Store basic information about the connection
18839>>>>>>>>>>>    Procedure StoreConnectionInfo Handle hCLIConnectionHandle String sDrvrId
18841>>>>>>>>>>>        
18841>>>>>>>>>>>        String sDummyZeroDate
18841>>>>>>>>>>>        Integer iDriverIndex
18841>>>>>>>>>>>        
18841>>>>>>>>>>>        Set phCLIConnectionHandle to hCLIConnectionHandle
18842>>>>>>>>>>>        Set psDriverID            to sDrvrId
18843>>>>>>>>>>>        
18843>>>>>>>>>>>        Case Begin
18843>>>>>>>>>>>            Case (sDrvrId = "MSSQLDRV")
18845>>>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
18846>>>>>>>>>>>                Set psDummyZeroDateMssqlDatetime to '1753-01-01'
18847>>>>>>>>>>>                Break
18848>>>>>>>>>>>            Case (sDrvrId = "DB2_DRV")
18851>>>>>>>>>>>                Set psDummyZeroDate to '0001-01-01'
18852>>>>>>>>>>>                Break
18853>>>>>>>>>>>            Case (sDrvrId = "ODBC_DRV")
18856>>>>>>>>>>>                Get DriverIndex "ODBC_DRV" to iDriverIndex
18857>>>>>>>>>>>                If (iDriverIndex <> 0) Begin
18859>>>>>>>>>>>                    Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDummyZeroDate
18862>>>>>>>>>>>                End
18862>>>>>>>>>>>>
18862>>>>>>>>>>>                Else Begin
18863>>>>>>>>>>>                    Move '0001-01-01' to sDummyZeroDate
18864>>>>>>>>>>>                End
18864>>>>>>>>>>>>
18864>>>>>>>>>>>
18864>>>>>>>>>>>                Set psDummyZeroDate to sDummyZeroDate
18865>>>>>>>>>>>                Break
18866>>>>>>>>>>>                
18866>>>>>>>>>>>        Case End
18866>>>>>>>>>>>        
18866>>>>>>>>>>>    End_Procedure
18867>>>>>>>>>>>    
18867>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
18869>>>>>>>>>>>        
18869>>>>>>>>>>>        String  sCurrentDriver
18869>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
18869>>>>>>>>>>>        
18869>>>>>>>>>>>        Move 0 to iDriver
18870>>>>>>>>>>>        
18870>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
18873>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
18879>>>>>>>>>>>>
18879>>>>>>>>>>>            
18879>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
18882>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriver) ) Begin
18884>>>>>>>>>>>                Move iCount to iDriver
18885>>>>>>>>>>>            End
18885>>>>>>>>>>>>
18885>>>>>>>>>>>        Loop
18886>>>>>>>>>>>>
18886>>>>>>>>>>>        
18886>>>>>>>>>>>        Function_Return iDriver
18887>>>>>>>>>>>        
18887>>>>>>>>>>>    End_Function
18888>>>>>>>>>>>
18888>>>>>>>>>>>    
18888>>>>>>>>>>>    // Destroy the SQLConnection object
18888>>>>>>>>>>>    Procedure DestroySQLConnection
18890>>>>>>>>>>>        Send Destroy
18891>>>>>>>>>>>    End_Procedure
18892>>>>>>>>>>>    
18892>>>>>>>>>>>    
18892>>>>>>>>>>>    // Connect to a database server
18892>>>>>>>>>>>    // Returns : 1 Succesfully connected
18892>>>>>>>>>>>    //           0 Not connected
18892>>>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
18894>>>>>>>>>>>        Integer ihdbc
18894>>>>>>>>>>>        String  sEmpty
18894>>>>>>>>>>>        
18894>>>>>>>>>>>        // Initialize
18894>>>>>>>>>>>        Move "" to sEmpty
18895>>>>>>>>>>>        Move 0  to ihdbc
18896>>>>>>>>>>>        
18896>>>>>>>>>>>        Move False to Err
18897>>>>>>>>>>>        
18897>>>>>>>>>>>        // Call the driver function to connect
18897>>>>>>>>>>>        Call_Driver 0 sDrvrId Function FUNC_SQLCONNECT ;            Callback Self ;            Passing sConnect sEmpty Self ;            Result ihdbc
18902>>>>>>>>>>>        
18902>>>>>>>>>>>        // If there was an error, make result invalid
18902>>>>>>>>>>>        If (Err) ;            Move 0 to ihdbc
18905>>>>>>>>>>>        
18905>>>>>>>>>>>        // Check result and store it
18905>>>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
18908>>>>>>>>>>>        
18908>>>>>>>>>>>        // Return success status
18908>>>>>>>>>>>        Function_Return (ihdbc <> 0)
18909>>>>>>>>>>>    End_Function
18910>>>>>>>>>>>    
18910>>>>>>>>>>>    
18910>>>>>>>>>>>    // Use a connection of an already open file
18910>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
18912>>>>>>>>>>>        Integer ihdbc
18912>>>>>>>>>>>        Integer bIsOpen
18912>>>>>>>>>>>        String  sDrvrId
18912>>>>>>>>>>>        String  sEmpty
18912>>>>>>>>>>>        
18912>>>>>>>>>>>        // Initialize
18912>>>>>>>>>>>        Move "" to sEmpty
18913>>>>>>>>>>>        Move 0  to ihdbc
18914>>>>>>>>>>>        
18914>>>>>>>>>>>        // Check if file is open
18914>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
18917>>>>>>>>>>>        If (bIsOpen) Begin
18919>>>>>>>>>>>            // Fill the driver id, assume longest is 255 characters
18919>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDrvrId
18920>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
18923>>>>>>>>>>>            
18923>>>>>>>>>>>            Move False to Err
18924>>>>>>>>>>>            
18924>>>>>>>>>>>            // Call the driver function to connect
18924>>>>>>>>>>>            Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;                Callback Self ;                Passing sEmpty sEmpty 0 ;                Result ihdbc
18929>>>>>>>>>>>            
18929>>>>>>>>>>>            // If there was an error, make result invalid
18929>>>>>>>>>>>            If (Err) ;                Move 0 to ihdbc
18932>>>>>>>>>>>            
18932>>>>>>>>>>>            // Check result and store it
18932>>>>>>>>>>>            If (ihdbc <> 0) Begin
18934>>>>>>>>>>>                // Somehow Call_driver overwrites the sDrvrId variable, restore it here
18934>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of iFileNum to sDrvrId
18937>>>>>>>>>>>                Send StoreConnectionInfo ihdbc sDrvrId
18938>>>>>>>>>>>                
18938>>>>>>>>>>>                // Set filenum so it can be used for fetching
18938>>>>>>>>>>>                Set piBindFile to iFileNum
18939>>>>>>>>>>>            End
18939>>>>>>>>>>>>
18939>>>>>>>>>>>        End
18939>>>>>>>>>>>>
18939>>>>>>>>>>>        
18939>>>>>>>>>>>        // Return success status
18939>>>>>>>>>>>        Function_Return (ihdbc <> 0)
18940>>>>>>>>>>>    End_Function
18941>>>>>>>>>>>    
18941>>>>>>>>>>>    
18941>>>>>>>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
18941>>>>>>>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
18941>>>>>>>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
18941>>>>>>>>>>>    // The connectstring must be an exact match, but can be case insensitive
18941>>>>>>>>>>>    // The connectstring can contain a connection id. For example: "DFCONNID=MyConnectionID"
18941>>>>>>>>>>>    // If no matching connectstring is found, this function will return 0
18941>>>>>>>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
18941>>>>>>>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
18943>>>>>>>>>>>        Integer ihdbc
18943>>>>>>>>>>>        String  sEmpty
18943>>>>>>>>>>>        Integer iFileNum
18943>>>>>>>>>>>        
18943>>>>>>>>>>>        // Initialize
18943>>>>>>>>>>>        Move "" to sEmpty
18944>>>>>>>>>>>        Move 0  to ihdbc
18945>>>>>>>>>>>        
18945>>>>>>>>>>>        Move False to Err
18946>>>>>>>>>>>        
18946>>>>>>>>>>>        // Call the driver function
18946>>>>>>>>>>>        //   Note we call FUNC_SQLFILECONNECT with iFileNum = 0.
18946>>>>>>>>>>>        //   This will perform SQLConnectionConnect instead of SQLFileConnect
18946>>>>>>>>>>>        Move 0 to iFileNum
18947>>>>>>>>>>>        Call_Driver iFileNum sDrvrId Function FUNC_SQLFILECONNECT ;            Callback Self ;            Passing sConnectString sEmpty Self ;            Result ihdbc
18952>>>>>>>>>>>        
18952>>>>>>>>>>>        // If there was an error, make result invalid
18952>>>>>>>>>>>        If (Err) ;            Move 0 to ihdbc
18955>>>>>>>>>>>        
18955>>>>>>>>>>>        // Check result and store it
18955>>>>>>>>>>>        If (ihdbc <> 0) ;            Send StoreConnectionInfo ihdbc sDrvrId
18958>>>>>>>>>>>        
18958>>>>>>>>>>>        // Return success status
18958>>>>>>>>>>>        Function_Return (ihdbc <> 0)
18959>>>>>>>>>>>    End_Function
18960>>>>>>>>>>>    
18960>>>>>>>>>>>    
18960>>>>>>>>>>>    // Disconnect from an embedded SQL server and free allocated
18960>>>>>>>>>>>    // resources
18960>>>>>>>>>>>    Procedure SQLDisconnect
18962>>>>>>>>>>>        Integer ihdbc
18962>>>>>>>>>>>        Integer iVoid
18962>>>>>>>>>>>        String  sDrvrId
18962>>>>>>>>>>>        String  sEmpty
18962>>>>>>>>>>>        
18962>>>>>>>>>>>        // Initialize
18962>>>>>>>>>>>        Move "" to sEmpty
18963>>>>>>>>>>>        
18963>>>>>>>>>>>        // Get the cli handle
18963>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18964>>>>>>>>>>>        Get psDriverId to sDrvrId
18965>>>>>>>>>>>        
18965>>>>>>>>>>>        // Free the CLI handle
18965>>>>>>>>>>>        If (ihdbc <> 0) Begin
18967>>>>>>>>>>>            // Call the driver function to disconnect
18967>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLDISCONNECT ;                Callback Self ;                Passing sEmpty sEmpty ihdbc ;                Result iVoid
18972>>>>>>>>>>>            
18972>>>>>>>>>>>            Move -1 to giLastSQLhdbc
18973>>>>>>>>>>>            
18973>>>>>>>>>>>            // Free the DataFlex handle
18973>>>>>>>>>>>            Send DestroySQLConnection
18974>>>>>>>>>>>        End
18974>>>>>>>>>>>>
18974>>>>>>>>>>>    End_Procedure
18975>>>>>>>>>>>    
18975>>>>>>>>>>>    // Create a cSQLStatement object
18975>>>>>>>>>>>    Function CreateSQLStatement Returns Handle
18977>>>>>>>>>>>        
18977>>>>>>>>>>>        Handle hoSQLStatement
18977>>>>>>>>>>>        Get Create (RefClass(cSQLStatement)) to hoSQLStatement
18978>>>>>>>>>>>        
18978>>>>>>>>>>>        // If the connection has a default Bind File, assign it to the
18978>>>>>>>>>>>        // statement object. The default is set when you open a file with a
18978>>>>>>>>>>>        // SetFileConnection command.
18978>>>>>>>>>>>        Set piBindFile of hoSQLStatement to (piBindFile(Self))
18979>>>>>>>>>>>        
18979>>>>>>>>>>>        Function_Return hoSQLStatement
18980>>>>>>>>>>>    End_Function
18981>>>>>>>>>>>    
18981>>>>>>>>>>>    
18981>>>>>>>>>>>    // Open a statement for use
18981>>>>>>>>>>>    Function SQLOpen Returns Handle
18983>>>>>>>>>>>        Handle  hoSQLStatement
18983>>>>>>>>>>>        Integer ihdbc
18983>>>>>>>>>>>        Integer ihstmt
18983>>>>>>>>>>>        Integer iVoid
18983>>>>>>>>>>>        String  sDrvrId
18983>>>>>>>>>>>        String  sEmpty
18983>>>>>>>>>>>        String  sDummyZeroDate
18983>>>>>>>>>>>        String  sDummyZeroDateMssqlDatetime
18983>>>>>>>>>>>        
18983>>>>>>>>>>>        // Initialize
18983>>>>>>>>>>>        Move "" to sEmpty
18984>>>>>>>>>>>        
18984>>>>>>>>>>>        // Get the cli handle to the connection
18984>>>>>>>>>>>        Get phCLIConnectionHandle to ihdbc
18985>>>>>>>>>>>        Get psDriverId  to sDrvrId
18986>>>>>>>>>>>        
18986>>>>>>>>>>>        // Allocate a new handle and populate it
18986>>>>>>>>>>>        If (ihdbc <> 0) Begin
18988>>>>>>>>>>>            // Create a new cSQLStatement object
18988>>>>>>>>>>>            Get CreateSQLStatement to hoSQLStatement
18989>>>>>>>>>>>            
18989>>>>>>>>>>>            // Call the driver function to allocate a cli statement handle
18989>>>>>>>>>>>            Call_Driver 0 sDrvrId Function FUNC_SQLOPEN ;                Callback Self ;                Passing hoSQLStatement sEmpty ihdbc ;                Result ihstmt
18994>>>>>>>>>>>            
18994>>>>>>>>>>>            // If unsuccessful destroy hoSQLStatement
18994>>>>>>>>>>>            If (ihstmt = 0) Begin
18996>>>>>>>>>>>                Send DestroySQLStatement of hoSQLStatement
18997>>>>>>>>>>>                Move 0 to hoSQLStatement
18998>>>>>>>>>>>            End
18998>>>>>>>>>>>>
18998>>>>>>>>>>>            Else Begin
18999>>>>>>>>>>>                Send StoreStatementInfo of hoSQLStatement ihstmt sDrvrId ihdbc
19000>>>>>>>>>>>                
19000>>>>>>>>>>>                // Store DummyZeroDate of hoSQLConnection in hoSQLStatement
19000>>>>>>>>>>>                Get psDummyZeroDate              to sDummyZeroDate
19001>>>>>>>>>>>                Get psDummyZeroDateMssqlDatetime to sDummyZeroDateMssqlDatetime
19002>>>>>>>>>>>                
19002>>>>>>>>>>>                Set psDummyZeroDate              of hoSQLStatement to sDummyZeroDate
19003>>>>>>>>>>>                Set psDummyZeroDateMssqlDatetime of hoSQLStatement to sDummyZeroDateMssqlDatetime
19004>>>>>>>>>>>                
19004>>>>>>>>>>>            End
19004>>>>>>>>>>>>
19004>>>>>>>>>>>        End
19004>>>>>>>>>>>>
19004>>>>>>>>>>>        
19004>>>>>>>>>>>        Function_Return hoSQLStatement
19005>>>>>>>>>>>    End_Function
19006>>>>>>>>>>>    
19006>>>>>>>>>>>End_Class
19007>>>>>>>>>>>
19007>>>>>>>>>>>// Manager for embedded SQL handles.                           
19007>>>>>>>>>>>// We want to be able to use multiple drivers and multiple            
19007>>>>>>>>>>>// connections within a driver and multiple statements within a       
19007>>>>>>>>>>>// connection. To allow this we have placed our own handle logic on   
19007>>>>>>>>>>>// top of the driver handle logic. This way we can handle the         
19007>>>>>>>>>>>// situation where two driver handles may be equal.                   
19007>>>>>>>>>>>
19007>>>>>>>>>>>Class cSQLHandleManager is a cObject
19008>>>>>>>>>>>    
19008>>>>>>>>>>>    Procedure Construct_object
19010>>>>>>>>>>>        Forward Send Construct_object
19012>>>>>>>>>>>        
19012>>>>>>>>>>>        Property String  psDefaultDriver      ""
19013>>>>>>>>>>>        Property String  psDefaultConnection  ""
19014>>>>>>>>>>>        
19014>>>>>>>>>>>    End_Procedure
19015>>>>>>>>>>>    
19015>>>>>>>>>>>    // Create a cSQLConnection object
19015>>>>>>>>>>>    Function CreateSQLConnection Returns Handle
19017>>>>>>>>>>>        Handle hoSQLConnection
19017>>>>>>>>>>>        Get Create (RefClass(cSQLConnection)) to hoSQLConnection
19018>>>>>>>>>>>        Function_Return hoSQLConnection
19019>>>>>>>>>>>    End_Function
19020>>>>>>>>>>>    
19020>>>>>>>>>>>    
19020>>>>>>>>>>>    // Store default connection information
19020>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
19022>>>>>>>>>>>        Set psDefaultDriver      to sDriver
19023>>>>>>>>>>>        Set psDefaultConnection  to sConnect
19024>>>>>>>>>>>    End_Procedure
19025>>>>>>>>>>>    
19025>>>>>>>>>>>    
19025>>>>>>>>>>>    // Make a connection to an embedded SQL server
19025>>>>>>>>>>>    // Returns : The DataFlex handle to the connection
19025>>>>>>>>>>>    Function SQLConnect String sDrvrID String sConnect Returns Integer
19027>>>>>>>>>>>        Handle hoSQLConnection
19027>>>>>>>>>>>        Integer bOK
19027>>>>>>>>>>>        
19027>>>>>>>>>>>        // Check arguments
19027>>>>>>>>>>>        If (sDrvrID = "" and sConnect = "") Begin
19029>>>>>>>>>>>            Get psDefaultDriver      to sDrvrId
19030>>>>>>>>>>>            Get psDefaultConnection  to sConnect
19031>>>>>>>>>>>        End
19031>>>>>>>>>>>>
19031>>>>>>>>>>>        
19031>>>>>>>>>>>        // Create a cSQLConnection object
19031>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
19032>>>>>>>>>>>        // Connect to the database
19032>>>>>>>>>>>        Get SQLConnect of hoSQLConnection sDrvrID sConnect to bOK
19033>>>>>>>>>>>        
19033>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
19033>>>>>>>>>>>        If (not(bOK)) Begin
19035>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
19036>>>>>>>>>>>            Move 0 to hoSQLConnection
19037>>>>>>>>>>>        End
19037>>>>>>>>>>>>
19037>>>>>>>>>>>        
19037>>>>>>>>>>>        Function_Return hoSQLConnection
19038>>>>>>>>>>>    End_Function
19039>>>>>>>>>>>    
19039>>>>>>>>>>>    
19039>>>>>>>>>>>    
19039>>>>>>>>>>>    // Make an existing connection available for use with Embedded SQL.
19039>>>>>>>>>>>    // The connection is identified by the number of a file
19039>>>>>>>>>>>    // that is open for that connection.
19039>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Handle
19041>>>>>>>>>>>        Handle hoSQLConnection
19041>>>>>>>>>>>        Integer bOK
19041>>>>>>>>>>>        
19041>>>>>>>>>>>        // Create a cSQLConnection object
19041>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
19042>>>>>>>>>>>        Get SQLFileConnect of hoSQLConnection iFileNum to bOK
19043>>>>>>>>>>>        
19043>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
19043>>>>>>>>>>>        If (not(bOK)) Begin
19045>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
19046>>>>>>>>>>>            Move 0 to hoSQLConnection
19047>>>>>>>>>>>        End
19047>>>>>>>>>>>>
19047>>>>>>>>>>>        
19047>>>>>>>>>>>        Function_Return hoSQLConnection
19048>>>>>>>>>>>    End_Function
19049>>>>>>>>>>>    
19049>>>>>>>>>>>    // Establish an embedded SQL connection that uses an existing connection from an earlier login or open.
19049>>>>>>>>>>>    // Existing connections are identified by there connectstring. (can be obtained with DF_DRIVER_SERVER_NAME attribute)
19049>>>>>>>>>>>    // If sConnectString exist in the list of existing connections, that connection will be used for embedded SQL.
19049>>>>>>>>>>>    // The connectstrings must be an exact match, but can be case insensitive
19049>>>>>>>>>>>    // If no matching connectstring is found, this function will return 0
19049>>>>>>>>>>>    // This function will only work with CLI connectivity kits 6.2 or later
19049>>>>>>>>>>>    Function SQLConnectionConnect String sDrvrID String sConnectString Returns Integer
19051>>>>>>>>>>>        Handle hoSQLConnection
19051>>>>>>>>>>>        Integer bOK
19051>>>>>>>>>>>        
19051>>>>>>>>>>>        // Check arguments
19051>>>>>>>>>>>        If (sDrvrID = "" and sConnectString = "") Begin
19053>>>>>>>>>>>            Get psDefaultDriver      to sDrvrId
19054>>>>>>>>>>>            Get psDefaultConnection  to sConnectString
19055>>>>>>>>>>>        End
19055>>>>>>>>>>>>
19055>>>>>>>>>>>        
19055>>>>>>>>>>>        // Create a cSQLConnection object
19055>>>>>>>>>>>        Get CreateSQLConnection to hoSQLConnection
19056>>>>>>>>>>>        // Connect to the database
19056>>>>>>>>>>>        Get SQLConnectionConnect of hoSQLConnection sDrvrID sConnectString to bOK
19057>>>>>>>>>>>        
19057>>>>>>>>>>>        // If connection to the database failed, destroy the cSQLConnection object and return a 0 handle
19057>>>>>>>>>>>        If (not(bOK)) Begin
19059>>>>>>>>>>>            Send DestroySQLConnection of hoSQLConnection
19060>>>>>>>>>>>            Move 0 to hoSQLConnection
19061>>>>>>>>>>>        End
19061>>>>>>>>>>>>
19061>>>>>>>>>>>        
19061>>>>>>>>>>>        Function_Return hoSQLConnection
19062>>>>>>>>>>>    End_Function
19063>>>>>>>>>>>    
19063>>>>>>>>>>>    
19063>>>>>>>>>>>End_Class
19064>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
19064>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
19064>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
19064>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
19064>>>>>>>>>>>
19064>>>>>>>>>>>Use Cli.pkg
19064>>>>>>>>>>>Use SQL.pkg
19064>>>>>>>>>>>
19064>>>>>>>>>>>//   Driver Indentification
19064>>>>>>>>>>>
19064>>>>>>>>>>>//   Error number constants
19064>>>>>>>>>>>
19064>>>>>>>>>>>
19064>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
19064>>>>>>>>>>>
19064>>>>>>>>>>>
19064>>>>>>>>>>>
19064>>>>>>>>>>>
19064>>>>>>>>>>>
19064>>>>>>>>>>>
19064>>>>>>>>>>>// SQL Server spcific types.
19064>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
19064>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
19064>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
19064>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
19064>>>>>>>>>>>
19064>>>>>>>>>>>// SQL Server spcific types.
19064>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
19064>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
19064>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
19064>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
19064>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
19064>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
19064>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
19064>>>>>>>>>>>
19064>>>>>>>>>>>
19064>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
19064>>>>>>>>>>>//
19064>>>>>>>>>>>//     Setup a constraint for a file.
19064>>>>>>>>>>>
19064>>>>>>>>>>>
19064>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
19065>>>>>>>>>>>    
19065>>>>>>>>>>>    Procedure Construct_Object
19067>>>>>>>>>>>        Forward Send Construct_Object
19069>>>>>>>>>>>        
19069>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
19070>>>>>>>>>>>    End_Procedure
19071>>>>>>>>>>>    
19071>>>>>>>>>>>    
19071>>>>>>>>>>>    
19071>>>>>>>>>>>    //   Extract the list from the out connect string.
19071>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
19073>>>>>>>>>>>        String  sItem
19073>>>>>>>>>>>        Integer iStart
19073>>>>>>>>>>>        Integer iEnd
19073>>>>>>>>>>>        
19073>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
19076>>>>>>>>>>>        
19076>>>>>>>>>>>        Send Delete_Data to hoStore
19077>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
19078>>>>>>>>>>>        While (iStart > 0)
19082>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
19083>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
19086>>>>>>>>>>>            Else Begin
19087>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
19088>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
19089>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
19092>>>>>>>>>>>                
19092>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
19095>>>>>>>>>>>                
19095>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
19098>>>>>>>>>>>            End
19098>>>>>>>>>>>>
19098>>>>>>>>>>>        Loop
19099>>>>>>>>>>>>
19099>>>>>>>>>>>        
19099>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
19100>>>>>>>>>>>    End_Function
19101>>>>>>>>>>>    
19101>>>>>>>>>>>    
19101>>>>>>>>>>>    
19101>>>>>>>>>>>    //   Call the driver's browse connect function
19101>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
19103>>>>>>>>>>>        String  sDriver
19103>>>>>>>>>>>        String  sOutConnStr
19103>>>>>>>>>>>        Integer iArg
19103>>>>>>>>>>>        Integer iRetval
19103>>>>>>>>>>>        
19103>>>>>>>>>>>        Get psDriverID to sDriver
19104>>>>>>>>>>>        If (sDriver <> "") Begin
19106>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
19107>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
19112>>>>>>>>>>>        End
19112>>>>>>>>>>>>
19112>>>>>>>>>>>        
19112>>>>>>>>>>>        Function_Return sOutConnStr
19113>>>>>>>>>>>    End_Function// BrowseConnect
19114>>>>>>>>>>>    
19114>>>>>>>>>>>    
19114>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
19116>>>>>>>>>>>        String  sDriver
19116>>>>>>>>>>>        String  sOutConnStr
19116>>>>>>>>>>>        Integer iArg
19116>>>>>>>>>>>        Integer iRetval
19116>>>>>>>>>>>        
19116>>>>>>>>>>>        Move 1 to iArg // Browses only local
19117>>>>>>>>>>>        
19117>>>>>>>>>>>        Get psDriverID to sDriver
19118>>>>>>>>>>>        If (sDriver <> "") Begin
19120>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
19121>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
19126>>>>>>>>>>>        End
19126>>>>>>>>>>>>
19126>>>>>>>>>>>        
19126>>>>>>>>>>>        Function_Return sOutConnStr
19127>>>>>>>>>>>    End_Function// BrowseConnect
19128>>>>>>>>>>>    
19128>>>>>>>>>>>    
19128>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
19130>>>>>>>>>>>        
19130>>>>>>>>>>>        String  sServerList
19130>>>>>>>>>>>        Integer iNumServers
19130>>>>>>>>>>>        Integer iDriver
19130>>>>>>>>>>>        Integer iClientVersion
19130>>>>>>>>>>>        String  sDriver
19130>>>>>>>>>>>        
19130>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
19131>>>>>>>>>>>        
19131>>>>>>>>>>>        If (iDriver) Begin
19133>>>>>>>>>>>            
19133>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
19136>>>>>>>>>>>            
19136>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
19137>>>>>>>>>>>            
19137>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
19138>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
19140>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
19141>>>>>>>>>>>            End
19141>>>>>>>>>>>>
19141>>>>>>>>>>>            Else Begin
19142>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
19143>>>>>>>>>>>            End
19143>>>>>>>>>>>>
19143>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
19144>>>>>>>>>>>        End
19144>>>>>>>>>>>>
19144>>>>>>>>>>>        
19144>>>>>>>>>>>        Function_Return iNumServers
19145>>>>>>>>>>>        
19145>>>>>>>>>>>    End_Function
19146>>>>>>>>>>>    
19146>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
19146>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
19146>>>>>>>>>>>    //   This may take a long time.
19146>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
19146>>>>>>>>>>>    Function EnumerateServers Returns Integer
19148>>>>>>>>>>>        
19148>>>>>>>>>>>        Integer iNumServers
19148>>>>>>>>>>>        Integer iNetworkLocal
19148>>>>>>>>>>>        
19148>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
19149>>>>>>>>>>>        
19149>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
19150>>>>>>>>>>>        
19150>>>>>>>>>>>        Function_Return iNumServers
19151>>>>>>>>>>>        
19151>>>>>>>>>>>    End_Function
19152>>>>>>>>>>>    
19152>>>>>>>>>>>    
19152>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
19152>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
19152>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
19152>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
19154>>>>>>>>>>>        
19154>>>>>>>>>>>        Integer iNumServers
19154>>>>>>>>>>>        Integer iNetworkLocal
19154>>>>>>>>>>>        
19154>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
19155>>>>>>>>>>>        
19155>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
19156>>>>>>>>>>>        
19156>>>>>>>>>>>        Function_Return iNumServers
19157>>>>>>>>>>>        
19157>>>>>>>>>>>    End_Function
19158>>>>>>>>>>>    
19158>>>>>>>>>>>    
19158>>>>>>>>>>>    
19158>>>>>>>>>>>    //   Enumerate database in a given server.
19158>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
19160>>>>>>>>>>>        Integer hoSQL
19160>>>>>>>>>>>        String  sConnect
19160>>>>>>>>>>>        String  sDatabase
19160>>>>>>>>>>>        Integer hdbc
19160>>>>>>>>>>>        Integer hstmt
19160>>>>>>>>>>>        Integer iFetchResult
19160>>>>>>>>>>>        
19160>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
19163>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
19166>>>>>>>>>>>        
19166>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
19169>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
19171>>>>>>>>>>>        
19171>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
19173>>>>>>>>>>>            Move Current_Object to hoSQL
19174>>>>>>>>>>>        End_Object
19175>>>>>>>>>>>        
19175>>>>>>>>>>>        If (hoSQL <> 0) Begin
19177>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
19178>>>>>>>>>>>            If (hdbc <> 0) Begin
19180>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
19181>>>>>>>>>>>                If (hstmt <> 0) Begin
19183>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
19183>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
19183>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
19183>>>>>>>>>>>                    //   stay the same.
19183>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
19184>>>>>>>>>>>                    Send SQLCall to hstmt
19185>>>>>>>>>>>                    Repeat
19185>>>>>>>>>>>>
19185>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
19186>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
19188>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
19189>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
19190>>>>>>>>>>>                        End
19190>>>>>>>>>>>>
19190>>>>>>>>>>>                    Until (iFetchResult = 0)
19192>>>>>>>>>>>                    
19192>>>>>>>>>>>                    Send SQLClose to hstmt
19193>>>>>>>>>>>                End
19193>>>>>>>>>>>>
19193>>>>>>>>>>>                Send SQLDisconnect to hdbc
19194>>>>>>>>>>>            End
19194>>>>>>>>>>>>
19194>>>>>>>>>>>        End
19194>>>>>>>>>>>>
19194>>>>>>>>>>>        Send Destroy_Object to hoSQL
19195>>>>>>>>>>>        
19195>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
19196>>>>>>>>>>>    End_Function
19197>>>>>>>>>>>    
19197>>>>>>>>>>>    
19197>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
19199>>>>>>>>>>>        
19199>>>>>>>>>>>        String  sSqlServerClientVersionName
19199>>>>>>>>>>>        
19199>>>>>>>>>>>        
19199>>>>>>>>>>>        Case Begin
19199>>>>>>>>>>>            
19199>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
19201>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
19202>>>>>>>>>>>                Case Break
19203>>>>>>>>>>>                
19203>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
19206>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
19207>>>>>>>>>>>                Case Break
19208>>>>>>>>>>>            
19208>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
19211>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
19212>>>>>>>>>>>                Case Break
19213>>>>>>>>>>>            
19213>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
19216>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
19217>>>>>>>>>>>                Case Break
19218>>>>>>>>>>>            
19218>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
19221>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
19222>>>>>>>>>>>                Case Break
19223>>>>>>>>>>>            
19223>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
19226>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
19227>>>>>>>>>>>                Case Break
19228>>>>>>>>>>>            
19228>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
19231>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
19232>>>>>>>>>>>                Case Break
19233>>>>>>>>>>>            
19233>>>>>>>>>>>            Case Else
19233>>>>>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
19234>>>>>>>>>>>                
19234>>>>>>>>>>>        Case End
19234>>>>>>>>>>>        
19234>>>>>>>>>>>        
19234>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
19235>>>>>>>>>>>        
19235>>>>>>>>>>>    End_Function
19236>>>>>>>>>>>
19236>>>>>>>>>>>
19236>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
19238>>>>>>>>>>>        
19238>>>>>>>>>>>        String  sSqlServerClientDriverName
19238>>>>>>>>>>>        
19238>>>>>>>>>>>        Case Begin
19238>>>>>>>>>>>            
19238>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
19240>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
19241>>>>>>>>>>>                Case Break
19242>>>>>>>>>>>                
19242>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
19245>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
19246>>>>>>>>>>>                Case Break
19247>>>>>>>>>>>            
19247>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
19250>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
19251>>>>>>>>>>>                Case Break
19252>>>>>>>>>>>            
19252>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
19255>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
19256>>>>>>>>>>>                Case Break
19257>>>>>>>>>>>            
19257>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
19260>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
19261>>>>>>>>>>>                Case Break
19262>>>>>>>>>>>            
19262>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
19265>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
19266>>>>>>>>>>>                Case Break
19267>>>>>>>>>>>            
19267>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
19270>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
19271>>>>>>>>>>>                Case Break
19272>>>>>>>>>>>            
19272>>>>>>>>>>>            Case Else
19272>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
19273>>>>>>>>>>>                
19273>>>>>>>>>>>        Case End
19273>>>>>>>>>>>        
19273>>>>>>>>>>>        
19273>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
19274>>>>>>>>>>>        
19274>>>>>>>>>>>    End_Function
19275>>>>>>>>>>>    
19275>>>>>>>>>>>    
19275>>>>>>>>>>>End_Class
19276>>>>>>>>>>>
19276>>>>>>>>>>>
19276>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\db2_drv.pkg)
19276>>>>>>>>>>>// DB2_DRV.PKG                                                          
19276>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
19276>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
19276>>>>>>>>>>>//   specific code to a DataFlex application.                           
19276>>>>>>>>>>>
19276>>>>>>>>>>>Use Cli.pkg
19276>>>>>>>>>>>
19276>>>>>>>>>>>// Driver attributes
19276>>>>>>>>>>>
19276>>>>>>>>>>>
19276>>>>>>>>>>>// Driver Indentification
19276>>>>>>>>>>>
19276>>>>>>>>>>>// Error number constants
19276>>>>>>>>>>>
19276>>>>>>>>>>>// Call driver function identifiers
19276>>>>>>>>>>>
19276>>>>>>>>>>>// DB2 specific data types
19276>>>>>>>>>>>Define SQL_CLOB           for   (-99)
19276>>>>>>>>>>>Define SQL_BLOB           for   (-98)
19276>>>>>>>>>>>Define SQL_XML            for   (-370)
19276>>>>>>>>>>>// DB2 Graphic types are Unicode types
19276>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
19276>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
19276>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
19276>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
19276>>>>>>>>>>>
19276>>>>>>>>>>>
19276>>>>>>>>>>>// Extra DB2 commands
19276>>>>>>>>>>>
19276>>>>>>>>>>>
19276>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
19276>>>>>>>>>>>//   Setup a constraint for a file.                                     
19276>>>>>>>>>>>
19276>>>>>>>>>>>
19276>>>>>>>>>>>
19276>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
19277>>>>>>>>>>>    
19277>>>>>>>>>>>    Procedure Construct_Object
19279>>>>>>>>>>>        Forward Send Construct_Object
19281>>>>>>>>>>>        
19281>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
19282>>>>>>>>>>>    End_Procedure
19283>>>>>>>>>>>    
19283>>>>>>>>>>>    
19283>>>>>>>>>>>    
19283>>>>>>>>>>>    // Reset the datasource list to the beginning
19283>>>>>>>>>>>    Procedure SeedDataSources
19285>>>>>>>>>>>        String  sDriver
19285>>>>>>>>>>>        String  sVoid
19285>>>>>>>>>>>        Integer iRetval
19285>>>>>>>>>>>        
19285>>>>>>>>>>>        Get psDriverID to sDriver
19286>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
19293>>>>>>>>>>>    End_Procedure
19294>>>>>>>>>>>    
19294>>>>>>>>>>>    
19294>>>>>>>>>>>    
19294>>>>>>>>>>>    // Call the driver's data sources function
19294>>>>>>>>>>>    Function DataSources Returns String
19296>>>>>>>>>>>        String  sDriver
19296>>>>>>>>>>>        String  sDataSource
19296>>>>>>>>>>>        String  sDescription
19296>>>>>>>>>>>        Integer iLength
19296>>>>>>>>>>>        Integer iRetval
19296>>>>>>>>>>>        
19296>>>>>>>>>>>        Get psDriverID to sDriver
19297>>>>>>>>>>>        If (sDriver <> "") Begin
19299>>>>>>>>>>>            Move 8192 to iLength
19300>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
19301>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
19302>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
19307>>>>>>>>>>>        End
19307>>>>>>>>>>>>
19307>>>>>>>>>>>        
19307>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
19310>>>>>>>>>>>        Else ;            Function_Return ""
19312>>>>>>>>>>>    End_Function
19313>>>>>>>>>>>    
19313>>>>>>>>>>>End_Class
19314>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\odbc_drv.pkg)
19314>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
19314>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
19314>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
19314>>>>>>>>>>>
19314>>>>>>>>>>>Use Cli.pkg
19314>>>>>>>>>>>
19314>>>>>>>>>>>// Driver Indentification
19314>>>>>>>>>>>
19314>>>>>>>>>>>// Error number constants
19314>>>>>>>>>>>
19314>>>>>>>>>>>// Call driver function identifiers
19314>>>>>>>>>>>
19314>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
19315>>>>>>>>>>>    
19315>>>>>>>>>>>    Procedure Construct_Object
19317>>>>>>>>>>>        Forward Send Construct_Object
19319>>>>>>>>>>>        
19319>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
19320>>>>>>>>>>>    End_Procedure
19321>>>>>>>>>>>    
19321>>>>>>>>>>>    
19321>>>>>>>>>>>    
19321>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
19321>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
19323>>>>>>>>>>>        String  sDriver
19323>>>>>>>>>>>        String  sVoid
19323>>>>>>>>>>>        Integer iRetval
19323>>>>>>>>>>>        
19323>>>>>>>>>>>        Get psDriverID to sDriver
19324>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
19331>>>>>>>>>>>    End_Procedure
19332>>>>>>>>>>>    
19332>>>>>>>>>>>    
19332>>>>>>>>>>>    // Call the driver's data sources function
19332>>>>>>>>>>>    Function DataSources Returns String
19334>>>>>>>>>>>        String  sDriver
19334>>>>>>>>>>>        String  sDataSource
19334>>>>>>>>>>>        String  sDescription
19334>>>>>>>>>>>        Integer iLength
19334>>>>>>>>>>>        Integer iRetval
19334>>>>>>>>>>>        
19334>>>>>>>>>>>        Get psDriverID to sDriver
19335>>>>>>>>>>>        If (sDriver <> "") Begin
19337>>>>>>>>>>>            Move 8192 to iLength
19338>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
19339>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
19340>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
19345>>>>>>>>>>>        End
19345>>>>>>>>>>>>
19345>>>>>>>>>>>        
19345>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
19348>>>>>>>>>>>        Else ;            Function_Return ""
19350>>>>>>>>>>>    End_Function
19351>>>>>>>>>>>    
19351>>>>>>>>>>>End_Class
19352>>>>>>>>>>>
19352>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
19352>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
19352>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
19352>>>>>>>>>>>//               specific functions in the DFBTRDRV.
19352>>>>>>>>>>>Use Ui
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Driver Indentification
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>// Driver attributes
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Call_Driver functions ID's
19352>>>>>>>>>>>//
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// DFBTRFN_SET_OWNER options
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to create all vars which may be needed
19352>>>>>>>>>>>// in other commands.
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to set the owner of a Btrieve file.
19352>>>>>>>>>>>// File must have been opened.
19352>>>>>>>>>>>// Filenumber needs to be passed.
19352>>>>>>>>>>>// To clear set the owner to "".
19352>>>>>>>>>>>// Examples:
19352>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
19352>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
19352>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
19352>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
19352>>>>>>>>>>>// To clear:
19352>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
19352>>>>>>>>>>>// options.
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to parse for Callback
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
19352>>>>>>>>>>>// File must have been opened.
19352>>>>>>>>>>>// Filenumber needs to be passed.
19352>>>>>>>>>>>// Examples:
19352>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
19352>>>>>>>>>>>// which will be tries when opening files.
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
19352>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
19352>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
19352>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to change the transaction type.
19352>>>>>>>>>>>// Valid types are:
19352>>>>>>>>>>>//     DFBTRTT_NONE
19352>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
19352>>>>>>>>>>>//     DFBTRTT_CONCURRENT
19352>>>>>>>>>>>//
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to get the current transaction type.
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to set explicit_locking
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to get explicit locking
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>//
19352>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
19352>>>>>>>>>>>//
19352>>>>>>>>>>>
19352>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
19352>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
19352>>>>>>>>>>>
19352>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
19353>>>>>>>>>>>    
19353>>>>>>>>>>>    Procedure Construct_Object Integer iImage
19355>>>>>>>>>>>        Forward Send Construct_object iImage
19357>>>>>>>>>>>        
19357>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
19358>>>>>>>>>>>    End_Procedure
19359>>>>>>>>>>>    
19359>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
19359>>>>>>>>>>>    //
19359>>>>>>>>>>>    
19359>>>>>>>>>>>    Function CKRevision Returns String
19361>>>>>>>>>>>        String  sDriverID
19361>>>>>>>>>>>        String  sRevision
19361>>>>>>>>>>>        String  sVoid
19361>>>>>>>>>>>        Integer iRetval
19361>>>>>>>>>>>        
19361>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
19361>>>>>>>>>>>        // This error would otherwise be raised when we have an older
19361>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
19361>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
19362>>>>>>>>>>>        Get psDriverID to sDriverID
19363>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
19364>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
19369>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
19370>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
19372>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
19372>>>>>>>>>>>            Move "0.0.0.0" to sRevision
19373>>>>>>>>>>>        End
19373>>>>>>>>>>>>
19373>>>>>>>>>>>        Function_Return sRevision
19374>>>>>>>>>>>    End_Function
19375>>>>>>>>>>>    
19375>>>>>>>>>>>    Function CkUsesUri Returns Integer
19377>>>>>>>>>>>        String  sDriverID
19377>>>>>>>>>>>        String  sVoid1
19377>>>>>>>>>>>        String  sVoid2
19377>>>>>>>>>>>        Integer iRetval
19377>>>>>>>>>>>        
19377>>>>>>>>>>>        Get psDriverID to sDriverID
19378>>>>>>>>>>>        
19378>>>>>>>>>>>        Move 0 to iRetval
19379>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
19379>>>>>>>>>>>        // This error would otherwise be raised when we have an older
19379>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
19379>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
19380>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
19385>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
19386>>>>>>>>>>>        
19386>>>>>>>>>>>        Function_Return iRetval
19387>>>>>>>>>>>    End_Function
19388>>>>>>>>>>>    
19388>>>>>>>>>>>    
19388>>>>>>>>>>>    
19388>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
19388>>>>>>>>>>>    //
19388>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
19388>>>>>>>>>>>    //
19388>>>>>>>>>>>    
19388>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
19390>>>>>>>>>>>        Integer iPartRev
19390>>>>>>>>>>>        Integer iCurrentPart
19390>>>>>>>>>>>        Integer iSeparatorPos
19390>>>>>>>>>>>        
19390>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
19393>>>>>>>>>>>        
19393>>>>>>>>>>>        Move 0 to iCurrentPart
19394>>>>>>>>>>>        Repeat
19394>>>>>>>>>>>>
19394>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
19395>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
19397>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
19398>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
19399>>>>>>>>>>>                Increment iCurrentPart
19400>>>>>>>>>>>            End
19400>>>>>>>>>>>>
19400>>>>>>>>>>>            Else If (sRevision <> "") Begin
19403>>>>>>>>>>>                Move sRevision to iPartRev
19404>>>>>>>>>>>                Move "" to sRevision
19405>>>>>>>>>>>                Increment iCurrentPart
19406>>>>>>>>>>>            End
19406>>>>>>>>>>>>
19406>>>>>>>>>>>            Else ;                Move -1 to iPartRev
19408>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
19410>>>>>>>>>>>        
19410>>>>>>>>>>>        Function_Return iPartRev
19411>>>>>>>>>>>    End_Function
19412>>>>>>>>>>>    
19412>>>>>>>>>>>    
19412>>>>>>>>>>>    
19412>>>>>>>>>>>    //
19412>>>>>>>>>>>    //  Returns the major revision of the CK
19412>>>>>>>>>>>    //
19412>>>>>>>>>>>    
19412>>>>>>>>>>>    Function CKMajorRevision Returns Integer
19414>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
19415>>>>>>>>>>>    End_Function
19416>>>>>>>>>>>    
19416>>>>>>>>>>>    
19416>>>>>>>>>>>    
19416>>>>>>>>>>>    //  Returns the minor revision of the CK
19416>>>>>>>>>>>    //
19416>>>>>>>>>>>    
19416>>>>>>>>>>>    Function CKMinorRevision Returns Integer
19418>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
19419>>>>>>>>>>>    End_Function
19420>>>>>>>>>>>    
19420>>>>>>>>>>>    
19420>>>>>>>>>>>    //  Returns the release revision of the CK
19420>>>>>>>>>>>    //
19420>>>>>>>>>>>    
19420>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
19422>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
19423>>>>>>>>>>>    End_Function
19424>>>>>>>>>>>    
19424>>>>>>>>>>>    
19424>>>>>>>>>>>    //  Returns the major revision of the CK
19424>>>>>>>>>>>    //
19424>>>>>>>>>>>    
19424>>>>>>>>>>>    Function CKBuildRevision Returns Integer
19426>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
19427>>>>>>>>>>>    End_Function
19428>>>>>>>>>>>    
19428>>>>>>>>>>>    
19428>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
19428>>>>>>>>>>>    //
19428>>>>>>>>>>>    
19428>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
19430>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
19433>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
19436>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
19439>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
19442>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
19445>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
19449>>>>>>>>>>>            End
19449>>>>>>>>>>>>
19449>>>>>>>>>>>        End
19449>>>>>>>>>>>>
19449>>>>>>>>>>>        
19449>>>>>>>>>>>        Function_Return (False)
19450>>>>>>>>>>>    End_Function
19451>>>>>>>>>>>    
19451>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
19451>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
19451>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
19451>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
19451>>>>>>>>>>>    //
19451>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
19451>>>>>>>>>>>    //   in the following format:
19451>>>>>>>>>>>    //       <version>.<revision>.<type>
19451>>>>>>>>>>>    //   possible values for <type>:
19451>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
19451>>>>>>>>>>>    //         server using Workgroup authentication mode
19451>>>>>>>>>>>    //       C for client cache engine
19451>>>>>>>>>>>    //       D for DOS workstation
19451>>>>>>>>>>>    //       N for client Requester
19451>>>>>>>>>>>    //       S for NetWare server
19451>>>>>>>>>>>    //       T for 32-bit Windows server engine
19451>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
19451>>>>>>>>>>>    //
19451>>>>>>>>>>>    //   example:
19451>>>>>>>>>>>    //       8.50.T
19451>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
19451>>>>>>>>>>>    //   32-bits Windows server.
19451>>>>>>>>>>>    //
19451>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
19451>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
19451>>>>>>>>>>>    //
19451>>>>>>>>>>>    //   If the version information is not available or can not be obtained
19451>>>>>>>>>>>    //   the functions will return "0.0.0"
19451>>>>>>>>>>>    
19451>>>>>>>>>>>    //  Returns the version information of the
19451>>>>>>>>>>>    //           Pervasive.SQL Client requester.
19451>>>>>>>>>>>    
19451>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
19453>>>>>>>>>>>        
19453>>>>>>>>>>>        String  sDriverID
19453>>>>>>>>>>>        String  sVersion
19453>>>>>>>>>>>        String  sVoid
19453>>>>>>>>>>>        Integer iRetval
19453>>>>>>>>>>>        
19453>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
19453>>>>>>>>>>>        // This error would otherwise be raised when we have an older
19453>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
19453>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
19454>>>>>>>>>>>        Get psDriverID to sDriverID
19455>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
19456>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
19461>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
19462>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
19464>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
19464>>>>>>>>>>>            Move "0.0.0" to sVersion
19465>>>>>>>>>>>        End
19465>>>>>>>>>>>>
19465>>>>>>>>>>>        Function_Return sVersion
19466>>>>>>>>>>>    End_Function
19467>>>>>>>>>>>    
19467>>>>>>>>>>>    //           Pervasive.SQL Engine
19467>>>>>>>>>>>    
19467>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
19469>>>>>>>>>>>        
19469>>>>>>>>>>>        String  sDriverID
19469>>>>>>>>>>>        String  sVersion
19469>>>>>>>>>>>        String  sVoid
19469>>>>>>>>>>>        Integer iRetval
19469>>>>>>>>>>>        
19469>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
19469>>>>>>>>>>>        // This error would otherwise be raised when we have an older
19469>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
19469>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
19470>>>>>>>>>>>        Get psDriverID to sDriverID
19471>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
19472>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
19477>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
19478>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
19480>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
19480>>>>>>>>>>>            Move "0.0.0" to sVersion
19481>>>>>>>>>>>        End
19481>>>>>>>>>>>>
19481>>>>>>>>>>>        Function_Return sVersion
19482>>>>>>>>>>>    End_Function
19483>>>>>>>>>>>    
19483>>>>>>>>>>>    //  Returns the version information of the
19483>>>>>>>>>>>    //           Pervasive.SQL Server Engine
19483>>>>>>>>>>>    
19483>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
19485>>>>>>>>>>>        
19485>>>>>>>>>>>        String  sDriverID
19485>>>>>>>>>>>        String  sVersion
19485>>>>>>>>>>>        String  sVoid
19485>>>>>>>>>>>        Integer iRetval
19485>>>>>>>>>>>        
19485>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
19485>>>>>>>>>>>        // This error would otherwise be raised when we have an older
19485>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
19485>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
19486>>>>>>>>>>>        Get psDriverID to sDriverID
19487>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
19488>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
19493>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
19494>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
19496>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
19496>>>>>>>>>>>            Move "0.0.0" to sVersion
19497>>>>>>>>>>>        End
19497>>>>>>>>>>>>
19497>>>>>>>>>>>        Function_Return sVersion
19498>>>>>>>>>>>    End_Function
19499>>>>>>>>>>>    
19499>>>>>>>>>>>End_Class
19500>>>>>>>>>>>
19500>>>>>>>>>>>
19500>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateFunctionLibrary.inc)
19500>>>>>>>>>>>Use DUFLanguageConstants.inc
19500>>>>>>>>>>>
19500>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
19500>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
19500>>>>>>>>>>>
19500>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
19500>>>>>>>>>>>
19500>>>>>>>>>>>
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_SERVER for "SERVER"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
19500>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
19500>>>>>>>>>>>
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tSQLScriptArray
19500>>>>>>>>>>>    Boolean bError
19500>>>>>>>>>>>    Boolean bArgumentSizeChanged
19500>>>>>>>>>>>    Integer iOrgArgumentSize
19500>>>>>>>>>>>    String[] sSQLScriptArray
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tSqlErrorArray
19500>>>>>>>>>>>    String[]  sSqlErrorArray
19500>>>>>>>>>>>    String[]  sSqlStatementArray
19500>>>>>>>>>>>    Integer[] iSqlErrorArray
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tSqlColumnNew
19500>>>>>>>>>>>    String  sBaseColumnName
19500>>>>>>>>>>>    String  sBaseTableName
19500>>>>>>>>>>>    String  sLabel
19500>>>>>>>>>>>    Integer iSqlType
19500>>>>>>>>>>>    Integer iSize
19500>>>>>>>>>>>    Integer iPrecision
19500>>>>>>>>>>>    Integer iDFType
19500>>>>>>>>>>>    Integer iDFNativeType
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tColumnType
19500>>>>>>>>>>>    String  sSQLType
19500>>>>>>>>>>>    Integer iSQLType
19500>>>>>>>>>>>    Boolean bCanEditSize
19500>>>>>>>>>>>    Integer iDefaultSize
19500>>>>>>>>>>>    Integer iMinSize
19500>>>>>>>>>>>    Number  nMaxSize
19500>>>>>>>>>>>    String  sDataFlexType
19500>>>>>>>>>>>    Integer iDataFlexType
19500>>>>>>>>>>>    Boolean bNativeDataType
19500>>>>>>>>>>>    String  sPrecision
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
19500>>>>>>>>>>>// Various SQL back-ends can have slightly different
19500>>>>>>>>>>>// keywords.
19500>>>>>>>>>>>Struct tSQLKeyWords
19500>>>>>>>>>>>    Integer iSQLWord
19500>>>>>>>>>>>    Integer iSQLDbType
19500>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tSQLRelation
19500>>>>>>>>>>>    Integer iFileNumber
19500>>>>>>>>>>>    Integer iFieldNumber
19500>>>>>>>>>>>    String  sFileName
19500>>>>>>>>>>>    String  sFieldName
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tSQLLoggedInUser
19500>>>>>>>>>>>    String sUser
19500>>>>>>>>>>>    String sProgram
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
19500>>>>>>>>>>>
19500>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
19500>>>>>>>>>>>// They can have slightly different SQL keywords.
19500>>>>>>>>>>>// Note: If a new type is added to the list,
19500>>>>>>>>>>>//       the struct array xxx must be adjusted
19500>>>>>>>>>>>//       so that it is filled with all SQL
19500>>>>>>>>>>>//       keywords for that new type.
19500>>>>>>>>>>>Enum_List
19500>>>>>>>>>>>    Define EN_DbTypeMSSQL
19500>>>>>>>>>>>    Define EN_DbTypeMySQL
19500>>>>>>>>>>>    Define EN_DbTypeOracle
19500>>>>>>>>>>>    Define EN_DbTypeDB2
19500>>>>>>>>>>>    Define EN_DbTypePostgre
19500>>>>>>>>>>>    Define EN_DbTypeDataFlex // Embedded database.
19500>>>>>>>>>>>End_Enum_List
19500>>>>>>>>>>>
19500>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
19500>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
19500>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
19500>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
19500>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
19500>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
19500>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
19500>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
19500>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
19500>>>>>>>>>>>
19500>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
19500>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
19500>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
19500>>>>>>>>>>>Enum_List
19500>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
19500>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
19500>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
19500>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
19500>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
19500>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
19500>>>>>>>>>>>End_Enum_List
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
19500>>>>>>>>>>>
19500>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
19500>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
19500>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
19500>>>>>>>>>>>
19500>>>>>>>>>>>// These are not defined pre DF 18:
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tSQLIntTableInfo
19500>>>>>>>>>>>    String sDriverName
19500>>>>>>>>>>>    String sServerName
19500>>>>>>>>>>>    String sDatabaseName
19500>>>>>>>>>>>    String sSchemaName
19500>>>>>>>>>>>    Boolean bRecnumTable
19500>>>>>>>>>>>    Integer iPrimaryIndex
19500>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
19500>>>>>>>>>>>    String sTableCharacterFormat
19500>>>>>>>>>>>    Boolean bUseDummyZeroDate
19500>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
19500>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
19500>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
19500>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
19500>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
19500>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
19500>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
19500>>>>>>>>>>>    String sFileIndexTablespace
19500>>>>>>>>>>>    String sFileLongTablespace
19500>>>>>>>>>>>    String sTableTablespace
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tSQLIntColumnInfo
19500>>>>>>>>>>>    Integer iFieldNumber
19500>>>>>>>>>>>    Integer iFieldIndex
19500>>>>>>>>>>>    Integer iFieldRelatedFile
19500>>>>>>>>>>>    Integer iFieldRelatedField
19500>>>>>>>>>>>    Integer iIndexNumber
19500>>>>>>>>>>>    Integer iIndexNumberSegments
19500>>>>>>>>>>>    Integer iIndexSegmentField1
19500>>>>>>>>>>>    Integer iIndexSegmentField2
19500>>>>>>>>>>>    Integer iIndexSegmentFieldn
19500>>>>>>>>>>>    String  sIndexName
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPIColumn
19500>>>>>>>>>>>    Integer iFieldNumber
19500>>>>>>>>>>>    String  sFieldName
19500>>>>>>>>>>>    Integer iType
19500>>>>>>>>>>>    String  sType
19500>>>>>>>>>>>    Integer iLength
19500>>>>>>>>>>>    Integer iPrecision
19500>>>>>>>>>>>    Integer iOptions
19500>>>>>>>>>>>    Boolean bIsSQLType
19500>>>>>>>>>>>    Boolean bAllowNULL
19500>>>>>>>>>>>    String  sDefaultValue
19500>>>>>>>>>>>    Boolean bShouldChange
19500>>>>>>>>>>>    Boolean bCancel
19500>>>>>>>>>>>    Boolean bError
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPIColumnCompare
19500>>>>>>>>>>>    Integer iFieldNumber
19500>>>>>>>>>>>    // FROM database:
19500>>>>>>>>>>>    Boolean bExistsFrom
19500>>>>>>>>>>>    String  sFieldNameFrom
19500>>>>>>>>>>>    Integer iTypeFrom
19500>>>>>>>>>>>    String  sTypeFrom
19500>>>>>>>>>>>    Integer iLengthFrom
19500>>>>>>>>>>>    Integer iPrecisionFrom
19500>>>>>>>>>>>    Integer iOptionsFrom
19500>>>>>>>>>>>    Boolean bIsSQLTypeFrom
19500>>>>>>>>>>>    Boolean bAllowNULLFrom
19500>>>>>>>>>>>    String  sDefaultValueFrom
19500>>>>>>>>>>>    Boolean bShouldChangeFrom
19500>>>>>>>>>>>    Boolean bCancelFrom
19500>>>>>>>>>>>    Boolean bErrorFrom
19500>>>>>>>>>>>    // TO database:
19500>>>>>>>>>>>    Boolean bExistsTo
19500>>>>>>>>>>>    Integer iFieldNumberTo
19500>>>>>>>>>>>    String  sFieldNameTo
19500>>>>>>>>>>>    Integer iTypeTo
19500>>>>>>>>>>>    String  sTypeTo
19500>>>>>>>>>>>    Integer iLengthTo
19500>>>>>>>>>>>    Integer iPrecisionTo
19500>>>>>>>>>>>    Integer iOptionsTo
19500>>>>>>>>>>>    Boolean bIsSQLTypeTo
19500>>>>>>>>>>>    Boolean bAllowNULLTo
19500>>>>>>>>>>>    String  sDefaultValueTo
19500>>>>>>>>>>>    Boolean bShouldChangeTo
19500>>>>>>>>>>>    Boolean bCancelTo
19500>>>>>>>>>>>    Boolean bErrorTo
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPIRelation
19500>>>>>>>>>>>    Handle  hTableFrom
19500>>>>>>>>>>>    Integer iColumnFrom
19500>>>>>>>>>>>    Handle  hTableTo
19500>>>>>>>>>>>    Integer iColumnTo
19500>>>>>>>>>>>    String  sLogicalNameFrom
19500>>>>>>>>>>>    String  sLogicalNameTo
19500>>>>>>>>>>>    String  sFieldNameFrom
19500>>>>>>>>>>>    String  sFieldNameTo
19500>>>>>>>>>>>    Boolean bShouldChange
19500>>>>>>>>>>>    Boolean bCancel
19500>>>>>>>>>>>    Boolean bError
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPIRelationCompare
19500>>>>>>>>>>>    // Common:
19500>>>>>>>>>>>    Handle  hTableFrom
19500>>>>>>>>>>>    Integer iColumnFrom
19500>>>>>>>>>>>    Handle  hTableTo
19500>>>>>>>>>>>    Integer iColumnTo
19500>>>>>>>>>>>    // FROM database:
19500>>>>>>>>>>>    Boolean bExistsFrom
19500>>>>>>>>>>>    String  sLogicalNameFrom_From
19500>>>>>>>>>>>    String  sLogicalNameTo_From
19500>>>>>>>>>>>    String  sFieldNameFrom_From
19500>>>>>>>>>>>    String  sFieldNameTo_From
19500>>>>>>>>>>>    Boolean bShouldChange_From
19500>>>>>>>>>>>    Boolean bCancel_From
19500>>>>>>>>>>>    Boolean bError_From
19500>>>>>>>>>>>    // TO database:
19500>>>>>>>>>>>    Boolean bExistsTo
19500>>>>>>>>>>>    String  sLogicalNameFrom_To
19500>>>>>>>>>>>    String  sLogicalNameTo_To
19500>>>>>>>>>>>    String  sFieldNameFrom_To
19500>>>>>>>>>>>    String  sFieldNameTo_To
19500>>>>>>>>>>>    Boolean bShouldChange_To
19500>>>>>>>>>>>    Boolean bCancel_To
19500>>>>>>>>>>>    Boolean bError_To
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPIIndexSegment
19500>>>>>>>>>>>    Integer iFieldNumber
19500>>>>>>>>>>>    String  sFieldName
19500>>>>>>>>>>>    Boolean bUppercase
19500>>>>>>>>>>>    Boolean bAscending
19500>>>>>>>>>>>    Boolean bShouldChange
19500>>>>>>>>>>>    Boolean bCancel
19500>>>>>>>>>>>    Boolean bError
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPIIndex
19500>>>>>>>>>>>    Integer iIndexNumber
19500>>>>>>>>>>>    Integer iPrimaryIndex
19500>>>>>>>>>>>    String  sSQLIndexName
19500>>>>>>>>>>>    Integer iSQLIndexType
19500>>>>>>>>>>>    Boolean bIsSQLClustered
19500>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
19500>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
19500>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
19500>>>>>>>>>>>    Boolean bShouldChange
19500>>>>>>>>>>>    Boolean bCancel
19500>>>>>>>>>>>    Boolean bError
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPIIndexCompare
19500>>>>>>>>>>>    // Common:
19500>>>>>>>>>>>    Integer iIndexNumber
19500>>>>>>>>>>>    // FROM database:
19500>>>>>>>>>>>    Boolean bExistsFrom
19500>>>>>>>>>>>    Integer iPrimaryIndexFrom
19500>>>>>>>>>>>    String  sSQLIndexNameFrom
19500>>>>>>>>>>>    Integer iSQLIndexTypeFrom
19500>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
19500>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
19500>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
19500>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
19500>>>>>>>>>>>    Boolean bShouldChangeFrom
19500>>>>>>>>>>>    Boolean bCancelFrom
19500>>>>>>>>>>>    Boolean bErrorFrom
19500>>>>>>>>>>>    // TO database:
19500>>>>>>>>>>>    Boolean bExistsTo
19500>>>>>>>>>>>    Integer iPrimaryIndexTo
19500>>>>>>>>>>>    String  sSQLIndexNameTo
19500>>>>>>>>>>>    Integer iSQLIndexTypeTo
19500>>>>>>>>>>>    Boolean bIsSQLClusteredTo
19500>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
19500>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
19500>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
19500>>>>>>>>>>>    Boolean bShouldChangeTo
19500>>>>>>>>>>>    Boolean bCancelTo
19500>>>>>>>>>>>    Boolean bErrorTo
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPITableNameInfo
19500>>>>>>>>>>>    Integer iTableNumber
19500>>>>>>>>>>>    String  sRootName
19500>>>>>>>>>>>    String  sLogicalName
19500>>>>>>>>>>>    String  sDisplayName
19500>>>>>>>>>>>    String  sDriverID
19500>>>>>>>>>>>    Boolean bIsAlias
19500>>>>>>>>>>>    Boolean bIsSQL
19500>>>>>>>>>>>    Boolean bIsSystemFile
19500>>>>>>>>>>>    Boolean bShouldChange
19500>>>>>>>>>>>    Boolean bCancel
19500>>>>>>>>>>>    Boolean bError
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPITableNameInfoCompare
19500>>>>>>>>>>>    Integer iTableNumber
19500>>>>>>>>>>>    // FROM
19500>>>>>>>>>>>    Boolean bExistsFrom
19500>>>>>>>>>>>    String  sRootNameFrom
19500>>>>>>>>>>>    String  sLogicalNameFrom
19500>>>>>>>>>>>    String  sDisplayNameFrom
19500>>>>>>>>>>>    String  sDriverIDFrom
19500>>>>>>>>>>>    Boolean bIsAliasFrom
19500>>>>>>>>>>>    Boolean bIsSQLFrom
19500>>>>>>>>>>>    Boolean bIsSystemFileFrom
19500>>>>>>>>>>>    // TO database:
19500>>>>>>>>>>>    Boolean bExistsTo
19500>>>>>>>>>>>    String  sRootNameTo
19500>>>>>>>>>>>    String  sLogicalNameTo
19500>>>>>>>>>>>    String  sDisplayNameTo
19500>>>>>>>>>>>    String  sDriverIDTo
19500>>>>>>>>>>>    Boolean bIsAliasTo
19500>>>>>>>>>>>    Boolean bIsSQLTo
19500>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
19500>>>>>>>>>>>    Boolean bShouldChange
19500>>>>>>>>>>>    Boolean bCancel
19500>>>>>>>>>>>    Boolean bError
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPITable
19500>>>>>>>>>>>    Handle hTable
19500>>>>>>>>>>>    Boolean bFromTable
19500>>>>>>>>>>>    Boolean bToTable
19500>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
19500>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
19500>>>>>>>>>>>    tAPIColumn[]      aApiColumns
19500>>>>>>>>>>>    tAPIColumn[]      aApiColumns
19500>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
19500>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
19500>>>>>>>>>>>    tAPIRelation[]    aApiRelations
19500>>>>>>>>>>>    tAPIRelation[]    aApiRelations
19500>>>>>>>>>>>    Boolean bShouldChange
19500>>>>>>>>>>>    Boolean bCancel
19500>>>>>>>>>>>    Boolean bError
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPITableCompare
19500>>>>>>>>>>>    Handle hTable
19500>>>>>>>>>>>    // FROM database:
19500>>>>>>>>>>>    Boolean bExistsFrom
19500>>>>>>>>>>>    // TO database:
19500>>>>>>>>>>>    Boolean bExistsTo
19500>>>>>>>>>>>    // Both:
19500>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
19500>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
19500>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
19500>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
19500>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
19500>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
19500>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
19500>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
19500>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
19500>>>>>>>>>>>    Boolean bCancel         // User cancel
19500>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>
19500>>>>>>>>>>>Struct tAPITableBooleans
19500>>>>>>>>>>>    Boolean bApiTableUpdateAuto
19500>>>>>>>>>>>    Boolean bCompareDate_DateTime
19500>>>>>>>>>>>    Boolean bCompareIndexAscending
19500>>>>>>>>>>>    Boolean bCompareIndexUppercase
19500>>>>>>>>>>>    Boolean bCompareFilelistUppercase
19500>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>
19500>>>>>>>>>>>Define C_tAPIColumn_None for 0
19500>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
19500>>>>>>>>>>>
19500>>>>>>>>>>>// SQL Key-Word Constants:
19500>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
19500>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
19500>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
19500>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
19500>>>>>>>>>>>Enum_List
19500>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
19500>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
19500>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
19500>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
19500>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
19500>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
19500>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
19500>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
19500>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
19500>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
19500>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
19500>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
19500>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
19500>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
19500>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
19500>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
19500>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
19500>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
19500>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
19500>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
19500>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
19500>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
19500>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
19500>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
19500>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
19500>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
19500>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
19500>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
19500>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
19500>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
19500>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
19500>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
19500>>>>>>>>>>>
19500>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
19500>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
19500>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
19500>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
19500>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
19500>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
19500>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
19500>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
19500>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
19500>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
19500>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
19500>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"
19500>>>>>>>>>>>End_Enum_List
19500>>>>>>>>>>>
19500>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cSQLConnectionIniFile.inc)
19500>>>>>>>>>>>//****************************************************************************
19500>>>>>>>>>>>// $Module type: Include file
19500>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
19500>>>>>>>>>>>//
19500>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
19500>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
19500>>>>>>>>>>>// E-mail      : support@rdctools.com
19500>>>>>>>>>>>// Web-site    : http://www.rdctools.com
19500>>>>>>>>>>>//
19500>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
19500>>>>>>>>>>>//
19500>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
19500>>>>>>>>>>>//
19500>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
19500>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
19500>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
19500>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
19500>>>>>>>>>>>// in the help folder for more details.
19500>>>>>>>>>>>//
19500>>>>>>>>>>>Use Winkern.pkg
19500>>>>>>>>>>>Use cIniFile.pkg
19500>>>>>>>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCryptographer.pkg)
19500>>>>>>>>>>>>>Use VdfBase.pkg
19500>>>>>>>>>>>>>
19500>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\CryptographerConstants.pkg)
19500>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
19500>>>>>>>>>>>>>>>// Algorithm classes
19500>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
19500>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
19500>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
19500>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
19500>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
19500>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
19500>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// Algorithm types
19500>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
19500>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
19500>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
19500>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
19500>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
19500>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
19500>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// Generic sub-ids
19500>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// RSA sub-ids
19500>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
19500>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
19500>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
19500>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
19500>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// DSS sub-ids
19500>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
19500>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
19500>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// DES sub_ids
19500>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
19500>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
19500>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
19500>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
19500>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
19500>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
19500>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
19500>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
19500>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
19500>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
19500>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
19500>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
19500>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
19500>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// Fortezza sub-ids
19500>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
19500>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// RC2 sub-ids
19500>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// Stream cipher sub-ids
19500>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
19500>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
19500>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
19500>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
19500>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
19500>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// Hash sub ids
19500>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
19500>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
19500>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
19500>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
19500>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
19500>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
19500>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
19500>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
19500>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
19500>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
19500>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
19500>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
19500>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
19500>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
19500>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// secure channel sub ids
19500>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
19500>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
19500>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
19500>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
19500>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
19500>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
19500>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// algorithm identifier definitions
19500>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
19500>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
19500>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
19500>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
19500>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
19500>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
19500>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
19500>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
19500>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
19500>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
19500>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
19500>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
19500>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
19500>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
19500>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
19500>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
19500>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
19500>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
19500>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
19500>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
19500>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
19500>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
19500>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
19500>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
19500>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
19500>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
19500>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
19500>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
19500>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
19500>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
19500>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
19500>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
19500>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
19500>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
19500>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
19500>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
19500>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
19500>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
19500>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
19500>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
19500>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
19500>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
19500>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
19500>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// Providers
19500>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
19500>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
19500>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
19500>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
19500>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
19500>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
19500>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
19500>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
19500>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
19500>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
19500>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
19500>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
19500>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
19500>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
19500>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
19500>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
19500>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
19500>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
19500>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
19500>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
19500>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
19500>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
19500>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
19500>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
19500>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
19500>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
19500>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
19500>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
19500>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
19500>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
19500>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
19500>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// Provider types
19500>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
19500>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
19500>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
19500>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
19500>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
19500>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
19500>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
19500>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
19500>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
19500>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
19500>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
19500>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
19500>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
19500>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
19500>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
19500>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
19500>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
19500>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// KP_MODE
19500>>>>>>>>>>>>>>>// KP_MODE
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
19500>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
19500>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
19500>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
19500>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
19500>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
19500>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
19500>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
19500>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
19500>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
19500>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
19500>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
19500>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
19500>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
19500>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
19500>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
19500>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
19500>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
19500>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
19500>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
19500>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
19500>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
19500>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
19500>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
19500>>>>>>>>>>>>>>>Define KP_RP                            for 23
19500>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
19500>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
19500>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
19500>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
19500>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
19500>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
19500>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
19500>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
19500>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
19500>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
19500>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
19500>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
19500>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
19500>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
19500>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
19500>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
19500>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
19500>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
19500>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
19500>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
19500>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
19500>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
19500>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>// key BLOB types
19500>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
19500>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
19500>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
19500>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
19500>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
19500>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
19500>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
19500>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>//  Structure cryptimportkey
19500>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
19500>>>>>>>>>>>>>>>    UChar    bType
19500>>>>>>>>>>>>>>>    UChar    bVersion
19500>>>>>>>>>>>>>>>    UShort   reserved
19500>>>>>>>>>>>>>>>    UInteger aiKeyAlg
19500>>>>>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
19500>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
19500>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
19500>>>>>>>>>>>>>>>    UInteger       dwKeySize
19500>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
19500>>>>>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
19500>>>>>>>>>>>>>>>Struct HMAC_INFO
19500>>>>>>>>>>>>>>>    UInteger HashAlgid
19500>>>>>>>>>>>>>>>    Pointer pbInnerString
19500>>>>>>>>>>>>>>>    DWord cbInnerString
19500>>>>>>>>>>>>>>>    Pointer pbOuterString
19500>>>>>>>>>>>>>>>    DWord cbOuterString
19500>>>>>>>>>>>>>>>End_Struct
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>
19500>>>>>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
19501>>>>>>>>>>>>>>>
19501>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
19502>>>>>>>>>>>>>>>
19502>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
19503>>>>>>>>>>>>>>>
19503>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
19504>>>>>>>>>>>>>>>
19504>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
19505>>>>>>>>>>>>>>>
19505>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
19506>>>>>>>>>>>>>>>
19506>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
19507>>>>>>>>>>>>>>>
19507>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
19508>>>>>>>>>>>>>>>
19508>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
19509>>>>>>>>>>>>>>>
19509>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
19510>>>>>>>>>>>>>>>    
19510>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
19511>>>>>>>>>>>>>>>
19511>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
19512>>>>>>>>>>>>>>>
19512>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
19513>>>>>>>>>>>>>>>
19513>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
19514>>>>>>>>>>>>>>>    
19514>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
19515>>>>>>>>>>>>>>>    
19515>>>>>>>>>>>>>
19515>>>>>>>>>>>>>Class cCryptographer is a cObject
19516>>>>>>>>>>>>>    
19516>>>>>>>>>>>>>    Procedure Construct_Object
19518>>>>>>>>>>>>>        Forward Send Construct_Object
19520>>>>>>>>>>>>>        
19520>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
19521>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
19522>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
19523>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
19524>>>>>>>>>>>>>        
19524>>>>>>>>>>>>>        // Private properties
19524>>>>>>>>>>>>>        Property Handle     Private_phProv
19525>>>>>>>>>>>>>    End_Procedure
19526>>>>>>>>>>>>>    
19526>>>>>>>>>>>>>    
19526>>>>>>>>>>>>>    // Acquire key container handle
19526>>>>>>>>>>>>>    Function AcquireContext Returns Handle
19528>>>>>>>>>>>>>        Integer iProvider
19528>>>>>>>>>>>>>        String sProvider
19528>>>>>>>>>>>>>        Handle hProv
19528>>>>>>>>>>>>>        Boolean bOk
19528>>>>>>>>>>>>>        Address addrProv
19528>>>>>>>>>>>>>        
19528>>>>>>>>>>>>>        Move 0 to hProv
19529>>>>>>>>>>>>>        Get piProvider to iProvider
19530>>>>>>>>>>>>>        Get psProvider to sProvider
19531>>>>>>>>>>>>>        
19531>>>>>>>>>>>>>        //  Determine address to be passed as provider
19531>>>>>>>>>>>>>        If (Trim(sProvider) <> "") Begin
19533>>>>>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
19534>>>>>>>>>>>>>        End
19534>>>>>>>>>>>>>>
19534>>>>>>>>>>>>>        Else Begin
19535>>>>>>>>>>>>>            Move 0 to addrProv
19536>>>>>>>>>>>>>        End
19536>>>>>>>>>>>>>>
19536>>>>>>>>>>>>>        
19536>>>>>>>>>>>>>        //  Acquire Crypto Context
19536>>>>>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
19537>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
19539>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
19540>>>>>>>>>>>>>        End
19540>>>>>>>>>>>>>>
19540>>>>>>>>>>>>>        
19540>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
19542>>>>>>>>>>>>>            // Fallback to original
19542>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
19543>>>>>>>>>>>>>            
19543>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
19545>>>>>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
19546>>>>>>>>>>>>>            End
19546>>>>>>>>>>>>>>
19546>>>>>>>>>>>>>        End
19546>>>>>>>>>>>>>>
19546>>>>>>>>>>>>>        Set Private_phProv to hProv
19547>>>>>>>>>>>>>        
19547>>>>>>>>>>>>>        Function_Return hProv
19548>>>>>>>>>>>>>    End_Function
19549>>>>>>>>>>>>>    
19549>>>>>>>>>>>>>    // Releases key container handle
19549>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
19551>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
19552>>>>>>>>>>>>>    End_Function
19553>>>>>>>>>>>>>    
19553>>>>>>>>>>>>>    // Creates hash object
19553>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
19555>>>>>>>>>>>>>        Integer iAlgorithm
19555>>>>>>>>>>>>>        Handle hHash
19555>>>>>>>>>>>>>        Boolean bOk
19555>>>>>>>>>>>>>        
19555>>>>>>>>>>>>>        Move 0 to hHash
19556>>>>>>>>>>>>>        Get piHash to iAlgorithm
19557>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
19558>>>>>>>>>>>>>        
19558>>>>>>>>>>>>>        Function_Return hHash
19559>>>>>>>>>>>>>    End_Function
19560>>>>>>>>>>>>>    
19560>>>>>>>>>>>>>    // Destroys the hash object
19560>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
19562>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
19563>>>>>>>>>>>>>    End_Function
19564>>>>>>>>>>>>>    
19564>>>>>>>>>>>>>    // Adds data to hash object
19564>>>>>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
19566>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
19567>>>>>>>>>>>>>    End_Function
19568>>>>>>>>>>>>>    
19568>>>>>>>>>>>>>    // Generates session key
19568>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
19570>>>>>>>>>>>>>        Integer iAlgorithm
19570>>>>>>>>>>>>>        Handle hKey
19570>>>>>>>>>>>>>        Boolean bOk
19570>>>>>>>>>>>>>        
19570>>>>>>>>>>>>>        Move 0 to hKey
19571>>>>>>>>>>>>>        Get piCipher to iAlgorithm
19572>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
19573>>>>>>>>>>>>>        
19573>>>>>>>>>>>>>        Function_Return hKey
19574>>>>>>>>>>>>>    End_Function
19575>>>>>>>>>>>>>    
19575>>>>>>>>>>>>>    // Imports a plain text key
19575>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
19577>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
19577>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
19577>>>>>>>>>>>>>        Boolean   bSuccess
19577>>>>>>>>>>>>>        Handle    hKey
19577>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
19577>>>>>>>>>>>>>        UChar[]   ucaKeyblob
19578>>>>>>>>>>>>>        Integer iVoid
19578>>>>>>>>>>>>>        
19578>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
19579>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
19580>>>>>>>>>>>>>        
19580>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
19581>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
19582>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
19583>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
19584>>>>>>>>>>>>>        
19584>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
19585>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
19586>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
19587>>>>>>>>>>>>>        
19587>>>>>>>>>>>>>        Move 0 to hKey
19588>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
19589>>>>>>>>>>>>>        If (not(bSuccess)) Begin
19591>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
19592>>>>>>>>>>>>>        End
19592>>>>>>>>>>>>>>
19592>>>>>>>>>>>>>        
19592>>>>>>>>>>>>>        Function_Return hKey
19593>>>>>>>>>>>>>    End_Function
19594>>>>>>>>>>>>>    
19594>>>>>>>>>>>>>    // Destroys the key
19594>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
19596>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
19597>>>>>>>>>>>>>    End_Function
19598>>>>>>>>>>>>>    
19598>>>>>>>>>>>>>    // Retrieves key data
19598>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
19600>>>>>>>>>>>>>        Integer iBuffer iLen
19600>>>>>>>>>>>>>        Boolean bOk
19600>>>>>>>>>>>>>        
19600>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
19601>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
19602>>>>>>>>>>>>>        Function_Return iBuffer
19603>>>>>>>>>>>>>    End_Function
19604>>>>>>>>>>>>>    
19604>>>>>>>>>>>>>    // Retrieves a hash value
19604>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns String
19606>>>>>>>>>>>>>        String  lsHash
19606>>>>>>>>>>>>>        Integer liResult
19606>>>>>>>>>>>>>        DWord   dwDataLen
19606>>>>>>>>>>>>>        
19606>>>>>>>>>>>>>        Move 0 to dwDataLen
19607>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
19608>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
19611>>>>>>>>>>>>>        
19611>>>>>>>>>>>>>        Move (Repeat(Character(0),dwDataLen)) to lsHash
19612>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(lsHash),AddressOf(dwDataLen),0)) to liResult
19613>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
19616>>>>>>>>>>>>>        
19616>>>>>>>>>>>>>        Function_Return lsHash
19617>>>>>>>>>>>>>    End_Function
19618>>>>>>>>>>>>>
19618>>>>>>>>>>>>>    // Encrypts data
19618>>>>>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
19620>>>>>>>>>>>>>        Handle hProv hHash hKey
19620>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
19620>>>>>>>>>>>>>        Boolean bOk
19620>>>>>>>>>>>>>        
19620>>>>>>>>>>>>>        Get AcquireContext to hProv
19621>>>>>>>>>>>>>        If (hProv) Begin
19623>>>>>>>>>>>>>            Get CreateHash hProv to hHash
19624>>>>>>>>>>>>>            If (hHash) Begin
19626>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
19627>>>>>>>>>>>>>                If (bOk) Begin
19629>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
19630>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
19631>>>>>>>>>>>>>                End
19631>>>>>>>>>>>>>>
19631>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
19632>>>>>>>>>>>>>            End
19632>>>>>>>>>>>>>>
19632>>>>>>>>>>>>>            
19632>>>>>>>>>>>>>            If (hKey) Begin
19634>>>>>>>>>>>>>                //  First call to determine resulting data size
19634>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
19635>>>>>>>>>>>>>                Move (Length(sData)) to iCipherLen
19636>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
19637>>>>>>>>>>>>>                
19637>>>>>>>>>>>>>                //  Reserve space in string
19637>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
19639>>>>>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
19640>>>>>>>>>>>>>                End
19640>>>>>>>>>>>>>>
19640>>>>>>>>>>>>>                
19640>>>>>>>>>>>>>                //  Call to really decrypt
19640>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
19641>>>>>>>>>>>>>                //If (not(bOk)) Begin
19641>>>>>>>>>>>>>                //Move "" to sData
19641>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
19641>>>>>>>>>>>>>                //End
19641>>>>>>>>>>>>>                
19641>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
19642>>>>>>>>>>>>>            End 
19642>>>>>>>>>>>>>>
19642>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
19643>>>>>>>>>>>>>        End 
19643>>>>>>>>>>>>>>
19643>>>>>>>>>>>>>        Function_Return sData
19644>>>>>>>>>>>>>    End_Function
19645>>>>>>>>>>>>>    
19645>>>>>>>>>>>>>    // Decrypts data
19645>>>>>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
19647>>>>>>>>>>>>>        Handle hProv hHash hKey
19647>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
19647>>>>>>>>>>>>>        Boolean bOk
19647>>>>>>>>>>>>>        
19647>>>>>>>>>>>>>        Get AcquireContext to hProv
19648>>>>>>>>>>>>>        If (hProv) Begin
19650>>>>>>>>>>>>>            Get CreateHash hProv to hHash
19651>>>>>>>>>>>>>            If (hHash) Begin
19653>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
19654>>>>>>>>>>>>>                If (bOk) Begin
19656>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
19657>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
19658>>>>>>>>>>>>>                End
19658>>>>>>>>>>>>>>
19658>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
19659>>>>>>>>>>>>>            End
19659>>>>>>>>>>>>>>
19659>>>>>>>>>>>>>            
19659>>>>>>>>>>>>>            If (hKey) Begin
19661>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
19662>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
19663>>>>>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
19663>>>>>>>>>>>>>                If (Length(sData) > iDataLen) Begin
19665>>>>>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
19666>>>>>>>>>>>>>                End
19666>>>>>>>>>>>>>>
19666>>>>>>>>>>>>>                
19666>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
19667>>>>>>>>>>>>>            End
19667>>>>>>>>>>>>>>
19667>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
19668>>>>>>>>>>>>>        End
19668>>>>>>>>>>>>>>
19668>>>>>>>>>>>>>        Function_Return sData
19669>>>>>>>>>>>>>    End_Function
19670>>>>>>>>>>>>>    
19670>>>>>>>>>>>>>    //  Generates random data.
19670>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
19672>>>>>>>>>>>>>        Handle hProv
19672>>>>>>>>>>>>>        UChar[] uaResult
19673>>>>>>>>>>>>>        Boolean bRes
19673>>>>>>>>>>>>>        
19673>>>>>>>>>>>>>        Get AcquireContext to hProv
19674>>>>>>>>>>>>>        
19674>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
19675>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
19676>>>>>>>>>>>>>        
19676>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
19677>>>>>>>>>>>>>        
19677>>>>>>>>>>>>>        Function_Return uaResult
19678>>>>>>>>>>>>>    End_Function
19679>>>>>>>>>>>>>    
19679>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
19679>>>>>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
19681>>>>>>>>>>>>>        String sResult
19681>>>>>>>>>>>>>        UChar[] aData
19682>>>>>>>>>>>>>        Address pBase64
19682>>>>>>>>>>>>>        Integer iVoid
19682>>>>>>>>>>>>>        
19682>>>>>>>>>>>>>        Get GenerateRandom iLenght to aData
19683>>>>>>>>>>>>>        
19683>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
19684>>>>>>>>>>>>>        Move pBase64 to sResult
19685>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
19686>>>>>>>>>>>>>        
19686>>>>>>>>>>>>>        Function_Return (Left(sResult, iLenght))
19687>>>>>>>>>>>>>    End_Function
19688>>>>>>>>>>>>>    
19688>>>>>>>>>>>>>End_Class
19689>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\Base64Functions.pkg)
19689>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
19689>>>>>>>>>>>>>//>
19689>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
19689>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
19689>>>>>>>>>>>>>//>
19689>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
19689>>>>>>>>>>>>>//> strings.
19689>>>>>>>>>>>>>//>
19689>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
19689>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
19689>>>>>>>>>>>>>//>
19689>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
19689>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
19689>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
19689>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
19689>>>>>>>>>>>>>
19689>>>>>>>>>>>>>Use VdfBase.pkg
19689>>>>>>>>>>>>>
19689>>>>>>>>>>>>>// Functions in vdfBase64.dll
19689>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
19690>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
19691>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
19692>>>>>>>>>>>>>
19692>>>>>>>>>>>>>// Structure
19692>>>>>>>>>>>>>Struct txxfBase64Buffer
19692>>>>>>>>>>>>>    Pointer pData
19692>>>>>>>>>>>>>    Integer iLength
19692>>>>>>>>>>>>>End_Struct
19692>>>>>>>>>>>>>
19692>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
19692>>>>>>>>>>>>>
19692>>>>>>>>>>>>>Object _oBase64Functions is a cObject
19694>>>>>>>>>>>>>    Move Self to oBase64Functions
19695>>>>>>>>>>>>>
19695>>>>>>>>>>>>>
19695>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
19698>>>>>>>>>>>>>        Address pBase64
19698>>>>>>>>>>>>>        String sResult
19698>>>>>>>>>>>>>        Integer iVoid
19698>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
19699>>>>>>>>>>>>>        Move pBase64 to sResult
19700>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
19701>>>>>>>>>>>>>        Function_Return sResult
19702>>>>>>>>>>>>>    End_Function
19703>>>>>>>>>>>>>
19703>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
19706>>>>>>>>>>>>>        Address pBinary
19706>>>>>>>>>>>>>        String sBinary
19706>>>>>>>>>>>>>        Integer iVoid iLen
19706>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
19707>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
19708>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
19709>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
19710>>>>>>>>>>>>>        Function_Return sBinary
19711>>>>>>>>>>>>>    End_Function
19712>>>>>>>>>>>>>
19712>>>>>>>>>>>>>End_Object
19713>>>>>>>>>>>Use MSSqldrv.pkg
19713>>>>>>>>>>>Use db2_drv.pkg
19713>>>>>>>>>>>Use odbc_drv.pkg
19713>>>>>>>>>>>Use vWin32fh.pkg
19713>>>>>>>>>>>
19713>>>>>>>>>>>Use DUFLanguageConstants.inc
19713>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\MertechDUF.pkg)
19713>>>>>>>>>>>>>//
19713>>>>>>>>>>>>>// Use of Mertech drivers:
19713>>>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
19713>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
19713>>>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
19713>>>>>>>>>>>>>//
#REM DO ~ USE MERTECH.INC
19713>>>>>>>>>>>>>// MySQL Data Types
19713>>>>>>>>>>>>>Define eMySQL_DECIMAL                               for 0
19713>>>>>>>>>>>>>Define eMySQL_TINY                                  for 1
19713>>>>>>>>>>>>>Define eMySQL_SHORT                                 for 2
19713>>>>>>>>>>>>>Define eMySQL_LONG                                  for 3
19713>>>>>>>>>>>>>Define eMySQL_FLOAT                                 for 4
19713>>>>>>>>>>>>>Define eMySQL_DOUBLE                                for 5
19713>>>>>>>>>>>>>Define eMySQL_NULL                                  for 6
19713>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             for 7
19713>>>>>>>>>>>>>Define eMySQL_LONGLONG                              for 8
19713>>>>>>>>>>>>>Define eMySQL_INT24                                 for 9
19713>>>>>>>>>>>>>Define eMySQL_DATE                                  for 10
19713>>>>>>>>>>>>>Define eMySQL_TIME                                  for 11
19713>>>>>>>>>>>>>Define eMySQL_DATETIME                              for 12
19713>>>>>>>>>>>>>Define eMySQL_YEAR                                  for 13
19713>>>>>>>>>>>>>Define eMySQL_NEWDATE                               for 14
19713>>>>>>>>>>>>>Define eMySQL_BIT                                   for 16
19713>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            for 246
19713>>>>>>>>>>>>>Define eMySQL_ENUM                                  for 247
19713>>>>>>>>>>>>>Define eMySQL_SET                                   for 248
19713>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             for 249
19713>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           for 250
19713>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             for 251
19713>>>>>>>>>>>>>Define eMySQL_BLOB                                  for 252
19713>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            for 253
19713>>>>>>>>>>>>>Define eMySQL_STRING                                for 254
19713>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             for -249
19713>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           for -250
19713>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             for -251
19713>>>>>>>>>>>>>Define eMySQL_TEXT                                  for -252
19713>>>>>>>>>>>>>
19713>>>>>>>>>>>>>// Oracle Data Types
19713>>>>>>>>>>>>>Define eOracle_VARCHAR2                             for   1
19713>>>>>>>>>>>>>Define eOracle_NUMBER                               for   2
19713>>>>>>>>>>>>>Define eOracle_INT                                  for   3
19713>>>>>>>>>>>>>Define eOracle_FLOAT                                for   4
19713>>>>>>>>>>>>>Define eOracle_STRING                               for   5
19713>>>>>>>>>>>>>Define eOracle_LONG                                 for   8
19713>>>>>>>>>>>>>Define eOracle_ROWID                                for  11
19713>>>>>>>>>>>>>Define eOracle_DATE                                 for  12
19713>>>>>>>>>>>>>Define eOracle_RAW                                  for  23
19713>>>>>>>>>>>>>Define eOracle_LONGRAW                              for  24
19713>>>>>>>>>>>>>Define eOracle_CHAR                                 for  96
19713>>>>>>>>>>>>>Define eOracle_MSLABEL                              for 106
19713>>>>>>>>>>>>>Define eOracle_CLOB                                 for 112
19713>>>>>>>>>>>>>Define eOracle_BLOB                                 for 113
19713>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            for 187
19713>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          for 188
19713>>>>>>>>>>>>>Define eOracle_INTERVALYM                           for 189
19713>>>>>>>>>>>>>Define eOracle_INTERVALDS                           for 190
19713>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         for 232
19713>>>>>>>>>>>>>Define eOracle_NCHAR                                for 286
19713>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            for 287
19713>>>>>>>>>>>>>Define eOracle_NCLOB                                for 288
19713>>>>>>>>>>>>>
19713>>>>>>>>>>>>>// PostgreSQL Data Types
19713>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                for  718
19713>>>>>>>>>>>>>Define ePgSQL_MONEY                                 for  790
19713>>>>>>>>>>>>>Define ePgSQL_BOOL                                  for   16
19713>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 for   17
19713>>>>>>>>>>>>>Define ePgSQL_CHAR                                  for   18
19713>>>>>>>>>>>>>Define ePgSQL_INT2                                  for   21
19713>>>>>>>>>>>>>Define ePgSQL_INT4                                  for   23
19713>>>>>>>>>>>>>Define ePgSQL_REGPROC                               for   24
19713>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          for 2202
19713>>>>>>>>>>>>>Define ePgSQL_REGOPER                               for 2203
19713>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           for 2204
19713>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              for 2205
19713>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               for 2206
19713>>>>>>>>>>>>>Define ePgSQL_TEXT                                  for   25
19713>>>>>>>>>>>>>Define ePgSQL_CITEXT                                for  -25
19713>>>>>>>>>>>>>Define ePgSQL_OID                                   for   26
19713>>>>>>>>>>>>>Define ePgSQL_TID                                   for   27
19713>>>>>>>>>>>>>Define ePgSQL_XID                                   for   28
19713>>>>>>>>>>>>>Define ePgSQL_CID                                   for   29
19713>>>>>>>>>>>>>Define ePgSQL_XML                                   for  142
19713>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                for 1042
19713>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               for 1043
19713>>>>>>>>>>>>>Define ePgSQL_INT8                                  for   20
19713>>>>>>>>>>>>>Define ePgSQL_PATH                                  for  602
19713>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                for  700
19713>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                for  701
19713>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               for  702
19713>>>>>>>>>>>>>Define ePgSQL_RELTIME                               for  703
19713>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             for  704
19713>>>>>>>>>>>>>Define ePgSQL_POINT                                 for  600
19713>>>>>>>>>>>>>Define ePgSQL_LINE                                  for  628
19713>>>>>>>>>>>>>Define ePgSQL_LSEG                                  for  601
19713>>>>>>>>>>>>>Define ePgSQL_BOX                                   for  603
19713>>>>>>>>>>>>>Define ePgSQL_POLYGON                               for  604
19713>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               for 1033
19713>>>>>>>>>>>>>Define ePgSQL_MACADDR                               for  829
19713>>>>>>>>>>>>>Define ePgSQL_INET                                  for  869
19713>>>>>>>>>>>>>Define ePgSQL_CIDR                                  for  650
19713>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             for 1114
19713>>>>>>>>>>>>>Define ePgSQL_DATE                                  for 1082
19713>>>>>>>>>>>>>Define ePgSQL_TIME                                  for 1083
19713>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           for 1184
19713>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              for 1186
19713>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               for 1700
19713>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                for 1266
19713>>>>>>>>>>>>>Define ePgSQL_BIT                                   for 1560
19713>>>>>>>>>>>>>Define ePgSQL_VARBIT                                for 1562
19713>>>>>>>>>>>>>Define ePgSQL_UUID                                  for 2950
19713>>>>>>>>>>>>>
19713>>>>>>>>>>>>>// SQL Server Data Types
19713>>>>>>>>>>>>>Define eSQLServer_NA                                for    0
19713>>>>>>>>>>>>>Define eSQLServer_CHAR                              for    1
19713>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           for    2
19713>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           for    3
19713>>>>>>>>>>>>>Define eSQLServer_INT                               for    4
19713>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          for    5
19713>>>>>>>>>>>>>Define eSQLServer_FLOAT                             for    6
19713>>>>>>>>>>>>>Define eSQLServer_REAL                              for    7
19713>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            for    8
19713>>>>>>>>>>>>>Define eSQLServer_DATETIME                          for   11
19713>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           for   12
19713>>>>>>>>>>>>>Define eSQLServer_DATE                              for   40
19713>>>>>>>>>>>>>Define eSQLServer_TIME                              for   41
19713>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         for   42
19713>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    for   43
19713>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     for   58
19713>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         for   93
19713>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       for  128
19713>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          for  129
19713>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         for  130
19713>>>>>>>>>>>>>Define eSQLServer_TEXT                              for   -1
19713>>>>>>>>>>>>>Define eSQLServer_BINARY                            for   -2
19713>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         for   -3
19713>>>>>>>>>>>>>Define eSQLServer_IMAGE                             for   -4
19713>>>>>>>>>>>>>Define eSQLServer_BIGINT                            for   -5
19713>>>>>>>>>>>>>Define eSQLServer_TINYINT                           for   -6
19713>>>>>>>>>>>>>Define eSQLServer_BIT                               for   -7
19713>>>>>>>>>>>>>Define eSQLServer_NCHAR                             for   -8
19713>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          for   -9
19713>>>>>>>>>>>>>Define eSQLServer_NTEXT                             for  -10
19713>>>>>>>>>>>>>Define eSQLServer_GUID                              for  -11
19713>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      for  -98
19713>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        for  -99
19713>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       for -100
19713>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        for -150
19713>>>>>>>>>>>>>Define eSQLServer_XML                               for -370
19713>>>>>>>>>>>>>
19713>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
19713>>>>>>>>>>>
19713>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
19713>>>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg
19713>>>>>>>>>>>
19713>>>>>>>>>>>
19713>>>>>>>>>>>    Define SQLFLEX   for "SQL_DRV"
19713>>>>>>>>>>>
19713>>>>>>>>>>>    Define MDSPgSQL  for "MDSPGSQL"
19713>>>>>>>>>>>
19713>>>>>>>>>>>    Define MDSMySQL  for "MDSMYSQL"
19713>>>>>>>>>>>
19713>>>>>>>>>>>    Define MDSDB2    for "MDS_DB2"
19713>>>>>>>>>>>
19713>>>>>>>>>>>    Define ORAFLEX   for "ORA_DRV"
19713>>>>>>>>>>>
19713>>>>>>>>>>>
19713>>>>>>>>>>>// SQLConnection.ini constants:
19713>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
19713>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
19713>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
19713>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
19713>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
19713>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
19713>>>>>>>>>>>
19713>>>>>>>>>>>// DF 19 ini-file settings:
19713>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
19713>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
19713>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
19713>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
19713>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
19713>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
19713>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
19713>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
19713>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
19713>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
19713>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
19713>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
19713>>>>>>>>>>>
19713>>>>>>>>>>>// Database Update Framework extended settings:
19713>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
19713>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
19713>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
19713>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
19713>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
19713>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
19713>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
19713>>>>>>>>>>>
19713>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
19713>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
19713>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
19713>>>>>>>>>>>
19713>>>>>>>>>>>Struct tSQLConnection
19713>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
19713>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
19713>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
19713>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. "MSSQLDRV", "DB2_DRV" or "ODBC_DRV".
19713>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
19713>>>>>>>>>>>    String sDatabase                // 6. SQL Database
19713>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
19713>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
19713>>>>>>>>>>>    String sUserID                  // 9. User ID
19713>>>>>>>>>>>    String sPassword                // 10. Password
19713>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
19713>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
19713>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
19713>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
19713>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
19713>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
19713>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
19713>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
19713>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
19713>>>>>>>>>>>End_Struct
19713>>>>>>>>>
19713>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
19714>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
19716>>>>>>>>>        Handle hoSQLManagerMT
19716>>>>>>>>>
19716>>>>>>>>>        Property String Private.psUseDatabase ""
19717>>>>>>>>>
19717>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
19717>>>>>>>>>        Property Handle  Private.phCurrentTable 0
19718>>>>>>>>>        Property Integer Private.piCurrentField 0
19719>>>>>>>>>
19719>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
19720>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
19721>>>>>>>>>
19721>>>>>>>>>        Property Handle phoSQLManagerMT
19722>>>>>>>>>
19722>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
19723>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
19724>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
19725>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
19726>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
19727>>>>>>>>>
19727>>>>>>>>>        Property Boolean pbHandleQueryErrors True
19728>>>>>>>>>
19728>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
19729>>>>>>>>>        Property String[] paSQLFetchResults
19730>>>>>>>>>
19730>>>>>>>>>        // Error handling
19730>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
19731>>>>>>>>>        Property Boolean pbSqlError False
19732>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
19733>>>>>>>>>        Property Boolean pbProcessingError False
19734>>>>>>>>>
19734>>>>>>>>>        // Statistics on query
19734>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
19735>>>>>>>>>        Property TimeSpan ptsQueryExec
19736>>>>>>>>>        Property TimeSpan ptsFetchResults
19737>>>>>>>>>        Property Integer piColumns 0
19738>>>>>>>>>        Property Integer piRows 0
19739>>>>>>>>>        Property Integer piRowType 0
19740>>>>>>>>>        Property String[] paQueryMessages
19741>>>>>>>>>        Property String psSQLStatementString
19742>>>>>>>>>
19742>>>>>>>>>        Property Integer[] paTableConvertExceptions
19743>>>>>>>>>
19743>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
19744>>>>>>>>>
19744>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
19744>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
19744>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
19744>>>>>>>>>        Property Integer piChunkMax 500
19745>>>>>>>>>
19745>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
19745>>>>>>>>>        Send SetupSQLKeywordArray
19746>>>>>>>>>    End_Procedure
19747>>>>>>>>>
19747>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
19747>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
19749>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
19751>>>>>>>>>            Function_Return (EQ)
19752>>>>>>>>>        End
19752>>>>>>>>>>
19752>>>>>>>>>        Function_Return (GT)
19753>>>>>>>>>    End_Function
19754>>>>>>>>>
19754>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
19754>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
19756>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
19759>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
19762>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
19765>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
19768>>>>>>>>>
19768>>>>>>>>>        Function_Return (EQ)
19769>>>>>>>>>    End_Function
19770>>>>>>>>>
19770>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
19772>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
19772>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
19773>>>>>>>>>        Integer iSize
19773>>>>>>>>>
19773>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
19774>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
19775>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
19776>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
19777>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
19778>>>>>>>>>
19778>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
19779>>>>>>>>>    End_Procedure
19780>>>>>>>>>
19780>>>>>>>>>    // Creates a struct array with all SQL keywords
19780>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
19780>>>>>>>>>    // have slightly different wording.
19780>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
19780>>>>>>>>>    // needs to be done for every keyword group below.
19780>>>>>>>>>    Procedure SetupSQLKeywordArray
19782>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
19782>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
19784>>>>>>>>>
19784>>>>>>>>>        // This should only be called once; but in case it is
19784>>>>>>>>>        // we delete the array first.
19784>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
19785>>>>>>>>>
19785>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
19785>>>>>>>>>        //
19785>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
19786>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
19787>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
19788>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
19789>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
19790>>>>>>>>>
19790>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
19791>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
19792>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
19793>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
19794>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
19795>>>>>>>>>
19795>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
19796>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
19797>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
19798>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
19799>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
19800>>>>>>>>>
19800>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
19801>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
19802>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
19803>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
19804>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
19805>>>>>>>>>
19805>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
19806>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
19807>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
19808>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
19809>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
19810>>>>>>>>>
19810>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
19811>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
19812>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
19813>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
19814>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
19815>>>>>>>>>
19815>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
19816>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
19817>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
19818>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
19819>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
19820>>>>>>>>>
19820>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
19821>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
19822>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
19823>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
19824>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
19825>>>>>>>>>
19825>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
19826>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
19827>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
19828>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
19829>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
19830>>>>>>>>>
19830>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
19831>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
19832>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
19833>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
19834>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
19835>>>>>>>>>
19835>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
19836>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
19837>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
19838>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
19839>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
19840>>>>>>>>>
19840>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
19841>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
19842>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
19843>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
19844>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
19845>>>>>>>>>
19845>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
19846>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
19847>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
19848>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
19849>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
19850>>>>>>>>>
19850>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
19851>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
19852>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
19853>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
19854>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
19855>>>>>>>>>
19855>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
19856>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
19857>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
19858>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
19859>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
19860>>>>>>>>>
19860>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
19861>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
19862>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
19863>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
19864>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
19865>>>>>>>>>
19865>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
19866>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
19867>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
19868>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
19869>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
19870>>>>>>>>>
19870>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
19871>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
19872>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
19873>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
19874>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
19875>>>>>>>>>
19875>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
19876>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
19877>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
19878>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
19879>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
19880>>>>>>>>>
19880>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
19881>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
19882>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
19883>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
19884>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
19885>>>>>>>>>
19885>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
19886>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
19887>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
19888>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
19889>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
19890>>>>>>>>>
19890>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
19891>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
19892>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
19893>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
19894>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
19895>>>>>>>>>
19895>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
19896>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
19897>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
19898>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
19899>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
19900>>>>>>>>>
19900>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
19901>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
19902>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
19903>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
19904>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
19905>>>>>>>>>
19905>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
19906>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
19907>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
19908>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
19909>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
19910>>>>>>>>>
19910>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
19911>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
19912>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
19913>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
19914>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
19915>>>>>>>>>
19915>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
19916>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
19917>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
19918>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
19919>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
19920>>>>>>>>>
19920>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
19921>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
19922>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
19923>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
19924>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
19925>>>>>>>>>
19925>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
19926>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
19927>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
19928>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
19929>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
19930>>>>>>>>>
19930>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
19931>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
19932>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
19933>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
19934>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
19935>>>>>>>>>
19935>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
19936>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
19937>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
19938>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
19939>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
19940>>>>>>>>>
19940>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
19941>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
19942>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
19943>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
19944>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
19945>>>>>>>>>
19945>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
19946>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
19947>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
19948>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
19949>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
19950>>>>>>>>>
19950>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
19951>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
19952>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
19953>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
19954>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
19955>>>>>>>>>
19955>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
19956>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
19957>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
19958>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
19959>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
19960>>>>>>>>>
19960>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
19961>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
19962>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
19963>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
19964>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
19965>>>>>>>>>
19965>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
19966>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
19967>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
19968>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
19969>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
19970>>>>>>>>>
19970>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
19971>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
19972>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
19973>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
19974>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
19975>>>>>>>>>
19975>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
19976>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
19977>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
19978>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
19979>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
19980>>>>>>>>>
19980>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
19981>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
19982>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
19983>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
19984>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
19985>>>>>>>>>
19985>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
19986>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
19987>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
19988>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
19989>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
19990>>>>>>>>>
19990>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
19991>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
19992>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
19993>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
19994>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
19995>>>>>>>>>
19995>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
19996>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
19997>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
19998>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
19999>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
20000>>>>>>>>>
20000>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
20000>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
20001>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
20002>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
20003>>>>>>>>>
20003>>>>>>>>>    End_Procedure
20004>>>>>>>>>
20004>>>>>>>>>End_Class
20005>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cSQLConnectionHandler.pkg)
20005>>>>>>>>>//****************************************************************************
20005>>>>>>>>>// $Module type: Class
20005>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
20005>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
20005>>>>>>>>>// Web-site    : http://www.rdctools.com
20005>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
20005>>>>>>>>>//
20005>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
20005>>>>>>>>>//
20005>>>>>>>>>// $Rev History:
20005>>>>>>>>>//    2015-08-11  Module header created
20005>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
20005>>>>>>>>>//                Added a new structure for passing connection data back & forth.
20005>>>>>>>>>//                Added better error handling.
20005>>>>>>>>>//                Added a decompose message for the connection string.
20005>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
20005>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
20005>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
20005>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
20005>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
20005>>>>>>>>>//****************************************************************************
20005>>>>>>>>>Use cli.pkg
20005>>>>>>>>>Use MSSqldrv.pkg
20005>>>>>>>>>Use db2_drv.pkg
20005>>>>>>>>>Use odbc_drv.pkg
20005>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cSQLConnectionIniFile.pkg)
20005>>>>>>>>>>>//****************************************************************************
20005>>>>>>>>>>>// $Module type: Class
20005>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
20005>>>>>>>>>>>//
20005>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
20005>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
20005>>>>>>>>>>>// E-mail      : support@rdctools.com
20005>>>>>>>>>>>// Web-site    : http://www.rdctools.com
20005>>>>>>>>>>>//
20005>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
20005>>>>>>>>>>>//
20005>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
20005>>>>>>>>>>>//               properties of that object.
20005>>>>>>>>>>>//
20005>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
20005>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
20005>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
20005>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
20005>>>>>>>>>>>// in the help folder for more details.
20005>>>>>>>>>>>//
20005>>>>>>>>>>>Use cSQLConnectionIniFile.inc
20005>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateDatabaseDriver.pkg)
20005>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
20005>>>>>>>>>>>>>
20005>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
20006>>>>>>>>>>>>>    Procedure Construct_Object
20008>>>>>>>>>>>>>        Forward Send Construct_Object
20010>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
20011>>>>>>>>>>>>>    End_Procedure
20012>>>>>>>>>>>>>
20012>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
20014>>>>>>>>>>>>>        String sRetval
20014>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
20016>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
20017>>>>>>>>>>>>>        End                                        
20017>>>>>>>>>>>>>>
20017>>>>>>>>>>>>>        Else Begin
20018>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
20019>>>>>>>>>>>>>        End
20019>>>>>>>>>>>>>>
20019>>>>>>>>>>>>>            
20019>>>>>>>>>>>>>        Function_Return sRetval
20020>>>>>>>>>>>>>    End_Function
20021>>>>>>>>>>>>>
20021>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
20023>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
20023>>>>>>>>>>>>>
20023>>>>>>>>>>>>>        Get psDriverID to sDriverID
20024>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
20025>>>>>>>>>>>>>        Move (sConnect * sServerKeyWord + "=" + sServer) to sConnect
20026>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
20028>>>>>>>>>>>>>            Move "" to sDatabase
20029>>>>>>>>>>>>>        End
20029>>>>>>>>>>>>>>
20029>>>>>>>>>>>>>        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
20031>>>>>>>>>>>>>            Function_Return sConnect
20032>>>>>>>>>>>>>        End
20032>>>>>>>>>>>>>>
20032>>>>>>>>>>>>>
20032>>>>>>>>>>>>>        If (sDatabase <> "") Begin
20034>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
20035>>>>>>>>>>>>>        End
20035>>>>>>>>>>>>>>
20035>>>>>>>>>>>>>        If (bTrusted = True) Begin
20037>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
20038>>>>>>>>>>>>>        End
20038>>>>>>>>>>>>>>
20038>>>>>>>>>>>>>        Else Begin
20039>>>>>>>>>>>>>            Move (sConnect * ";" + CS_SQLIniUIDKeyword + "=" + sUserID * ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
20040>>>>>>>>>>>>>        End
20040>>>>>>>>>>>>>>
20040>>>>>>>>>>>>>        Function_Return sConnect
20041>>>>>>>>>>>>>    End_Function
20042>>>>>>>>>>>>>
20042>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
20044>>>>>>>>>>>>>        Boolean bLoginSuccessful
20044>>>>>>>>>>>>>        String sDriverID
20044>>>>>>>>>>>>>
20044>>>>>>>>>>>>>        Get psDriverID to sDriverID
20045>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
20047>>>>>>>>>>>>>            Function_Return True
20048>>>>>>>>>>>>>        End
20048>>>>>>>>>>>>>>
20048>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
20049>>>>>>>>>>>>>        If (bTrusted = False) Begin
20051>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
20052>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
20054>>>>>>>>>>>>>        End
20054>>>>>>>>>>>>>>
20054>>>>>>>>>>>>>        Else Begin
20055>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
20057>>>>>>>>>>>>>        End
20057>>>>>>>>>>>>>>
20057>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
20058>>>>>>>>>>>>>        Function_Return bLoginSuccessful
20059>>>>>>>>>>>>>    End_Function
20060>>>>>>>>>>>>>End_Class
20061>>>>>>>>>>>>>
20061>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
20062>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
20064>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
20065>>>>>>>>>>>>>    End_Function
20066>>>>>>>>>>>>>End_Class
20067>>>>>>>>>>>>>
20067>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
20068>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
20070>>>>>>>>>>>>>        Boolean bLoginSuccessful
20070>>>>>>>>>>>>>        String sDriverID
20070>>>>>>>>>>>>>
20070>>>>>>>>>>>>>        Get psDriverID to sDriverID
20071>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
20073>>>>>>>>>>>>>            Function_Return True
20074>>>>>>>>>>>>>        End
20074>>>>>>>>>>>>>>
20074>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
20075>>>>>>>>>>>>>        If (bTrusted = False) Begin
20077>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
20079>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
20080>>>>>>>>>>>>>            End
20080>>>>>>>>>>>>>>
20080>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
20083>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
20084>>>>>>>>>>>>>            End
20084>>>>>>>>>>>>>>
20084>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
20086>>>>>>>>>>>>>        End
20086>>>>>>>>>>>>>>
20086>>>>>>>>>>>>>        Else Begin
20087>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
20089>>>>>>>>>>>>>        End
20089>>>>>>>>>>>>>>
20089>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
20090>>>>>>>>>>>>>
20090>>>>>>>>>>>>>        Function_Return bLoginSuccessful
20091>>>>>>>>>>>>>    End_Function
20092>>>>>>>>>>>>>End_Class
20093>>>>>>>>>>>>>
20093>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
20094>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
20096>>>>>>>>>>>>>        Boolean bLoginSuccessful
20096>>>>>>>>>>>>>        String sDriverID
20096>>>>>>>>>>>>>
20096>>>>>>>>>>>>>        Move False to Err
20097>>>>>>>>>>>>>        Get psDriverID to sDriverID
20098>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
20100>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
20101>>>>>>>>>>>>>        End
20101>>>>>>>>>>>>>>
20101>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
20103>>>>>>>>>>>>>
20103>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
20104>>>>>>>>>>>>>        Function_Return bLoginSuccessful
20105>>>>>>>>>>>>>    End_Function
20106>>>>>>>>>>>>>End_Class
20107>>>>>>>>>>>>>
20107>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
20108>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
20110>>>>>>>>>>>>>        Function_Return ""
20111>>>>>>>>>>>>>    End_Function
20112>>>>>>>>>>>>>End_Class
20113>>>>>>>>>>>>>
20113>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
20114>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
20116>>>>>>>>>>>>>        Boolean bLoginSuccessful
20116>>>>>>>>>>>>>        String sDriverID
20116>>>>>>>>>>>>>
20116>>>>>>>>>>>>>        Get psDriverID to sDriverID
20117>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
20117>>>>>>>>>>>>>        Move False to Err
20118>>>>>>>>>>>>>        If (bTrusted = False) Begin
20120>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
20122>>>>>>>>>>>>>        End
20122>>>>>>>>>>>>>>
20122>>>>>>>>>>>>>        Else Begin
20123>>>>>>>>>>>>>            Login sServer "" "" sDriverID
20125>>>>>>>>>>>>>        End
20125>>>>>>>>>>>>>>
20125>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
20126>>>>>>>>>>>>>
20126>>>>>>>>>>>>>        Function_Return bLoginSuccessful
20127>>>>>>>>>>>>>    End_Function
20128>>>>>>>>>>>>>End_Class
20129>>>>>>>>>>>>>
20129>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
20130>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
20132>>>>>>>>>>>>>        Boolean bLoginSuccessful
20132>>>>>>>>>>>>>        String sDriverID
20132>>>>>>>>>>>>>        Integer iPos
20132>>>>>>>>>>>>>
20132>>>>>>>>>>>>>        Get psDriverID to sDriverID
20133>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
20134>>>>>>>>>>>>>        If (iPos = 0) Begin
20136>>>>>>>>>>>>>            If (sDatabase <> "") Begin
20138>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
20139>>>>>>>>>>>>>            End
20139>>>>>>>>>>>>>>
20139>>>>>>>>>>>>>        End
20139>>>>>>>>>>>>>>
20139>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
20139>>>>>>>>>>>>>        Move False to Err
20140>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
20140>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
20142>>>>>>>>>>>>>
20142>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
20143>>>>>>>>>>>>>        Function_Return bLoginSuccessful
20144>>>>>>>>>>>>>    End_Function
20145>>>>>>>>>>>>>End_Class
20146>>>>>>>>>>>>>
20146>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
20147>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
20149>>>>>>>>>>>>>        Boolean bLoginSuccessful
20149>>>>>>>>>>>>>        String sDriverID
20149>>>>>>>>>>>>>
20149>>>>>>>>>>>>>        Get psDriverID to sDriverID
20150>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
20150>>>>>>>>>>>>>        Move False to Err
20151>>>>>>>>>>>>>        If (bTrusted = False) Begin
20153>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
20155>>>>>>>>>>>>>        End
20155>>>>>>>>>>>>>>
20155>>>>>>>>>>>>>        Else Begin
20156>>>>>>>>>>>>>            Login sServer "" "" sDriverID
20158>>>>>>>>>>>>>        End
20158>>>>>>>>>>>>>>
20158>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
20159>>>>>>>>>>>>>        Function_Return bLoginSuccessful
20160>>>>>>>>>>>>>    End_Function
20161>>>>>>>>>>>>>End_Class
20162>>>>>>>>>>>>>
20162>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
20163>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
20165>>>>>>>>>>>>>        Boolean bLoginSuccessful
20165>>>>>>>>>>>>>        String sDriverID
20165>>>>>>>>>>>>>
20165>>>>>>>>>>>>>        Get psDriverID to sDriverID
20166>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
20166>>>>>>>>>>>>>        Move False to Err
20167>>>>>>>>>>>>>        If (bTrusted = False) Begin
20169>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
20171>>>>>>>>>>>>>        End
20171>>>>>>>>>>>>>>
20171>>>>>>>>>>>>>        Else Begin
20172>>>>>>>>>>>>>            Login sServer "" "" sDriverID
20174>>>>>>>>>>>>>        End
20174>>>>>>>>>>>>>>
20174>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
20175>>>>>>>>>>>>>        Function_Return bLoginSuccessful
20176>>>>>>>>>>>>>    End_Function
20177>>>>>>>>>>>>>End_Class
20178>>>>>>>>>>>>>
20178>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
20179>>>>>>>>>>>>>    Procedure Construct_Object
20181>>>>>>>>>>>>>        Forward Send Construct_Object
20183>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
20184>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
20185>>>>>>>>>>>>>    End_Procedure
20186>>>>>>>>>>>>>
20186>>>>>>>>>>>>>    Function CreateDriver Returns Handle
20188>>>>>>>>>>>>>        String sDriverID
20188>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
20188>>>>>>>>>>>>>
20188>>>>>>>>>>>>>        Get psDriverID to sDriverID
20189>>>>>>>>>>>>>        Case Begin
20189>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
20191>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
20192>>>>>>>>>>>>>                Case Break
20193>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
20196>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
20197>>>>>>>>>>>>>                Case Break
20198>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
20201>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
20202>>>>>>>>>>>>>                Case Break
20203>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
20206>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
20207>>>>>>>>>>>>>                Case Break
20208>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
20211>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
20212>>>>>>>>>>>>>                Case Break
20213>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
20216>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
20217>>>>>>>>>>>>>                Case Break
20218>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
20221>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
20222>>>>>>>>>>>>>                Case Break
20223>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
20223>>>>>>>>>>>>>            Case Else
20223>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
20224>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
20225>>>>>>>>>>>>>        Case End
20225>>>>>>>>>>>>>
20225>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
20226>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
20227>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
20228>>>>>>>>>>>>>
20228>>>>>>>>>>>>>        Function_Return hoDriver
20229>>>>>>>>>>>>>    End_Function
20230>>>>>>>>>>>>>
20230>>>>>>>>>>>>>    Procedure DestroyDriver
20232>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
20234>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
20235>>>>>>>>>>>>>        End
20235>>>>>>>>>>>>>>
20235>>>>>>>>>>>>>    End_Procedure
20236>>>>>>>>>>>>>
20236>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
20238>>>>>>>>>>>>>        String sConnect
20238>>>>>>>>>>>>>        Handle hoDriver
20238>>>>>>>>>>>>>
20238>>>>>>>>>>>>>        Get CreateDriver to hoDriver
20239>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
20240>>>>>>>>>>>>>        Send DestroyDriver
20241>>>>>>>>>>>>>        Function_Return sConnect
20242>>>>>>>>>>>>>    End_Function
20243>>>>>>>>>>>>>
20243>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
20245>>>>>>>>>>>>>        Boolean bLoginSuccessful
20245>>>>>>>>>>>>>        Handle hoDriver
20245>>>>>>>>>>>>>
20245>>>>>>>>>>>>>        Get CreateDriver to hoDriver
20246>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
20247>>>>>>>>>>>>>        Send DestroyDriver
20248>>>>>>>>>>>>>        Function_Return bLoginSuccessful
20249>>>>>>>>>>>>>    End_Function
20250>>>>>>>>>>>>>
20250>>>>>>>>>>>>>End_Class
20251>>>>>>>>>>>
20251>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
20252>>>>>>>>>>>    Procedure Construct_Object
20254>>>>>>>>>>>        Forward Send Construct_Object
20256>>>>>>>>>>>
20256>>>>>>>>>>>        Property String Private_psIniFilePath
20257>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
20258>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
20259>>>>>>>>>>>
20259>>>>>>>>>>>//        { Visibility=Private }
20259>>>>>>>>>>>        Property Boolean pbDFConnId False
20260>>>>>>>>>>>
20260>>>>>>>>>>>        // We use Base64 coding instead of the cCryptographer class because the
20260>>>>>>>>>>>        // password will get scrambled while writing/reading to/from the ini-file.
20260>>>>>>>>>>>//        { Visibility=Public }
20260>>>>>>>>>>>//        // *** You really want to change this value! ***
20260>>>>>>>>>>>//        Property String psHashString "zx!2139(LI0+?ips7433"
20260>>>>>>>>>>>
20260>>>>>>>>>>>    End_Procedure
20261>>>>>>>>>>>
20261>>>>>>>>>>>    Procedure End_Construct_Object
20263>>>>>>>>>>>        Forward Send End_Construct_Object
20265>>>>>>>>>>>    End_Procedure
20266>>>>>>>>>>>
20266>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
20268>>>>>>>>>>>        String sIniFile
20268>>>>>>>>>>>        Get vFolderFormat sPath to sPath
20269>>>>>>>>>>>        Set private_psIniFilePath to sPath
20270>>>>>>>>>>>        Get psIniFileName to sIniFile
20271>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
20272>>>>>>>>>>>    End_Procedure
20273>>>>>>>>>>>
20273>>>>>>>>>>>    Function psIniFilePath Returns String
20275>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
20276>>>>>>>>>>>    End_Function
20277>>>>>>>>>>>
20277>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
20279>>>>>>>>>>>        String sPath
20279>>>>>>>>>>>        Get psIniFilePath to sPath
20280>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
20281>>>>>>>>>>>        Set private_psIniFileName to sFileName
20282>>>>>>>>>>>    End_Procedure
20283>>>>>>>>>>>
20283>>>>>>>>>>>    Function psIniFileName Returns String
20285>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
20286>>>>>>>>>>>    End_Function
20287>>>>>>>>>>>
20287>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
20287>>>>>>>>>>>    // Sets a value in the program's ini file (write)
20287>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
20287>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
20289>>>>>>>>>>>        String sIniFile sPath
20289>>>>>>>>>>>
20289>>>>>>>>>>>        Get psIniFilePath to sPath
20290>>>>>>>>>>>        Get psIniFileName to sIniFile
20291>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
20292>>>>>>>>>>>        Set psFileName to sIniFile
20293>>>>>>>>>>>        Send WriteString sSection sValueName sValue
20294>>>>>>>>>>>    End_Procedure
20295>>>>>>>>>>>
20295>>>>>>>>>>>    // Get a value from program's ini-file (read)
20295>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
20295>>>>>>>>>>>    // Returns the value
20295>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
20297>>>>>>>>>>>        String sValue sIniFile sPath
20297>>>>>>>>>>>
20297>>>>>>>>>>>        Get psIniFilePath to sPath
20298>>>>>>>>>>>        Get psIniFileName to sIniFile
20299>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
20300>>>>>>>>>>>        Set psFileName to sIniFile
20301>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
20302>>>>>>>>>>>
20302>>>>>>>>>>>        Function_Return sValue
20303>>>>>>>>>>>    End_Function
20304>>>>>>>>>>>
20304>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
20304>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
20306>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
20309>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
20312>>>>>>>>>>>
20312>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
20315>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
20318>>>>>>>>>>>
20318>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
20321>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
20324>>>>>>>>>>>
20324>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
20327>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
20330>>>>>>>>>>>
20330>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
20333>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
20336>>>>>>>>>>>
20336>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
20339>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
20342>>>>>>>>>>>
20342>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
20345>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
20348>>>>>>>>>>>
20348>>>>>>>>>>>        Function_Return (EQ)
20349>>>>>>>>>>>    End_Function
20350>>>>>>>>>>>
20350>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
20352>>>>>>>>>>>        Handle hoSections
20352>>>>>>>>>>>        Integer iItems
20352>>>>>>>>>>>
20352>>>>>>>>>>>        Send ReadSections hoSections
20353>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
20354>>>>>>>>>>>        Function_Return iItems
20355>>>>>>>>>>>    End_Function
20356>>>>>>>>>>>
20356>>>>>>>>>>>    // The normal connection string looks something like this;
20356>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
20356>>>>>>>>>>>    // ...but the full connection string looks like this;
20356>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
20356>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
20356>>>>>>>>>>>//        String sSection
20356>>>>>>>>>>>//        Integer iCount
20356>>>>>>>>>>>//
20356>>>>>>>>>>>//        Move False to Err
20356>>>>>>>>>>>//        Get psIniSectionName to sSection
20356>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
20356>>>>>>>>>>>//        Increment iCount
20356>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
20356>>>>>>>>>>>//
20356>>>>>>>>>>>//        Function_Return (Err = False)
20356>>>>>>>>>>>//    End_Function
20356>>>>>>>>>>>
20356>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
20358>>>>>>>>>>>        Integer iCount
20358>>>>>>>>>>>        Boolean bExists
20358>>>>>>>>>>>        String sSection
20358>>>>>>>>>>>
20358>>>>>>>>>>>        Move False to Err
20359>>>>>>>>>>>        Move 1 to iCount
20360>>>>>>>>>>>        Get psIniSectionName to sSection
20361>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
20362>>>>>>>>>>>        While (bExists = True)
20366>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
20367>>>>>>>>>>>            Increment iCount
20368>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
20369>>>>>>>>>>>        Loop
20370>>>>>>>>>>>>
20370>>>>>>>>>>>        Function_Return (Err = False)
20371>>>>>>>>>>>    End_Function
20372>>>>>>>>>>>
20372>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
20374>>>>>>>>>>>        Integer iCount
20374>>>>>>>>>>>        String sSection
20374>>>>>>>>>>>        Boolean bExists
20374>>>>>>>>>>>
20374>>>>>>>>>>>        Move False to Err
20375>>>>>>>>>>>        Move 1 to iCount
20376>>>>>>>>>>>        Get psIniSectionName to sSection
20377>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
20378>>>>>>>>>>>        While (bExists = True)
20382>>>>>>>>>>>            If (iCount = iItem) Begin
20384>>>>>>>>>>>                Send DeleteSection sSection
20385>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
20385>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
20386>>>>>>>>>>>            End
20386>>>>>>>>>>>>
20386>>>>>>>>>>>            Increment iCount
20387>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
20388>>>>>>>>>>>        Loop
20389>>>>>>>>>>>>
20389>>>>>>>>>>>
20389>>>>>>>>>>>        Function_Return (Err = False)
20390>>>>>>>>>>>    End_Function
20391>>>>>>>>>>>
20391>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
20391>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
20391>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
20393>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20393>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20394>>>>>>>>>>>        tSQLConnection   SQLConnection
20394>>>>>>>>>>>        tSQLConnection   SQLConnection
20394>>>>>>>>>>>        Integer iIndex
20394>>>>>>>>>>>
20394>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
20395>>>>>>>>>>>        If (iIndex = -1) Begin
20397>>>>>>>>>>>            Move True to SQLConnection.bError
20398>>>>>>>>>>>            Function_Return SQLConnection
20399>>>>>>>>>>>        End
20399>>>>>>>>>>>>
20399>>>>>>>>>>>
20399>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
20400>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
20401>>>>>>>>>>>
20401>>>>>>>>>>>        Function_Return SQLConnection
20402>>>>>>>>>>>    End_Function
20403>>>>>>>>>>>
20403>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
20403>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
20405>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20405>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20406>>>>>>>>>>>        Integer iRetval iCount iSize
20406>>>>>>>>>>>        String sValue
20406>>>>>>>>>>>        Boolean bExists
20406>>>>>>>>>>>
20406>>>>>>>>>>>        Move -1 to iRetval
20407>>>>>>>>>>>
20407>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
20408>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
20409>>>>>>>>>>>        Decrement iSize
20410>>>>>>>>>>>        For iCount from 0 to iSize
20416>>>>>>>>>>>>
20416>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
20417>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
20418>>>>>>>>>>>            If (bExists) Begin
20420>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
20421>>>>>>>>>>>                Move iSize to iCount         // We're done!
20422>>>>>>>>>>>            End
20422>>>>>>>>>>>>
20422>>>>>>>>>>>        Loop
20423>>>>>>>>>>>>
20423>>>>>>>>>>>
20423>>>>>>>>>>>        Function_Return iRetval
20424>>>>>>>>>>>    End_Function
20425>>>>>>>>>>>
20425>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
20425>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
20425>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
20427>>>>>>>>>>>        Integer iCount iSize iItems
20427>>>>>>>>>>>        String sValue
20427>>>>>>>>>>>        Boolean bExists
20427>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20427>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20428>>>>>>>>>>>
20428>>>>>>>>>>>        Move 0 to iItems
20429>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
20430>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
20431>>>>>>>>>>>        Decrement iSize
20432>>>>>>>>>>>        For iCount from 0 to iSize
20438>>>>>>>>>>>>
20438>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
20439>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
20440>>>>>>>>>>>            If (bExists) Begin
20442>>>>>>>>>>>                Increment iItems
20443>>>>>>>>>>>            End
20443>>>>>>>>>>>>
20443>>>>>>>>>>>        Loop
20444>>>>>>>>>>>>
20444>>>>>>>>>>>
20444>>>>>>>>>>>        Function_Return (iItems > 1)
20445>>>>>>>>>>>    End_Function
20446>>>>>>>>>>>
20446>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
20446>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
20448>>>>>>>>>>>        Boolean bOK
20448>>>>>>>>>>>        Integer iSize iCount
20448>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20448>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20449>>>>>>>>>>>        tSQLConnection SQLConnection
20449>>>>>>>>>>>        tSQLConnection SQLConnection
20449>>>>>>>>>>>        String sConnectionString
20449>>>>>>>>>>>
20449>>>>>>>>>>>        Move False to Err
20450>>>>>>>>>>>        Get psConnectionString to sConnectionString
20451>>>>>>>>>>>
20451>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
20452>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
20453>>>>>>>>>>>        Decrement iSize
20454>>>>>>>>>>>        // Set all current connection to inactive.
20454>>>>>>>>>>>        For iCount from 0 to iSize
20460>>>>>>>>>>>>
20460>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
20461>>>>>>>>>>>        Loop
20462>>>>>>>>>>>>
20462>>>>>>>>>>>
20462>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
20463>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
20464>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
20465>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
20466>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
20467>>>>>>>>>>>
20467>>>>>>>>>>>        Function_Return (bOK = True)
20468>>>>>>>>>>>    End_Function
20469>>>>>>>>>>>
20469>>>>>>>>>>>    // Used for updating an existing connection with new data.
20469>>>>>>>>>>>    // Returns True if successful.
20469>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
20471>>>>>>>>>>>        Boolean bOK
20471>>>>>>>>>>>        Integer iItem iSize iCount
20471>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20471>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20472>>>>>>>>>>>
20472>>>>>>>>>>>        Move False to Err
20473>>>>>>>>>>>        Move -1 to iItem
20474>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
20475>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
20476>>>>>>>>>>>        Decrement iSize
20477>>>>>>>>>>>        // Set all current connection to inactive.
20477>>>>>>>>>>>        For iCount from 0 to iSize
20483>>>>>>>>>>>>
20483>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
20484>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
20486>>>>>>>>>>>                Move iCount to iItem
20487>>>>>>>>>>>            End
20487>>>>>>>>>>>>
20487>>>>>>>>>>>        Loop
20488>>>>>>>>>>>>
20488>>>>>>>>>>>
20488>>>>>>>>>>>        If (iItem <> -1) Begin
20490>>>>>>>>>>>            Move True to SQLConnection.bEnabled
20491>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
20492>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
20493>>>>>>>>>>>        End
20493>>>>>>>>>>>>
20493>>>>>>>>>>>
20493>>>>>>>>>>>        Function_Return (bOK = True)
20494>>>>>>>>>>>    End_Function
20495>>>>>>>>>>>
20495>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
20497>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20497>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
20498>>>>>>>>>>>        String sSection sValue
20498>>>>>>>>>>>        Integer iCount
20498>>>>>>>>>>>        Boolean bExists bEnabled
20498>>>>>>>>>>>
20498>>>>>>>>>>>        Get psIniSectionName to sSection
20499>>>>>>>>>>>        Get SectionExists sSection to bExists
20500>>>>>>>>>>>        If (bExists = False) Begin
20502>>>>>>>>>>>            Function_Return SQLConnectionsArray
20503>>>>>>>>>>>        End
20503>>>>>>>>>>>>
20503>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
20504>>>>>>>>>>>        If (bExists = True) Begin
20506>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
20507>>>>>>>>>>>>
20507>>>>>>>>>>>        End
20507>>>>>>>>>>>>
20507>>>>>>>>>>>
20507>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
20508>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
20509>>>>>>>>>>>
20509>>>>>>>>>>>        While (bExists = True)                 
20513>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
20513>>>>>>>>>>>            // We always put the enabled/active connection at the top
20513>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
20513>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
20513>>>>>>>>>>>
20513>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
20514>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
20515>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
20516>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
20517>>>>>>>>>>>
20517>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
20517>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
20518>>>>>>>>>>>            If (sValue = "99") Begin
20520>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
20521>>>>>>>>>>>            End
20521>>>>>>>>>>>>
20521>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
20522>>>>>>>>>>>
20522>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
20523>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
20524>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
20526>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
20527>>>>>>>>>>>            End
20527>>>>>>>>>>>>
20527>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
20529>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
20530>>>>>>>>>>>            End
20530>>>>>>>>>>>>
20530>>>>>>>>>>>
20530>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
20531>>>>>>>>>>>
20531>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
20532>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
20533>>>>>>>>>>>
20533>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
20534>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
20535>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
20537>>>>>>>>>>>                Get DecryptPassword sValue to sValue
20538>>>>>>>>>>>            End
20538>>>>>>>>>>>>
20538>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
20539>>>>>>>>>>>
20539>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
20539>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
20540>>>>>>>>>>>
20540>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
20541>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
20542>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
20543>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
20544>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
20545>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
20546>>>>>>>>>>>//            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword        ""     to SQLConnectionsArray[iCount].bDisabled
20546>>>>>>>>>>>
20546>>>>>>>>>>>            Increment iCount
20547>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
20548>>>>>>>>>>>        Loop
20549>>>>>>>>>>>>
20549>>>>>>>>>>>
20549>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
20549>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
20551>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
20552>>>>>>>>>>>        End
20552>>>>>>>>>>>>
20552>>>>>>>>>>>
20552>>>>>>>>>>>        Function_Return SQLConnectionsArray
20553>>>>>>>>>>>    End_Function
20554>>>>>>>>>>>
20554>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
20556>>>>>>>>>>>        Integer iCount iSize
20556>>>>>>>>>>>        Boolean bOK
20556>>>>>>>>>>>        String sConnectionString sSection sValue
20556>>>>>>>>>>>
20556>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
20556>>>>>>>>>>>        Move 0 to iCount
20557>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
20558>>>>>>>>>>>        If (bOK = False) Begin
20560>>>>>>>>>>>            Function_Return False
20561>>>>>>>>>>>        End
20561>>>>>>>>>>>>
20561>>>>>>>>>>>
20561>>>>>>>>>>>        Move False to Err
20562>>>>>>>>>>>        Get psIniSectionName to sSection
20563>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
20563>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
20564>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
20565>>>>>>>>>>>        Decrement iSize
20566>>>>>>>>>>>
20566>>>>>>>>>>>        For iCount from 0 to iSize
20572>>>>>>>>>>>>
20572>>>>>>>>>>>            // DF 19 compatible settings:
20572>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
20573>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
20574>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
20575>>>>>>>>>>>            
20575>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
20576>>>>>>>>>>>
20576>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
20577>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
20579>>>>>>>>>>>                Get EncryptPassword sValue to sValue
20580>>>>>>>>>>>            End
20580>>>>>>>>>>>>
20580>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
20581>>>>>>>>>>>
20581>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
20583>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
20584>>>>>>>>>>>            End
20584>>>>>>>>>>>>
20584>>>>>>>>>>>
20584>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
20585>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
20586>>>>>>>>>>>
20586>>>>>>>>>>>            // The Database Update Framework extended settings:
20586>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
20587>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
20588>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
20589>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
20590>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
20591>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
20592>>>>>>>>>>>        Loop
20593>>>>>>>>>>>>
20593>>>>>>>>>>>
20593>>>>>>>>>>>        Function_Return (bOK and Err = False)
20594>>>>>>>>>>>    End_Function
20595>>>>>>>>>>>
20595>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
20595>>>>>>>>>>>    //
20595>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
20595>>>>>>>>>>>    // corresponding to the passed iDbType.
20595>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
20597>>>>>>>>>>>        String sRetval
20597>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
20599>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
20600>>>>>>>>>>>        End
20600>>>>>>>>>>>>
20600>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
20602>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
20603>>>>>>>>>>>        End
20603>>>>>>>>>>>>
20603>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
20605>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
20606>>>>>>>>>>>        End
20606>>>>>>>>>>>>
20606>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
20608>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
20609>>>>>>>>>>>        End
20609>>>>>>>>>>>>
20609>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
20611>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
20612>>>>>>>>>>>        End
20612>>>>>>>>>>>>
20612>>>>>>>>>>>        Function_Return sRetval
20613>>>>>>>>>>>    End_Function
20614>>>>>>>>>>>
20614>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
20614>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
20614>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
20616>>>>>>>>>>>        Integer iRetval
20616>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
20618>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
20619>>>>>>>>>>>        End
20619>>>>>>>>>>>>
20619>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
20621>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
20622>>>>>>>>>>>        End
20622>>>>>>>>>>>>
20622>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
20624>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
20625>>>>>>>>>>>        End
20625>>>>>>>>>>>>
20625>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
20627>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
20628>>>>>>>>>>>        End
20628>>>>>>>>>>>>
20628>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
20630>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
20631>>>>>>>>>>>        End
20631>>>>>>>>>>>>
20631>>>>>>>>>>>        Function_Return iRetval
20632>>>>>>>>>>>    End_Function
20633>>>>>>>>>>>
20633>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
20633>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
20633>>>>>>>>>>>    // the SQL Connection program's grid.
20633>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
20635>>>>>>>>>>>        String sRetval
20635>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
20637>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
20638>>>>>>>>>>>        End
20638>>>>>>>>>>>>
20638>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
20640>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
20641>>>>>>>>>>>        End
20641>>>>>>>>>>>>
20641>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
20643>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
20644>>>>>>>>>>>        End
20644>>>>>>>>>>>>
20644>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
20646>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
20647>>>>>>>>>>>        End
20647>>>>>>>>>>>>
20647>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
20649>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
20650>>>>>>>>>>>        End
20650>>>>>>>>>>>>
20650>>>>>>>>>>>        Function_Return sRetval
20651>>>>>>>>>>>    End_Function
20652>>>>>>>>>>>
20652>>>>>>>>>>>    // Pass a driver id and the function will return
20652>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
20652>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
20652>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
20654>>>>>>>>>>>        Integer iRetval
20654>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
20656>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
20657>>>>>>>>>>>        End
20657>>>>>>>>>>>>
20657>>>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
20659>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
20660>>>>>>>>>>>        End
20660>>>>>>>>>>>>
20660>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
20662>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
20663>>>>>>>>>>>        End
20663>>>>>>>>>>>>
20663>>>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
20665>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
20666>>>>>>>>>>>        End
20666>>>>>>>>>>>>
20666>>>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
20668>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
20669>>>>>>>>>>>        End
20669>>>>>>>>>>>>
20669>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
20671>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
20672>>>>>>>>>>>        End
20672>>>>>>>>>>>>
20672>>>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
20674>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
20675>>>>>>>>>>>        End
20675>>>>>>>>>>>>
20675>>>>>>>>>>>        Function_Return iRetval
20676>>>>>>>>>>>    End_Function
20677>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
20677>>>>>>>>>>>>
20677>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
20679>>>>>>>>>>>>    Integer iStart iEnd
20679>>>>>>>>>>>>    String sRetval
20679>>>>>>>>>>>>
20679>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
20680>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
20681>>>>>>>>>>>>    If (iStart = 0) Begin
20683>>>>>>>>>>>>        Function_Return ""
20684>>>>>>>>>>>>    End
20684>>>>>>>>>>>>>
20684>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
20685>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
20686>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
20688>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
20689>>>>>>>>>>>>    End
20689>>>>>>>>>>>>>
20689>>>>>>>>>>>>    Else Begin
20690>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
20691>>>>>>>>>>>>    End
20691>>>>>>>>>>>>>
20691>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
20693>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
20694>>>>>>>>>>>>        Decrement iEnd
20695>>>>>>>>>>>>    End
20695>>>>>>>>>>>>>
20695>>>>>>>>>>>>    If (iEnd <> 0) Begin
20697>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
20698>>>>>>>>>>>>    End
20698>>>>>>>>>>>>>
20698>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
20699>>>>>>>>>>>>
20699>>>>>>>>>>>>    Function_Return (Trim(sRetval))
20700>>>>>>>>>>>>End_Function
20701>>>>>>>>>>>>
20701>>>>>>>>>>>>
20701>>>>>>>>>>>
20701>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
20703>>>>>>>>>>>        String sConnect
20703>>>>>>>>>>>        Handle hoDriver
20703>>>>>>>>>>>
20703>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
20704>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
20705>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
20706>>>>>>>>>>>        Send Destroy of hoDriver
20707>>>>>>>>>>>
20707>>>>>>>>>>>        Function_Return sConnect
20708>>>>>>>>>>>    End_Function
20709>>>>>>>>>>>
20709>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
20709>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
20711>>>>>>>>>>>        String sConnect
20711>>>>>>>>>>>
20711>>>>>>>>>>>        Case Begin
20711>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
20713>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
20714>>>>>>>>>>>                If (sDatabase <> "") Begin
20716>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
20717>>>>>>>>>>>                End
20717>>>>>>>>>>>>
20717>>>>>>>>>>>                Case Break
20718>>>>>>>>>>>
20718>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
20721>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
20723>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
20724>>>>>>>>>>>                End
20724>>>>>>>>>>>>
20724>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
20727>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
20728>>>>>>>>>>>                End
20728>>>>>>>>>>>>
20728>>>>>>>>>>>
20728>>>>>>>>>>>                If (sDatabase <> "") Begin
20730>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
20731>>>>>>>>>>>                End
20731>>>>>>>>>>>>
20731>>>>>>>>>>>                Case Break
20732>>>>>>>>>>>
20732>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
20735>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
20736>>>>>>>>>>>                If (sDatabase <> "") Begin
20738>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
20739>>>>>>>>>>>                End
20739>>>>>>>>>>>>
20739>>>>>>>>>>>                Case Break
20740>>>>>>>>>>>
20740>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
20743>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
20744>>>>>>>>>>>                If (sDatabase <> "") Begin
20746>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
20747>>>>>>>>>>>                End
20747>>>>>>>>>>>>
20747>>>>>>>>>>>                Case Break
20748>>>>>>>>>>>
20748>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
20751>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
20752>>>>>>>>>>>                If (sDatabase <> "") Begin
20754>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
20755>>>>>>>>>>>                End
20755>>>>>>>>>>>>
20755>>>>>>>>>>>                Case Break
20756>>>>>>>>>>>
20756>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
20759>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
20760>>>>>>>>>>>                If (sDatabase <> "") Begin
20762>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
20763>>>>>>>>>>>                End
20763>>>>>>>>>>>>
20763>>>>>>>>>>>                Case Break
20764>>>>>>>>>>>
20764>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
20767>>>>>>>>>>>                Break
20768>>>>>>>>>>>
20768>>>>>>>>>>>            Case Else
20768>>>>>>>>>>>                Move "" to sConnect
20769>>>>>>>>>>>        Case End
20769>>>>>>>>>>>
20769>>>>>>>>>>>        Function_Return sConnect
20770>>>>>>>>>>>    End_Function
20771>>>>>>>>>>>
20771>>>>>>>>>>>    // Use Base64
20771>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
20773>>>>>>>>>>>        String sRetval
20773>>>>>>>>>>>//        Handle hoCryptographer
20773>>>>>>>>>>>//
20773>>>>>>>>>>>//        Get psHashString to sHashString
20773>>>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
20773>>>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
20773>>>>>>>>>>>//        Get Encrypt of hoCryptographer sHashString sPassword to sRetval
20773>>>>>>>>>>>//
20773>>>>>>>>>>>//        Send Destroy of hoCryptographer
20773>>>>>>>>>>>          Get EncodeString of oBase64Functions sPassword to sRetval
20774>>>>>>>>>>>        Function_Return sRetval
20775>>>>>>>>>>>    End_Function
20776>>>>>>>>>>>
20776>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
20778>>>>>>>>>>>        String sRetval
20778>>>>>>>>>>>//        Handle hoCryptographer
20778>>>>>>>>>>>//
20778>>>>>>>>>>>//        Get psHashString to sHashString
20778>>>>>>>>>>>//        Get Create (RefClass(cCryptographer)) to hoCryptographer
20778>>>>>>>>>>>//        Set psProvider of hoCryptographer to MS_ENHANCED_PROV
20778>>>>>>>>>>>//        Get Decrypt of hoCryptographer sHashString sPassword to sRetval
20778>>>>>>>>>>>//
20778>>>>>>>>>>>//        Send Destroy of hoCryptographer
20778>>>>>>>>>>>          Get DecodeString of oBase64Functions sPassword to sRetval
20779>>>>>>>>>>>
20779>>>>>>>>>>>        Function_Return sRetval
20780>>>>>>>>>>>    End_Function
20781>>>>>>>>>>>
20781>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
20781>>>>>>>>>>>    Function ApplicationPath Returns String
20783>>>>>>>>>>>        String sApplicationFileName sPath
20783>>>>>>>>>>>        Integer iNumChars iRetval
20783>>>>>>>>>>>
20783>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
20784>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
20785>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
20786>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
20787>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
20788>>>>>>>>>>>
20788>>>>>>>>>>>        Function_Return sPath
20789>>>>>>>>>>>    End_Function
20790>>>>>>>>>>>
20790>>>>>>>>>>>End_Class
20791>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
20791>>>>>>>>>
20791>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
20791>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
20791>>>>>>>>>    Use cConnectionDUF.pkg
Including file: cConnectionDUF.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cConnectionDUF.pkg)
20791>>>>>>>>>>>// * Dummy class * that will only be used if DF 18.2 or less.
20791>>>>>>>>>>>//
20791>>>>>>>>>>>// The cConnection class is new to DF 19 and that DF 19 package/class
20791>>>>>>>>>>>// will be used automatically instead of this package
20791>>>>>>>>>>>// if the current DF version is 19 and up _and_ the class
20791>>>>>>>>>>>// has been instantianted in the cApplication object.
20791>>>>>>>>>>>//
20791>>>>>>>>>>>// If an object of the original cConnection class is placed in
20791>>>>>>>>>>>// the cApplication, that connection logic will be used instead
20791>>>>>>>>>>>// of the Database Update Framework's SQLConnections logic. Or more
20791>>>>>>>>>>>// correctly; "Managed Connection" settings will be read and applied
20791>>>>>>>>>>>// instead of those defined in the framework's SQLConnections.ini file.
20791>>>>>>>>>>>//
20791>>>>>>>>>>>Struct tConnection
20791>>>>>>>>>>>    String sId                // connection id
20791>>>>>>>>>>>    String sString            // server-string as added via the ini file
20791>>>>>>>>>>>    String sUID               // User Id
20791>>>>>>>>>>>    String sPWD               // non-encrypted password
20791>>>>>>>>>>>    Boolean bTrustedConnection // Trusted connection
20791>>>>>>>>>>>    Integer iOptions          // connection ID options (don't use)
20791>>>>>>>>>>>    String sDriver            // name of driver
20791>>>>>>>>>>>    Integer iDriverIndex      // loaded driver index (is 1 based, 0 if none)
20791>>>>>>>>>>>    String sConnectionString  // Full connection string assembled from various strings
20791>>>>>>>>>>>    String sSection           // this is usually the section name as it appears
20791>>>>>>>>>>>                              // in the connections ini file (e.g., [Connection1])
20791>>>>>>>>>>>    Boolean bDisabled         // if set, this is not an active Id
20791>>>>>>>>>>>End_Struct
20791>>>>>>>>>>>
20791>>>>>>>>>>>
20791>>>>>>>>>>>Class cConnection is a cObject
20792>>>>>>>>>>>
20792>>>>>>>>>>>    Procedure Construct_Object
20794>>>>>>>>>>>        Forward Send Construct_Object
20796>>>>>>>>>>>
20796>>>>>>>>>>>    End_Procedure
20797>>>>>>>>>>>
20797>>>>>>>>>>>    Function ConnectionIdInfo Returns tConnection
20799>>>>>>>>>>>        tConnection Connection
20799>>>>>>>>>>>        tConnection Connection
20799>>>>>>>>>>>        Function_Return Connection
20800>>>>>>>>>>>    End_Function
20801>>>>>>>>>>>
20801>>>>>>>>>>>    Function IsConnectionIdLoggedIn Returns Boolean
20803>>>>>>>>>>>        Function_Return False
20804>>>>>>>>>>>    End_Function
20805>>>>>>>>>>>
20805>>>>>>>>>>>    Function LoginConnectionId Returns String
20807>>>>>>>>>>>        Function_Return ""
20808>>>>>>>>>>>    End_Function
20809>>>>>>>>>>>
20809>>>>>>>>>>>    // get array of managed connections across all drivers
20809>>>>>>>>>>>    // returns array of connections in tConnection.
20809>>>>>>>>>>>    Function ConnectionIDs Returns tConnection[]
20811>>>>>>>>>>>        tConnection[] Connections
20811>>>>>>>>>>>        tConnection[] Connections
20812>>>>>>>>>>>        Function_Return Connections
20813>>>>>>>>>>>    End_Function
20814>>>>>>>>>>>
20814>>>>>>>>>>>    Function ConnectionIdIndex String sConnectionID Returns Integer
20816>>>>>>>>>>>        Function_Return 0
20817>>>>>>>>>>>    End_Function
20818>>>>>>>>>>>
20818>>>>>>>>>>>    Function RedirectConnectionId String sConnectionID String sServer String sUserId String sPw Boolean bTrusted Boolean bKeepOpen Returns Boolean
20820>>>>>>>>>>>        Function_Return False
20821>>>>>>>>>>>    End_Function
20822>>>>>>>>>>>
20822>>>>>>>>>>>End_Class
20823>>>>>>>>>
20823>>>>>>>>>// We're making references to this object handle so we need it defined
20823>>>>>>>>>// here as well as for the cDbUpdateHandler class
20823>>>>>>>>>
20823>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
20823>>>>>>>>>
20823>>>>>>>>>Class cSQLConnectionHandler is a cObject
20824>>>>>>>>>
20824>>>>>>>>>    Procedure Construct_Object
20826>>>>>>>>>        Forward Send Construct_Object
20828>>>>>>>>>        Move Self to ghoSQLConnectionHandler
20829>>>>>>>>>
20829>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
20830>>>>>>>>>
20830>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
20830>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
20830>>>>>>>>>        // methods to this class.
20830>>>>>>>>>        Property Boolean pbUseConnectionID True
20831>>>>>>>>>        Property Boolean pbToANSI          True
20832>>>>>>>>>        Property Boolean pbRecnum          True
20833>>>>>>>>>        Property Boolean pbCopyData        True
20834>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
20835>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
20836>>>>>>>>>        Property Boolean pbCompareIndexAscending False
20837>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
20838>>>>>>>>>
20838>>>>>>>>>        // Driver default value settings:
20838>>>>>>>>>        // Note: When the object is created the corresponding values
20838>>>>>>>>>        // from the driver .int files are read.
20838>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
20838>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
20839>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
20840>>>>>>>>>        Property String psDriverDefaultValueDate     ""
20841>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
20842>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
20843>>>>>>>>>        Property String psDriverDefaultValueText     ""
20844>>>>>>>>>
20844>>>>>>>>>        // Driver "nullability" settings:
20844>>>>>>>>>        // Note: When the object is created the corresponding values
20844>>>>>>>>>        // from the driver .int files are read.
20844>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
20844>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
20845>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
20846>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
20847>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
20848>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
20849>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
20850>>>>>>>>>
20850>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
20850>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
20850>>>>>>>>>        //     driver interfaces.
20850>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
20850>>>>>>>>>        //     of the struct they are all routed throu this struct property.
20850>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
20851>>>>>>>>>
20851>>>>>>>>>    End_Procedure
20852>>>>>>>>>
20852>>>>>>>>>    Procedure End_Construct_Object
20854>>>>>>>>>        Boolean bReadSettings
20854>>>>>>>>>        tSQLConnection SQLConnection
20854>>>>>>>>>        tSQLConnection SQLConnection
20854>>>>>>>>>
20854>>>>>>>>>        Forward Send End_Construct_Object
20856>>>>>>>>>
20856>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
20856>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
20857>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
20858>>>>>>>>>    End_Procedure
20859>>>>>>>>>
20859>>>>>>>>>    // *** Properties ***
20859>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
20859>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
20859>>>>>>>>>    // merely here for conveniance.
20859>>>>>>>>>    //
20859>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
20859>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
20859>>>>>>>>>    // This struct property contains all the connection data.
20859>>>>>>>>>    //
20859>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
20861>>>>>>>>>        Boolean bIsDaw bOK
20861>>>>>>>>>
20861>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
20862>>>>>>>>>
20862>>>>>>>>>        // When starting a program we might not have a connection id yet:
20862>>>>>>>>>        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
20864>>>>>>>>>            Procedure_Return
20865>>>>>>>>>        End
20865>>>>>>>>>>
20865>>>>>>>>>
20865>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
20865>>>>>>>>>        // be logged in already and don't want to do it again.
20865>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
20867>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
20867>>>>>>>>>            // driver interfaces about the change & make a new login.
20867>>>>>>>>>            Get SQLLogin SQLConnection to bOK
20868>>>>>>>>>            If (bOK = False) Begin
20870>>>>>>>>>                Error DFERR_PROGRAM "Login error."
20871>>>>>>>>>>
20871>>>>>>>>>            End
20871>>>>>>>>>>
20871>>>>>>>>>        End
20871>>>>>>>>>>
20871>>>>>>>>>
20871>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
20871>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
20872>>>>>>>>>
20872>>>>>>>>>    End_Procedure
20873>>>>>>>>>
20873>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
20873>>>>>>>>>    // attempt to load the driver.
20873>>>>>>>>>    // Returns true if the passed driver is SQL based.
20873>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
20875>>>>>>>>>        Boolean bOK
20875>>>>>>>>>
20875>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
20876>>>>>>>>>        If (bOK = False) Begin
20878>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
20879>>>>>>>>>        End
20879>>>>>>>>>>
20879>>>>>>>>>
20879>>>>>>>>>        Function_Return bOK
20880>>>>>>>>>    End_Function
20881>>>>>>>>>
20881>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
20881>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
20883>>>>>>>>>        String sAttributeValue
20883>>>>>>>>>        Integer iDriverID
20883>>>>>>>>>        Boolean bNULL bSQLDriver
20883>>>>>>>>>
20883>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
20884>>>>>>>>>        If (bSQLDriver = False) Begin
20886>>>>>>>>>            Procedure_Return
20887>>>>>>>>>        End
20887>>>>>>>>>>
20887>>>>>>>>>
20887>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
20888>>>>>>>>>
20888>>>>>>>>>        // Driver default values for various data types:
20888>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
20891>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
20892>>>>>>>>>
20892>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
20895>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
20896>>>>>>>>>
20896>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
20899>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
20900>>>>>>>>>
20900>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
20903>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
20904>>>>>>>>>
20904>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
20907>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
20908>>>>>>>>>
20908>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
20911>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
20912>>>>>>>>>
20912>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
20912>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
20915>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
20916>>>>>>>>>
20916>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
20919>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
20920>>>>>>>>>
20920>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
20923>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
20924>>>>>>>>>
20924>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
20927>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
20928>>>>>>>>>
20928>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
20931>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
20932>>>>>>>>>
20932>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
20935>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
20936>>>>>>>>>
20936>>>>>>>>>    End_Procedure
20937>>>>>>>>>
20937>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
20939>>>>>>>>>        Boolean bOK bIsDaw bIsMertech bTrusted
20939>>>>>>>>>        String sConnectionString sServer sDatabase sUserId sPassword sDriverID
20939>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
20939>>>>>>>>>        Integer iDriverID
20939>>>>>>>>>
20939>>>>>>>>>        Move False to bOK
20940>>>>>>>>>
20940>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
20941>>>>>>>>>        If (bIsDaw = False) Begin
20943>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
20944>>>>>>>>>            If (bIsMertech = False) Begin
20946>>>>>>>>>                Function_Return False
20947>>>>>>>>>            End
20947>>>>>>>>>>
20947>>>>>>>>>        End
20947>>>>>>>>>>
20947>>>>>>>>>
20947>>>>>>>>>        Move Error_Object_Id to hoErrorObj
20948>>>>>>>>>        Move Self to Error_Object_Id
20949>>>>>>>>>
20949>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
20950>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
20951>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
20952>>>>>>>>>        If (iDriverID = 0) Begin
20954>>>>>>>>>            Move hoErrorObj to Error_Object_Id
20955>>>>>>>>>            Function_Return False
20956>>>>>>>>>        End
20956>>>>>>>>>>
20956>>>>>>>>>
20956>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
20956>>>>>>>>>        If (bIsMertech = False) Begin
20958>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
20961>>>>>>>>>        End
20961>>>>>>>>>>
20961>>>>>>>>>
20961>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
20962>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
20963>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
20964>>>>>>>>>        Send Destroy   of hoDriver
20965>>>>>>>>>        Move hoErrorObj to Error_Object_Id
20966>>>>>>>>>
20966>>>>>>>>>        Function_Return bOK
20967>>>>>>>>>    End_Function
20968>>>>>>>>>
20968>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
20970>>>>>>>>>        tSQLConnection SQLConnection
20970>>>>>>>>>        tSQLConnection SQLConnection
20970>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
20971>>>>>>>>>        Function_Return SQLConnection
20972>>>>>>>>>    End_Function
20973>>>>>>>>>
20973>>>>>>>>>    Procedure Set psConnectionID String sValue
20975>>>>>>>>>        tSQLConnection SQLConnection
20975>>>>>>>>>        tSQLConnection SQLConnection
20975>>>>>>>>>
20975>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
20976>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
20978>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
20979>>>>>>>>>        End
20979>>>>>>>>>>
20979>>>>>>>>>
20979>>>>>>>>>        // Else we might want to change the current connection ID
20979>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
20982>>>>>>>>>            Move False to Err
20983>>>>>>>>>            Logout SQLConnection.sDriverID
20984>>>>>>>>>            // This will also make a login to the new server.
20984>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
20985>>>>>>>>>        End
20985>>>>>>>>>>
20985>>>>>>>>>        Set pSQLConnection to SQLConnection
20986>>>>>>>>>    End_Procedure
20987>>>>>>>>>
20987>>>>>>>>>    Function psConnectionID Returns String
20989>>>>>>>>>        tSQLConnection SQLConnection
20989>>>>>>>>>        tSQLConnection SQLConnection
20989>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
20990>>>>>>>>>        Function_Return SQLConnection.sConnectionID
20991>>>>>>>>>    End_Function
20992>>>>>>>>>
20992>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
20992>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
20992>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
20992>>>>>>>>>    //       for a connection string has the wrong format for that driver.
20992>>>>>>>>>    Procedure Set psDriverID String sValue
20994>>>>>>>>>        tSQLConnection SQLConnection
20994>>>>>>>>>        tSQLConnection SQLConnection
20994>>>>>>>>>        Get pSQLConnection to SQLConnection
20995>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
20996>>>>>>>>>        Set pSQLConnection to SQLConnection
20997>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
20999>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
21000>>>>>>>>>        End
21000>>>>>>>>>>
21000>>>>>>>>>    End_Procedure
21001>>>>>>>>>
21001>>>>>>>>>    Function psDriverID Returns String
21003>>>>>>>>>        tSQLConnection SQLConnection
21003>>>>>>>>>        tSQLConnection SQLConnection
21003>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21004>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
21006>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
21007>>>>>>>>>        End
21007>>>>>>>>>>
21007>>>>>>>>>        Function_Return SQLConnection.sDriverID
21008>>>>>>>>>    End_Function
21009>>>>>>>>>
21009>>>>>>>>>    Procedure Set psConnectionString String sValue
21011>>>>>>>>>        tSQLConnection SQLConnection
21011>>>>>>>>>        tSQLConnection SQLConnection
21011>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21012>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
21013>>>>>>>>>        Set pSQLConnection to SQLConnection
21014>>>>>>>>>    End_Procedure
21015>>>>>>>>>
21015>>>>>>>>>    Function psConnectionString Returns String
21017>>>>>>>>>        tSQLConnection SQLConnection
21017>>>>>>>>>        tSQLConnection SQLConnection
21017>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21018>>>>>>>>>        Function_Return SQLConnection.sConnectionString
21019>>>>>>>>>    End_Function
21020>>>>>>>>>
21020>>>>>>>>>    Procedure Set psServer String sValue
21022>>>>>>>>>        tSQLConnection SQLConnection
21022>>>>>>>>>        tSQLConnection SQLConnection
21022>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21023>>>>>>>>>        Move sValue        to SQLConnection.sServer
21024>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
21025>>>>>>>>>        Set pSQLConnection to SQLConnection
21026>>>>>>>>>    End_Procedure
21027>>>>>>>>>
21027>>>>>>>>>    Function psServer Returns String
21029>>>>>>>>>        tSQLConnection SQLConnection
21029>>>>>>>>>        tSQLConnection SQLConnection
21029>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21030>>>>>>>>>        Function_Return SQLConnection.sServer
21031>>>>>>>>>    End_Function
21032>>>>>>>>>
21032>>>>>>>>>    Procedure Set psDatabase String sValue
21034>>>>>>>>>        tSQLConnection SQLConnection
21034>>>>>>>>>        tSQLConnection SQLConnection
21034>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21035>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
21036>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
21037>>>>>>>>>        Set pSQLConnection to SQLConnection
21038>>>>>>>>>    End_Procedure
21039>>>>>>>>>
21039>>>>>>>>>    Function psDatabase Returns String
21041>>>>>>>>>        tSQLConnection SQLConnection
21041>>>>>>>>>        tSQLConnection SQLConnection
21041>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21042>>>>>>>>>        Function_Return SQLConnection.sDatabase
21043>>>>>>>>>    End_Function
21044>>>>>>>>>
21044>>>>>>>>>    Procedure Set psUserID String sValue
21046>>>>>>>>>        tSQLConnection SQLConnection
21046>>>>>>>>>        tSQLConnection SQLConnection
21046>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21047>>>>>>>>>        Move sValue        to SQLConnection.sUserID
21048>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
21049>>>>>>>>>        Set pSQLConnection to SQLConnection
21050>>>>>>>>>    End_Procedure
21051>>>>>>>>>
21051>>>>>>>>>    Function psUserID Returns String
21053>>>>>>>>>        tSQLConnection SQLConnection
21053>>>>>>>>>        tSQLConnection SQLConnection
21053>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21054>>>>>>>>>        Function_Return SQLConnection.sUserID
21055>>>>>>>>>    End_Function
21056>>>>>>>>>
21056>>>>>>>>>    // This is the uncrypted password
21056>>>>>>>>>    Procedure Set psPassword String sValue
21058>>>>>>>>>        tSQLConnection SQLConnection
21058>>>>>>>>>        tSQLConnection SQLConnection
21058>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21059>>>>>>>>>        Move sValue        to SQLConnection.sPassword
21060>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
21061>>>>>>>>>        Set pSQLConnection to SQLConnection
21062>>>>>>>>>    End_Procedure
21063>>>>>>>>>
21063>>>>>>>>>    Function psPassword Returns String
21065>>>>>>>>>        tSQLConnection SQLConnection
21065>>>>>>>>>        tSQLConnection SQLConnection
21065>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21066>>>>>>>>>        Function_Return SQLConnection.sPassword
21067>>>>>>>>>    End_Function
21068>>>>>>>>>
21068>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
21070>>>>>>>>>        tSQLConnection SQLConnection
21070>>>>>>>>>        tSQLConnection SQLConnection
21070>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21071>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
21072>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
21073>>>>>>>>>        Set pSQLConnection to SQLConnection
21074>>>>>>>>>    End_Procedure
21075>>>>>>>>>
21075>>>>>>>>>    Function pbTrusted Returns Boolean
21077>>>>>>>>>        tSQLConnection SQLConnection
21077>>>>>>>>>        tSQLConnection SQLConnection
21077>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21078>>>>>>>>>        Function_Return SQLConnection.bTrusted
21079>>>>>>>>>    End_Function
21080>>>>>>>>>
21080>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
21080>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
21080>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
21080>>>>>>>>>    //     the central pSQLConnection "hub".
21080>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
21082>>>>>>>>>        tSQLConnection SQLConnection
21082>>>>>>>>>        tSQLConnection SQLConnection
21082>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21083>>>>>>>>>        Move bValue to SQLConnection.bTrusted
21084>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
21085>>>>>>>>>    End_Procedure
21086>>>>>>>>>
21086>>>>>>>>>    Function pbSilentLogin Returns Boolean
21088>>>>>>>>>        tSQLConnection SQLConnection
21088>>>>>>>>>        tSQLConnection SQLConnection
21088>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21089>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
21090>>>>>>>>>    End_Function
21091>>>>>>>>>
21091>>>>>>>>>    Procedure Set piDbType Integer iValue
21093>>>>>>>>>        tSQLConnection SQLConnection
21093>>>>>>>>>        tSQLConnection SQLConnection
21093>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21094>>>>>>>>>        Move iValue to SQLConnection.iDbType
21095>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
21096>>>>>>>>>    End_Procedure
21097>>>>>>>>>
21097>>>>>>>>>    Function piDbType Returns Integer
21099>>>>>>>>>        tSQLConnection SQLConnection
21099>>>>>>>>>        tSQLConnection SQLConnection
21099>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21100>>>>>>>>>        Function_Return SQLConnection.iDbType
21101>>>>>>>>>    End_Function
21102>>>>>>>>>
21102>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
21104>>>>>>>>>        tSQLConnection SQLConnection
21104>>>>>>>>>        tSQLConnection SQLConnection
21104>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21105>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
21106>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
21107>>>>>>>>>    End_Procedure
21108>>>>>>>>>
21108>>>>>>>>>    Function psBaseTableSpace Returns String
21110>>>>>>>>>        tSQLConnection SQLConnection
21110>>>>>>>>>        tSQLConnection SQLConnection
21110>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21111>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
21112>>>>>>>>>    End_Function
21113>>>>>>>>>
21113>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
21115>>>>>>>>>        tSQLConnection SQLConnection
21115>>>>>>>>>        tSQLConnection SQLConnection
21115>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21116>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
21117>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
21118>>>>>>>>>    End_Procedure
21119>>>>>>>>>
21119>>>>>>>>>    Function psIndexTableSpace Returns String
21121>>>>>>>>>        tSQLConnection SQLConnection
21121>>>>>>>>>        tSQLConnection SQLConnection
21121>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21122>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
21123>>>>>>>>>    End_Function
21124>>>>>>>>>
21124>>>>>>>>>    Procedure Set psLongTableSpace String sValue
21126>>>>>>>>>        tSQLConnection SQLConnection
21126>>>>>>>>>        tSQLConnection SQLConnection
21126>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21127>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
21128>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
21129>>>>>>>>>    End_Procedure
21130>>>>>>>>>
21130>>>>>>>>>    Function psLongTableSpace Returns String
21132>>>>>>>>>        tSQLConnection SQLConnection
21132>>>>>>>>>        tSQLConnection SQLConnection
21132>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21133>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
21134>>>>>>>>>    End_Function
21135>>>>>>>>>
21135>>>>>>>>>    Procedure Set psSchema String sValue
21137>>>>>>>>>        tSQLConnection SQLConnection
21137>>>>>>>>>        tSQLConnection SQLConnection
21137>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21138>>>>>>>>>        Move sValue to SQLConnection.sSchema
21139>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
21140>>>>>>>>>    End_Procedure
21141>>>>>>>>>
21141>>>>>>>>>    Function psSchema Returns String
21143>>>>>>>>>        tSQLConnection SQLConnection
21143>>>>>>>>>        tSQLConnection SQLConnection
21143>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21144>>>>>>>>>        Function_Return SQLConnection.sSchema
21145>>>>>>>>>    End_Function
21146>>>>>>>>>
21146>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
21148>>>>>>>>>        tSQLConnection SQLConnection
21148>>>>>>>>>        tSQLConnection SQLConnection
21148>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21149>>>>>>>>>        Move bValue to SQLConnection.bEnabled
21150>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
21151>>>>>>>>>    End_Procedure
21152>>>>>>>>>
21152>>>>>>>>>    Function pbEnabled Returns Boolean
21154>>>>>>>>>        tSQLConnection SQLConnection
21154>>>>>>>>>        tSQLConnection SQLConnection
21154>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
21155>>>>>>>>>        Function_Return SQLConnection.bEnabled
21156>>>>>>>>>    End_Function
21157>>>>>>>>>
21157>>>>>>>>>
21157>>>>>>>>>    // ************************************
21157>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
21159>>>>>>>>>        tSQLConnection SQLConnection
21159>>>>>>>>>        tSQLConnection SQLConnection
21159>>>>>>>>>
21159>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
21159>>>>>>>>>        // deferr reading SQL connection values until later.
21159>>>>>>>>>        If (bReadDFConnSettings = True) Begin
21161>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
21161>>>>>>>>>            If (ghoConnection > 0) Begin
21163>>>>>>>>>                Get ReadcConnections to SQLConnection
21164>>>>>>>>>            End
21164>>>>>>>>>>
21164>>>>>>>>>
21164>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
21164>>>>>>>>>            // object is used.
21164>>>>>>>>>            If (bReadSQLConnections = True) Begin
21166>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
21167>>>>>>>>>            End
21167>>>>>>>>>>
21167>>>>>>>>>        End
21167>>>>>>>>>>
21167>>>>>>>>>
21167>>>>>>>>>        Function_Return SQLConnection
21168>>>>>>>>>    End_Function
21169>>>>>>>>>
21169>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
21169>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
21171>>>>>>>>>        tConnection Connection
21171>>>>>>>>>        tConnection Connection
21171>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
21171>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
21171>>>>>>>>>        Integer iRetval iDbType
21171>>>>>>>>>        Boolean bOK bEnabled bConnected
21171>>>>>>>>>        String sConnectionID sSchema
21171>>>>>>>>>
21171>>>>>>>>>
21171>>>>>>>>>        Function_Return SQLConnection
21172>>>>>>>>>    End_Function
21173>>>>>>>>>
21173>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
21173>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
21173>>>>>>>>>    // connection id for a particular driver.
21173>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
21173>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
21173>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
21173>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
21173>>>>>>>>>    // connections of the DAW cConnect class.
21173>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
21175>>>>>>>>>        tConnection[] ConnIdArray
21175>>>>>>>>>        tConnection[] ConnIdArray
21176>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
21176>>>>>>>>>        Boolean bEnabled bFound
21176>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
21176>>>>>>>>>
21176>>>>>>>>>        Move False to bFound
21177>>>>>>>>>        If (ghoConnection > 0) Begin
21179>>>>>>>>>
21179>>>>>>>>>            // The property of the cDbUpdateHandler container object
21179>>>>>>>>>            Get psDriverID to sDriverID
21180>>>>>>>>>
21180>>>>>>>>>            Move 0 to iConnectionIDCounter
21181>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
21181>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
21182>>>>>>>>>            Decrement iSize
21183>>>>>>>>>            For iCount from 0 to iSize
21189>>>>>>>>>>
21189>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
21190>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
21191>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
21192>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
21192>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
21192>>>>>>>>>                If (sConnectionID = "") Begin
21194>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
21195>>>>>>>>>                End
21195>>>>>>>>>>
21195>>>>>>>>>                Else Begin
21196>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
21198>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
21199>>>>>>>>>                    End
21199>>>>>>>>>>
21199>>>>>>>>>                End
21199>>>>>>>>>>
21199>>>>>>>>>
21199>>>>>>>>>                If (bFound = True) Begin
21201>>>>>>>>>                    Increment iConnectionIDCounter
21202>>>>>>>>>                End
21202>>>>>>>>>>
21202>>>>>>>>>            Loop
21203>>>>>>>>>>
21203>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
21204>>>>>>>>>            If (bFound = True) Begin
21206>>>>>>>>>                Move sConnectionID2 to sConnectionID
21207>>>>>>>>>            End
21207>>>>>>>>>>
21207>>>>>>>>>        End
21207>>>>>>>>>>
21207>>>>>>>>>
21207>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
21207>>>>>>>>>        // but no DFConn.ini record has been created.
21207>>>>>>>>>        If (iSize = -1) Begin
21209>>>>>>>>>            Move True to bFound
21210>>>>>>>>>        End
21210>>>>>>>>>>
21210>>>>>>>>>
21210>>>>>>>>>        Function_Return bFound
21211>>>>>>>>>    End_Function
21212>>>>>>>>>
21212>>>>>>>>>    // Send on object creation to read the default connection string settings, and
21212>>>>>>>>>    // create a connection to the server.
21212>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
21214>>>>>>>>>        String sPath sFileName sPassword
21214>>>>>>>>>        Boolean bExists bActive
21214>>>>>>>>>        tSQLConnection[] SQLConnectionArray
21214>>>>>>>>>        tSQLConnection[] SQLConnectionArray
21215>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
21215>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
21215>>>>>>>>>        Handle hoIniFile
21215>>>>>>>>>        Integer iSize iCount iRetval
21215>>>>>>>>>
21215>>>>>>>>>        Get psIniFilePath to sPath
21216>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
21217>>>>>>>>>        If (sPath = "") Begin
21219>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
21220>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
21221>>>>>>>>>        End
21221>>>>>>>>>>
21221>>>>>>>>>        Get vFolderFormat sPath to sPath
21222>>>>>>>>>        Get psIniFileName to sFileName
21223>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
21224>>>>>>>>>
21224>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
21225>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
21226>>>>>>>>>        If (iSize = 0) Begin
21228>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
21228>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
21228>>>>>>>>>            // in the cApplication object.
21228>>>>>>>>>            Get pSQLConnection to SQLConnection
21229>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
21231>>>>>>>>>                Function_Return SQLConnectionEmpty
21232>>>>>>>>>            End
21232>>>>>>>>>>
21232>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0]
21233>>>>>>>>>        End
21233>>>>>>>>>>
21233>>>>>>>>>
21233>>>>>>>>>        Move False to bActive
21234>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
21234>>>>>>>>>        Decrement iSize
21235>>>>>>>>>        For iCount from 0 to iSize
21241>>>>>>>>>>
21241>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
21242>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
21244>>>>>>>>>                Move True to bActive
21245>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
21246>>>>>>>>>            End
21246>>>>>>>>>>
21246>>>>>>>>>        Loop
21247>>>>>>>>>>
21247>>>>>>>>>
21247>>>>>>>>>        // In case all connections have been disabled, we're out of here.
21247>>>>>>>>>        If (bActive = False) Begin
21249>>>>>>>>>            Function_Return SQLConnectionEmpty
21250>>>>>>>>>        End
21250>>>>>>>>>>
21250>>>>>>>>>
21250>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin
21251>>>>>>>>>
21251>>>>>>>>>        Set pSQLConnection to SQLConnection
21252>>>>>>>>>        Get AutoSetConnectionID to iRetval
21253>>>>>>>>>
21253>>>>>>>>>        Function_Return SQLConnection
21254>>>>>>>>>    End_Function
21255>>>>>>>>>
21255>>>>>>>>>    Procedure Set psIniFilePath String sPath
21257>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
21258>>>>>>>>>    End_Procedure
21259>>>>>>>>>
21259>>>>>>>>>    Function psIniFilePath Returns String
21261>>>>>>>>>        String sRetval
21261>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
21262>>>>>>>>>        Function_Return sRetval
21263>>>>>>>>>    End_Function
21264>>>>>>>>>
21264>>>>>>>>>    Procedure Set psIniFileName String sFileName
21266>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
21267>>>>>>>>>    End_Procedure
21268>>>>>>>>>
21268>>>>>>>>>    Function psIniFileName Returns String
21270>>>>>>>>>        String sRetval
21270>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
21271>>>>>>>>>        Function_Return sRetval
21272>>>>>>>>>    End_Function
21273>>>>>>>>>
21273>>>>>>>>>    // We use Base64 coding instead of the cCryptographer class because the
21273>>>>>>>>>    // password will get scrambled while writing/reading to/from the ini-file.
21273>>>>>>>>>//    { MethodType=Property Category="Behavior" InitialValue="zx!2139(LI0+?ips7433"}
21273>>>>>>>>>//    Procedure Set psHashString String sHashString
21273>>>>>>>>>//        Set psHashString of (phoSQLConnectionIniFile(Self)) to sHashString
21273>>>>>>>>>//    End_Procedure
21273>>>>>>>>>//
21273>>>>>>>>>//    Function psHashString Returns String
21273>>>>>>>>>//        String sRetval
21273>>>>>>>>>//        Get psHashString of (phoSQLConnectionIniFile(Self)) to sRetval
21273>>>>>>>>>//        Function_Return sRetval
21273>>>>>>>>>//    End_Function
21273>>>>>>>>>
21273>>>>>>>>>    Procedure Set psIniSectionName String sSection
21275>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
21276>>>>>>>>>    End_Procedure
21277>>>>>>>>>
21277>>>>>>>>>    Function psIniSectionName Returns String
21279>>>>>>>>>        String sRetval
21279>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
21280>>>>>>>>>        Function_Return sRetval
21281>>>>>>>>>    End_Function
21282>>>>>>>>>
21282>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
21284>>>>>>>>>        Handle ho
21284>>>>>>>>>        Get phoSQLConnectionIniFile to ho
21285>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
21286>>>>>>>>>    End_Procedure
21287>>>>>>>>>
21287>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
21289>>>>>>>>>        Handle ho
21289>>>>>>>>>        String sRetval
21289>>>>>>>>>        Get phoSQLConnectionIniFile to ho
21290>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
21291>>>>>>>>>        Function_Return sRetval
21292>>>>>>>>>    End_Function
21293>>>>>>>>>
21293>>>>>>>>>    Function SectionExists String sSection Returns Boolean
21295>>>>>>>>>        Handle ho
21295>>>>>>>>>        Boolean bRetval
21295>>>>>>>>>        Get phoSQLConnectionIniFile to ho
21296>>>>>>>>>        Get SectionExists of ho sSection to bRetval
21297>>>>>>>>>        Function_Return bRetval
21298>>>>>>>>>    End_Function
21299>>>>>>>>>
21299>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
21301>>>>>>>>>        Handle ho
21301>>>>>>>>>        Boolean bRetval
21301>>>>>>>>>        Get phoSQLConnectionIniFile to ho
21302>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
21303>>>>>>>>>        Function_Return bRetval
21304>>>>>>>>>    End_Function
21305>>>>>>>>>
21305>>>>>>>>>    Function EncryptPassword String sPassword Returns String
21307>>>>>>>>>        Handle ho
21307>>>>>>>>>        String sRetval
21307>>>>>>>>>        Get phoSQLConnectionIniFile to ho
21308>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
21309>>>>>>>>>        Function_Return sRetval
21310>>>>>>>>>    End_Function
21311>>>>>>>>>
21311>>>>>>>>>    Function DecryptPassword String sPassword Returns String
21313>>>>>>>>>        Handle ho
21313>>>>>>>>>        String sRetval
21313>>>>>>>>>        Get phoSQLConnectionIniFile to ho
21314>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
21315>>>>>>>>>        Function_Return sRetval
21316>>>>>>>>>    End_Function
21317>>>>>>>>>
21317>>>>>>>>>    // *** Main Connection Message ***
21317>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
21319>>>>>>>>>        Handle hoDriver
21319>>>>>>>>>        String sConnectionString sError
21319>>>>>>>>>        Boolean bLoginSuccessful
21319>>>>>>>>>
21319>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
21320>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
21321>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
21322>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
21323>>>>>>>>>        If (bLoginSuccessful = False) Begin
21325>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)
21326>>>>>>>>>>
21326>>>>>>>>>            Send Exit_Application
21327>>>>>>>>>        End
21327>>>>>>>>>>
21327>>>>>>>>>        Send Destroy of hoDriver
21328>>>>>>>>>    End_Procedure
21329>>>>>>>>>
21329>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
21331>>>>>>>>>        Integer iRetval
21331>>>>>>>>>        Handle hoCLI
21331>>>>>>>>>        String sDriverID
21331>>>>>>>>>
21331>>>>>>>>>        Get psDriverID to sDriverID
21332>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
21333>>>>>>>>>        If (hoCLI <> 0) Begin
21335>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
21336>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
21337>>>>>>>>>            Send Destroy of hoCLI
21338>>>>>>>>>        End
21338>>>>>>>>>>
21338>>>>>>>>>
21338>>>>>>>>>        Function_Return iRetval
21339>>>>>>>>>    End_Function
21340>>>>>>>>>
21340>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
21342>>>>>>>>>        String sServer sDatabase sUserID sPassword
21342>>>>>>>>>        tSQLConnection SQLConnection
21342>>>>>>>>>        tSQLConnection SQLConnection
21342>>>>>>>>>
21342>>>>>>>>>        Set psDriverID to sDriverID
21343>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
21344>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted
21345>>>>>>>>>    End_Procedure
21346>>>>>>>>>
21346>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
21346>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
21346>>>>>>>>>    // or the one in the DataFlex Bin folder.)
21346>>>>>>>>>    // We then need to delete the current one before creating a new one.
21346>>>>>>>>>    // This is because the parameters may differ between the program code and the
21346>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
21346>>>>>>>>>    // when one tries to create a Connection ID that already exists.
21346>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
21348>>>>>>>>>        Integer iResult iDriver iNumConn iConn
21348>>>>>>>>>        Handle hoCLI
21348>>>>>>>>>        String sID
21348>>>>>>>>>
21348>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
21350>>>>>>>>>            Procedure_Return
21351>>>>>>>>>        End
21351>>>>>>>>>>
21351>>>>>>>>>
21351>>>>>>>>>        Move 0 to iResult
21352>>>>>>>>>        Get Create U_cCLIHandler to hoCLI
21353>>>>>>>>>        If (hoCLI <> 0) Begin
21355>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
21356>>>>>>>>>            Get DriverIndex sDriverID to iDriver
21357>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
21360>>>>>>>>>            Decrement iNumConn
21361>>>>>>>>>            For iConn from 0 to iNumConn
21367>>>>>>>>>>
21367>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
21370>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
21372>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
21373>>>>>>>>>                End
21373>>>>>>>>>>
21373>>>>>>>>>            Loop
21374>>>>>>>>>>
21374>>>>>>>>>            Send Destroy of hoCLI
21375>>>>>>>>>        End
21375>>>>>>>>>>
21375>>>>>>>>>
21375>>>>>>>>>    End_Procedure
21376>>>>>>>>>
21376>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
21378>>>>>>>>>        Integer iResult iDriver iNumConn iConn
21378>>>>>>>>>        Handle hoCLI
21378>>>>>>>>>        String sID sConnectionString sVal sDatabase
21378>>>>>>>>>        tSQLConnection SQLConnection
21378>>>>>>>>>        tSQLConnection SQLConnection
21378>>>>>>>>>        Boolean bTrusted
21378>>>>>>>>>
21378>>>>>>>>>        Move 0 to iResult
21379>>>>>>>>>        Get Create U_cCLIHandler to hoCLI
21380>>>>>>>>>        If (hoCLI <> 0) Begin
21382>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
21383>>>>>>>>>            Get DriverIndex sDriverID to iDriver
21384>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
21387>>>>>>>>>            Decrement iNumConn
21388>>>>>>>>>            For iConn from 0 to iNumConn
21394>>>>>>>>>>
21394>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
21397>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
21399>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
21400>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
21403>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
21406>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
21407>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
21410>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
21411>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
21412>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
21413>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
21414>>>>>>>>>
21414>>>>>>>>>                    Case Begin
21414>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
21416>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
21417>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
21418>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
21419>>>>>>>>>                            Case Break
21420>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
21423>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
21424>>>>>>>>>                            Case Break
21425>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
21428>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
21429>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
21431>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
21432>>>>>>>>>                            End
21432>>>>>>>>>>
21432>>>>>>>>>                            Case Break
21433>>>>>>>>>                        Case (sDriverID = SQLFLEX)
21436>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
21437>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
21438>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
21440>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
21441>>>>>>>>>                            End
21441>>>>>>>>>>
21441>>>>>>>>>                            Else Begin
21442>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
21443>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
21444>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
21445>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
21446>>>>>>>>>                            End
21446>>>>>>>>>>
21446>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
21447>>>>>>>>>                            Case Break
21448>>>>>>>>>                        Case (sDriverID = MDSMySQL)
21451>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
21452>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
21453>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
21455>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
21456>>>>>>>>>                            End
21456>>>>>>>>>>
21456>>>>>>>>>                            Else Begin
21457>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
21458>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
21459>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
21460>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
21461>>>>>>>>>                            End
21461>>>>>>>>>>
21461>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
21462>>>>>>>>>                            Case Break
21463>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
21466>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
21467>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
21468>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
21470>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
21471>>>>>>>>>                            End
21471>>>>>>>>>>
21471>>>>>>>>>                            Else Begin
21472>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
21473>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
21474>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
21475>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
21476>>>>>>>>>                            End
21476>>>>>>>>>>
21476>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
21477>>>>>>>>>                            Case Break
21478>>>>>>>>>
21478>>>>>>>>>                        Case (sDriverID = ORAFLEX)
21481>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
21482>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
21483>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
21484>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
21486>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
21487>>>>>>>>>                            End
21487>>>>>>>>>>
21487>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
21489>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
21490>>>>>>>>>                            End
21490>>>>>>>>>>
21490>>>>>>>>>                            Else Begin
21491>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
21492>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
21493>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
21494>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
21495>>>>>>>>>                            End
21495>>>>>>>>>>
21495>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
21496>>>>>>>>>                            Case Break
21497>>>>>>>>>                        Case Else
21497>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
21498>>>>>>>>>>
21498>>>>>>>>>                            Case Break
21499>>>>>>>>>                    Case End
21499>>>>>>>>>                End
21499>>>>>>>>>>
21499>>>>>>>>>            Loop
21500>>>>>>>>>>
21500>>>>>>>>>            Send Destroy of hoCLI
21501>>>>>>>>>        End
21501>>>>>>>>>>
21501>>>>>>>>>
21501>>>>>>>>>        Function_Return SQLConnection
21502>>>>>>>>>    End_Function
21503>>>>>>>>>
21503>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
21505>>>>>>>>>        String  sCurrentDriver
21505>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
21505>>>>>>>>>
21505>>>>>>>>>        Move 0 to iDriver
21506>>>>>>>>>        Move 0 to iCount
21507>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
21510>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
21516>>>>>>>>>>
21516>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
21519>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
21521>>>>>>>>>                Function_Return iCount
21522>>>>>>>>>            End
21522>>>>>>>>>>
21522>>>>>>>>>        Loop
21523>>>>>>>>>>
21523>>>>>>>>>
21523>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
21523>>>>>>>>>        If (iDriver = 0) Begin
21525>>>>>>>>>            Move 0 to LastErr
21526>>>>>>>>>            Load_Driver sDriverID
21527>>>>>>>>>            // If driver could not be loaded.
21527>>>>>>>>>            If (LastErr = 4255) Begin
21529>>>>>>>>>                Move 0 to iCount
21530>>>>>>>>>            End
21530>>>>>>>>>>
21530>>>>>>>>>        End
21530>>>>>>>>>>
21530>>>>>>>>>        Function_Return iCount
21531>>>>>>>>>    End_Function
21532>>>>>>>>>
21532>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
21532>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
21534>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
21534>>>>>>>>>        Boolean bTrusted bSilent
21534>>>>>>>>>        Integer iRetval
21534>>>>>>>>>
21534>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
21535>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
21536>>>>>>>>>        Move SQLConnection.sServer       to sServer
21537>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
21538>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
21539>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
21540>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
21541>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
21542>>>>>>>>>
21542>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
21543>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
21543>>>>>>>>>        Get AutoSetConnectionID to iRetval
21544>>>>>>>>>    End_Procedure
21545>>>>>>>>>
21545>>>>>>>>>    // Called when the object is constructed.
21545>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
21545>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
21545>>>>>>>>>    // the database is needed.
21545>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
21547>>>>>>>>>        String sConnectionID sDriverID sConnectionString
21547>>>>>>>>>        Integer iDriver iRetval
21547>>>>>>>>>        Handle hoCLI
21547>>>>>>>>>        Boolean bOK bSilent bMertechDriver
21547>>>>>>>>>
21547>>>>>>>>>        Get pbSilentLogin      to bSilent
21548>>>>>>>>>        Get psConnectionID     to sConnectionID
21549>>>>>>>>>        Get psConnectionString to sConnectionString
21550>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
21550>>>>>>>>>        Get psDriverID to sDriverID
21551>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
21552>>>>>>>>>        If (bOK = False) Begin
21554>>>>>>>>>            Function_Return False
21555>>>>>>>>>        End
21555>>>>>>>>>>
21555>>>>>>>>>
21555>>>>>>>>>        // Mertech drivers can't use connection ID's.
21555>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
21556>>>>>>>>>        If (bMertechDriver = True) Begin
21558>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
21558>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
21558>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
21559>>>>>>>>>            Function_Return (hoCLI <> 0)
21560>>>>>>>>>        End
21560>>>>>>>>>>
21560>>>>>>>>>
21560>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
21561>>>>>>>>>        // If driver not loaded; load it.
21561>>>>>>>>>        If (iDriver = 0) Begin
21563>>>>>>>>>            Load_Driver sDriverID
21564>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
21565>>>>>>>>>        End
21565>>>>>>>>>>
21565>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
21565>>>>>>>>>        If (iDriver = 0) Begin
21567>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
21568>>>>>>>>>>
21568>>>>>>>>>            Function_Return False
21569>>>>>>>>>        End           
21569>>>>>>>>>>
21569>>>>>>>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
21572>>>>>>>>>        
21572>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
21573>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
21574>>>>>>>>>        // Delete the connection first; in case it exists
21574>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
21575>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
21576>>>>>>>>>        Send Destroy of hoCLI
21577>>>>>>>>>
21577>>>>>>>>>        Function_Return (iRetval = 0)
21578>>>>>>>>>    End_Function
21579>>>>>>>>>
21579>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
21579>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
21579>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
21579>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
21579>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
21579>>>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
21581>>>>>>>>>        Handle hoSQLHandler
21581>>>>>>>>>        String sDriverID sServer sDatabase
21581>>>>>>>>>
21581>>>>>>>>>        Move 0 to hoSQLHandler
21582>>>>>>>>>        Get psDriverID to sDriverID
21583>>>>>>>>>        Get psServer   to sServer
21584>>>>>>>>>        Get psDatabase to sDatabase
21585>>>>>>>>>
21585>>>>>>>>>        Function_Return hoSQLHandler
21586>>>>>>>>>    End_Function
21587>>>>>>>>>
21587>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
21589>>>>>>>>>        Boolean bOK bMertechDriver
21589>>>>>>>>>
21589>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
21590>>>>>>>>>
21590>>>>>>>>>        If (bOK = False) Begin
21592>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
21593>>>>>>>>>        End
21593>>>>>>>>>>
21593>>>>>>>>>
21593>>>>>>>>>        If (bOK = False) Begin
21595>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
21596>>>>>>>>>            If (bMertechDriver = True) Begin
21598>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
21599>>>>>>>>>>
21599>>>>>>>>>            End
21599>>>>>>>>>>
21599>>>>>>>>>            Else Begin
21600>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
21601>>>>>>>>>>
21601>>>>>>>>>            End
21601>>>>>>>>>>
21601>>>>>>>>>            Function_Return False
21602>>>>>>>>>        End
21602>>>>>>>>>>
21602>>>>>>>>>
21602>>>>>>>>>        Function_Return True
21603>>>>>>>>>    End_Function
21604>>>>>>>>>
21604>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
21606>>>>>>>>>        Boolean bOK
21606>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
21607>>>>>>>>>        Function_Return bOK
21608>>>>>>>>>    End_Function
21609>>>>>>>>>
21609>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
21611>>>>>>>>>        Boolean bOK
21611>>>>>>>>>        Move False to bOK
21612>>>>>>>>>        Function_Return bOK
21613>>>>>>>>>    End_Function
21614>>>>>>>>>
21614>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
21616>>>>>>>>>        Handle hoIniFile
21616>>>>>>>>>        String sConnect
21616>>>>>>>>>
21616>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
21617>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
21618>>>>>>>>>
21618>>>>>>>>>        Function_Return sConnect
21619>>>>>>>>>    End_Function
21620>>>>>>>>>
21620>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
21620>>>>>>>>>    // Pass a complete driver connection string
21620>>>>>>>>>    // Returns the following as a struct:
21620>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
21620>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
21620>>>>>>>>>    //
21620>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
21622>>>>>>>>>        tSQLConnection SQLConnection
21622>>>>>>>>>        tSQLConnection SQLConnection
21622>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
21622>>>>>>>>>        Boolean bTrusted bSilent bOK
21622>>>>>>>>>        Integer iPos
21622>>>>>>>>>
21622>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
21623>>>>>>>>>        If (bOK = False) Begin
21625>>>>>>>>>            Function_Return SQLConnection
21626>>>>>>>>>        End
21626>>>>>>>>>>
21626>>>>>>>>>
21626>>>>>>>>>        Move False to bTrusted
21627>>>>>>>>>        Move False to bSilent
21628>>>>>>>>>
21628>>>>>>>>>        Case Begin
21628>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
21630>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
21631>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
21632>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
21633>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
21634>>>>>>>>>                If (bTrusted = False) Begin
21636>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
21637>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
21638>>>>>>>>>                End
21638>>>>>>>>>>
21638>>>>>>>>>                Case Break
21639>>>>>>>>>
21639>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
21642>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
21644>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
21645>>>>>>>>>                End
21645>>>>>>>>>>
21645>>>>>>>>>                Else Begin
21646>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
21647>>>>>>>>>                End
21647>>>>>>>>>>
21647>>>>>>>>>
21647>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
21648>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
21649>>>>>>>>>                If (bTrusted = False) Begin
21651>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
21652>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
21653>>>>>>>>>                End
21653>>>>>>>>>>
21653>>>>>>>>>                Case Break
21654>>>>>>>>>
21654>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
21657>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
21658>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
21659>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
21660>>>>>>>>>                Case Break
21661>>>>>>>>>
21661>>>>>>>>>            Case (sDriverID = SQLFLEX)
21664>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
21665>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
21666>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
21667>>>>>>>>>                If (bTrusted = False) Begin
21669>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
21670>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
21671>>>>>>>>>                End
21671>>>>>>>>>>
21671>>>>>>>>>                Case Break
21672>>>>>>>>>
21672>>>>>>>>>            Case (sDriverID = ORAFLEX)
21675>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
21676>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
21677>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
21679>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
21680>>>>>>>>>                End
21680>>>>>>>>>>
21680>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
21681>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
21682>>>>>>>>>                Case Break
21683>>>>>>>>>
21683>>>>>>>>>            Case (sDriverID = MDSPgSQL)
21686>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
21687>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
21688>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
21689>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
21690>>>>>>>>>                Case Break
21691>>>>>>>>>
21691>>>>>>>>>            Case (sDriverID = MDSMySQL)
21694>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
21695>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
21696>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
21697>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
21698>>>>>>>>>                Case Break
21699>>>>>>>>>
21699>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
21702>>>>>>>>>                Break
21703>>>>>>>>>        Case End
21703>>>>>>>>>
21703>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
21704>>>>>>>>>
21704>>>>>>>>>        // bSilent?
21704>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
21705>>>>>>>>>        If (iPos = 0) Begin
21707>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
21708>>>>>>>>>        End
21708>>>>>>>>>>
21708>>>>>>>>>        If (iPos = 0) Begin
21710>>>>>>>>>            Move "0"                                                            to sValue
21711>>>>>>>>>        End
21711>>>>>>>>>>
21711>>>>>>>>>        Else Begin
21712>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
21713>>>>>>>>>        End
21713>>>>>>>>>>
21713>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
21714>>>>>>>>>
21714>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
21715>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
21716>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
21717>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
21718>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
21719>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
21720>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
21721>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
21722>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
21723>>>>>>>>>
21723>>>>>>>>>        Function_Return SQLConnection
21724>>>>>>>>>    End_Function
21725>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
21725>>>>>>>>>>
21725>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
21727>>>>>>>>>>    Integer iStart iEnd
21727>>>>>>>>>>    String sRetval
21727>>>>>>>>>>
21727>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
21728>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
21729>>>>>>>>>>    If (iStart = 0) Begin
21731>>>>>>>>>>        Function_Return ""
21732>>>>>>>>>>    End
21732>>>>>>>>>>>
21732>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
21733>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
21734>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
21736>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
21737>>>>>>>>>>    End
21737>>>>>>>>>>>
21737>>>>>>>>>>    Else Begin
21738>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
21739>>>>>>>>>>    End
21739>>>>>>>>>>>
21739>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
21741>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
21742>>>>>>>>>>        Decrement iEnd
21743>>>>>>>>>>    End
21743>>>>>>>>>>>
21743>>>>>>>>>>    If (iEnd <> 0) Begin
21745>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
21746>>>>>>>>>>    End
21746>>>>>>>>>>>
21746>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
21747>>>>>>>>>>
21747>>>>>>>>>>    Function_Return (Trim(sRetval))
21748>>>>>>>>>>End_Function
21749>>>>>>>>>>
21749>>>>>>>>>>
21749>>>>>>>>>
21749>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
21749>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
21751>>>>>>>>>        Handle ho
21751>>>>>>>>>        Integer iIndex
21751>>>>>>>>>        Boolean bRetval bOK
21751>>>>>>>>>        tSQLConnection SQLConnection
21751>>>>>>>>>        tSQLConnection SQLConnection
21751>>>>>>>>>
21751>>>>>>>>>        Get pSQLConnection to SQLConnection
21752>>>>>>>>>        Get phoSQLConnectionIniFile to ho
21753>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
21754>>>>>>>>>        If (iIndex = -1) Begin
21756>>>>>>>>>            Function_Return False
21757>>>>>>>>>        End
21757>>>>>>>>>>
21757>>>>>>>>>
21757>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
21758>>>>>>>>>        Send UpdateConnectionString of ghoSQLConnectionHandler SQLConnection
21759>>>>>>>>>        If (ghoConnection > 0) Begin
21761>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
21762>>>>>>>>>            If (iIndex <> -1) Begin
21764>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
21765>>>>>>>>>            End
21765>>>>>>>>>>
21765>>>>>>>>>        End
21765>>>>>>>>>>
21765>>>>>>>>>
21765>>>>>>>>>        Function_Return bRetval
21766>>>>>>>>>    End_Function
21767>>>>>>>>>
21767>>>>>>>>>End_Class
21768>>>>>>>Use vWin32fh.pkg
21768>>>>>>>
21768>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
21768>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
21768>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
21768>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
21768>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
21768>>>>>>>//
21768>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convertall dummy zero Date values from 1753-01-01 to 0001-01-01.
21768>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
21768>>>>>>>
21768>>>>>>>
21768>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
21768>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
21768>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
21768>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
21768>>>>>>>//
21768>>>>>>>
21768>>>>>>>Class cDbUpdateFunctionLibrary is a cObject
21769>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\ParseKeyWord.pkg)
21770>>>>>>>>
21770>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
21772>>>>>>>>    Integer iStart iEnd
21772>>>>>>>>    String sRetval
21772>>>>>>>>
21772>>>>>>>>    Move (Trim(sConnect)) to sConnect
21773>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
21774>>>>>>>>    If (iStart = 0) Begin
21776>>>>>>>>        Function_Return ""
21777>>>>>>>>    End
21777>>>>>>>>>
21777>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
21778>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
21779>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
21781>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
21782>>>>>>>>    End
21782>>>>>>>>>
21782>>>>>>>>    Else Begin
21783>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
21784>>>>>>>>    End
21784>>>>>>>>>
21784>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
21786>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
21787>>>>>>>>        Decrement iEnd
21788>>>>>>>>    End
21788>>>>>>>>>
21788>>>>>>>>    If (iEnd <> 0) Begin
21790>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
21791>>>>>>>>    End
21791>>>>>>>>>
21791>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
21792>>>>>>>>
21792>>>>>>>>    Function_Return (Trim(sRetval))
21793>>>>>>>>End_Function
21794>>>>>>>>
21794>>>>>>>>
21794>>>>>>>
21794>>>>>>>    Procedure Construct_Object
21796>>>>>>>        Handle ho
21796>>>>>>>        Forward Send Construct_Object
21798>>>>>>>
21798>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
21799>>>>>>>
21799>>>>>>>        Send CreateDbUpdateLibraryProperties
21800>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
21800>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
21800>>>>>>>        // etc settings.
21800>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
21802>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
21803>>>>>>>            Set phoSQLConnectionHandler to ho
21804>>>>>>>        End
21804>>>>>>>>
21804>>>>>>>
21804>>>>>>>    End_Procedure
21805>>>>>>>
21805>>>>>>>    Procedure End_Construct_Object
21807>>>>>>>        Forward Send End_Construct_Object
21809>>>>>>>    End_Procedure
21810>>>>>>>
21810>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
21810>>>>>>>    //
21810>>>>>>>    // * Dummy function for the Studio's Code Explorer *
21810>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
21812>>>>>>>        Function_Return False
21813>>>>>>>    End_Function
21814>>>>>>>
21814>>>>>>>    // Function for creating a new *Database*.
21814>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
21814>>>>>>>    // Returns True if successful.
21814>>>>>>>    // ToDo: Currently only works for MS-SQL...
21814>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
21816>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
21816>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
21816>>>>>>>        Handle hConnection hStmt hoSQLManager
21816>>>>>>>        Integer iFetchResult iDbType iPos
21816>>>>>>>        Boolean bOK bMertechDriver bExists
21816>>>>>>>
21816>>>>>>>        Get piDbType to iDbType
21817>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
21819>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL and MySQL & DB2 with Mertech drivers"
21820>>>>>>>>
21820>>>>>>>            Function_Return False
21821>>>>>>>        End
21821>>>>>>>>
21821>>>>>>>
21821>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
21822>>>>>>>        If (bExists = True) Begin
21824>>>>>>>            Function_Return True
21825>>>>>>>        End
21825>>>>>>>>
21825>>>>>>>
21825>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
21826>>>>>>>        If (bMertechDriver = False) Begin
21828>>>>>>>            Get phoSQLManager to hoSQLManager
21829>>>>>>>        End
21829>>>>>>>>
21829>>>>>>>        Else Begin
21830>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
21831>>>>>>>        End
21831>>>>>>>>
21831>>>>>>>
21831>>>>>>>        Get psConnectionID     to sConnectionID
21832>>>>>>>        Get psConnectionString to sConnectionString
21833>>>>>>>        Move 0 to LastErr
21834>>>>>>>
21834>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
21836>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
21836>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
21836>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
21836>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
21836>>>>>>>//                If (iPos > 0) Begin
21836>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
21836>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
21836>>>>>>>//                End
21836>>>>>>>//            End
21836>>>>>>>        End
21836>>>>>>>>
21836>>>>>>>
21836>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
21837>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
21838>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
21839>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
21841>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
21842>>>>>>>>
21842>>>>>>>            Function_Return False
21843>>>>>>>        End
21843>>>>>>>>
21843>>>>>>>
21843>>>>>>>        Get SqlOpen of hConnection to hStmt
21844>>>>>>>
21844>>>>>>>        If (hStmt = 0) Begin
21846>>>>>>>            Send SqlDisconnect of hoSQLManager
21847>>>>>>>            Error DFERR_PROGRAM CS_SQLConnectError
21848>>>>>>>>
21848>>>>>>>            Function_Return False
21849>>>>>>>        End
21849>>>>>>>>
21849>>>>>>>
21849>>>>>>>        Get psCollation to sCollation
21850>>>>>>>
21850>>>>>>>        Case Begin
21850>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
21852>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
21853>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
21854>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
21855>>>>>>>
21855>>>>>>>                // Check if database exists
21855>>>>>>>                Send SqlExecDirect of hStmt sSQL
21856>>>>>>>                Get SqlFetch of hStmt to iFetchResult
21857>>>>>>>                Send SqlClose of hStmt
21858>>>>>>>                Send SqlDisconnect of hConnection
21859>>>>>>>                // If database already exists we're out of here!
21859>>>>>>>                // Note that we return True as this is not an error.
21859>>>>>>>                If (iFetchResult > 0) Begin
21861>>>>>>>                    Function_Return True
21862>>>>>>>                End
21862>>>>>>>>
21862>>>>>>>                // Database doesn't exist, create it.
21862>>>>>>>                If (iFetchResult = 0) Begin
21864>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
21865>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
21866>>>>>>>                    If (sCollation <> "") Begin
21868>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
21869>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
21870>>>>>>>                    End
21870>>>>>>>>
21870>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
21871>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
21872>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
21874>>>>>>>                        Function_Return False
21875>>>>>>>                    End
21875>>>>>>>>
21875>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
21875>>>>>>>                    Sleep 1
21876>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
21877>>>>>>>                End
21877>>>>>>>>
21877>>>>>>>                Case Break
21878>>>>>>>
21878>>>>>>>            Case (sDriverID = MDSPgSQL)
21881>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
21881>>>>>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
21882>>>>>>>                Case Break
21883>>>>>>>
21883>>>>>>>            Case (sDriverID = MDSMySQL or (iDbType = 1 and sDriverID = ODBC_DRV_ID))
21886>>>>>>>                // ToDo: How should this be set/checked?
21886>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
21886>>>>>>>//                    Set psCollation to "utf8"
21886>>>>>>>//                End
21886>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
21886>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
21887>>>>>>>                Case Break
21888>>>>>>>
21888>>>>>>>            Case (sDriverID = MDSDB2)
21891>>>>>>>                Case Break
21892>>>>>>>
21892>>>>>>>            Case Else
21892>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
21893>>>>>>>>
21893>>>>>>>        Case End
21893>>>>>>>
21893>>>>>>>        If (Err = False) Begin
21895>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
21896>>>>>>>        End
21896>>>>>>>>
21896>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
21896>>>>>>>        // the one we just created.
21896>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
21898>>>>>>>            Set psDatabase to sDatabase
21899>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
21899>>>>>>>            If (bPermanantly = True) Begin
21901>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
21903>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
21904>>>>>>>                End
21904>>>>>>>>
21904>>>>>>>            End
21904>>>>>>>>
21904>>>>>>>        End
21904>>>>>>>>
21904>>>>>>>
21904>>>>>>>        Function_Return (Err = False)
21905>>>>>>>    End_Function
21906>>>>>>>
21906>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
21906>>>>>>>    // will be used.
21906>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
21908>>>>>>>        Boolean bOK bExists bShowProgress
21908>>>>>>>        String sStatement sDriverID
21908>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
21908>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
21908>>>>>>>        Integer iDbType
21908>>>>>>>
21908>>>>>>>        If (sDatabase = "") Begin
21910>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
21911>>>>>>>>
21911>>>>>>>            Function_Return False
21912>>>>>>>        End
21912>>>>>>>>
21912>>>>>>>        If (sBackupName = "") Begin
21914>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
21915>>>>>>>>
21915>>>>>>>            Function_Return False
21916>>>>>>>        End
21916>>>>>>>>
21916>>>>>>>
21916>>>>>>>        // Create backup-folder if it doesn't exist
21916>>>>>>>        Get vFolderExists sPath to bExists
21917>>>>>>>        If (bExists = False) Begin
21919>>>>>>>            Get vCreateDirectory sPath to bOK
21920>>>>>>>            If (bOK = False) Begin
21922>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
21923>>>>>>>>
21923>>>>>>>                Function_Return False
21924>>>>>>>            End
21924>>>>>>>>
21924>>>>>>>        End
21924>>>>>>>>
21924>>>>>>>        // Make sure the path ends with a back-slash
21924>>>>>>>        If (sPath <> "") Begin
21926>>>>>>>            Get vFolderFormat sPath to sPath
21927>>>>>>>        End
21927>>>>>>>>
21927>>>>>>>
21927>>>>>>>        Get psDriverID to sDriverID
21928>>>>>>>        Get piDbType   to iDbType
21929>>>>>>>        If (num_arguments > 3) Begin
21931>>>>>>>            Move bShowProg to bShowProgress
21932>>>>>>>        End
21932>>>>>>>>
21932>>>>>>>
21932>>>>>>>        Case Begin
21932>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
21934>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
21934>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
21934>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
21935>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
21936>>>>>>>
21936>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
21937>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
21938>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
21939>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
21940>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
21941>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
21942>>>>>>>                Case Break
21943>>>>>>>            Case Else
21943>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
21944>>>>>>>        Case End
21944>>>>>>>
21944>>>>>>>        Function_Return bOK
21945>>>>>>>    End_Function
21946>>>>>>>
21946>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
21948>>>>>>>        Boolean bOK bExists
21948>>>>>>>        String sStatement sDriverID sRetval sPrevious
21948>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
21948>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
21948>>>>>>>        Integer iDbType iRows iFetchResult iColumn
21948>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
21948>>>>>>>        tSQLConnection SQLConnection
21948>>>>>>>        tSQLConnection SQLConnection
21948>>>>>>>
21948>>>>>>>        If (sDatabase = "") Begin
21950>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
21951>>>>>>>>
21951>>>>>>>            Function_Return ""
21952>>>>>>>        End
21952>>>>>>>>
21952>>>>>>>
21952>>>>>>>        Move "" to sRetval
21953>>>>>>>        Get psDriverID to sDriverID
21954>>>>>>>        Get piDbType   to iDbType
21955>>>>>>>
21955>>>>>>>        Case Begin
21955>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
21957>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
21957>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
21958>>>>>>>
21958>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
21959>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
21960>>>>>>>                Get phoSQLManager to hoSQLHandler
21961>>>>>>>
21961>>>>>>>                If (hoSQLHandler <> 0) Begin
21963>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
21964>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
21965>>>>>>>
21965>>>>>>>                    If (hoSQLConnect <> 0) Begin
21967>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
21968>>>>>>>                        If (hstmt <> 0) Begin
21970>>>>>>>                            Send SqlExecDirect of hstmt sStatement
21971>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
21972>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
21973>>>>>>>                            If (iFetchResult <> 0) Begin
21975>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
21976>>>>>>>                            End
21976>>>>>>>>
21976>>>>>>>                            Send SQLClose of hstmt
21977>>>>>>>                        End
21977>>>>>>>>
21977>>>>>>>                        Send SQLDisconnect of hoSQLConnect
21978>>>>>>>                    End
21978>>>>>>>>
21978>>>>>>>                End
21978>>>>>>>>
21978>>>>>>>                Case Break
21979>>>>>>>            Case Else
21979>>>>>>>                If (bSilent = False) Begin
21981>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
21982>>>>>>>                End
21982>>>>>>>>
21982>>>>>>>        Case End
21982>>>>>>>
21982>>>>>>>        Function_Return sRetval
21983>>>>>>>    End_Function
21984>>>>>>>
21984>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
21986>>>>>>>        Boolean bOK bExists bMertechDriver
21986>>>>>>>        String sDriverID sSQL sSQL1 sConnectionID sConnectionString sSet sWith
21986>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
21986>>>>>>>        Handle hConnection hStmt hoSQLManager
21986>>>>>>>        Integer iFetchResult iDbType
21986>>>>>>>
21986>>>>>>>        If (sDatabase = "") Begin
21988>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
21989>>>>>>>>
21989>>>>>>>            Function_Return False
21990>>>>>>>        End
21990>>>>>>>>
21990>>>>>>>
21990>>>>>>>        If (sSQLCollation = "") Begin
21992>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
21993>>>>>>>>
21993>>>>>>>            Function_Return False
21994>>>>>>>        End
21994>>>>>>>>
21994>>>>>>>
21994>>>>>>>        Get psDriverID to sDriverID
21995>>>>>>>        Get piDbType   to iDbType
21996>>>>>>>
21996>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
21997>>>>>>>        If (bMertechDriver = False) Begin
21999>>>>>>>            Get phoSQLManager to hoSQLManager
22000>>>>>>>        End
22000>>>>>>>>
22000>>>>>>>        Else Begin
22001>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
22002>>>>>>>        End
22002>>>>>>>>
22002>>>>>>>
22002>>>>>>>        Get psConnectionID     to sConnectionID
22003>>>>>>>        Get psConnectionString to sConnectionString
22004>>>>>>>        Move 0 to LastErr
22005>>>>>>>
22005>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
22006>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
22007>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
22008>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
22010>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
22011>>>>>>>>
22011>>>>>>>            Function_Return False
22012>>>>>>>        End
22012>>>>>>>>
22012>>>>>>>
22012>>>>>>>        Get SqlOpen of hConnection to hStmt
22013>>>>>>>
22013>>>>>>>        If (hStmt = 0) Begin
22015>>>>>>>            Send SqlDisconnect of hoSQLManager
22016>>>>>>>            Error DFERR_PROGRAM CS_SQLConnectError
22017>>>>>>>>
22017>>>>>>>            Function_Return False
22018>>>>>>>        End
22018>>>>>>>>
22018>>>>>>>
22018>>>>>>>        // Check if collation already exists
22018>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
22019>>>>>>>        // If the current collate is the same as the new; do nothing.
22019>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
22021>>>>>>>            Function_Return True
22022>>>>>>>        End
22022>>>>>>>>
22022>>>>>>>
22022>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
22023>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
22024>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
22025>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
22026>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
22027>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
22028>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
22029>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
22030>>>>>>>
22030>>>>>>>        // MS-SQL Syntax:
22030>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
22030>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
22030>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
22030>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
22031>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
22032>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
22033>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
22033>>>>>>>
22033>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
22034>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
22035>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
22036>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
22038>>>>>>>           Function_Return False
22039>>>>>>>        End
22039>>>>>>>>
22039>>>>>>>
22039>>>>>>>        Function_Return (Err = False)
22040>>>>>>>    End_Function
22041>>>>>>>
22041>>>>>>>    // * Dummy function for the Studio's Code Explorer *
22041>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
22043>>>>>>>        Function_Return False
22044>>>>>>>    End_Function
22045>>>>>>>
22045>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
22045>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
22045>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
22045>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
22045>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
22045>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
22047>>>>>>>        Handle hToTable
22047>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
22047>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
22047>>>>>>>        tSQLConnection SQLConnection
22047>>>>>>>        tSQLConnection SQLConnection
22047>>>>>>>        Integer iPos iMaxRecords
22047>>>>>>>
22047>>>>>>>        Get psDriverID to sDriverID
22048>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
22049>>>>>>>        If (bExists = False) Begin
22051>>>>>>>            Function_Return False
22052>>>>>>>        End
22052>>>>>>>>
22052>>>>>>>
22052>>>>>>>        If (num_arguments > 1) Begin
22054>>>>>>>            Move bCpyDat to bCopyData
22055>>>>>>>        End
22055>>>>>>>>
22055>>>>>>>        Else Begin
22056>>>>>>>            Move False to bCopyData
22057>>>>>>>        End
22057>>>>>>>>
22057>>>>>>>
22057>>>>>>>        Open hTable
22059>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
22062>>>>>>>        If (bOpened = False) Begin
22064>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
22065>>>>>>>>
22065>>>>>>>            Function_Return False
22066>>>>>>>        End
22066>>>>>>>>
22066>>>>>>>        Move 0 to hToTable
22067>>>>>>>
22067>>>>>>>        Move 16711679 to iMaxRecords
22068>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
22071>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
22072>>>>>>>        If (iPos > 0) Begin
22074>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
22075>>>>>>>        End
22075>>>>>>>>
22075>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
22078>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
22079>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
22080>>>>>>>
22080>>>>>>>        If (ghoProgressBar <> 0) Begin
22082>>>>>>>            Send DoAdvance of ghoProgressBar
22083>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
22084>>>>>>>        End
22084>>>>>>>>
22084>>>>>>>
22084>>>>>>>        Move False to Err
22085>>>>>>>
22085>>>>>>>        Structure_Start hToTable DATAFLEX_ID
22086>>>>>>>            Structure_Copy hTable to hToTable
22087>>>>>>>
22087>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
22090>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
22093>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
22096>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
22099>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
22102>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
22103>>>>>>>
22103>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
22105>>>>>>>
22105>>>>>>>        Set Action_Text of ghoStatusPanel to ""
22106>>>>>>>        Move (not(Err)) to bOK
22107>>>>>>>        If (bOK = True and bCopyData = True) Begin
22109>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
22110>>>>>>>        End
22110>>>>>>>>
22110>>>>>>>
22110>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
22111>>>>>>>        If (bMertechDriver = True) Begin
22113>>>>>>>            Open hTable
22115>>>>>>>        End
22115>>>>>>>>
22115>>>>>>>
22115>>>>>>>        // This must be after copying data...
22115>>>>>>>        If (Err = False) Begin
22117>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
22120>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
22123>>>>>>>        End
22123>>>>>>>>
22123>>>>>>>        Move (not(Err)) to bOK
22124>>>>>>>
22124>>>>>>>        Function_Return (bOK = True)
22125>>>>>>>    End_Function
22126>>>>>>>
22126>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
22126>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
22126>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
22128>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
22128>>>>>>>        Integer iDbType
22128>>>>>>>        Boolean bExists
22128>>>>>>>
22128>>>>>>>        Get psDriverID to sDriverID
22129>>>>>>>        Get UtilTableHandleToString hTable to sTableName
22130>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
22131>>>>>>>        If (bExists = True) Begin
22133>>>>>>>            Function_Return False
22134>>>>>>>        End
22134>>>>>>>>
22134>>>>>>>
22134>>>>>>>        Get psDataPathFirstPart to sPath
22135>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
22136>>>>>>>
22136>>>>>>>        Get piDbType to iDbType
22137>>>>>>>        Get _SqlProperTableName sTableName to sTableName
22138>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
22139>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
22140>>>>>>>
22140>>>>>>>        Move False to Err
22141>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
22142>>>>>>>
22142>>>>>>>        Function_Return (Err = False)
22143>>>>>>>    End_Function
22144>>>>>>>
22144>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
22144>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
22144>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
22146>>>>>>>        String sSQLString sPath sCreateTable sDriverID
22146>>>>>>>        Integer iDbType
22146>>>>>>>        Boolean bExists
22146>>>>>>>
22146>>>>>>>        Get psDriverID to sDriverID
22147>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
22148>>>>>>>        If (bExists = True) Begin
22150>>>>>>>            Function_Return False
22151>>>>>>>        End
22151>>>>>>>>
22151>>>>>>>
22151>>>>>>>        Get psDataPathFirstPart to sPath
22152>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
22153>>>>>>>        If (bExists = True) Begin
22155>>>>>>>            // ToDo: What should we do if an .int file already exists?
22155>>>>>>>        End
22155>>>>>>>>
22155>>>>>>>
22155>>>>>>>        Get piDbType to iDbType
22156>>>>>>>        Get _SqlProperTableName sTableName to sTableName
22157>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
22158>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
22159>>>>>>>
22159>>>>>>>        Move False to Err
22160>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
22161>>>>>>>
22161>>>>>>>        Function_Return (Err = False)
22162>>>>>>>    End_Function
22163>>>>>>>
22163>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
22163>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
22163>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
22163>>>>>>>    Function SqlTableRemove Integer hTable Returns Boolean
22165>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
22165>>>>>>>        Integer iRetval iDbType
22165>>>>>>>        Boolean bExists bMertechDriver bOK
22165>>>>>>>
22165>>>>>>>        Get psDriverID to sDriverID
22166>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
22167>>>>>>>        Get UtilTableHandleToString hTable to sTableName
22168>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
22169>>>>>>>        If (bExists = False) Begin
22171>>>>>>>            Function_Return False
22172>>>>>>>        End
22172>>>>>>>>
22172>>>>>>>
22172>>>>>>>        Get psDataPathFirstPart to sPath
22173>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
22174>>>>>>>
22174>>>>>>>        Get piDbType to iDbType
22175>>>>>>>        Get _SqlProperTableName sTableName to sTableName
22176>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
22177>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
22178>>>>>>>
22178>>>>>>>        Move False to Err
22179>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
22180>>>>>>>
22180>>>>>>>        // We also need to remove the cache-file since the table has been changed
22180>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
22181>>>>>>>
22181>>>>>>>        Function_Return (Err = False)
22182>>>>>>>    End_Function
22183>>>>>>>
22183>>>>>>>    // First deletes the data cache file and then drops the passed data table.
22183>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
22185>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
22185>>>>>>>        Integer iRetval iDbType
22185>>>>>>>        Boolean bMertechDriver bOK
22185>>>>>>>
22185>>>>>>>        Get psDriverID to sDriverID
22186>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
22187>>>>>>>        Get psDataPathFirstPart to sPath
22188>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
22189>>>>>>>
22189>>>>>>>        Get piDbType to iDbType
22190>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
22191>>>>>>>        Get psSchema to sSchema
22192>>>>>>>        If (sSchema = "") Begin
22194>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
22195>>>>>>>        End
22195>>>>>>>>
22195>>>>>>>        Move (Uppercase(sTableName)) to sVal
22196>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
22198>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
22199>>>>>>>        End
22199>>>>>>>>
22199>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
22200>>>>>>>
22200>>>>>>>        Move False to Err
22201>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
22202>>>>>>>
22202>>>>>>>        // We also need to remove the cache-file since the table has been changed
22202>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
22203>>>>>>>
22203>>>>>>>        Function_Return (Err = False)
22204>>>>>>>    End_Function
22205>>>>>>>
22205>>>>>>>    // *** Sql View Messages ***
22205>>>>>>>
22205>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
22205>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
22207>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
22207>>>>>>>        Integer iRetval
22207>>>>>>>        Boolean bMertechDriver bOK
22207>>>>>>>
22207>>>>>>>        Get psDriverID to sDriverID
22208>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
22209>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
22210>>>>>>>
22210>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
22211>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
22212>>>>>>>        Set psSQLStatementString to sSQLString
22213>>>>>>>
22213>>>>>>>        // As we don't check if the view exist or not, it might happen
22213>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
22213>>>>>>>        Move False to Err
22214>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
22215>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
22216>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
22217>>>>>>>        Move 0 to LastErr
22218>>>>>>>
22218>>>>>>>        // We also need to remove the cache-file since the table has been changed
22218>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
22219>>>>>>>
22219>>>>>>>        Function_Return (Err = False)
22220>>>>>>>    End_Function
22221>>>>>>>
22221>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
22223>>>>>>>        Boolean bOK
22223>>>>>>>        Integer iDbType
22223>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
22223>>>>>>>
22223>>>>>>>        Get psDriverID to sDriverID
22224>>>>>>>        Get piDbType   to iDbType
22225>>>>>>>
22225>>>>>>>        Case Begin
22225>>>>>>>            Case (iDbType = EN_DbTypeDB2)
22227>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
22228>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
22229>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
22230>>>>>>>            Break
22231>>>>>>>
22231>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
22234>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
22235>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
22236>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
22237>>>>>>>            Break
22238>>>>>>>
22238>>>>>>>            Case (iDbType = EN_DbTypeOracle)
22241>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
22242>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
22243>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
22244>>>>>>>            Break
22245>>>>>>>
22245>>>>>>>            Case (iDbType = EN_DbTypePostgre)
22248>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
22249>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
22250>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
22251>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
22252>>>>>>>            Break
22253>>>>>>>
22253>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
22256>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
22257>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
22258>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
22259>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
22260>>>>>>>            Break
22261>>>>>>>        Case End
22261>>>>>>>
22261>>>>>>>        Move False to Err
22262>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
22263>>>>>>>        Move (Err = False) to bOK
22264>>>>>>>
22264>>>>>>>        Function_Return bOK
22265>>>>>>>    End_Function
22266>>>>>>>
22266>>>>>>>    // * Dummy function for the Studio's Code Explorer *
22266>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
22268>>>>>>>        Function_Return False
22269>>>>>>>    End_Function
22270>>>>>>>
22270>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
22270>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
22272>>>>>>>        Integer iLength iDecimals
22272>>>>>>>        String sColumnValue
22272>>>>>>>        String sTableName sDriverID
22272>>>>>>>        Boolean bOK bInitializeValue
22272>>>>>>>
22272>>>>>>>        Get psDriverID to sDriverID
22273>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22274>>>>>>>        If (bOK = False) Begin
22276>>>>>>>            Function_Return False
22277>>>>>>>        End
22277>>>>>>>>
22277>>>>>>>
22277>>>>>>>        Get UtilTableHandleToString hTable to sTableName
22278>>>>>>>        If (sTableName = "") Begin
22280>>>>>>>            Function_Return False
22281>>>>>>>        End
22281>>>>>>>>
22281>>>>>>>
22281>>>>>>>        If (num_arguments > 3) Begin
22283>>>>>>>            Move iLen     to iLength
22284>>>>>>>            Move iDec     to iDecimals
22285>>>>>>>            Move bInitVal to bInitializeValue
22286>>>>>>>            Move sColVal  to sColumnValue
22287>>>>>>>        End
22287>>>>>>>>
22287>>>>>>>
22287>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
22288>>>>>>>
22288>>>>>>>        Function_Return (bOK = True)
22289>>>>>>>    End_Function
22290>>>>>>>
22290>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
22290>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
22292>>>>>>>        Integer iDbType iLength iDecimals iDriver
22292>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
22292>>>>>>>        String sDriverID sNotNull
22292>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
22292>>>>>>>        Handle hTable
22292>>>>>>>
22292>>>>>>>        Get psDriverID to sDriverID
22293>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22294>>>>>>>        If (bOK = False) Begin
22296>>>>>>>            Function_Return True
22297>>>>>>>        End
22297>>>>>>>>
22297>>>>>>>
22297>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
22298>>>>>>>        If (hTable = 0) Begin
22300>>>>>>>            Get NextFreeFilelistSlot to hTable
22301>>>>>>>        End
22301>>>>>>>>
22301>>>>>>>
22301>>>>>>>        Get piDbType to iDbType
22302>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
22302>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
22303>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
22305>>>>>>>            Function_Return True
22306>>>>>>>        End
22306>>>>>>>>
22306>>>>>>>
22306>>>>>>>        Get DriverIndex sDriverID to iDriver
22307>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
22308>>>>>>>        If (bIsMertechDriver = False) Begin
22310>>>>>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
22313>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
22316>>>>>>>        End
22316>>>>>>>>
22316>>>>>>>
22316>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
22317>>>>>>>        If (num_arguments > 3) Begin
22319>>>>>>>            Move iLen     to iLength
22320>>>>>>>            Move iDec     to iDecimals
22321>>>>>>>            Move bInitVal to bInitializeValue
22322>>>>>>>            Move sColVal  to sColumnValue
22323>>>>>>>        End
22323>>>>>>>>
22323>>>>>>>
22323>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
22324>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
22325>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
22326>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
22327>>>>>>>
22327>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
22328>>>>>>>        If (bFixed = False) Begin
22330>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
22331>>>>>>>        End
22331>>>>>>>>
22331>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
22332>>>>>>>
22332>>>>>>>        Move False to Err
22333>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
22334>>>>>>>
22334>>>>>>>        If (bInitializeValue = True and Err = False) Begin
22336>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
22337>>>>>>>        End
22337>>>>>>>>
22337>>>>>>>
22337>>>>>>>        If (Err = False) Begin
22339>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
22340>>>>>>>        End
22340>>>>>>>>
22340>>>>>>>
22340>>>>>>>        Move (not(Err)) to bRetval
22341>>>>>>>
22341>>>>>>>        // We also need to remove the cache-file since the table has been changed
22341>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
22342>>>>>>>        If (bIsMertechDriver = False) Begin
22344>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
22347>>>>>>>        End
22347>>>>>>>>
22347>>>>>>>        Function_Return bRetval
22348>>>>>>>    End_Function
22349>>>>>>>
22349>>>>>>>    // To update all current rows for a table column with a common value.
22349>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
22351>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
22351>>>>>>>        Boolean bRetval bSQLDriver
22351>>>>>>>        Integer iCurrErr iDbType
22351>>>>>>>
22351>>>>>>>        Move False to bRetval
22352>>>>>>>        Get piDbType to iDbType
22353>>>>>>>        Get psDriverID to sDriverID
22354>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
22355>>>>>>>        If (bSQLDriver = False) Begin
22357>>>>>>>            Function_Return bRetval
22358>>>>>>>        End
22358>>>>>>>>
22358>>>>>>>        Get UtilTableHandleToString hTable to sTableName
22359>>>>>>>
22359>>>>>>>        Move Err to iCurrErr
22360>>>>>>>        Move False to Err
22361>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
22362>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
22363>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
22364>>>>>>>        If (sDriverID = MDSMySQL) Begin
22366>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
22367>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
22368>>>>>>>        End
22368>>>>>>>>
22368>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
22368>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
22370>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
22371>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
22372>>>>>>>        End
22372>>>>>>>>
22372>>>>>>>        Else Begin
22373>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
22374>>>>>>>        End
22374>>>>>>>>
22374>>>>>>>
22374>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
22375>>>>>>>        Move (Err = False) to bRetval
22376>>>>>>>        Move iCurrErr to Err
22377>>>>>>>
22377>>>>>>>        Function_Return bRetval
22378>>>>>>>    End_Function
22379>>>>>>>
22379>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
22379>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
22379>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
22381>>>>>>>        String sDriverID sTableName
22381>>>>>>>        Boolean bOK
22381>>>>>>>
22381>>>>>>>        Get psDriverID to sDriverID
22382>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22383>>>>>>>        If (bOK = False) Begin
22385>>>>>>>            Function_Return False
22386>>>>>>>        End
22386>>>>>>>>
22386>>>>>>>
22386>>>>>>>        Get UtilTableHandleToString hTable to sTableName
22387>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
22388>>>>>>>
22388>>>>>>>        Function_Return (Err = False)
22389>>>>>>>    End_Function
22390>>>>>>>
22390>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
22390>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
22390>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
22390>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
22392>>>>>>>        Integer iDbType iLength iDecimals
22392>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
22392>>>>>>>        Boolean bExists bOK bFixed
22392>>>>>>>        Handle hTable
22392>>>>>>>
22392>>>>>>>        Get psDriverID to sDriverID
22393>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22394>>>>>>>        If (bOK = False) Begin
22396>>>>>>>            Function_Return False
22397>>>>>>>        End
22397>>>>>>>>
22397>>>>>>>
22397>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
22398>>>>>>>        If (hTable = 0) Begin
22400>>>>>>>            Get NextFreeFilelistSlot to hTable
22401>>>>>>>        End
22401>>>>>>>>
22401>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
22402>>>>>>>        If (bExists = False) Begin
22404>>>>>>>            Function_Return False
22405>>>>>>>        End
22405>>>>>>>>
22405>>>>>>>
22405>>>>>>>        If (num_arguments > 3) Begin
22407>>>>>>>            Move iLen to iLength
22408>>>>>>>        End
22408>>>>>>>>
22408>>>>>>>        If (num_arguments > 4) Begin
22410>>>>>>>            Move iDec to iDecimals
22411>>>>>>>        End
22411>>>>>>>>
22411>>>>>>>
22411>>>>>>>        Get piDbType to iDbType
22412>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
22413>>>>>>>
22413>>>>>>>        Move False to Err
22414>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
22415>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
22416>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
22417>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
22418>>>>>>>
22418>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
22419>>>>>>>        If (bFixed = False) Begin
22421>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
22422>>>>>>>        End
22422>>>>>>>>
22422>>>>>>>
22422>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
22423>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
22424>>>>>>>
22424>>>>>>>        // We also need to remove the cache-file since the table has been changed
22424>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
22425>>>>>>>
22425>>>>>>>        Function_Return (Err = False)
22426>>>>>>>    End_Function
22427>>>>>>>
22427>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
22429>>>>>>>        Boolean bOK bErr bIsSQLDriver
22429>>>>>>>        String sDriverID
22429>>>>>>>        Integer iDataType
22429>>>>>>>
22429>>>>>>>        Get psDriverID to sDriverID
22430>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
22431>>>>>>>        If (bIsSQLDriver = False) Begin
22433>>>>>>>            Function_Return False
22434>>>>>>>        End
22434>>>>>>>>
22434>>>>>>>
22434>>>>>>>        Move Err to bErr
22435>>>>>>>        Move False to bErr
22436>>>>>>>
22436>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
22436>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
22436>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
22437>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
22440>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
22442>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
22443>>>>>>>        End
22443>>>>>>>>
22443>>>>>>>
22443>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
22446>>>>>>>        Move (not(Err)) to bOK
22447>>>>>>>        Move bErr to Err
22448>>>>>>>
22448>>>>>>>        Function_Return bOK
22449>>>>>>>    End_Function
22450>>>>>>>
22450>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
22452>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
22452>>>>>>>        String sDriverID
22452>>>>>>>
22452>>>>>>>        Get psDriverID to sDriverID
22453>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
22454>>>>>>>        If (bIsSQLDriver = False) Begin
22456>>>>>>>            Function_Return False
22457>>>>>>>        End
22457>>>>>>>>
22457>>>>>>>
22457>>>>>>>        Move Err to bErr
22458>>>>>>>        Move False to bErr
22459>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
22462>>>>>>>        If (bNullable = bCurrentState) Begin
22464>>>>>>>            Function_Return True
22465>>>>>>>        End
22465>>>>>>>>
22465>>>>>>>
22465>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
22468>>>>>>>        If (bOpen = False) Begin
22470>>>>>>>            Get AutoConnectionIDLogin to bOK
22471>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
22472>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
22473>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
22474>>>>>>>            Open hTable
22476>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
22477>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
22478>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
22479>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
22482>>>>>>>        End
22482>>>>>>>>
22482>>>>>>>        If (bOpen = True) Begin
22484>>>>>>>            Structure_Start hTable sDriverID
22485>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
22488>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
22489>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
22491>>>>>>>            Set Action_Text of ghoStatusPanel to ""
22492>>>>>>>        End
22492>>>>>>>>
22492>>>>>>>
22492>>>>>>>        Move (not(Err)) to bOK
22493>>>>>>>        Move bErr to Err
22494>>>>>>>
22494>>>>>>>        Function_Return bOK
22495>>>>>>>    End_Function
22496>>>>>>>
22496>>>>>>>    // Drop column by its table handle
22496>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
22498>>>>>>>        String sDriverID sTableName
22498>>>>>>>        Boolean bOK
22498>>>>>>>
22498>>>>>>>        Get psDriverID to sDriverID
22499>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22500>>>>>>>        If (bOK = False) Begin
22502>>>>>>>            Function_Return False
22503>>>>>>>        End
22503>>>>>>>>
22503>>>>>>>
22503>>>>>>>        Get UtilTableHandleToString hTable to sTableName
22504>>>>>>>        If (sTableName = "") Begin
22506>>>>>>>            Function_Return False
22507>>>>>>>        End
22507>>>>>>>>
22507>>>>>>>
22507>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
22508>>>>>>>
22508>>>>>>>        Function_Return (bOK = True)
22509>>>>>>>    End_Function
22510>>>>>>>
22510>>>>>>>    // Drop column by its table name as a string.
22510>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
22512>>>>>>>        Integer iDbType iDriver
22512>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
22512>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
22512>>>>>>>        Handle hTable
22512>>>>>>>
22512>>>>>>>        Get psDriverID to sDriverID
22513>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22514>>>>>>>        If (bOK = False) Begin
22516>>>>>>>            Function_Return False
22517>>>>>>>        End
22517>>>>>>>>
22517>>>>>>>
22517>>>>>>>        Get DriverIndex sDriverID to iDriver
22518>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
22521>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
22524>>>>>>>
22524>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
22525>>>>>>>        If (hTable <> 0) Begin
22527>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
22528>>>>>>>            If (bExists = False) Begin
22530>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
22533>>>>>>>                Function_Return False
22534>>>>>>>            End
22534>>>>>>>>
22534>>>>>>>        End
22534>>>>>>>>
22534>>>>>>>
22534>>>>>>>        Get piDbType to iDbType
22535>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
22537>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
22538>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
22539>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
22542>>>>>>>            Function_Return bOK
22543>>>>>>>        End
22543>>>>>>>>
22543>>>>>>>
22543>>>>>>>        Move False to Err
22544>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
22545>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
22546>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
22547>>>>>>>
22547>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
22548>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
22549>>>>>>>        Move (not(Err)) to bRetval
22550>>>>>>>
22550>>>>>>>        // We also need to remove the cache-file since the table has been changed
22550>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
22551>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
22554>>>>>>>
22554>>>>>>>        Function_Return bRetval
22555>>>>>>>    End_Function
22556>>>>>>>
22556>>>>>>>    // Rename a field/column by table handle (filelist number)
22556>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
22558>>>>>>>        String sDriverID sTableName
22558>>>>>>>        Boolean bOK
22558>>>>>>>
22558>>>>>>>        Get psDriverID to sDriverID
22559>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22560>>>>>>>        If (bOK = False) Begin
22562>>>>>>>            Function_Return False
22563>>>>>>>        End
22563>>>>>>>>
22563>>>>>>>
22563>>>>>>>        Get UtilTableHandleToString hTable to sTableName
22564>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
22565>>>>>>>
22565>>>>>>>        Function_Return (Err = False)
22566>>>>>>>    End_Function
22567>>>>>>>
22567>>>>>>>    // Rename a field/column by table name.
22567>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
22569>>>>>>>        Integer iDbType iDataType
22569>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
22569>>>>>>>        Boolean bOK bRetval
22569>>>>>>>        Handle hTable
22569>>>>>>>
22569>>>>>>>        Move sTableName to sOrgTableName
22570>>>>>>>        Get psDriverID to sDriverID
22571>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22572>>>>>>>        If (bOK = False) Begin
22574>>>>>>>            Function_Return False
22575>>>>>>>        End
22575>>>>>>>>
22575>>>>>>>
22575>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
22576>>>>>>>        If (sVal = "") Begin
22578>>>>>>>            Function_Return False
22579>>>>>>>        End
22579>>>>>>>>
22579>>>>>>>
22579>>>>>>>        Get piDbType to iDbType
22580>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
22581>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
22582>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
22583>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
22584>>>>>>>
22584>>>>>>>        Case Begin
22584>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
22586>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
22587>>>>>>>                Case Break
22588>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
22588>>>>>>>            Case (iDbType = EN_dbTypeOracle)
22591>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
22592>>>>>>>                Case Break
22593>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
22593>>>>>>>            Case (iDbType = EN_dbTypeDB2)
22596>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
22597>>>>>>>                Case Break
22598>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
22598>>>>>>>            Case (iDbType = EN_dbTypePostgre)
22601>>>>>>>                Move sOrgTableName to sTableName
22602>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
22603>>>>>>>                Case Break
22604>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
22607>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
22607>>>>>>>                Move sOrgTableName to sTableName
22608>>>>>>>                Get psDatabase to sDatabase
22609>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
22610>>>>>>>                If (hTable = 0) Begin
22612>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
22613>>>>>>>                    If (bOK = False) Begin
22615>>>>>>>                        Function_Return False
22616>>>>>>>                    End
22616>>>>>>>>
22616>>>>>>>                    Get NextFreeFilelistSlot to hTable
22617>>>>>>>                End
22617>>>>>>>>
22617>>>>>>>                Else Begin
22618>>>>>>>                    Open hTable
22620>>>>>>>                End
22620>>>>>>>>
22620>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
22621>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
22622>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
22623>>>>>>>                Case Break
22624>>>>>>>            Case Else
22624>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
22625>>>>>>>        Case End
22625>>>>>>>
22625>>>>>>>        Move False to Err
22626>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
22627>>>>>>>        Move (Err = False) to bRetval
22628>>>>>>>        // We also need to remove the cache-file since the table has been changed
22628>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
22629>>>>>>>
22629>>>>>>>        Function_Return bRetval
22630>>>>>>>    End_Function
22631>>>>>>>
22631>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
22633>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
22633>>>>>>>        Boolean bMertechDriver
22633>>>>>>>        Integer iNumCols iCount iDataType
22633>>>>>>>        String sValue
22633>>>>>>>
22633>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
22634>>>>>>>        If (bMertechDriver = False) Begin
22636>>>>>>>            Get phoSQLManager to hoSQLHandler
22637>>>>>>>        End
22637>>>>>>>>
22637>>>>>>>        Else Begin
22638>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
22639>>>>>>>        End
22639>>>>>>>>
22639>>>>>>>
22639>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
22640>>>>>>>        If (hSQLConnect <> 0) Begin
22642>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
22643>>>>>>>            If (hStmt <> 0) Begin
22645>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
22646>>>>>>>
22646>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
22647>>>>>>>                For iCount from 1 to iNumCols
22653>>>>>>>>
22653>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
22654>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
22656>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
22657>>>>>>>                        Move iNumCols to iCount // We're out of here
22658>>>>>>>                    End
22658>>>>>>>>
22658>>>>>>>                Loop
22659>>>>>>>>
22659>>>>>>>
22659>>>>>>>                Send SQLClose of hStmt
22660>>>>>>>            End
22660>>>>>>>>
22660>>>>>>>            Send SQLDisconnect of hSQLConnect
22661>>>>>>>        End
22661>>>>>>>>
22661>>>>>>>
22661>>>>>>>        Function_Return iDataType
22662>>>>>>>    End_Function
22663>>>>>>>
22663>>>>>>>    // * Dummy function for the Studio's Code Explorer *
22663>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
22665>>>>>>>        Function_Return False
22666>>>>>>>    End_Function
22667>>>>>>>
22667>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
22669>>>>>>>        String sConnectionString sMessage
22669>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
22669>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
22669>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
22672>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
22672>>>>>>>        TimeSpan tsQuery tsFetch
22672>>>>>>>        tSqlErrorArray aSqlErrorArray
22672>>>>>>>        tSqlErrorArray aSqlErrorArray
22672>>>>>>>        Boolean bOK bMertechDriver bShowProgress
22672>>>>>>>        tSQLConnection SQLConnection
22672>>>>>>>        tSQLConnection SQLConnection
22672>>>>>>>
22672>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
22673>>>>>>>        If (bOK = False) Begin
22675>>>>>>>            Procedure_Return
22676>>>>>>>        End
22676>>>>>>>>
22676>>>>>>>
22676>>>>>>>        If (num_arguments > 2) Begin
22678>>>>>>>            Move bShowProgr to bShowProgress
22679>>>>>>>        End
22679>>>>>>>>
22679>>>>>>>
22679>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
22680>>>>>>>
22680>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
22681>>>>>>>        If (bMertechDriver = True) Begin
22683>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
22684>>>>>>>        End
22684>>>>>>>>
22684>>>>>>>        If (bMertechDriver = False) Begin
22686>>>>>>>            Get phoSQLManager to hoSqlHandler
22687>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
22688>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
22689>>>>>>>        End
22689>>>>>>>>
22689>>>>>>>
22689>>>>>>>        If (hoSQLConnect <> 0) Begin
22691>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
22692>>>>>>>            If (hoStmt <> 0) Begin
22694>>>>>>>                // record starting date/time stamp
22694>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
22695>>>>>>>                // turn on error handling if enabled
22695>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
22697>>>>>>>                    Set pbSqlError to False
22698>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
22699>>>>>>>                    Move Error_Object_Id to hoError
22700>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
22702>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
22703>>>>>>>                    End
22703>>>>>>>>
22703>>>>>>>                    Else Begin
22704>>>>>>>                        Move Self to Error_Object_Id
22705>>>>>>>                    End
22705>>>>>>>>
22705>>>>>>>                End
22705>>>>>>>>
22705>>>>>>>
22705>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
22705>>>>>>>                Set psSQLStatementString to sStmt
22706>>>>>>>                Send Cursor_Wait of Cursor_Control
22707>>>>>>>                Send SqlExecDirect of hoStmt sStmt
22708>>>>>>>                Send Cursor_Ready of Cursor_Control
22709>>>>>>>
22709>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
22711>>>>>>>                    Move hoError to Error_Object_Id
22712>>>>>>>                End
22712>>>>>>>>
22712>>>>>>>
22712>>>>>>>                Move 0 to iMsgs
22713>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
22713>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
22713>>>>>>>                If (bMertechDriver = False) Begin
22715>>>>>>>                    Move Err to iErr
22716>>>>>>>                    Move LastErr to iLastErr
22717>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
22718>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
22719>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
22720>>>>>>>                    Send _SqlColumnInfo hoStmt
22721>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
22722>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
22723>>>>>>>                    Repeat
22723>>>>>>>>
22723>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
22724>>>>>>>                        If (iFetchResult <> 0) Begin
22726>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
22727>>>>>>>                        End
22727>>>>>>>>
22727>>>>>>>                    Until (iFetchResult = 0)
22729>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
22730>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
22731>>>>>>>                    Move iErr to Err
22732>>>>>>>                    Move iLastErr to LastErr
22733>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
22734>>>>>>>                End
22734>>>>>>>>
22734>>>>>>>
22734>>>>>>>                Set piRows    to iRows
22735>>>>>>>                Set piRowType to iRowType
22736>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
22737>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
22738>>>>>>>
22738>>>>>>>                If (iMsgs <> 0) Begin
22740>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
22742>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
22743>>>>>>>                    End
22743>>>>>>>>
22743>>>>>>>                    For i from 1 to iMsgs
22749>>>>>>>>
22749>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
22750>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
22751>>>>>>>                        If (bShowProgress = True) Begin
22753>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
22755>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
22756>>>>>>>                            End
22756>>>>>>>>
22756>>>>>>>                            Else Begin
22757>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
22759>>>>>>>                            End
22759>>>>>>>>
22759>>>>>>>                        End
22759>>>>>>>>
22759>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
22760>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
22761>>>>>>>                    Loop
22762>>>>>>>>
22762>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
22764>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
22765>>>>>>>                    End
22765>>>>>>>>
22765>>>>>>>                    Set paQueryMessages to sMsg
22766>>>>>>>                End
22766>>>>>>>>
22766>>>>>>>                Else Begin
22767>>>>>>>                    If (bShowProgress = True) Begin
22769>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
22770>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
22772>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
22773>>>>>>>                            Decrement iMsgs
22774>>>>>>>                            For i from 0 to iMsgs
22780>>>>>>>>
22780>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
22783>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
22786>>>>>>>                            Loop
22787>>>>>>>>
22787>>>>>>>                        End
22787>>>>>>>>
22787>>>>>>>                    End
22787>>>>>>>>
22787>>>>>>>                End
22787>>>>>>>>
22787>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
22788>>>>>>>            End
22788>>>>>>>>
22788>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
22789>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
22790>>>>>>>            Set ptsQueryExec to tsQuery
22791>>>>>>>            Set ptsFetchResults to tsFetch
22792>>>>>>>            Send SqlClose of hoStmt
22793>>>>>>>        End
22793>>>>>>>>
22793>>>>>>>
22793>>>>>>>        Send SqlDisconnect of hoSQLConnect
22794>>>>>>>    End_Procedure
22795>>>>>>>
22795>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
22795>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
22795>>>>>>>    // Returns False if no error occured.
22795>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
22797>>>>>>>        Boolean bOK bShowProgress
22797>>>>>>>        tSQLScriptArray SQLScriptArray
22797>>>>>>>        tSQLScriptArray SQLScriptArray
22797>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
22797>>>>>>>        TimeSpan tsTotalTime
22797>>>>>>>
22797>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
22798>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
22799>>>>>>>        If (SQLScriptArray.bError = True) Begin
22801>>>>>>>            Function_Return False
22802>>>>>>>        End
22802>>>>>>>>
22802>>>>>>>
22802>>>>>>>        If (num_arguments > 3) Begin
22804>>>>>>>            Move bShowProgr to bShowProgress
22805>>>>>>>        End
22805>>>>>>>>
22805>>>>>>>
22805>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
22806>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
22807>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
22808>>>>>>>
22808>>>>>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
22810>>>>>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
22811>>>>>>>>
22811>>>>>>>        End
22811>>>>>>>>
22811>>>>>>>
22811>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
22812>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
22813>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
22814>>>>>>>
22814>>>>>>>        Function_Return bOK
22815>>>>>>>    End_Function
22816>>>>>>>
22816>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
22816>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
22816>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
22816>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
22818>>>>>>>        Integer iChannel iArgumentSize iCount
22818>>>>>>>        Number nByteCount
22818>>>>>>>        String sSQLScript
22818>>>>>>>        tSQLScriptArray SqlScriptArray
22818>>>>>>>        tSQLScriptArray SqlScriptArray
22818>>>>>>>        UChar[] uCharData
22819>>>>>>>
22819>>>>>>>        Move False to Err
22820>>>>>>>        Get Seq_New_Channel to iChannel
22821>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
22823>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
22824>>>>>>>>
22824>>>>>>>            Move True to SqlScriptArray.bError
22825>>>>>>>            Function_Return SqlScriptArray
22826>>>>>>>        End
22826>>>>>>>>
22826>>>>>>>
22826>>>>>>>        // First decide the size of the script
22826>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
22828>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
22830>>>>>>>        Close_Input channel iChannel
22832>>>>>>>
22832>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
22833>>>>>>>        If (nByteCount  < 1) Begin
22835>>>>>>>            Send Seq_Release_Channel iChannel
22836>>>>>>>            Move True to SqlScriptArray.bError
22837>>>>>>>            Function_Return SqlScriptArray
22838>>>>>>>        End
22838>>>>>>>>
22838>>>>>>>
22838>>>>>>>        // If necessary change the string argument_size
22838>>>>>>>        Get_Argument_Size to iArgumentSize
22839>>>>>>>        If (nByteCount >= iArgumentSize) Begin
22841>>>>>>>            Move (nByteCount + 2048) to nByteCount
22842>>>>>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
22843>>>>>>>>
22843>>>>>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
22844>>>>>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
22845>>>>>>>        End
22845>>>>>>>>
22845>>>>>>>        Else Begin
22846>>>>>>>            Move False to SqlScriptArray.bArgumentSizeChanged
22847>>>>>>>        End
22847>>>>>>>>
22847>>>>>>>
22847>>>>>>>        // Read the script file from memory line-by-line
22847>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
22849>>>>>>>            Move 0 to iCount
22850>>>>>>>            Repeat
22850>>>>>>>>
22850>>>>>>>                Readln channel iChannel sSQLScript
22852>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
22853>>>>>>>                Increment iCount
22854>>>>>>>            Until (SeqEof = True)
22856>>>>>>>        Close_Input channel iChannel
22858>>>>>>>        Send Seq_Release_Channel iChannel
22859>>>>>>>
22859>>>>>>>        // Finally "sanitize" the script by removing all comments.
22859>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
22860>>>>>>>
22860>>>>>>>        Function_Return SqlScriptArray
22861>>>>>>>    End_Function
22862>>>>>>>
22862>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
22864>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
22864>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
22864>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
22864>>>>>>>        String[] sMsg aSQLQueryMessages
22866>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
22866>>>>>>>        TimeSpan tsQuery
22866>>>>>>>        tSqlErrorArray aSqlErrorArray
22866>>>>>>>        tSqlErrorArray aSqlErrorArray
22866>>>>>>>        tSQLConnection SQLConnection
22866>>>>>>>        tSQLConnection SQLConnection
22866>>>>>>>        Boolean bMertechDriver bShowProgress
22866>>>>>>>
22866>>>>>>>        If (num_arguments > 4) Begin
22868>>>>>>>            Move bShowProgr to bShowProgress
22869>>>>>>>        End
22869>>>>>>>>
22869>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
22870>>>>>>>        If (bMertechDriver = False) Begin
22872>>>>>>>            Get phoSQLManager to hoSql
22873>>>>>>>        End
22873>>>>>>>>
22873>>>>>>>        Else Begin
22874>>>>>>>            Get _MertechSQLManagerHandle to hoSql
22875>>>>>>>        End
22875>>>>>>>>
22875>>>>>>>
22875>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
22876>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
22876>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
22876>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
22876>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
22876>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
22876>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
22876>>>>>>>        Get piChunkMax to iChunkMax
22877>>>>>>>        Move 0 to iChunkCounter
22878>>>>>>>        Move "" to sStmt
22879>>>>>>>
22879>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
22880>>>>>>>        Move (Character(13) + Character(10)) to sCR
22881>>>>>>>
22881>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
22882>>>>>>>
22882>>>>>>>        If (bMertechDriver = True) Begin
22884>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
22885>>>>>>>        End
22885>>>>>>>>
22885>>>>>>>        If (bMertechDriver = False) Begin
22887>>>>>>>            Get phoSQLManager  to hoSQL
22888>>>>>>>            If (sDriverID = ODBC_DRV_ID) Begin
22890>>>>>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
22892>>>>>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
22893>>>>>>>                    If (iPos > 0) Begin
22895>>>>>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
22896>>>>>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
22897>>>>>>>                    End
22897>>>>>>>>
22897>>>>>>>                End
22897>>>>>>>>
22897>>>>>>>            End
22897>>>>>>>>
22897>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
22898>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
22899>>>>>>>        End
22899>>>>>>>>
22899>>>>>>>
22899>>>>>>>        If (hoSQLConnect <> 0) Begin
22901>>>>>>>            Move False to Err
22902>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
22903>>>>>>>            If (hoStmt <> 0) Begin
22905>>>>>>>
22905>>>>>>>                // If the embedded resource should be written as a script file to disk:
22905>>>>>>>                If (bCreateScriptFile = True) Begin
22907>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
22908>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
22909>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
22910>>>>>>>                    Get Seq_New_Channel to iOut
22911>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
22913>>>>>>>                        Direct_Output channel iOut sExportFile
22915>>>>>>>                    End
22915>>>>>>>>
22915>>>>>>>                End
22915>>>>>>>>
22915>>>>>>>
22915>>>>>>>                // Record starting date/time stamp
22915>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
22916>>>>>>>                // Turn on error handling if enabled
22916>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
22918>>>>>>>                    Set pbSqlError to False
22919>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
22920>>>>>>>                    Move Error_Object_Id to hoError
22921>>>>>>>                    Move Self to Error_Object_Id
22922>>>>>>>                End
22922>>>>>>>>
22922>>>>>>>
22922>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
22923>>>>>>>                Decrement iRows
22924>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
22926>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
22927>>>>>>>                End
22927>>>>>>>>
22927>>>>>>>
22927>>>>>>>                For iCount from 0 to iRows
22933>>>>>>>>
22933>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
22934>>>>>>>
22934>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
22936>>>>>>>                        If (sSQLVal <> "") Begin
22938>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
22939>>>>>>>                        End
22939>>>>>>>>
22939>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
22940>>>>>>>                    End
22940>>>>>>>>
22940>>>>>>>
22940>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
22940>>>>>>>                    // or if at the very end of the script.
22940>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
22942>>>>>>>
22942>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
22942>>>>>>>                        // instead of all in one go.
22942>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
22943>>>>>>>
22943>>>>>>>                        If (bCreateScriptFile = True) Begin
22945>>>>>>>                            Write channel iOut sStmt
22947>>>>>>>                        End
22947>>>>>>>>
22947>>>>>>>                        Move "" to sStmt
22948>>>>>>>                        Move 0 to iChunkCounter
22949>>>>>>>                    End
22949>>>>>>>>
22949>>>>>>>                    Increment iChunkCounter
22950>>>>>>>                Loop
22951>>>>>>>>
22951>>>>>>>
22951>>>>>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
22951>>>>>>>                //       so not used for now.
22951>>>>>>>                If (bMertechDriver = False) Begin
22953>>>>>>>                    Repeat
22953>>>>>>>>
22953>>>>>>>                        If (pbHandleQueryErrors(Self)) Begin
22955>>>>>>>                            Move hoError to Error_Object_Id
22956>>>>>>>                        End
22956>>>>>>>>
22956>>>>>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
22957>>>>>>>
22957>>>>>>>                        Send _SqlColumnInfo hoStmt
22958>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
22959>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
22960>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
22961>>>>>>>                        Set piRows    to iRows
22962>>>>>>>                        Set piRowType to iRowType
22963>>>>>>>
22963>>>>>>>                        If (iMsgs <> 0) Begin
22965>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
22967>>>>>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
22968>>>>>>>                            End
22968>>>>>>>>
22968>>>>>>>                            For i from 1 to iMsgs
22974>>>>>>>>
22974>>>>>>>                                Get SqlGetMessage of hoStmt i to sMessage
22975>>>>>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
22976>>>>>>>                                If (bShowProgress = True) Begin
22978>>>>>>>                                    If (Active_State(ghoStatusPanel)) Begin
22980>>>>>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
22981>>>>>>>                                    End
22981>>>>>>>>
22981>>>>>>>                                    Else Begin
22982>>>>>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
22984>>>>>>>                                    End
22984>>>>>>>>
22984>>>>>>>                                End
22984>>>>>>>>
22984>>>>>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
22985>>>>>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
22986>>>>>>>                            Loop
22987>>>>>>>>
22987>>>>>>>
22987>>>>>>>
22987>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
22989>>>>>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
22990>>>>>>>                            End
22990>>>>>>>>
22990>>>>>>>                            Set paQueryMessages to sMsg
22991>>>>>>>                        End
22991>>>>>>>>
22991>>>>>>>
22991>>>>>>>                        Get SQLNextResultSet of hoStmt to iNextSet
22992>>>>>>>                    Until (iNextSet = 0)
22994>>>>>>>                End
22994>>>>>>>>
22994>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
22995>>>>>>>            End
22995>>>>>>>>
22995>>>>>>>
22995>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
22996>>>>>>>            Set ptsQueryExec to tsQuery
22997>>>>>>>            Send SqlClose of hoStmt
22998>>>>>>>
22998>>>>>>>            If (bCreateScriptFile = True) Begin
23000>>>>>>>                Close_Output channel iOut
23002>>>>>>>                Send Seq_Release_Channel iOut
23003>>>>>>>            End
23003>>>>>>>>
23003>>>>>>>        End
23003>>>>>>>>
23003>>>>>>>        Send SqlDisconnect of hoSQLConnect
23004>>>>>>>
23004>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
23005>>>>>>>    End_Function
23006>>>>>>>
23006>>>>>>>    // * Dummy function for the Studio's Code Explorer *
23006>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
23008>>>>>>>        Function_Return False
23009>>>>>>>    End_Function
23010>>>>>>>
23010>>>>>>>    // Does three things with auxilirary files;
23010>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
23010>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
23010>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
23010>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
23012>>>>>>>        String sDataPath sDDSrcPath sDriverID
23012>>>>>>>        Boolean bOK bExists bMertechDriver
23012>>>>>>>        Integer iCount iCh iPos
23012>>>>>>>
23012>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
23012>>>>>>>        If (sTableName contains ".") Begin
23014>>>>>>>            Move (Pos(".", sTableName)) to iPos
23015>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
23016>>>>>>>        End
23016>>>>>>>>
23016>>>>>>>
23016>>>>>>>        Get psDriverID to sDriverID
23017>>>>>>>        Get psDataPathFirstPart to sDataPath
23018>>>>>>>        Get vFolderExists sDataPath to bOK
23019>>>>>>>        If (bOK = False) Begin
23021>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
23022>>>>>>>>
23022>>>>>>>            Function_Return False
23023>>>>>>>        End
23023>>>>>>>>
23023>>>>>>>
23023>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
23024>>>>>>>        // First delete the cache file:
23024>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
23025>>>>>>>
23025>>>>>>>        Get Seq_New_Channel to iCh
23026>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
23028>>>>>>>            Function_Return False
23029>>>>>>>        End
23029>>>>>>>>
23029>>>>>>>
23029>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
23030>>>>>>>        If (bExists = False) Begin
23032>>>>>>>            Function_Return False
23033>>>>>>>        End
23033>>>>>>>>
23033>>>>>>>
23033>>>>>>>        Get SqlUtilUpdateIntFile hTable to bOK
23034>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
23034>>>>>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
23035>>>>>>>
23035>>>>>>>        // If in development environment; output new .fd file:
23035>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
23036>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
23037>>>>>>>        If (iCount > 1) Begin
23039>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
23040>>>>>>>        End
23040>>>>>>>>
23040>>>>>>>        Get vFolderExists sDDSrcPath to bExists
23041>>>>>>>        If (bExists = True) Begin
23043>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
23044>>>>>>>            Move False to Err
23045>>>>>>>            Get AutoConnectionIDLogin to bOK
23046>>>>>>>            If (hTable <> 0) Begin
23048>>>>>>>                Open hTable
23050>>>>>>>            End
23050>>>>>>>>
23050>>>>>>>            Else Begin
23051>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
23052>>>>>>>            End
23052>>>>>>>>
23052>>>>>>>
23052>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
23055>>>>>>>            If (bOK = True) Begin
23057>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
23059>>>>>>>            End
23059>>>>>>>>
23059>>>>>>>            If (Err = True) Begin
23061>>>>>>>                Move False to bOK
23062>>>>>>>            End
23062>>>>>>>>
23062>>>>>>>        End
23062>>>>>>>>
23062>>>>>>>
23062>>>>>>>        Function_Return (bOK = True)
23063>>>>>>>    End_Function
23064>>>>>>>
23064>>>>>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
23066>>>>>>>        Integer iChIn iChOut iCount
23066>>>>>>>        Boolean bExists
23066>>>>>>>        String sExistingColumn
23066>>>>>>>
23066>>>>>>>        Move False to bExists
23067>>>>>>>        Get Seq_New_Channel to iChIn
23068>>>>>>>        Get Seq_New_Channel to iChOut
23069>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
23071>>>>>>>            Function_Return True
23072>>>>>>>        End
23072>>>>>>>>
23072>>>>>>>
23072>>>>>>>        Move False to Err
23073>>>>>>>        Direct_Input ("'" + sFullTAGFileName + "'")
23074>>>>>>>        While (not(SeqEof))
23078>>>>>>>            Readln channel iChIn sExistingColumn
23080>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
23082>>>>>>>                Move True to bExists
23083>>>>>>>            End
23083>>>>>>>>
23083>>>>>>>            If (Trim(sExistingColumn) = "") Begin
23085>>>>>>>                Move True to SeqEof
23086>>>>>>>            End
23086>>>>>>>>
23086>>>>>>>        Loop
23087>>>>>>>>
23087>>>>>>>        Close_Input channel iChIn
23089>>>>>>>        Send Seq_Release_Channel iChIn
23090>>>>>>>
23090>>>>>>>        If (bExists = False) Begin
23092>>>>>>>            Append_Output channel iChOut sFullTAGFileName
23094>>>>>>>            Writeln channel iChOut sColumnName
23097>>>>>>>            Close_Output channel iChOut
23099>>>>>>>            Send Seq_Release_Channel iChOut
23100>>>>>>>        End
23100>>>>>>>>
23100>>>>>>>
23100>>>>>>>        Function_Return (Err = False)
23101>>>>>>>    End_Function
23102>>>>>>>
23102>>>>>>>    // Message for changing .int files to use connection ID's
23102>>>>>>>    //
23102>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
23102>>>>>>>    // OR changes an existing connection id to a new id.
23102>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
23102>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
23102>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
23104>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
23104>>>>>>>        String[] sFilesData
23105>>>>>>>        Boolean bOK bCancel
23105>>>>>>>        Integer iSize iCount
23105>>>>>>>
23105>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
23106>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
23107>>>>>>>        If (iSize = 0) Begin
23109>>>>>>>            If (ghoStatusPanel <> 0) Begin
23111>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
23113>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
23114>>>>>>>                End
23114>>>>>>>>
23114>>>>>>>            End
23114>>>>>>>>
23114>>>>>>>            Send Info_Box "No .int files found! Nothing was changed."
23115>>>>>>>            Procedure_Return
23116>>>>>>>        End
23116>>>>>>>>
23116>>>>>>>
23116>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
23117>>>>>>>        Get vFolderFormat sDataPath to sDataPath
23118>>>>>>>        Decrement iSize
23119>>>>>>>        For iCount from 0 to iSize
23125>>>>>>>>
23125>>>>>>>            Move sFilesData[iCount] to sFileName
23126>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
23126>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
23127>>>>>>>            If (ghoStatusPanel <> 0) Begin
23129>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
23131>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
23132>>>>>>>                    If (bCancel = True) Begin
23134>>>>>>>                        Send Deactivate of ghoStatusPanel
23135>>>>>>>                        Procedure_Return
23136>>>>>>>                    End
23136>>>>>>>>
23136>>>>>>>                End
23136>>>>>>>>
23136>>>>>>>            End
23136>>>>>>>>
23136>>>>>>>        Loop
23137>>>>>>>>
23137>>>>>>>
23137>>>>>>>        Get psDriverID to sDriverID
23138>>>>>>>
23138>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
23138>>>>>>>        Move "" to sFileName
23139>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
23141>>>>>>>            Move "MSSQLDrv.int" to sFileName
23142>>>>>>>        End
23142>>>>>>>>
23142>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
23144>>>>>>>            Move "DB2_Drv.int" to sFileName
23145>>>>>>>        End
23145>>>>>>>>
23145>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
23147>>>>>>>            Move "ODBC_Drv.int" to sFileName
23148>>>>>>>        End
23148>>>>>>>>
23148>>>>>>>        If (sFileName <> "") Begin
23150>>>>>>>            Move "" to sDriverFile
23151>>>>>>>            Get_File_Path sFileName to sDriverFile
23152>>>>>>>            If (sDriverFile <> "") Begin
23154>>>>>>>                Get psConnectionString to sConnectionString
23155>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
23156>>>>>>>            End
23156>>>>>>>>
23156>>>>>>>        End
23156>>>>>>>>
23156>>>>>>>    End_Procedure
23157>>>>>>>
23157>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
23157>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
23159>>>>>>>        String[] sDatabaseArray
23160>>>>>>>        String sVal sServer sDriverID
23160>>>>>>>        Integer iCount iSize iPos
23160>>>>>>>        Boolean bExists
23160>>>>>>>        tSQLConnection SQLConnection
23160>>>>>>>        tSQLConnection SQLConnection
23160>>>>>>>
23160>>>>>>>        Move False to bExists
23161>>>>>>>        Get psDriverID to sDriverID
23162>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
23162>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
23164>>>>>>>            Function_Return bExists
23165>>>>>>>        End
23165>>>>>>>>
23165>>>>>>>
23165>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
23166>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
23168>>>>>>>            Function_Return False
23169>>>>>>>        End
23169>>>>>>>>
23169>>>>>>>
23169>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
23170>>>>>>>        Move SQLConnection.sServer to sServer
23171>>>>>>>
23171>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
23171>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
23173>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
23174>>>>>>>        End
23174>>>>>>>>
23174>>>>>>>        Else If (sServer contains "/") Begin
23177>>>>>>>            Move (Pos("/", sServer)) to iPos
23178>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
23179>>>>>>>        End
23179>>>>>>>>
23179>>>>>>>
23179>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
23180>>>>>>>        Decrement iSize
23181>>>>>>>        For iCount from 0 to iSize
23187>>>>>>>>
23187>>>>>>>            Move sDatabaseArray[iCount] to sVal
23188>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
23190>>>>>>>                Move True to bExists
23191>>>>>>>                If (bExists = True) Begin
23193>>>>>>>                    Move iSize to iCount // We're done.
23194>>>>>>>                End
23194>>>>>>>>
23194>>>>>>>            End
23194>>>>>>>>
23194>>>>>>>        Loop
23195>>>>>>>>
23195>>>>>>>
23195>>>>>>>        Function_Return bExists
23196>>>>>>>    End_Function
23197>>>>>>>
23197>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
23197>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
23199>>>>>>>        String sTableName sVal
23199>>>>>>>        Boolean bExists
23199>>>>>>>        String[] sTablesArray
23200>>>>>>>        Integer iSize iCount
23200>>>>>>>
23200>>>>>>>        Move False to bExists
23201>>>>>>>        Get UtilTableHandleToString hTable to sTableName
23202>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
23203>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
23204>>>>>>>        Decrement iSize
23205>>>>>>>        For iCount from 0 to iSize
23211>>>>>>>>
23211>>>>>>>            Move sTablesArray[iCount] to sVal
23212>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
23214>>>>>>>                Move True to bExists
23215>>>>>>>                Move iSize to iCount // We're done!
23216>>>>>>>            End
23216>>>>>>>>
23216>>>>>>>        Loop
23217>>>>>>>>
23217>>>>>>>
23217>>>>>>>        Function_Return bExists
23218>>>>>>>    End_Function
23219>>>>>>>
23219>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
23219>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
23221>>>>>>>        String sVal
23221>>>>>>>        Boolean bExists
23221>>>>>>>        String[] sTablesArray
23222>>>>>>>        Integer iSize iCount
23222>>>>>>>
23222>>>>>>>        Move False to bExists
23223>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
23224>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
23225>>>>>>>        Decrement iSize
23226>>>>>>>        For iCount from 0 to iSize
23232>>>>>>>>
23232>>>>>>>            Move sTablesArray[iCount] to sVal
23233>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
23235>>>>>>>                Move True to bExists
23236>>>>>>>                Move iSize to iCount // We're done!
23237>>>>>>>            End
23237>>>>>>>>
23237>>>>>>>        Loop
23238>>>>>>>>
23238>>>>>>>
23238>>>>>>>        Function_Return bExists
23239>>>>>>>    End_Function
23240>>>>>>>
23240>>>>>>>    // ToDo: This index name function needs to be finished...
23240>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
23242>>>>>>>        String sSchema sTableName sDriverID
23242>>>>>>>        Boolean bExists
23242>>>>>>>
23242>>>>>>>        Get psDriverID to sDriverID
23243>>>>>>>        Get psSchema to sSchema
23244>>>>>>>        Get UtilTableHandleToString hTable to sTableName
23245>>>>>>>
23245>>>>>>>        Function_Return bExists
23246>>>>>>>    End_Function
23247>>>>>>>
23247>>>>>>>    // Checks if a column/field name exists in a SQL table definition
23247>>>>>>>    // Returns True if it does
23247>>>>>>>    // Sample:
23247>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
23247>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
23249>>>>>>>        Integer iNumColumns iColumn
23249>>>>>>>        String sColumn sDriverID
23249>>>>>>>        String[] sColumnsArray
23250>>>>>>>        Boolean bExists bOK
23250>>>>>>>
23250>>>>>>>        Move False to bExists
23251>>>>>>>        Get AutoConnectionIDLogin to bOK
23252>>>>>>>        Get psDriverID to sDriverID
23253>>>>>>>
23253>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
23254>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
23255>>>>>>>        Decrement iNumColumns
23256>>>>>>>        For iColumn from 0 to iNumColumns
23262>>>>>>>>
23262>>>>>>>            Move sColumnsArray[iColumn] to sColumn
23263>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
23265>>>>>>>                Move True to bExists
23266>>>>>>>                Move iNumColumns to iColumn // We're out of here
23267>>>>>>>            End
23267>>>>>>>>
23267>>>>>>>        Loop
23268>>>>>>>>
23268>>>>>>>
23268>>>>>>>        Function_Return bExists
23269>>>>>>>    End_Function
23270>>>>>>>
23270>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
23272>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
23272>>>>>>>        Boolean bOpened bOK
23272>>>>>>>        String sColumnName sNativeTypeName
23272>>>>>>>
23272>>>>>>>        Get AutoConnectionIDLogin to bOK
23273>>>>>>>        Get OpenTableExclusive hTable to bOK
23274>>>>>>>        If (bOK = False) Begin
23276>>>>>>>            Function_Return False
23277>>>>>>>        End
23277>>>>>>>>
23277>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
23280>>>>>>>        If (bOpened = False) Begin
23282>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
23283>>>>>>>>
23283>>>>>>>            Function_Return False
23284>>>>>>>        End
23284>>>>>>>>
23284>>>>>>>
23284>>>>>>>        Move False to Err
23285>>>>>>>
23285>>>>>>>        Structure_Start hTable
23286>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
23289>>>>>>>
23289>>>>>>>            For iColumn from 1 to iNumColumns
23295>>>>>>>>
23295>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
23298>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
23301>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
23304>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
23307>>>>>>>
23307>>>>>>>                Case Begin
23307>>>>>>>                    Case (iDFType = DF_DATE)
23309>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
23311>>>>>>>                            // Convert datetime to date
23311>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
23314>>>>>>>                        End
23314>>>>>>>>
23314>>>>>>>                        Case Break
23315>>>>>>>                    Case (iDFType = DF_DATETIME)
23318>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
23320>>>>>>>                            // Convert datetime to datetime2
23320>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
23323>>>>>>>                        End
23323>>>>>>>>
23323>>>>>>>                        Case Break
23324>>>>>>>                    Case (iDFType = DF_ASCII)
23327>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
23329>>>>>>>                            // Convert char to varchar
23329>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
23332>>>>>>>                        End
23332>>>>>>>>
23332>>>>>>>                        Case Break
23333>>>>>>>                    Case (iDFType = DF_TEXT)
23336>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
23338>>>>>>>                            // Convert text to varchar(max)
23338>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
23341>>>>>>>                        End
23341>>>>>>>>
23341>>>>>>>                        Case Break
23342>>>>>>>                    Case (iDFType = DF_BINARY)
23345>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
23347>>>>>>>                            // Convert image to varbinary(max)
23347>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
23350>>>>>>>                        End
23350>>>>>>>>
23350>>>>>>>                        Case Break
23351>>>>>>>                Case End
23351>>>>>>>            Loop
23352>>>>>>>>
23352>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
23353>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
23355>>>>>>>
23355>>>>>>>        Set Action_Text of ghoStatusPanel to ""
23356>>>>>>>        Function_Return (Err = False)
23357>>>>>>>    End_Function
23358>>>>>>>
23358>>>>>>>
23358>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
23358>>>>>>>    // the DbUpdateVersion database revision in.
23358>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
23358>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
23358>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
23360>>>>>>>        Boolean bOK bOpened
23360>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
23360>>>>>>>
23360>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
23363>>>>>>>        Get _TableNameOnly sTableName to sTableName
23364>>>>>>>        If (sTableName = "") Begin
23366>>>>>>>            Function_Return False
23367>>>>>>>        End
23367>>>>>>>>
23367>>>>>>>
23367>>>>>>>        // This just creates the table and a "dummy" column.
23367>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
23368>>>>>>>        If (bOK = False) Begin
23370>>>>>>>            Function_Return False
23371>>>>>>>        End
23371>>>>>>>>
23371>>>>>>>
23371>>>>>>>        Close hTable
23372>>>>>>>        Move False to Err
23373>>>>>>>
23373>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
23374>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
23375>>>>>>>        Move "Decimal" to sDataType
23376>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
23377>>>>>>>
23377>>>>>>>        // Adds the "sColumnName" passed to the function
23377>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
23378>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
23379>>>>>>>
23379>>>>>>>        // Now we can delete the dummy column:
23379>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
23380>>>>>>>
23380>>>>>>>        // Finally, we attach to the newly created table.
23380>>>>>>>        If (Err = False) Begin
23382>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
23383>>>>>>>        End
23383>>>>>>>>
23383>>>>>>>        Open hTable
23385>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
23388>>>>>>>
23388>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
23389>>>>>>>    End_Function
23390>>>>>>>
23390>>>>>>>    // The table must already exist in the filelist for this function to work.
23390>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
23390>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
23392>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
23392>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
23392>>>>>>>        String[] sIndexArray
23393>>>>>>>        Integer iCount iCh iSize
23393>>>>>>>
23393>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
23394>>>>>>>        Get psConnectionString to sConnectionString
23395>>>>>>>
23395>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
23396>>>>>>>        If (bANSI = False) Begin
23398>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
23399>>>>>>>        End
23399>>>>>>>>
23399>>>>>>>
23399>>>>>>>        Get psDataPathFirstPart to sDataPath
23400>>>>>>>        Get vFolderExists sDataPath to bOK
23401>>>>>>>        If (bOK = False) Begin
23403>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
23404>>>>>>>>
23404>>>>>>>            Function_Return False
23405>>>>>>>        End
23405>>>>>>>>
23405>>>>>>>        Get vFolderFormat sDataPath to sDataPath
23406>>>>>>>
23406>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
23409>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
23412>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
23413>>>>>>>        Move sLogicalName  to sPhysicalFileName
23414>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
23415>>>>>>>
23415>>>>>>>        Get IsMertechDriver sDriverID to bMertech
23416>>>>>>>        If (bMertech = True) Begin
23418>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
23418>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
23418>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
23418>>>>>>>            Function_Return (bOK = True)
23419>>>>>>>        End
23419>>>>>>>>
23419>>>>>>>
23419>>>>>>>        Get psSchema hTable to sSchemaName
23420>>>>>>>        If (sSchemaName = "") Begin
23422>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
23423>>>>>>>        End
23423>>>>>>>>
23423>>>>>>>
23423>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
23423>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
23424>>>>>>>        If (bExists = True) Begin
23426>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
23427>>>>>>>        End
23427>>>>>>>>
23427>>>>>>>
23427>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
23428>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
23429>>>>>>>
23429>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
23430>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
23435>>>>>>>            If (bUseConnectionID = True) Begin
23437>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
23444>>>>>>>            End
23444>>>>>>>>
23444>>>>>>>            Else Begin
23445>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
23452>>>>>>>            End
23452>>>>>>>>
23452>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
23457>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
23462>>>>>>>            // There seems to be a new order how these are set from DF19.
23462>>>>>>>            If (bSysFile = True) Begin
23464>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
23469>>>>>>>            End
23469>>>>>>>>
23469>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
23474>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
23479>>>>>>>            If (bSysFile = True) Begin
23481>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
23486>>>>>>>            End
23486>>>>>>>>
23486>>>>>>>
23486>>>>>>>            If (bSysFile = False) Begin
23488>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
23489>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
23490>>>>>>>                If (iSize > 0) Begin
23492>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
23495>>>>>>>                    Writeln channel iCh // Just an empty line
23497>>>>>>>                End
23497>>>>>>>>
23497>>>>>>>                Decrement iSize
23498>>>>>>>                For iCount from 0 to iSize
23504>>>>>>>>
23504>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
23507>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
23510>>>>>>>                    Writeln channel iCh
23512>>>>>>>                Loop
23513>>>>>>>>
23513>>>>>>>            End
23513>>>>>>>>
23513>>>>>>>        Send Seq_Close_Channel iCh
23514>>>>>>>
23514>>>>>>>        // Wait a sec for Windows to finish writing the file:
23514>>>>>>>        Sleep 1
23515>>>>>>>
23515>>>>>>>        Function_Return (bOK = True)
23516>>>>>>>    End_Function
23517>>>>>>>
23517>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
23517>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
23517>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
23517>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
23517>>>>>>>    // column types.
23517>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
23519>>>>>>>        Handle hDatabase
23519>>>>>>>        Integer iDriver iServers iCount
23519>>>>>>>        String sValue
23519>>>>>>>
23519>>>>>>>        If (sServer = "") Begin
23521>>>>>>>            Function_Return 0
23522>>>>>>>        End
23522>>>>>>>>
23522>>>>>>>
23522>>>>>>>        Get DriverIndex sDriverID to iDriver
23523>>>>>>>        If (iDriver = 0) Begin
23525>>>>>>>            Function_Return 0
23526>>>>>>>        End
23526>>>>>>>>
23526>>>>>>>
23526>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
23529>>>>>>>        For iCount from 1 to iServers
23535>>>>>>>>
23535>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
23538>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
23540>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
23543>>>>>>>            End
23543>>>>>>>>
23543>>>>>>>        Loop
23544>>>>>>>>
23544>>>>>>>
23544>>>>>>>        Function_Return hDatabase
23545>>>>>>>    End_Function
23546>>>>>>>
23546>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
23546>>>>>>>//        String sRootName
23546>>>>>>>//        Boolean bOK
23546>>>>>>>//
23546>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
23546>>>>>>>//        Move (sRootName contains sDriverID) to bOK
23546>>>>>>>//
23546>>>>>>>//        Function_Return bOK
23546>>>>>>>//    End_Function
23546>>>>>>>
23546>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
23546>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
23546>>>>>>>//        Integer iDbType
23546>>>>>>>//        Boolean bOK
23546>>>>>>>//
23546>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
23546>>>>>>>//        If (bOK = True) Begin
23546>>>>>>>//            Function_Return False
23546>>>>>>>//        End
23546>>>>>>>//
23546>>>>>>>//        Get psDriverID to sDriverID
23546>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
23546>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
23546>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
23546>>>>>>>//
23546>>>>>>>//        Get psDriverID to sDriverID
23546>>>>>>>//        Get piDbType   to iDbType
23546>>>>>>>//        Get psSchema   to sSchema
23546>>>>>>>//        If (sSchema = "") Begin
23546>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
23546>>>>>>>//        End
23546>>>>>>>//
23546>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
23546>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
23546>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
23546>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
23546>>>>>>>//            End
23546>>>>>>>//            Else Begin
23546>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
23546>>>>>>>//            End
23546>>>>>>>//        End
23546>>>>>>>//
23546>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
23546>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
23546>>>>>>>//
23546>>>>>>>//        Function_Return True
23546>>>>>>>//    End_Function
23546>>>>>>>
23546>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV;MyTable" or "MyTable.MSSQLDRV"
23546>>>>>>>    // from the passed filelist.
23546>>>>>>>    // Returns the number of tables affected.
23546>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
23548>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
23548>>>>>>>        Integer iRetval
23548>>>>>>>        Handle hTable
23548>>>>>>>
23548>>>>>>>        // We first save the current filelist as the passed filelist name
23548>>>>>>>        // may come from another workspace, to restore it when we're ready.
23548>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
23551>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
23554>>>>>>>        Move 0 to hTable
23555>>>>>>>        Move 0 to iRetval
23556>>>>>>>
23556>>>>>>>        Repeat
23556>>>>>>>>
23556>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
23559>>>>>>>            If (hTable <> 0) Begin
23561>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
23564>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
23567>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
23570>>>>>>>                Move (Uppercase(sRootName)) to sVal
23571>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
23573>>>>>>>                    // Prefixes:
23573>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
23574>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
23575>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
23576>>>>>>>                    // Suffixes:
23576>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
23577>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
23578>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
23579>>>>>>>
23579>>>>>>>                    // Change Filelist entry:
23579>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
23582>>>>>>>
23582>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
23583>>>>>>>                    If (sVal contains "dbo.") Begin
23585>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
23586>>>>>>>
23586>>>>>>>                        // Change Filelist entry:
23586>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
23589>>>>>>>                    End
23589>>>>>>>>
23589>>>>>>>                    Increment iRetval
23590>>>>>>>                End
23590>>>>>>>>
23590>>>>>>>            End
23590>>>>>>>>
23590>>>>>>>        Until (hTable = 0)
23592>>>>>>>
23592>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
23595>>>>>>>
23595>>>>>>>        Function_Return iRetval
23596>>>>>>>    End_Function
23597>>>>>>>
23597>>>>>>>    // To open all Sql based tables in Filelist.cfg
23597>>>>>>>    Procedure SqlUtilOpenAllTables
23599>>>>>>>        Handle hTable
23599>>>>>>>        String sRoot sDriverID
23599>>>>>>>        Boolean bOK
23599>>>>>>>
23599>>>>>>>        Move 0 to hTable
23600>>>>>>>        Move "" to sDriverID
23601>>>>>>>        Get AutoConnectionIDLogin to bOK
23602>>>>>>>
23602>>>>>>>        Repeat
23602>>>>>>>>
23602>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
23605>>>>>>>            If (hTable > 0) Begin
23607>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
23610>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
23612>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
23615>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
23617>>>>>>>                        Open hTable
23619>>>>>>>                    End
23619>>>>>>>>
23619>>>>>>>                End
23619>>>>>>>>
23619>>>>>>>            End
23619>>>>>>>>
23619>>>>>>>
23619>>>>>>>        Until (hTable = 0)
23621>>>>>>>    End_Procedure
23622>>>>>>>
23622>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
23622>>>>>>>//        String sRetval sDriverID
23622>>>>>>>//        String sTableName
23622>>>>>>>//        Integer iDbType iIndex
23622>>>>>>>//        Boolean bOK
23622>>>>>>>//
23622>>>>>>>//        Get psDriverID to sDriverID
23622>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
23622>>>>>>>//        If (hTable = 0 or bOK = False) Begin
23622>>>>>>>//            Function_Return ""
23622>>>>>>>//        End
23622>>>>>>>//
23622>>>>>>>//        Move False to Err
23622>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
23622>>>>>>>//        Get piDbType to iDbType
23622>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
23622>>>>>>>//        If (iIndex = -1) Begin
23622>>>>>>>//            Function_Return ""
23622>>>>>>>//        End
23622>>>>>>>//
23622>>>>>>>//        Function_Return sRetval
23622>>>>>>>//    End_Function
23622>>>>>>>
23622>>>>>>>    // Checks if the passed Table;
23622>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
23622>>>>>>>    // 2) It has an .int file.
23622>>>>>>>    // If both is True it should already be connected to SQL
23622>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
23624>>>>>>>        Boolean bExists bRootName
23624>>>>>>>        String sRootName sDataPath
23624>>>>>>>
23624>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
23627>>>>>>>        Move (sRootName contains sDriverID) to bRootName
23628>>>>>>>
23628>>>>>>>        Get psDataPathFirstPart to sDataPath
23629>>>>>>>        Get vFolderExists sDataPath to bExists
23630>>>>>>>        If (bExists = False) Begin
23632>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
23632>>>>>>>            Function_Return False
23633>>>>>>>        End
23633>>>>>>>>
23633>>>>>>>
23633>>>>>>>        Get vFolderFormat sDataPath to sDataPath
23634>>>>>>>        Get _TableNameOnly sRootName to sRootName
23635>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
23636>>>>>>>
23636>>>>>>>        Function_Return (bRootName = True and bExists = True)
23637>>>>>>>    End_Function
23638>>>>>>>
23638>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
23640>>>>>>>        Boolean bViewTableType bOpen bOK
23640>>>>>>>        Integer iTableCount iNumTables
23640>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
23640>>>>>>>        Handle hoCliHandler
23640>>>>>>>        tSQLConnection SQLConnection
23640>>>>>>>        tSQLConnection SQLConnection
23640>>>>>>>
23640>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
23643>>>>>>>        If (bOpen = False) Begin
23645>>>>>>>            Get AutoConnectionIDLogin to bOK
23646>>>>>>>            Open hTable
23648>>>>>>>        End
23648>>>>>>>>
23648>>>>>>>
23648>>>>>>>        Get pSQLConnection to SQLConnection
23649>>>>>>>        Get phoCLIHandler to hoCliHandler
23650>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
23651>>>>>>>
23651>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
23654>>>>>>>        Get _TableNameOnly sTableName to sTableName
23655>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
23658>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
23659>>>>>>>
23659>>>>>>>        For iTableCount from 1 to iNumTables
23665>>>>>>>>
23665>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
23666>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
23667>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
23669>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
23670>>>>>>>                Move iNumTables to iTableCount // We're done.
23671>>>>>>>            End
23671>>>>>>>>
23671>>>>>>>        Loop
23672>>>>>>>>
23672>>>>>>>
23672>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
23673>>>>>>>        If (bOpen = False) Begin
23675>>>>>>>            Close hTable
23676>>>>>>>        End
23676>>>>>>>>
23676>>>>>>>
23676>>>>>>>        Function_Return bViewTableType
23677>>>>>>>    End_Function
23678>>>>>>>
23678>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
23678>>>>>>>    //
23678>>>>>>>    // SQL utility function that returns a database type (string) constant
23678>>>>>>>    // corresponding to the passed iDbType.
23678>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
23680>>>>>>>        String sRetval
23680>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
23681>>>>>>>        Function_Return sRetval
23682>>>>>>>    End_Function
23683>>>>>>>
23683>>>>>>>    // SQL utility function that returns a database type constant (integer)
23683>>>>>>>    // corresponding to the passed sDbType string constant.
23683>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
23685>>>>>>>        Integer iRetval
23685>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
23686>>>>>>>        Function_Return iRetval
23687>>>>>>>    End_Function
23688>>>>>>>
23688>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
23688>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
23688>>>>>>>    // the SQL Connection program's grid.
23688>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
23690>>>>>>>        String sRetval
23690>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
23691>>>>>>>        Function_Return sRetval
23692>>>>>>>    End_Function
23693>>>>>>>
23693>>>>>>>    // Pass a driver name as a string and the function will return
23693>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
23693>>>>>>>    // quite work and always returns "MS SQL Server"
23693>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
23695>>>>>>>        Integer iRetval
23695>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
23696>>>>>>>        Function_Return iRetval
23697>>>>>>>    End_Function
23698>>>>>>>
23698>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
23698>>>>>>>    // that "fits" in the max allowed length for table names.
23698>>>>>>>    // Max number of characters allowed for table names;
23698>>>>>>>    // IBM DB2      = 128
23698>>>>>>>    // MS-SQL       = 128
23698>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
23698>>>>>>>    // MySQL        = 64
23698>>>>>>>    // PostgreSQL   = 64
23698>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
23700>>>>>>>        String sGUIDName
23700>>>>>>>        Integer iDbType iLength
23700>>>>>>>
23700>>>>>>>        Get piDbType to iDbType
23701>>>>>>>        Move (RandomHexUUID()) to sGUIDName
23702>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
23703>>>>>>>        Move (Length(sGUIDName)) to iLength
23704>>>>>>>
23704>>>>>>>        Case Begin
23704>>>>>>>            Case (iDbType = EN_DbTypeDB2)
23706>>>>>>>            If (iLength > 128) Begin
23708>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
23709>>>>>>>            End
23709>>>>>>>>
23709>>>>>>>            Case Break
23710>>>>>>>
23710>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
23713>>>>>>>            If (iLength > 128) Begin
23715>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
23716>>>>>>>            End
23716>>>>>>>>
23716>>>>>>>            Case Break
23717>>>>>>>
23717>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
23720>>>>>>>            If (iLength > 128) Begin
23722>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
23723>>>>>>>            End
23723>>>>>>>>
23723>>>>>>>            Case Break
23724>>>>>>>
23724>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
23727>>>>>>>            If (iLength > 64) Begin
23729>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
23730>>>>>>>            End
23730>>>>>>>>
23730>>>>>>>            Case Break
23731>>>>>>>
23731>>>>>>>            Case (iDbType = EN_DbTypePostgre)
23734>>>>>>>            If (iLength > 64) Begin
23736>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
23737>>>>>>>            End
23737>>>>>>>>
23737>>>>>>>        Case End
23737>>>>>>>
23737>>>>>>>        Function_Return sGUIDName
23738>>>>>>>    End_Function
23739>>>>>>>
23739>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
23739>>>>>>>    // Pass the memory resource file reference and the filename to be created,
23739>>>>>>>    // including full path.
23739>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
23741>>>>>>>        String sText
23741>>>>>>>        Integer iCh iSize iArgSize
23741>>>>>>>
23741>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
23742>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
23743>>>>>>>            Get_Channel_Size iCh to iSize
23744>>>>>>>            Get_Argument_Size to iArgSize
23745>>>>>>>            If (iSize > iArgSize) Begin
23747>>>>>>>                Set_Argument_Size iSize
23748>>>>>>>>
23748>>>>>>>            End
23748>>>>>>>>
23748>>>>>>>            Read_Block channel iCh sText iSize
23750>>>>>>>        Send Seq_Close_Channel iCh
23751>>>>>>>
23751>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
23752>>>>>>>            Write channel iCh sText
23754>>>>>>>        Send Seq_Close_Channel iCh
23755>>>>>>>
23755>>>>>>>        If (iSize <> iArgSize) Begin
23757>>>>>>>            Set_Argument_Size iArgSize
23758>>>>>>>>
23758>>>>>>>        End
23758>>>>>>>>
23758>>>>>>>
23758>>>>>>>        // Wait for file to be written to disk.
23758>>>>>>>        Sleep 2
23759>>>>>>>    End_Procedure
23760>>>>>>>
23760>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
23762>>>>>>>        String sNotNull sRetval sDefaultValue
23762>>>>>>>        Boolean bOK
23762>>>>>>>
23762>>>>>>>        Get IsSQLDriver sDriverID to bOK
23763>>>>>>>        If (bOK = False) Begin
23765>>>>>>>            Function_Return ""
23766>>>>>>>        End
23766>>>>>>>>
23766>>>>>>>
23766>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
23767>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
23768>>>>>>>
23768>>>>>>>        Case Begin
23768>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
23770>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
23771>>>>>>>                Case Break
23772>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
23775>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
23776>>>>>>>                Case Break
23777>>>>>>>            Case (iDbType = EN_dbTypePostgre)
23780>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
23781>>>>>>>                Case Break
23782>>>>>>>            Case (iDbType = EN_dbTypeDB2)
23785>>>>>>>                Move (String(sNotNull))                                     to sRetval
23786>>>>>>>                Case Break
23787>>>>>>>
23787>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
23787>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
23787>>>>>>>            Case (iDbType = EN_dbTypeOracle)
23790>>>>>>>                Move  ""                                                    to sRetval
23791>>>>>>>                Case Break
23792>>>>>>>
23792>>>>>>>            Case Else
23792>>>>>>>                Move  ""                                                    to sRetval
23793>>>>>>>        Case End
23793>>>>>>>
23793>>>>>>>        Function_Return sRetval
23794>>>>>>>    End_Function
23795>>>>>>>
23795>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
23797>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
23797>>>>>>>        Boolean bOpened bOK bMertech
23797>>>>>>>
23797>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
23797>>>>>>>        // which makes the program unable to run because they can't be opened.
23797>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
23797>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
23797>>>>>>>        // proper .int files for the two tables.
23797>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
23799>>>>>>>            Function_Return True
23800>>>>>>>        End
23800>>>>>>>>
23800>>>>>>>
23800>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
23803>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
23804>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
23805>>>>>>>        Move CS_ANSI_Txt to sNewFormat
23806>>>>>>>        Get AutoConnectionIDLogin to bOK
23807>>>>>>>
23807>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
23807>>>>>>>        Sleep 1
23808>>>>>>>
23808>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
23811>>>>>>>        If (bOpened = False) Begin
23813>>>>>>>            Open hTable
23815>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
23818>>>>>>>        End
23818>>>>>>>>
23818>>>>>>>        If (bOpened = False) Begin
23820>>>>>>>            Function_Return False
23821>>>>>>>        End
23821>>>>>>>>
23821>>>>>>>
23821>>>>>>>        Get psDriverID to sDriverID
23822>>>>>>>        Get IsMertechDriver sDriverID to bMertech
23823>>>>>>>        If (bMertech = True) Begin
23825>>>>>>>            Get psDataPathFirstPart to sDataPath
23826>>>>>>>            Get vFolderExists sDataPath to bOK
23827>>>>>>>            If (bOK = False) Begin
23829>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
23830>>>>>>>>
23830>>>>>>>                Function_Return False
23831>>>>>>>            End
23831>>>>>>>>
23831>>>>>>>            Get vFolderFormat sDataPath to sDataPath
23832>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
23835>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
23836>>>>>>>            Move sDatabaseName to sPhysicalFileName
23837>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
23838>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
23839>>>>>>>            Function_Return (bOK = True)
23840>>>>>>>        End
23840>>>>>>>>
23840>>>>>>>
23840>>>>>>>        Move False to Err
23841>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
23844>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
23845>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
23845>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
23845>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
23846>>>>>>>
23846>>>>>>>        Move False to Err
23847>>>>>>>
23847>>>>>>>        If (hTable > 0) Begin
23849>>>>>>>            Structure_Start hTable
23850>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
23853>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
23856>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
23858>>>>>>>        End
23858>>>>>>>>
23858>>>>>>>        Else Begin
23859>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
23862>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
23865>>>>>>>        End
23865>>>>>>>>
23865>>>>>>>        Function_Return (Err = False)
23866>>>>>>>    End_Function
23867>>>>>>>
23867>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
23869>>>>>>>        String[] sReturnArray
23870>>>>>>>        String sValue sUserID sPassword
23870>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
23870>>>>>>>        Integer iFetchResult iRetval
23870>>>>>>>        tSQLConnection SQLConnection
23870>>>>>>>        tSQLConnection SQLConnection
23870>>>>>>>
23870>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
23871>>>>>>>        If (hoSQLHandler <> 0) Begin
23873>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
23874>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
23875>>>>>>>            If (hoSQLConnect <> 0) Begin
23877>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
23878>>>>>>>                If (hStmt <> 0) Begin
23880>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
23881>>>>>>>                    If (sArgument <> "") Begin
23883>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
23884>>>>>>>                    End
23884>>>>>>>>
23884>>>>>>>                    Send SQLCall of hStmt
23885>>>>>>>
23885>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
23886>>>>>>>                    If (iRetval = 0) Begin
23888>>>>>>>                        Repeat
23888>>>>>>>>
23888>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
23889>>>>>>>                            If (iFetchResult <> 0) Begin
23891>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
23892>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
23893>>>>>>>                            End
23893>>>>>>>>
23893>>>>>>>                        Until (iFetchResult = 0)
23895>>>>>>>                        Send SQLClose of hStmt
23896>>>>>>>                    End
23896>>>>>>>>
23896>>>>>>>                End
23896>>>>>>>>
23896>>>>>>>                Send SQLDisconnect of hoSQLConnect
23897>>>>>>>            End
23897>>>>>>>>
23897>>>>>>>        End
23897>>>>>>>>
23897>>>>>>>
23897>>>>>>>        Function_Return sReturnArray
23898>>>>>>>    End_Function
23899>>>>>>>
23899>>>>>>>    // * Dummy function for the Studio's Code Explorer *
23899>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
23901>>>>>>>        Function_Return False
23902>>>>>>>    End_Function
23903>>>>>>>
23903>>>>>>>    // Enumerate SQL Servers.
23903>>>>>>>    // Pass a driver id. Returns a string array.
23903>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
23903>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
23903>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
23905>>>>>>>        String[] sReturnArray
23906>>>>>>>        Handle hoSQLHandler
23906>>>>>>>        String sServer
23906>>>>>>>        Integer iCount iNumItems iDataSourceType
23906>>>>>>>
23906>>>>>>>        If (num_arguments > 1) Begin
23908>>>>>>>            Move iDatSrcType to iDataSourceType
23909>>>>>>>        End
23909>>>>>>>>
23909>>>>>>>
23909>>>>>>>        Case Begin
23909>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
23911>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
23912>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
23913>>>>>>>                For iCount from 0 to (iNumItems - 1)
23919>>>>>>>>
23919>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
23920>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
23921>>>>>>>                Loop
23922>>>>>>>>
23922>>>>>>>                Case Break
23923>>>>>>>
23923>>>>>>>            Case (sDriverID = DB2_DRV_ID)
23926>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
23927>>>>>>>                Send SeedDataSources of hoSQLHandler
23928>>>>>>>                Move 0 to iCount
23929>>>>>>>                Repeat
23929>>>>>>>>
23929>>>>>>>                    Get DataSources of hoSQLHandler to sServer
23930>>>>>>>                    If (sServer <> "") Begin
23932>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
23933>>>>>>>                        Move sServer to sReturnArray[iCount]
23934>>>>>>>                    End
23934>>>>>>>>
23934>>>>>>>                    Increment iCount
23935>>>>>>>                Until (sServer = "")
23937>>>>>>>                Case Break
23938>>>>>>>
23938>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
23941>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
23942>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
23943>>>>>>>                Move 0 to iCount
23944>>>>>>>                Repeat
23944>>>>>>>>
23944>>>>>>>                    Get DataSources of hoSQLHandler to sServer
23945>>>>>>>                    If (sServer <> "") Begin
23947>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
23948>>>>>>>                        Move sServer to sReturnArray[iCount]
23949>>>>>>>                    End
23949>>>>>>>>
23949>>>>>>>                    Increment iCount
23950>>>>>>>                Until (sServer = "")
23952>>>>>>>                Case Break
23953>>>>>>>
23953>>>>>>>            Case (sDriverID = SQLFLEX)
23956>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
23957>>>>>>>                Case Break
23958>>>>>>>
23958>>>>>>>            Case (sDriverID = ORAFLEX)
23961>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
23962>>>>>>>                Case Break
23963>>>>>>>
23963>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
23963>>>>>>>            Case (sDriverID = MDSPgSQL)
23966>>>>>>>                Move "localhost" to sReturnArray[0]
23967>>>>>>>                Case Break
23968>>>>>>>
23968>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
23968>>>>>>>            Case (sDriverID = MDSMySQL)
23971>>>>>>>                Move "localhost" to sReturnArray[0]
23972>>>>>>>                Case Break
23973>>>>>>>
23973>>>>>>>            Case Else
23973>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
23974>>>>>>>>
23974>>>>>>>        Case End
23974>>>>>>>
23974>>>>>>>        Function_Return sReturnArray
23975>>>>>>>    End_Function
23976>>>>>>>
23976>>>>>>>    // Returns all databases as a string array for the passed driver id.
23976>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
23978>>>>>>>        String[] sReturnArray
23979>>>>>>>        String sServer sVal
23979>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
23979>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
23980>>>>>>>        tSQLConnection SQLConnection
23980>>>>>>>        tSQLConnection SQLConnection
23980>>>>>>>        Boolean bOK
23980>>>>>>>        Integer iCount iSize
23980>>>>>>>
23980>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
23981>>>>>>>        If (bOK = False) Begin
23983>>>>>>>            Function_Return sReturnArray
23984>>>>>>>        End
23984>>>>>>>>
23984>>>>>>>
23984>>>>>>>        Case Begin
23984>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
23986>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
23987>>>>>>>                Case Break
23988>>>>>>>            Case (sDriverID = DB2_DRV_ID)
23991>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
23992>>>>>>>                Case Break
23993>>>>>>>
23993>>>>>>>            // This is needed to be able to check if a database exists or not.
23993>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
23996>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
23997>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
23999>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
24001>>>>>>>                        // If a FILEDSN: (can only be one database name)
24001>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
24002>>>>>>>                    End
24002>>>>>>>>
24002>>>>>>>                    Else Begin
24003>>>>>>>                        // Else the DSN's were read from the registry.
24003>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
24004>>>>>>>                        Move SQLConnection.sServer to sServer
24005>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
24006>>>>>>>                        Decrement iSize
24007>>>>>>>                        for iCount from 0 to iSize
24013>>>>>>>>
24013>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
24014>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
24016>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
24017>>>>>>>                                Move iSize to iCount // We're done.
24018>>>>>>>                            End
24018>>>>>>>>
24018>>>>>>>                        Loop
24019>>>>>>>>
24019>>>>>>>                    End
24019>>>>>>>>
24019>>>>>>>                End
24019>>>>>>>>
24019>>>>>>>                Case Break
24020>>>>>>>
24020>>>>>>>            Case (sDriverID = SQLFLEX)
24023>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
24024>>>>>>>                Case Break
24025>>>>>>>
24025>>>>>>>            Case (sDriverID = MDSPgSQL)
24028>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
24029>>>>>>>                Case Break
24030>>>>>>>
24030>>>>>>>            Case (sDriverID = MDSMySQL)
24033>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
24034>>>>>>>                Case Break
24035>>>>>>>
24035>>>>>>>            Case (sDriverID = ORAFLEX)
24038>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
24039>>>>>>>                Case Break
24040>>>>>>>
24040>>>>>>>            Case Else
24040>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
24041>>>>>>>>
24041>>>>>>>        Case End
24041>>>>>>>
24041>>>>>>>        Function_Return sReturnArray
24042>>>>>>>    End_Function
24043>>>>>>>
24043>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
24043>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
24045>>>>>>>        String[] sReturnArray
24046>>>>>>>        Boolean bOK
24046>>>>>>>
24046>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
24047>>>>>>>        If (bOK = False) Begin
24049>>>>>>>            Function_Return sReturnArray
24050>>>>>>>        End
24050>>>>>>>>
24050>>>>>>>
24050>>>>>>>        Case Begin
24050>>>>>>>            Case (sDriverID = DB2_DRV_ID)
24052>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
24053>>>>>>>                Case Break
24054>>>>>>>
24054>>>>>>>            Case (sDriverID = MDSPgSQL)
24057>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
24058>>>>>>>                Case Break
24059>>>>>>>
24059>>>>>>>            Case (sDriverID = ORAFLEX)
24062>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
24063>>>>>>>                Case Break
24064>>>>>>>
24064>>>>>>>            Case Else
24064>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
24065>>>>>>>>
24065>>>>>>>                Case Break
24066>>>>>>>        Case End
24066>>>>>>>
24066>>>>>>>        Function_Return sReturnArray
24067>>>>>>>    End_Function
24068>>>>>>>
24068>>>>>>>    // Returns all schemas as a string array for the passed driver id.
24068>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
24070>>>>>>>        String[] sReturnArray
24071>>>>>>>        Boolean bOK
24071>>>>>>>
24071>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
24072>>>>>>>        If (bOK = False) Begin
24074>>>>>>>            Function_Return sReturnArray
24075>>>>>>>        End
24075>>>>>>>>
24075>>>>>>>
24075>>>>>>>        Case Begin
24075>>>>>>>            Case (sDriverID = DB2_DRV_ID)
24077>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
24078>>>>>>>                Case Break
24079>>>>>>>
24079>>>>>>>            Case (sDriverID = MDSPgSQL)
24082>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
24083>>>>>>>                Case Break
24084>>>>>>>
24084>>>>>>>            Case (sDriverID = ORAFLEX)
24087>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
24088>>>>>>>                Case Break
24089>>>>>>>
24089>>>>>>>            Case Else
24089>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
24090>>>>>>>>
24090>>>>>>>                Case Break
24091>>>>>>>        Case End
24091>>>>>>>
24091>>>>>>>        Function_Return sReturnArray
24092>>>>>>>    End_Function
24093>>>>>>>
24093>>>>>>>    // Returns a string array with all tables for the current database.
24093>>>>>>>    Function SqlUtilEnumerateTables String sDriverID Returns String[]
24095>>>>>>>        String[] sReturnArray sArray
24097>>>>>>>        String sDatabase sConnectionString sSelect sSchema
24097>>>>>>>        Integer iSize iCount iDbType
24097>>>>>>>        Boolean bOK
24097>>>>>>>
24097>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
24099>>>>>>>            Function_Return sArray
24100>>>>>>>        End
24100>>>>>>>>
24100>>>>>>>
24100>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
24101>>>>>>>        If (bOK = False) Begin
24103>>>>>>>            Function_Return sReturnArray
24104>>>>>>>        End
24104>>>>>>>>
24104>>>>>>>
24104>>>>>>>        Get psConnectionString to sConnectionString
24105>>>>>>>        Get psDatabase to sDatabase
24106>>>>>>>        Get psSchema   to sSchema
24107>>>>>>>
24107>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
24107>>>>>>>        // the dbType.
24107>>>>>>>        Get piDbType to iDbType
24108>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
24110>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
24112>>>>>>>                Move MDSMySQL to sDriverID
24113>>>>>>>            End
24113>>>>>>>>
24113>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
24115>>>>>>>                Move MSSQLDRV_ID to sDriverID
24116>>>>>>>            End
24116>>>>>>>>
24116>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
24118>>>>>>>                Move DB2_DRV_ID to sDriverID
24119>>>>>>>            End
24119>>>>>>>>
24119>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
24121>>>>>>>                Move MDSPgSQL to sDriverID
24122>>>>>>>            End
24122>>>>>>>>
24122>>>>>>>        End
24122>>>>>>>>
24122>>>>>>>
24122>>>>>>>        Case Begin
24122>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
24124>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
24125>>>>>>>                Case Break
24126>>>>>>>
24126>>>>>>>            Case (sDriverID = DB2_DRV_ID)
24129>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
24130>>>>>>>                Case Break
24131>>>>>>>
24131>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
24134>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
24135>>>>>>>                Case Break
24136>>>>>>>
24136>>>>>>>            Case (sDriverID = SQLFLEX)
24139>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
24140>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
24141>>>>>>>                Case Break
24142>>>>>>>
24142>>>>>>>            Case (sDriverID = MDSMySQL)
24145>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
24146>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
24147>>>>>>>                Case Break
24148>>>>>>>
24148>>>>>>>            Case (sDriverID = MDSPgSQL)
24151>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
24152>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
24153>>>>>>>                Case Break
24154>>>>>>>
24154>>>>>>>            Case (sDriverID = ORAFLEX)
24157>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
24158>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
24159>>>>>>>                Move (SizeOfArray(sArray)) to iSize
24160>>>>>>>                Decrement iSize
24161>>>>>>>                For iCount from 0 to iSize
24167>>>>>>>>
24167>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
24169>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
24170>>>>>>>                    End
24170>>>>>>>>
24170>>>>>>>                Loop
24171>>>>>>>>
24171>>>>>>>                Case Break
24172>>>>>>>
24172>>>>>>>            Case Else
24172>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
24173>>>>>>>>
24173>>>>>>>                Case Break
24174>>>>>>>        Case End
24174>>>>>>>
24174>>>>>>>        Function_Return sReturnArray
24175>>>>>>>    End_Function
24176>>>>>>>
24176>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
24176>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
24178>>>>>>>        String[] sReturnArray
24179>>>>>>>        String sConnectionString sSelect sSchema
24179>>>>>>>        Boolean bOK
24179>>>>>>>        Integer iDbType
24179>>>>>>>
24179>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
24180>>>>>>>        If (bOK = False) Begin
24182>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
24183>>>>>>>>
24183>>>>>>>            Function_Return sReturnArray
24184>>>>>>>        End
24184>>>>>>>>
24184>>>>>>>
24184>>>>>>>        Get psConnectionString to sConnectionString
24185>>>>>>>        Get psSchema to sSchema
24186>>>>>>>
24186>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
24186>>>>>>>        // the dbType.
24186>>>>>>>        Get piDbType to iDbType
24187>>>>>>>
24187>>>>>>>        Case Begin
24187>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
24189>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
24191>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
24192>>>>>>>                End
24192>>>>>>>>
24192>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
24194>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
24195>>>>>>>                End
24195>>>>>>>>
24195>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
24197>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
24198>>>>>>>                End
24198>>>>>>>>
24198>>>>>>>
24198>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
24199>>>>>>>                Case Break
24200>>>>>>>
24200>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
24203>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
24204>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
24205>>>>>>>                Case Break
24206>>>>>>>
24206>>>>>>>            Case (sDriverID = DB2_DRV_ID)
24209>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
24210>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
24211>>>>>>>                Case Break
24212>>>>>>>
24212>>>>>>>            Case (sDriverID = SQLFLEX)
24215>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
24216>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
24217>>>>>>>                Case Break
24218>>>>>>>
24218>>>>>>>            Case (sDriverID = MDSMySQL)
24221>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
24222>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
24223>>>>>>>                Case Break
24224>>>>>>>
24224>>>>>>>            Case (sDriverID = MDSPgSQL)
24227>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
24228>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
24229>>>>>>>                Case Break
24230>>>>>>>
24230>>>>>>>            Case (sDriverID = ORAFLEX)
24233>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
24234>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
24235>>>>>>>                Case Break
24236>>>>>>>
24236>>>>>>>            Case Else
24236>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
24237>>>>>>>>
24237>>>>>>>                Case Break
24238>>>>>>>        Case End
24238>>>>>>>
24238>>>>>>>        Function_Return sReturnArray
24239>>>>>>>    End_Function
24240>>>>>>>
24240>>>>>>>
24240>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
24240>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
24242>>>>>>>        String[] sReturnArray sReturnArray2
24244>>>>>>>        String sConnectionString sSelect sSchema
24244>>>>>>>        Boolean bOK
24244>>>>>>>        Integer iCount iSize
24244>>>>>>>
24244>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
24245>>>>>>>        If (bOK = False) Begin
24247>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
24248>>>>>>>>
24248>>>>>>>            Function_Return sReturnArray
24249>>>>>>>        End
24249>>>>>>>>
24249>>>>>>>
24249>>>>>>>        Get psConnectionString to sConnectionString
24250>>>>>>>        Get psSchema to sSchema
24251>>>>>>>
24251>>>>>>>        Case Begin
24251>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
24253>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
24254>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
24255>>>>>>>                Case Break
24256>>>>>>>
24256>>>>>>>            Case (sDriverID = DB2_DRV_ID)
24259>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24260>>>>>>>>
24260>>>>>>>//                Move () to sSelect
24260>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
24260>>>>>>>                Case Break
24261>>>>>>>
24261>>>>>>>            Case (sDriverID = SQLFLEX)
24264>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24265>>>>>>>>
24265>>>>>>>//                Move () to sSelect
24265>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
24265>>>>>>>                Case Break
24266>>>>>>>
24266>>>>>>>            Case (sDriverID = MDSMySQL)
24269>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24270>>>>>>>>
24270>>>>>>>//                Move () to sSelect
24270>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
24270>>>>>>>                Case Break
24271>>>>>>>
24271>>>>>>>            Case (sDriverID = MDSPgSQL)
24274>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24275>>>>>>>>
24275>>>>>>>//                Move () to sSelect
24275>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
24275>>>>>>>                Case Break
24276>>>>>>>
24276>>>>>>>            Case (sDriverID = ORAFLEX)
24279>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24280>>>>>>>>
24280>>>>>>>//                Move () to sSelect
24280>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
24280>>>>>>>                Case Break
24281>>>>>>>
24281>>>>>>>            Case Else
24281>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
24282>>>>>>>>
24282>>>>>>>                Case Break
24283>>>>>>>        Case End
24283>>>>>>>
24283>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
24284>>>>>>>        Decrement iSize
24285>>>>>>>        For iCount from 0 to iSize
24291>>>>>>>>
24291>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
24293>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
24294>>>>>>>            End
24294>>>>>>>>
24294>>>>>>>        Loop
24295>>>>>>>>
24295>>>>>>>
24295>>>>>>>        Function_Return sReturnArray2
24296>>>>>>>    End_Function
24297>>>>>>>
24297>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
24297>>>>>>>    // The format of the array is "TableName.FieldName"
24297>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
24299>>>>>>>        String[] sFileNameArray sFieldNameArray
24301>>>>>>>        tSQLRelation[] sRelationsArray
24301>>>>>>>        tSQLRelation[] sRelationsArray
24302>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
24302>>>>>>>        Boolean bOK
24302>>>>>>>        Integer iCount iSize iLength
24302>>>>>>>
24302>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
24303>>>>>>>        If (bOK = False) Begin
24305>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
24306>>>>>>>>
24306>>>>>>>            Function_Return sRelationsArray
24307>>>>>>>        End
24307>>>>>>>>
24307>>>>>>>
24307>>>>>>>        Get psConnectionString to sConnectionString
24308>>>>>>>        Get psSchema to sSchema
24309>>>>>>>
24309>>>>>>>        Case Begin
24309>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
24311>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
24312>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
24313>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
24314>>>>>>>                Case Break
24315>>>>>>>
24315>>>>>>>            Case (sDriverID = DB2_DRV_ID)
24318>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24319>>>>>>>>
24319>>>>>>>//                Move () to sSelect
24319>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
24319>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
24319>>>>>>>                Case Break
24320>>>>>>>
24320>>>>>>>            Case (sDriverID = SQLFLEX)
24323>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24324>>>>>>>>
24324>>>>>>>//                Move () to sSelect
24324>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
24324>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
24324>>>>>>>                Case Break
24325>>>>>>>
24325>>>>>>>            Case (sDriverID = MDSMySQL)
24328>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24329>>>>>>>>
24329>>>>>>>//                Move () to sSelect
24329>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
24329>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
24329>>>>>>>                Case Break
24330>>>>>>>
24330>>>>>>>            Case (sDriverID = MDSPgSQL)
24333>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24334>>>>>>>>
24334>>>>>>>//                Move () to sSelect
24334>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
24334>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
24334>>>>>>>                Case Break
24335>>>>>>>
24335>>>>>>>            Case (sDriverID = ORAFLEX)
24338>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
24339>>>>>>>>
24339>>>>>>>//                Move () to sSelect
24339>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
24339>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
24339>>>>>>>                Case Break
24340>>>>>>>
24340>>>>>>>            Case Else
24340>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
24341>>>>>>>>
24341>>>>>>>                Case Break
24342>>>>>>>        Case End
24342>>>>>>>
24342>>>>>>>        Move (Length(sTableName)) to iLength
24343>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
24344>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
24345>>>>>>>        Decrement iSize
24346>>>>>>>        For iCount from 0 to iSize
24352>>>>>>>>
24352>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
24354>>>>>>>                Move sFileNameArray[iCount]         to sFileName
24355>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
24356>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
24357>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
24358>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
24359>>>>>>>            End
24359>>>>>>>>
24359>>>>>>>        Loop
24360>>>>>>>>
24360>>>>>>>
24360>>>>>>>        Function_Return sRelationsArray
24361>>>>>>>    End_Function
24362>>>>>>>
24362>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
24364>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
24364>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
24365>>>>>>>        String[] sUsers sPrograms
24367>>>>>>>        String sSelect
24367>>>>>>>        Integer iSize iCount
24367>>>>>>>
24367>>>>>>>        Case Begin
24367>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
24369>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
24370>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
24371>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
24372>>>>>>>                Case Break
24373>>>>>>>            Case (sDriverID = SQLFLEX)
24376>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
24377>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
24378>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
24379>>>>>>>                Case Break
24380>>>>>>>            Case Else
24380>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
24381>>>>>>>>
24381>>>>>>>        Case End
24381>>>>>>>
24381>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
24382>>>>>>>        Decrement iSize
24383>>>>>>>        For iCount from 0 to iSize
24389>>>>>>>>
24389>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
24390>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
24391>>>>>>>        Loop
24392>>>>>>>>
24392>>>>>>>
24392>>>>>>>        Function_Return SQLLoggedInUser
24393>>>>>>>    End_Function
24394>>>>>>>
24394>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
24394>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
24394>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
24396>>>>>>>        String[] sFilesData
24397>>>>>>>        Boolean bExists
24397>>>>>>>        Integer iCh
24397>>>>>>>        String sFileName sExt
24397>>>>>>>
24397>>>>>>>        Get vFolderExists sDataPath to bExists
24398>>>>>>>        If (bExists = True) Begin
24400>>>>>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
24401>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
24402>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
24403>>>>>>>            Direct_Input channel iCh sDataPath
24405>>>>>>>                Repeat
24405>>>>>>>>
24405>>>>>>>                    Readln channel iCh sFileName
24407>>>>>>>                    Get ParseFileExtension sFileName to sExt
24408>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
24410>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
24412>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
24413>>>>>>>                        End
24413>>>>>>>>
24413>>>>>>>                    End
24413>>>>>>>>
24413>>>>>>>                Until (SeqEof = True)
24415>>>>>>>            Close_Input channel iCh
24417>>>>>>>            Send Seq_Release_Channel iCh
24418>>>>>>>        End
24418>>>>>>>>
24418>>>>>>>        Function_Return sFilesData
24419>>>>>>>    End_Function
24420>>>>>>>
24420>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
24420>>>>>>>    // for DAW drivers.
24420>>>>>>>    // Returns: A string array.
24420>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
24422>>>>>>>        String[] sReturnArray
24423>>>>>>>        String sValue sPrevious
24423>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
24423>>>>>>>        Integer iFetchResult iRows
24423>>>>>>>        tSQLConnection SQLConnection
24423>>>>>>>        tSQLConnection SQLConnection
24423>>>>>>>
24423>>>>>>>        Get phoSQLManager to hoSQLHandler
24424>>>>>>>
24424>>>>>>>        If (hoSQLHandler <> 0) Begin
24426>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
24427>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
24428>>>>>>>
24428>>>>>>>            If (hoSQLConnect <> 0) Begin
24430>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
24431>>>>>>>                If (hstmt <> 0) Begin
24433>>>>>>>                    Send SqlExecDirect of hstmt sStmt
24434>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
24435>>>>>>>                    Repeat
24435>>>>>>>>
24435>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
24436>>>>>>>                        If (iFetchResult <> 0) Begin
24438>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
24439>>>>>>>                            If (sValue <> sPrevious) Begin
24441>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
24442>>>>>>>                            End
24442>>>>>>>>
24442>>>>>>>                            Move sValue to sPrevious
24443>>>>>>>                        End
24443>>>>>>>>
24443>>>>>>>                    Until (iFetchResult = 0)
24445>>>>>>>                    Send SQLClose of hstmt
24446>>>>>>>                End
24446>>>>>>>>
24446>>>>>>>                Send SQLDisconnect of hoSQLConnect
24447>>>>>>>            End
24447>>>>>>>>
24447>>>>>>>        End
24447>>>>>>>>
24447>>>>>>>
24447>>>>>>>        Function_Return sReturnArray
24448>>>>>>>    End_Function
24449>>>>>>>
24449>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
24449>>>>>>>    // for Mertech drivers.
24449>>>>>>>    // Returns: A string array.
24449>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
24451>>>>>>>        String[] sReturnArray
24452>>>>>>>        String sValue sUserID sPassword
24452>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
24452>>>>>>>        Integer iFetchResult iRows
24452>>>>>>>        tSQLConnection SQLConnection
24452>>>>>>>        tSQLConnection SQLConnection
24452>>>>>>>
24452>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
24453>>>>>>>
24453>>>>>>>        If (hoSQLHandler <> 0) Begin
24455>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
24456>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
24457>>>>>>>
24457>>>>>>>            If (hoSQLConnect <> 0) Begin
24459>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
24460>>>>>>>                If (hStmt <> 0) Begin
24462>>>>>>>                    Send SqlExecDirect of hStmt sStmt
24463>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
24464>>>>>>>                    Repeat
24464>>>>>>>>
24464>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
24465>>>>>>>                        If (iFetchResult <> 0) Begin
24467>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
24468>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
24469>>>>>>>                        End
24469>>>>>>>>
24469>>>>>>>                    Until (iFetchResult = 0)
24471>>>>>>>                    Send SQLClose of hStmt
24472>>>>>>>                End
24472>>>>>>>>
24472>>>>>>>                Send SQLDisconnect of hoSQLConnect
24473>>>>>>>            End
24473>>>>>>>>
24473>>>>>>>        End
24473>>>>>>>>
24473>>>>>>>
24473>>>>>>>        Function_Return sReturnArray
24474>>>>>>>    End_Function
24475>>>>>>>
24475>>>>>>>    // * Dummy function for the Studio's Code Explorer *
24475>>>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
24477>>>>>>>        Function_Return False
24478>>>>>>>    End_Function
24479>>>>>>>
24479>>>>>>>    // Returns the index for the passed sTableName
24479>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
24479>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
24481>>>>>>>        Integer iIndex iSize iCount
24481>>>>>>>        String[] sTablesArray
24482>>>>>>>        String sVal sConnectionString
24482>>>>>>>
24482>>>>>>>        Move -1 to iIndex
24483>>>>>>>        Get psConnectionString to sConnectionString
24484>>>>>>>        Get SqlUtilEnumerateTables sDriverID to sTablesArray
24485>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
24486>>>>>>>        Decrement iSize
24487>>>>>>>        For iCount from 0 to iSize
24493>>>>>>>>
24493>>>>>>>            Move sTablesArray[iCount] to sVal
24494>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
24496>>>>>>>                Move iCount to iIndex // We found it!
24497>>>>>>>                Move iSize to iCount  // End the loop
24498>>>>>>>            End
24498>>>>>>>>
24498>>>>>>>        Loop
24499>>>>>>>>
24499>>>>>>>
24499>>>>>>>        Function_Return iIndex
24500>>>>>>>    End_Function
24501>>>>>>>
24501>>>>>>>    // Helper function that builds a string like;
24501>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
24501>>>>>>>    Function _SqlSelectFromWhereName Returns String
24503>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
24503>>>>>>>
24503>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
24504>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
24505>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
24506>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
24507>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
24508>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
24509>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
24510>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
24511>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
24512>>>>>>>        Function_Return sRetval
24513>>>>>>>    End_Function
24514>>>>>>>
24514>>>>>>>    // Helper function to create a SQL statement like;
24514>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
24514>>>>>>>    // Used for checking if an index exists.
24514>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
24516>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
24516>>>>>>>
24516>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
24517>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
24518>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
24519>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
24520>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
24521>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
24522>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
24523>>>>>>>
24523>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
24524>>>>>>>
24524>>>>>>>        Function_Return sRetval
24525>>>>>>>    End_Function
24526>>>>>>>
24526>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
24526>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
24526>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
24528>>>>>>>        String sRetval
24528>>>>>>>        If (iLength <> 0) Begin
24530>>>>>>>            Move ("(" + String(iLength)) to sRetval
24531>>>>>>>            If (iDecimals <> 0) Begin
24533>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
24534>>>>>>>            End
24534>>>>>>>>
24534>>>>>>>            Move (sRetval + ")") to sRetval
24535>>>>>>>        End
24535>>>>>>>>
24535>>>>>>>        Function_Return sRetval
24536>>>>>>>    End_Function
24537>>>>>>>
24537>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
24539>>>>>>>        Integer i iCols iItem
24539>>>>>>>        tSqlColumnNew[] aQueryColumns
24539>>>>>>>        tSqlColumnNew[] aQueryColumns
24540>>>>>>>
24540>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
24541>>>>>>>        For i from 1 to iCols
24547>>>>>>>>
24547>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
24548>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
24549>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
24550>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
24551>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
24552>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
24553>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
24554>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
24555>>>>>>>        Loop
24556>>>>>>>>
24556>>>>>>>        Set piColumns to iCols
24557>>>>>>>        Set paQueryColumns to aQueryColumns
24558>>>>>>>    End_Procedure
24559>>>>>>>
24559>>>>>>>    // Checks that the passed sDriverID is defined.
24559>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
24559>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
24561>>>>>>>        Boolean bOK
24561>>>>>>>        Integer iDriver
24561>>>>>>>
24561>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
24563>>>>>>>            Function_Return False
24564>>>>>>>        End
24564>>>>>>>>
24564>>>>>>>
24564>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
24565>>>>>>>
24565>>>>>>>        If (bOK = False) Begin
24567>>>>>>>            Get IsMertechDriver sDriverID to bOK
24568>>>>>>>        End
24568>>>>>>>>
24568>>>>>>>
24568>>>>>>>        If (bOK = False) Begin
24570>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
24571>>>>>>>>
24571>>>>>>>            Function_Return False
24572>>>>>>>        End
24572>>>>>>>>
24572>>>>>>>
24572>>>>>>>        Get DriverIndex sDriverID to iDriver
24573>>>>>>>        If (iDriver = 0) Begin
24575>>>>>>>            Load_Driver sDriverID
24576>>>>>>>        End
24576>>>>>>>>
24576>>>>>>>
24576>>>>>>>        Function_Return True
24577>>>>>>>    End_Function
24578>>>>>>>
24578>>>>>>>    // Checks that the length parameter has been passed correctly.
24578>>>>>>>    // This is only of concern for certain SQL data types.
24578>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
24580>>>>>>>        Integer iLength
24580>>>>>>>        Boolean bOK bCheckTypeLength
24580>>>>>>>
24580>>>>>>>        If (num_arguments > 1) Begin
24582>>>>>>>            Move iLen to iLength
24583>>>>>>>        End
24583>>>>>>>>
24583>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
24584>>>>>>>
24584>>>>>>>        If (bCheckTypeLength = True) Begin
24586>>>>>>>            Move (iLength > 0) to bOK
24587>>>>>>>        End
24587>>>>>>>>
24587>>>>>>>
24587>>>>>>>        Function_Return (bOK = True)
24588>>>>>>>    End_Function
24589>>>>>>>
24589>>>>>>>    Function _SqlProperTableName String sTableName Returns String
24591>>>>>>>        String sVal sSchema sDriverID
24591>>>>>>>        Integer iDbType
24591>>>>>>>
24591>>>>>>>        If (Trim(sTableName) = "") Begin
24593>>>>>>>            Function_Return ""
24594>>>>>>>        End
24594>>>>>>>>
24594>>>>>>>
24594>>>>>>>        Get psDriverID to sDriverID
24595>>>>>>>        Get piDbType   to iDbType
24596>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
24598>>>>>>>            Get psUserID to sSchema
24599>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
24599>>>>>>>            Move (Uppercase(sSchema)) to sSchema
24600>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
24601>>>>>>>            Function_Return sTableName
24602>>>>>>>        End
24602>>>>>>>>
24602>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
24604>>>>>>>            Get psDatabase to sVal
24605>>>>>>>            Move (sVal + "." + sTableName) to sTableName
24606>>>>>>>            Function_Return sTableName
24607>>>>>>>        End
24607>>>>>>>>
24607>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
24609>>>>>>>            Move ('"' + sTableName + '"') to sTableName
24610>>>>>>>            Function_Return sTableName
24611>>>>>>>        End
24611>>>>>>>>
24611>>>>>>>
24611>>>>>>>        Get psSchema to sSchema
24612>>>>>>>        If (sSchema = "") Begin
24614>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
24615>>>>>>>        End
24615>>>>>>>>
24615>>>>>>>
24615>>>>>>>        Move (Uppercase(sTableName)) to sVal
24616>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
24618>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
24620>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
24621>>>>>>>            End
24621>>>>>>>>
24621>>>>>>>            Else Begin
24622>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
24623>>>>>>>            End
24623>>>>>>>>
24623>>>>>>>        End
24623>>>>>>>>
24623>>>>>>>
24623>>>>>>>        Function_Return sTableName
24624>>>>>>>    End_Function
24625>>>>>>>
24625>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
24625>>>>>>>    // the passed sFieldName has the correct spelling.
24625>>>>>>>    // Used with Embedded SQL statement calls.
24625>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
24625>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
24627>>>>>>>        String sRetval sValue sDriverID
24627>>>>>>>        String[] sColumnNamesArray
24628>>>>>>>        Integer iCount iColumns
24628>>>>>>>
24628>>>>>>>        Move "" to sRetval
24629>>>>>>>        Get psDriverID to sDriverID
24630>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
24631>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
24632>>>>>>>        Decrement iColumns
24633>>>>>>>
24633>>>>>>>        For iCount from 0 to iColumns
24639>>>>>>>>
24639>>>>>>>            Move sColumnNamesArray[iCount] to sValue
24640>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
24642>>>>>>>                Move sValue to sRetval
24643>>>>>>>                Move iColumns to iCount // We're done.
24644>>>>>>>            End
24644>>>>>>>>
24644>>>>>>>        Loop
24645>>>>>>>>
24645>>>>>>>
24645>>>>>>>        Function_Return sRetval
24646>>>>>>>    End_Function
24647>>>>>>>
24647>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
24649>>>>>>>        String[] sReturnArray
24650>>>>>>>        Handle hoSQLHandler
24650>>>>>>>        Integer iCount iSize iItem
24650>>>>>>>        String sServer sUser sPassword
24650>>>>>>>        tSQLConnection SQLConnection
24650>>>>>>>        tSQLConnection SQLConnection
24650>>>>>>>
24650>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
24651>>>>>>>        Send Delete_Data    of hoSQLHandler
24652>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
24653>>>>>>>
24653>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
24654>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
24655>>>>>>>        Decrement iSize
24656>>>>>>>
24656>>>>>>>        For iCount from 0 to iSize
24662>>>>>>>>
24662>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
24663>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
24664>>>>>>>            Increment iItem
24665>>>>>>>        Loop
24666>>>>>>>>
24666>>>>>>>
24666>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
24667>>>>>>>
24667>>>>>>>        Function_Return sReturnArray
24668>>>>>>>    End_Function
24669>>>>>>>
24669>>>>>>>    Function _SqlTableArrayDAW Returns String[]
24671>>>>>>>        String[] sReturnArray
24672>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
24672>>>>>>>        Handle hoSQLHandler
24672>>>>>>>        Integer iCount iSize iItem iPos
24672>>>>>>>        Boolean bOK
24672>>>>>>>        tSQLConnection SQLConnection
24672>>>>>>>        tSQLConnection SQLConnection
24672>>>>>>>
24672>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
24673>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
24675>>>>>>>            Function_Return sReturnArray
24676>>>>>>>        End
24676>>>>>>>>
24676>>>>>>>
24676>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
24677>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
24678>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
24679>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
24680>>>>>>>
24680>>>>>>>        Get phoCLIHandler to hoSQLHandler
24681>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
24682>>>>>>>        Send Delete_Data  of hoSQLHandler
24683>>>>>>>
24683>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
24684>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
24685>>>>>>>        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
24687>>>>>>>            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
24689>>>>>>>                Move (Pos(";", sConnectionString)) to iPos
24690>>>>>>>                If (iPos > 0) Begin
24692>>>>>>>                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
24693>>>>>>>                    Move (Trim(sConnectionString)) to sConnectionString
24694>>>>>>>                End
24694>>>>>>>>
24694>>>>>>>            End
24694>>>>>>>>
24694>>>>>>>        End
24694>>>>>>>>
24694>>>>>>>
24694>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
24695>>>>>>>        Move False to Err
24696>>>>>>>        Move 0 to iItem
24697>>>>>>>
24697>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
24697>>>>>>>        for iCount from 1 to iSize
24703>>>>>>>>
24703>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
24704>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
24705>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
24706>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
24707>>>>>>>            Move (Trim(sTable)) to sTable
24708>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
24710>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
24711>>>>>>>            End
24711>>>>>>>>
24711>>>>>>>            Else Begin
24712>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
24713>>>>>>>            End
24713>>>>>>>>
24713>>>>>>>            If (bOK = True) Begin
24715>>>>>>>                Move sTable to sReturnArray[iItem]
24716>>>>>>>                Increment iItem
24717>>>>>>>            End
24717>>>>>>>>
24717>>>>>>>        Loop
24718>>>>>>>>
24718>>>>>>>
24718>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
24719>>>>>>>
24719>>>>>>>        Function_Return sReturnArray
24720>>>>>>>    End_Function
24721>>>>>>>
24721>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
24723>>>>>>>        String[] sReturnArray
24724>>>>>>>        String sValue
24724>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
24724>>>>>>>        Integer iRetval iCols iFetchResult
24724>>>>>>>        tSQLConnection SQLConnection
24724>>>>>>>        tSQLConnection SQLConnection
24724>>>>>>>
24724>>>>>>>        Get phoSQLManager to hoSQLHandler
24725>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
24726>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
24727>>>>>>>
24727>>>>>>>        If (hoSQLConnect <> 0) Begin
24729>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
24730>>>>>>>            If (hStmt <> 0) Begin
24732>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
24733>>>>>>>                If (sArgument <> "") Begin
24735>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
24736>>>>>>>                End
24736>>>>>>>>
24736>>>>>>>
24736>>>>>>>                Send SqlCall             of hStmt
24737>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
24738>>>>>>>                If (iRetval = 0) Begin
24740>>>>>>>                    Repeat
24740>>>>>>>>
24740>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
24741>>>>>>>                        If (iCols > 0) Begin
24743>>>>>>>                            Repeat
24743>>>>>>>>
24743>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
24744>>>>>>>                                If (iFetchResult <> 0) Begin
24746>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
24747>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
24748>>>>>>>                                End
24748>>>>>>>>
24748>>>>>>>                            Until (iFetchResult = 0)
24750>>>>>>>                        End
24750>>>>>>>>
24750>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
24751>>>>>>>                    Until (iRetval = 0)
24753>>>>>>>                    Send SqlClose of hStmt
24754>>>>>>>                End
24754>>>>>>>>
24754>>>>>>>            End
24754>>>>>>>>
24754>>>>>>>            Send SqlDisconnect of hoSQLConnect
24755>>>>>>>        End
24755>>>>>>>>
24755>>>>>>>        Function_Return sReturnArray
24756>>>>>>>    End_Function
24757>>>>>>>
24757>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
24759>>>>>>>        String[] sReturnArray
24760>>>>>>>        String sDataSource
24760>>>>>>>        Handle hoSQLHandler
24760>>>>>>>        Integer iItem
24760>>>>>>>
24760>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
24761>>>>>>>        Send SeedDataSources of hoSQLHandler
24762>>>>>>>
24762>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
24763>>>>>>>
24763>>>>>>>        Repeat
24763>>>>>>>>
24763>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
24764>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
24765>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
24766>>>>>>>            Increment iItem
24767>>>>>>>        Until (sDataSource = "")
24769>>>>>>>
24769>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
24770>>>>>>>
24770>>>>>>>        Function_Return sReturnArray
24771>>>>>>>    End_Function
24772>>>>>>>
24772>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
24774>>>>>>>        String[] sReturnArray
24775>>>>>>>        String sDataSource
24775>>>>>>>        Handle hoSQLHandler
24775>>>>>>>        Integer iItem
24775>>>>>>>
24775>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
24776>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
24777>>>>>>>
24777>>>>>>>        Send SeedDataSources of hoSQLHandler
24778>>>>>>>
24778>>>>>>>        Repeat
24778>>>>>>>>
24778>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
24779>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
24781>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
24782>>>>>>>                Increment iItem
24783>>>>>>>            End
24783>>>>>>>>
24783>>>>>>>        Until (sDataSource = "")
24785>>>>>>>
24785>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
24786>>>>>>>
24786>>>>>>>        Function_Return sReturnArray
24787>>>>>>>    End_Function
24788>>>>>>>
24788>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
24790>>>>>>>        String[] sDataSources
24791>>>>>>>        tSQLConnection SQLConnection
24791>>>>>>>        tSQLConnection SQLConnection
24791>>>>>>>        tSQLIntTableInfo[] sReturnArray
24791>>>>>>>        tSQLIntTableInfo[] sReturnArray
24792>>>>>>>        Integer iRetval iDataSources iCount iItem
24792>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
24792>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
24792>>>>>>>        Boolean bExists bKeyOpened
24792>>>>>>>
24792>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
24793>>>>>>>        Move SQLConnection.sConnectionString to sConnection
24794>>>>>>>        Move SQLConnection.sServer           to sServer
24795>>>>>>>
24795>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
24795>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
24797>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
24798>>>>>>>            Set psFileName of hoIniFile to sServer
24799>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
24800>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
24801>>>>>>>            Send Destroy of hoIniFile
24802>>>>>>>        End
24802>>>>>>>>
24802>>>>>>>
24802>>>>>>>        // DSN - read DATABASE name from the registry
24802>>>>>>>        Else Begin
24803>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
24804>>>>>>>
24804>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
24804>>>>>>>            // most probably place the info is kept that we're after.
24804>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
24805>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
24806>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
24807>>>>>>>            If (bExists = True) Begin
24809>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
24810>>>>>>>            End
24810>>>>>>>>
24810>>>>>>>            Else Begin
24811>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
24812>>>>>>>            End
24812>>>>>>>>
24812>>>>>>>
24812>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
24813>>>>>>>            If (bExists) Begin
24815>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
24816>>>>>>>                If (bKeyOpened) Begin
24818>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
24819>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
24820>>>>>>>                    If (iDataSources > 0) Begin
24822>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
24823>>>>>>>                        Decrement iDataSources
24824>>>>>>>                        for iCount from 0 to iDataSources
24830>>>>>>>>
24830>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
24831>>>>>>>                        Loop
24832>>>>>>>>
24832>>>>>>>                        Move 0 to iItem
24833>>>>>>>                        for iCount from 0 to iDataSources
24839>>>>>>>>
24839>>>>>>>                            Move sDataSources[iCount] to sSubKey
24840>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
24841>>>>>>>                            If (bKeyOpened = True) Begin
24843>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
24844>>>>>>>                                If (bExists = True) Begin
24846>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
24847>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
24848>>>>>>>                                    Increment iItem
24849>>>>>>>                                End
24849>>>>>>>>
24849>>>>>>>                            End
24849>>>>>>>>
24849>>>>>>>                        Loop
24850>>>>>>>>
24850>>>>>>>                    End
24850>>>>>>>>
24850>>>>>>>                    Send CloseKey of hoRegistry
24851>>>>>>>                    Send Destroy of hoODBCDataSources
24852>>>>>>>                End
24852>>>>>>>>
24852>>>>>>>            End
24852>>>>>>>>
24852>>>>>>>
24852>>>>>>>            // We then check the "User DNS" area in the registry.
24852>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
24853>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
24854>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
24855>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
24856>>>>>>>
24856>>>>>>>            If (bExists) Begin
24858>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
24859>>>>>>>                If (bKeyOpened) Begin
24861>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
24862>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
24863>>>>>>>                    If (iDataSources > 0) Begin
24865>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
24866>>>>>>>                        Decrement iDataSources
24867>>>>>>>                        for iCount from 0 to iDataSources
24873>>>>>>>>
24873>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
24874>>>>>>>                        Loop
24875>>>>>>>>
24875>>>>>>>                        for iCount from 0 to iDataSources
24881>>>>>>>>
24881>>>>>>>                            Move sDataSources[iCount] to sSubKey
24882>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
24883>>>>>>>                            If (bKeyOpened = True) Begin
24885>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
24886>>>>>>>                                If (bExists = True) Begin
24888>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
24889>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
24890>>>>>>>                                    Increment iItem
24891>>>>>>>                                End
24891>>>>>>>>
24891>>>>>>>                            End
24891>>>>>>>>
24891>>>>>>>                        Loop
24892>>>>>>>>
24892>>>>>>>                    End
24892>>>>>>>>
24892>>>>>>>                    Send CloseKey of hoRegistry
24893>>>>>>>                    Send Destroy of hoODBCDataSources
24894>>>>>>>                End
24894>>>>>>>>
24894>>>>>>>            End
24894>>>>>>>>
24894>>>>>>>
24894>>>>>>>            Send Destroy of hoRegistry
24895>>>>>>>        End
24895>>>>>>>>
24895>>>>>>>
24895>>>>>>>        Function_Return sReturnArray
24896>>>>>>>    End_Function
24897>>>>>>>
24897>>>>>>>    // We might have a split Sql script where the info about which database to use is
24897>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
24897>>>>>>>    // insert it for scriplets to come after the first one.
24897>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
24899>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
24899>>>>>>>        Integer iStart iEnd iDbType
24899>>>>>>>        Boolean bOK
24899>>>>>>>
24899>>>>>>>        Get piDbType to iDbType
24900>>>>>>>        Get psDriverID to sDriverID
24901>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
24902>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
24903>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
24904>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
24905>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
24906>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
24908>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
24909>>>>>>>            Move (Pos("]", sTmp)) to iEnd
24910>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
24911>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
24912>>>>>>>            Set Private.psUseDatabase to sUseDatabase
24913>>>>>>>        End
24913>>>>>>>>
24913>>>>>>>        Else Begin
24914>>>>>>>            Move (Uppercase(sStmt)) to sTmp
24915>>>>>>>
24915>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
24915>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
24917>>>>>>>                Get Private.psUseDatabase to sUseDatabase
24918>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
24919>>>>>>>            End
24919>>>>>>>>
24919>>>>>>>
24919>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
24919>>>>>>>            // We will get an error when trying to create a view if it already exists.
24919>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
24919>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
24922>>>>>>>                // Make sure we only have one space between statements/words.
24922>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
24923>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
24924>>>>>>>                Move (Trim(sTmp)) to sTmp
24925>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
24926>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
24927>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
24929>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
24930>>>>>>>                End
24930>>>>>>>>
24930>>>>>>>                Move (Trim(sTmp)) to sTmp
24931>>>>>>>                // Remove data view as it already exists!
24931>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
24932>>>>>>>            End
24932>>>>>>>>
24932>>>>>>>        End
24932>>>>>>>>
24932>>>>>>>
24932>>>>>>>        Function_Return sStmt
24933>>>>>>>    End_Function
24934>>>>>>>
24934>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
24934>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
24936>>>>>>>        String sRetval
24936>>>>>>>        Integer iDbType iIndex
24936>>>>>>>        tSQLKeyWords[] SQLKeywordArray
24936>>>>>>>        tSQLKeyWords[] SQLKeywordArray
24937>>>>>>>        tSQLKeyWords   SQLKeyWords
24937>>>>>>>        tSQLKeyWords   SQLKeyWords
24937>>>>>>>
24937>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
24937>>>>>>>        Get piDbType to iDbType
24938>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
24939>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
24940>>>>>>>
24940>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
24941>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
24942>>>>>>>        Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
24943>>>>>>>
24943>>>>>>>        Function_Return sRetval
24944>>>>>>>    End_Function
24945>>>>>>>
24945>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
24945>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
24947>>>>>>>        String[] sSQLScriptArray
24948>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
24948>>>>>>>        Integer iSize iCount
24948>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
24948>>>>>>>
24948>>>>>>>        Move False to bCommentStart
24949>>>>>>>        Move False to bCommentEnd
24950>>>>>>>        Move False to bDashComment
24951>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
24952>>>>>>>        Move "*/"  to sCommentEnd
24953>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
24954>>>>>>>
24954>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
24955>>>>>>>        Decrement iSize
24956>>>>>>>        Move "" to sText
24957>>>>>>>
24957>>>>>>>        For iCount from 0 to iSize
24963>>>>>>>>
24963>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
24964>>>>>>>            Move (Trim(sLine)) to sTmp
24965>>>>>>>            If (sTmp <> "") Begin
24967>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
24968>>>>>>>                If (bCommentStart = False) Begin
24970>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
24971>>>>>>>                    If (bCommentStart = False) Begin
24973>>>>>>>                    End
24973>>>>>>>>
24973>>>>>>>                End
24973>>>>>>>>
24973>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
24974>>>>>>>                If (bCommentEnd = True) Begin
24976>>>>>>>                    Move False to bCommentStart
24977>>>>>>>                End
24977>>>>>>>>
24977>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
24979>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
24980>>>>>>>                End
24980>>>>>>>>
24980>>>>>>>            End
24980>>>>>>>>
24980>>>>>>>        Loop
24981>>>>>>>>
24981>>>>>>>
24981>>>>>>>        // Update the retval struct array:
24981>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
24982>>>>>>>        Function_Return SqlScriptArray
24983>>>>>>>    End_Function
24984>>>>>>>
24984>>>>>>>
24984>>>>>>>    // *** Database API Functions: ***
24984>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
24984>>>>>>>    // make changes/updates to the database.
24984>>>>>>>
24984>>>>>>>    // * Dummy function for the Studio's Code Explorer *
24984>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
24986>>>>>>>        Function_Return False
24987>>>>>>>    End_Function
24988>>>>>>>
24988>>>>>>>    // This might not do what you think - Here's what it does:
24988>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
24988>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
24988>>>>>>>    // to the SQL table.
24988>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
24988>>>>>>>    // already exists in SQL.
24988>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
24988>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
24988>>>>>>>    // restructuring an existing table.
24988>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
24990>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
24990>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
24990>>>>>>>        Handle hToTable
24990>>>>>>>        Integer iPos
24990>>>>>>>
24990>>>>>>>        Move True to bUseConnectionID
24991>>>>>>>        If (num_arguments > 1) Begin
24993>>>>>>>            Move bUseConnID to bUseConnectionID
24994>>>>>>>        End
24994>>>>>>>>
24994>>>>>>>
24994>>>>>>>        Get psDriverID to sDriverID
24995>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
24995>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
24996>>>>>>>        If (bExists = False) Begin
24998>>>>>>>            Function_Return False
24999>>>>>>>        End
24999>>>>>>>>
24999>>>>>>>
24999>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
25000>>>>>>>
25000>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
25001>>>>>>>        If (bOK = False) Begin
25003>>>>>>>            Function_Return False
25004>>>>>>>        End
25004>>>>>>>>
25004>>>>>>>
25004>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
25004>>>>>>>        // we do nothing
25004>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
25005>>>>>>>        If (bExists = True) Begin
25007>>>>>>>            Function_Return False
25008>>>>>>>        End
25008>>>>>>>>
25008>>>>>>>
25008>>>>>>>        Get psConnectionID     to sConnectionID
25009>>>>>>>        Get psConnectionString to sConnectionString
25010>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
25012>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
25013>>>>>>>>
25013>>>>>>>            Function_Return False
25014>>>>>>>        End
25014>>>>>>>>
25014>>>>>>>
25014>>>>>>>        Set Private.phCurrentTable to hTable
25015>>>>>>>        Get psSchema to sSchema
25016>>>>>>>        If (sSchema = "") Begin
25018>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
25019>>>>>>>        End
25019>>>>>>>>
25019>>>>>>>
25019>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
25020>>>>>>>
25020>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
25020>>>>>>>        // was a programmer's error and we adjust for it here.
25020>>>>>>>        If (bMertechDriver = True) Begin
25022>>>>>>>            Move False to bUseConnectionID
25023>>>>>>>        End
25023>>>>>>>>
25023>>>>>>>
25023>>>>>>>        // If we should use a connection id we need to check it exists;
25023>>>>>>>        // else we create it before attempting creating the table
25023>>>>>>>        If (bUseConnectionID = True) Begin
25025>>>>>>>            Get AutoConnectionIDLogin to bOK
25026>>>>>>>            If (bOk = False) Begin
25028>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
25029>>>>>>>>
25029>>>>>>>                Function_Return False
25030>>>>>>>            End
25030>>>>>>>>
25030>>>>>>>        End
25030>>>>>>>>
25030>>>>>>>
25030>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
25033>>>>>>>        Get _TableNameOnly sRootName to sRootName
25034>>>>>>>        If (sRootName = "") Begin
25036>>>>>>>            Function_Return False
25037>>>>>>>        End
25037>>>>>>>>
25037>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
25038>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
25041>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
25044>>>>>>>
25044>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
25044>>>>>>>        //
25044>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
25044>>>>>>>        // because then the table should not be visible to users.
25044>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
25044>>>>>>>//        If (iPos <> 1) Begin
25044>>>>>>>//            If (sDisplayName contains ".") Begin
25044>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
25044>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
25044>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
25044>>>>>>>//            End
25044>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
25044>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
25044>>>>>>>//            End
25044>>>>>>>//        End
25044>>>>>>>
25044>>>>>>>        If (bIsAlias = False) Begin
25046>>>>>>>            Get OpenTableExclusive hTable to bOpened
25047>>>>>>>            If (bOpened = False) Begin
25049>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
25050>>>>>>>>
25050>>>>>>>                Function_Return False
25051>>>>>>>            End
25051>>>>>>>>
25051>>>>>>>        End
25051>>>>>>>>
25051>>>>>>>
25051>>>>>>>        If (ghoProgressBar <> 0) Begin
25053>>>>>>>            Send DoAdvance of ghoProgressBar
25054>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
25055>>>>>>>        End
25055>>>>>>>>
25055>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
25055>>>>>>>        Move hTable to hToTable
25056>>>>>>>        Move False to Err
25057>>>>>>>
25057>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
25057>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
25057>>>>>>>        // a proper and updated .int file.
25057>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
25060>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
25061>>>>>>>
25061>>>>>>>        If (bIsAlias = False) Begin
25063>>>>>>>            Structure_Start hToTable sDriverID
25064>>>>>>>                Set Private.phCurrentTable to hTable
25065>>>>>>>                If (bUseConnectionID = True) Begin
25067>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
25070>>>>>>>                End
25070>>>>>>>>
25070>>>>>>>                Else Begin
25071>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
25074>>>>>>>                End
25074>>>>>>>>
25074>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
25077>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
25077>>>>>>>                Move False to Err
25078>>>>>>>                Move 0 to LastErr
25079>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
25080>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
25082>>>>>>>            Set Action_Text of ghoStatusPanel to ""
25083>>>>>>>        End
25083>>>>>>>>
25083>>>>>>>
25083>>>>>>>        Move (not(Err)) to bOK
25084>>>>>>>        If (bOK = True) Begin
25086>>>>>>>            // The attributes set above will always trigger an error
25086>>>>>>>            // We also adjust the Filelist entries
25086>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
25089>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
25092>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
25095>>>>>>>
25095>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
25095>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
25096>>>>>>>        End
25096>>>>>>>>
25096>>>>>>>
25096>>>>>>>        Function_Return (bOK = True)
25097>>>>>>>    End_Function
25098>>>>>>>
25098>>>>>>>    // Sample usage:
25098>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
25098>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
25098>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
25100>>>>>>>        Boolean bOK bIsSQLTable
25100>>>>>>>
25100>>>>>>>        Get AutoConnectionIDLogin to bOK
25101>>>>>>>        Move False to Err
25102>>>>>>>        Get OpenTableExclusive hTable to bOK
25103>>>>>>>        If (bOK = False) Begin
25105>>>>>>>            Function_Return False
25106>>>>>>>        End
25106>>>>>>>>
25106>>>>>>>
25106>>>>>>>        // ToDo: Add to all table change functions!
25106>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
25107>>>>>>>            If (bIsSQLTable = True) Begin
25109>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
25112>>>>>>>            End
25112>>>>>>>>
25112>>>>>>>
25112>>>>>>>        Set Private.phCurrentTable to hTable
25113>>>>>>>        Structure_Start hTable
25114>>>>>>>            Set_Attribute iAttribute of hTable to iValue
25117>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
25118>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
25120>>>>>>>
25120>>>>>>>        Set Action_Text of ghoStatusPanel to ""
25121>>>>>>>        Function_Return (Err = False)
25122>>>>>>>    End_Function
25123>>>>>>>
25123>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
25123>>>>>>>    // or to change the filelist slot names.
25123>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
25125>>>>>>>        Boolean bExists
25125>>>>>>>
25125>>>>>>>        Move False to Err
25126>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
25127>>>>>>>        If (bExists = False) Begin
25129>>>>>>>            Function_Return False
25130>>>>>>>        End
25130>>>>>>>>
25130>>>>>>>
25130>>>>>>>        If (ghoProgressBar <> 0) Begin
25132>>>>>>>            Send DoAdvance of ghoProgressBar
25133>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
25134>>>>>>>        End
25134>>>>>>>>
25134>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
25134>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
25136>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
25139>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
25142>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
25145>>>>>>>            Function_Return (Err = False) // And we're done.
25146>>>>>>>        End
25146>>>>>>>>
25146>>>>>>>
25146>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
25148>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
25151>>>>>>>        End
25151>>>>>>>>
25151>>>>>>>        Else Begin
25152>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
25155>>>>>>>        End
25155>>>>>>>>
25155>>>>>>>
25155>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
25158>>>>>>>
25158>>>>>>>        // This seems no longer be the case for the Studio to automatically add the schema name
25158>>>>>>>        // in front of the DISPLAY_NAME for the table.
25158>>>>>>>//        If (sDriverID <> DATAFLEX_ID and not(Uppercase(sDisplayName) contains "DBO.")) Begin
25158>>>>>>>//            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ("dbo." + sDisplayName)
25158>>>>>>>//        End
25158>>>>>>>//        Else Begin
25158>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
25161>>>>>>>//        End
25161>>>>>>>
25161>>>>>>>        Function_Return (Err = False)
25162>>>>>>>    End_Function
25163>>>>>>>
25163>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
25165>>>>>>>        Boolean bOK
25165>>>>>>>
25165>>>>>>>        Get AutoConnectionIDLogin to bOK
25166>>>>>>>        Move False to Err
25167>>>>>>>        Get OpenTableExclusive hTable to bOK
25168>>>>>>>        If (bOK = False) Begin
25170>>>>>>>            Function_Return False
25171>>>>>>>        End
25171>>>>>>>>
25171>>>>>>>
25171>>>>>>>        Set Private.phCurrentTable to hTable
25172>>>>>>>        Structure_Start hTable
25173>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
25176>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
25177>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
25179>>>>>>>
25179>>>>>>>        Set Action_Text of ghoStatusPanel to ""
25180>>>>>>>        Function_Return (Err = False)
25181>>>>>>>    End_Function
25182>>>>>>>
25182>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
25184>>>>>>>        Boolean bOK
25184>>>>>>>
25184>>>>>>>        Move False to Err
25185>>>>>>>        Get AutoConnectionIDLogin to bOK
25186>>>>>>>        Open hToTable
25188>>>>>>>        Get OpenTableExclusive hTable to bOK
25189>>>>>>>        If (bOK = False) Begin
25191>>>>>>>            Function_Return False
25192>>>>>>>        End
25192>>>>>>>>
25192>>>>>>>
25192>>>>>>>        Set Private.phCurrentTable to hTable
25193>>>>>>>        Structure_Start hTable
25194>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
25197>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
25200>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
25201>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
25203>>>>>>>
25203>>>>>>>        Set Action_Text of ghoStatusPanel to ""
25204>>>>>>>        Function_Return (Err = False)
25205>>>>>>>    End_Function
25206>>>>>>>
25206>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
25208>>>>>>>        Integer[] aTableConvertExceptions
25209>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
25210>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
25211>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
25212>>>>>>>    End_Procedure
25213>>>>>>>
25213>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
25215>>>>>>>        Integer[] aTableDateCorrectionExceptions
25216>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
25217>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
25218>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
25219>>>>>>>    End_Procedure
25220>>>>>>>
25220>>>>>>>    Procedure ApiTableConvertALLToSql
25222>>>>>>>        Integer[] iTablesArray
25223>>>>>>>        Integer iSize iCount
25223>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
25223>>>>>>>        String sDriverID
25223>>>>>>>
25223>>>>>>>        Get psDriverID to sDriverID
25224>>>>>>>        Get pbUseConnectionID to bUseConnectionID
25225>>>>>>>        Get pbToANSI          to bToANSI
25226>>>>>>>        Get pbRecnum          to bRecnum
25227>>>>>>>        Get pbCopyData        to bCopyData
25228>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
25230>>>>>>>            Get pbContinueOnError to bContinueOnError
25231>>>>>>>        End
25231>>>>>>>>
25231>>>>>>>
25231>>>>>>>        Get _AllTablesToConvert to iTablesArray
25232>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
25233>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
25234>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
25235>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
25236>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
25237>>>>>>>
25237>>>>>>>        Decrement iSize
25238>>>>>>>        For iCount from 0 to iSize
25244>>>>>>>>
25244>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
25245>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
25246>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
25246>>>>>>>            // if there was an error converting one table...
25246>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
25246>>>>>>>        Loop
25247>>>>>>>>
25247>>>>>>>
25247>>>>>>>    End_Procedure
25248>>>>>>>
25248>>>>>>>    Procedure ApiTableAttachALLToSql
25250>>>>>>>        Integer[] iTablesArray
25251>>>>>>>        Integer iSize iCount
25251>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
25251>>>>>>>        String sDriverID
25251>>>>>>>
25251>>>>>>>        Get psDriverID to sDriverID
25252>>>>>>>        Get pbUseConnectionID to bUseConnectionID
25253>>>>>>>        Get pbToANSI          to bToANSI
25254>>>>>>>        Get pbRecnum          to bRecnum
25255>>>>>>>        Get pbCopyData        to bCopyData
25256>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
25258>>>>>>>            Get pbContinueOnError to bContinueOnError
25259>>>>>>>        End
25259>>>>>>>>
25259>>>>>>>
25259>>>>>>>        Get _AllTablesToConvert to iTablesArray
25260>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
25261>>>>>>>        Decrement iSize
25262>>>>>>>        For iCount from 0 to iSize
25268>>>>>>>>
25268>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
25269>>>>>>>        Loop
25270>>>>>>>>
25270>>>>>>>
25270>>>>>>>    End_Procedure
25271>>>>>>>
25271>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
25271>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
25273>>>>>>>        Handle hTable
25273>>>>>>>        String sRootNameTo sLogicalNameTo sDisplayNameTo sConnectionID
25273>>>>>>>        Boolean bIsSQLTableFrom bTableExists bSameTableNames bANSI bOK
25273>>>>>>>
25273>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
25274>>>>>>>        If (bSameTableNames = True) Begin
25276>>>>>>>            Function_Return True
25277>>>>>>>        End
25277>>>>>>>>
25277>>>>>>>
25277>>>>>>>        Move True to bOK
25278>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
25279>>>>>>>        Set Private.phCurrentTable              to hTable
25280>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
25283>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
25286>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
25289>>>>>>>
25289>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
25291>>>>>>>            Get psConnectionID to sConnectionID
25292>>>>>>>            Get UtilTableExists hTable to bTableExists
25293>>>>>>>            If (bTableExists = True) Begin
25295>>>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
25296>>>>>>>            End
25296>>>>>>>>
25296>>>>>>>            Else Begin
25297>>>>>>>                Get pbToANSI to bANSI
25298>>>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
25299>>>>>>>            End
25299>>>>>>>>
25299>>>>>>>        End
25299>>>>>>>>
25299>>>>>>>
25299>>>>>>>        Function_Return bOK
25300>>>>>>>    End_Function
25301>>>>>>>
25301>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
25303>>>>>>>        Handle hToTable hoLogFile
25303>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
25303>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
25303>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
25303>>>>>>>        tSQLConnection SQLConnection
25303>>>>>>>        tSQLConnection SQLConnection
25303>>>>>>>
25303>>>>>>>        Get UtilTableExists hTable to bExists
25304>>>>>>>        If (bExists = False) Begin
25306>>>>>>>            Set Private.phCurrentTable to hTable
25307>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
25308>>>>>>>>
25308>>>>>>>            Function_Return False
25309>>>>>>>        End
25309>>>>>>>>
25309>>>>>>>
25309>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
25310>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
25310>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
25310>>>>>>>        If (bIsAlias = True) Begin
25312>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
25315>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
25317>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
25320>>>>>>>                Get psConnectionID to sConnectionID
25321>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
25322>>>>>>>            End
25322>>>>>>>>
25322>>>>>>>            Function_Return True
25323>>>>>>>        End
25323>>>>>>>>
25323>>>>>>>
25323>>>>>>>        Set Private.phCurrentTable to hTable
25324>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
25327>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
25330>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
25333>>>>>>>
25333>>>>>>>        If (ghoProgressBar <> 0) Begin
25335>>>>>>>            Send DoAdvance of ghoProgressBar
25336>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
25337>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
25338>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
25339>>>>>>>        End
25339>>>>>>>>
25339>>>>>>>
25339>>>>>>>        // Marco Kuipers suggestion;
25339>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
25339>>>>>>>        // an SQL table; rename the SQL table by adding a GUID at the end, then convert the
25339>>>>>>>        // table again.
25339>>>>>>>        Get UtilTableIsSQL hTable to bOK
25340>>>>>>>        If (bOK = False) Begin
25342>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
25343>>>>>>>            If (bExists = True) Begin
25345>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
25346>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
25347>>>>>>>                Get phoLogFile to hoLogFile
25348>>>>>>>                If (hoLogFile <> 0) Begin
25350>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
25351>>>>>>>                    Send LogError sWarning False
25352>>>>>>>                End
25352>>>>>>>>
25352>>>>>>>                Else Begin
25353>>>>>>>                    Error DFERR_PROGRAM sWarning
25354>>>>>>>>
25354>>>>>>>                End
25354>>>>>>>>
25354>>>>>>>            End
25354>>>>>>>>
25354>>>>>>>        End
25354>>>>>>>>
25354>>>>>>>
25354>>>>>>>        // Does the rootname contain a driver?
25354>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
25356>>>>>>>            // Does the table already exist as an SQL table?
25356>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
25357>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
25357>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
25357>>>>>>>            If (bExists = False) Begin
25359>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
25360>>>>>>>            End
25360>>>>>>>>
25360>>>>>>>            If (bExists = True) Begin
25362>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
25363>>>>>>>                Function_Return False
25364>>>>>>>            End
25364>>>>>>>>
25364>>>>>>>        End
25364>>>>>>>>
25364>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
25365>>>>>>>
25365>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
25366>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
25366>>>>>>>        // passed as True, we adjust for that here.
25366>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
25367>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
25369>>>>>>>            Move False to bUseConnectionID
25370>>>>>>>        End
25370>>>>>>>>
25370>>>>>>>
25370>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
25371>>>>>>>        Move SQLConnection.sSchema           to sSchema
25372>>>>>>>        If (sSchema = "") Begin
25374>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
25375>>>>>>>            Move (Lowercase(sSchema))        to sSchema
25376>>>>>>>        End
25376>>>>>>>>
25376>>>>>>>
25376>>>>>>>        If (sDriverID = ORAFLEX) Begin
25378>>>>>>>            Move SQLConnection.sUserID       to sSchema
25379>>>>>>>        End
25379>>>>>>>>
25379>>>>>>>
25379>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
25380>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
25381>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
25382>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
25384>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
25385>>>>>>>>
25385>>>>>>>            Function_Return False
25386>>>>>>>        End
25386>>>>>>>>
25386>>>>>>>
25386>>>>>>>        Get AutoConnectionIDLogin to bOK
25387>>>>>>>        Open hTable
25389>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
25392>>>>>>>        If (bOpened = False) Begin
25394>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
25395>>>>>>>>
25395>>>>>>>            Function_Return False
25396>>>>>>>        End
25396>>>>>>>>
25396>>>>>>>
25396>>>>>>>        If (ghoProgressBar <> 0) Begin
25398>>>>>>>            Send DoAdvance of ghoProgressBar
25399>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
25400>>>>>>>        End
25400>>>>>>>>
25400>>>>>>>
25400>>>>>>>        Move 0 to hToTable
25401>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
25402>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
25403>>>>>>>
25403>>>>>>>        Case Begin
25403>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
25405>>>>>>>                Case Break
25406>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
25409>>>>>>>                Case Break
25410>>>>>>>            Case (sDriverID = DB2_DRV_ID)
25413>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
25414>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
25415>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
25416>>>>>>>                Case Break
25417>>>>>>>            Case (sDriverID = ORAFLEX)
25420>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
25421>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
25422>>>>>>>                Case Break
25423>>>>>>>            Case (sDriverID = MDSMySQL)
25426>>>>>>>                Case Break
25427>>>>>>>            Case (sDriverID = MDSPgSQL)
25430>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
25431>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
25432>>>>>>>                Case Break
25433>>>>>>>            Case (sDriverID = DATAFLEX_ID)
25436>>>>>>>                Case Break
25437>>>>>>>            Case Else
25437>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
25438>>>>>>>>
25438>>>>>>>                Case Break
25439>>>>>>>        Case End
25439>>>>>>>
25439>>>>>>>        Move False to Err
25440>>>>>>>
25440>>>>>>>        If (bMertechDriver = True) Begin
25442>>>>>>>            // Note: This function also sets the Err flag.
25442>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
25443>>>>>>>        End
25443>>>>>>>>
25443>>>>>>>
25443>>>>>>>        If (bMertechDriver = False) Begin
25445>>>>>>>            Structure_Start hToTable sDriverID
25446>>>>>>>                Structure_Copy hTable to hToTable
25447>>>>>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
25450>>>>>>>
25450>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
25452>>>>>>>                    If (bUseConnectionID = True) Begin
25454>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
25457>>>>>>>                    End
25457>>>>>>>>
25457>>>>>>>                    Else Begin
25458>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
25461>>>>>>>                    End
25461>>>>>>>>
25461>>>>>>>
25461>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
25464>>>>>>>
25464>>>>>>>                    If (sSchema <> "") Begin
25466>>>>>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
25469>>>>>>>                    End
25469>>>>>>>>
25469>>>>>>>
25469>>>>>>>                    If (sDriverID = DB2_DRV_ID) Begin
25471>>>>>>>                        If (sLongTableSpace <> "") Begin
25473>>>>>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
25476>>>>>>>                        End
25476>>>>>>>>
25476>>>>>>>                        If (sBaseTableSpace <> "") Begin
25478>>>>>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
25481>>>>>>>                        End
25481>>>>>>>>
25481>>>>>>>                        If (sIndexTableSpace <> "") Begin
25483>>>>>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
25486>>>>>>>                        End
25486>>>>>>>>
25486>>>>>>>                    End
25486>>>>>>>>
25486>>>>>>>                End
25486>>>>>>>>
25486>>>>>>>
25486>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
25487>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
25489>>>>>>>            Set Action_Text of ghoStatusPanel to ""
25490>>>>>>>        End
25490>>>>>>>>
25490>>>>>>>
25490>>>>>>>        Move (not(Err)) to bOK
25491>>>>>>>
25491>>>>>>>        If (bOK = True and bCopyData = True) Begin
25493>>>>>>>            If (bMertechDriver = False) Begin
25495>>>>>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
25496>>>>>>>            End
25496>>>>>>>>
25496>>>>>>>            Else Begin
25497>>>>>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
25498>>>>>>>            End
25498>>>>>>>>
25498>>>>>>>
25498>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
25500>>>>>>>                Get pbContinueOnError to bContinueOnError
25501>>>>>>>            End
25501>>>>>>>>
25501>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
25501>>>>>>>            // rename it by adding a GUID to the end of the table name
25501>>>>>>>            // - or as much as "fit" because different SQL back-ends have
25501>>>>>>>            // different rules how long a table name can be.
25501>>>>>>>            // The new table will probably contain data but something went
25501>>>>>>>            // wrong while converting the data from embedded to SQL.
25501>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
25503>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
25504>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
25505>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
25506>>>>>>>>
25506>>>>>>>            End
25506>>>>>>>>
25506>>>>>>>        End
25506>>>>>>>>
25506>>>>>>>
25506>>>>>>>        // This must be after copying data...
25506>>>>>>>        If (Err = False) Begin
25508>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
25511>>>>>>>            // It seems the Studio does not do this any more, so commented out.
25511>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
25511>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
25511>>>>>>>            //                // The max length for the display_name is 31 characters...
25511>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
25511>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
25511>>>>>>>            //                End
25511>>>>>>>            //            End
25511>>>>>>>        End
25511>>>>>>>>
25511>>>>>>>
25511>>>>>>>        Close hTable
25512>>>>>>>        Move (not(Err)) to bOK
25513>>>>>>>        Function_Return bOK
25514>>>>>>>    End_Function
25515>>>>>>>
25515>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
25515>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
25515>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
25515>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
25517>>>>>>>        Boolean bOpened bOK
25517>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
25517>>>>>>>        String sErrorFile sEmpty sPath
25517>>>>>>>
25517>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
25520>>>>>>>        Get AutoConnectionIDLogin to bOK
25521>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
25523>>>>>>>            Send IncreaseSortBufferSize
25524>>>>>>>//            Send SetAllIndexesToBatch hToTable
25524>>>>>>>        End
25524>>>>>>>>
25524>>>>>>>
25524>>>>>>>        Move False to Err
25525>>>>>>>        Open sPhysicalName as hToTable
25527>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
25530>>>>>>>        If (bOpened = False) Begin
25532>>>>>>>            Function_Return False
25533>>>>>>>        End
25533>>>>>>>>
25533>>>>>>>
25533>>>>>>>        If (ghoStatusPanel <> 0) Begin
25535>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
25536>>>>>>>            Set piMinimum of ghoProgressBar to 0
25537>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
25538>>>>>>>        End
25538>>>>>>>>
25538>>>>>>>
25538>>>>>>>        Move "" to sEmpty
25539>>>>>>>        Move False to Err
25540>>>>>>>        Move True to bOK
25541>>>>>>>        Set Private.phCurrentTable to hToTable
25542>>>>>>>
25542>>>>>>>        // No need to get the record identifier
25542>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
25545>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
25548>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
25550>>>>>>>            // Remove all indices to speed up copying of data:
25550>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
25555>>>>>>>            If (iRetval <> 0) Begin
25557>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
25558>>>>>>>>
25558>>>>>>>                Function_Return False
25559>>>>>>>            End
25559>>>>>>>>
25559>>>>>>>        End
25559>>>>>>>>
25559>>>>>>>
25559>>>>>>>        Move (sRootName + ".err") to sErrorFile
25560>>>>>>>        Move 0 to iIndex
25561>>>>>>>        Move False to Err
25562>>>>>>>
25562>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
25564>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
25567>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
25572>>>>>>>            If (iRetval <> 0) Begin
25574>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
25575>>>>>>>>
25575>>>>>>>                Function_Return False
25576>>>>>>>            End
25576>>>>>>>>
25576>>>>>>>        End
25576>>>>>>>>
25576>>>>>>>        Else Begin
25577>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
25580>>>>>>>        End
25580>>>>>>>>
25580>>>>>>>
25580>>>>>>>        If (Err = False) Begin
25582>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
25583>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
25584>>>>>>>        End
25584>>>>>>>>
25584>>>>>>>
25584>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
25586>>>>>>>            // Recreate indices:
25586>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
25591>>>>>>>            If (iRetval <> 0) Begin
25593>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
25594>>>>>>>>
25594>>>>>>>                Function_Return False
25595>>>>>>>            End
25595>>>>>>>>
25595>>>>>>>        End
25595>>>>>>>>
25595>>>>>>>
25595>>>>>>>        Close hToTable
25596>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
25599>>>>>>>
25599>>>>>>>        If (bOK = True) Begin
25601>>>>>>>            Move (not(Err)) to bOK
25602>>>>>>>        End
25602>>>>>>>>
25602>>>>>>>
25602>>>>>>>        If (ghoStatusPanel <> 0) Begin
25604>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
25605>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
25606>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
25607>>>>>>>        End
25607>>>>>>>>
25607>>>>>>>
25607>>>>>>>        Function_Return (bOK = True)
25608>>>>>>>    End_Function
25609>>>>>>>
25609>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
25609>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
25609>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
25611>>>>>>>        Handle hFile
25611>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
25611>>>>>>>        Integer iColumn iIdentityType iDataType iDbType iCount iSize
25611>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
25611>>>>>>>        tSQLConnection SQLConnection
25611>>>>>>>        tSQLConnection SQLConnection
25611>>>>>>>        tAPIColumn[] aColumns
25611>>>>>>>        tAPIColumn[] aColumns
25612>>>>>>>        tColumnType ColumnType
25612>>>>>>>        tColumnType ColumnType
25612>>>>>>>
25612>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
25612>>>>>>>        Get UtilTableExists hTable to bOk
25613>>>>>>>        If (bOk = True) Begin
25615>>>>>>>            Function_Return False
25616>>>>>>>        End
25616>>>>>>>>
25616>>>>>>>
25616>>>>>>>        Set Private.phCurrentTable to hTable
25617>>>>>>>        Move sLogicalName to sTableName
25618>>>>>>>        If (ghoProgressBar <> 0) Begin
25620>>>>>>>            Send DoAdvance of ghoProgressBar
25621>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
25622>>>>>>>        End
25622>>>>>>>>
25622>>>>>>>
25622>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
25623>>>>>>>        Get psDriverID to sDriverID
25624>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
25625>>>>>>>        Get piDbType to iDbType
25626>>>>>>>
25626>>>>>>>        // If no columns passed in, we need to create a "dummy" column
25626>>>>>>>        Move False to bDeleteDummy
25627>>>>>>>        If (Num_Arguments = 8) Begin
25629>>>>>>>            Move aColumnIn to aColumns
25630>>>>>>>        End
25630>>>>>>>>
25630>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
25632>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
25633>>>>>>>            Move ColumnType.iSQLType to iDataType
25634>>>>>>>            If (bRecnum = False) Begin
25636>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
25637>>>>>>>            End
25637>>>>>>>>
25637>>>>>>>            Else Begin
25638>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
25639>>>>>>>            End
25639>>>>>>>>
25639>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
25640>>>>>>>            Move True to bDeleteDummy
25641>>>>>>>        End
25641>>>>>>>>
25641>>>>>>>
25641>>>>>>>        // If columns have been passed as an array we need to check if an identity column
25641>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
25641>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
25641>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
25641>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
25643>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
25644>>>>>>>            Decrement iSize
25645>>>>>>>            for iCount from 0 to iSize
25651>>>>>>>>
25651>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
25653>>>>>>>                    Move False to bRecnum
25654>>>>>>>                    Move iSize to iCount
25655>>>>>>>                End
25655>>>>>>>>
25655>>>>>>>            Loop
25656>>>>>>>>
25656>>>>>>>        End
25656>>>>>>>>
25656>>>>>>>
25656>>>>>>>        // If this is a SQL based driver we also check if the table exists
25656>>>>>>>        // in the SQL back end; in case we do nothing.
25656>>>>>>>        If (bSqlDriver = True) Begin
25658>>>>>>>            // Get all connection properties
25658>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
25659>>>>>>>            Move SQLConnection.sSchema to sSchema
25660>>>>>>>            If (sSchema = "") Begin
25662>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
25663>>>>>>>            End
25663>>>>>>>>
25663>>>>>>>
25663>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
25664>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
25664>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
25664>>>>>>>            If (bExists = False) Begin
25666>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
25667>>>>>>>            End
25667>>>>>>>>
25667>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
25667>>>>>>>            // we will just add it to Filelist.cfg
25667>>>>>>>            If (bExists = True) Begin
25669>>>>>>>                If (bExistsInFilelist = False) Begin
25671>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
25673>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
25674>>>>>>>                    End
25674>>>>>>>>
25674>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
25677>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
25680>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
25683>>>>>>>                    Move False to bSysFile
25684>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
25685>>>>>>>                End
25685>>>>>>>>
25685>>>>>>>                Function_Return False
25686>>>>>>>            End
25686>>>>>>>>
25686>>>>>>>        End
25686>>>>>>>>
25686>>>>>>>
25686>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
25687>>>>>>>        If (num_arguments > 6) Begin
25689>>>>>>>            If (bANSI = False) Begin
25691>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
25692>>>>>>>            End
25692>>>>>>>>
25692>>>>>>>        End
25692>>>>>>>>
25692>>>>>>>
25692>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
25692>>>>>>>        // is a programmer's error and we auto-correct for it here.
25692>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
25692>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
25692>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
25692>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
25692>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
25693>>>>>>>        If (bMertechDriver = True) Begin
25695>>>>>>>            If (bUseConnectionID = True) Begin
25697>>>>>>>                Move False to bUseConnectionID
25698>>>>>>>            End
25698>>>>>>>>
25698>>>>>>>            Move sDriverID to sOriginalDriverID
25699>>>>>>>            Move DATAFLEX_ID to sDriverID
25700>>>>>>>        End
25700>>>>>>>>
25700>>>>>>>
25700>>>>>>>        Move False to Err
25701>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
25703>>>>>>>            Move sRootName to sPhysicalFile
25704>>>>>>>        End
25704>>>>>>>>
25704>>>>>>>
25704>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
25706>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
25707>>>>>>>
25707>>>>>>>            // If DAW driver and we should use a connection id we need to
25707>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
25707>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
25709>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
25710>>>>>>>                If (bExists = False) Begin
25712>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
25713>>>>>>>                    If (bOk = False) Begin
25715>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
25716>>>>>>>>
25716>>>>>>>                        Function_Return False
25717>>>>>>>                    End
25717>>>>>>>>
25717>>>>>>>                End
25717>>>>>>>>
25717>>>>>>>            End
25717>>>>>>>>
25717>>>>>>>
25717>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
25719>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
25720>>>>>>>            End
25720>>>>>>>>
25720>>>>>>>            Else Begin
25721>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
25722>>>>>>>            End
25722>>>>>>>>
25722>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
25723>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
25723>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
25723>>>>>>>//            End
25723>>>>>>>        End
25723>>>>>>>>
25723>>>>>>>        Move False to Err
25724>>>>>>>        Move 0 to hFile
25725>>>>>>>
25725>>>>>>>        Structure_Start hFile sDriverID
25726>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
25728>>>>>>>                If (bUseConnectionID = True) Begin
25730>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
25733>>>>>>>                End
25733>>>>>>>>
25733>>>>>>>                Else Begin
25734>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
25737>>>>>>>                End
25737>>>>>>>>
25737>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
25740>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
25743>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
25746>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
25749>>>>>>>
25749>>>>>>>                If (sSchema <> "") Begin
25751>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
25754>>>>>>>                End
25754>>>>>>>>
25754>>>>>>>
25754>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
25756>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
25758>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
25761>>>>>>>                    End
25761>>>>>>>>
25761>>>>>>>                End
25761>>>>>>>>
25761>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
25763>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
25765>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
25768>>>>>>>                    End
25768>>>>>>>>
25768>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
25770>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
25773>>>>>>>                    End
25773>>>>>>>>
25773>>>>>>>                End
25773>>>>>>>>
25773>>>>>>>            End
25773>>>>>>>>
25773>>>>>>>
25773>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
25776>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
25777>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
25778>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
25780>>>>>>>        Set Action_Text of ghoStatusPanel to ""
25781>>>>>>>
25781>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
25781>>>>>>>        If (bMertechDriver = True) Begin
25783>>>>>>>            Move sOriginalDriverID to sDriverID
25784>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
25786>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
25787>>>>>>>            End
25787>>>>>>>>
25787>>>>>>>            // Note: This function also sets the Err flag.
25787>>>>>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
25787>>>>>>>        End
25787>>>>>>>>
25787>>>>>>>
25787>>>>>>>        Move (not(Err)) to bOK
25788>>>>>>>        If (bOk = True) Begin
25790>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
25792>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
25793>>>>>>>            End
25793>>>>>>>>
25793>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
25796>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
25799>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
25802>>>>>>>
25802>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
25802>>>>>>>            If (bDeleteDummy) Begin
25804>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
25805>>>>>>>            End
25805>>>>>>>>
25805>>>>>>>        End
25805>>>>>>>>
25805>>>>>>>
25805>>>>>>>        Close hTable
25806>>>>>>>        Function_Return (bOK = True)
25807>>>>>>>    End_Function
25808>>>>>>>
25808>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
25810>>>>>>>        Move False to Err
25811>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
25814>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
25817>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
25820>>>>>>>
25820>>>>>>>        Function_Return (Err = False)
25821>>>>>>>    End_Function
25822>>>>>>>
25822>>>>>>>    // ToDo: Needs to be revised
25822>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
25824>>>>>>>        Handle hTable
25824>>>>>>>        String sDEFName sDataPath
25824>>>>>>>        Boolean bExists
25824>>>>>>>
25824>>>>>>>        // Do nothing if MSSQL Driver.
25824>>>>>>>//        Get IsMSSQLDriver to bExists
25824>>>>>>>//        If (bExists = True) Begin
25824>>>>>>>//            Procedure_Return
25824>>>>>>>//        End
25824>>>>>>>
25824>>>>>>>        Get psDataPathFirstPart to sDataPath
25825>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
25826>>>>>>>        If (bExists = True) Begin
25828>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
25828>>>>>>>            // still be missing from the filelist and needs to be added.
25828>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
25829>>>>>>>            If (bExists = True) Begin
25831>>>>>>>                Procedure_Return
25832>>>>>>>            End
25832>>>>>>>>
25832>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
25832>>>>>>>            Else Begin
25833>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
25836>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
25839>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
25842>>>>>>>                Procedure_Return
25843>>>>>>>            End
25843>>>>>>>>
25843>>>>>>>        End
25843>>>>>>>>
25843>>>>>>>
25843>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
25844>>>>>>>        Move 0 to hTable
25845>>>>>>>        Move False to Err
25846>>>>>>>
25846>>>>>>>        Structure_Start hTable DATAFLEX_ID
25847>>>>>>>            Load_Def sDEFName Onto hTable
25848>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
25851>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
25852>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
25854>>>>>>>        Set Action_Text of ghoStatusPanel to ""
25855>>>>>>>
25855>>>>>>>        Move iFilelistSlot to hTable
25856>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
25859>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
25862>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
25865>>>>>>>
25865>>>>>>>    End_Procedure
25866>>>>>>>
25866>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
25868>>>>>>>        Boolean bTmp bErr bOK
25868>>>>>>>        String sTableName sDisplayName sFileName
25868>>>>>>>
25868>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
25868>>>>>>>        Move Err to bTmp
25869>>>>>>>        Move False to Err
25870>>>>>>>
25870>>>>>>>        Get AutoConnectionIDLogin to bOK
25871>>>>>>>        // First get the info for the current filelist slot:
25871>>>>>>>        Open iFromFileSlot
25873>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
25876>>>>>>>        If (bOK = True) Begin
25878>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
25881>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
25884>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
25887>>>>>>>
25887>>>>>>>            //...then move it.
25887>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
25890>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
25893>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
25896>>>>>>>
25896>>>>>>>            //...and finally remove the old filelist values.
25896>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
25899>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
25902>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
25905>>>>>>>        End
25905>>>>>>>>
25905>>>>>>>        Close iFromFileSlot
25906>>>>>>>
25906>>>>>>>        Move Err to bErr
25907>>>>>>>        Move bTmp to Err
25908>>>>>>>        Function_Return (bErr = False)
25909>>>>>>>    End_Function
25910>>>>>>>
25910>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
25912>>>>>>>        Handle hTable
25912>>>>>>>        Boolean bOK bExists
25912>>>>>>>        String sDriverID
25912>>>>>>>
25912>>>>>>>        Get UtilTableExists hTableFrom to bOK
25913>>>>>>>        If (bOK = False) Begin
25915>>>>>>>            Set Private.phCurrentTable to hTableFrom
25916>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
25917>>>>>>>>
25917>>>>>>>            Function_Return False
25918>>>>>>>        End
25918>>>>>>>>
25918>>>>>>>
25918>>>>>>>        Get UtilTableExists hTableTo to bOK
25919>>>>>>>        If (bOK = False) Begin
25921>>>>>>>            Set Private.phCurrentTable to hTableTo
25922>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
25923>>>>>>>>
25923>>>>>>>            Function_Return False
25924>>>>>>>        End
25924>>>>>>>>
25924>>>>>>>
25924>>>>>>>        Get AutoConnectionIDLogin to bOK
25925>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
25926>>>>>>>        If (bOK = False) Begin
25928>>>>>>>            Function_Return False
25929>>>>>>>        End
25929>>>>>>>>
25929>>>>>>>
25929>>>>>>>        Move False to Err
25930>>>>>>>        Open hTableTo
25932>>>>>>>
25932>>>>>>>        Move hTableFrom to hTable
25933>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
25936>>>>>>>        Set Private.phCurrentTable to hTable
25937>>>>>>>
25937>>>>>>>        Structure_Start hTable sDriverID
25938>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
25941>>>>>>>            If (iColumnTo <> 0) Begin
25943>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
25946>>>>>>>            End
25946>>>>>>>>
25946>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
25947>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
25949>>>>>>>        Set Action_Text of ghoStatusPanel to ""
25950>>>>>>>
25950>>>>>>>        If (hTableTo > 0) Begin
25952>>>>>>>            Close hTableTo
25953>>>>>>>        End
25953>>>>>>>>
25953>>>>>>>
25953>>>>>>>        Function_Return (Err = False)
25954>>>>>>>    End_Function
25955>>>>>>>
25955>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
25955>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
25957>>>>>>>        String sTableName sDriverID
25957>>>>>>>        Boolean bOk
25957>>>>>>>        String sDataPath
25957>>>>>>>
25957>>>>>>>        Get AutoConnectionIDLogin to bOK
25958>>>>>>>        Move False to Err
25959>>>>>>>        Get psDriverID to sDriverID
25960>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
25961>>>>>>>        If (sTableName = "") Begin
25963>>>>>>>            Function_Return False
25964>>>>>>>        End
25964>>>>>>>>
25964>>>>>>>
25964>>>>>>>        Set Private.phCurrentTable to hTable
25965>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
25966>>>>>>>        Delete_db sTableName
25967>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
25968>>>>>>>
25968>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
25970>>>>>>>            Get SqlTableRemoveByTableName sDriverID sTableName to bOk
25971>>>>>>>            Get psDataPathFirstPart to sDataPath
25972>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
25973>>>>>>>        End
25973>>>>>>>>
25973>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
25973>>>>>>>        If (hTable <> 0) Begin
25975>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
25978>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
25981>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
25984>>>>>>>        End
25984>>>>>>>>
25984>>>>>>>
25984>>>>>>>        Close hTable
25985>>>>>>>        Function_Return (hTable <> 0)
25986>>>>>>>    End_Function
25987>>>>>>>
25987>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
25989>>>>>>>        Handle hTable
25989>>>>>>>        Boolean bOK
25989>>>>>>>
25989>>>>>>>        Get AutoConnectionIDLogin to bOK
25990>>>>>>>        Move False to Err
25991>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
25993>>>>>>>        Move hTableFrom to hTable
25994>>>>>>>
25994>>>>>>>        Structure_Start hTable
25995>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
25998>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
25999>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
26001>>>>>>>        Set Action_Text of ghoStatusPanel to ""
26002>>>>>>>
26002>>>>>>>        Close hTableFrom
26003>>>>>>>        Function_Return (Err = False)
26004>>>>>>>    End_Function
26005>>>>>>>
26005>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
26007>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
26007>>>>>>>        Boolean bOK bExists bOpened
26007>>>>>>>        tAPITableNameInfo APITableNameInfo
26007>>>>>>>        tAPITableNameInfo APITableNameInfo
26007>>>>>>>
26007>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
26010>>>>>>>        If (bOpened = False) Begin
26012>>>>>>>            Get OpenTableExclusive hTable to bOpened
26013>>>>>>>            If (bOpened = False) Begin
26015>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
26016>>>>>>>                Function_Return False
26017>>>>>>>            End
26017>>>>>>>>
26017>>>>>>>        End
26017>>>>>>>>
26017>>>>>>>
26017>>>>>>>        Set Private.phCurrentTable to hTable
26018>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
26019>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
26020>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
26021>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
26022>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
26023>>>>>>>        If (bExists = True) Begin
26025>>>>>>>            Function_Return True
26026>>>>>>>        End
26026>>>>>>>>
26026>>>>>>>
26026>>>>>>>        Set Private.phCurrentTable to hTable
26027>>>>>>>        Move False to Err
26028>>>>>>>        Get psDataPathFirstPart to sDataPath
26029>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
26032>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
26035>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
26038>>>>>>>
26038>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
26041>>>>>>>        Close hTable
26042>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
26044>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
26045>>>>>>>            If (bExists = True) Begin
26047>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
26049>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
26052>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
26052>>>>>>>                    // might report "File in use..." and the deletion will fail.
26052>>>>>>>                    Sleep 2
26053>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
26054>>>>>>>                End
26054>>>>>>>>
26054>>>>>>>            End
26054>>>>>>>>
26054>>>>>>>        End
26054>>>>>>>>
26054>>>>>>>
26054>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
26056>>>>>>>            If (not(sPhysicalName contains ".")) Begin
26058>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
26059>>>>>>>            End
26059>>>>>>>>
26059>>>>>>>
26059>>>>>>>            // Change the table name in the .int file to the new table new:
26059>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
26060>>>>>>>            If (bOK = False) Begin
26062>>>>>>>                Function_Return False
26063>>>>>>>            End
26063>>>>>>>>
26063>>>>>>>
26063>>>>>>>            // Change table name at the SQL side:
26063>>>>>>>            Get psSchema to sSchema
26064>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
26065>>>>>>>
26065>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
26066>>>>>>>            // Remove cache file and Rename the physical file names:
26066>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
26067>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
26068>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
26069>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
26070>>>>>>>
26070>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
26070>>>>>>>//            If (not(sDisplayName contains ".")) Begin
26070>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
26070>>>>>>>//            End
26070>>>>>>>        End
26070>>>>>>>>
26070>>>>>>>
26070>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
26073>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
26076>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
26079>>>>>>>
26079>>>>>>>        Function_Return (Err = False)
26080>>>>>>>    End_Function
26081>>>>>>>
26081>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
26083>>>>>>>        Move False to Err
26084>>>>>>>        Set Private.phCurrentTable to hTable
26085>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
26088>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
26091>>>>>>>
26091>>>>>>>        Function_Return (Err = False)
26092>>>>>>>    End_Function
26093>>>>>>>
26093>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
26093>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
26093>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
26095>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
26095>>>>>>>        Handle hTable
26095>>>>>>>        Boolean bIsSame
26095>>>>>>>
26095>>>>>>>        Move APITableInfo.iTableNumber      to hTable
26096>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
26097>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
26100>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
26101>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
26104>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
26107>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
26108>>>>>>>
26108>>>>>>>        If (bCompareFilelistUppercase = True) Begin
26110>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
26111>>>>>>>        End
26111>>>>>>>>
26111>>>>>>>        Else Begin
26112>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
26113>>>>>>>        End
26113>>>>>>>>
26113>>>>>>>
26113>>>>>>>        Function_Return bIsSame
26114>>>>>>>    End_Function
26115>>>>>>>
26115>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
26115>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
26117>>>>>>>        Handle hFile hTable
26117>>>>>>>        String sTableName sLogicalName sDisplayName
26117>>>>>>>        String sConnectionID sVal sSchema sOriginalDriverID sDriverIDFrom sDriverIDTo sRootName
26117>>>>>>>        Integer iColumn iDbType
26117>>>>>>>        Boolean bOk bExists bMertechDriver bExistsInFilelist bOpened bApiTableUpdateAuto
26117>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
26117>>>>>>>        Boolean bIsSame bSameTableNames bFilelistError bIsAliasFrom bIsAliasTo bIsSQLTableFrom bIsSQLTableTo
26117>>>>>>>        tSQLConnection SQLConnection
26117>>>>>>>        tSQLConnection SQLConnection
26117>>>>>>>        tAPITable      APITableFrom APITableTo
26117>>>>>>>        tAPITable      APITableFrom APITableTo
26117>>>>>>>        tColumnType    ColumnType
26117>>>>>>>        tColumnType    ColumnType
26117>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
26117>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
26118>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
26118>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
26119>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
26119>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
26120>>>>>>>
26120>>>>>>>        // We don't allow changes to the framework's DbVersion table.
26120>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
26122>>>>>>>            Function_Return False
26123>>>>>>>        End
26123>>>>>>>>
26123>>>>>>>
26123>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
26124>>>>>>>        Get piDbType                            to iDbType
26125>>>>>>>        Get pbRecnum                            to bRecnum
26126>>>>>>>        Get pbToANSI                            to bToANSI
26127>>>>>>>        Get pbCopyData                          to bCopyData
26128>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
26129>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
26130>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
26131>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
26132>>>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
26133>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
26134>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
26136>>>>>>>            Move False                          to bUseConnectionID
26137>>>>>>>        End
26137>>>>>>>>
26137>>>>>>>
26137>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
26138>>>>>>>        Set Private.phCurrentTable              to hTable
26139>>>>>>>        Get UtilTableExists  hTable             to bTableExists
26140>>>>>>>
26140>>>>>>>        If (ghoProgressBar <> 0) Begin
26142>>>>>>>            Send DoAdvance of ghoProgressBar
26143>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
26144>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
26145>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
26146>>>>>>>        End
26146>>>>>>>>
26146>>>>>>>
26146>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
26147>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
26148>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
26149>>>>>>>        Get UtilTableIsSQL   hTable             to bIsSQLTableTo
26150>>>>>>>        Move True                               to APITableFrom.bFromTable
26151>>>>>>>        Move hTable                             to APITableFrom.hTable
26152>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
26153>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
26154>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
26155>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
26156>>>>>>>
26156>>>>>>>        If (bTableExists = True) Begin
26158>>>>>>>            If (bIsSQLTableTo = True) Begin
26160>>>>>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
26161>>>>>>>            End
26161>>>>>>>>
26161>>>>>>>
26161>>>>>>>            Get OpenTableExclusive hTable to bOpened
26162>>>>>>>            If (bOpened = False) Begin
26164>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
26165>>>>>>>                Function_Return False
26166>>>>>>>            End
26166>>>>>>>>
26166>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
26167>>>>>>>            Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns     APITableTo.aApiColumns    to aAPIColumnCompare
26168>>>>>>>            Get UtilIndexCombineFromAndToArrays  APITableFrom.aApiIndexes     APITableTo.aApiIndexes    to aAPIIndexCompare
26169>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
26170>>>>>>>        End
26170>>>>>>>>
26170>>>>>>>
26170>>>>>>>        Move False to Err
26171>>>>>>>        Case Begin
26171>>>>>>>            // Alias table:
26171>>>>>>>            Case (bIsAliasFrom = True)
26173>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
26174>>>>>>>                Case Break
26175>>>>>>>
26175>>>>>>>            // New Table:
26175>>>>>>>            Case (bTableExists = False)
26178>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
26179>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
26180>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
26181>>>>>>>                Case Break
26182>>>>>>>
26182>>>>>>>            // Update table:
26182>>>>>>>            Case (bTableExists = True)
26185>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
26186>>>>>>>                If (bIsSame = True) Begin
26188>>>>>>>                    Case Break
26189>>>>>>>                End
26189>>>>>>>>
26189>>>>>>>                If (bFilelistError = True) Begin
26191>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
26192>>>>>>>                    If (bOk = False) Begin
26194>>>>>>>                        Case Break
26195>>>>>>>                    End
26195>>>>>>>>
26195>>>>>>>                End
26195>>>>>>>>
26195>>>>>>>
26195>>>>>>>                If (ghoProgressBar <> 0) Begin
26197>>>>>>>                    Send DoAdvance of ghoProgressBar
26198>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
26199>>>>>>>                End
26199>>>>>>>>
26199>>>>>>>
26199>>>>>>>                // Columns:
26199>>>>>>>                Move True to bOk
26200>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
26201>>>>>>>                If (bIsSame = False) Begin
26203>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
26204>>>>>>>                End
26204>>>>>>>>
26204>>>>>>>                If (bOk = False) Begin
26206>>>>>>>                    Case Break
26207>>>>>>>                End
26207>>>>>>>>
26207>>>>>>>
26207>>>>>>>                // Indexes:
26207>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
26208>>>>>>>                If (bIsSame = False) Begin
26210>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
26211>>>>>>>                End
26211>>>>>>>>
26211>>>>>>>
26211>>>>>>>                // Relations:
26211>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
26212>>>>>>>                If (bIsSame = False) Begin
26214>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
26215>>>>>>>                    If (bOk = False) Begin
26217>>>>>>>                        Case Break
26218>>>>>>>                    End
26218>>>>>>>>
26218>>>>>>>                End
26218>>>>>>>>
26218>>>>>>>
26218>>>>>>>                // Filelist Names:
26218>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
26219>>>>>>>                Case Break
26220>>>>>>>
26220>>>>>>>            Case Else
26220>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
26221>>>>>>>>
26221>>>>>>>                Move False to bOk
26222>>>>>>>        Case End
26222>>>>>>>
26222>>>>>>>        Close hTable
26223>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
26224>>>>>>>
26224>>>>>>>        Function_Return (bOK = True)
26225>>>>>>>    End_Function
26226>>>>>>>
26226>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
26226>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
26226>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
26226>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
26226>>>>>>>    //
26226>>>>>>>    // The root of the problem is the following:
26226>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
26226>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
26226>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
26226>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
26226>>>>>>>    // an SQL error will be thrown;
26226>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
26226>>>>>>>    Function ApiTableFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
26228>>>>>>>        Boolean bOK bIsAlias bIsSQL
26228>>>>>>>        Integer iCount iSize iDateSize iItems
26228>>>>>>>        Handle hTable
26228>>>>>>>        String sLogicalName
26228>>>>>>>        Integer[] aTablesToCheck aDateFields
26230>>>>>>>
26230>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
26231>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
26232>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
26233>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
26234>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
26235>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
26236>>>>>>>
26236>>>>>>>        Move True to bOK
26237>>>>>>>        Decrement iSize
26238>>>>>>>        for iCount from 0 to iSize
26244>>>>>>>>
26244>>>>>>>            Move aTablesToCheck[iCount] to hTable
26245>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
26246>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
26247>>>>>>>            Get UtilTableIsSql   hTable to bIsSQL
26248>>>>>>>
26248>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
26251>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
26252>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
26253>>>>>>>
26253>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
26255>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
26256>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
26257>>>>>>>                If (iDateSize > 0) Begin
26259>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
26260>>>>>>>                    Close hTable
26261>>>>>>>                End
26261>>>>>>>>
26261>>>>>>>            End
26261>>>>>>>>
26261>>>>>>>        Loop
26262>>>>>>>>
26262>>>>>>>
26262>>>>>>>        Close DF_ALL
26263>>>>>>>        Function_Return bOK
26264>>>>>>>    End_Function
26265>>>>>>>
26265>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
26265>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
26267>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
26269>>>>>>>        Integer iField iSize iCount iType
26269>>>>>>>        Boolean bOpen bOK
26269>>>>>>>
26269>>>>>>>        Get UtilTableExists hTable to bOK
26270>>>>>>>        If (bOK = False) Begin
26272>>>>>>>            Set Private.phCurrentTable to hTable
26273>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
26274>>>>>>>>
26274>>>>>>>            Function_Return aDateFieldsEmpty
26275>>>>>>>        End
26275>>>>>>>>
26275>>>>>>>
26275>>>>>>>        Open hTable
26277>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
26280>>>>>>>        If (bOpen = False) Begin
26282>>>>>>>            Error ("Table could not be opened." * String(hTable))
26283>>>>>>>>
26283>>>>>>>            Function_Return aDateFieldsEmpty
26284>>>>>>>        End
26284>>>>>>>>
26284>>>>>>>
26284>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
26287>>>>>>>        for iCount from 1 to iSize
26293>>>>>>>>
26293>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
26296>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
26298>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
26299>>>>>>>            End
26299>>>>>>>>
26299>>>>>>>        Loop
26300>>>>>>>>
26300>>>>>>>
26300>>>>>>>        Function_Return aDateFields
26301>>>>>>>    End_Function
26302>>>>>>>
26302>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
26302>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
26302>>>>>>>    // and the record is saved
26302>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
26302>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
26302>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
26304>>>>>>>        Integer iSize iCount iField iRecord iRetval iTotalRecords iDateFormat
26304>>>>>>>        String sValue
26304>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges
26304>>>>>>>        Date dDate dDateMin
26304>>>>>>>        Integer[] iaChangeField
26305>>>>>>>
26305>>>>>>>        Get UtilTableExists hTable to bOK
26306>>>>>>>        If (bOK = False) Begin
26308>>>>>>>            Set Private.phCurrentTable to hTable
26309>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
26310>>>>>>>>
26310>>>>>>>            Function_Return False
26311>>>>>>>        End
26311>>>>>>>>
26311>>>>>>>
26311>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
26311>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
26311>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
26314>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
26317>>>>>>>
26317>>>>>>>        Send SetAllIndexesToBatch hTable True
26318>>>>>>>        Open hTable
26320>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
26323>>>>>>>        If (bOpened = False) Begin
26325>>>>>>>            Function_Return False
26326>>>>>>>        End
26326>>>>>>>>
26326>>>>>>>
26326>>>>>>>        Set Private.phCurrentTable to hTable
26327>>>>>>>        Move 0 to iRecord
26328>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
26329>>>>>>>        Decrement iSize
26330>>>>>>>
26330>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
26333>>>>>>>        Set piPosition   of ghoProgressBar to 0
26334>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
26335>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
26336>>>>>>>        Move CS_DUFLowestAllowedDateValue  to dDateMin
26337>>>>>>>        Move False to Err
26338>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
26339>>>>>>>
26339>>>>>>>        Clear hTable
26340>>>>>>>        Repeat
26340>>>>>>>>
26340>>>>>>>            Vfind hTable 0 GT
26342>>>>>>>            Move Found to bFound
26343>>>>>>>            If (bFound = True) Begin
26345>>>>>>>                Move False to bSaveChanges
26346>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
26347>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
26348>>>>>>>                Decrement iSize
26349>>>>>>>                for iCount from 0 to iSize
26355>>>>>>>>
26355>>>>>>>                    Move aDateFields[iCount] to iField
26356>>>>>>>                    Get_Field_Value hTable iField to dDate
26359>>>>>>>                    If (bFixZeroDates = True) Begin
26361>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
26362>>>>>>>                    End
26362>>>>>>>>
26362>>>>>>>                    Else Begin
26363>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
26364>>>>>>>                    End
26364>>>>>>>>
26364>>>>>>>                    If (bChange = True) Begin
26366>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
26367>>>>>>>                    End
26367>>>>>>>>
26367>>>>>>>                Loop
26368>>>>>>>>
26368>>>>>>>
26368>>>>>>>                // Only change Date fields that needs to be changed.
26368>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
26370>>>>>>>                    Reread hTable
26374>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
26375>>>>>>>                        Decrement iSize
26376>>>>>>>                        for iCount from 0 to iSize
26382>>>>>>>>
26382>>>>>>>                            Move iaChangeField[iCount] to iField
26383>>>>>>>                            Set Private.piCurrentField to iField
26384>>>>>>>                            Set_Field_Value hTable iField to dDateMin
26387>>>>>>>                        Loop
26388>>>>>>>>
26388>>>>>>>                        Move False to Err
26389>>>>>>>                        SaveRecord hTable
26390>>>>>>>                    Unlock
26391>>>>>>>>
26391>>>>>>>                End
26391>>>>>>>>
26391>>>>>>>
26391>>>>>>>                Increment iRecord
26392>>>>>>>                // Increment the StatusPanel counter and check the
26392>>>>>>>                // cancel status every 100 records rather than every
26392>>>>>>>                // record, it's way faster.
26392>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
26394>>>>>>>                    Send DoAdvance of ghoProgressBar
26395>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
26396>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
26397>>>>>>>                End
26397>>>>>>>>
26397>>>>>>>            End
26397>>>>>>>>
26397>>>>>>>        Until (bFound = False)
26399>>>>>>>
26399>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
26402>>>>>>>        If (bResetIndexesToOnLine = True) Begin
26404>>>>>>>            Send SetAllIndexesToBatch hTable False
26405>>>>>>>        End
26405>>>>>>>>
26405>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
26406>>>>>>>
26406>>>>>>>        Function_Return (Err = False)
26407>>>>>>>    End_Function
26408>>>>>>>
26408>>>>>>>
26408>>>>>>>    // * Dummy function for the Studio's Code Explorer *
26408>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
26410>>>>>>>        Function_Return False
26411>>>>>>>    End_Function
26412>>>>>>>
26412>>>>>>>    // Adds a column name to the passed table number.
26412>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
26414>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
26414>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
26414>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
26414>>>>>>>
26414>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
26415>>>>>>>        If (bExists = True) Begin
26417>>>>>>>            Function_Return False
26418>>>>>>>        End
26418>>>>>>>>
26418>>>>>>>
26418>>>>>>>        Move False to Err
26419>>>>>>>        If (num_arguments > 4) Begin
26421>>>>>>>            Move iPrec to iPrecision
26422>>>>>>>        End
26422>>>>>>>>
26422>>>>>>>        If (num_arguments > 6) Begin
26424>>>>>>>            Move bInitVal to bInitializeValue
26425>>>>>>>            Move sColVal  to sColumnValue
26426>>>>>>>        End
26426>>>>>>>>
26426>>>>>>>        If (iType < -1490) Begin
26428>>>>>>>            Move (iType + 1500) to iType
26429>>>>>>>        End
26429>>>>>>>>
26429>>>>>>>
26429>>>>>>>        Move hTable to iFile
26430>>>>>>>        Get psDriverID to sDriverID
26431>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
26432>>>>>>>        Get AutoConnectionIDLogin to bOK
26433>>>>>>>        Move False to Err
26434>>>>>>>        Move LastErr to iLastErr
26435>>>>>>>        Open iFile Mode DF_EXCLUSIVE
26437>>>>>>>        Set Private.phCurrentTable to hTable
26438>>>>>>>        Structure_Start iFile sDriverID
26439>>>>>>>            Move 0 to iColumn
26440>>>>>>>            Set Private.piCurrentField to iColumn
26441>>>>>>>            Create_Field hTable At iColumn
26442>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
26445>>>>>>>            If (bMertechDriver = True) Begin
26447>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
26448>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
26449>>>>>>>            End
26449>>>>>>>>
26449>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
26452>>>>>>>            If (bMertechDriver = True) Begin
26454>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
26455>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
26456>>>>>>>                Move False to Err
26457>>>>>>>                Move iLastErr to LastErr
26458>>>>>>>            End
26458>>>>>>>>
26458>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
26461>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
26464>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
26465>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
26467>>>>>>>
26467>>>>>>>        Set Action_Text of ghoStatusPanel to ""
26468>>>>>>>
26468>>>>>>>        // If in development environment; create .fd file:
26468>>>>>>>        Open hTable
26470>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
26471>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
26472>>>>>>>        If (iCount > 1) Begin
26474>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
26475>>>>>>>        End
26475>>>>>>>>
26475>>>>>>>        Get vFolderExists sDDSrcPath to bExists
26476>>>>>>>        If (bExists = True) Begin
26478>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
26479>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
26482>>>>>>>            Get _TableNameOnly sTableName to sTableName
26483>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
26485>>>>>>>        End
26485>>>>>>>>
26485>>>>>>>
26485>>>>>>>        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
26486>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
26487>>>>>>>        If (iCount > 1) Begin
26489>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
26490>>>>>>>        End
26490>>>>>>>>
26490>>>>>>>        get vFolderFormat sDataPath to sDataPath
26491>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
26491>>>>>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
26492>>>>>>>
26492>>>>>>>        // Check for a default value
26492>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
26494>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
26495>>>>>>>        End
26495>>>>>>>>
26495>>>>>>>        Close hTable
26496>>>>>>>
26496>>>>>>>        Function_Return (Err = False)
26497>>>>>>>    End_Function
26498>>>>>>>
26498>>>>>>>    // Adds a column name to the passed table number.
26498>>>>>>>    Function ApiColumnInsert Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
26500>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields
26500>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bIsDateType
26500>>>>>>>        String sDdSrcPath sTableName sColumnValue
26500>>>>>>>
26500>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
26501>>>>>>>        Move False to Err
26502>>>>>>>        If (bExists = True) Begin
26504>>>>>>>            Function_Return False
26505>>>>>>>        End
26505>>>>>>>>
26505>>>>>>>        If (num_arguments > 4) Begin
26507>>>>>>>            Move iPrec to iPrecision
26508>>>>>>>        End
26508>>>>>>>>
26508>>>>>>>        If (iType < -1490) Begin
26510>>>>>>>            Move (iType + 1500) to iType
26511>>>>>>>        End
26511>>>>>>>>
26511>>>>>>>
26511>>>>>>>        Get AutoConnectionIDLogin to bOK
26512>>>>>>>        Move False to Err
26513>>>>>>>        // Structure_start will change the value of hTable...
26513>>>>>>>        Move hTable to iFile
26514>>>>>>>        Get OpenTableExclusive iFile to bOK
26515>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
26518>>>>>>>
26518>>>>>>>        // If the passed column number is higher than the current number of fields
26518>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
26518>>>>>>>        // a new field to the end:
26518>>>>>>>        If (iColumn > iNumberOfFields) Begin
26520>>>>>>>            Move 0 to iColumn
26521>>>>>>>        End
26521>>>>>>>>
26521>>>>>>>
26521>>>>>>>        Set Private.phCurrentTable to hTable
26522>>>>>>>        Set Private.piCurrentField to iColumn
26523>>>>>>>
26523>>>>>>>        Structure_Start iFile
26524>>>>>>>            Create_Field iFile At iColumn
26525>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
26528>>>>>>>            If (bIsSQLType = False) Begin
26530>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
26533>>>>>>>            End
26533>>>>>>>>
26533>>>>>>>            Else Begin
26534>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
26537>>>>>>>            End
26537>>>>>>>>
26537>>>>>>>            Get UtilColumnIsDateType iType bIsSQLType to bIsDateType
26538>>>>>>>            If (bIsDateType = False) Begin
26540>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
26543>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
26546>>>>>>>            End
26546>>>>>>>>
26546>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
26547>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
26549>>>>>>>
26549>>>>>>>        Set Action_Text of ghoStatusPanel to ""
26550>>>>>>>        // If in development environment; create .fd file:
26550>>>>>>>        Open hTable
26552>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
26553>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
26554>>>>>>>        If (iCount > 1) Begin
26556>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
26557>>>>>>>        End
26557>>>>>>>>
26557>>>>>>>        Get vFolderExists sDDSrcPath to bExists
26558>>>>>>>        If (bExists = True) Begin
26560>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
26561>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
26564>>>>>>>            Get _TableNameOnly sTableName to sTableName
26565>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
26567>>>>>>>        End
26567>>>>>>>>
26567>>>>>>>
26567>>>>>>>        // Check for a default value
26567>>>>>>>        Close hTable
26568>>>>>>>
26568>>>>>>>        Function_Return (Err = False)
26569>>>>>>>    End_Function
26570>>>>>>>
26570>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
26570>>>>>>>//        Integer iColumn iCount iFile
26570>>>>>>>//        Boolean bExists bOK
26570>>>>>>>//        String sDdSrcPath sTableName
26570>>>>>>>//
26570>>>>>>>//        Get AutoConnectionIDLogin to bOK
26570>>>>>>>//        Move False to Err
26570>>>>>>>//
26570>>>>>>>//        // Structure_start will change the value of hTable...
26570>>>>>>>//        Move hTable to iFile
26570>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
26570>>>>>>>//
26570>>>>>>>//        Structure_Start iFile
26570>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
26570>>>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
26570>>>>>>>//
26570>>>>>>>//        // If in development environment; create .fd file:
26570>>>>>>>//        Open hTable
26570>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
26570>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
26570>>>>>>>//        If (iCount > 1) Begin
26570>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
26570>>>>>>>//        End
26570>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
26570>>>>>>>//        If (bExists = True) Begin
26570>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
26570>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
26570>>>>>>>//            Get _TableNameOnly sTableName to sTableName
26570>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
26570>>>>>>>//        End
26570>>>>>>>//        Close hTable
26570>>>>>>>//
26570>>>>>>>//        Function_Return (Err = False)
26570>>>>>>>//    End_Function
26570>>>>>>>
26570>>>>>>>    // To update all records for a table column with a fixed value.
26570>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
26572>>>>>>>        Integer iRecs iCurrErr iField iRecord
26572>>>>>>>        Boolean bRetval bOpen
26572>>>>>>>
26572>>>>>>>        Move 0 to iRecs
26573>>>>>>>        Move False to bRetval
26574>>>>>>>        Move Err to iCurrErr
26575>>>>>>>        Move False to Err
26576>>>>>>>
26576>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
26579>>>>>>>        If (bOpen = False) Begin
26581>>>>>>>            Open hTable
26583>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
26586>>>>>>>            If (bOpen = False) Begin
26588>>>>>>>                Function_Return bRetval
26589>>>>>>>            End
26589>>>>>>>>
26589>>>>>>>        End
26589>>>>>>>>
26589>>>>>>>
26589>>>>>>>        Field_Map hTable sFieldName to iField
26591>>>>>>>        If (iField <> 0) Begin
26593>>>>>>>            Set Private.phCurrentTable to hTable
26594>>>>>>>            Set Private.piCurrentField to iField
26595>>>>>>>            Clear hTable
26596>>>>>>>            Repeat
26596>>>>>>>>
26596>>>>>>>                Vfind hTable 0 GT
26598>>>>>>>                If (Found) Begin
26600>>>>>>>                    If (ghoStatusPanel <> 0) Begin
26602>>>>>>>                        Get_Field_Value hTable 0 to iRecord
26605>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_UpdateVersion * String(iRecord))
26606>>>>>>>                    End
26606>>>>>>>>
26606>>>>>>>                    Reread hTable
26610>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
26613>>>>>>>                        SaveRecord hTable
26614>>>>>>>                    Unlock
26615>>>>>>>>
26615>>>>>>>                End
26615>>>>>>>>
26615>>>>>>>           Until (not(Found))
26617>>>>>>>        End
26617>>>>>>>>
26617>>>>>>>
26617>>>>>>>        Move (Err = False) to bRetval
26618>>>>>>>        Move iCurrErr to Err
26619>>>>>>>
26619>>>>>>>        Function_Return bRetval
26620>>>>>>>    End_Function
26621>>>>>>>
26621>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
26621>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
26623>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
26623>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
26623>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
26623>>>>>>>
26623>>>>>>>//        Set Private.phCurrentTable to hTable
26623>>>>>>>        Get psDriverID to sDriverID
26624>>>>>>>        Get piDbType to iDbType
26625>>>>>>>        Get UtilTableHandleToString hTable to sTableName
26626>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
26627>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
26628>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
26629>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
26631>>>>>>>            Move True to bIsSqlTable
26632>>>>>>>        End
26632>>>>>>>>
26632>>>>>>>        Move False to bIsOpen
26633>>>>>>>        If (hTable > 0) Begin
26635>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
26638>>>>>>>        End
26638>>>>>>>>
26638>>>>>>>        If (bIsOpen = True) Begin
26640>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
26643>>>>>>>        End
26643>>>>>>>>
26643>>>>>>>        Else Begin
26644>>>>>>>            Get pbRecnum to bRecnumTable
26645>>>>>>>        End
26645>>>>>>>>
26645>>>>>>>
26645>>>>>>>        Move False to Err
26646>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
26647>>>>>>>        Decrement iSize
26648>>>>>>>        for iCount from 0 to iSize
26654>>>>>>>>
26654>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
26655>>>>>>>            If (hTable > 0) Begin
26657>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
26658>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
26659>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
26662>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
26663>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
26664>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
26665>>>>>>>            End
26665>>>>>>>>
26665>>>>>>>            Else Begin
26666>>>>>>>                Move False to bFieldExists
26667>>>>>>>            End
26667>>>>>>>>
26667>>>>>>>
26667>>>>>>>            If (bFieldExists = False) Begin
26669>>>>>>>                Move 0 to iColumn
26670>>>>>>>                Create_Field hTable At iColumn
26671>>>>>>>            End
26671>>>>>>>>
26671>>>>>>>            Else Begin
26672>>>>>>>                Move iCount to iColumn
26673>>>>>>>            End
26673>>>>>>>>
26673>>>>>>>
26673>>>>>>>            Set Private.piCurrentField to iColumn
26674>>>>>>>
26674>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
26675>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
26678>>>>>>>
26678>>>>>>>            Move aColumns[iCount].iType to iType
26679>>>>>>>            Move (not(iType < -1490)) to bNativeType
26680>>>>>>>            If (iType < -1490) Begin
26682>>>>>>>                Move (iType + 1500) to iType
26683>>>>>>>            End
26683>>>>>>>>
26683>>>>>>>
26683>>>>>>>            If (bIsSqlTable = True) Begin
26685>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
26687>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
26688>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
26691>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
26694>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
26697>>>>>>>
26697>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
26698>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
26700>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
26701>>>>>>>                    End
26701>>>>>>>>
26701>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
26704>>>>>>>
26704>>>>>>>                End
26704>>>>>>>>
26704>>>>>>>                Else Begin
26705>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
26708>>>>>>>                End
26708>>>>>>>>
26708>>>>>>>            End
26708>>>>>>>>
26708>>>>>>>            Else Begin
26709>>>>>>>                If (bCreating = False) Begin
26711>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
26712>>>>>>>                End
26712>>>>>>>>
26712>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
26715>>>>>>>            End
26715>>>>>>>>
26715>>>>>>>
26715>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
26716>>>>>>>            If (bIsDateType = False) Begin
26718>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
26721>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
26724>>>>>>>            End
26724>>>>>>>>
26724>>>>>>>
26724>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
26726>>>>>>>                Move 0 to iIndex
26727>>>>>>>                Create_Index hTable at iIndex
26728>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
26731>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
26734>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
26737>>>>>>>
26737>>>>>>>                // If we have an identity table - we must create a primary_key table.
26737>>>>>>>                If (bIsSqlTable = True) Begin
26739>>>>>>>                End
26739>>>>>>>>
26739>>>>>>>            End
26739>>>>>>>>
26739>>>>>>>        Loop
26740>>>>>>>>
26740>>>>>>>
26740>>>>>>>        Function_Return (Err = False)
26741>>>>>>>    End_Function
26742>>>>>>>
26742>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
26742>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
26744>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
26744>>>>>>>        Boolean bOK bIsSqlTable
26744>>>>>>>        String sFieldNameTo
26744>>>>>>>
26744>>>>>>>        If (num_arguments > 4) Begin
26746>>>>>>>            Move iPrec to iPrecFrom
26747>>>>>>>        End
26747>>>>>>>>
26747>>>>>>>        If (iTypeFrom < -1490) Begin
26749>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
26750>>>>>>>        End
26750>>>>>>>>
26750>>>>>>>
26750>>>>>>>        Get AutoConnectionIDLogin to bOK
26751>>>>>>>        Move False to Err
26752>>>>>>>        Get OpenTableExclusive hTable to bOK
26753>>>>>>>        If (bOK = False) Begin
26755>>>>>>>            Function_Return False
26756>>>>>>>        End
26756>>>>>>>>
26756>>>>>>>
26756>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
26757>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
26758>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
26760>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
26761>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
26762>>>>>>>        If (Err = True) Begin
26764>>>>>>>            Function_Return False
26765>>>>>>>        End
26765>>>>>>>>
26765>>>>>>>
26765>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
26768>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
26769>>>>>>>        If (bIsSqlTable = False) Begin
26771>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
26774>>>>>>>        End
26774>>>>>>>>
26774>>>>>>>        Else Begin
26775>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
26778>>>>>>>        End
26778>>>>>>>>
26778>>>>>>>        // Let the driver decide the other values;
26778>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
26781>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
26784>>>>>>>
26784>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
26786>>>>>>>            Function_Return False
26787>>>>>>>        End
26787>>>>>>>>
26787>>>>>>>
26787>>>>>>>        Set Private.phCurrentTable to hTable
26788>>>>>>>        Set Private.piCurrentField to iColumn
26789>>>>>>>
26789>>>>>>>        Structure_Start hTable
26790>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
26793>>>>>>>//            If (bIsSqlTable = False) Begin
26793>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
26796>>>>>>>//            End
26796>>>>>>>//            Else Begin
26796>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
26796>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
26796>>>>>>>//            End
26796>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
26799>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
26802>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
26803>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
26805>>>>>>>
26805>>>>>>>        Set Action_Text of ghoStatusPanel to ""
26806>>>>>>>        Function_Return (Err = False)
26807>>>>>>>    End_Function
26808>>>>>>>
26808>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
26808>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
26810>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
26810>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
26810>>>>>>>        String sFieldNameTo sDriverIDTo
26810>>>>>>>        tColumnType ColumnType
26810>>>>>>>        tColumnType ColumnType
26810>>>>>>>
26810>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
26811>>>>>>>        Get piDbType to iDbType
26812>>>>>>>        If (num_arguments > 4) Begin
26814>>>>>>>            Move iPrec to iPrecFrom
26815>>>>>>>            Move iOpt  to iOptionFrom
26816>>>>>>>        End
26816>>>>>>>>
26816>>>>>>>        If (iTypeFrom < -1490) Begin
26818>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
26819>>>>>>>        End
26819>>>>>>>>
26819>>>>>>>
26819>>>>>>>        Get AutoConnectionIDLogin to bOK
26820>>>>>>>        Move False to Err
26821>>>>>>>        Close hTable
26822>>>>>>>        Get OpenTableExclusive hTable to bOK
26823>>>>>>>        If (bOK = False) Begin
26825>>>>>>>            Function_Return False
26826>>>>>>>        End
26826>>>>>>>>
26826>>>>>>>
26826>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
26829>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
26832>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
26833>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
26836>>>>>>>
26836>>>>>>>        If (bIsSQLTableTo = True) Begin
26838>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
26841>>>>>>>        End
26841>>>>>>>>
26841>>>>>>>        Else Begin
26842>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
26845>>>>>>>        End
26845>>>>>>>>
26845>>>>>>>
26845>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
26848>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
26851>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
26854>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
26854>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
26854>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
26856>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
26857>>>>>>>        End
26857>>>>>>>>
26857>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
26860>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
26861>>>>>>>        End
26861>>>>>>>>
26861>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
26862>>>>>>>
26862>>>>>>>        If (bCompareDate_DateTime = False) Begin
26864>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
26865>>>>>>>            If (bSkip = True) Begin
26867>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
26869>>>>>>>                    Function_Return True
26870>>>>>>>                End
26870>>>>>>>>
26870>>>>>>>            End
26870>>>>>>>>
26870>>>>>>>        End
26870>>>>>>>>
26870>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
26873>>>>>>>            Function_Return True
26874>>>>>>>        End
26874>>>>>>>>
26874>>>>>>>
26874>>>>>>>        Set Private.phCurrentTable to hTable
26875>>>>>>>        Set Private.piCurrentField to iColumn
26876>>>>>>>
26876>>>>>>>        Structure_Start hTable
26877>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
26879>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
26882>>>>>>>            End
26882>>>>>>>>
26882>>>>>>>
26882>>>>>>>            If (bIsSameDataType = False) Begin
26884>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
26887>>>>>>>                If (bIsSQLTableTo = True) Begin
26889>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
26892>>>>>>>                End
26892>>>>>>>>
26892>>>>>>>            End
26892>>>>>>>>
26892>>>>>>>
26892>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
26894>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
26897>>>>>>>            End
26897>>>>>>>>
26897>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
26899>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
26902>>>>>>>            End
26902>>>>>>>>
26902>>>>>>>
26902>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
26904>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
26904>>>>>>>                If (bRecnumTable = True) Begin
26906>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
26909>>>>>>>                End
26909>>>>>>>>
26909>>>>>>>
26909>>>>>>>                // We might need to create an index here.
26909>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
26909>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
26909>>>>>>>                // index update checking logic.
26909>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
26912>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
26914>>>>>>>                    Create_Index hTable At iIndex
26915>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
26918>>>>>>>                End
26918>>>>>>>>
26918>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
26921>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
26924>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
26927>>>>>>>                If (bIsSQLTableTo = True) Begin
26929>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
26932>>>>>>>                End
26932>>>>>>>>
26932>>>>>>>            End
26932>>>>>>>>
26932>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
26933>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
26935>>>>>>>
26935>>>>>>>        Set Action_Text of ghoStatusPanel to ""
26936>>>>>>>        Function_Return (Err = False)
26937>>>>>>>    End_Function
26938>>>>>>>
26938>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
26940>>>>>>>        Boolean bOK
26940>>>>>>>
26940>>>>>>>        Get AutoConnectionIDLogin to bOK
26941>>>>>>>        Move False to Err
26942>>>>>>>        Get OpenTableExclusive hTable to bOK
26943>>>>>>>        If (bOK = False) Begin
26945>>>>>>>            Function_Return False
26946>>>>>>>        End
26946>>>>>>>>
26946>>>>>>>
26946>>>>>>>        Structure_Start hTable
26947>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
26950>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
26951>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
26953>>>>>>>
26953>>>>>>>        Set Action_Text of ghoStatusPanel to ""
26954>>>>>>>        Function_Return (Err = False)
26955>>>>>>>    End_Function
26956>>>>>>>
26956>>>>>>>    // To move an existing field to another position in a table.
26956>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
26958>>>>>>>        String sColumn sDriverID
26958>>>>>>>        Integer iType iSQLType iDbType
26958>>>>>>>        Boolean bOK bIsDate
26958>>>>>>>
26958>>>>>>>        Close hTable
26959>>>>>>>        Get AutoConnectionIDLogin to bOK
26960>>>>>>>        Get OpenTableExclusive hTable to bOK
26961>>>>>>>        If (bOK = False) Begin
26963>>>>>>>            Function_Return False
26964>>>>>>>        End
26964>>>>>>>>
26964>>>>>>>
26964>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
26967>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
26969>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
26970>>>>>>>>
26970>>>>>>>            Function_Return False
26971>>>>>>>        End
26971>>>>>>>>
26971>>>>>>>
26971>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
26974>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
26977>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
26978>>>>>>>
26978>>>>>>>        Set Private.phCurrentTable to hTable
26979>>>>>>>        Set Private.piCurrentField to iOld
26980>>>>>>>
26980>>>>>>>//        If (bIsDate = False) Begin
26980>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
26980>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
26980>>>>>>>//        End
26980>>>>>>>//        Else Begin
26980>>>>>>>//            Move 6 to iLength
26980>>>>>>>//            Move 0 to iPrecision
26980>>>>>>>//        End
26980>>>>>>>
26980>>>>>>>        Move False to Err
26981>>>>>>>
26981>>>>>>>        Structure_Start hTable
26982>>>>>>>            Delete_Field hTable iOld
26983>>>>>>>            Create_Field hTable At iNew
26984>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
26987>>>>>>>
26987>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
26990>>>>>>>            If (bIsSQLType = False) Begin
26992>>>>>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
26995>>>>>>>            End
26995>>>>>>>>
26995>>>>>>>            Else Begin
26996>>>>>>>                Set_Attribute DF_FIELD_TYPE        of hTable iNew to iType
26999>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
26999>>>>>>>            End
26999>>>>>>>>
26999>>>>>>>
26999>>>>>>>            If (bIsDate = False) Begin
27001>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
27004>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
27007>>>>>>>            End
27007>>>>>>>>
27007>>>>>>>
27007>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27008>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27010>>>>>>>
27010>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27011>>>>>>>        Function_Return (Err = False)
27012>>>>>>>    End_Function
27013>>>>>>>
27013>>>>>>>    // Deletes a column name for the passed table number (and column number).
27013>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
27015>>>>>>>        Integer iColumn
27015>>>>>>>        Boolean bOK
27015>>>>>>>
27015>>>>>>>        Get AutoConnectionIDLogin to bOK
27016>>>>>>>        Move False to Err
27017>>>>>>>        Close hTable
27018>>>>>>>        Get OpenTableExclusive hTable to bOK
27019>>>>>>>        If (bOK = False) Begin
27021>>>>>>>            Function_Return False
27022>>>>>>>        End
27022>>>>>>>>
27022>>>>>>>
27022>>>>>>>        If (not(Err)) Begin
27024>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27025>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
27026>>>>>>>            Field_Map hTable sFieldName to iColumn
27028>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
27029>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
27030>>>>>>>            If (iColumn = 0) Begin
27032>>>>>>>                Move 0 to LastErr
27033>>>>>>>                Function_Return False
27034>>>>>>>            End
27034>>>>>>>>
27034>>>>>>>            Move False to Err
27035>>>>>>>
27035>>>>>>>            Set Private.phCurrentTable to hTable
27036>>>>>>>            Set Private.piCurrentField to iColumn
27037>>>>>>>
27037>>>>>>>            Structure_Start hTable
27038>>>>>>>                Delete_Field hTable iColumn
27039>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
27040>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27042>>>>>>>            Set Action_Text of ghoStatusPanel to ""
27043>>>>>>>        End
27043>>>>>>>>
27043>>>>>>>        Else Begin
27044>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
27045>>>>>>>>
27045>>>>>>>        End
27045>>>>>>>>
27045>>>>>>>
27045>>>>>>>        Function_Return (Err = False)
27046>>>>>>>    End_Function
27047>>>>>>>
27047>>>>>>>    // Renames a field for the passed table number & old field name & new field name
27047>>>>>>>    // Returns True if no errors occured.
27047>>>>>>>    // Sample usage:
27047>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
27047>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
27049>>>>>>>        Integer iField
27049>>>>>>>        Boolean bOK bExists bIsOpen
27049>>>>>>>
27049>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
27050>>>>>>>        If (bExists = True) Begin
27052>>>>>>>            Function_Return False
27053>>>>>>>        End
27053>>>>>>>>
27053>>>>>>>
27053>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
27053>>>>>>>        //       opened exclusively, so we first open it in normal mode.
27053>>>>>>>        Close hTable
27054>>>>>>>        Open hTable
27056>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
27059>>>>>>>        If (bIsOpen = False) Begin
27061>>>>>>>            Function_Return False
27062>>>>>>>        End
27062>>>>>>>>
27062>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27063>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
27064>>>>>>>        Field_Map hTable sOldFieldName to iField
27066>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
27067>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
27068>>>>>>>
27068>>>>>>>        Get AutoConnectionIDLogin to bOK
27069>>>>>>>        Get OpenTableExclusive hTable to bOK
27070>>>>>>>        If (bOK = False) Begin
27072>>>>>>>            Function_Return False
27073>>>>>>>        End
27073>>>>>>>>
27073>>>>>>>
27073>>>>>>>        Move False to Err
27074>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
27075>>>>>>>        Set Private.phCurrentTable to hTable
27076>>>>>>>        Set Private.piCurrentField to iField
27077>>>>>>>
27077>>>>>>>        If (iField > 0) Begin
27079>>>>>>>            Structure_Start hTable
27080>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
27083>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
27084>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27086>>>>>>>        End
27086>>>>>>>>
27086>>>>>>>        Else Begin
27087>>>>>>>            Move 0 to LastErr
27088>>>>>>>            Move False to Err
27089>>>>>>>        End
27089>>>>>>>>
27089>>>>>>>
27089>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27090>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
27091>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
27092>>>>>>>
27092>>>>>>>        Function_Return (Err = False)
27093>>>>>>>    End_Function
27094>>>>>>>
27094>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
27096>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
27096>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
27097>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
27097>>>>>>>        Boolean bRenameField
27097>>>>>>>
27097>>>>>>>        Open hTable
27099>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27100>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
27101>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
27102>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
27105>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
27106>>>>>>>        Decrement iSize
27107>>>>>>>        for iCount from 0 to iSize
27113>>>>>>>>
27113>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
27115>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27116>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
27117>>>>>>>
27117>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
27119>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
27121>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
27122>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
27123>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
27125>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
27126>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
27127>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
27128>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
27129>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
27130>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
27131>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
27132>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
27133>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
27134>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
27135>>>>>>>                        Increment iItem
27136>>>>>>>                    End
27136>>>>>>>>
27136>>>>>>>                End
27136>>>>>>>>
27136>>>>>>>            End
27136>>>>>>>>
27136>>>>>>>        Loop
27137>>>>>>>>
27137>>>>>>>
27137>>>>>>>        Move False to Err
27138>>>>>>>        Move 0 to LastErr
27139>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
27140>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
27141>>>>>>>        Function_Return aAPIColumnsToInsert
27142>>>>>>>    End_Function
27143>>>>>>>
27143>>>>>>>    Function UtilColumnsInsert Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
27145>>>>>>>        Integer iSize iCount
27145>>>>>>>        Boolean bOK
27145>>>>>>>        tAPIColumn[] aColumnsTo
27145>>>>>>>        tAPIColumn[] aColumnsTo
27146>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
27146>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
27147>>>>>>>
27147>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
27148>>>>>>>        If (iSize = 0) Begin
27150>>>>>>>            Function_Return True
27151>>>>>>>        End
27151>>>>>>>>
27151>>>>>>>
27151>>>>>>>        Move False to Err
27152>>>>>>>        Decrement iSize
27153>>>>>>>        for iCount from 0 to iSize
27159>>>>>>>>
27159>>>>>>>            Get ApiColumnInsert hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
27160>>>>>>>        Loop
27161>>>>>>>>
27161>>>>>>>
27161>>>>>>>        Function_Return bOK
27162>>>>>>>    End_Function
27163>>>>>>>
27163>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
27163>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
27165>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
27165>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
27166>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
27166>>>>>>>
27166>>>>>>>        Move 0 to iItem
27167>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
27168>>>>>>>        Decrement iSize
27169>>>>>>>        for iCount from 0 to iSize
27175>>>>>>>>
27175>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
27177>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
27178>>>>>>>                If (iShouldMove <> -1) Begin
27180>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
27181>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
27182>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
27183>>>>>>>                    Increment iItem
27184>>>>>>>                End
27184>>>>>>>>
27184>>>>>>>            End
27184>>>>>>>>
27184>>>>>>>        Loop
27185>>>>>>>>
27185>>>>>>>
27185>>>>>>>        Move False to Err
27186>>>>>>>        Move 0 to LastErr
27187>>>>>>>        Function_Return aAPIColumnsToMove
27188>>>>>>>    End_Function
27189>>>>>>>
27189>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
27191>>>>>>>        Integer iSize iCount
27191>>>>>>>        Boolean bOK
27191>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
27191>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
27192>>>>>>>
27192>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
27193>>>>>>>        If (iSize = 0) Begin
27195>>>>>>>            Function_Return True
27196>>>>>>>        End
27196>>>>>>>>
27196>>>>>>>
27196>>>>>>>        Move False to Err
27197>>>>>>>        Decrement iSize
27198>>>>>>>        for iCount from 0 to iSize
27204>>>>>>>>
27204>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27205>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
27206>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
27208>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
27209>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
27210>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
27211>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
27212>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
27214>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
27215>>>>>>>                    Decrement iSize
27216>>>>>>>                    Move 0 to iCount
27217>>>>>>>                End
27217>>>>>>>>
27217>>>>>>>            End
27217>>>>>>>>
27217>>>>>>>        Loop
27218>>>>>>>>
27218>>>>>>>
27218>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
27219>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
27220>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
27222>>>>>>>            Move 0 to LastErr
27223>>>>>>>        End
27223>>>>>>>>
27223>>>>>>>        Function_Return bOK
27224>>>>>>>    End_Function
27225>>>>>>>
27225>>>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
27225>>>>>>>    // We then assume this field should be renamed.
27225>>>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
27225>>>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
27225>>>>>>>//
27225>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27225>>>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
27225>>>>>>>//
27225>>>>>>>//        If (bDifferentFieldNames = True) Begin
27225>>>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
27225>>>>>>>//            If (bShouldBeRenamed = False) Begin
27225>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
27225>>>>>>>//                Function_Return False
27225>>>>>>>//            End
27225>>>>>>>//
27225>>>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
27225>>>>>>>//            If (bShouldBeRenamed = False) Begin
27225>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
27225>>>>>>>//                Function_Return False
27225>>>>>>>//            End
27225>>>>>>>//
27225>>>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
27225>>>>>>>//            If (bShouldBeRenamed = False) Begin
27225>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
27225>>>>>>>//                Function_Return False
27225>>>>>>>//            End
27225>>>>>>>//
27225>>>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
27225>>>>>>>//            If (bShouldBeRenamed = False) Begin
27225>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
27225>>>>>>>//                Function_Return False
27225>>>>>>>//            End
27225>>>>>>>//        End
27225>>>>>>>//
27225>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
27225>>>>>>>//        Function_Return True
27225>>>>>>>//    End_Function
27225>>>>>>>
27225>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
27225>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
27225>>>>>>>    // - The "FROM" field name is <> "TO" field name
27225>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
27225>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
27225>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
27227>>>>>>>        Boolean bExists bShouldRename
27227>>>>>>>        String sFieldNameFrom sFieldNameTo
27227>>>>>>>
27227>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
27228>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
27229>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
27231>>>>>>>            Function_Return False
27232>>>>>>>        End
27232>>>>>>>>
27232>>>>>>>
27232>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
27233>>>>>>>//        If (bShouldRename = False) Begin
27233>>>>>>>//            Function_Return False
27233>>>>>>>//        End
27233>>>>>>>//
27233>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
27233>>>>>>>//            Function_Return True
27233>>>>>>>//        End
27233>>>>>>>
27233>>>>>>>        Function_Return bShouldRename
27234>>>>>>>    End_Function
27235>>>>>>>
27235>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
27235>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
27235>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
27237>>>>>>>        Integer iCount iSize iRetval
27237>>>>>>>        String sFieldNameFrom
27237>>>>>>>
27237>>>>>>>        Move -1 to iRetval
27238>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
27240>>>>>>>            Function_Return iRetval
27241>>>>>>>        End
27241>>>>>>>>
27241>>>>>>>
27241>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
27242>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
27243>>>>>>>        Decrement iSize
27244>>>>>>>        for iCount from 0 to iSize
27250>>>>>>>>
27250>>>>>>>            // We're only interested in fields other than the passed field/column number:
27250>>>>>>>            If (iCount <> iColumn) Begin
27252>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
27254>>>>>>>                    Move (iCount + 1) to iRetval
27255>>>>>>>                End
27255>>>>>>>>
27255>>>>>>>            End
27255>>>>>>>>
27255>>>>>>>        Loop
27256>>>>>>>>
27256>>>>>>>
27256>>>>>>>        Move 0 to LastErr
27257>>>>>>>        Function_Return iRetval
27258>>>>>>>    End_Function
27259>>>>>>>
27259>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
27261>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
27261>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
27262>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
27262>>>>>>>        Boolean bRenameField
27262>>>>>>>
27262>>>>>>>        Open hTable
27264>>>>>>>        Move 0 to iItem
27265>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
27266>>>>>>>        Decrement iSize
27267>>>>>>>        for iCount from 0 to iSize
27273>>>>>>>>
27273>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
27275>>>>>>>                // Check if the field exists in another position (other field number)
27275>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
27276>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
27277>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
27279>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
27280>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
27281>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
27282>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
27283>>>>>>>                    Increment iItem
27284>>>>>>>                End
27284>>>>>>>>
27284>>>>>>>            End
27284>>>>>>>>
27284>>>>>>>        Loop
27285>>>>>>>>
27285>>>>>>>
27285>>>>>>>        Move False to Err
27286>>>>>>>        Move 0 to LastErr
27287>>>>>>>        Function_Return aAPIColumnsToRename
27288>>>>>>>    End_Function
27289>>>>>>>
27289>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
27291>>>>>>>        Integer iSize iCount
27291>>>>>>>        Boolean bOK
27291>>>>>>>        tAPIColumn[] aColumnsTo
27291>>>>>>>        tAPIColumn[] aColumnsTo
27292>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
27292>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
27293>>>>>>>
27293>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
27294>>>>>>>        If (iSize = 0) Begin
27296>>>>>>>            Function_Return True
27297>>>>>>>        End
27297>>>>>>>>
27297>>>>>>>
27297>>>>>>>        Move False to Err
27298>>>>>>>        Decrement iSize
27299>>>>>>>        For iCount from 0 to iSize
27305>>>>>>>>
27305>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27306>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
27307>>>>>>>        Loop
27308>>>>>>>>
27308>>>>>>>
27308>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
27309>>>>>>>        Function_Return bOK
27310>>>>>>>    End_Function
27311>>>>>>>
27311>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
27313>>>>>>>        Boolean bDateType
27313>>>>>>>
27313>>>>>>>        If (bIsSQLTableTo = True) Begin
27315>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
27316>>>>>>>        End
27316>>>>>>>>
27316>>>>>>>        Else Begin
27317>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
27318>>>>>>>        End
27318>>>>>>>>
27318>>>>>>>
27318>>>>>>>        Function_Return bDateType
27319>>>>>>>    End_Function
27320>>>>>>>
27320>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
27322>>>>>>>        Integer iCount iSize iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
27322>>>>>>>        Handle hFile
27322>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bShouldMove bIsSQLDriver bIsSame bOK bSkip
27322>>>>>>>        Boolean bRecnum bIsSQLTableTo bOpened bRecnumTable bIsOpen bSkipTypeChange bIsDateType
27322>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
27322>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
27322>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
27327>>>>>>>        tColumnType ColumnType
27327>>>>>>>        tColumnType ColumnType
27327>>>>>>>
27327>>>>>>>        Move False to Err
27328>>>>>>>        Close hTable
27329>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
27330>>>>>>>        If (bIsOpen = False) Begin
27332>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
27333>>>>>>>>
27333>>>>>>>            Function_Return False
27334>>>>>>>        End
27334>>>>>>>>
27334>>>>>>>
27334>>>>>>>        Get piDbType to iDbType
27335>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
27338>>>>>>>        Get IsSQLDriver sDriverIDFrom to bIsSQLDriver
27339>>>>>>>        Get UtilTableIsSQL hTable     to bIsSQLTableTo
27340>>>>>>>        If (bIsSQLTableTo = False) Begin
27342>>>>>>>            Move DATAFLEX_ID to sDriverIDTo
27343>>>>>>>        End
27343>>>>>>>>
27343>>>>>>>        Else Begin
27344>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
27347>>>>>>>        End
27347>>>>>>>>
27347>>>>>>>
27347>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
27348>>>>>>>
27348>>>>>>>        // Before we start to change the table we need to do three things;
27348>>>>>>>        // 1) Insert any new fields
27348>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
27349>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
27351>>>>>>>            Get UtilColumnsInsert hTable aApiInsertColumns to bOK
27352>>>>>>>            If (bOK = False) Begin
27354>>>>>>>                Function_Return False
27355>>>>>>>            End
27355>>>>>>>>
27355>>>>>>>            // Update info with changes made.
27355>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
27356>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
27357>>>>>>>        End
27357>>>>>>>>
27357>>>>>>>
27357>>>>>>>        // 2) Rename fields
27357>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
27358>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
27360>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
27361>>>>>>>            If (bOK = False) Begin
27363>>>>>>>                Function_Return False
27364>>>>>>>            End
27364>>>>>>>>
27364>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
27365>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
27366>>>>>>>        End
27366>>>>>>>>
27366>>>>>>>
27366>>>>>>>        // 3) Move fields with same names
27366>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
27367>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
27369>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
27370>>>>>>>            If (bOK = False) Begin
27372>>>>>>>                Function_Return False
27373>>>>>>>            End
27373>>>>>>>>
27373>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
27374>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
27375>>>>>>>        End
27375>>>>>>>>
27375>>>>>>>        
27375>>>>>>>        // ToDo: Why was this commented out?
27375>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
27375>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
27375>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
27375>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
27375>>>>>>>//            If (bOK = False) Begin
27375>>>>>>>//                Function_Return False
27375>>>>>>>//            End
27375>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
27375>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
27375>>>>>>>//        End
27375>>>>>>>
27375>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
27375>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
27377>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
27378>>>>>>>            If (bIsSame = True) Begin
27380>>>>>>>                Function_Return True
27381>>>>>>>            End
27381>>>>>>>>
27381>>>>>>>        End
27381>>>>>>>>
27381>>>>>>>
27381>>>>>>>        // We can now continue to make standard field changes:
27381>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
27382>>>>>>>        Set Private.phCurrentTable to hTable
27383>>>>>>>        Move hTable to hFile
27384>>>>>>>        Structure_Start hFile sDriverIDTo
27385>>>>>>>
27385>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iSize
27386>>>>>>>            Decrement iSize
27387>>>>>>>            For iCount from 0 to iSize
27393>>>>>>>>
27393>>>>>>>                Send DoAdvance of ghoProgressBar
27394>>>>>>>
27394>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
27395>>>>>>>                Set Private.piCurrentField                  to iColumn
27396>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
27397>>>>>>>                If (bIsSame = False) Begin
27399>>>>>>>
27399>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
27400>>>>>>>                    If (bFieldExistsFrom = True) Begin
27402>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
27403>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
27404>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
27405>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
27406>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
27407>>>>>>>
27407>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
27408>>>>>>>    //                    Get UtilDFDataTypeToSqlTypeMapping sDriverIDFrom iDbType iTypeFrom to ColumnType
27408>>>>>>>    //                    Move ColumnType.iDataFlexType                   to iDataFlexType
27408>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
27409>>>>>>>                        If (iTypeFrom < -1490) Begin
27411>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
27412>>>>>>>                        End
27412>>>>>>>>
27412>>>>>>>
27412>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
27412>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
27412>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
27414>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
27415>>>>>>>                        End
27415>>>>>>>>
27415>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
27418>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
27419>>>>>>>                        End
27419>>>>>>>>
27419>>>>>>>
27419>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
27420>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
27421>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
27422>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
27423>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
27424>>>>>>>
27424>>>>>>>                        Move False to bSkipTypeChange
27425>>>>>>>                        If (bCompareDate_DateTime = False) Begin
27427>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
27428>>>>>>>                        End
27428>>>>>>>>
27428>>>>>>>
27428>>>>>>>                        If (bFieldExistsTo = False) Begin
27430>>>>>>>                            Move 0 to iColumn
27431>>>>>>>                            Create_Field hFile At iColumn
27432>>>>>>>                            Set Private.piCurrentField to iColumn
27433>>>>>>>                        End
27433>>>>>>>>
27433>>>>>>>
27433>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
27435>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
27438>>>>>>>                        End
27438>>>>>>>>
27438>>>>>>>
27438>>>>>>>                        If (bIsSQLTableFrom = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
27440>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
27443>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
27444>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
27446>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
27447>>>>>>>                            End
27447>>>>>>>>
27447>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
27450>>>>>>>                        End
27450>>>>>>>>
27450>>>>>>>
27450>>>>>>>                        If (bSkipTypeChange = False) Begin
27452>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
27454>>>>>>>                                If (bIsSQLTableTo = True) Begin
27456>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hFile iColumn to iTypeFrom
27459>>>>>>>                                End
27459>>>>>>>>
27459>>>>>>>                                Else Begin
27460>>>>>>>                                    Set_Attribute DF_FIELD_TYPE          of hFile iColumn to iDataFlexType
27463>>>>>>>                                End
27463>>>>>>>>
27463>>>>>>>                            End
27463>>>>>>>>
27463>>>>>>>                        End
27463>>>>>>>>
27463>>>>>>>
27463>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
27464>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
27464>>>>>>>                        If (bIsDateType = False) Begin
27466>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
27468>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
27471>>>>>>>                            End
27471>>>>>>>>
27471>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
27473>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
27476>>>>>>>                            End
27476>>>>>>>>
27476>>>>>>>                        End
27476>>>>>>>>
27476>>>>>>>
27476>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
27478>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
27478>>>>>>>                            If (bRecnumTable = True) Begin
27480>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
27483>>>>>>>                            End
27483>>>>>>>>
27483>>>>>>>
27483>>>>>>>                            // We might need to create an index here.
27483>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
27483>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
27483>>>>>>>                            // index update checking logic.
27483>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
27486>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
27488>>>>>>>                                Create_Index hFile at iIndex
27489>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
27492>>>>>>>                            End
27492>>>>>>>>
27492>>>>>>>
27492>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
27495>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
27498>>>>>>>                                // Note: The order of these two are crucial!
27498>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
27501>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
27504>>>>>>>                        End
27504>>>>>>>>
27504>>>>>>>                    End
27504>>>>>>>>
27504>>>>>>>                    Else Begin
27505>>>>>>>                        Delete_Field hFile iColumn
27506>>>>>>>                    End
27506>>>>>>>>
27506>>>>>>>                End
27506>>>>>>>>
27506>>>>>>>            Loop
27507>>>>>>>>
27507>>>>>>>
27507>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27508>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27510>>>>>>>
27510>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27511>>>>>>>        Function_Return (Err = False)
27512>>>>>>>    End_Function
27513>>>>>>>
27513>>>>>>>    // * Dummy function for the Studio's Code Explorer *
27513>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
27515>>>>>>>        Function_Return False
27516>>>>>>>    End_Function
27517>>>>>>>
27517>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
27517>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
27517>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
27517>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
27519>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
27519>>>>>>>        String sDriverID
27519>>>>>>>        Boolean bOK bExists bIsMertechDriver
27519>>>>>>>
27519>>>>>>>        Get AutoConnectionIDLogin to bOK
27520>>>>>>>        Get OpenTableExclusive hTable to bOK
27521>>>>>>>        If (bOK = False) Begin
27523>>>>>>>            Function_Return False
27524>>>>>>>        End
27524>>>>>>>>
27524>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
27527>>>>>>>
27527>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
27530>>>>>>>            Move (iIndexSegments > 0) to bExists
27531>>>>>>>        If (bExists = True) Begin
27533>>>>>>>            Function_Return True
27534>>>>>>>        End
27534>>>>>>>>
27534>>>>>>>
27534>>>>>>>        Move -1 to iSegment1
27535>>>>>>>        Move -1 to iSegment2
27536>>>>>>>        Move -1 to iSegment3
27537>>>>>>>        Move -1 to iSegment4
27538>>>>>>>        Move -1 to iSegment5
27539>>>>>>>        Move -1 to iSegment6
27540>>>>>>>        Move -1 to iSegment7
27541>>>>>>>        Move -1 to iSegment8
27542>>>>>>>        Move -1 to iSegment9
27543>>>>>>>        Move -1 to iSegment10
27544>>>>>>>
27544>>>>>>>        If (num_arguments > 3) Begin
27546>>>>>>>            Move iSgmnt1 to iSegment1
27547>>>>>>>        End
27547>>>>>>>>
27547>>>>>>>        If (num_arguments > 4) Begin
27549>>>>>>>            Move iSgmnt2 to iSegment2
27550>>>>>>>        End
27550>>>>>>>>
27550>>>>>>>        If (num_arguments > 5) Begin
27552>>>>>>>            Move iSgmnt3 to iSegment3
27553>>>>>>>        End
27553>>>>>>>>
27553>>>>>>>        If (num_arguments > 6) Begin
27555>>>>>>>            Move iSgmnt4 to iSegment4
27556>>>>>>>        End
27556>>>>>>>>
27556>>>>>>>        If (num_arguments > 7) Begin
27558>>>>>>>            Move iSgmnt5 to iSegment5
27559>>>>>>>        End
27559>>>>>>>>
27559>>>>>>>        If (num_arguments > 8) Begin
27561>>>>>>>            Move iSgmnt6 to iSegment6
27562>>>>>>>        End
27562>>>>>>>>
27562>>>>>>>        If (num_arguments > 9) Begin
27564>>>>>>>            Move iSgmnt7 to iSegment7
27565>>>>>>>        End
27565>>>>>>>>
27565>>>>>>>        If (num_arguments > 10) Begin
27567>>>>>>>            Move iSgmnt8 to iSegment8
27568>>>>>>>        End
27568>>>>>>>>
27568>>>>>>>        If (num_arguments > 11) Begin
27570>>>>>>>            Move iSgmnt9 to iSegment9
27571>>>>>>>        End
27571>>>>>>>>
27571>>>>>>>        If (num_arguments > 12) Begin
27573>>>>>>>            Move iSgmnt10 to iSegment10
27574>>>>>>>        End
27574>>>>>>>>
27574>>>>>>>
27574>>>>>>>        Move False to Err
27575>>>>>>>        Move hTable to iTableNo
27576>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27577>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
27578>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
27579>>>>>>>
27579>>>>>>>        // We start by deleting the index, if it exists.
27579>>>>>>>        If (bExists = True) Begin
27581>>>>>>>            Structure_Start hTable sDriverID
27582>>>>>>>                Delete_Index iTableNo iIndex
27583>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
27584>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27586>>>>>>>        End
27586>>>>>>>>
27586>>>>>>>
27586>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
27587>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
27588>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
27589>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27590>>>>>>>        Move False to Err
27591>>>>>>>        Move 0 to LastErr
27592>>>>>>>
27592>>>>>>>        // Need to re-open if index deleted.
27592>>>>>>>        Move iTableNo to hTable
27593>>>>>>>        Get OpenTableExclusive hTable to bOK
27594>>>>>>>        If (bOK = False) Begin
27596>>>>>>>            Function_Return False
27597>>>>>>>        End
27597>>>>>>>>
27597>>>>>>>
27597>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27598>>>>>>>        Structure_Start hTable sDriverID
27599>>>>>>>            Create_Index hTable At iIndex
27600>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
27603>>>>>>>
27603>>>>>>>            If (iSgmnt1 <> -1) Begin
27605>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
27608>>>>>>>            End
27608>>>>>>>>
27608>>>>>>>            If (iSegment2 <> -1) Begin
27610>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
27613>>>>>>>            End
27613>>>>>>>>
27613>>>>>>>            If (iSegment3 <> -1) Begin
27615>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
27618>>>>>>>            End
27618>>>>>>>>
27618>>>>>>>            If (iSegment4 <> -1) Begin
27620>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
27623>>>>>>>            End
27623>>>>>>>>
27623>>>>>>>            If (iSegment5 <> -1) Begin
27625>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
27628>>>>>>>            End
27628>>>>>>>>
27628>>>>>>>            If (iSegment6 <> -1) Begin
27630>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
27633>>>>>>>            End
27633>>>>>>>>
27633>>>>>>>            If (iSegment7 <> -1) Begin
27635>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
27638>>>>>>>            End
27638>>>>>>>>
27638>>>>>>>            If (iSegment8 <> -1) Begin
27640>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
27643>>>>>>>            End
27643>>>>>>>>
27643>>>>>>>            If (iSegment9 <> -1) Begin
27645>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
27648>>>>>>>            End
27648>>>>>>>>
27648>>>>>>>            If (iSegment10 <> -1) Begin
27650>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
27653>>>>>>>            End
27653>>>>>>>>
27653>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27654>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27656>>>>>>>
27656>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27657>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27658>>>>>>>
27658>>>>>>>        Function_Return (Err = False)
27659>>>>>>>    End_Function
27660>>>>>>>
27660>>>>>>>    // Example:
27660>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
27660>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
27660>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
27662>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
27662>>>>>>>        String sDriverID
27662>>>>>>>        Boolean bOK
27662>>>>>>>
27662>>>>>>>        Get AutoConnectionIDLogin to bOK
27663>>>>>>>
27663>>>>>>>        Move False to Err
27664>>>>>>>        Move hTable to iTableNo
27665>>>>>>>        Get OpenTableExclusive hTable to bOK
27666>>>>>>>        If (bOK = False) Begin
27668>>>>>>>            Function_Return False
27669>>>>>>>        End
27669>>>>>>>>
27669>>>>>>>
27669>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
27672>>>>>>>
27672>>>>>>>        // We start by deleting the index
27672>>>>>>>        Structure_Start hTable sDriverID
27673>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27674>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
27675>>>>>>>            Delete_Index iTableNo iIndex
27676>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
27677>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
27678>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
27680>>>>>>>
27680>>>>>>>        Move False to Err
27681>>>>>>>        Move iTableNo to hTable
27682>>>>>>>        Get OpenTableExclusive hTable to bOK
27683>>>>>>>        If (bOK = False) Begin
27685>>>>>>>            Function_Return False
27686>>>>>>>        End
27686>>>>>>>>
27686>>>>>>>
27686>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27687>>>>>>>        Structure_Start hTable sDriverID
27688>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
27689>>>>>>>
27689>>>>>>>            Create_Index hTable at iIndex
27690>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
27693>>>>>>>
27693>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
27699>>>>>>>>
27699>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
27702>>>>>>>            Loop
27703>>>>>>>>
27703>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
27705>>>>>>>
27705>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
27706>>>>>>>
27706>>>>>>>        Function_Return (Err = False)
27707>>>>>>>    End_Function
27708>>>>>>>
27708>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
27710>>>>>>>        String[] aFields
27711>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iFieldTo iSegmentsTo iSQLIndexType iLastIndex iTableNo iSQLIndexTo
27711>>>>>>>        String sDriverID sSQLIndexName sTableName
27711>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
27711>>>>>>>
27711>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
27712>>>>>>>        If (iSegmentsFrom = 0) Begin
27714>>>>>>>            Function_Return False
27715>>>>>>>        End
27715>>>>>>>>
27715>>>>>>>
27715>>>>>>>        Get AutoConnectionIDLogin to bOK
27716>>>>>>>        Move False to Err
27717>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
27718>>>>>>>        If (bIsOpen = False) Begin
27720>>>>>>>            Function_Return False
27721>>>>>>>        End
27721>>>>>>>>
27721>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
27724>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
27725>>>>>>>
27725>>>>>>>        Move 0     to iSegmentsTo
27726>>>>>>>        Move 0     to iSQLIndexType
27727>>>>>>>        Move ""    to sSQLIndexName
27728>>>>>>>        Move False to bIsSQLTemporaryIndex
27729>>>>>>>        Move False to bIsSQLPrimaryKey
27730>>>>>>>        Move False to bIsSQLClustered
27731>>>>>>>
27731>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
27732>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
27735>>>>>>>        Move (iSegmentsTo > 0) to bExists
27736>>>>>>>        If (bExists = True) Begin
27738>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
27740>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
27743>>>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
27746>>>>>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
27747>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
27750>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
27753>>>>>>>            End
27753>>>>>>>>
27753>>>>>>>        End
27753>>>>>>>>
27753>>>>>>>
27753>>>>>>>        Move hTable to iTableNo
27754>>>>>>>        Move False to Err
27755>>>>>>>        Move 0 to LastErr
27756>>>>>>>
27756>>>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
27756>>>>>>>        //       _outside_ the Structure_Start/End construct.
27756>>>>>>>//        Move False to bIsSQLTemporaryIndex
27756>>>>>>>//        #IF (!@ > 170)
27756>>>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
27756>>>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
27756>>>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
27756>>>>>>>//                End
27756>>>>>>>//            End
27756>>>>>>>//        #ENDIF
27756>>>>>>>
27756>>>>>>>        Structure_Start hTable sDriverID
27757>>>>>>>            If (bExists = True) Begin
27759>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
27760>>>>>>>            End
27760>>>>>>>>
27760>>>>>>>
27760>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
27761>>>>>>>
27761>>>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
27763>>>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
27766>>>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
27769>>>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
27772>>>>>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
27775>>>>>>>            End
27775>>>>>>>>
27775>>>>>>>
27775>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
27778>>>>>>>
27778>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
27784>>>>>>>>
27784>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
27785>>>>>>>                If (iFieldFrom <> -1 ) Begin
27787>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
27790>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
27793>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
27796>>>>>>>                End
27796>>>>>>>>
27796>>>>>>>            Loop
27797>>>>>>>>
27797>>>>>>>
27797>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27798>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27800>>>>>>>
27800>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27801>>>>>>>
27801>>>>>>>        Function_Return (Err = False)
27802>>>>>>>    End_Function
27803>>>>>>>
27803>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
27803>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
27803>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
27805>>>>>>>        Integer iLastIndex iCount iTableNo iSegments iIndexType
27805>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
27805>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
27805>>>>>>>
27805>>>>>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
27805>>>>>>>        // so we can then not rename the index.
27805>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
27806>>>>>>>        If (bIsMertechDriver = True) Begin
27808>>>>>>>            Function_Return False
27809>>>>>>>        End    
27809>>>>>>>>
27809>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
27810>>>>>>>        
27810>>>>>>>        If (bIsSQLDriver = False) Begin
27812>>>>>>>            Function_Return False
27813>>>>>>>        End
27813>>>>>>>>
27813>>>>>>>
27813>>>>>>>        Move False to Err
27814>>>>>>>        Move hTable to iTableNo
27815>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
27818>>>>>>>        for iCount from 0 to iLastIndex
27824>>>>>>>>
27824>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
27827>>>>>>>            Move (iSegments > 0) to bExists
27828>>>>>>>            If (bExists = True) Begin
27830>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
27833>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
27835>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
27836>>>>>>>                    Structure_Start iTableNo sDriverID
27837>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
27840>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27842>>>>>>>                    Open hTable
27844>>>>>>>                End
27844>>>>>>>>
27844>>>>>>>            End
27844>>>>>>>>
27844>>>>>>>        Loop
27845>>>>>>>>
27845>>>>>>>
27845>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
27848>>>>>>>        If (bIsOpen = False) Begin
27850>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
27851>>>>>>>        End
27851>>>>>>>>
27851>>>>>>>        If (bIsOpen = False) Begin
27853>>>>>>>            Function_Return False
27854>>>>>>>        End
27854>>>>>>>>
27854>>>>>>>
27854>>>>>>>        Function_Return (Err = False)
27855>>>>>>>    End_Function
27856>>>>>>>
27856>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
27856>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
27856>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
27858>>>>>>>        Integer iSize iCount iIndexNumberTo
27858>>>>>>>        String sSQLIndexNameTo
27858>>>>>>>        Integer iRetVal
27858>>>>>>>
27858>>>>>>>        Move 0 to iRetVal
27859>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
27862>>>>>>>        If (iRetVal = 0) Begin
27864>>>>>>>            Function_Return 0
27865>>>>>>>        End
27865>>>>>>>>
27865>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
27866>>>>>>>        Decrement iSize
27867>>>>>>>        for iCount from 0 to iSize
27873>>>>>>>>
27873>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
27875>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
27877>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
27878>>>>>>>                End
27878>>>>>>>>
27878>>>>>>>            End
27878>>>>>>>>
27878>>>>>>>        Loop
27879>>>>>>>>
27879>>>>>>>
27879>>>>>>>        Function_Return iRetVal
27880>>>>>>>    End_Function
27881>>>>>>>
27881>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
27883>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
27883>>>>>>>
27883>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
27886>>>>>>>        If (iSegment = iNumSegments) Begin
27888>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
27888>>>>>>>        End
27888>>>>>>>>
27888>>>>>>>
27888>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
27891>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
27897>>>>>>>>
27897>>>>>>>                //*** Move index segment attributes
27897>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
27900>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
27903>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
27906>>>>>>>
27906>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
27909>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
27912>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
27915>>>>>>>            Loop
27916>>>>>>>>
27916>>>>>>>
27916>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
27919>>>>>>>        End
27919>>>>>>>>
27919>>>>>>>
27919>>>>>>>        Function_Return (Err = False)
27920>>>>>>>    End_Function
27921>>>>>>>
27921>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
27923>>>>>>>        String[] aFields
27924>>>>>>>        Integer iCount iSize iIndex
27924>>>>>>>        String sDriverID
27924>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey
27924>>>>>>>
27924>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
27925>>>>>>>        If (iSize = 0) Begin
27927>>>>>>>            Function_Return True
27928>>>>>>>        End
27928>>>>>>>>
27928>>>>>>>
27928>>>>>>>        Get AutoConnectionIDLogin to bOK
27929>>>>>>>        Move False to Err
27930>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
27933>>>>>>>        If (bIsOpen = False) Begin
27935>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
27936>>>>>>>            If (bIsOpen = False) Begin
27938>>>>>>>                Function_Return False
27939>>>>>>>            End
27939>>>>>>>>
27939>>>>>>>        End
27939>>>>>>>>
27939>>>>>>>
27939>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
27942>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
27943>>>>>>>
27943>>>>>>>        Move False to Err
27944>>>>>>>        Move 0 to LastErr
27945>>>>>>>        Decrement iSize
27946>>>>>>>
27946>>>>>>>        Structure_Start hTable sDriverID
27947>>>>>>>            for iCount from 0 to iSize
27953>>>>>>>>
27953>>>>>>>//                Move False to bIsSQLPrimaryKey
27953>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
27953>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
27953>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
27953>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
27953>>>>>>>//                #ENDIF
27953>>>>>>>                // We can't delete if this is a primary key index:
27953>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
27953>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
27954>>>>>>>                    Delete_Index hTable iIndex
27955>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
27955>>>>>>>//                End
27955>>>>>>>            Loop
27956>>>>>>>>
27956>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27957>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27959>>>>>>>//        Move False to Err
27959>>>>>>>        Move 0 to LastErr
27960>>>>>>>
27960>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27961>>>>>>>        Function_Return (Err = False)
27962>>>>>>>    End_Function
27963>>>>>>>
27963>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
27965>>>>>>>        Boolean bOK
27965>>>>>>>
27965>>>>>>>        Get AutoConnectionIDLogin to bOK
27966>>>>>>>        Move False to Err
27967>>>>>>>        Get OpenTableExclusive hTable to bOK
27968>>>>>>>        If (bOK = False) Begin
27970>>>>>>>            Function_Return False
27971>>>>>>>        End
27971>>>>>>>>
27971>>>>>>>        Structure_Start hTable
27972>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
27975>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27976>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
27978>>>>>>>
27978>>>>>>>        Set Action_Text of ghoStatusPanel to ""
27979>>>>>>>        Function_Return (Err = False)
27980>>>>>>>    End_Function
27981>>>>>>>
27981>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
27983>>>>>>>        Integer iCase
27983>>>>>>>        Boolean bOK
27983>>>>>>>
27983>>>>>>>        If (bUppercase = True) Begin
27985>>>>>>>            Move DF_CASE_IGNORED to iCase
27986>>>>>>>        End
27986>>>>>>>>
27986>>>>>>>        Else Begin
27987>>>>>>>            Move DF_CASE_USED to iCase
27988>>>>>>>        End
27988>>>>>>>>
27988>>>>>>>
27988>>>>>>>        Get AutoConnectionIDLogin to bOK
27989>>>>>>>        Move False to Err
27990>>>>>>>        Get OpenTableExclusive hTable to bOK
27991>>>>>>>        If (bOK = False) Begin
27993>>>>>>>            Function_Return False
27994>>>>>>>        End
27994>>>>>>>>
27994>>>>>>>        Structure_Start hTable
27995>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
27998>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
27999>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
28001>>>>>>>
28001>>>>>>>        Set Action_Text of ghoStatusPanel to ""
28002>>>>>>>        Function_Return (Err = False)
28003>>>>>>>    End_Function
28004>>>>>>>
28004>>>>>>>    // To delete an index
28004>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
28006>>>>>>>        Integer iTableNo iNumSegments
28006>>>>>>>        String sDriverID
28006>>>>>>>        Boolean bOK
28006>>>>>>>
28006>>>>>>>        Get AutoConnectionIDLogin to bOK
28007>>>>>>>        Move False to Err
28008>>>>>>>        Move hTable to iTableNo
28009>>>>>>>        Get OpenTableExclusive hTable to bOK
28010>>>>>>>        If (bOK = False) Begin
28012>>>>>>>            Function_Return False
28013>>>>>>>        End
28013>>>>>>>>
28013>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
28016>>>>>>>
28016>>>>>>>        // Check to see if the index exists or not...
28016>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
28019>>>>>>>        If (iNumSegments = 0) Begin
28021>>>>>>>            Function_Return False
28022>>>>>>>        End
28022>>>>>>>>
28022>>>>>>>
28022>>>>>>>        Structure_Start hTable sDriverID
28023>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
28024>>>>>>>            Delete_Index iTableNo iIndex
28025>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
28026>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
28027>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
28029>>>>>>>
28029>>>>>>>        Set Action_Text of ghoStatusPanel to ""
28030>>>>>>>        Function_Return (Err = False)
28031>>>>>>>    End_Function
28032>>>>>>>
28032>>>>>>>    // Delete an Index Segment
28032>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
28034>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary
28034>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
28034>>>>>>>        Integer iIndexType
28034>>>>>>>        String sDriverID
28034>>>>>>>
28034>>>>>>>        Get AutoConnectionIDLogin to bOK
28035>>>>>>>        Move False to Err
28036>>>>>>>
28036>>>>>>>        Get OpenTableExclusive hTable to bOK
28037>>>>>>>        If (bOK = False) Begin
28039>>>>>>>            Function_Return False
28040>>>>>>>        End
28040>>>>>>>>
28040>>>>>>>
28040>>>>>>>        // Check to see if the index exists or not...
28040>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
28043>>>>>>>        If (iNumSegments = 0) Begin
28045>>>>>>>            Function_Return False
28046>>>>>>>        End
28046>>>>>>>>
28046>>>>>>>
28046>>>>>>>        Move False to bIndexTemporary
28047>>>>>>>        Get psDriverID to sDriverID
28048>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
28049>>>>>>>        If (bSQLDriver) Begin
28051>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
28054>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
28057>>>>>>>                Move True to bIndexTemporary
28058>>>>>>>        End
28058>>>>>>>>
28058>>>>>>>
28058>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
28058>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
28060>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
28063>>>>>>>            If (iSegment = iNumSegments) Begin
28065>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
28068>>>>>>>            End
28068>>>>>>>>
28068>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
28071>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
28077>>>>>>>>
28077>>>>>>>                    //*** Move index segment attributes
28077>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
28080>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
28083>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
28086>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
28089>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
28092>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
28095>>>>>>>                Loop
28096>>>>>>>>
28096>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
28099>>>>>>>            End
28099>>>>>>>>
28099>>>>>>>        End
28099>>>>>>>>
28099>>>>>>>
28099>>>>>>>        Else Begin
28100>>>>>>>           Structure_Start hTable
28101>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
28104>>>>>>>               If (iSegment = iNumSegments) Begin
28106>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
28109>>>>>>>               End
28109>>>>>>>>
28109>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
28112>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
28118>>>>>>>>
28118>>>>>>>                       //*** Move index segment attributes
28118>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
28121>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
28124>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
28127>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
28130>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
28133>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
28136>>>>>>>                   Loop
28137>>>>>>>>
28137>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
28140>>>>>>>               End
28140>>>>>>>>
28140>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
28141>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
28143>>>>>>>            Set Action_Text of ghoStatusPanel to ""
28144>>>>>>>        End
28144>>>>>>>>
28144>>>>>>>
28144>>>>>>>        Function_Return (Err = False)
28145>>>>>>>    End_Function
28146>>>>>>>
28146>>>>>>>    // Add/Insert an Index Segment
28146>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
28148>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary
28148>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
28148>>>>>>>        Integer iIndexType
28148>>>>>>>        String sDriverId
28148>>>>>>>
28148>>>>>>>        Get AutoConnectionIDLogin to bOK
28149>>>>>>>        Move False to Err
28150>>>>>>>
28150>>>>>>>        Get OpenTableExclusive hTable to bOK
28151>>>>>>>        If (bOK = False) Begin
28153>>>>>>>            Function_Return False
28154>>>>>>>        End
28154>>>>>>>>
28154>>>>>>>
28154>>>>>>>        Move False to bIndexTemporary
28155>>>>>>>        // Check to see if the index exists or not...
28155>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
28158>>>>>>>        If (iNumSegments = 0) Begin
28160>>>>>>>            Function_Return False
28161>>>>>>>        End
28161>>>>>>>>
28161>>>>>>>
28161>>>>>>>        Get psDriverID to sDriverID
28162>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
28163>>>>>>>        If (bSQLDriver) Begin
28165>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
28168>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
28171>>>>>>>                Move True to bIndexTemporary
28172>>>>>>>        End
28172>>>>>>>>
28172>>>>>>>
28172>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
28172>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
28174>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
28177>>>>>>>
28177>>>>>>>           If (iSegment > iNumSegments) Begin
28179>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
28182>>>>>>>               Move (iNumSegments + 1) to iCurSegment
28183>>>>>>>           End
28183>>>>>>>>
28183>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
28186>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
28189>>>>>>>               Move iNumSegments to iCurSegment
28190>>>>>>>
28190>>>>>>>               While (iCurSegment > iSegment)
28194>>>>>>>                   //*** Move index segment attributes
28194>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
28197>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
28200>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
28203>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
28206>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
28209>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
28212>>>>>>>                   Decrement iCurSegment
28213>>>>>>>               Loop
28214>>>>>>>>
28214>>>>>>>
28214>>>>>>>               //*** Now set new segment attributes
28214>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
28217>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
28220>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
28223>>>>>>>           End
28223>>>>>>>>
28223>>>>>>>        End
28223>>>>>>>>
28223>>>>>>>
28223>>>>>>>        Else Begin
28224>>>>>>>        Structure_Start hTable
28225>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
28228>>>>>>>
28228>>>>>>>            If (iSegment > iNumSegments) Begin
28230>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
28233>>>>>>>                Move (iNumSegments + 1) to iCurSegment
28234>>>>>>>            End
28234>>>>>>>>
28234>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
28237>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
28240>>>>>>>                Move iNumSegments to iCurSegment
28241>>>>>>>
28241>>>>>>>                While (iCurSegment > iSegment)
28245>>>>>>>                    //*** Move index segment attributes
28245>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
28248>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
28251>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
28254>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
28257>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
28260>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
28263>>>>>>>                    Decrement iCurSegment
28264>>>>>>>                Loop
28265>>>>>>>>
28265>>>>>>>
28265>>>>>>>                //*** Now set new segment attributes
28265>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
28268>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
28271>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
28274>>>>>>>            End
28274>>>>>>>>
28274>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
28275>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
28277>>>>>>>            Set Action_Text of ghoStatusPanel to ""
28278>>>>>>>        End
28278>>>>>>>>
28278>>>>>>>
28278>>>>>>>        Function_Return (Err = False)
28279>>>>>>>    End_Function
28280>>>>>>>
28280>>>>>>>    Function API_TABLE_UTILITY_FUNCTIONS Returns Boolean
28282>>>>>>>        Function_Return False
28283>>>>>>>    End_Function
28284>>>>>>>
28284>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
28284>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
28284>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
28286>>>>>>>        Boolean bIsSame
28286>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
28286>>>>>>>
28286>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
28287>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
28288>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
28289>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
28290>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
28291>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
28292>>>>>>>
28292>>>>>>>        If (bCompareFilelistUppercase = True) Begin
28294>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
28295>>>>>>>        End
28295>>>>>>>>
28295>>>>>>>        Else Begin
28296>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
28297>>>>>>>        End
28297>>>>>>>>
28297>>>>>>>        If (bIsSame = False) Begin
28299>>>>>>>            Function_Return False
28300>>>>>>>        End
28300>>>>>>>>
28300>>>>>>>
28300>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
28301>>>>>>>        If (bIsSame = False) Begin
28303>>>>>>>            Function_Return False
28304>>>>>>>        End
28304>>>>>>>>
28304>>>>>>>
28304>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
28305>>>>>>>        If (bIsSame = False) Begin
28307>>>>>>>            Function_Return False
28308>>>>>>>        End
28308>>>>>>>>
28308>>>>>>>
28308>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
28309>>>>>>>        If (bIsSame = False) Begin
28311>>>>>>>            Function_Return False
28312>>>>>>>        End
28312>>>>>>>>
28312>>>>>>>
28312>>>>>>>        Function_Return bIsSame
28313>>>>>>>    End_Function
28314>>>>>>>
28314>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
28316>>>>>>>        Handle hTableFrom hTableTo
28316>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
28316>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
28316>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
28316>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
28316>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
28317>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
28317>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
28318>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
28318>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
28319>>>>>>>
28319>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
28320>>>>>>>        If (bIsSame = True) Begin
28322>>>>>>>            Function_Return True
28323>>>>>>>        End
28323>>>>>>>>
28323>>>>>>>
28323>>>>>>>        Move False to bFilelistError
28324>>>>>>>        Move True to bIsSame
28325>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
28326>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
28327>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
28328>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
28329>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
28330>>>>>>>
28330>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
28331>>>>>>>        Get _TableNameOnly sRootName             to sRootName
28332>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
28333>>>>>>>
28333>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
28333>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
28333>>>>>>>        If (bCodeGenerateMode = True) Begin
28335>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
28335>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
28337>>>>>>>                Function_Return False
28338>>>>>>>            End
28338>>>>>>>>
28338>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
28339>>>>>>>            If (bIsSame = False) Begin
28341>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
28342>>>>>>>                Move True to bFilelistError
28343>>>>>>>                Function_Return False
28344>>>>>>>            End
28344>>>>>>>>
28344>>>>>>>        End
28344>>>>>>>>
28344>>>>>>>
28344>>>>>>>        If (bCodeGenerateMode = False) Begin
28346>>>>>>>            // Then we want to create this table
28346>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
28348>>>>>>>                Function_Return False
28349>>>>>>>            End
28349>>>>>>>>
28349>>>>>>>
28349>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
28350>>>>>>>            If (bIsSame = False) Begin
28352>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
28353>>>>>>>>
28353>>>>>>>                Move True to bFilelistError
28354>>>>>>>                Function_Return False
28355>>>>>>>            End
28355>>>>>>>>
28355>>>>>>>        End
28355>>>>>>>>
28355>>>>>>>
28355>>>>>>>        // Check columns:
28355>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
28356>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
28357>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
28358>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
28359>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
28360>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
28361>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
28362>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
28363>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
28364>>>>>>>        If (bIsSame = False) Begin
28366>>>>>>>            Function_Return False
28367>>>>>>>        End
28367>>>>>>>>
28367>>>>>>>
28367>>>>>>>        // ...then check indexes:
28367>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
28368>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
28369>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
28370>>>>>>>        If (bIsSame = False) Begin
28372>>>>>>>            Function_Return False
28373>>>>>>>        End
28373>>>>>>>>
28373>>>>>>>
28373>>>>>>>        // ...and finally relationships:
28373>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
28374>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
28375>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
28376>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
28377>>>>>>>
28377>>>>>>>        Function_Return (bIsSame = True)
28378>>>>>>>    End_Function
28379>>>>>>>
28379>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
28379>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
28381>>>>>>>        Handle hTable
28381>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
28381>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
28381>>>>>>>
28381>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
28383>>>>>>>            Move True to bFilelistError
28384>>>>>>>            Function_Return False
28385>>>>>>>        End
28385>>>>>>>>
28385>>>>>>>
28385>>>>>>>        Move APITableCompare.hTable to hTable
28386>>>>>>>        Move True  to bIsSame
28387>>>>>>>        Move False to bFilelistError
28388>>>>>>>
28388>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
28390>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
28391>>>>>>>        End
28391>>>>>>>>
28391>>>>>>>        Else Begin
28392>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
28393>>>>>>>        End
28393>>>>>>>>
28393>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
28394>>>>>>>
28394>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
28395>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
28396>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
28397>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
28398>>>>>>>
28398>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
28398>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
28398>>>>>>>        If (bCodeGenerateMode = True) Begin
28400>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
28400>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
28402>>>>>>>                Function_Return False
28403>>>>>>>            End
28403>>>>>>>>
28403>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
28404>>>>>>>            If (bIsSame = False) Begin
28406>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
28407>>>>>>>                Move True to bFilelistError
28408>>>>>>>                Function_Return False
28409>>>>>>>            End
28409>>>>>>>>
28409>>>>>>>        End
28409>>>>>>>>
28409>>>>>>>
28409>>>>>>>        If (bCodeGenerateMode = False) Begin
28411>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
28413>>>>>>>                // Then we might want to create this table
28413>>>>>>>                Function_Return False
28414>>>>>>>            End
28414>>>>>>>>
28414>>>>>>>
28414>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
28415>>>>>>>            If (bIsSame = False) Begin
28417>>>>>>>                Function_Return False
28418>>>>>>>            End
28418>>>>>>>>
28418>>>>>>>
28418>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
28419>>>>>>>            If (bIsSame = False) Begin
28421>>>>>>>                Function_Return False
28422>>>>>>>            End
28422>>>>>>>>
28422>>>>>>>
28422>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
28423>>>>>>>            If (bIsSame = False) Begin
28425>>>>>>>                Function_Return False
28426>>>>>>>            End
28426>>>>>>>>
28426>>>>>>>
28426>>>>>>>            // Check table names et al.
28426>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
28427>>>>>>>            If (bIsSame = False) Begin
28429>>>>>>>                Function_Return False
28430>>>>>>>            End
28430>>>>>>>>
28430>>>>>>>        End
28430>>>>>>>>
28430>>>>>>>
28430>>>>>>>        // Check Columns:
28430>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
28431>>>>>>>        If (bIsSame = False) Begin
28433>>>>>>>            Function_Return False
28434>>>>>>>        End
28434>>>>>>>>
28434>>>>>>>
28434>>>>>>>        // ...then check Indexes:
28434>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
28435>>>>>>>        If (bIsSame = False) Begin
28437>>>>>>>            Function_Return False
28438>>>>>>>        End
28438>>>>>>>>
28438>>>>>>>
28438>>>>>>>        // ...and finally Relationships:
28438>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
28439>>>>>>>
28439>>>>>>>        Function_Return (bIsSame = True)
28440>>>>>>>    End_Function
28441>>>>>>>
28441>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
28441>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
28441>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
28441>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
28441>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
28443>>>>>>>        tAPITableNameInfo ApiTableNameInfo
28443>>>>>>>        tAPITableNameInfo ApiTableNameInfo
28443>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
28443>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
28445>>>>>>>        tAPIColumn[]    aApiColumns
28445>>>>>>>        tAPIColumn[]    aApiColumns
28446>>>>>>>        tAPIIndex[]     aApiIndexes
28446>>>>>>>        tAPIIndex[]     aApiIndexes
28447>>>>>>>        tAPIRelation[]  aApiRelations
28447>>>>>>>        tAPIRelation[]  aApiRelations
28448>>>>>>>        Handle hTable
28448>>>>>>>        Integer iCount iPos
28448>>>>>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen bOK
28448>>>>>>>        String sLogicalName sMessageText
28448>>>>>>>
28448>>>>>>>        Get AutoConnectionIDLogin to bOK
28449>>>>>>>        Move 0 to hTable
28450>>>>>>>        If (bFromTables = True) Begin
28452>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
28453>>>>>>>            If (bCompareUtil = True) Begin
28455>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
28456>>>>>>>            End
28456>>>>>>>>
28456>>>>>>>        End
28456>>>>>>>>
28456>>>>>>>        Else Begin
28457>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
28458>>>>>>>            If (bCompareUtil = True) Begin
28460>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
28461>>>>>>>            End
28461>>>>>>>>
28461>>>>>>>        End
28461>>>>>>>>
28461>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
28462>>>>>>>
28462>>>>>>>        Get UtilFilelistNoOfTables to iCount
28463>>>>>>>        Set piMaximum of ghoProgressBar to iCount
28464>>>>>>>        Move 0 to iCount
28465>>>>>>>
28465>>>>>>>        Repeat
28465>>>>>>>>
28465>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
28468>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
28470>>>>>>>
28470>>>>>>>                Open hTable
28472>>>>>>>                // ToDo: Needs to be revised
28472>>>>>>>                // For some reason tables may be reported as "unopened", while in
28472>>>>>>>                // fact the open was successful (!)
28472>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
28472>>>>>>>//                If (bIsOpen = False) Begin
28472>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
28472>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
28472>>>>>>>//                    Function_Return aApiTablesEmpty
28472>>>>>>>//                End
28472>>>>>>>
28472>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
28475>>>>>>>                Set piPosition of ghoProgressBar to iCount
28476>>>>>>>                Send DoAdvance of ghoProgressBarOverall
28477>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
28478>>>>>>>
28478>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
28479>>>>>>>//                Close hTable DF_PERMANENT
28479>>>>>>>                Increment iCount
28480>>>>>>>            End
28480>>>>>>>>
28480>>>>>>>
28480>>>>>>>            If (bStatusPanel = True) Begin
28482>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
28483>>>>>>>                If (bUserCancel = True) Begin
28485>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
28486>>>>>>>                    Function_Return aApiTablesEmpty
28487>>>>>>>                End
28487>>>>>>>>
28487>>>>>>>            End
28487>>>>>>>>
28487>>>>>>>
28487>>>>>>>        Until (hTable = 0)
28489>>>>>>>
28489>>>>>>>        Function_Return aApiTables
28490>>>>>>>    End_Function
28491>>>>>>>
28491>>>>>>>    // Returns a 'single' table APITable struct.
28491>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
28493>>>>>>>        tAPITableNameInfo ApiTableNameInfo
28493>>>>>>>        tAPITableNameInfo ApiTableNameInfo
28493>>>>>>>        tAPITable         ApiTable ApiTableEmpty
28493>>>>>>>        tAPITable         ApiTable ApiTableEmpty
28493>>>>>>>        tAPIColumn[]     aApiColumns
28493>>>>>>>        tAPIColumn[]     aApiColumns
28494>>>>>>>        tAPIIndex[]      aApiIndexes
28494>>>>>>>        tAPIIndex[]      aApiIndexes
28495>>>>>>>        tAPIRelation[]   aApiRelations
28495>>>>>>>        tAPIRelation[]   aApiRelations
28496>>>>>>>        Integer iCount iPos
28496>>>>>>>        Boolean bIsAlias bUserCancel bIsSQL bIsOpen
28496>>>>>>>        String sLogicalName sRootName sDisplayName sTableName sDriverID sMessageText
28496>>>>>>>
28496>>>>>>>        Open hTable
28498>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
28501>>>>>>>        If (bIsOpen = False) Begin
28503>>>>>>>            Move True to ApiTableEmpty.bError
28504>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
28505>>>>>>>            Function_Return ApiTableEmpty
28506>>>>>>>        End
28506>>>>>>>>
28506>>>>>>>
28506>>>>>>>        // Fill Table Name Info
28506>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
28507>>>>>>>
28507>>>>>>>        // Fill columns
28507>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
28508>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
28510>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
28512>>>>>>>                Move True to ApiTableEmpty.bError
28513>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
28514>>>>>>>                Function_Return ApiTableEmpty
28515>>>>>>>            End
28515>>>>>>>>
28515>>>>>>>        End
28515>>>>>>>>
28515>>>>>>>
28515>>>>>>>        // Fill indexes
28515>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
28516>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
28518>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
28520>>>>>>>                Move True to ApiTableEmpty.bError
28521>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
28522>>>>>>>                Function_Return ApiTableEmpty
28523>>>>>>>            End
28523>>>>>>>>
28523>>>>>>>        End
28523>>>>>>>>
28523>>>>>>>
28523>>>>>>>
28523>>>>>>>        // Fill relationships
28523>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
28524>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
28526>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
28528>>>>>>>                Move True to ApiTableEmpty.bError
28529>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
28530>>>>>>>                Function_Return ApiTableEmpty
28531>>>>>>>            End
28531>>>>>>>>
28531>>>>>>>        End
28531>>>>>>>>
28531>>>>>>>
28531>>>>>>>        Move hTable             to ApiTable.hTable
28532>>>>>>>        Move bFromTables        to ApiTable.bFromTable
28533>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
28534>>>>>>>
28534>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
28535>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
28536>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
28537>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
28538>>>>>>>
28538>>>>>>>        Function_Return ApiTable
28539>>>>>>>    End_Function
28540>>>>>>>
28540>>>>>>>
28540>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
28542>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
28542>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
28542>>>>>>>        Boolean bIsOpen
28542>>>>>>>
28542>>>>>>>        Open hTable
28544>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
28547>>>>>>>        If (bIsOpen = False) Begin
28549>>>>>>>            Move True   to APITableNameInfoEmpty.bError
28550>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
28551>>>>>>>            Function_Return APITableNameInfoEmpty
28552>>>>>>>        End
28552>>>>>>>>
28552>>>>>>>
28552>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
28553>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
28556>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
28559>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
28562>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
28565>>>>>>>
28565>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
28566>>>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
28567>>>>>>>
28567>>>>>>>//        Close hTable
28567>>>>>>>
28567>>>>>>>        Function_Return APITableNameInfo
28568>>>>>>>    End_Function
28569>>>>>>>
28569>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
28571>>>>>>>        Integer iSize iCount iTable iItem
28571>>>>>>>        tAPITableNameInfo ApiTableNameInfo
28571>>>>>>>        tAPITableNameInfo ApiTableNameInfo
28571>>>>>>>
28571>>>>>>>        Move -1 to iItem
28572>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
28573>>>>>>>        Decrement iSize
28574>>>>>>>        for iCount from 0 to iSize
28580>>>>>>>>
28580>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
28581>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
28583>>>>>>>                Move iCount to iItem
28584>>>>>>>                Move iSize  to iCount // We're done.
28585>>>>>>>            End
28585>>>>>>>>
28585>>>>>>>        Loop
28586>>>>>>>>
28586>>>>>>>
28586>>>>>>>        Function_Return iItem
28587>>>>>>>    End_Function
28588>>>>>>>
28588>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
28590>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
28593>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
28596>>>>>>>
28596>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
28599>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
28602>>>>>>>
28602>>>>>>>        Function_Return (EQ)
28603>>>>>>>    End_Function
28604>>>>>>>
28604>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
28606>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
28606>>>>>>>        Handle hTable
28606>>>>>>>        tAPITable[] aAPITableFromAndTo
28606>>>>>>>        tAPITable[] aAPITableFromAndTo
28607>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
28607>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
28607>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
28607>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
28607>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
28607>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
28608>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
28608>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
28609>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
28609>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
28610>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
28610>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
28611>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
28611>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
28611>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
28611>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
28614>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
28614>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
28617>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
28617>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
28620>>>>>>>
28620>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
28621>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
28622>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
28624>>>>>>>            Function_Return aAPITableCompare
28625>>>>>>>        End
28625>>>>>>>>
28625>>>>>>>
28625>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
28626>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
28627>>>>>>>
28627>>>>>>>        Move 0 to iItem
28628>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
28629>>>>>>>        Decrement iSize
28630>>>>>>>        for iCount from 0 to iSize
28636>>>>>>>>
28636>>>>>>>
28636>>>>>>>            Move iCount to iItemFrom
28637>>>>>>>            Move iCount to iItemTo
28638>>>>>>>            Move APITableEmpty to APITableFrom
28639>>>>>>>            Move APITableEmpty to APITableTo
28640>>>>>>>
28640>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
28642>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
28643>>>>>>>            End
28643>>>>>>>>
28643>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
28645>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
28646>>>>>>>            End
28646>>>>>>>>
28646>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
28648>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
28649>>>>>>>                Move (iCount + 1) to iItemTo
28650>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
28651>>>>>>>            End
28651>>>>>>>>
28651>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
28653>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
28654>>>>>>>                If (iItemTo <> -1) Begin
28656>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
28657>>>>>>>                End
28657>>>>>>>>
28657>>>>>>>                Else Begin
28658>>>>>>>                    Move APITableEmpty to APITableTo
28659>>>>>>>                End
28659>>>>>>>>
28659>>>>>>>            End
28659>>>>>>>>
28659>>>>>>>
28659>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
28660>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
28661>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
28662>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
28663>>>>>>>
28663>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
28664>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
28665>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
28666>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
28667>>>>>>>
28667>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
28668>>>>>>>
28668>>>>>>>            If (hTable > 0) Begin
28670>>>>>>>
28670>>>>>>>                // Table info:
28670>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
28671>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
28672>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
28673>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
28674>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
28675>>>>>>>
28675>>>>>>>                // Column info:
28675>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
28676>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
28677>>>>>>>
28677>>>>>>>                // Index info:
28677>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
28678>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
28679>>>>>>>
28679>>>>>>>                // Relation info:
28679>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
28680>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
28681>>>>>>>
28681>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
28682>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
28683>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
28684>>>>>>>                If (iItemTo > iItemFrom) Begin
28686>>>>>>>                    Increment iCount
28687>>>>>>>                End
28687>>>>>>>>
28687>>>>>>>                Increment iItem
28688>>>>>>>            End
28688>>>>>>>>
28688>>>>>>>
28688>>>>>>>        Loop
28689>>>>>>>>
28689>>>>>>>
28689>>>>>>>        Function_Return aAPITableCompare
28690>>>>>>>    End_Function
28691>>>>>>>
28691>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
28693>>>>>>>        Integer iSize iCount iTable iItem
28693>>>>>>>        tAPITableNameInfo ApiTableNameInfo
28693>>>>>>>        tAPITableNameInfo ApiTableNameInfo
28693>>>>>>>
28693>>>>>>>        Move -1 to iItem
28694>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
28695>>>>>>>        Decrement iSize
28696>>>>>>>        For iCount from 0 to iSize
28702>>>>>>>>
28702>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
28703>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
28705>>>>>>>                Move iCount to iItem
28706>>>>>>>                Move iSize  to iCount // We're done.
28707>>>>>>>            End
28707>>>>>>>>
28707>>>>>>>        Loop
28708>>>>>>>>
28708>>>>>>>
28708>>>>>>>        Function_Return iItem
28709>>>>>>>    End_Function
28710>>>>>>>
28710>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
28712>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
28712>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
28712>>>>>>>
28712>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
28714>>>>>>>            Function_Return APITableNameInfoCompare
28715>>>>>>>        End
28715>>>>>>>>
28715>>>>>>>
28715>>>>>>>        // FROM database info:
28715>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
28717>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
28718>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
28719>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
28720>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
28721>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
28722>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
28723>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
28724>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
28725>>>>>>>        End
28725>>>>>>>>
28725>>>>>>>
28725>>>>>>>        // TO database info:
28725>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
28727>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
28728>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
28729>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
28730>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
28731>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
28732>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
28733>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
28734>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
28735>>>>>>>        End
28735>>>>>>>>
28735>>>>>>>
28735>>>>>>>        Function_Return APITableNameInfoCompare
28736>>>>>>>    End_Function
28737>>>>>>>
28737>>>>>>>    // Note:
28737>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
28737>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
28737>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
28737>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
28737>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
28737>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
28739>>>>>>>        String sTableName
28739>>>>>>>        Boolean bOpen bExists bOK
28739>>>>>>>
28739>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
28740>>>>>>>        If (bExists = False) Begin
28742>>>>>>>            Function_Return ""
28743>>>>>>>        End
28743>>>>>>>>
28743>>>>>>>
28743>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
28744>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
28747>>>>>>>        If (bOpen = False) Begin
28749>>>>>>>            Get AutoConnectionIDLogin to bOK
28750>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
28751>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
28752>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
28753>>>>>>>            Open hTable
28755>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
28756>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
28757>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
28758>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
28761>>>>>>>        End
28761>>>>>>>>
28761>>>>>>>        If (bOpen = True) Begin
28763>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
28764>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
28767>>>>>>>            // If blank it is an embedded table:
28767>>>>>>>            If (sTableName = "") Begin
28769>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
28772>>>>>>>                Move 0 to LastErr
28773>>>>>>>                Move False to Err
28774>>>>>>>            End
28774>>>>>>>>
28774>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
28775>>>>>>>        End
28775>>>>>>>>
28775>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
28776>>>>>>>        Move 0 to LastErr
28777>>>>>>>
28777>>>>>>>        Function_Return sTableName
28778>>>>>>>    End_Function
28779>>>>>>>
28779>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
28779>>>>>>>    // Returns 0 if unsuccessful.
28779>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
28779>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
28781>>>>>>>        String sValue sPrefixTableName sDriverID
28781>>>>>>>        Handle hTable hRetval
28781>>>>>>>
28781>>>>>>>        Get psDriverID to sDriverID
28782>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
28784>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
28785>>>>>>>        End
28785>>>>>>>>
28785>>>>>>>        Move 0 to hTable
28786>>>>>>>        Move 0 to hRetval
28787>>>>>>>        Repeat
28787>>>>>>>>
28787>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
28790>>>>>>>            If (hTable <> 0) Begin
28792>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
28795>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
28797>>>>>>>                    Move hTable to hRetval
28798>>>>>>>                    Move 0 to hTable
28799>>>>>>>                End
28799>>>>>>>>
28799>>>>>>>            End
28799>>>>>>>>
28799>>>>>>>        Until (hTable = 0)
28801>>>>>>>
28801>>>>>>>        Function_Return hRetval
28802>>>>>>>    End_Function
28803>>>>>>>
28803>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
28803>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
28803>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
28805>>>>>>>        Boolean bOK bExists
28805>>>>>>>        String sDataPath sBackupFolder
28805>>>>>>>
28805>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
28806>>>>>>>        Move "BackupData" to sBackupFolder
28807>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
28808>>>>>>>        Get vFolderFormat sDataPath to sDataPath
28809>>>>>>>
28809>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
28810>>>>>>>        If (bExists = False) Begin
28812>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
28813>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
28814>>>>>>>            If (bExists = False) Begin
28816>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
28817>>>>>>>>
28817>>>>>>>                Function_Return False
28818>>>>>>>            End
28818>>>>>>>>
28818>>>>>>>            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
28819>>>>>>>            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
28820>>>>>>>            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
28821>>>>>>>            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
28822>>>>>>>        End
28822>>>>>>>>
28822>>>>>>>
28822>>>>>>>        Set Message_Text of ghoStatusPanel to ""
28823>>>>>>>        Function_Return bOK
28824>>>>>>>    End_Function
28825>>>>>>>
28825>>>>>>>    // * Dummy function for the Studio's Code Explorer *
28825>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
28827>>>>>>>        Function_Return False
28828>>>>>>>    End_Function
28829>>>>>>>
28829>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
28829>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
28831>>>>>>>        Boolean bIsSame
28831>>>>>>>        Integer iCount iSize iColumn
28831>>>>>>>
28831>>>>>>>        Move True to bIsSame
28832>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
28833>>>>>>>        Set piMaximum of ghoProgressBar  to iSize
28834>>>>>>>
28834>>>>>>>        Decrement iSize
28835>>>>>>>        for iCount from 0 to iSize
28841>>>>>>>>
28841>>>>>>>            Set piPosition of ghoProgressBar to iCount
28842>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
28843>>>>>>>            If (bIsSame = False) Begin
28845>>>>>>>                Function_Return False
28846>>>>>>>            End
28846>>>>>>>>
28846>>>>>>>        Loop
28847>>>>>>>>
28847>>>>>>>
28847>>>>>>>        Function_Return (bIsSame = True)
28848>>>>>>>    End_Function
28849>>>>>>>
28849>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
28849>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
28851>>>>>>>        Integer iFromType iToType iDbType
28851>>>>>>>        tColumnType ColumnType
28851>>>>>>>        tColumnType ColumnType
28851>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
28851>>>>>>>
28851>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
28853>>>>>>>            Function_Return False
28854>>>>>>>        End
28854>>>>>>>>
28854>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
28856>>>>>>>            Function_Return False
28857>>>>>>>        End
28857>>>>>>>>
28857>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
28859>>>>>>>            Function_Return False
28860>>>>>>>        End
28860>>>>>>>>
28860>>>>>>>        If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
28862>>>>>>>            Function_Return False
28863>>>>>>>        End
28863>>>>>>>>
28863>>>>>>>        If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
28865>>>>>>>            If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
28867>>>>>>>                End
28867>>>>>>>>
28867>>>>>>>            Else Begin
28868>>>>>>>                Function_Return False
28869>>>>>>>            End
28869>>>>>>>>
28869>>>>>>>        End
28869>>>>>>>>
28869>>>>>>>
28869>>>>>>>        Get piDbType                       to iDbType
28870>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
28871>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
28872>>>>>>>
28872>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
28872>>>>>>>        // data types between Embedded and SQL.
28872>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
28874>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
28875>>>>>>>        End
28875>>>>>>>>
28875>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
28877>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
28878>>>>>>>        End
28878>>>>>>>>
28878>>>>>>>
28878>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
28879>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
28880>>>>>>>
28880>>>>>>>        // Make Date and DateTime comparison?
28880>>>>>>>        If (bCompareDate_DataTime = True) Begin
28882>>>>>>>            If (iFromType <> iToType) Begin
28884>>>>>>>                Function_Return False
28885>>>>>>>            End
28885>>>>>>>>
28885>>>>>>>        End
28885>>>>>>>>
28885>>>>>>>
28885>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
28885>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
28887>>>>>>>            If (iFromType <> iToType) Begin
28889>>>>>>>                Function_Return False
28890>>>>>>>            End
28890>>>>>>>>
28890>>>>>>>        End
28890>>>>>>>>
28890>>>>>>>
28890>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
28890>>>>>>>        If (bIsDateTypeFrom = False) Begin
28892>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
28894>>>>>>>                Function_Return False
28895>>>>>>>            End
28895>>>>>>>>
28895>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
28897>>>>>>>                Function_Return False
28898>>>>>>>            End
28898>>>>>>>>
28898>>>>>>>        End
28898>>>>>>>>
28898>>>>>>>
28898>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
28900>>>>>>>            Function_Return False
28901>>>>>>>        End
28901>>>>>>>>
28901>>>>>>>
28901>>>>>>>        Function_Return True
28902>>>>>>>    End_Function
28903>>>>>>>
28903>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
28905>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iLength iPrecision iCheckFieldNumber
28905>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel bState
28905>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
28905>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
28907>>>>>>>        String sDriverID sFieldName sRootName sLogicalName sValue
28907>>>>>>>
28907>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
28908>>>>>>>        Get piDbType to iDbType
28909>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
28912>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
28915>>>>>>>
28915>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
28918>>>>>>>        If (bIsOpen = False) Begin
28920>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
28921>>>>>>>            Open hTable
28923>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
28924>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
28927>>>>>>>            If (bIsOpen = False) Begin
28929>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
28930>>>>>>>                Move True to APIColumnsEmpty[0].bError
28931>>>>>>>                Function_Return APIColumnsEmpty
28932>>>>>>>            End
28932>>>>>>>>
28932>>>>>>>        End
28932>>>>>>>>
28932>>>>>>>
28932>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
28935>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
28936>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
28937>>>>>>>
28937>>>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
28938>>>>>>>        If (bIsSqlTable = True) Begin
28940>>>>>>>            Get UtilTableExists hTable to bExists
28941>>>>>>>            If (bExists = False) Begin
28943>>>>>>>                Move True to APIColumnsEmpty[0].bError
28944>>>>>>>                Function_Return APIColumnsEmpty
28945>>>>>>>            End
28945>>>>>>>>
28945>>>>>>>        End
28945>>>>>>>>
28945>>>>>>>
28945>>>>>>>        Move 0 to iCount
28946>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
28949>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
28950>>>>>>>
28950>>>>>>>        for iColumn from 1 to iNumColumns
28956>>>>>>>>
28956>>>>>>>            Move 0 to iOptions
28957>>>>>>>            Move False to bIdentityKey
28958>>>>>>>            Move False to Err
28959>>>>>>>            Move 0     to LastErr
28960>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
28961>>>>>>>            Set piPosition of ghoProgressBar to iColumn
28962>>>>>>>            If (bDawSqlDriver = True) Begin
28964>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
28965>>>>>>>                If (bIsSqlTable = True) Begin
28967>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
28970>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
28971>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
28974>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
28977>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
28980>>>>>>>                End
28980>>>>>>>>
28980>>>>>>>                Else Begin
28981>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
28984>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
28985>>>>>>>                End
28985>>>>>>>>
28985>>>>>>>
28985>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
28985>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
28988>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
28989>>>>>>>                If (bExists = False) Begin
28991>>>>>>>                    Move 0 to APIColumns[iCount].iType
28992>>>>>>>                End
28992>>>>>>>>
28992>>>>>>>                If (bExists = True) Begin
28994>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
28997>>>>>>>                End
28997>>>>>>>>
28997>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
28998>>>>>>>                If (bIdentityKey = True) Begin
29000>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
29001>>>>>>>                End
29001>>>>>>>>
29001>>>>>>>            End
29001>>>>>>>>
29001>>>>>>>            Else Begin
29002>>>>>>>                Move False to Err
29003>>>>>>>                Move 0     to LastErr
29004>>>>>>>                If (bIsSqlTable = True) Begin
29006>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
29009>>>>>>>                End
29009>>>>>>>>
29009>>>>>>>                Else Begin
29010>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
29013>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
29014>>>>>>>                End
29014>>>>>>>>
29014>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
29014>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
29015>>>>>>>                If (bExists = False) Begin
29017>>>>>>>                    Move 0 to APIColumns[iCount].iType
29018>>>>>>>                End
29018>>>>>>>>
29018>>>>>>>            End
29018>>>>>>>>
29018>>>>>>>
29018>>>>>>>            If (bExists = True) Begin
29020>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
29021>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
29024>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
29024>>>>>>>//                If (bIsSqlTable = True) Begin
29024>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
29024>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
29024>>>>>>>//                End
29024>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
29027>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
29030>>>>>>>
29030>>>>>>>                // If the length was zero we might have an Overlap(!) field.
29030>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
29030>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
29032>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
29035>>>>>>>                    If (iType = DF_OVERLAP) Begin
29037>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
29038>>>>>>>                        Move 0 to APIColumns[iCount].iLength
29039>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
29040>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
29041>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
29042>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
29043>>>>>>>                        Decrement iCount
29044>>>>>>>                    End
29044>>>>>>>>
29044>>>>>>>                End
29044>>>>>>>>
29044>>>>>>>            End
29044>>>>>>>>
29044>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
29045>>>>>>>            If (bUserCancel = True) Begin
29047>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
29048>>>>>>>                Function_Return APIColumnsEmpty
29049>>>>>>>            End
29049>>>>>>>>
29049>>>>>>>            Increment iCount
29050>>>>>>>        Loop
29051>>>>>>>>
29051>>>>>>>
29051>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
29052>>>>>>>        Function_Return APIColumns
29053>>>>>>>    End_Function
29054>>>>>>>
29054>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
29054>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
29054>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
29054>>>>>>>    // have "holes" in the series of index numbers.
29054>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
29056>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
29056>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
29057>>>>>>>        tAPIColumnCompare   APIColumnCompare
29057>>>>>>>        tAPIColumnCompare   APIColumnCompare
29057>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iColumnFrom iColumnTo
29057>>>>>>>
29057>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
29058>>>>>>>        Decrement iSizeFrom
29059>>>>>>>        for iCount from 0 to iSizeFrom
29065>>>>>>>>
29065>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
29066>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
29067>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
29068>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
29069>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
29070>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
29071>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
29072>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
29073>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
29074>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
29075>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
29076>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
29077>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
29078>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
29079>>>>>>>        Loop
29080>>>>>>>>
29080>>>>>>>
29080>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
29081>>>>>>>        Decrement iSizeTo
29082>>>>>>>        for iCount from 0 to iSizeTo
29088>>>>>>>>
29088>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
29089>>>>>>>            // Search if the field number already exists in the array; else add it.
29089>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
29090>>>>>>>            If (iItem = -1) Begin
29092>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
29093>>>>>>>            End
29093>>>>>>>>
29093>>>>>>>
29093>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
29094>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
29095>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
29096>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
29097>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
29098>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
29099>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
29100>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
29101>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
29102>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
29103>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
29104>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
29105>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
29106>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
29107>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
29108>>>>>>>        Loop
29109>>>>>>>>
29109>>>>>>>
29109>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
29110>>>>>>>
29110>>>>>>>        Function_Return aAPIColumnCompare
29111>>>>>>>    End_Function
29112>>>>>>>
29112>>>>>>>    // Checks if a field name exists in a table definition
29112>>>>>>>    // Returns True if it does
29112>>>>>>>    // Sample:
29112>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
29112>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
29114>>>>>>>        Integer iNumColumns iColumn
29114>>>>>>>        String sColumn
29114>>>>>>>        Boolean bExists bOK bOpen
29114>>>>>>>
29114>>>>>>>        Get AutoConnectionIDLogin to bOK
29115>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29116>>>>>>>        Open hTable
29118>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29119>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
29122>>>>>>>        If (bOpen = False) Begin
29124>>>>>>>            Function_Return False
29125>>>>>>>        End
29125>>>>>>>>
29125>>>>>>>
29125>>>>>>>        Move False to bExists
29126>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
29129>>>>>>>        for iColumn from 1 to iNumColumns
29135>>>>>>>>
29135>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
29138>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
29140>>>>>>>                Move iNumColumns to iColumn
29141>>>>>>>                Move True to bExists
29142>>>>>>>            End
29142>>>>>>>>
29142>>>>>>>        Loop
29143>>>>>>>>
29143>>>>>>>        Close hTable
29144>>>>>>>
29144>>>>>>>        Function_Return bExists
29145>>>>>>>    End_Function
29146>>>>>>>
29146>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
29146>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
29148>>>>>>>        Integer iNumColumns iColumn iRetval
29148>>>>>>>        String sColumn
29148>>>>>>>        Boolean bOK bOpen
29148>>>>>>>
29148>>>>>>>        Get AutoConnectionIDLogin to bOK
29149>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
29150>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29151>>>>>>>        Open hTable
29153>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29154>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
29157>>>>>>>        If (bOpen = False) Begin
29159>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
29160>>>>>>>            Function_Return False
29161>>>>>>>        End
29161>>>>>>>>
29161>>>>>>>
29161>>>>>>>        Move 0 to iColumn
29162>>>>>>>        Move 0 to iRetval
29163>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
29166>>>>>>>        for iColumn from 1 to iNumColumns
29172>>>>>>>>
29172>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
29175>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
29177>>>>>>>                Move iColumn to iRetval
29178>>>>>>>                Move iNumColumns to iColumn
29179>>>>>>>            End
29179>>>>>>>>
29179>>>>>>>        Loop
29180>>>>>>>>
29180>>>>>>>        Close hTable
29181>>>>>>>
29181>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
29182>>>>>>>        Function_Return iRetval
29183>>>>>>>    End_Function
29184>>>>>>>
29184>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
29184>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
29184>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
29186>>>>>>>        tColumnType RetvalType
29186>>>>>>>        tColumnType RetvalType
29186>>>>>>>
29186>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
29187>>>>>>>        Function_Return RetvalType.iSQLType
29188>>>>>>>    End_Function
29189>>>>>>>
29189>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
29189>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
29189>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
29191>>>>>>>        tColumnType RetvalType
29191>>>>>>>        tColumnType RetvalType
29191>>>>>>>
29191>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
29192>>>>>>>        Function_Return RetvalType.sSQLType
29193>>>>>>>    End_Function
29194>>>>>>>
29194>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
29196>>>>>>>        tColumnType RetvalType
29196>>>>>>>        tColumnType RetvalType
29196>>>>>>>
29196>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
29197>>>>>>>        Function_Return RetvalType.sPrecision
29198>>>>>>>    End_Function
29199>>>>>>>
29199>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
29201>>>>>>>        tColumnType RetvalType
29201>>>>>>>        tColumnType RetvalType
29201>>>>>>>
29201>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
29202>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
29202>>>>>>>        // if the column type length is _not_ fixed.
29202>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
29203>>>>>>>    End_Function
29204>>>>>>>
29204>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
29206>>>>>>>        tColumnType RetvalType
29206>>>>>>>        tColumnType RetvalType
29206>>>>>>>        String sValue
29206>>>>>>>        Integer iRetval iPos
29206>>>>>>>
29206>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
29207>>>>>>>        Move RetvalType.sPrecision to sValue
29208>>>>>>>        Move (Pos(".", sValue)) to iPos
29209>>>>>>>        If (iPos <> 0) Begin
29211>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
29212>>>>>>>        End
29212>>>>>>>>
29212>>>>>>>        Else Begin
29213>>>>>>>            Move sValue to iRetval
29214>>>>>>>        End
29214>>>>>>>>
29214>>>>>>>        Function_Return iRetval
29215>>>>>>>    End_Function
29216>>>>>>>
29216>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
29218>>>>>>>        tColumnType RetvalType
29218>>>>>>>        tColumnType RetvalType
29218>>>>>>>        String sValue
29218>>>>>>>        Integer iRetval iPos
29218>>>>>>>
29218>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
29219>>>>>>>        Move RetvalType.sPrecision to sValue
29220>>>>>>>        Move (Pos(".", sValue)) to iPos
29221>>>>>>>        If (iPos = 0) Begin
29223>>>>>>>            Function_Return 0
29224>>>>>>>        End
29224>>>>>>>>
29224>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
29225>>>>>>>
29225>>>>>>>        Function_Return iRetval
29226>>>>>>>    End_Function
29227>>>>>>>
29227>>>>>>>    // * Dummy function for the Studio's Code Explorer *
29227>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
29229>>>>>>>        Function_Return False
29230>>>>>>>    End_Function
29231>>>>>>>
29231>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
29231>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
29233>>>>>>>        Boolean bIsSame
29233>>>>>>>        Integer iCount iSize
29233>>>>>>>
29233>>>>>>>        Move True to bIsSame
29234>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
29235>>>>>>>        Decrement iSize
29236>>>>>>>        For iCount from 0 to iSize
29242>>>>>>>>
29242>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
29243>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
29244>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
29245>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
29246>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
29247>>>>>>>            If (bIsSame = False) Begin
29249>>>>>>>                Function_Return False
29250>>>>>>>            End
29250>>>>>>>>
29250>>>>>>>        Loop
29251>>>>>>>>
29251>>>>>>>
29251>>>>>>>        Function_Return bIsSame
29252>>>>>>>    End_Function
29253>>>>>>>
29253>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
29253>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
29255>>>>>>>        Boolean bIsSame
29255>>>>>>>        Integer iSegment
29255>>>>>>>
29255>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
29256>>>>>>>        If (bIsSame = False) Begin
29258>>>>>>>            Function_Return False
29259>>>>>>>        End
29259>>>>>>>>
29259>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
29260>>>>>>>        If (bIsSame = False) Begin
29262>>>>>>>            Function_Return False
29263>>>>>>>        End
29263>>>>>>>>
29263>>>>>>>
29263>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
29265>>>>>>>            // * We should probably not compare SQL index names?
29265>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
29265>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
29265>>>>>>>            //     Function_Return False
29265>>>>>>>            // End
29265>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
29266>>>>>>>            If (bIsSame = False) Begin
29268>>>>>>>                Function_Return False
29269>>>>>>>            End
29269>>>>>>>>
29269>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
29270>>>>>>>            If (bIsSame = False) Begin
29272>>>>>>>                Function_Return False
29273>>>>>>>            End
29273>>>>>>>>
29273>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
29274>>>>>>>            If (bIsSame = False) Begin
29276>>>>>>>                Function_Return False
29277>>>>>>>            End
29277>>>>>>>>
29277>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
29278>>>>>>>            If (bIsSame = False) Begin
29280>>>>>>>                Function_Return False
29281>>>>>>>            End
29281>>>>>>>>
29281>>>>>>>        End
29281>>>>>>>>
29281>>>>>>>
29281>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
29282>>>>>>>        Move (iSegment = -1) to bIsSame
29283>>>>>>>
29283>>>>>>>        Function_Return (bIsSame = True)
29284>>>>>>>    End_Function
29285>>>>>>>
29285>>>>>>>    // Compares each segment for the passed index.
29285>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
29285>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
29287>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
29287>>>>>>>        Boolean bIsSame
29287>>>>>>>
29287>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
29288>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
29289>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
29290>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
29291>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
29292>>>>>>>
29292>>>>>>>        Decrement iNumSegments
29293>>>>>>>        for iSegment from 0 to iNumSegments
29299>>>>>>>>
29299>>>>>>>            Move False to bIsSame
29300>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
29302>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
29303>>>>>>>            End
29303>>>>>>>>
29303>>>>>>>            If (bIsSame = False) Begin
29305>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
29306>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
29307>>>>>>>                Function_Return iSegment
29308>>>>>>>            End
29308>>>>>>>>
29308>>>>>>>        Loop
29309>>>>>>>>
29309>>>>>>>
29309>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
29310>>>>>>>        Function_Return -1 // This means bIsSame = True
29311>>>>>>>    End_Function
29312>>>>>>>
29312>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
29314>>>>>>>        Boolean bIsSame
29314>>>>>>>
29314>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
29315>>>>>>>        If (bIsSame = False) Begin
29317>>>>>>>            Function_Return False
29318>>>>>>>        End
29318>>>>>>>>
29318>>>>>>>        If (bCompareIndexUppercase = True) Begin
29320>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
29321>>>>>>>            If (bIsSame = False) Begin
29323>>>>>>>                Function_Return False
29324>>>>>>>            End
29324>>>>>>>>
29324>>>>>>>        End
29324>>>>>>>>
29324>>>>>>>        If (bCompareIndexAscending = True) Begin
29326>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
29327>>>>>>>            If (bIsSame = False) Begin
29329>>>>>>>                Function_Return False
29330>>>>>>>            End
29330>>>>>>>>
29330>>>>>>>        End
29330>>>>>>>>
29330>>>>>>>
29330>>>>>>>        Function_Return True
29331>>>>>>>    End_Function
29332>>>>>>>
29332>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
29334>>>>>>>        Boolean bIsSame bOK bExists
29334>>>>>>>        Integer iSize iSizeFrom iSizeTo iCount iIndexSegment
29334>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
29334>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
29335>>>>>>>
29335>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
29336>>>>>>>        If (iSize = 0) Begin
29338>>>>>>>            Function_Return True
29339>>>>>>>        End
29339>>>>>>>>
29339>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
29340>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
29341>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
29342>>>>>>>
29342>>>>>>>        for iCount from 0 to (iSize - 1)
29348>>>>>>>>
29348>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
29349>>>>>>>            If (bIsSame = False) Begin
29351>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
29352>>>>>>>            End
29352>>>>>>>>
29352>>>>>>>        Loop
29353>>>>>>>>
29353>>>>>>>
29353>>>>>>>        // We probably should delete other indexes if they exists.
29353>>>>>>>        for iCount from (iSize +1) to iSizeTo
29359>>>>>>>>
29359>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
29360>>>>>>>        Loop
29361>>>>>>>>
29361>>>>>>>
29361>>>>>>>        Function_Return bOK
29362>>>>>>>    End_Function
29363>>>>>>>
29363>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
29363>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
29363>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
29363>>>>>>>//        String sFieldName sDriverID
29363>>>>>>>//
29363>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
29363>>>>>>>//        If (bIsOpen = False) Begin
29363>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29363>>>>>>>//            Open hTable
29363>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29363>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
29363>>>>>>>//            If (bIsOpen = False) Begin
29363>>>>>>>//                Function_Return False
29363>>>>>>>//            End
29363>>>>>>>//        End
29363>>>>>>>//
29363>>>>>>>//        Move True to bEqual
29363>>>>>>>//        Get psDriverID to sDriverID
29363>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
29363>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
29363>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
29363>>>>>>>//        Decrement iSize
29363>>>>>>>//
29363>>>>>>>//        For iCount from 0 to iSize
29363>>>>>>>//            Move 0 to iOptions
29363>>>>>>>//            Move False to bIdentityKey
29363>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
29363>>>>>>>//
29363>>>>>>>//            // We need to use the column name - not the column integer as
29363>>>>>>>//            // the order does not need to be the same, and the logic should still work.
29363>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
29363>>>>>>>//            If (iColumn > 0) Begin
29363>>>>>>>//                If (bDawSqlDriver = True) Begin
29363>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
29363>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
29363>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
29363>>>>>>>//                        Move False to bEqual
29363>>>>>>>//                    End
29363>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
29363>>>>>>>//                    If (bIdentityKey = True) Begin
29363>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
29363>>>>>>>//                    End
29363>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
29363>>>>>>>//                        Move False to bEqual
29363>>>>>>>//                    End
29363>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
29363>>>>>>>//                End
29363>>>>>>>//                Else Begin
29363>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
29363>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
29363>>>>>>>//                        Move False to bEqual
29363>>>>>>>//                    End
29363>>>>>>>//                End
29363>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
29363>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
29363>>>>>>>//                    Move False to bEqual
29363>>>>>>>//                End
29363>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
29363>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
29363>>>>>>>//                    Move False to bEqual
29363>>>>>>>//                End
29363>>>>>>>//                If (bEqual = False) Begin
29363>>>>>>>//                    Function_Return False
29363>>>>>>>//                End
29363>>>>>>>//            End
29363>>>>>>>//
29363>>>>>>>//            Else Begin
29363>>>>>>>//                Function_Return False
29363>>>>>>>//            End
29363>>>>>>>//        Loop
29363>>>>>>>//
29363>>>>>>>//        Function_Return bEqual
29363>>>>>>>//    End_Function
29363>>>>>>>
29363>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
29365>>>>>>>        tAPIIndex[] APIIndexes
29365>>>>>>>        tAPIIndex[] APIIndexes
29366>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
29366>>>>>>>        String sDriverID
29366>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable bIsSQLPrimaryKey
29366>>>>>>>
29366>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
29367>>>>>>>        Get psDriverID to sDriverID
29368>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
29369>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
29370>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
29373>>>>>>>        If (bIsOpen = False) Begin
29375>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29376>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
29377>>>>>>>            Open hTable
29379>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
29380>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29381>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
29384>>>>>>>            If (bIsOpen = False) Begin
29386>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
29387>>>>>>>                Move True to APIIndexes[0].bError
29388>>>>>>>                Function_Return APIIndexes
29389>>>>>>>            End
29389>>>>>>>>
29389>>>>>>>        End
29389>>>>>>>>
29389>>>>>>>
29389>>>>>>>        Move 0 to iCount
29390>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
29393>>>>>>>        for iIndex from 1 to iIndexes
29399>>>>>>>>
29399>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
29399>>>>>>>            // numbers doesn't not need to be consequitive:
29399>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
29402>>>>>>>            If (iNumSegments > 0) Begin
29404>>>>>>>
29404>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
29405>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
29408>>>>>>>                If (bIsSQLTable = True) Begin
29410>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
29413>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
29416>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
29419>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
29422>>>>>>>                End
29422>>>>>>>>
29422>>>>>>>
29422>>>>>>>                Move 0 to iSegmentCount
29423>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
29426>>>>>>>                For iSegment from 1 to iNumSegments
29432>>>>>>>>
29432>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
29435>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
29436>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
29439>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
29442>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
29445>>>>>>>                    Increment iSegmentCount
29446>>>>>>>                Loop
29447>>>>>>>>
29447>>>>>>>                Increment iCount
29448>>>>>>>            End
29448>>>>>>>>
29448>>>>>>>        Loop
29449>>>>>>>>
29449>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
29450>>>>>>>
29450>>>>>>>        Function_Return APIIndexes
29451>>>>>>>    End_Function
29452>>>>>>>
29452>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
29452>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
29452>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
29452>>>>>>>    // have "holes" in the series of index numbers.
29452>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
29454>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
29454>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
29455>>>>>>>        tAPIIndexCompare   APIIndexCompare
29455>>>>>>>        tAPIIndexCompare   APIIndexCompare
29455>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem iIndexFrom iIndexTo
29455>>>>>>>
29455>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
29456>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
29457>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
29459>>>>>>>            Function_Return aAPIIndexCompare
29460>>>>>>>        End
29460>>>>>>>>
29460>>>>>>>
29460>>>>>>>        Decrement iSizeFrom
29461>>>>>>>        for iCount from 0 to iSizeFrom
29467>>>>>>>>
29467>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
29468>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
29469>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
29470>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
29471>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
29472>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
29473>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
29474>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
29475>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
29476>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
29477>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
29478>>>>>>>        Loop
29479>>>>>>>>
29479>>>>>>>
29479>>>>>>>        Decrement iSizeTo
29480>>>>>>>        for iCount from 0 to iSizeTo
29486>>>>>>>>
29486>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
29487>>>>>>>            // Search if the Index number already exists in the array; else add it.
29487>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
29488>>>>>>>            If (iItem = -1) Begin
29490>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
29491>>>>>>>            End
29491>>>>>>>>
29491>>>>>>>
29491>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
29492>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
29493>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
29494>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
29495>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
29496>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
29497>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
29498>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
29499>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
29500>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
29501>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
29502>>>>>>>        Loop
29503>>>>>>>>
29503>>>>>>>
29503>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
29504>>>>>>>
29504>>>>>>>        Function_Return aAPIIndexCompare
29505>>>>>>>    End_Function
29506>>>>>>>
29506>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
29506>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
29508>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
29508>>>>>>>        String sDriverID
29508>>>>>>>        Integer iSegment
29508>>>>>>>
29508>>>>>>>        Get psDriverID to sDriverID
29509>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
29510>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
29511>>>>>>>        If (bIsSqlTable = True) Begin
29513>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
29514>>>>>>>        End
29514>>>>>>>>
29514>>>>>>>
29514>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
29515>>>>>>>        If (bIsSame = False) Begin
29517>>>>>>>            Function_Return False
29518>>>>>>>        End
29518>>>>>>>>
29518>>>>>>>
29518>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
29520>>>>>>>            // Don't think we should do this. Or should we?
29520>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
29520>>>>>>>
29520>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
29521>>>>>>>            If (bIsSame = False) Begin
29523>>>>>>>                Function_Return False
29524>>>>>>>            End
29524>>>>>>>>
29524>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
29525>>>>>>>            If (bIsSame = False) Begin
29527>>>>>>>                Function_Return False
29528>>>>>>>            End
29528>>>>>>>>
29528>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
29529>>>>>>>            If (bIsSame = False) Begin
29531>>>>>>>                Function_Return False
29532>>>>>>>            End
29532>>>>>>>>
29532>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
29533>>>>>>>            If (bIsSame = False) Begin
29535>>>>>>>                Function_Return False
29536>>>>>>>            End
29536>>>>>>>>
29536>>>>>>>        End
29536>>>>>>>>
29536>>>>>>>
29536>>>>>>>        Function_Return bIsSame
29537>>>>>>>    End_Function
29538>>>>>>>
29538>>>>>>>    // DF_INDEX_SQL_TYPE values
29538>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
29538>>>>>>>    // returns a string with the name.
29538>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
29540>>>>>>>        String sRetval
29540>>>>>>>        Case Begin
29540>>>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
29542>>>>>>>                Move "DF_INDEX_CLIENT" to sRetval
29543>>>>>>>                Case Break
29544>>>>>>>            Case (iIndexType = DF_INDEX_SERVER)
29547>>>>>>>                Move "DF_INDEX_SERVER" to sRetval
29548>>>>>>>                Case Break
29549>>>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
29552>>>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
29553>>>>>>>                Case Break
29554>>>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
29557>>>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
29558>>>>>>>                Case Break
29559>>>>>>>            Case Else
29559>>>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
29560>>>>>>>        Case End
29560>>>>>>>        Function_Return sRetval
29561>>>>>>>    End_Function
29562>>>>>>>
29562>>>>>>>    // * Dummy function for the Studio's Code Explorer *
29562>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
29564>>>>>>>        Function_Return False
29565>>>>>>>    End_Function
29566>>>>>>>
29566>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
29566>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
29568>>>>>>>        Boolean bIsSame
29568>>>>>>>        Integer iSize iCount
29568>>>>>>>
29568>>>>>>>        Move True to bIsSame
29569>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
29570>>>>>>>        Decrement iSize
29571>>>>>>>        For iCount from 0 to iSize
29577>>>>>>>>
29577>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
29578>>>>>>>            If (bIsSame = False) Begin
29580>>>>>>>                Function_Return False
29581>>>>>>>            End
29581>>>>>>>>
29581>>>>>>>        Loop
29582>>>>>>>>
29582>>>>>>>
29582>>>>>>>        Function_Return bIsSame
29583>>>>>>>    End_Function
29584>>>>>>>
29584>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
29584>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
29586>>>>>>>        Boolean bIsSame
29586>>>>>>>
29586>>>>>>>        Move True to bIsSame
29587>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
29589>>>>>>>            Function_Return False
29590>>>>>>>        End
29590>>>>>>>>
29590>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
29592>>>>>>>            Function_Return False
29593>>>>>>>        End
29593>>>>>>>>
29593>>>>>>>
29593>>>>>>>        // We could also compare field names, but I don't think that is necessary...
29593>>>>>>>
29593>>>>>>>        Function_Return bIsSame
29594>>>>>>>    End_Function
29595>>>>>>>
29595>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
29595>>>>>>>    // already exists.
29595>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
29597>>>>>>>        Boolean bIsSame bOK
29597>>>>>>>        Integer iSizeTo iSize iCount iColumn
29597>>>>>>>        String sDriverID
29597>>>>>>>
29597>>>>>>>        Move True to bOK
29598>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
29599>>>>>>>        If (iSizeTo > 0) Begin
29601>>>>>>>            Get AutoConnectionIDLogin to bOK
29602>>>>>>>            Move False to Err
29603>>>>>>>            Open hTable Mode DF_EXCLUSIVE
29605>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
29608>>>>>>>            Decrement iSizeTo
29609>>>>>>>
29609>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
29609>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
29609>>>>>>>            Structure_Start hTable sDriverID
29610>>>>>>>                for iCount from 0 to iSizeTo
29616>>>>>>>>
29616>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
29617>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
29620>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
29623>>>>>>>                Loop
29624>>>>>>>>
29624>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
29625>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
29627>>>>>>>            Set Action_Text of ghoStatusPanel to ""
29628>>>>>>>        End
29628>>>>>>>>
29628>>>>>>>
29628>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
29629>>>>>>>        Decrement iSize
29630>>>>>>>        for iCount from 0 to iSize
29636>>>>>>>>
29636>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
29637>>>>>>>        Loop
29638>>>>>>>>
29638>>>>>>>
29638>>>>>>>        Function_Return bOK
29639>>>>>>>    End_Function
29640>>>>>>>
29640>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
29642>>>>>>>        tAPIRelation[] APIRelations
29642>>>>>>>        tAPIRelation[] APIRelations
29643>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
29643>>>>>>>        Handle hParent
29643>>>>>>>        Boolean bIsOpen
29643>>>>>>>
29643>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
29644>>>>>>>        Move 0 to iCount
29645>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
29648>>>>>>>        If (bIsOpen = False) Begin
29650>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29651>>>>>>>            Open hTable
29653>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
29654>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
29657>>>>>>>            If (bIsOpen = False) Begin
29659>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
29660>>>>>>>                Move True to APIRelations[0].bError
29661>>>>>>>                Function_Return APIRelations
29662>>>>>>>            End
29662>>>>>>>>
29662>>>>>>>        End
29662>>>>>>>>
29662>>>>>>>
29662>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
29665>>>>>>>        For iColumn from 1 to iNumColumns
29671>>>>>>>>
29671>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
29674>>>>>>>            If (hParent <> 0) Begin
29676>>>>>>>                Open hParent
29678>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
29679>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
29682>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
29683>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
29686>>>>>>>
29686>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
29687>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
29690>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
29693>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
29694>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
29697>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
29698>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
29699>>>>>>>                Move False                                              to APIRelations[iCount].bError
29700>>>>>>>                Close hParent
29701>>>>>>>                Increment iCount
29702>>>>>>>            End
29702>>>>>>>>
29702>>>>>>>        Loop
29703>>>>>>>>
29703>>>>>>>
29703>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
29704>>>>>>>        Function_Return APIRelations
29705>>>>>>>    End_Function
29706>>>>>>>
29706>>>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
29708>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
29710>>>>>>>            Function_Return (EQ)
29711>>>>>>>        End
29711>>>>>>>>
29711>>>>>>>
29711>>>>>>>        Function_Return (GT)
29712>>>>>>>    End_Function
29713>>>>>>>
29713>>>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
29715>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
29718>>>>>>>
29718>>>>>>>        Function_Return (GT)
29719>>>>>>>    End_Function
29720>>>>>>>
29720>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
29720>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
29720>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
29722>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
29722>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
29723>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
29723>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
29724>>>>>>>        tAPIRelationCompare   APIRelationCompare
29724>>>>>>>        tAPIRelationCompare   APIRelationCompare
29724>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
29724>>>>>>>
29724>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
29725>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
29726>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
29728>>>>>>>            Function_Return aAPIRelationCompare
29729>>>>>>>        End
29729>>>>>>>>
29729>>>>>>>
29729>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
29730>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
29731>>>>>>>
29731>>>>>>>        Decrement iSizeFrom
29732>>>>>>>        for iCount from 0 to iSizeFrom
29738>>>>>>>>
29738>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
29739>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
29740>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
29741>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
29742>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
29743>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
29744>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
29745>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
29746>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
29747>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
29748>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
29749>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
29750>>>>>>>        Loop
29751>>>>>>>>
29751>>>>>>>
29751>>>>>>>        Decrement iSizeTo
29752>>>>>>>        for iCount from 0 to iSizeTo
29758>>>>>>>>
29758>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
29759>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
29760>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
29761>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
29762>>>>>>>
29762>>>>>>>            // Search if the relation already exists in the array; else add it.
29762>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
29763>>>>>>>            If (iItem = -1) Begin
29765>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
29766>>>>>>>            End
29766>>>>>>>>
29766>>>>>>>
29766>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
29767>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
29768>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
29769>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
29770>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
29771>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
29772>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
29773>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
29774>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
29775>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
29776>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
29777>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
29778>>>>>>>        Loop
29779>>>>>>>>
29779>>>>>>>
29779>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
29780>>>>>>>
29780>>>>>>>        Function_Return aAPIRelationCompare
29781>>>>>>>    End_Function
29782>>>>>>>
29782>>>>>>>    // * Dummy function for the Studio's Code Explorer *
29782>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
29784>>>>>>>        Function_Return False
29785>>>>>>>    End_Function
29786>>>>>>>
29786>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
29786>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
29786>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
29786>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
29788>>>>>>>        Boolean bFound
29788>>>>>>>
29788>>>>>>>        Move False to Err
29789>>>>>>>        Open CodeMast
29791>>>>>>>        Open CodeType
29793>>>>>>>
29793>>>>>>>        If (bCodeType = True) Begin
29795>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
29796>>>>>>>            Clear CodeType
29797>>>>>>>            Move sTypeValue to CODETYPE.Type
29798>>>>>>>            Find eq CODETYPE by 1
29799>>>>>>>>
29799>>>>>>>            Move Found to bFound
29800>>>>>>>            If (bFound = True) Begin
29802>>>>>>>                Reread CodeType
29806>>>>>>>            End
29806>>>>>>>>
29806>>>>>>>            Else Begin
29807>>>>>>>                Clear CodeType
29808>>>>>>>            End
29808>>>>>>>>
29808>>>>>>>
29808>>>>>>>            Move sTypeValue to CODETYPE.Type
29809>>>>>>>            Move sValue2    to CODETYPE.Description
29810>>>>>>>            Move sValue3    to CODETYPE.Comment
29811>>>>>>>            SaveRecord CODETYPE
29812>>>>>>>
29812>>>>>>>            If (bFound = True) Begin
29814>>>>>>>                Unlock
29815>>>>>>>>
29815>>>>>>>            End
29815>>>>>>>>
29815>>>>>>>        End
29815>>>>>>>>
29815>>>>>>>
29815>>>>>>>        If (bCodeType = False) Begin
29817>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
29818>>>>>>>            Clear CODEMAST
29819>>>>>>>            Move sTypeValue to CODEMAST.Type
29820>>>>>>>            Move sValue2    to CODEMAST.Code
29821>>>>>>>            Find eq CODEMAST by 1
29822>>>>>>>>
29822>>>>>>>            Move Found to bFound
29823>>>>>>>            If (bFound = True) Begin
29825>>>>>>>                Reread CODEMAST
29829>>>>>>>            End
29829>>>>>>>>
29829>>>>>>>            Else Begin
29830>>>>>>>                Clear CODEMAST
29831>>>>>>>            End
29831>>>>>>>>
29831>>>>>>>
29831>>>>>>>            Move sTypeValue to CODEMAST.Type
29832>>>>>>>            Move sValue2    to CODEMAST.Code
29833>>>>>>>            Move sValue3    to CODEMAST.Description
29834>>>>>>>            SaveRecord CODEMAST
29835>>>>>>>
29835>>>>>>>            If (bFound = True) Begin
29837>>>>>>>                Unlock
29838>>>>>>>>
29838>>>>>>>            End
29838>>>>>>>>
29838>>>>>>>        End
29838>>>>>>>>
29838>>>>>>>
29838>>>>>>>        Close CodeMast
29839>>>>>>>        Close CodeType
29840>>>>>>>
29840>>>>>>>        Function_Return (Err = False)
29841>>>>>>>    End_Function
29842>>>>>>>
29842>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
29842>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
29842>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
29844>>>>>>>        Boolean bFound
29844>>>>>>>
29844>>>>>>>        Move False to Err
29845>>>>>>>        Open CodeMast
29847>>>>>>>        Open CodeType
29849>>>>>>>
29849>>>>>>>        Clear CodeType
29850>>>>>>>        Move sFromValue to CODETYPE.Type
29851>>>>>>>        Find eq CODETYPE.Type
29852>>>>>>>>
29852>>>>>>>        If (Found = True) Begin
29854>>>>>>>            Reread CODETYPE
29858>>>>>>>                Move sToValue to CODETYPE.Type
29859>>>>>>>                SaveRecord CODETYPE
29860>>>>>>>            Unlock
29861>>>>>>>>
29861>>>>>>>        End
29861>>>>>>>>
29861>>>>>>>
29861>>>>>>>        Clear CODEMAST
29862>>>>>>>        Find gt CODEMAST by Recnum
29863>>>>>>>>
29863>>>>>>>        While (Found = True)
29867>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
29868>>>>>>>            If (bFound = True) Begin
29870>>>>>>>                Reread CODEMAST
29874>>>>>>>                    Move sToValue to CODEMAST.Type
29875>>>>>>>                    SaveRecord CODEMAST
29876>>>>>>>                Unlock
29877>>>>>>>>
29877>>>>>>>            End
29877>>>>>>>>
29877>>>>>>>            Find gt CODEMAST by Recnum
29878>>>>>>>>
29878>>>>>>>        Loop
29879>>>>>>>>
29879>>>>>>>
29879>>>>>>>        Close CodeMast
29880>>>>>>>        Close CodeType
29881>>>>>>>
29881>>>>>>>        Function_Return (Err = False)
29882>>>>>>>    End_Function
29883>>>>>>>
29883>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
29883>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
29885>>>>>>>        Boolean bFound
29885>>>>>>>
29885>>>>>>>        Move False to Err
29886>>>>>>>        Open CodeMast
29888>>>>>>>
29888>>>>>>>        Clear CODEMAST
29889>>>>>>>        Move sTypeValue to CODEMAST.Type
29890>>>>>>>        Move sValue2    to CODEMAST.Code
29891>>>>>>>        Find eq CODEMAST.Code
29892>>>>>>>>
29892>>>>>>>        Move Found to bFound
29893>>>>>>>        If (bFound = True) Begin
29895>>>>>>>            Delete CODEMAST
29896>>>>>>>        End
29896>>>>>>>>
29896>>>>>>>
29896>>>>>>>        Close CodeMast
29897>>>>>>>
29897>>>>>>>        Function_Return (Err = False)
29898>>>>>>>    End_Function
29899>>>>>>>
29899>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
29901>>>>>>>        Boolean bRecnum bToAnsi
29901>>>>>>>        Integer iCh
29901>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
29901>>>>>>>
29901>>>>>>>        If (Trim(sDataPath) = "") Begin
29903>>>>>>>            Function_Return False
29904>>>>>>>        End
29904>>>>>>>>
29904>>>>>>>
29904>>>>>>>        Move False to Err
29905>>>>>>>        Get psDriverID     to sDriverID
29906>>>>>>>        Get psConnectionID to sConnectionID
29907>>>>>>>        Get psSchema       to sSchemaName
29908>>>>>>>        Get True           to bRecnum
29909>>>>>>>        Get pbToANSI       to bToAnsi
29910>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
29911>>>>>>>        If (bToAnsi = False) Begin
29913>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
29914>>>>>>>        End
29914>>>>>>>>
29914>>>>>>>
29914>>>>>>>        Get vFolderFormat sDataPath to sDataPath
29915>>>>>>>        Move "CodeMast.int"         to sFileName
29916>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
29917>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
29920>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
29923>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
29926>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
29929>>>>>>>            Writeln channel iCh ("")
29932>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
29935>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
29938>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
29941>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
29944>>>>>>>            Writeln channel iCh ("")
29947>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
29950>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
29953>>>>>>>            Writeln channel iCh ("")
29956>>>>>>>        Send Seq_Close_Channel iCh
29957>>>>>>>
29957>>>>>>>        Get vFolderFormat sDataPath to sDataPath
29958>>>>>>>        Move "CodeType.int"         to sFileName
29959>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
29960>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
29963>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
29966>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
29969>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
29972>>>>>>>            Writeln channel iCh ("")
29975>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
29978>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
29981>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
29984>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
29987>>>>>>>            Writeln channel iCh ("")
29990>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
29993>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
29996>>>>>>>            Writeln channel iCh ("")
29999>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
30002>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
30005>>>>>>>            Writeln channel iCh ("")
30008>>>>>>>        Send Seq_Close_Channel iCh
30009>>>>>>>
30009>>>>>>>        Function_Return (Err = False)
30010>>>>>>>    End_Function
30011>>>>>>>
30011>>>>>>>    // * Dummy function for the Studio's Code Explorer *
30011>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
30013>>>>>>>        Function_Return False
30014>>>>>>>    End_Function
30015>>>>>>>
30015>>>>>>>    // Check if the file exists in the Data folder,
30015>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
30015>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
30017>>>>>>>        String sPath sDataPath
30017>>>>>>>        Boolean bExists
30017>>>>>>>
30017>>>>>>>        Get psDataPathFirstPart to sPath
30018>>>>>>>        Move (sPath + sFileName) to sFileName
30019>>>>>>>        Get vFilePathExists sFileName to bExists
30020>>>>>>>
30020>>>>>>>        If (bExists = False) Begin
30022>>>>>>>            // Read from memory & create file on disk.
30022>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
30023>>>>>>>            Get vFilePathExists sFileName to bExists
30024>>>>>>>        End
30024>>>>>>>>
30024>>>>>>>        Function_Return bExists
30025>>>>>>>    End_Function
30026>>>>>>>
30026>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
30028>>>>>>>        tColumnType RetvalType
30028>>>>>>>        tColumnType RetvalType
30028>>>>>>>        Integer iRetval
30028>>>>>>>
30028>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
30029>>>>>>>        Move RetvalType.iDataFlexType to iRetval
30030>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
30032>>>>>>>            If (iLength <= 255) Begin
30034>>>>>>>                Move DF_ASCII to iRetval
30035>>>>>>>            End
30035>>>>>>>>
30035>>>>>>>        End
30035>>>>>>>>
30035>>>>>>>        Function_Return iRetval
30036>>>>>>>    End_Function
30037>>>>>>>
30037>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
30039>>>>>>>        String sRetval
30039>>>>>>>
30039>>>>>>>        Case Begin
30039>>>>>>>            Case (iDataType = DF_ASCII)
30041>>>>>>>                Move "DF_ASCII" to sRetval
30042>>>>>>>                Case Break
30043>>>>>>>            Case (iDataType = DF_BCD)
30046>>>>>>>                Move "DF_BCD" to sRetval
30047>>>>>>>                Case Break
30048>>>>>>>            Case (iDataType = DF_BINARY)
30051>>>>>>>                Move "DF_BINARY" to sRetval
30052>>>>>>>                Case Break
30053>>>>>>>            Case (iDataType = DF_DATE)
30056>>>>>>>                Move "DF_DATE" to sRetval
30057>>>>>>>                Case Break
30058>>>>>>>            Case (iDataType = DF_DATETIME)
30061>>>>>>>                Move "DF_DATETIME" to sRetval
30062>>>>>>>                Case Break
30063>>>>>>>            Case (iDataType = DF_TEXT)
30066>>>>>>>                Move "DF_TEXT" to sRetval
30067>>>>>>>                Case Break
30068>>>>>>>            Case Else
30068>>>>>>>                Move "" to sRetval
30069>>>>>>>        Case End
30069>>>>>>>
30069>>>>>>>        Function_Return sRetval
30070>>>>>>>    End_Function
30071>>>>>>>
30071>>>>>>>    // The default value used for a datatype as specified in the driver int file.
30071>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
30073>>>>>>>        String sRetval sServer
30073>>>>>>>        tColumnType RetvalType
30073>>>>>>>        tColumnType RetvalType
30073>>>>>>>        Integer iDriver iDataFlexType
30073>>>>>>>        Handle hDatabase
30073>>>>>>>
30073>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
30074>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
30075>>>>>>>        Get DriverIndex sDriverID to iDriver
30076>>>>>>>        Get psServer to sServer
30077>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
30078>>>>>>>        If (hDatabase = 0) Begin
30080>>>>>>>            Function_Return ""
30081>>>>>>>        End
30081>>>>>>>>
30081>>>>>>>
30081>>>>>>>        Case Begin
30081>>>>>>>            Case (iDataFlexType = DF_ASCII)
30083>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
30086>>>>>>>                Case Break
30087>>>>>>>            Case (iDataFlexType = DF_BCD)
30090>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
30093>>>>>>>                Case Break
30094>>>>>>>            Case (iDataFlexType = DF_BINARY)
30097>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
30100>>>>>>>                Case Break
30101>>>>>>>            Case (iDataFlexType = DF_DATE)
30104>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
30107>>>>>>>                Case Break
30108>>>>>>>            Case (iDataFlexType = DF_DATETIME)
30111>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
30114>>>>>>>                Case Break
30115>>>>>>>            Case (iDataFlexType = DF_TEXT)
30118>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
30121>>>>>>>                Case Break
30122>>>>>>>            Case Else
30122>>>>>>>                Move "" to sRetval
30123>>>>>>>        Case End
30123>>>>>>>
30123>>>>>>>        Function_Return sRetval
30124>>>>>>>    End_Function
30125>>>>>>>
30125>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
30127>>>>>>>        String sDriverID sServer
30127>>>>>>>        tColumnType RetvalType
30127>>>>>>>        tColumnType RetvalType
30127>>>>>>>        Integer iDbType iDriver
30127>>>>>>>        Handle hDatabase
30127>>>>>>>
30127>>>>>>>        Get psDriverID to sDriverID
30128>>>>>>>        Get piDbType   to iDbType
30129>>>>>>>        Get DriverIndex sDriverID to iDriver
30130>>>>>>>        Get psServer to sServer
30131>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
30132>>>>>>>        If (hDatabase = 0) Begin
30134>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
30135>>>>>>>>
30135>>>>>>>            Procedure_Return
30136>>>>>>>        End
30136>>>>>>>>
30136>>>>>>>
30136>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
30139>>>>>>>
30139>>>>>>>    End_Procedure
30140>>>>>>>
30140>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
30142>>>>>>>        String sDriverID sServer
30142>>>>>>>        tColumnType RetvalType
30142>>>>>>>        tColumnType RetvalType
30142>>>>>>>        Integer iDbType iDriver
30142>>>>>>>        Handle hDatabase
30142>>>>>>>
30142>>>>>>>        Get psDriverID to sDriverID
30143>>>>>>>        Get piDbType   to iDbType
30144>>>>>>>        Get DriverIndex sDriverID to iDriver
30145>>>>>>>        Get psServer to sServer
30146>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
30147>>>>>>>        If (hDatabase = 0) Begin
30149>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
30150>>>>>>>>
30150>>>>>>>            Procedure_Return
30151>>>>>>>        End
30151>>>>>>>>
30151>>>>>>>
30151>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
30154>>>>>>>
30154>>>>>>>    End_Procedure
30155>>>>>>>
30155>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
30155>>>>>>>    // are mapped to the standard DataFlex data types.
30155>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
30155>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
30157>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
30157>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
30159>>>>>>>        String sDataType
30159>>>>>>>        Integer iDataType iDriverID iCount
30159>>>>>>>        Boolean bSQLDriver
30159>>>>>>>
30159>>>>>>>        Move 0 to iCount
30160>>>>>>>        Get DriverIndex sDriverID to iDriverID
30161>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
30162>>>>>>>        If (bSQLDriver = False) Begin
30164>>>>>>>            Function_Return EmptyArray
30165>>>>>>>        End
30165>>>>>>>>
30165>>>>>>>
30165>>>>>>>        // DF_ASCII
30165>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
30167>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
30170>>>>>>>        End
30170>>>>>>>>
30170>>>>>>>        Else Begin
30171>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
30174>>>>>>>        End
30174>>>>>>>>
30174>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
30175>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
30176>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
30177>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
30178>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
30179>>>>>>>        Increment iCount
30180>>>>>>>
30180>>>>>>>        // DF_BINARY
30180>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
30182>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
30185>>>>>>>        End
30185>>>>>>>>
30185>>>>>>>        Else Begin
30186>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
30189>>>>>>>        End
30189>>>>>>>>
30189>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
30190>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
30191>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
30192>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
30193>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
30194>>>>>>>        Increment iCount
30195>>>>>>>
30195>>>>>>>        // DF_DATE
30195>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
30197>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
30200>>>>>>>        End
30200>>>>>>>>
30200>>>>>>>        Else Begin
30201>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
30204>>>>>>>        End
30204>>>>>>>>
30204>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
30205>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
30206>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
30207>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
30208>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
30209>>>>>>>        Increment iCount
30210>>>>>>>
30210>>>>>>>        // DF_DATETIME
30210>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
30212>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
30215>>>>>>>        End
30215>>>>>>>>
30215>>>>>>>        Else Begin
30216>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
30219>>>>>>>        End
30219>>>>>>>>
30219>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
30220>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
30221>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
30222>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
30223>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
30224>>>>>>>        Increment iCount
30225>>>>>>>
30225>>>>>>>        // DF_NUMERIC
30225>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
30225>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
30225>>>>>>>        // we make them here all "Numeric"...
30225>>>>>>>        Case Begin
30225>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
30227>>>>>>>                Move SQL_NUMERIC to iDataType
30228>>>>>>>                Move "numeric"   to sDataType
30229>>>>>>>                Case Break
30230>>>>>>>            Case (sDriverID = DB2_DRV_ID)
30233>>>>>>>                Move SQL_NUMERIC to iDataType
30234>>>>>>>                Move "NUMERIC"   to sDataType
30235>>>>>>>                Case Break
30236>>>>>>>            Case (sDriverID = SQLFLEX)
30239>>>>>>>                Move eSQLServer_NUMERIC to iDataType
30240>>>>>>>                Move "numeric"   to sDataType
30241>>>>>>>                Case Break
30242>>>>>>>            Case (sDriverID = MDSMySQL)
30245>>>>>>>                Move eMySQL_DECIMAL to iDataType
30246>>>>>>>                Move "decimal"   to sDataType
30247>>>>>>>                Case Break
30248>>>>>>>            Case (sDriverID = ORAFLEX)
30251>>>>>>>                Move eOracle_NUMBER to iDataType
30252>>>>>>>                Move "NUMBER"   to sDataType
30253>>>>>>>                Case Break
30254>>>>>>>            Case (sDriverID = MDSPgSQL)
30257>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
30258>>>>>>>                Move "decimal"   to sDataType
30259>>>>>>>                Case Break
30260>>>>>>>            Case Else
30260>>>>>>>                Move DF_BCD      to iDataType
30261>>>>>>>                Move "Numeric"   to sDataType
30262>>>>>>>        Case End
30262>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
30263>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
30264>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
30265>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
30266>>>>>>>        Increment iCount
30267>>>>>>>
30267>>>>>>>        // DF_TEXT
30267>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
30269>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
30272>>>>>>>        End
30272>>>>>>>>
30272>>>>>>>        Else Begin
30273>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
30276>>>>>>>        End
30276>>>>>>>>
30276>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
30277>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
30278>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
30279>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
30280>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
30281>>>>>>>
30281>>>>>>>        Function_Return ColumnTypeArray
30282>>>>>>>    End_Function
30283>>>>>>>
30283>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
30285>>>>>>>        tColumnType[] ColumnTypeArray
30285>>>>>>>        tColumnType[] ColumnTypeArray
30286>>>>>>>        tColumnType   ColumnType
30286>>>>>>>        tColumnType   ColumnType
30286>>>>>>>        Integer iCount iSize
30286>>>>>>>
30286>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
30287>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
30288>>>>>>>        Decrement iSize
30289>>>>>>>
30289>>>>>>>        for iCount from 0 to iSize
30295>>>>>>>>
30295>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
30297>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
30298>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
30299>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
30300>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
30301>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
30302>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
30303>>>>>>>                Move iSize to iCount
30304>>>>>>>            End
30304>>>>>>>>
30304>>>>>>>        Loop
30305>>>>>>>>
30305>>>>>>>
30305>>>>>>>        Function_Return ColumnType
30306>>>>>>>    End_Function
30307>>>>>>>
30307>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
30307>>>>>>>    // are mapped to a DUF data type.
30307>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
30309>>>>>>>        tColumnType ColumnType
30309>>>>>>>        tColumnType ColumnType
30309>>>>>>>        String sDataType
30309>>>>>>>        Integer iDriverID iCount
30309>>>>>>>
30309>>>>>>>        Move 0 to iCount
30310>>>>>>>        Get DriverIndex sDriverID to iDriverID
30311>>>>>>>
30311>>>>>>>        Case Begin
30311>>>>>>>            // DF_ASCII
30311>>>>>>>            Case (iType = DF_ASCII_DUF)
30313>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30315>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
30318>>>>>>>                End
30318>>>>>>>>
30318>>>>>>>                Else Begin
30319>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
30322>>>>>>>                End
30322>>>>>>>>
30322>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
30323>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
30324>>>>>>>                Move sDataType   to ColumnType.sSQLType
30325>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
30326>>>>>>>                Move False       to ColumnType.bCanEditSize
30327>>>>>>>                Case Break
30328>>>>>>>
30328>>>>>>>            // DF_BINARY
30328>>>>>>>            Case (iType = DF_BINARY_DUF)
30331>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30333>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
30336>>>>>>>                End
30336>>>>>>>>
30336>>>>>>>                Else Begin
30337>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
30340>>>>>>>                End
30340>>>>>>>>
30340>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
30341>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
30342>>>>>>>                Move sDataType   to ColumnType.sSQLType
30343>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
30344>>>>>>>                Move False       to ColumnType.bCanEditSize
30345>>>>>>>                Case Break
30346>>>>>>>
30346>>>>>>>            // DF_DATE
30346>>>>>>>            Case (iType = DF_DATE_DUF)
30349>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30351>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
30354>>>>>>>                End
30354>>>>>>>>
30354>>>>>>>                Else Begin
30355>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
30358>>>>>>>                End
30358>>>>>>>>
30358>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
30359>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
30360>>>>>>>                Move sDataType   to ColumnType.sSQLType
30361>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
30362>>>>>>>                Move True        to ColumnType.bCanEditSize
30363>>>>>>>                Case Break
30364>>>>>>>
30364>>>>>>>            // DF_DATETIME
30364>>>>>>>            Case (iType = DF_DATETIME_DUF)
30367>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30369>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
30372>>>>>>>                End
30372>>>>>>>>
30372>>>>>>>                Else Begin
30373>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
30376>>>>>>>                End
30376>>>>>>>>
30376>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
30377>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
30378>>>>>>>                Move sDataType   to ColumnType.sSQLType
30379>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
30380>>>>>>>                Move True        to ColumnType.bCanEditSize
30381>>>>>>>                Case Break
30382>>>>>>>
30382>>>>>>>            // DF_NUMERIC
30382>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
30382>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
30382>>>>>>>            // we make them here all "Numeric"...
30382>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
30382>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
30382>>>>>>>            // End
30382>>>>>>>            // Else Begin
30382>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
30382>>>>>>>            // End
30382>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
30382>>>>>>>            Case (iType = DF_BCD_DUF)
30385>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
30386>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
30387>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
30388>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
30389>>>>>>>                Move False       to ColumnType.bCanEditSize
30390>>>>>>>                Case Break
30391>>>>>>>
30391>>>>>>>            // DF_TEXT
30391>>>>>>>            Case (iType = DF_TEXT_DUF)
30394>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
30396>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
30399>>>>>>>                End
30399>>>>>>>>
30399>>>>>>>                Else Begin
30400>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
30403>>>>>>>                End
30403>>>>>>>>
30403>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
30404>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
30405>>>>>>>                Move sDataType   to ColumnType.sSQLType
30406>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
30407>>>>>>>                Move False       to ColumnType.bCanEditSize
30408>>>>>>>                Case Break
30409>>>>>>>
30409>>>>>>>            Case Else
30409>>>>>>>                Move -1999       to ColumnType.iDataFlexType
30410>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
30411>>>>>>>                Move "Undefined" to ColumnType.sSQLType
30412>>>>>>>                Move -1999       to ColumnType.iSQLType
30413>>>>>>>                Move True        to ColumnType.bCanEditSize
30414>>>>>>>
30414>>>>>>>        Case End
30414>>>>>>>
30414>>>>>>>        Function_Return ColumnType
30415>>>>>>>    End_Function
30416>>>>>>>
30416>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
30418>>>>>>>        String sDataPath sDriverID
30418>>>>>>>        Boolean bMertechDriver bOK
30418>>>>>>>        Integer iPos
30418>>>>>>>
30418>>>>>>>        If (sTableName contains ".") Begin
30420>>>>>>>            Move (Pos(".", sTableName)) to iPos
30421>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
30422>>>>>>>        End
30422>>>>>>>>
30422>>>>>>>
30422>>>>>>>        Get psDriverID to sDriverID
30423>>>>>>>        Get psDataPathFirstPart to sDataPath
30424>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
30425>>>>>>>        // First delete the cache file:
30425>>>>>>>        If (bMertechDriver = False) Begin
30427>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
30428>>>>>>>        End
30428>>>>>>>>
30428>>>>>>>        Else Begin
30429>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
30430>>>>>>>        End
30430>>>>>>>>
30430>>>>>>>
30430>>>>>>>        Function_Return bOK
30431>>>>>>>    End_Function
30432>>>>>>>
30432>>>>>>>    // Changes source code files.
30432>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
30432>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
30432>>>>>>>    // to use a Connection ID.
30432>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
30432>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
30432>>>>>>>    // Returns True if no errors occured.
30432>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
30434>>>>>>>        Integer iCh iRow iItems iCount
30434>>>>>>>        String sValue sRow
30434>>>>>>>        String[] sFileArray
30435>>>>>>>        Boolean bExists bIsActive
30435>>>>>>>
30435>>>>>>>        Move False to Err
30436>>>>>>>        Move 0 to iRow
30437>>>>>>>
30437>>>>>>>        If (ghoStatusPanel <> 0) Begin
30439>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
30440>>>>>>>        End
30440>>>>>>>>
30440>>>>>>>
30440>>>>>>>        Get vFilePathExists sFileName to bExists
30441>>>>>>>        If (bExists = False) Begin
30443>>>>>>>            If (bShowResult = True) Begin
30445>>>>>>>                If (bIsActive = True) Begin
30447>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
30448>>>>>>>                End
30448>>>>>>>>
30448>>>>>>>                Else Begin
30449>>>>>>>                    Showln "File does not exist: " sFileName
30452>>>>>>>                End
30452>>>>>>>>
30452>>>>>>>            End
30452>>>>>>>>
30452>>>>>>>            Function_Return False
30453>>>>>>>        End
30453>>>>>>>>
30453>>>>>>>
30453>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
30454>>>>>>>        If (iCh < 1) Begin
30456>>>>>>>            Function_Return False
30457>>>>>>>        End
30457>>>>>>>>
30457>>>>>>>
30457>>>>>>>        If (bShowResult = True) Begin
30459>>>>>>>            If (ghoStatusPanel <> 0) Begin
30461>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
30462>>>>>>>                If (bIsActive = True) Begin
30464>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
30465>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
30466>>>>>>>                    Send DoAdvance of ghoProgressBar
30467>>>>>>>                End
30467>>>>>>>>
30467>>>>>>>            End
30467>>>>>>>>
30467>>>>>>>            Else Begin
30468>>>>>>>                Showln ""
30470>>>>>>>                Showln "sFileName = " sFileName
30473>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
30478>>>>>>>            End
30478>>>>>>>>
30478>>>>>>>        End
30478>>>>>>>>
30478>>>>>>>
30478>>>>>>>        While (not(SeqEof))
30482>>>>>>>            Readln channel iCh sRow
30484>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
30486>>>>>>>//                If (bShowResult = True) Begin
30486>>>>>>>//                    If (bIsActive = True) Begin
30486>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
30486>>>>>>>//                    End
30486>>>>>>>//                    Else Begin
30486>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
30486>>>>>>>//                    End
30486>>>>>>>//                End
30486>>>>>>>                // Change the whole line to the new connection id:
30486>>>>>>>                Move sChangeTo to sRow
30487>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
30487>>>>>>>            End
30487>>>>>>>>
30487>>>>>>>            Move sRow to sFileArray[iRow]
30488>>>>>>>            Increment iRow
30489>>>>>>>        Loop
30490>>>>>>>>
30490>>>>>>>        Send Seq_Close_Channel iCh
30491>>>>>>>
30491>>>>>>>        Sleep 1 // Wait for Windows to close the file
30492>>>>>>>
30492>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
30493>>>>>>>        If (iCh < 1) Begin
30495>>>>>>>            Function_Return False
30496>>>>>>>        End
30496>>>>>>>>
30496>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
30497>>>>>>>        Decrement iItems
30498>>>>>>>
30498>>>>>>>        For iCount from 0 to iItems
30504>>>>>>>>
30504>>>>>>>            Move sFileArray[iCount] to sValue
30505>>>>>>>            Writeln channel iCh sValue
30508>>>>>>>        Loop
30509>>>>>>>>
30509>>>>>>>        Send Seq_Close_Channel iCh
30510>>>>>>>
30510>>>>>>>        Function_Return (Err = False)
30511>>>>>>>    End_Function
30512>>>>>>>
30512>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
30514>>>>>>>        Integer iRetval
30514>>>>>>>        Move 1 to iRetval
30515>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
30517>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
30518>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
30519>>>>>>>        End
30519>>>>>>>>
30519>>>>>>>        Function_Return (iRetval = 0)
30520>>>>>>>    End_Function
30521>>>>>>>
30521>>>>>>>    // *** DEPRECIATED ***
30521>>>>>>>    // Use the AutoSetConnectionID function instead.
30521>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
30521>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
30521>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
30521>>>>>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
30521>>>>>>>//        String sConnectionString sDriverID
30521>>>>>>>//        Boolean bOK bSilent bDawDriver
30521>>>>>>>//        Handle hoCLI
30521>>>>>>>//
30521>>>>>>>//        Move False to bOK
30521>>>>>>>//        Get psDriverID to sDriverID
30521>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
30521>>>>>>>//        If (bDawDriver = False) Begin
30521>>>>>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
30521>>>>>>>//            Function_Return False
30521>>>>>>>//        End
30521>>>>>>>//
30521>>>>>>>//        Get psConnectionString to sConnectionString
30521>>>>>>>//        Get pbSilentLogin      to bSilent
30521>>>>>>>//
30521>>>>>>>//        Get phoCLIHandler to hoCLI
30521>>>>>>>//        If (hoCLI <> 0) Begin
30521>>>>>>>//            Set psDriverID of hoCLI to sDriverID
30521>>>>>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
30521>>>>>>>//        End
30521>>>>>>>//
30521>>>>>>>//        Function_Return (bOK = False)
30521>>>>>>>//    End_Function
30521>>>>>>>
30521>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
30521>>>>>>>    // and opens it in "notepad.exe".
30521>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
30521>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
30521>>>>>>>    Procedure UtilShowErrorList
30523>>>>>>>        tSqlErrorArray aSqlErrorArray
30523>>>>>>>        tSqlErrorArray aSqlErrorArray
30523>>>>>>>        Integer iRows iCount iCh iErrorNum
30523>>>>>>>        String sPath sFileName sErrorTxt sStatement
30523>>>>>>>
30523>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
30524>>>>>>>        Get vFolderFormat sPath to sPath
30525>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
30526>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
30527>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
30528>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
30529>>>>>>>            If (iRows > 0) Begin
30531>>>>>>>                Decrement iRows
30532>>>>>>>                for iCount from 0 to iRows
30538>>>>>>>>
30538>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
30539>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
30540>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
30541>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
30547>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
30551>>>>>>>                Loop
30552>>>>>>>>
30552>>>>>>>            End
30552>>>>>>>>
30552>>>>>>>        Send Seq_Close_Channel iCh
30553>>>>>>>
30553>>>>>>>        If (iRows > 0) Begin
30555>>>>>>>            Runprogram Shell Background (sPath + sFileName)
30556>>>>>>>        End
30556>>>>>>>>
30556>>>>>>>    End_Procedure
30557>>>>>>>
30557>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
30557>>>>>>>    // and the table needs to exist as an SQL table.
30557>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
30559>>>>>>>        String sRootName sDriverID
30559>>>>>>>        Boolean bIsSQL
30559>>>>>>>
30559>>>>>>>        Move False to bIsSQL
30560>>>>>>>        If (hTable > 0) Begin
30562>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
30565>>>>>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
30566>>>>>>>            If (bIsSQL = True) Begin
30568>>>>>>>                Get psDriverID to sDriverID
30569>>>>>>>                Get _TableNameOnly sRootName to sRootName
30570>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
30571>>>>>>>            End
30571>>>>>>>>
30571>>>>>>>        End
30571>>>>>>>>
30571>>>>>>>
30571>>>>>>>        Function_Return bIsSQL
30572>>>>>>>    End_Function
30573>>>>>>>
30573>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
30575>>>>>>>        Boolean bIsSQL
30575>>>>>>>        Move (sRootName contains ":") to bIsSQL
30576>>>>>>>        Function_Return bIsSQL
30577>>>>>>>    End_Function
30578>>>>>>>
30578>>>>>>>
30578>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
30578>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
30578>>>>>>>    // but the Logical name is different.
30578>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
30578>>>>>>>//    Function UtilTableIsAlias Handle hTable Returns Boolean
30578>>>>>>>//        String sPhysicalName sPhysicalNameCompare
30578>>>>>>>//        Boolean bWasOpen bOpened bOK
30578>>>>>>>//        Integer iCount
30578>>>>>>>//
30578>>>>>>>//        Move 0 to iCount
30578>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bWasOpen
30578>>>>>>>//        If (bWasOpen = False) Begin
30578>>>>>>>//            Open hTable
30578>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpened
30578>>>>>>>//            If (bOpened = False) Begin
30578>>>>>>>//                Function_Return False
30578>>>>>>>//            End
30578>>>>>>>//        End
30578>>>>>>>//
30578>>>>>>>//        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
30578>>>>>>>//        Get _TableNameOnly sPhysicalName to sPhysicalName
30578>>>>>>>//        If (bWasOpen = False and bOpened = True) Begin
30578>>>>>>>//            Close hTable
30578>>>>>>>//        End
30578>>>>>>>//
30578>>>>>>>//        Move 0 to hTable
30578>>>>>>>//        Repeat
30578>>>>>>>//            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
30578>>>>>>>//            If (hTable > 0 and hTable <> 50) Begin
30578>>>>>>>//                Open hTable
30578>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bOpened
30578>>>>>>>//                If (bOpened = True) Begin
30578>>>>>>>//                    Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalNameCompare
30578>>>>>>>//                    Close hTable
30578>>>>>>>//                    Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
30578>>>>>>>//                    If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
30578>>>>>>>//                        Increment iCount
30578>>>>>>>//                    End
30578>>>>>>>//                End
30578>>>>>>>//            End
30578>>>>>>>//        Until (hTable = 0)
30578>>>>>>>//
30578>>>>>>>//        If (iCount > 1) Begin
30578>>>>>>>//            Function_Return True
30578>>>>>>>//        End
30578>>>>>>>//
30578>>>>>>>//        Function_Return False
30578>>>>>>>//    End_Function
30578>>>>>>>
30578>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
30580>>>>>>>        String sPhysicalName sPhysicalNameCompare
30580>>>>>>>        Integer iCount iMaster iAlias iInTable
30580>>>>>>>
30580>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalName
30583>>>>>>>        Get _TableNameOnly sPhysicalName to sPhysicalName
30584>>>>>>>        Move hTable to iInTable
30585>>>>>>>        Move 0 to hTable
30586>>>>>>>        Move 0 to iCount
30587>>>>>>>
30587>>>>>>>        Repeat
30587>>>>>>>>
30587>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
30590>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
30592>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sPhysicalNameCompare
30595>>>>>>>                Get _TableNameOnly sPhysicalNameCompare to sPhysicalNameCompare
30596>>>>>>>                If (Uppercase(sPhysicalName) = Uppercase(sPhysicalNameCompare)) Begin
30598>>>>>>>//======= Original ===========================
30598>>>>>>>//                    If (iCount = 0) Begin
30598>>>>>>>//                        Move hTable to iMaster
30598>>>>>>>//                    End
30598>>>>>>>//                    If (iCount > 0) Begin
30598>>>>>>>//                        Move hTable to iAlias
30598>>>>>>>//                    End
30598>>>>>>>//                    Increment iCount
30598>>>>>>>//===========================================
30598>>>>>>>                    Case Begin
30598>>>>>>>                        Case (iCount = 0)
30600>>>>>>>                            // The first table is going to be the master file
30600>>>>>>>                            Move hTable to iMaster
30601>>>>>>>                            Increment iCount
30602>>>>>>>                            Case Break
30603>>>>>>>
30603>>>>>>>                        Case (iCount > 0 and iInTable = hTable)
30606>>>>>>>                            // If we have another Physical name entry then we need to
30606>>>>>>>                            //  check if the InTable file is an alias to that master
30606>>>>>>>                            Move hTable to iAlias
30607>>>>>>>                            Increment iCount
30608>>>>>>>                            Case Break
30609>>>>>>>                    Case End
30609>>>>>>>                End
30609>>>>>>>>
30609>>>>>>>            End
30609>>>>>>>>
30609>>>>>>>        Until (hTable = 0)
30611>>>>>>>
30611>>>>>>>        If (iCount > 1) Begin
30613>>>>>>>            Function_Return (iInTable >= iAlias and iAlias > iMaster)
30614>>>>>>>        End
30614>>>>>>>>
30614>>>>>>>
30614>>>>>>>        Function_Return False
30615>>>>>>>    End_Function
30616>>>>>>>
30616>>>>>>>//    Function UtilTableIsAliasFdFile Handle hTable Returns Boolean
30616>>>>>>>//        String sDDSrcPath sDataPath sLogicalName
30616>>>>>>>//        Boolean bOK bExists
30616>>>>>>>//
30616>>>>>>>//        Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
30616>>>>>>>//        If (Right(sDataPath, 1) = "\") Begin
30616>>>>>>>//            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
30616>>>>>>>//        End
30616>>>>>>>//        Move (StringFromRightOfChar(sDataPath, "\")) to sDDSrcPath
30616>>>>>>>//        Move (Replace(sDDSrcPath, sDataPath, ""))    to sDDSrcPath
30616>>>>>>>//        Move (sDDSrcPath + "DDSrc")                  to sDDSrcPath
30616>>>>>>>//        Get vFolderFormat sDDSrcPath                 to sDDSrcPath
30616>>>>>>>//
30616>>>>>>>//        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
30616>>>>>>>//        Get vFilePathExists (sDDSrcPath + sLogicalName + ".fd") to bExists
30616>>>>>>>//
30616>>>>>>>//        Function_Return bExists
30616>>>>>>>//    End_Function
30616>>>>>>>
30616>>>>>>>    // To Open a table with any driver.
30616>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
30616>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
30616>>>>>>>    //
30616>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
30616>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
30616>>>>>>>    // returns a True if successful (table could be opened).
30616>>>>>>>    //
30616>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
30616>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
30616>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
30616>>>>>>>    // set properly we can open the table.
30616>>>>>>>    //
30616>>>>>>>    // DAW Driver Syntax:
30616>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
30616>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
30616>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
30616>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
30616>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
30616>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
30616>>>>>>>    //
30616>>>>>>>    // DAW Driver Sample:
30616>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
30616>>>>>>>    //
30616>>>>>>>    // Mertech Driver Samples:
30616>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
30616>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
30616>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
30616>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
30616>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
30618>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
30618>>>>>>>        Boolean bOpen bMertechDriver bOK
30618>>>>>>>        tSQLConnection SQLConnection
30618>>>>>>>        tSQLConnection SQLConnection
30618>>>>>>>        
30618>>>>>>>        Move False to bOpen
30619>>>>>>>        Move sTableName to sTableNameOrg
30620>>>>>>>        If (hTable > 0) Begin
30622>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
30623>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
30624>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
30625>>>>>>>            Open hTable Mode iMode
30627>>>>>>>            Send Trap_Error of Error_Object_Id 20529
30628>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
30629>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
30630>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
30633>>>>>>>            If (bOpen = True) Begin
30635>>>>>>>                Function_Return True
30636>>>>>>>            End
30636>>>>>>>>
30636>>>>>>>        End
30636>>>>>>>>
30636>>>>>>>
30636>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
30637>>>>>>>        If (hTable > 0) Begin
30639>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
30642>>>>>>>        End
30642>>>>>>>>
30642>>>>>>>
30642>>>>>>>        Function_Return bOpen
30643>>>>>>>    End_Function
30644>>>>>>>
30644>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
30646>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
30646>>>>>>>        Boolean bOpen bMertechDriver bOK
30646>>>>>>>        tSQLConnection SQLConnection
30646>>>>>>>        tSQLConnection SQLConnection
30646>>>>>>>
30646>>>>>>>        If (hTable < 1) Begin
30648>>>>>>>            Function_Return False
30649>>>>>>>        End
30649>>>>>>>>
30649>>>>>>>
30649>>>>>>>        Move sTableName to sTableNameOrg
30650>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
30651>>>>>>>        Move SQLConnection.sDriverID to sDriverID
30652>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
30653>>>>>>>        Move SQLConnection.sConnectionString to sConnection
30654>>>>>>>        Move SQLConnection.sSchema to sSchema
30655>>>>>>>        If (sSchema = "") Begin
30657>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
30658>>>>>>>        End
30658>>>>>>>>
30658>>>>>>>
30658>>>>>>>        // We need to remove the ".int" part of the table name because
30658>>>>>>>        // the table name after the "#" in the connection syntax below wants the
30658>>>>>>>        // "bare" table name without any extension.
30658>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
30660>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
30662>>>>>>>                Get ParseFileExtension sTableName to sExt
30663>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
30664>>>>>>>            End
30664>>>>>>>>
30664>>>>>>>            Else Begin
30665>>>>>>>                Move sTableName to sTableNameShort
30666>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
30667>>>>>>>            End
30667>>>>>>>>
30667>>>>>>>            If (bMertechDriver = False) Begin
30669>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
30670>>>>>>>                Move sConnection to sTableName
30671>>>>>>>            End
30671>>>>>>>>
30671>>>>>>>        End
30671>>>>>>>>
30671>>>>>>>
30671>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30672>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
30673>>>>>>>        If (hTable = 0) Begin
30675>>>>>>>            Get NextFreeFilelistSlot to hTable
30676>>>>>>>        End
30676>>>>>>>>
30676>>>>>>>
30676>>>>>>>        Case Begin
30676>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
30678>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
30678>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
30680>>>>>>>                    Open sTableName as hTable
30682>>>>>>>                End
30682>>>>>>>>
30682>>>>>>>                Else Begin
30683>>>>>>>                    Get OpenTableExclusive hTable to bOK
30684>>>>>>>                    If (bOK = False) Begin
30686>>>>>>>                        Function_Return False
30687>>>>>>>                    End
30687>>>>>>>>
30687>>>>>>>                End
30687>>>>>>>>
30687>>>>>>>                Case Break
30688>>>>>>>
30688>>>>>>>            Case (sDriverID = DB2_DRV_ID)
30691>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
30691>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
30693>>>>>>>                    Open sTableName as hTable
30695>>>>>>>                End
30695>>>>>>>>
30695>>>>>>>                Else Begin
30696>>>>>>>                    Get OpenTableExclusive hTable to bOK
30697>>>>>>>                    If (bOK = False) Begin
30699>>>>>>>                        Function_Return False
30700>>>>>>>                    End
30700>>>>>>>>
30700>>>>>>>                End
30700>>>>>>>>
30700>>>>>>>                Case Break
30701>>>>>>>
30701>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
30704>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
30704>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
30706>>>>>>>                    Open sTableName as hTable
30708>>>>>>>                End
30708>>>>>>>>
30708>>>>>>>                Else Begin
30709>>>>>>>                    Get OpenTableExclusive hTable to bOK
30710>>>>>>>                    If (bOK = False) Begin
30712>>>>>>>                        Function_Return False
30713>>>>>>>                    End
30713>>>>>>>>
30713>>>>>>>                End
30713>>>>>>>>
30713>>>>>>>                Case Break
30714>>>>>>>
30714>>>>>>>            Case (sDriverID = SQLFLEX)
30717>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
30717>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
30717>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
30718>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
30718>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
30720>>>>>>>                    Open sTableName as hTable
30722>>>>>>>                End
30722>>>>>>>>
30722>>>>>>>                Else Begin
30723>>>>>>>                    Get OpenTableExclusive hTable to bOK
30724>>>>>>>                    If (bOK = False) Begin
30726>>>>>>>                        Function_Return False
30727>>>>>>>                    End
30727>>>>>>>>
30727>>>>>>>                End
30727>>>>>>>>
30727>>>>>>>                Case Break
30728>>>>>>>
30728>>>>>>>            Case (sDriverID = MDSMySQL)
30731>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
30731>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
30732>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
30732>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
30734>>>>>>>                    Open sTableName as hTable
30736>>>>>>>                End
30736>>>>>>>>
30736>>>>>>>                Else Begin
30737>>>>>>>                    Get OpenTableExclusive hTable to bOK
30738>>>>>>>                    If (bOK = False) Begin
30740>>>>>>>                        Function_Return False
30741>>>>>>>                    End
30741>>>>>>>>
30741>>>>>>>                End
30741>>>>>>>>
30741>>>>>>>                Case Break
30742>>>>>>>
30742>>>>>>>            Case (sDriverID = MDSPgSQL)
30745>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
30745>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
30746>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
30746>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
30748>>>>>>>                    Open sTableName as hTable
30750>>>>>>>                End
30750>>>>>>>>
30750>>>>>>>                Else Begin
30751>>>>>>>                    Get OpenTableExclusive hTable to bOK
30752>>>>>>>                    If (bOK = False) Begin
30754>>>>>>>                        Function_Return False
30755>>>>>>>                    End
30755>>>>>>>>
30755>>>>>>>                End
30755>>>>>>>>
30755>>>>>>>                Case Break
30756>>>>>>>
30756>>>>>>>            Case (sDriverID = ORAFLEX)
30759>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
30759>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
30759>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
30760>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
30760>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
30762>>>>>>>                    Open sTableName as hTable
30764>>>>>>>                End
30764>>>>>>>>
30764>>>>>>>                Else Begin
30765>>>>>>>                    Get OpenTableExclusive hTable to bOK
30766>>>>>>>                    If (bOK = False) Begin
30768>>>>>>>                        Function_Return False
30769>>>>>>>                    End
30769>>>>>>>>
30769>>>>>>>                End
30769>>>>>>>>
30769>>>>>>>                Case Break
30770>>>>>>>
30770>>>>>>>            Case (sDriverID = DATAFLEX_ID)
30773>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
30775>>>>>>>                    Open sTableName as hTable
30777>>>>>>>                End
30777>>>>>>>>
30777>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
30780>>>>>>>                    Get OpenTableExclusive hTable to bOK
30781>>>>>>>                    If (bOK = False) Begin
30783>>>>>>>                        Function_Return False
30784>>>>>>>                    End
30784>>>>>>>>
30784>>>>>>>                End
30784>>>>>>>>
30784>>>>>>>                Else Begin
30785>>>>>>>                    Open hTable
30787>>>>>>>                End
30787>>>>>>>>
30787>>>>>>>                Case Break
30788>>>>>>>
30788>>>>>>>            // ToDo: Logic needs to be expanded for Mertech drivers!
30788>>>>>>>
30788>>>>>>>            Case Else
30788>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
30789>>>>>>>>
30789>>>>>>>        Case End
30789>>>>>>>
30789>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
30790>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
30791>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
30793>>>>>>>            Move False to Found
30794>>>>>>>        End
30794>>>>>>>>
30794>>>>>>>        // If open failed, the Err is set to true,
30794>>>>>>>        // but we don't want that because it could end our loop.
30794>>>>>>>        Move False to Err
30795>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
30798>>>>>>>
30798>>>>>>>        Function_Return bOpen
30799>>>>>>>    End_Function
30800>>>>>>>
30800>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
30800>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
30800>>>>>>>    // if it is an SQL table
30800>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
30802>>>>>>>        Boolean bExists bIsSQLTable
30802>>>>>>>        String sDataPath sRootName
30802>>>>>>>
30802>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
30803>>>>>>>        If (bExists = False) Begin
30805>>>>>>>            Function_Return False
30806>>>>>>>        End
30806>>>>>>>>
30806>>>>>>>
30806>>>>>>>        Move False to bIsSQLTable
30807>>>>>>>        If (hTable > 0) Begin
30809>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
30812>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
30813>>>>>>>        End
30813>>>>>>>>
30813>>>>>>>        If (bIsSQLTable = True) Begin
30815>>>>>>>            Get UtilTableIsSQL hTable to bExists
30816>>>>>>>            Function_Return bExists
30817>>>>>>>        End
30817>>>>>>>>
30817>>>>>>>        Else Begin
30818>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
30819>>>>>>>            Get vFolderFormat sDataPath to sDataPath
30820>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
30821>>>>>>>        End
30821>>>>>>>>
30821>>>>>>>
30821>>>>>>>        Function_Return bExists
30822>>>>>>>    End_Function
30823>>>>>>>
30823>>>>>>>    // Pass a table handle
30823>>>>>>>    // Returns True if the table exists in filelist.cfg.
30823>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
30825>>>>>>>        Handle hTable
30825>>>>>>>        Boolean bFound
30825>>>>>>>
30825>>>>>>>        Move False to bFound
30826>>>>>>>        Move 0 to hTable
30827>>>>>>>        Repeat
30827>>>>>>>>
30827>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
30830>>>>>>>            If (hTable > 0) Begin
30832>>>>>>>                If (hTable = hCheckTable) Begin
30834>>>>>>>                    Move True to bFound
30835>>>>>>>                End
30835>>>>>>>>
30835>>>>>>>            End
30835>>>>>>>>
30835>>>>>>>            If (bFound = True) ;                Break
30838>>>>>>>        Until (hTable = 0)
30840>>>>>>>
30840>>>>>>>        Function_Return (bFound = True)
30841>>>>>>>    End_Function
30842>>>>>>>
30842>>>>>>>    // Pass a table's logical name
30842>>>>>>>    // Returns True if the table exists in filelist.cfg.
30842>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
30844>>>>>>>        Handle hTable
30844>>>>>>>        Boolean bFound
30844>>>>>>>        String sCompareTable
30844>>>>>>>
30844>>>>>>>        Move False to bFound
30845>>>>>>>        Move 0 to hTable
30846>>>>>>>        Repeat
30846>>>>>>>>
30846>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
30849>>>>>>>            If (hTable > 0) Begin
30851>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
30854>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
30856>>>>>>>                    Move True to bFound
30857>>>>>>>                End
30857>>>>>>>>
30857>>>>>>>            End
30857>>>>>>>>
30857>>>>>>>            If (bFound = True) ;                Break
30860>>>>>>>        Until (hTable = 0)
30862>>>>>>>
30862>>>>>>>        Function_Return (bFound = True)
30863>>>>>>>    End_Function
30864>>>>>>>
30864>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
30866>>>>>>>        Boolean bOK bExists
30866>>>>>>>        String sDriverID
30866>>>>>>>
30866>>>>>>>        Get UtilTableExists hTable to bExists
30867>>>>>>>        If (bExists = False) Begin
30869>>>>>>>            Function_Return ""
30870>>>>>>>        End
30870>>>>>>>>
30870>>>>>>>        Get OpenTableExclusive hTable to bOK
30871>>>>>>>        If (bOK = False) Begin
30873>>>>>>>            Function_Return ""
30874>>>>>>>        End
30874>>>>>>>>
30874>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
30877>>>>>>>
30877>>>>>>>        Function_Return sDriverID
30878>>>>>>>    End_Function
30879>>>>>>>
30879>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
30879>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
30881>>>>>>>        Handle hTable
30881>>>>>>>        Integer iRetval
30881>>>>>>>
30881>>>>>>>        Move 0 to hTable
30882>>>>>>>        Move 0 to iRetval
30883>>>>>>>
30883>>>>>>>        Repeat
30883>>>>>>>>
30883>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
30886>>>>>>>            If (hTable > 0) Begin
30888>>>>>>>                Increment iRetval
30889>>>>>>>            End
30889>>>>>>>>
30889>>>>>>>        Until (hTable = 0)
30891>>>>>>>
30891>>>>>>>        Function_Return iRetval
30892>>>>>>>    End_Function
30893>>>>>>>
30893>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
30893>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
30895>>>>>>>        Handle hTable
30895>>>>>>>        String sRoot sDriverID
30895>>>>>>>        Boolean bIsSQLTable
30895>>>>>>>        Integer iPos
30895>>>>>>>
30895>>>>>>>        Move 0 to hTable
30896>>>>>>>        Move "" to sDriverID
30897>>>>>>>        Move False to bIsSQLTable
30898>>>>>>>
30898>>>>>>>        Repeat
30898>>>>>>>>
30898>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
30901>>>>>>>            If (hTable > 0) Begin
30903>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
30906>>>>>>>                If (sRoot contains ":") Begin
30908>>>>>>>                    Move (Pos(":", sRoot)) to iPos
30909>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
30910>>>>>>>                End
30910>>>>>>>>
30910>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
30911>>>>>>>            End
30911>>>>>>>>
30911>>>>>>>
30911>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
30913>>>>>>>
30913>>>>>>>        Function_Return sDriverID
30914>>>>>>>    End_Function
30915>>>>>>>
30915>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
30917>>>>>>>        String sRootName
30917>>>>>>>        Boolean bIsSQL
30917>>>>>>>        Handle hTable
30917>>>>>>>
30917>>>>>>>        Move False to bIsSQL
30918>>>>>>>        Move 0 to hTable
30919>>>>>>>        Repeat
30919>>>>>>>>
30919>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
30922>>>>>>>            If (hTable > 0) Begin
30924>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
30927>>>>>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
30928>>>>>>>                If (bIsSQL = True) Begin
30930>>>>>>>                    Move 0 to hTable
30931>>>>>>>                End
30931>>>>>>>>
30931>>>>>>>            End
30931>>>>>>>>
30931>>>>>>>        Until (hTable = 0)
30933>>>>>>>
30933>>>>>>>        Function_Return (bIsSQL = False)
30934>>>>>>>    End_Function
30935>>>>>>>
30935>>>>>>>    // * Dummy function for the Studio's Code Explorer *
30935>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
30937>>>>>>>        Function_Return False
30938>>>>>>>    End_Function
30939>>>>>>>
30939>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
30941>>>>>>>        String  sRetval
30941>>>>>>>        String[] sOverlapFieldsArray
30942>>>>>>>        Integer iType iColumn iColumns
30942>>>>>>>        Boolean bOpen bOverlap
30942>>>>>>>
30942>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
30945>>>>>>>        If (bOpen = False) Begin
30947>>>>>>>            Open hTable
30949>>>>>>>        End
30949>>>>>>>>
30949>>>>>>>
30949>>>>>>>        Move "" to sRetval
30950>>>>>>>
30950>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
30953>>>>>>>
30953>>>>>>>        for iColumn from 0 to iColumns
30959>>>>>>>>
30959>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
30962>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
30964>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
30967>>>>>>>                If (bOverlap) Begin
30969>>>>>>>                    If (sRetval <> "") Begin
30971>>>>>>>                        Append sRetval ","
30972>>>>>>>                    End
30972>>>>>>>>
30972>>>>>>>                    Append sRetval iColumn
30973>>>>>>>                End
30973>>>>>>>>
30973>>>>>>>            End
30973>>>>>>>>
30973>>>>>>>        Loop
30974>>>>>>>>
30974>>>>>>>
30974>>>>>>>        If (bOpen = False) Begin
30976>>>>>>>            Close hTable
30977>>>>>>>        End
30977>>>>>>>>
30977>>>>>>>
30977>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
30978>>>>>>>
30978>>>>>>>        Function_Return sOverlapFieldsArray
30979>>>>>>>    End_Function
30980>>>>>>>
30980>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
30980>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
30982>>>>>>>        tColumnType[] ColumnType
30982>>>>>>>        tColumnType[] ColumnType
30983>>>>>>>
30983>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
30983>>>>>>>        // the dbType.
30983>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
30985>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
30987>>>>>>>                Move MDSMySQL to sDriverID
30988>>>>>>>            End
30988>>>>>>>>
30988>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
30990>>>>>>>                Move MSSQLDRV_ID to sDriverID
30991>>>>>>>            End
30991>>>>>>>>
30991>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
30993>>>>>>>                Move DB2_DRV_ID to sDriverID
30994>>>>>>>            End
30994>>>>>>>>
30994>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
30996>>>>>>>                Move MDSPgSQL to sDriverID
30997>>>>>>>            End
30997>>>>>>>>
30997>>>>>>>        End
30997>>>>>>>>
30997>>>>>>>
30997>>>>>>>        Case Begin
30997>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
30999>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
31000>>>>>>>                Case Break
31001>>>>>>>
31001>>>>>>>            Case (iDbType = EN_DbTypeDB2)
31004>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
31005>>>>>>>                Case Break
31006>>>>>>>
31006>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
31009>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
31010>>>>>>>                Case Break
31011>>>>>>>
31011>>>>>>>            Case (sDriverID = MDSMySQL)
31014>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
31015>>>>>>>                Case Break
31016>>>>>>>
31016>>>>>>>            Case (sDriverID = ORAFLEX)
31019>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
31020>>>>>>>                Case Break
31021>>>>>>>
31021>>>>>>>            Case (sDriverID = MDSPgSQL)
31024>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
31025>>>>>>>                Case Break
31026>>>>>>>        Case End
31026>>>>>>>
31026>>>>>>>        Function_Return ColumnType
31027>>>>>>>    End_Function
31028>>>>>>>
31028>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
31030>>>>>>>        Handle hoRegistry hoODBCDriverNames
31030>>>>>>>        Boolean bExists bKeyOpened
31030>>>>>>>        String sKey
31030>>>>>>>        String[] sDrivers
31031>>>>>>>        Integer iDriverNames iDriverName
31031>>>>>>>
31031>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
31032>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
31033>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
31034>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
31035>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
31036>>>>>>>        If (bExists) Begin
31038>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
31039>>>>>>>            If (bKeyOpened) Begin
31041>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
31042>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
31043>>>>>>>                If (iDriverNames > 0) Begin
31045>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
31046>>>>>>>                    Decrement iDriverNames
31047>>>>>>>                    for iDriverName from 0 to iDriverNames
31053>>>>>>>>
31053>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
31054>>>>>>>                    Loop
31055>>>>>>>>
31055>>>>>>>                End
31055>>>>>>>>
31055>>>>>>>                Send CloseKey of hoRegistry
31056>>>>>>>            End
31056>>>>>>>>
31056>>>>>>>        End
31056>>>>>>>>
31056>>>>>>>        Send Destroy of hoRegistry
31057>>>>>>>
31057>>>>>>>        Function_Return sDrivers
31058>>>>>>>    End_Function
31059>>>>>>>
31059>>>>>>>    // DataFlex Embedded Database Data Types:
31059>>>>>>>    // Helper function for UtilEnumerateColumnTypes
31059>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
31061>>>>>>>        tColumnType[] ColumnType
31061>>>>>>>        tColumnType[] ColumnType
31062>>>>>>>        Integer i
31062>>>>>>>
31062>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
31063>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
31064>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
31065>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
31066>>>>>>>        Move "254"              to ColumnType[i].sPrecision
31067>>>>>>>        Increment i
31068>>>>>>>
31068>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
31069>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
31070>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
31071>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
31072>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
31073>>>>>>>        Increment i
31074>>>>>>>
31074>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
31075>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
31076>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
31077>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
31078>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
31079>>>>>>>        Move True               to ColumnType[i].bCanEditSize
31080>>>>>>>        Increment i
31081>>>>>>>
31081>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
31082>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
31083>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
31084>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
31085>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
31086>>>>>>>        Increment i
31087>>>>>>>
31087>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
31088>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
31089>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
31090>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
31091>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
31092>>>>>>>        Increment i
31093>>>>>>>
31093>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
31094>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
31095>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
31096>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
31097>>>>>>>        Move "23"               to ColumnType[i].sPrecision
31098>>>>>>>        Move True               to ColumnType[i].bCanEditSize
31099>>>>>>>        Increment i
31100>>>>>>>
31100>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
31101>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
31102>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
31103>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
31104>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
31105>>>>>>>
31105>>>>>>>        Function_Return ColumnType
31106>>>>>>>    End_Function
31107>>>>>>>
31107>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
31109>>>>>>>        tColumnType[] aColumnType
31109>>>>>>>        tColumnType[] aColumnType
31110>>>>>>>        Integer i
31110>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\DB2_DRV_DriverDef.inc)
31110>>>>>>>>// Generated By The Database Update Framework
31110>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
31110>>>>>>>>// Driver COLUMN DATA TYPES
31110>>>>>>>>//
31110>>>>>>>>// Created: 2019-07-18 18:57:13.935
31110>>>>>>>>
31110>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
31111>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
31112>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31113>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31114>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31115>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31116>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31117>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31118>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31119>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31120>>>>>>>>            Increment i
31121>>>>>>>>
31121>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
31122>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
31123>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31124>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31125>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31126>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31127>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31128>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31129>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31130>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31131>>>>>>>>            Increment i
31132>>>>>>>>
31132>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
31133>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
31134>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31135>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31136>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31137>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31138>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31139>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31140>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31141>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31142>>>>>>>>            Increment i
31143>>>>>>>>
31143>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
31144>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
31145>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31146>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31147>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31148>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31149>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31150>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31151>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31152>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31153>>>>>>>>            Increment i
31154>>>>>>>>
31154>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
31155>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
31156>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31157>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31158>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31159>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31160>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31161>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31162>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31163>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31164>>>>>>>>            Increment i
31165>>>>>>>>
31165>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
31166>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
31167>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31168>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31169>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31170>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
31171>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
31172>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31173>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31174>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
31175>>>>>>>>            Increment i
31176>>>>>>>>
31176>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
31177>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
31178>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31179>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31180>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
31181>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
31182>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
31183>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31184>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31185>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
31186>>>>>>>>            Increment i
31187>>>>>>>>
31187>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
31188>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
31189>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31190>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31191>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
31192>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
31193>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
31194>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31195>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31196>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
31197>>>>>>>>            Increment i
31198>>>>>>>>
31198>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
31199>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
31200>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31201>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31202>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31203>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31204>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31205>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31206>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31207>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31208>>>>>>>>            Increment i
31209>>>>>>>>
31209>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
31210>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
31211>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31212>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31213>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31214>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31215>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31216>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
31217>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
31218>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31219>>>>>>>>            Increment i
31220>>>>>>>>
31220>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
31221>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
31222>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31223>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31224>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31225>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31226>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31227>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31228>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31229>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31230>>>>>>>>            Increment i
31231>>>>>>>>
31231>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
31232>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
31233>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31234>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31235>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
31236>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31237>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
31238>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31239>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31240>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
31241>>>>>>>>            Increment i
31242>>>>>>>>
31242>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
31243>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
31244>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31245>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31246>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31247>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31248>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31249>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31250>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31251>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31252>>>>>>>>            Increment i
31253>>>>>>>>
31253>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
31254>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
31255>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31256>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31257>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31258>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31259>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
31260>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31261>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31262>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
31263>>>>>>>>            Increment i
31264>>>>>>>>
31264>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
31265>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
31266>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31267>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31268>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31269>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31270>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31271>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31272>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31273>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31274>>>>>>>>            Increment i
31275>>>>>>>>
31275>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
31276>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
31277>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31278>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31279>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31280>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31281>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31282>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
31283>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
31284>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
31285>>>>>>>>            Increment i
31286>>>>>>>>
31286>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
31287>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
31288>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31289>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31290>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31291>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31292>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
31293>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31294>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31295>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
31296>>>>>>>>            Increment i
31297>>>>>>>>
31297>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
31298>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
31299>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31300>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31301>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31302>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31303>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31304>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31305>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31306>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31307>>>>>>>>            Increment i
31308>>>>>>>>
31308>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
31309>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
31310>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31311>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31312>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31313>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31314>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31315>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31316>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31317>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31318>>>>>>>>            Increment i
31319>>>>>>>>
31319>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
31320>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
31321>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31322>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31323>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31324>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31325>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31326>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31327>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31328>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31329>>>>>>>>            Increment i
31330>>>>>>>>
31330>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
31331>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
31332>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31333>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31334>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
31335>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31336>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
31337>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31338>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31339>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
31340>>>>>>>>            Increment i
31341>>>>>>>>
31341>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
31342>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
31343>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31344>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31345>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31346>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31347>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31348>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31349>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31350>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31351>>>>>>>>            Increment i
31352>>>>>>>>
31352>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
31353>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
31354>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31355>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31356>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31357>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31358>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31359>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31360>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31361>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31362>>>>>>>>            Increment i
31363>>>>>>>>
31363>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
31364>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
31365>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31366>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31367>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
31368>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
31369>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
31370>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31371>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31372>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
31373>>>>>>>>            Increment i
31374>>>>>>>>
31374>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
31375>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
31376>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31377>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31378>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
31379>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31380>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
31381>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31382>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31383>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
31384>>>>>>>>            Increment i
31385>>>>>>>>
31385>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
31386>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
31387>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31388>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31389>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31390>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31391>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31392>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31393>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31394>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31395>>>>>>>>            Increment i
31396>>>>>>>>
31396>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
31397>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
31398>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31399>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31400>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
31401>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31402>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31403>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31404>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31405>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31406>>>>>>>>            Increment i
31407>>>>>>>>
31407>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
31408>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
31409>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31410>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31411>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31412>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31413>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31414>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31415>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31416>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31417>>>>>>>>            Increment i
31418>>>>>>>>
31418>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
31419>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
31420>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31421>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31422>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31423>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31424>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31425>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31426>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31427>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31428>>>>>>>>            Increment i
31429>>>>>>>>
31429>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
31430>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
31431>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31432>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31433>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31434>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31435>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31436>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31437>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31438>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31439>>>>>>>>            Increment i
31440>>>>>>>>
31440>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
31441>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
31442>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31443>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31444>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31445>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31446>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31447>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31448>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31449>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31450>>>>>>>>            Increment i
31451>>>>>>>>
31451>>>>>>>>
31451>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
31451>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
31451>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
31451>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
31451>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        // ToDo: We need to change the sType when using this!
31451>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
31451>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
31451>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
31451>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
31451>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
31451>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
31451>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
31451>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
31451>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
31451>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
31451>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
31451>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
31451>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
31451>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
31451>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
31451>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
31451>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
31451>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
31451>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
31451>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
31451>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        // ToDo: We need to change the sType when using this!
31451>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
31451>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
31451>>>>>>>//        Increment i
31451>>>>>>>//
31451>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
31451>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
31451>>>>>>>//
31451>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
31451>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
31451>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
31451>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
31451>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
31451>>>>>>>
31451>>>>>>>        Function_Return aColumnType
31452>>>>>>>    End_Function
31453>>>>>>>
31453>>>>>>>    // Microsoft SQL Server Database Data Types:
31453>>>>>>>    // Helper function for UtilEnumerateColumnTypes
31453>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
31455>>>>>>>        tColumnType[] aColumnType
31455>>>>>>>        tColumnType[] aColumnType
31456>>>>>>>        Integer i
31456>>>>>>>
31456>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\MSSQLDRV_DriverDef.inc)
31458>>>>>>>>// Generated By The Database Update Framework
31458>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
31458>>>>>>>>// Driver COLUMN DATA TYPES
31458>>>>>>>>//
31458>>>>>>>>// Created: 2019-07-18 18:56:37.539
31458>>>>>>>>
31458>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
31459>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
31460>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31461>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31462>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31463>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31464>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31465>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31466>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31467>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31468>>>>>>>>            Increment i
31469>>>>>>>>
31469>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
31470>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
31471>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31472>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31473>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31474>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31475>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31476>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
31477>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
31478>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31479>>>>>>>>            Increment i
31480>>>>>>>>
31480>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
31481>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
31482>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31483>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31484>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31485>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31486>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31487>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31488>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31489>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31490>>>>>>>>            Increment i
31491>>>>>>>>
31491>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
31492>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
31493>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31494>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31495>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31496>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31497>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31498>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31499>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31500>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31501>>>>>>>>            Increment i
31502>>>>>>>>
31502>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
31503>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
31504>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31505>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31506>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31507>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31508>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31509>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
31510>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
31511>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
31512>>>>>>>>            Increment i
31513>>>>>>>>
31513>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
31514>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
31515>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31516>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31517>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31518>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
31519>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
31520>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
31521>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
31522>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
31523>>>>>>>>            Increment i
31524>>>>>>>>
31524>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
31525>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
31526>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31527>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31528>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
31529>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
31530>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
31531>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
31532>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
31533>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
31534>>>>>>>>            Increment i
31535>>>>>>>>
31535>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
31536>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
31537>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31538>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31539>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
31540>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
31541>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
31542>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
31543>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
31544>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
31545>>>>>>>>            Increment i
31546>>>>>>>>
31546>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
31547>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
31548>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31549>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31550>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31551>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31552>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31553>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31554>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31555>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31556>>>>>>>>            Increment i
31557>>>>>>>>
31557>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
31558>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
31559>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31560>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31561>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31562>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31563>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31564>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31565>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31566>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31567>>>>>>>>            Increment i
31568>>>>>>>>
31568>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
31569>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
31570>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31571>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31572>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31573>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31574>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31575>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
31576>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
31577>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31578>>>>>>>>            Increment i
31579>>>>>>>>
31579>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
31580>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
31581>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31582>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31583>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
31584>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31585>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
31586>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31587>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31588>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
31589>>>>>>>>            Increment i
31590>>>>>>>>
31590>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
31591>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
31592>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31593>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31594>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31595>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31596>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31597>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31598>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31599>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31600>>>>>>>>            Increment i
31601>>>>>>>>
31601>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
31602>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
31603>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31604>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31605>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31606>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31607>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
31608>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31609>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31610>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
31611>>>>>>>>            Increment i
31612>>>>>>>>
31612>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
31613>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
31614>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31615>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31616>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31617>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31618>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31619>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
31620>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
31621>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31622>>>>>>>>            Increment i
31623>>>>>>>>
31623>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
31624>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
31625>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31626>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31627>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31628>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31629>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31630>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31631>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31632>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31633>>>>>>>>            Increment i
31634>>>>>>>>
31634>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
31635>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
31636>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31637>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31638>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31639>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31640>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
31641>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31642>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31643>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
31644>>>>>>>>            Increment i
31645>>>>>>>>
31645>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
31646>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
31647>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31648>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31649>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31650>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31651>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31652>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31653>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31654>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31655>>>>>>>>            Increment i
31656>>>>>>>>
31656>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
31657>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
31658>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31659>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31660>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31661>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31662>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31663>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31664>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31665>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31666>>>>>>>>            Increment i
31667>>>>>>>>
31667>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
31668>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
31669>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31670>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31671>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31672>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31673>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31674>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
31675>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
31676>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31677>>>>>>>>            Increment i
31678>>>>>>>>
31678>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
31679>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
31680>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31681>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31682>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
31683>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31684>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
31685>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31686>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31687>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
31688>>>>>>>>            Increment i
31689>>>>>>>>
31689>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
31690>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
31691>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31692>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31693>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31694>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31695>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31696>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31697>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31698>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31699>>>>>>>>            Increment i
31700>>>>>>>>
31700>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
31701>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
31702>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31703>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31704>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31705>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31706>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31707>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
31708>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
31709>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31710>>>>>>>>            Increment i
31711>>>>>>>>
31711>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
31712>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
31713>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31714>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31715>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
31716>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
31717>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
31718>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31719>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31720>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
31721>>>>>>>>            Increment i
31722>>>>>>>>
31722>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
31723>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
31724>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31725>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31726>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
31727>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31728>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
31729>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31730>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31731>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
31732>>>>>>>>            Increment i
31733>>>>>>>>
31733>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
31734>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
31735>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31736>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31737>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
31738>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
31739>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
31740>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31741>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31742>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
31743>>>>>>>>            Increment i
31744>>>>>>>>
31744>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
31745>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
31746>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31747>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31748>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
31749>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31750>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31751>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
31752>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
31753>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31754>>>>>>>>            Increment i
31755>>>>>>>>
31755>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
31756>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
31757>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31758>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31759>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31760>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31761>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31762>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31763>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31764>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31765>>>>>>>>            Increment i
31766>>>>>>>>
31766>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
31767>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
31768>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31769>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31770>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31771>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31772>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31773>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31774>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31775>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31776>>>>>>>>            Increment i
31777>>>>>>>>
31777>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
31778>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
31779>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31780>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31781>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31782>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31783>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31784>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
31785>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
31786>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31787>>>>>>>>            Increment i
31788>>>>>>>>
31788>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
31789>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
31790>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31791>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31792>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
31793>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31794>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
31795>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
31796>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
31797>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
31798>>>>>>>>            Increment i
31799>>>>>>>>
31799>>>>>>>>
31799>>>>>>>
31799>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
31799>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
31799>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
31799>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
31799>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
31799>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
31799>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
31799>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
31799>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
31799>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
31799>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
31799>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
31799>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
31799>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
31799>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
31799>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
31799>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
31799>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
31799>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
31799>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
31799>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
31799>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
31799>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
31799>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
31799>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
31799>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
31799>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
31799>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
31799>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
31799>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
31799>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
31799>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
31799>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
31799>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
31799>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
31799>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
31799>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>//
31799>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
31799>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
31799>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
31799>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
31799>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
31799>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
31799>>>>>>>//            Increment i
31799>>>>>>>
31799>>>>>>>        End
31799>>>>>>>>
31799>>>>>>>
31799>>>>>>>        // Mertech SQLFlex driver
31799>>>>>>>        If (sDriverID = SQLFLEX) Begin
31801>>>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\sql_drv_DriverDef.inc)
31801>>>>>>>>// Generated By The Database Update Framework
31801>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
31801>>>>>>>>// Driver COLUMN DATA TYPES
31801>>>>>>>>//
31801>>>>>>>>// Created: 2018-03-14 23:47:46.885
31801>>>>>>>>
31801>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
31802>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
31803>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31804>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31805>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31806>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31807>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31808>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31809>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31810>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31811>>>>>>>>            Increment i
31812>>>>>>>>
31812>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
31813>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
31814>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31815>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31816>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31817>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31818>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31819>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
31820>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
31821>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31822>>>>>>>>            Increment i
31823>>>>>>>>
31823>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
31824>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
31825>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31826>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31827>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
31828>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
31829>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
31830>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31831>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31832>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
31833>>>>>>>>            Increment i
31834>>>>>>>>
31834>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
31835>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
31836>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31837>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31838>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31839>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31840>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
31841>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31842>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31843>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
31844>>>>>>>>            Increment i
31845>>>>>>>>
31845>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
31846>>>>>>>>            Move 40                                      to aColumnType[i].iSQLType
31847>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31848>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31849>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
31850>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
31851>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
31852>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31853>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31854>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
31855>>>>>>>>            Increment i
31856>>>>>>>>
31856>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
31857>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
31858>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31859>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31860>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
31861>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
31862>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
31863>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31864>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31865>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
31866>>>>>>>>            Increment i
31867>>>>>>>>
31867>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
31868>>>>>>>>            Move 42                                      to aColumnType[i].iSQLType
31869>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31870>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31871>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
31872>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
31873>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
31874>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31875>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31876>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
31877>>>>>>>>            Increment i
31878>>>>>>>>
31878>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
31879>>>>>>>>            Move 43                                      to aColumnType[i].iSQLType
31880>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31881>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31882>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
31883>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
31884>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
31885>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31886>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31887>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
31888>>>>>>>>            Increment i
31889>>>>>>>>
31889>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
31890>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
31891>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31892>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31893>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31894>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31895>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31896>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31897>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31898>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31899>>>>>>>>            Increment i
31900>>>>>>>>
31900>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
31901>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
31902>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31903>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31904>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31905>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31906>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31907>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31908>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31909>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31910>>>>>>>>            Increment i
31911>>>>>>>>
31911>>>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
31912>>>>>>>>            Move 130                                     to aColumnType[i].iSQLType
31913>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31914>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31915>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
31916>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
31917>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
31918>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31919>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31920>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
31921>>>>>>>>            Increment i
31922>>>>>>>>
31922>>>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
31923>>>>>>>>            Move 129                                     to aColumnType[i].iSQLType
31924>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31925>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31926>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
31927>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
31928>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
31929>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31930>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31931>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
31932>>>>>>>>            Increment i
31933>>>>>>>>
31933>>>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
31934>>>>>>>>            Move 128                                     to aColumnType[i].iSQLType
31935>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
31936>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31937>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
31938>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
31939>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
31940>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31941>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31942>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
31943>>>>>>>>            Increment i
31944>>>>>>>>
31944>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
31945>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
31946>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31947>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31948>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
31949>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31950>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
31951>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
31952>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
31953>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
31954>>>>>>>>            Increment i
31955>>>>>>>>
31955>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
31956>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
31957>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31958>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31959>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
31960>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31961>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
31962>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31963>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31964>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
31965>>>>>>>>            Increment i
31966>>>>>>>>
31966>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
31967>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
31968>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31969>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31970>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
31971>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31972>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
31973>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
31974>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
31975>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
31976>>>>>>>>            Increment i
31977>>>>>>>>
31977>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
31978>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
31979>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31980>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31981>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
31982>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31983>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
31984>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
31985>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
31986>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
31987>>>>>>>>            Increment i
31988>>>>>>>>
31988>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
31989>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
31990>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
31991>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
31992>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
31993>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
31994>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
31995>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
31996>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
31997>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
31998>>>>>>>>            Increment i
31999>>>>>>>>
31999>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
32000>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
32001>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32002>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32003>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32004>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32005>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
32006>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32007>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32008>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
32009>>>>>>>>            Increment i
32010>>>>>>>>
32010>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
32011>>>>>>>>            Move -100                                    to aColumnType[i].iSQLType
32012>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32013>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32014>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32015>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32016>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32017>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32018>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32019>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32020>>>>>>>>            Increment i
32021>>>>>>>>
32021>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
32022>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
32023>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32024>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32025>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32026>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32027>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32028>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32029>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32030>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32031>>>>>>>>            Increment i
32032>>>>>>>>
32032>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
32033>>>>>>>>            Move 58                                      to aColumnType[i].iSQLType
32034>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32035>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32036>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
32037>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
32038>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
32039>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32040>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32041>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
32042>>>>>>>>            Increment i
32043>>>>>>>>
32043>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
32044>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
32045>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32046>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32047>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
32048>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32049>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
32050>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32051>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32052>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
32053>>>>>>>>            Increment i
32054>>>>>>>>
32054>>>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
32055>>>>>>>>            Move -150                                    to aColumnType[i].iSQLType
32056>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32057>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32058>>>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
32059>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32060>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32061>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32062>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32063>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32064>>>>>>>>            Increment i
32065>>>>>>>>
32065>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
32066>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
32067>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32068>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32069>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32070>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32071>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32072>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
32073>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
32074>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32075>>>>>>>>            Increment i
32076>>>>>>>>
32076>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
32077>>>>>>>>            Move 41                                      to aColumnType[i].iSQLType
32078>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32079>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32080>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
32081>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
32082>>>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
32083>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32084>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32085>>>>>>>>            Move 16                                      to aColumnType[i].sPrecision
32086>>>>>>>>            Increment i
32087>>>>>>>>
32087>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
32088>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
32089>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32090>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32091>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
32092>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32093>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32094>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32095>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32096>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32097>>>>>>>>            Increment i
32098>>>>>>>>
32098>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
32099>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
32100>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32101>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32102>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
32103>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32104>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
32105>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32106>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32107>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
32108>>>>>>>>            Increment i
32109>>>>>>>>
32109>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
32110>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
32111>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32112>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32113>>>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
32114>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32115>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32116>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32117>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32118>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32119>>>>>>>>            Increment i
32120>>>>>>>>
32120>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
32121>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
32122>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32123>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32124>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
32125>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32126>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
32127>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32128>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32129>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
32130>>>>>>>>            Increment i
32131>>>>>>>>
32131>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
32132>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
32133>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32134>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32135>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32136>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32137>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32138>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32139>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32140>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32141>>>>>>>>            Increment i
32142>>>>>>>>
32142>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
32143>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
32144>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32145>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32146>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32147>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32148>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
32149>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32150>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32151>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
32152>>>>>>>>            Increment i
32153>>>>>>>>
32153>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
32154>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
32155>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32156>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32157>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32158>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32159>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32160>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32161>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32162>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32163>>>>>>>>            Increment i
32164>>>>>>>>
32164>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
32165>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
32166>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32167>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32168>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32169>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32170>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32171>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32172>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32173>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32174>>>>>>>>            Increment i
32175>>>>>>>>
32175>>>>>>>>
32175>>>>>>>
32175>>>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
32175>>>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
32175>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
32175>>>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Char"             to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Date"             to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
32175>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
32175>>>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
32175>>>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Double"           to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Float"            to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Int"              to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
32175>>>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Real"             to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
32175>>>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Text"             to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
32175>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "Time"             to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
32175>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
32175>>>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
32175>>>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
32175>>>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "38"               to ColumnType[i].sPrecision
32175>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
32175>>>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
32175>>>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                    to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
32175>>>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
32175>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
32175>>>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
32175>>>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
32175>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
32175>>>>>>>//            Increment i
32175>>>>>>>//
32175>>>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
32175>>>>>>>//            Move "XML"              to ColumnType[i].sSQLType
32175>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
32175>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
32175>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
32175>>>>>>>        End
32175>>>>>>>>
32175>>>>>>>
32175>>>>>>>        Function_Return aColumnType
32176>>>>>>>    End_Function
32177>>>>>>>
32177>>>>>>>    // MySQL Data Types
32177>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
32179>>>>>>>        tColumnType[] aColumnType
32179>>>>>>>        tColumnType[] aColumnType
32180>>>>>>>        Integer i
32180>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\mdsmysql_DriverDef.inc)
32180>>>>>>>>// Generated By The Database Update Framework
32180>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
32180>>>>>>>>// Driver COLUMN DATA TYPES
32180>>>>>>>>//
32180>>>>>>>>// Created: 2018-03-14 23:46:49.593
32180>>>>>>>>
32180>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
32181>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
32182>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32183>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32184>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32185>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32186>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32187>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32188>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32189>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32190>>>>>>>>            Increment i
32191>>>>>>>>
32191>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
32192>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
32193>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32194>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32195>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
32196>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32197>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
32198>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32199>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32200>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
32201>>>>>>>>            Increment i
32202>>>>>>>>
32202>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
32203>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
32204>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32205>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32206>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32207>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32208>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32209>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32210>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32211>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32212>>>>>>>>            Increment i
32213>>>>>>>>
32213>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
32214>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
32215>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32216>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32217>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32218>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32219>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
32220>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32221>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32222>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
32223>>>>>>>>            Increment i
32224>>>>>>>>
32224>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
32225>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
32226>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32227>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32228>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
32229>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32230>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32231>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
32232>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
32233>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
32234>>>>>>>>            Increment i
32235>>>>>>>>
32235>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
32236>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
32237>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32238>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32239>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
32240>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
32241>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
32242>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32243>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32244>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
32245>>>>>>>>            Increment i
32246>>>>>>>>
32246>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
32247>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
32248>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32249>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32250>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32251>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32252>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32253>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32254>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32255>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32256>>>>>>>>            Increment i
32257>>>>>>>>
32257>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
32258>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
32259>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32260>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32261>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32262>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32263>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32264>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32265>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32266>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32267>>>>>>>>            Increment i
32268>>>>>>>>
32268>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
32269>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
32270>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32271>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32272>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32273>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32274>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32275>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32276>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32277>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32278>>>>>>>>            Increment i
32279>>>>>>>>
32279>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
32280>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
32281>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32282>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32283>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
32284>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32285>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
32286>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32287>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32288>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
32289>>>>>>>>            Increment i
32290>>>>>>>>
32290>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
32291>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
32292>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32293>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32294>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
32295>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32296>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32297>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32298>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32299>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32300>>>>>>>>            Increment i
32301>>>>>>>>
32301>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
32302>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
32303>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32304>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32305>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
32306>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32307>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
32308>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32309>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32310>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
32311>>>>>>>>            Increment i
32312>>>>>>>>
32312>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
32313>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
32314>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32315>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32316>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32317>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32318>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32319>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32320>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32321>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32322>>>>>>>>            Increment i
32323>>>>>>>>
32323>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
32324>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
32325>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32326>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32327>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32328>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32329>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32330>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
32331>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
32332>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32333>>>>>>>>            Increment i
32334>>>>>>>>
32334>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
32335>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
32336>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32337>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32338>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32339>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32340>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32341>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32342>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32343>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32344>>>>>>>>            Increment i
32345>>>>>>>>
32345>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
32346>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
32347>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32348>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32349>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
32350>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32351>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
32352>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32353>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32354>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
32355>>>>>>>>            Increment i
32356>>>>>>>>
32356>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
32357>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
32358>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32359>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32360>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32361>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32362>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32363>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
32364>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
32365>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32366>>>>>>>>            Increment i
32367>>>>>>>>
32367>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
32368>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
32369>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32370>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32371>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
32372>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32373>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
32374>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32375>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32376>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
32377>>>>>>>>            Increment i
32378>>>>>>>>
32378>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
32379>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
32380>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32381>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32382>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
32383>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32384>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
32385>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32386>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32387>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
32388>>>>>>>>            Increment i
32389>>>>>>>>
32389>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
32390>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
32391>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32392>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32393>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32394>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32395>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32396>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
32397>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
32398>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32399>>>>>>>>            Increment i
32400>>>>>>>>
32400>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
32401>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
32402>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32403>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32404>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
32405>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32406>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32407>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32408>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32409>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32410>>>>>>>>            Increment i
32411>>>>>>>>
32411>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
32412>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
32413>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32414>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32415>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
32416>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
32417>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
32418>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32419>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32420>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
32421>>>>>>>>            Increment i
32422>>>>>>>>
32422>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
32423>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
32424>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32425>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32426>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
32427>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32428>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
32429>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32430>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32431>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
32432>>>>>>>>            Increment i
32433>>>>>>>>
32433>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
32434>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
32435>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32436>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32437>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
32438>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32439>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
32440>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32441>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32442>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
32443>>>>>>>>            Increment i
32444>>>>>>>>
32444>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
32445>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
32446>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32447>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32448>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
32449>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32450>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
32451>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32452>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32453>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
32454>>>>>>>>            Increment i
32455>>>>>>>>
32455>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
32456>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
32457>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32458>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32459>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
32460>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32461>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32462>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32463>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32464>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32465>>>>>>>>            Increment i
32466>>>>>>>>
32466>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
32467>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
32468>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32469>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32470>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
32471>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32472>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32473>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32474>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32475>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32476>>>>>>>>            Increment i
32477>>>>>>>>
32477>>>>>>>>
32477>>>>>>>
32477>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
32477>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
32477>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
32477>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
32477>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
32477>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
32477>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
32477>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
32477>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
32477>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
32477>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
32477>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
32477>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
32477>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
32477>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
32477>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
32477>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
32477>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
32477>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
32477>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
32477>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
32477>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
32477>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
32477>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
32477>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
32477>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
32477>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
32477>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
32477>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
32477>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
32477>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32477>>>>>>>//        Increment i
32477>>>>>>>//
32477>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
32477>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
32477>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32477>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
32477>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
32477>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32477>>>>>>>//        Increment i
32477>>>>>>>
32477>>>>>>>        Function_Return aColumnType
32478>>>>>>>    End_Function
32479>>>>>>>
32479>>>>>>>    // Oracle Data Types
32479>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
32481>>>>>>>        tColumnType[] aColumnType
32481>>>>>>>        tColumnType[] aColumnType
32482>>>>>>>        Integer i
32482>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\ora_drv_DriverDef.inc)
32482>>>>>>>>// Generated By The Database Update Framework
32482>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
32482>>>>>>>>// Driver COLUMN DATA TYPES
32482>>>>>>>>//
32482>>>>>>>>// Created: 2018-03-14 23:47:34.82
32482>>>>>>>>
32482>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
32483>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
32484>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32485>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32486>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32487>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32488>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32489>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32490>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32491>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32492>>>>>>>>            Increment i
32493>>>>>>>>
32493>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
32494>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
32495>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32496>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32497>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32498>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32499>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
32500>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32501>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32502>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
32503>>>>>>>>            Increment i
32504>>>>>>>>
32504>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
32505>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
32506>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32507>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32508>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32509>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32510>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32511>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
32512>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
32513>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32514>>>>>>>>            Increment i
32515>>>>>>>>
32515>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
32516>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
32517>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32518>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32519>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
32520>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
32521>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
32522>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
32523>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
32524>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
32525>>>>>>>>            Increment i
32526>>>>>>>>
32526>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
32527>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
32528>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32529>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32530>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32531>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32532>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32533>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32534>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32535>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32536>>>>>>>>            Increment i
32537>>>>>>>>
32537>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
32538>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
32539>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32540>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32541>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32542>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32543>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32544>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32545>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32546>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32547>>>>>>>>            Increment i
32548>>>>>>>>
32548>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
32549>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
32550>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32551>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32552>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
32553>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32554>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32555>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32556>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32557>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32558>>>>>>>>            Increment i
32559>>>>>>>>
32559>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
32560>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
32561>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32562>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32563>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
32564>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32565>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32566>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32567>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32568>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32569>>>>>>>>            Increment i
32570>>>>>>>>
32570>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
32571>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
32572>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32573>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32574>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32575>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32576>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32577>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32578>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32579>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32580>>>>>>>>            Increment i
32581>>>>>>>>
32581>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
32582>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
32583>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32584>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32585>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32586>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32587>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32588>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32589>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32590>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32591>>>>>>>>            Increment i
32592>>>>>>>>
32592>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
32593>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
32594>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32595>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32596>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32597>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32598>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
32599>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32600>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32601>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
32602>>>>>>>>            Increment i
32603>>>>>>>>
32603>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
32604>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
32605>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32606>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32607>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
32608>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32609>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32610>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
32611>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
32612>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32613>>>>>>>>            Increment i
32614>>>>>>>>
32614>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
32615>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
32616>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32617>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32618>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32619>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32620>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32621>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32622>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32623>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32624>>>>>>>>            Increment i
32625>>>>>>>>
32625>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
32626>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
32627>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32628>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32629>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32630>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32631>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
32632>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32633>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32634>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
32635>>>>>>>>            Increment i
32636>>>>>>>>
32636>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
32637>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
32638>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32639>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32640>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32641>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32642>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
32643>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32644>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32645>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
32646>>>>>>>>            Increment i
32647>>>>>>>>
32647>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
32648>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
32649>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32650>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32651>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
32652>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32653>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32654>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32655>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32656>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32657>>>>>>>>            Increment i
32658>>>>>>>>
32658>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
32659>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
32660>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32661>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32662>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
32663>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32664>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32665>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32666>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32667>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32668>>>>>>>>            Increment i
32669>>>>>>>>
32669>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
32670>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
32671>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32672>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32673>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
32674>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32675>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32676>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32677>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32678>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32679>>>>>>>>            Increment i
32680>>>>>>>>
32680>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
32681>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
32682>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32683>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32684>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32685>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32686>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
32687>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32688>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32689>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
32690>>>>>>>>            Increment i
32691>>>>>>>>
32691>>>>>>>>
32691>>>>>>>
32691>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
32691>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
32691>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
32691>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
32691>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
32691>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
32691>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
32691>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
32691>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
32691>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
32691>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
32691>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
32691>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
32691>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
32691>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
32691>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
32691>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
32691>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
32691>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
32691>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
32691>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
32691>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
32691>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
32691>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
32691>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
32691>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
32691>>>>>>>//        Increment i
32691>>>>>>>//
32691>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
32691>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
32691>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32691>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32691>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32691>>>>>>>
32691>>>>>>>        Function_Return aColumnType
32692>>>>>>>    End_Function
32693>>>>>>>
32693>>>>>>>    // PostgreSQL Data Types
32693>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
32695>>>>>>>        tColumnType[] aColumnType
32695>>>>>>>        tColumnType[] aColumnType
32696>>>>>>>        Integer i
32696>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\mdspgsql_DriverDef.inc)
32696>>>>>>>>// Generated By The Database Update Framework
32696>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
32696>>>>>>>>// Driver COLUMN DATA TYPES
32696>>>>>>>>//
32696>>>>>>>>// Created: 2018-03-14 23:47:02.984
32696>>>>>>>>
32696>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
32697>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
32698>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32699>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32700>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32701>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32702>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32703>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32704>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32705>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32706>>>>>>>>            Increment i
32707>>>>>>>>
32707>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
32708>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
32709>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32710>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32711>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32712>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32713>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32714>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32715>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32716>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32717>>>>>>>>            Increment i
32718>>>>>>>>
32718>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
32719>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
32720>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32721>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32722>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32723>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32724>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32725>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32726>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32727>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32728>>>>>>>>            Increment i
32729>>>>>>>>
32729>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
32730>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
32731>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32732>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32733>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32734>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32735>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32736>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32737>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32738>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32739>>>>>>>>            Increment i
32740>>>>>>>>
32740>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
32741>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
32742>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32743>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32744>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32745>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32746>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32747>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32748>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32749>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32750>>>>>>>>            Increment i
32751>>>>>>>>
32751>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
32752>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
32753>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32754>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32755>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32756>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32757>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32758>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32759>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32760>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32761>>>>>>>>            Increment i
32762>>>>>>>>
32762>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
32763>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
32764>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32765>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32766>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
32767>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32768>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32769>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
32770>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
32771>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
32772>>>>>>>>            Increment i
32773>>>>>>>>
32773>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
32774>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
32775>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32776>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32777>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32778>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32779>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32780>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32781>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32782>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32783>>>>>>>>            Increment i
32784>>>>>>>>
32784>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
32785>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
32786>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32787>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32788>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
32789>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32790>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
32791>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32792>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32793>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
32794>>>>>>>>            Increment i
32795>>>>>>>>
32795>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
32796>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
32797>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32798>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32799>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
32800>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32801>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
32802>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32803>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32804>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
32805>>>>>>>>            Increment i
32806>>>>>>>>
32806>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
32807>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
32808>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32809>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32810>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
32811>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32812>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
32813>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32814>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32815>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
32816>>>>>>>>            Increment i
32817>>>>>>>>
32817>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
32818>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
32819>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32820>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32821>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
32822>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32823>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32824>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
32825>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
32826>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32827>>>>>>>>            Increment i
32828>>>>>>>>
32828>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
32829>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
32830>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32831>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32832>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
32833>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32834>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
32835>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32836>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32837>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
32838>>>>>>>>            Increment i
32839>>>>>>>>
32839>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
32840>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
32841>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32842>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32843>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
32844>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32845>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32846>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32847>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32848>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32849>>>>>>>>            Increment i
32850>>>>>>>>
32850>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
32851>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
32852>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32853>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32854>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
32855>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32856>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
32857>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
32858>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
32859>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
32860>>>>>>>>            Increment i
32861>>>>>>>>
32861>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
32862>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
32863>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32864>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32865>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32866>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32867>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32868>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32869>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32870>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32871>>>>>>>>            Increment i
32872>>>>>>>>
32872>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
32873>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
32874>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32875>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32876>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
32877>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
32878>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
32879>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32880>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32881>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
32882>>>>>>>>            Increment i
32883>>>>>>>>
32883>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
32884>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
32885>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32886>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32887>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
32888>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32889>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32890>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
32891>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
32892>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32893>>>>>>>>            Increment i
32894>>>>>>>>
32894>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
32895>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
32896>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32897>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32898>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
32899>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32900>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32901>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32902>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32903>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32904>>>>>>>>            Increment i
32905>>>>>>>>
32905>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
32906>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
32907>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
32908>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32909>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
32910>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
32911>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
32912>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32913>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32914>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
32915>>>>>>>>            Increment i
32916>>>>>>>>
32916>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
32917>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
32918>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32919>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32920>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32921>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32922>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32923>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32924>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32925>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32926>>>>>>>>            Increment i
32927>>>>>>>>
32927>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
32928>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
32929>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
32930>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
32931>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
32932>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
32933>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
32934>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
32935>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
32936>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
32937>>>>>>>>            Increment i
32938>>>>>>>>
32938>>>>>>>>
32938>>>>>>>
32938>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
32938>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
32938>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
32938>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
32938>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
32938>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
32938>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
32938>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
32938>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
32938>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
32938>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
32938>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
32938>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
32938>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
32938>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
32938>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
32938>>>>>>>//        Increment i
32938>>>>>>>//
32938>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
32938>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
32938>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
32938>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
32938>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
32938>>>>>>>//        Increment i
32938>>>>>>>
32938>>>>>>>        Function_Return aColumnType
32939>>>>>>>    End_Function
32940>>>>>>>
32940>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
32940>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
32942>>>>>>>        Integer iValue iSize iCount iStart
32942>>>>>>>        tColumnType[] ColumnTypeArray
32942>>>>>>>        tColumnType[] ColumnTypeArray
32943>>>>>>>        tColumnType RetvalType
32943>>>>>>>        tColumnType RetvalType
32943>>>>>>>        String sValue
32943>>>>>>>        Boolean bFrameworkDataFlexType
32943>>>>>>>
32943>>>>>>>        Move "Undefined" to RetvalType.sSQLType
32944>>>>>>>        Move -1999       to RetvalType.iSQLType
32945>>>>>>>
32945>>>>>>>        Move 0 to iStart
32946>>>>>>>        Move (Uppercase(sType)) to sType
32947>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
32948>>>>>>>        If (bFrameworkDataFlexType = True) Begin
32950>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
32951>>>>>>>            Function_Return RetvalType
32952>>>>>>>        End
32952>>>>>>>>
32952>>>>>>>
32952>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
32953>>>>>>>
32953>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
32954>>>>>>>        Decrement iSize
32955>>>>>>>
32955>>>>>>>        for iCount from iStart to iSize
32961>>>>>>>>
32961>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
32962>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
32963>>>>>>>            If (bIntegerInputType = True) Begin
32965>>>>>>>                If (iValue = iType) Begin
32967>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
32968>>>>>>>                    Move iType                                  to RetvalType.iSQLType
32969>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
32970>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
32971>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
32972>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
32973>>>>>>>                    Move iSize to iCount // We're done!
32974>>>>>>>                End
32974>>>>>>>>
32974>>>>>>>            End
32974>>>>>>>>
32974>>>>>>>            Else Begin
32975>>>>>>>                Move (Uppercase(sValue)) to sValue
32976>>>>>>>                If (sValue = sType) Begin
32978>>>>>>>                    Move sType                                  to RetvalType.sSQLType
32979>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
32980>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
32981>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
32982>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
32983>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
32984>>>>>>>                    Move iSize to iCount // We're done!
32985>>>>>>>                End
32985>>>>>>>>
32985>>>>>>>            End
32985>>>>>>>>
32985>>>>>>>        Loop
32986>>>>>>>>
32986>>>>>>>
32986>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
32986>>>>>>>        // In which case we search for a match in DataFlex standard types:
32986>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
32988>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
32989>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
32990>>>>>>>            Decrement iSize
32991>>>>>>>
32991>>>>>>>            for iCount from iStart to iSize
32997>>>>>>>>
32997>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
32998>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
32999>>>>>>>                If (iValue = iType) Begin
33001>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
33002>>>>>>>                    Move iType                                  to RetvalType.iSQLType
33003>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
33004>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
33005>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
33006>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
33007>>>>>>>                    Move iSize to iCount // We're done!
33008>>>>>>>                End
33008>>>>>>>>
33008>>>>>>>            Loop
33009>>>>>>>>
33009>>>>>>>        End
33009>>>>>>>>
33009>>>>>>>
33009>>>>>>>        Function_Return RetvalType
33010>>>>>>>    End_Function
33011>>>>>>>
33011>>>>>>>    Function _AllTablesToConvert Returns Integer[]
33013>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
33015>>>>>>>        Handle hTable
33015>>>>>>>        Integer iIndex
33015>>>>>>>        String sTableName
33015>>>>>>>        Boolean bFlexErrs
33015>>>>>>>
33015>>>>>>>        // a) Get the exception table array the developer has specified
33015>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
33016>>>>>>>
33016>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
33016>>>>>>>        Repeat
33016>>>>>>>>
33016>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
33019>>>>>>>            If (hTable <> 0) Begin
33021>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
33024>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
33025>>>>>>>                If (bFlexErrs = False) Begin
33027>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
33029>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
33030>>>>>>>                        If (iIndex = -1) Begin
33032>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
33033>>>>>>>                        End
33033>>>>>>>>
33033>>>>>>>                    End
33033>>>>>>>>
33033>>>>>>>                End
33033>>>>>>>>
33033>>>>>>>            End
33033>>>>>>>>
33033>>>>>>>        Until (hTable = 0)
33035>>>>>>>
33035>>>>>>>        Move 0 to hTable
33036>>>>>>>
33036>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
33036>>>>>>>        Repeat
33036>>>>>>>>
33036>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
33039>>>>>>>            If (hTable > 0) Begin
33041>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
33044>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
33045>>>>>>>                If (bFlexErrs = False) Begin
33047>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
33048>>>>>>>                    If (iIndex = -1) Begin
33050>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
33051>>>>>>>                    End
33051>>>>>>>>
33051>>>>>>>                End
33051>>>>>>>>
33051>>>>>>>            End
33051>>>>>>>>
33051>>>>>>>        Until (hTable = 0)
33053>>>>>>>
33053>>>>>>>        Function_Return iTablesArray
33054>>>>>>>    End_Function
33055>>>>>>>
33055>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
33057>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
33059>>>>>>>        Handle hTable
33059>>>>>>>        Integer iIndex
33059>>>>>>>        String sTableName
33059>>>>>>>        Boolean bFlexErrs
33059>>>>>>>
33059>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
33060>>>>>>>        Move 0 to hTable
33061>>>>>>>
33061>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
33061>>>>>>>        Repeat
33061>>>>>>>>
33061>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
33064>>>>>>>            If (hTable > 0) Begin
33066>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
33069>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
33070>>>>>>>                If (bFlexErrs = False) Begin
33072>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
33073>>>>>>>                    If (iIndex = -1) Begin
33075>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
33076>>>>>>>                    End
33076>>>>>>>>
33076>>>>>>>                End
33076>>>>>>>>
33076>>>>>>>            End
33076>>>>>>>>
33076>>>>>>>        Until (hTable = 0)
33078>>>>>>>
33078>>>>>>>        Function_Return iTablesArray
33079>>>>>>>    End_Function
33080>>>>>>>
33080>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
33082>>>>>>>        tAPIColumn NewAPIColumn
33082>>>>>>>        tAPIColumn NewAPIColumn
33082>>>>>>>
33082>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
33083>>>>>>>        Move iType      to NewAPIColumn.iType
33084>>>>>>>        Move iLength    to NewAPIColumn.iLength
33085>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
33086>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
33087>>>>>>>
33087>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
33088>>>>>>>
33088>>>>>>>        Function_Return aCurrent
33089>>>>>>>    End_Function
33090>>>>>>>
33090>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
33092>>>>>>>        String sRetval sFieldName
33092>>>>>>>        Integer iCount iSize
33092>>>>>>>
33092>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
33093>>>>>>>        Decrement iSize
33094>>>>>>>        for iCount from 0 to iSize
33100>>>>>>>>
33100>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
33101>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
33102>>>>>>>        Loop
33103>>>>>>>>
33103>>>>>>>        Move (Trim(sRetval)) to sRetval
33104>>>>>>>
33104>>>>>>>        Function_Return sRetval
33105>>>>>>>    End_Function
33106>>>>>>>
33106>>>>>>>    // *** Miscellaneous other functions ***
33106>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
33106>>>>>>>    //
33106>>>>>>>
33106>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
33106>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
33108>>>>>>>        Integer iPerc
33108>>>>>>>        Number nReady nTotal
33108>>>>>>>
33108>>>>>>>        Send DoAdvance of ghoProgressBar
33109>>>>>>>
33109>>>>>>>        If (sCallback_Text contains "Copy records") Begin
33111>>>>>>>            Move CS_SQLCopyingData to sCallback_Text
33112>>>>>>>        End
33112>>>>>>>>
33112>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
33114>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
33115>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
33116>>>>>>>        End
33116>>>>>>>>
33116>>>>>>>        If (sCallback_Text contains "Creating index") Begin
33118>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
33119>>>>>>>        End
33119>>>>>>>>
33119>>>>>>>
33119>>>>>>>        Case Begin
33119>>>>>>>            Case (iCallback_Type = DF_Message_Text)
33121>>>>>>>//                Set Message_Text of ghoStatusPanel to sCallback_Text
33121>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
33122>>>>>>>                Case Break
33123>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
33126>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
33127>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
33128>>>>>>>                Case Break
33129>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
33132>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
33133>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
33134>>>>>>>                Case Break
33135>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
33138>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
33139>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
33140>>>>>>>                Case Break
33141>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
33144>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
33145>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
33146>>>>>>>                Case Break
33147>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
33150>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
33151>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
33152>>>>>>>                Case Break
33153>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
33156>>>>>>>                Send None
33157>>>>>>>                Case Break
33158>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
33161>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
33162>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
33163>>>>>>>                Case Break
33164>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
33167>>>>>>>                //*** Interpret numbers
33167>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
33168>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
33169>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
33170>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
33171>>>>>>>                Case Break
33172>>>>>>>            Case Else
33172>>>>>>>                Set Message_Text to ""
33173>>>>>>>                Set Action_Text  to ""
33174>>>>>>>        Case End
33174>>>>>>>
33174>>>>>>>        Send ProcessEvents of ghoStatusPanel
33175>>>>>>>        Function_Return False
33176>>>>>>>    End_Function
33177>>>>>>>
33177>>>>>>>    Procedure IncreaseSortBufferSize
33179>>>>>>>        String sNull
33179>>>>>>>        Integer iSortBufferSize
33179>>>>>>>        Boolean bBufferSet
33179>>>>>>>
33179>>>>>>>        Move "" to sNull
33180>>>>>>>        Move (1024 * 128) to iSortBufferSize
33181>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
33186>>>>>>>
33186>>>>>>>    End_Procedure
33187>>>>>>>
33187>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
33189>>>>>>>        Integer iLastIndex iIndex iNumSegments
33189>>>>>>>        Boolean bOK
33189>>>>>>>        String sDriverID
33189>>>>>>>
33189>>>>>>>        If (hTable > 0) Begin
33191>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
33192>>>>>>>            Close hTable
33193>>>>>>>            Get OpenTableExclusive hTable to bOK
33194>>>>>>>            If (bOK = False) Begin
33196>>>>>>>                Procedure_Return
33197>>>>>>>            End
33197>>>>>>>>
33197>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
33200>>>>>>>            Structure_Start hTable sDriverID
33201>>>>>>>                for iIndex from 1 to iLastIndex
33207>>>>>>>>
33207>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
33210>>>>>>>                    If (iNumSegments > 0) Begin
33212>>>>>>>                        If (bSetToBatch = True) Begin
33214>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
33217>>>>>>>                        End
33217>>>>>>>>
33217>>>>>>>                        Else Begin
33218>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
33221>>>>>>>                        End
33221>>>>>>>>
33221>>>>>>>                    End
33221>>>>>>>>
33221>>>>>>>                Loop
33222>>>>>>>>
33222>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
33224>>>>>>>        End
33224>>>>>>>>
33224>>>>>>>    End_Procedure
33225>>>>>>>
33225>>>>>>>    Function NextFreeFilelistSlot Returns Handle
33227>>>>>>>        Handle hTable
33227>>>>>>>
33227>>>>>>>        Move 0 to hTable
33228>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
33231>>>>>>>
33231>>>>>>>        Function_Return hTable
33232>>>>>>>    End_Function
33233>>>>>>>
33233>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
33233>>>>>>>    Procedure DebugPrint String sStmt String sFileName
33235>>>>>>>        Integer iCh
33235>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
33236>>>>>>>            Write channel iCh sStmt
33238>>>>>>>        Send Seq_Close_Channel iCh
33239>>>>>>>    End_Procedure
33240>>>>>>>
33240>>>>>>>    // Returns the integer number for the passed Driver ID that is
33240>>>>>>>    // needed by some database API calls.
33240>>>>>>>    Function DriverIndex String sDriverID Returns Integer
33242>>>>>>>        String  sCurrentDriver
33242>>>>>>>        Integer iNumberOfDrivers iDriver iCount
33242>>>>>>>
33242>>>>>>>        Move 0 to iDriver
33243>>>>>>>
33243>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
33246>>>>>>>        for iCount from 1 to iNumberOfDrivers
33252>>>>>>>>
33252>>>>>>>
33252>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
33255>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
33257>>>>>>>                Move iCount to iDriver
33258>>>>>>>            End
33258>>>>>>>>
33258>>>>>>>        Loop
33259>>>>>>>>
33259>>>>>>>
33259>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
33259>>>>>>>        If (iDriver = 0) Begin
33261>>>>>>>            Move False to Err
33262>>>>>>>            Load_Driver sDriverID
33263>>>>>>>            If (Err = False) Begin
33265>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
33268>>>>>>>            End
33268>>>>>>>>
33268>>>>>>>        End
33268>>>>>>>>
33268>>>>>>>
33268>>>>>>>        Function_Return iDriver
33269>>>>>>>    End_Function
33270>>>>>>>
33270>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
33270>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
33270>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
33270>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
33272>>>>>>>        Integer iMode
33272>>>>>>>        Boolean bOpened
33272>>>>>>>        String sTableName
33272>>>>>>>
33272>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33273>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
33276>>>>>>>        If (bOpened) Begin
33278>>>>>>>            If (IsDebuggerPresent()) Begin
33280>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
33283>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
33285>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
33286>>>>>>>                    Function_Return True
33287>>>>>>>                End
33287>>>>>>>>
33287>>>>>>>            End
33287>>>>>>>>
33287>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
33290>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
33292>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
33293>>>>>>>                Function_Return True
33294>>>>>>>            End
33294>>>>>>>>
33294>>>>>>>            Close hTable
33295>>>>>>>        End
33295>>>>>>>>
33295>>>>>>>        Else Begin
33296>>>>>>>            Open hTable
33298>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
33301>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
33303>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
33306>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
33308>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
33309>>>>>>>                    Function_Return True
33310>>>>>>>                End
33310>>>>>>>>
33310>>>>>>>            End
33310>>>>>>>>
33310>>>>>>>
33310>>>>>>>        End
33310>>>>>>>>
33310>>>>>>>
33310>>>>>>>        Close hTable
33311>>>>>>>        Open hTable Mode DF_EXCLUSIVE
33313>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
33316>>>>>>>
33316>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
33317>>>>>>>        Function_Return bOpened
33318>>>>>>>    End_Function
33319>>>>>>>
33319>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
33321>>>>>>>        String sConnectionID sConnectionString sDriverID
33321>>>>>>>        Boolean bExists bOK bSQLDriver bMertech
33321>>>>>>>        Handle hoCLI hoDriver
33321>>>>>>>        Integer iRetval
33321>>>>>>>        tSQLConnection SQLConnection
33321>>>>>>>        tSQLConnection SQLConnection
33321>>>>>>>
33321>>>>>>>        Get psDriverID to sDriverID
33322>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
33323>>>>>>>        If (bSQLDriver = False) Begin
33325>>>>>>>            Function_Return True
33326>>>>>>>        End
33326>>>>>>>>
33326>>>>>>>
33326>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
33327>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
33328>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
33329>>>>>>>        Get IsMertechDriver sDriverID to bMertech
33330>>>>>>>        If (bMertech = True) Begin
33332>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
33333>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
33334>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
33335>>>>>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
33336>>>>>>>            Send Destroy of hoDriver
33337>>>>>>>            Function_Return bOK
33338>>>>>>>        End
33338>>>>>>>>
33338>>>>>>>
33338>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
33339>>>>>>>
33339>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
33340>>>>>>>        If (bExists = False) Begin
33342>>>>>>>            // We always start by deleting the current connection - if any - because the
33342>>>>>>>            // login details my have changed.
33342>>>>>>>            Get phoCLIHandler to hoCLI
33343>>>>>>>            Set psDriverID    of hoCLI to sDriverID
33344>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
33345>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
33346>>>>>>>            If (bOk = False) Begin
33348>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
33349>>>>>>>>
33349>>>>>>>                Function_Return False
33350>>>>>>>            End
33350>>>>>>>>
33350>>>>>>>            Move bOK to bExists
33351>>>>>>>        End
33351>>>>>>>>
33351>>>>>>>
33351>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
33352>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
33353>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
33354>>>>>>>        Send Destroy of hoDriver
33355>>>>>>>
33355>>>>>>>        Function_Return (bExists = True)
33356>>>>>>>    End_Function
33357>>>>>>>
33357>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
33357>>>>>>>    // Returns: False if nobody else is running
33357>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
33357>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
33357>>>>>>>    //      tables are not locked as DataFlex tables are.
33357>>>>>>>    Function IsDatabaseInUse Returns Boolean
33359>>>>>>>        Handle  hTable
33359>>>>>>>        String  sRootName
33359>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs
33359>>>>>>>        Integer iCount iTables
33359>>>>>>>
33359>>>>>>>        Move 0 to iTables
33360>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
33361>>>>>>>        Get AutoConnectionIDLogin to bOK
33362>>>>>>>        Get UtilFilelistNoOfTables to iTables
33363>>>>>>>        Set piPosition   of ghoProgressBar to 0
33364>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
33365>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
33366>>>>>>>        Move 0 to hTable
33367>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
33370>>>>>>>        Move False to bErr
33371>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
33372>>>>>>>
33372>>>>>>>        Repeat
33372>>>>>>>>
33372>>>>>>>            Set piPosition of ghoProgressBar to iCount
33373>>>>>>>            Increment iCount
33374>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
33377>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
33378>>>>>>>
33378>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
33378>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
33379>>>>>>>            Move False to bOpen
33380>>>>>>>
33380>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
33380>>>>>>>            If (bIsSQLTable = False and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
33382>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
33383>>>>>>>                Open hTable
33385>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
33388>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
33389>>>>>>>                If (bOpen = True) Begin
33391>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
33391>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
33392>>>>>>>                    If (bAlias = False) Begin
33394>>>>>>>                        Close hTable
33395>>>>>>>                        Get OpenTableExclusive hTable to bOpen
33396>>>>>>>                        If (bOpen = False) Begin
33398>>>>>>>                            Move True to bErr
33399>>>>>>>                        End
33399>>>>>>>>
33399>>>>>>>                    End
33399>>>>>>>>
33399>>>>>>>                End
33399>>>>>>>>
33399>>>>>>>                Close hTable
33400>>>>>>>            End
33400>>>>>>>>
33400>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
33403>>>>>>>            If (bErr = True ) ;                Break
33406>>>>>>>        Until (not(hTable))
33408>>>>>>>
33408>>>>>>>        Set Action_Text of ghoStatusPanel to ""
33409>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
33410>>>>>>>        Move False to Err
33411>>>>>>>
33411>>>>>>>        Function_Return bErr
33412>>>>>>>    End_Function
33413>>>>>>>
33413>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
33413>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
33413>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
33413>>>>>>>    // NOTE: Only applicable for DAW drivers.
33413>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
33415>>>>>>>        String sID sConnString
33415>>>>>>>        Integer iDriver iNumConn iCount
33415>>>>>>>        Handle hoCLI
33415>>>>>>>        Boolean bOK
33415>>>>>>>
33415>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
33416>>>>>>>        If (bOK = False) Begin
33418>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
33419>>>>>>>>
33419>>>>>>>            Function_Return False
33420>>>>>>>        End
33420>>>>>>>>
33420>>>>>>>
33420>>>>>>>        Move False to bOK
33421>>>>>>>        Get phoCLIHandler to hoCLI
33422>>>>>>>        If (hoCLI <> 0) Begin
33424>>>>>>>            Set psDriverID of hoCLI to sDriverID
33425>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
33426>>>>>>>
33426>>>>>>>            // If driver not loaded; load it.
33426>>>>>>>            If (iDriver = 0) Begin
33428>>>>>>>                Load_Driver sDriverID
33429>>>>>>>                Get DriverIndex sDriverID to iDriver
33430>>>>>>>            End
33430>>>>>>>>
33430>>>>>>>            If (iDriver <> 0) Begin
33432>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
33435>>>>>>>                Decrement iNumConn
33436>>>>>>>                for iCount from 0 to iNumConn
33442>>>>>>>>
33442>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
33445>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
33448>>>>>>>                    If (sID = sConnectionID) Begin
33450>>>>>>>                        Move True to bOK
33451>>>>>>>                    End
33451>>>>>>>>
33451>>>>>>>                Loop
33452>>>>>>>>
33452>>>>>>>            End
33452>>>>>>>>
33452>>>>>>>        End
33452>>>>>>>>
33452>>>>>>>
33452>>>>>>>        Function_Return bOK
33453>>>>>>>    End_Function
33454>>>>>>>
33454>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
33456>>>>>>>        Boolean bOK
33456>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
33457>>>>>>>        Function_Return bOK
33458>>>>>>>    End_Function
33459>>>>>>>
33459>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
33461>>>>>>>        Boolean bOK
33461>>>>>>>        Move False to bOK
33462>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
33463>>>>>>>        Function_Return bOK
33464>>>>>>>    End_Function
33465>>>>>>>
33465>>>>>>>    Function IsMSSQLDriver Returns Boolean
33467>>>>>>>        Integer iDriverIndex
33467>>>>>>>
33467>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
33468>>>>>>>
33468>>>>>>>        Function_Return (iDriverIndex <> 0)
33469>>>>>>>    End_Function
33470>>>>>>>
33470>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
33470>>>>>>>    // attempt to load the driver.
33470>>>>>>>    // Returns true if the passed driver is SQL based.
33470>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
33472>>>>>>>        Boolean bOK
33472>>>>>>>
33472>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
33473>>>>>>>
33473>>>>>>>        If (bOK = False) Begin
33475>>>>>>>            Get IsMertechDriver sDriverID to bOK
33476>>>>>>>        End
33476>>>>>>>>
33476>>>>>>>
33476>>>>>>>        Function_Return bOK
33477>>>>>>>    End_Function
33478>>>>>>>
33478>>>>>>>    // *** Error Handler ***
33478>>>>>>>    //
33478>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
33478>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
33478>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
33480>>>>>>>        Integer iSize iErrorMode
33480>>>>>>>        tSqlErrorArray aSqlErrorArray
33480>>>>>>>        tSqlErrorArray aSqlErrorArray
33480>>>>>>>
33480>>>>>>>        If (pbProcessingError(Self)) Begin
33482>>>>>>>            Procedure_Return
33483>>>>>>>        End
33483>>>>>>>>
33483>>>>>>>
33483>>>>>>>        Get Error_Report_Mode to iErrorMode
33484>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
33486>>>>>>>            Procedure_Return
33487>>>>>>>        End
33487>>>>>>>>
33487>>>>>>>
33487>>>>>>>        Set pbProcessingError to True
33488>>>>>>>        Set pbSqlError to True
33489>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
33490>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
33491>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
33492>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
33493>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
33494>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
33495>>>>>>>        Set pbProcessingError to False
33496>>>>>>>    End_Procedure
33497>>>>>>>
33497>>>>>>>    // *** Miscellanous Helper Functions ***
33497>>>>>>>    //
33497>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
33497>>>>>>>    // returns the table name only; stripped of any path or filename extension.
33497>>>>>>>    Function _TableNameOnly String sName Returns String
33499>>>>>>>        String sPath sExt
33499>>>>>>>
33499>>>>>>>        Get ParseFolderName sName to sPath
33500>>>>>>>        If (sPath <> "") Begin
33502>>>>>>>            Move (Replace(sPath, sName, "")) to sName
33503>>>>>>>        End
33503>>>>>>>>
33503>>>>>>>        Get ParseFileExtension sName to sExt
33504>>>>>>>        If (sExt <> "") Begin
33506>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
33507>>>>>>>        End
33507>>>>>>>>
33507>>>>>>>
33507>>>>>>>        Function_Return sName
33508>>>>>>>    End_Function
33509>>>>>>>
33509>>>>>>>    // Removes any prefix to a table name.
33509>>>>>>>    // Example mssqldrv:mytable returns mytable
33509>>>>>>>    //         dbo.mytable returns mytable
33509>>>>>>>    Function _TableNoPrefix String sName Returns String
33511>>>>>>>        Integer iPos
33511>>>>>>>
33511>>>>>>>        Move (Pos(":", sName)) to iPos
33512>>>>>>>        If (iPos <> 0) Begin
33514>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
33515>>>>>>>        End
33515>>>>>>>>
33515>>>>>>>        Move (Pos(".", sName)) to iPos
33516>>>>>>>        If (iPos <> 0) Begin
33518>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
33519>>>>>>>        End
33519>>>>>>>>
33519>>>>>>>
33519>>>>>>>        Function_Return sName
33520>>>>>>>    End_Function
33521>>>>>>>
33521>>>>>>>    // Returns the first datapath found in the psDataPath property.
33521>>>>>>>    // The returned path always ends with a "\"
33521>>>>>>>    Function psDataPathFirstPart Returns String
33523>>>>>>>        String sDataPath
33523>>>>>>>        Integer iCount
33523>>>>>>>
33523>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
33524>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
33525>>>>>>>        If (iCount > 1) Begin
33527>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
33528>>>>>>>        End
33528>>>>>>>>
33528>>>>>>>        If (sDataPath <> "") Begin
33530>>>>>>>            Get vFolderFormat sDataPath to sDataPath
33531>>>>>>>        End
33531>>>>>>>>
33531>>>>>>>
33531>>>>>>>        Function_Return sDataPath
33532>>>>>>>    End_Function
33533>>>>>>>
33533>>>>>>>    Function psLogTextFileWithPath Returns String
33535>>>>>>>        String sFileName
33535>>>>>>>        Handle hoLogFile
33535>>>>>>>        Get phoLogFile to hoLogFile
33536>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
33537>>>>>>>        Function_Return sFileName
33538>>>>>>>    End_Function
33539>>>>>>>
33539>>>>>>>    // *** Property Messages ***
33539>>>>>>>    //
33539>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
33539>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
33539>>>>>>>    //
33539>>>>>>>
33539>>>>>>>    Function pSQLConnection Returns tSQLConnection
33541>>>>>>>        tSQLConnection SQLConnection
33541>>>>>>>        tSQLConnection SQLConnection
33541>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33543>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
33543>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33544>>>>>>>>
33544>>>>>>>            Function_Return
33545>>>>>>>        End
33545>>>>>>>>
33545>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
33546>>>>>>>        Function_Return SQLConnection
33547>>>>>>>    End_Function
33548>>>>>>>
33548>>>>>>>    // * Dummy function for the Studio's Code Explorer *
33548>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
33550>>>>>>>        Function_Return False
33551>>>>>>>    End_Function
33552>>>>>>>
33552>>>>>>>    Procedure Set psServer String sValue
33554>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33556>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
33556>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33557>>>>>>>>
33557>>>>>>>            Procedure_Return
33558>>>>>>>        End
33558>>>>>>>>
33558>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
33559>>>>>>>    End_Procedure
33560>>>>>>>
33560>>>>>>>    Function psServer Returns String
33562>>>>>>>        String sValue
33562>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33564>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33565>>>>>>>>
33565>>>>>>>            Function_Return
33566>>>>>>>        End
33566>>>>>>>>
33566>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
33567>>>>>>>        Function_Return sValue
33568>>>>>>>    End_Function
33569>>>>>>>
33569>>>>>>>    Procedure Set psDatabase String sValue
33571>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33573>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33574>>>>>>>>
33574>>>>>>>            Procedure_Return
33575>>>>>>>        End
33575>>>>>>>>
33575>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
33576>>>>>>>    End_Procedure
33577>>>>>>>
33577>>>>>>>    Function psDatabase Returns String
33579>>>>>>>        String sValue
33579>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33581>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33582>>>>>>>>
33582>>>>>>>            Function_Return
33583>>>>>>>        End
33583>>>>>>>>
33583>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
33584>>>>>>>        Function_Return sValue
33585>>>>>>>    End_Function
33586>>>>>>>
33586>>>>>>>    Procedure Set psUserID String sValue
33588>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33590>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33591>>>>>>>>
33591>>>>>>>            Procedure_Return
33592>>>>>>>        End
33592>>>>>>>>
33592>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
33593>>>>>>>    End_Procedure
33594>>>>>>>
33594>>>>>>>    Function psUserID Returns String
33596>>>>>>>        String sValue
33596>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33598>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33599>>>>>>>>
33599>>>>>>>            Function_Return
33600>>>>>>>        End
33600>>>>>>>>
33600>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
33601>>>>>>>        Function_Return sValue
33602>>>>>>>    End_Function
33603>>>>>>>
33603>>>>>>>    Procedure Set psPassword String sValue
33605>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33607>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33608>>>>>>>>
33608>>>>>>>            Procedure_Return
33609>>>>>>>        End
33609>>>>>>>>
33609>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
33610>>>>>>>    End_Procedure
33611>>>>>>>
33611>>>>>>>    Function psPassword Returns String
33613>>>>>>>        String sValue
33613>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33615>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33616>>>>>>>>
33616>>>>>>>            Function_Return
33617>>>>>>>        End
33617>>>>>>>>
33617>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
33618>>>>>>>        Function_Return sValue
33619>>>>>>>    End_Function
33620>>>>>>>
33620>>>>>>>    Procedure Set pbTrusted Boolean bValue
33622>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33624>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33625>>>>>>>>
33625>>>>>>>            Procedure_Return
33626>>>>>>>        End
33626>>>>>>>>
33626>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
33627>>>>>>>    End_Procedure
33628>>>>>>>
33628>>>>>>>    Function pbTrusted Returns Boolean
33630>>>>>>>        Boolean bValue
33630>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33632>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33633>>>>>>>>
33633>>>>>>>            Function_Return
33634>>>>>>>        End
33634>>>>>>>>
33634>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
33635>>>>>>>        Function_Return bValue
33636>>>>>>>    End_Function
33637>>>>>>>
33637>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
33639>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33641>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33642>>>>>>>>
33642>>>>>>>            Procedure_Return
33643>>>>>>>        End
33643>>>>>>>>
33643>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
33644>>>>>>>    End_Procedure
33645>>>>>>>
33645>>>>>>>    Function pbSilentLogin Returns Boolean
33647>>>>>>>        Boolean bValue
33647>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33649>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33650>>>>>>>>
33650>>>>>>>            Function_Return
33651>>>>>>>        End
33651>>>>>>>>
33651>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
33652>>>>>>>        Function_Return bValue
33653>>>>>>>    End_Function
33654>>>>>>>
33654>>>>>>>    Procedure Set psConnectionID String sValue
33656>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33658>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33659>>>>>>>>
33659>>>>>>>            Procedure_Return
33660>>>>>>>        End
33660>>>>>>>>
33660>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
33661>>>>>>>    End_Procedure
33662>>>>>>>
33662>>>>>>>    Function psConnectionID Returns String
33664>>>>>>>        String sValue
33664>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33666>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33667>>>>>>>>
33667>>>>>>>            Function_Return
33668>>>>>>>        End
33668>>>>>>>>
33668>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
33669>>>>>>>        Function_Return sValue
33670>>>>>>>    End_Function
33671>>>>>>>
33671>>>>>>>    Procedure Set psConnectionString String sValue
33673>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33675>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33676>>>>>>>>
33676>>>>>>>            Procedure_Return
33677>>>>>>>        End
33677>>>>>>>>
33677>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
33678>>>>>>>    End_Procedure
33679>>>>>>>
33679>>>>>>>    Function psConnectionString Returns String
33681>>>>>>>        String sValue
33681>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33683>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33684>>>>>>>>
33684>>>>>>>            Function_Return
33685>>>>>>>        End
33685>>>>>>>>
33685>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
33686>>>>>>>        Function_Return sValue
33687>>>>>>>    End_Function
33688>>>>>>>
33688>>>>>>>    // The normal connection string looks something like this;
33688>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
33688>>>>>>>    // ...and the full connection string looks like this;
33688>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
33688>>>>>>>    Function psFullConnectionString Returns String
33690>>>>>>>        String sConnectionID sConnectionString
33690>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33692>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33693>>>>>>>>
33693>>>>>>>            Function_Return
33694>>>>>>>        End
33694>>>>>>>>
33694>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
33695>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
33696>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
33697>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
33698>>>>>>>    End_Function
33699>>>>>>>
33699>>>>>>>    Function piConnectionOptions Returns Integer
33701>>>>>>>        Integer iValue
33701>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33703>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33704>>>>>>>>
33704>>>>>>>            Function_Return
33705>>>>>>>        End
33705>>>>>>>>
33705>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
33706>>>>>>>        Function_Return iValue
33707>>>>>>>    End_Function
33708>>>>>>>
33708>>>>>>>    Procedure Set psSchema String sValue
33710>>>>>>>        tSQLConnection SQLConnection
33710>>>>>>>        tSQLConnection SQLConnection
33710>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33712>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33713>>>>>>>>
33713>>>>>>>            Procedure_Return
33714>>>>>>>        End
33714>>>>>>>>
33714>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
33715>>>>>>>    End_Procedure
33716>>>>>>>
33716>>>>>>>    Function psSchema Returns String
33718>>>>>>>        String sRetval
33718>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33720>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33721>>>>>>>>
33721>>>>>>>            Function_Return
33722>>>>>>>        End
33722>>>>>>>>
33722>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
33723>>>>>>>        Function_Return sRetval
33724>>>>>>>    End_Function
33725>>>>>>>
33725>>>>>>>    Procedure Set psBaseTableSpace String sValue
33727>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33729>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33730>>>>>>>>
33730>>>>>>>            Procedure_Return
33731>>>>>>>        End
33731>>>>>>>>
33731>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
33732>>>>>>>    End_Procedure
33733>>>>>>>
33733>>>>>>>    Function psBaseTableSpace Returns String
33735>>>>>>>        String sRetval
33735>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33737>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33738>>>>>>>>
33738>>>>>>>            Function_Return
33739>>>>>>>        End
33739>>>>>>>>
33739>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
33740>>>>>>>        Function_Return sRetval
33741>>>>>>>    End_Function
33742>>>>>>>
33742>>>>>>>    Procedure Set psLongTableSpace String sValue
33744>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33746>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33747>>>>>>>>
33747>>>>>>>            Procedure_Return
33748>>>>>>>        End
33748>>>>>>>>
33748>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
33749>>>>>>>    End_Procedure
33750>>>>>>>
33750>>>>>>>    Function psLongTableSpace Returns String
33752>>>>>>>        String sRetval
33752>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33754>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33755>>>>>>>>
33755>>>>>>>            Function_Return
33756>>>>>>>        End
33756>>>>>>>>
33756>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
33757>>>>>>>        Function_Return sRetval
33758>>>>>>>    End_Function
33759>>>>>>>
33759>>>>>>>    Procedure Set psIndexTableSpace String sValue
33761>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33763>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33764>>>>>>>>
33764>>>>>>>            Procedure_Return
33765>>>>>>>        End
33765>>>>>>>>
33765>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
33766>>>>>>>    End_Procedure
33767>>>>>>>
33767>>>>>>>    Function psIndexTableSpace Returns String
33769>>>>>>>        String sRetval
33769>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33771>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33772>>>>>>>>
33772>>>>>>>            Function_Return
33773>>>>>>>        End
33773>>>>>>>>
33773>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
33774>>>>>>>        Function_Return sRetval
33775>>>>>>>    End_Function
33776>>>>>>>
33776>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
33778>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33780>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33781>>>>>>>>
33781>>>>>>>            Procedure_Return
33782>>>>>>>        End
33782>>>>>>>>
33782>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
33783>>>>>>>    End_Procedure
33784>>>>>>>
33784>>>>>>>    Function pbUseConnectionID Returns Boolean
33786>>>>>>>        Boolean bState
33786>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33788>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33789>>>>>>>>
33789>>>>>>>            Function_Return
33790>>>>>>>        End
33790>>>>>>>>
33790>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
33791>>>>>>>        Function_Return bState
33792>>>>>>>    End_Function
33793>>>>>>>
33793>>>>>>>    Procedure Set pbToANSI Boolean bState
33795>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33797>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33798>>>>>>>>
33798>>>>>>>            Procedure_Return
33799>>>>>>>        End
33799>>>>>>>>
33799>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
33800>>>>>>>    End_Procedure
33801>>>>>>>
33801>>>>>>>    Function pbToANSI Returns Boolean
33803>>>>>>>        Boolean bState
33803>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33805>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33806>>>>>>>>
33806>>>>>>>            Function_Return
33807>>>>>>>        End
33807>>>>>>>>
33807>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
33808>>>>>>>        Function_Return bState
33809>>>>>>>    End_Function
33810>>>>>>>
33810>>>>>>>    Procedure Set pbRecnum Boolean bState
33812>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33814>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33815>>>>>>>>
33815>>>>>>>            Procedure_Return
33816>>>>>>>        End
33816>>>>>>>>
33816>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
33817>>>>>>>    End_Procedure
33818>>>>>>>
33818>>>>>>>    Function pbRecnum Returns Boolean
33820>>>>>>>        Boolean bState
33820>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33822>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33823>>>>>>>>
33823>>>>>>>            Function_Return
33824>>>>>>>        End
33824>>>>>>>>
33824>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
33825>>>>>>>        Function_Return bState
33826>>>>>>>    End_Function
33827>>>>>>>
33827>>>>>>>    Procedure Set pbCopyData Boolean bState
33829>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33831>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33832>>>>>>>>
33832>>>>>>>            Procedure_Return
33833>>>>>>>        End
33833>>>>>>>>
33833>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
33834>>>>>>>    End_Procedure
33835>>>>>>>
33835>>>>>>>    Function pbCopyData Returns Boolean
33837>>>>>>>        Boolean bState
33837>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33839>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33840>>>>>>>>
33840>>>>>>>            Function_Return
33841>>>>>>>        End
33841>>>>>>>>
33841>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
33842>>>>>>>        Function_Return bState
33843>>>>>>>    End_Function
33844>>>>>>>
33844>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
33846>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33848>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33849>>>>>>>>
33849>>>>>>>            Procedure_Return
33850>>>>>>>        End
33850>>>>>>>>
33850>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
33851>>>>>>>    End_Procedure
33852>>>>>>>
33852>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
33854>>>>>>>        Boolean bState
33854>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33856>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33857>>>>>>>>
33857>>>>>>>            Function_Return
33858>>>>>>>        End
33858>>>>>>>>
33858>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
33859>>>>>>>        Function_Return bState
33860>>>>>>>    End_Function
33861>>>>>>>
33861>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
33863>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33865>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33866>>>>>>>>
33866>>>>>>>            Procedure_Return
33867>>>>>>>        End
33867>>>>>>>>
33867>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
33868>>>>>>>    End_Procedure
33869>>>>>>>
33869>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
33871>>>>>>>        Boolean bState
33871>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33873>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33874>>>>>>>>
33874>>>>>>>            Function_Return
33875>>>>>>>        End
33875>>>>>>>>
33875>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
33876>>>>>>>        Function_Return bState
33877>>>>>>>    End_Function
33878>>>>>>>
33878>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
33880>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33882>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33883>>>>>>>>
33883>>>>>>>            Procedure_Return
33884>>>>>>>        End
33884>>>>>>>>
33884>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
33885>>>>>>>    End_Procedure
33886>>>>>>>
33886>>>>>>>    Function pbCompareIndexAscending Returns Boolean
33888>>>>>>>        Boolean bState
33888>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33890>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33891>>>>>>>>
33891>>>>>>>            Function_Return
33892>>>>>>>        End
33892>>>>>>>>
33892>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
33893>>>>>>>        Function_Return bState
33894>>>>>>>    End_Function
33895>>>>>>>
33895>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
33897>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33899>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33900>>>>>>>>
33900>>>>>>>            Procedure_Return
33901>>>>>>>        End
33901>>>>>>>>
33901>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
33902>>>>>>>    End_Procedure
33903>>>>>>>
33903>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
33905>>>>>>>        Boolean bState
33905>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33907>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
33908>>>>>>>>
33908>>>>>>>            Function_Return
33909>>>>>>>        End
33909>>>>>>>>
33909>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
33910>>>>>>>        Function_Return bState
33911>>>>>>>    End_Function
33912>>>>>>>
33912>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
33914>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33916>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33917>>>>>>>>
33917>>>>>>>            Procedure_Return
33918>>>>>>>        End
33918>>>>>>>>
33918>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
33919>>>>>>>    End_Procedure
33920>>>>>>>
33920>>>>>>>    Function psDriverDefaultValueASCII Returns String
33922>>>>>>>        String sRetval
33922>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33924>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33925>>>>>>>>
33925>>>>>>>            Function_Return
33926>>>>>>>        End
33926>>>>>>>>
33926>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
33927>>>>>>>        Function_Return sRetval
33928>>>>>>>    End_Function
33929>>>>>>>
33929>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
33931>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33933>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33934>>>>>>>>
33934>>>>>>>            Procedure_Return
33935>>>>>>>        End
33935>>>>>>>>
33935>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
33936>>>>>>>    End_Procedure
33937>>>>>>>
33937>>>>>>>    Function psDriverDefaultValueBinary Returns String
33939>>>>>>>        String sRetval
33939>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33941>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33942>>>>>>>>
33942>>>>>>>            Function_Return
33943>>>>>>>        End
33943>>>>>>>>
33943>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
33944>>>>>>>        Function_Return sRetval
33945>>>>>>>    End_Function
33946>>>>>>>
33946>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
33948>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33950>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33951>>>>>>>>
33951>>>>>>>            Procedure_Return
33952>>>>>>>        End
33952>>>>>>>>
33952>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
33953>>>>>>>    End_Procedure
33954>>>>>>>
33954>>>>>>>    Function psDriverDefaultValueDate Returns String
33956>>>>>>>        String sRetval
33956>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33958>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33959>>>>>>>>
33959>>>>>>>            Function_Return
33960>>>>>>>        End
33960>>>>>>>>
33960>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
33961>>>>>>>        Function_Return sRetval
33962>>>>>>>    End_Function
33963>>>>>>>
33963>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
33965>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33967>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33968>>>>>>>>
33968>>>>>>>            Procedure_Return
33969>>>>>>>        End
33969>>>>>>>>
33969>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
33970>>>>>>>    End_Procedure
33971>>>>>>>
33971>>>>>>>    Function psDriverDefaultValueDateTime Returns String
33973>>>>>>>        String sRetval
33973>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33975>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33976>>>>>>>>
33976>>>>>>>            Function_Return
33977>>>>>>>        End
33977>>>>>>>>
33977>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
33978>>>>>>>        Function_Return sRetval
33979>>>>>>>    End_Function
33980>>>>>>>
33980>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
33982>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33984>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33985>>>>>>>>
33985>>>>>>>            Procedure_Return
33986>>>>>>>        End
33986>>>>>>>>
33986>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
33987>>>>>>>    End_Procedure
33988>>>>>>>
33988>>>>>>>    Function psDriverDefaultValueNumeric Returns String
33990>>>>>>>        String sRetval
33990>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
33992>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
33993>>>>>>>>
33993>>>>>>>            Function_Return
33994>>>>>>>        End
33994>>>>>>>>
33994>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
33995>>>>>>>        Function_Return sRetval
33996>>>>>>>    End_Function
33997>>>>>>>
33997>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
33999>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34001>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34002>>>>>>>>
34002>>>>>>>            Procedure_Return
34003>>>>>>>        End
34003>>>>>>>>
34003>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
34004>>>>>>>    End_Procedure
34005>>>>>>>
34005>>>>>>>    Function psDriverDefaultValueText Returns String
34007>>>>>>>        String sRetval
34007>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34009>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34010>>>>>>>>
34010>>>>>>>            Function_Return
34011>>>>>>>        End
34011>>>>>>>>
34011>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
34012>>>>>>>        Function_Return sRetval
34013>>>>>>>    End_Function
34014>>>>>>>
34014>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
34016>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34018>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34019>>>>>>>>
34019>>>>>>>            Procedure_Return
34020>>>>>>>        End
34020>>>>>>>>
34020>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
34021>>>>>>>    End_Procedure
34022>>>>>>>
34022>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
34024>>>>>>>        Boolean bState
34024>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34026>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34027>>>>>>>>
34027>>>>>>>            Function_Return
34028>>>>>>>        End
34028>>>>>>>>
34028>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
34029>>>>>>>        Function_Return bState
34030>>>>>>>    End_Function
34031>>>>>>>
34031>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
34033>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34035>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34036>>>>>>>>
34036>>>>>>>            Procedure_Return
34037>>>>>>>        End
34037>>>>>>>>
34037>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
34038>>>>>>>    End_Procedure
34039>>>>>>>
34039>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
34041>>>>>>>        Boolean bState
34041>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34043>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34044>>>>>>>>
34044>>>>>>>            Function_Return
34045>>>>>>>        End
34045>>>>>>>>
34045>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
34046>>>>>>>        Function_Return bState
34047>>>>>>>    End_Function
34048>>>>>>>
34048>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
34050>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34052>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34053>>>>>>>>
34053>>>>>>>            Procedure_Return
34054>>>>>>>        End
34054>>>>>>>>
34054>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
34055>>>>>>>    End_Procedure
34056>>>>>>>
34056>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
34058>>>>>>>        Boolean bState
34058>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34060>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34061>>>>>>>>
34061>>>>>>>            Function_Return
34062>>>>>>>        End
34062>>>>>>>>
34062>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
34063>>>>>>>        Function_Return bState
34064>>>>>>>    End_Function
34065>>>>>>>
34065>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
34067>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34069>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34070>>>>>>>>
34070>>>>>>>            Procedure_Return
34071>>>>>>>        End
34071>>>>>>>>
34071>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
34072>>>>>>>    End_Procedure
34073>>>>>>>
34073>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
34075>>>>>>>        Boolean bState
34075>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34077>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34078>>>>>>>>
34078>>>>>>>            Function_Return
34079>>>>>>>        End
34079>>>>>>>>
34079>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
34080>>>>>>>        Function_Return bState
34081>>>>>>>    End_Function
34082>>>>>>>
34082>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
34084>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34086>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34087>>>>>>>>
34087>>>>>>>            Procedure_Return
34088>>>>>>>        End
34088>>>>>>>>
34088>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
34089>>>>>>>    End_Procedure
34090>>>>>>>
34090>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
34092>>>>>>>        Boolean bState
34092>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34094>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34095>>>>>>>>
34095>>>>>>>            Function_Return
34096>>>>>>>        End
34096>>>>>>>>
34096>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
34097>>>>>>>        Function_Return bState
34098>>>>>>>    End_Function
34099>>>>>>>
34099>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
34101>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34103>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34104>>>>>>>>
34104>>>>>>>            Procedure_Return
34105>>>>>>>        End
34105>>>>>>>>
34105>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
34106>>>>>>>    End_Procedure
34107>>>>>>>
34107>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
34109>>>>>>>        Boolean bState
34109>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
34111>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
34112>>>>>>>>
34112>>>>>>>            Function_Return
34113>>>>>>>        End
34113>>>>>>>>
34113>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
34114>>>>>>>        Function_Return bState
34115>>>>>>>    End_Function
34116>>>>>>>
34116>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
34116>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
34116>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
34116>>>>>>>    //       for a connection string has the wrong format for that driver.
34116>>>>>>>    Procedure Set psDriverID String sValue
34118>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34119>>>>>>>        Delegate Set psDriverID to sValue
34121>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34122>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
34123>>>>>>>    End_Procedure
34124>>>>>>>
34124>>>>>>>    Function psDriverID Returns String
34126>>>>>>>        String sDriverID
34126>>>>>>>
34126>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34127>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
34127>>>>>>>        Delegate Get psDriverID to sDriverID
34129>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34130>>>>>>>        Move False to Err
34131>>>>>>>
34131>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
34131>>>>>>>        // probably used as "utilites" from a special made program and
34131>>>>>>>        // the ghoSQLConnectionHandler must have been setup
34131>>>>>>>        If (sDriverID = "") Begin
34133>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
34134>>>>>>>        End
34134>>>>>>>>
34134>>>>>>>        Function_Return sDriverID
34135>>>>>>>    End_Function
34136>>>>>>>
34136>>>>>>>    Procedure Set piDbType Integer iValue
34138>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34139>>>>>>>        Delegate Set piDbType to iValue
34141>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34142>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
34143>>>>>>>    End_Procedure
34144>>>>>>>
34144>>>>>>>    Function piDbType Returns String
34146>>>>>>>        Integer iRetval
34146>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
34147>>>>>>>        Function_Return iRetval
34148>>>>>>>    End_Function
34149>>>>>>>
34149>>>>>>>    Function phoLogFile Returns Handle
34151>>>>>>>        Handle hoLogFile
34151>>>>>>>
34151>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34152>>>>>>>        Delegate Get phoLogFile to hoLogFile
34154>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
34155>>>>>>>
34155>>>>>>>        Function_Return hoLogFile
34156>>>>>>>    End_Function
34157>>>>>>>
34157>>>>>>>    Function pnCurrentVersionUpdate Returns Number
34159>>>>>>>        Number nCurrentVersionUpdate
34159>>>>>>>
34159>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34160>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
34162>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
34163>>>>>>>
34163>>>>>>>        Function_Return nCurrentVersionUpdate
34164>>>>>>>    End_Function
34165>>>>>>>
34165>>>>>>>    Procedure LogError String sText Boolean bError
34167>>>>>>>        Handle hoLogFile
34167>>>>>>>        Number nCurrentVersionUpdate
34167>>>>>>>
34167>>>>>>>        Get phoLogFile to hoLogFile
34168>>>>>>>        If (hoLogFile = 0) Begin
34170>>>>>>>            Procedure_Return
34171>>>>>>>        End
34171>>>>>>>>
34171>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
34172>>>>>>>
34172>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
34173>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
34174>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
34175>>>>>>>    End_Procedure
34176>>>>>>>
34176>>>>>>>    Function pbContinueOnError Returns Boolean
34178>>>>>>>        Boolean bContinueOnError
34178>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
34180>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
34181>>>>>>>        End
34181>>>>>>>>
34181>>>>>>>        Function_Return bContinueOnError
34182>>>>>>>    End_Function
34183>>>>>>>
34183>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
34183>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
34183>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
34183>>>>>>>    // Good read about which collation to select:
34183>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
34183>>>>>>>    Procedure Set psCollation String sCollation
34185>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
34187>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
34188>>>>>>>        End
34188>>>>>>>>
34188>>>>>>>    End_Procedure
34189>>>>>>>
34189>>>>>>>    Function psCollation Returns String
34191>>>>>>>        String sCollation
34191>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
34193>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
34194>>>>>>>        End
34194>>>>>>>>
34194>>>>>>>        Function_Return sCollation
34195>>>>>>>    End_Function
34196>>>>>>>
34196>>>>>>>
34196>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
34198>>>>>>>        Integer iMax iPos
34198>>>>>>>        String sName
34198>>>>>>>
34198>>>>>>>        Move (Lowercase(sField)) to sField
34199>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
34202>>>>>>>        for iPos from 0 to iMax
34208>>>>>>>>
34208>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
34211>>>>>>>            Move (Lowercase(sName)) to sName
34212>>>>>>>            If (sName = sField) Begin
34214>>>>>>>                Function_Return iPos
34215>>>>>>>            End
34215>>>>>>>>
34215>>>>>>>        Loop
34216>>>>>>>>
34216>>>>>>>        Function_Return -1
34217>>>>>>>    End_Function
34218>>>>>>>
34218>>>>>>>
34218>>>>>>>    // * Dummy function for the Studio's Code Explorer *
34218>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
34220>>>>>>>        Function_Return False
34221>>>>>>>    End_Function
34222>>>>>>>
34222>>>>>>>    // *** Helper functions with compiled sql script code ***
34222>>>>>>>    //
34222>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
34222>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
34222>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
34222>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
34222>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
34222>>>>>>>    //   ALTER TABLE MyTable
34222>>>>>>>    //       REBUILD
34222>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
34224>>>>>>>        Boolean bOK
34224>>>>>>>
34224>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
34226>>>>>>>            Function_Return False
34227>>>>>>>        End
34227>>>>>>>>
34227>>>>>>>
34227>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
34227>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
34228>>>>>>>
34228>>>>>>>        Function_Return (bOK = True)
34229>>>>>>>    End_Function
34230>>>>>>>
34230>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
34230>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
34230>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
34230>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
34230>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
34230>>>>>>>    //   ALTER TABLE MyTable
34230>>>>>>>    //       REBUILD
34230>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
34232>>>>>>>        tSQLScriptArray SQLScriptArray
34232>>>>>>>        tSQLScriptArray SQLScriptArray
34232>>>>>>>        String sDriverID
34232>>>>>>>        Boolean bOK
34232>>>>>>>        Integer iSize iCount
34232>>>>>>>
34232>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
34234>>>>>>>            Function_Return False
34235>>>>>>>        End
34235>>>>>>>>
34235>>>>>>>
34235>>>>>>>        Get psDriverID to sDriverID
34236>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
34237>>>>>>>        If (SQLScriptArray.bError = True) Begin
34239>>>>>>>            Function_Return False
34240>>>>>>>        End
34240>>>>>>>>
34240>>>>>>>
34240>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
34241>>>>>>>        Decrement iSize
34242>>>>>>>
34242>>>>>>>        for iCount from 0 to iSize
34248>>>>>>>>
34248>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
34250>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
34251>>>>>>>            End
34251>>>>>>>>
34251>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
34253>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
34254>>>>>>>            End
34254>>>>>>>>
34254>>>>>>>        Loop
34255>>>>>>>>
34255>>>>>>>
34255>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
34256>>>>>>>
34256>>>>>>>        Function_Return (bOK = True)
34257>>>>>>>    End_Function
34258>>>>>>>
34258>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
34260>>>>>>>        tSQLScriptArray SQLScriptArray
34260>>>>>>>        tSQLScriptArray SQLScriptArray
34260>>>>>>>        String sDriverID sCollation
34260>>>>>>>        Boolean bOK
34260>>>>>>>        Integer iSize iCount
34260>>>>>>>
34260>>>>>>>        If (Trim(sDatabaseName) = "") Begin
34262>>>>>>>            Function_Return False
34263>>>>>>>        End
34263>>>>>>>>
34263>>>>>>>
34263>>>>>>>        Get psDriverID  to sDriverID
34264>>>>>>>        Get psCollation to sCollation
34265>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
34266>>>>>>>        If (SQLScriptArray.bError = True) Begin
34268>>>>>>>            Function_Return False
34269>>>>>>>        End
34269>>>>>>>>
34269>>>>>>>
34269>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
34270>>>>>>>        Decrement iSize
34271>>>>>>>
34271>>>>>>>        for iCount from 0 to iSize
34277>>>>>>>>
34277>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
34279>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
34280>>>>>>>            End
34280>>>>>>>>
34280>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
34282>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
34283>>>>>>>            End
34283>>>>>>>>
34283>>>>>>>        Loop
34284>>>>>>>>
34284>>>>>>>
34284>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
34285>>>>>>>
34285>>>>>>>        Function_Return (bOK = True)
34286>>>>>>>    End_Function
34287>>>>>>>
34287>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
34289>>>>>>>        tSQLScriptArray SQLScriptArray
34289>>>>>>>        tSQLScriptArray SQLScriptArray
34289>>>>>>>        String sDriverID sCollation
34289>>>>>>>        Boolean bOK
34289>>>>>>>        Integer iSize iCount
34289>>>>>>>
34289>>>>>>>        If (Trim(sDatabaseName) = "") Begin
34291>>>>>>>            Function_Return False
34292>>>>>>>        End
34292>>>>>>>>
34292>>>>>>>
34292>>>>>>>        Get psDriverID  to sDriverID
34293>>>>>>>        Get psCollation to sCollation
34294>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
34295>>>>>>>        If (SQLScriptArray.bError = True) Begin
34297>>>>>>>            Function_Return False
34298>>>>>>>        End
34298>>>>>>>>
34298>>>>>>>
34298>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
34299>>>>>>>        Decrement iSize
34300>>>>>>>
34300>>>>>>>        for iCount from 0 to iSize
34306>>>>>>>>
34306>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
34308>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
34309>>>>>>>            End
34309>>>>>>>>
34309>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
34311>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
34312>>>>>>>            End
34312>>>>>>>>
34312>>>>>>>        Loop
34313>>>>>>>>
34313>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
34313>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
34314>>>>>>>
34314>>>>>>>        Function_Return (bOK = True)
34315>>>>>>>    End_Function
34316>>>>>>>
34316>>>>>>>    // *** Helper functions for Mertech Drivers ***
34316>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
34316>>>>>>>    // and commands that the Studio editor knows nothing about.
34316>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
34318>>>>>>>        Integer iRetval
34318>>>>>>>        String sPath
34318>>>>>>>
34318>>>>>>>        If (sPath = "" or sTableName = "") Begin
34320>>>>>>>            Function_Return True
34321>>>>>>>        End
34321>>>>>>>>
34321>>>>>>>
34321>>>>>>>        Get vFolderFormat sPath to sPath
34322>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
34323>>>>>>>        Function_Return (iRetval = 0)
34324>>>>>>>    End_Function
34325>>>>>>>
34325>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
34327>>>>>>>        Integer iFile
34327>>>>>>>        Boolean bOEMState bOpen bOK
34327>>>>>>>        String sDriverID 
34327>>>>>>>        Move False to Err
34328>>>>>>>        Function_Return (Err = False)
34329>>>>>>>    End_Function
34330>>>>>>>
34330>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
34332>>>>>>>        Integer iNumItems iCount
34332>>>>>>>        String[] sReturnArray
34333>>>>>>>        String sServer
34333>>>>>>>
34333>>>>>>>
34333>>>>>>>        Function_Return sReturnArray
34334>>>>>>>    End_Function
34335>>>>>>>
34335>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
34337>>>>>>>        String[] sReturnArray
34338>>>>>>>        String sServer
34338>>>>>>>
34338>>>>>>>
34338>>>>>>>        Function_Return sReturnArray
34339>>>>>>>    End_Function
34340>>>>>>>
34340>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
34342>>>>>>>        Handle hoSQLHandler hoSQLConnect
34342>>>>>>>
34342>>>>>>>        Move 0 to hoSQLConnect
34343>>>>>>>
34343>>>>>>>        Function_Return hoSQLConnect
34344>>>>>>>    End_Function
34345>>>>>>>
34345>>>>>>>    // Returns the handle of the Mertech SQL handler.
34345>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
34345>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
34345>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
34347>>>>>>>        Handle hoSQLHandler
34347>>>>>>>        String sDriverID sServer sDatabase
34347>>>>>>>
34347>>>>>>>        Move 0 to hoSQLHandler
34348>>>>>>>        Get psDriverID to sDriverID
34349>>>>>>>        Get psServer   to sServer
34350>>>>>>>        Get psDatabase to sDatabase
34351>>>>>>>
34351>>>>>>>        Function_Return hoSQLHandler
34352>>>>>>>    End_Function
34353>>>>>>>
34353>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
34353>>>>>>>    // macro-commands <sigh!>
34353>>>>>>>    // Note: The function sets the Err flag.
34353>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
34355>>>>>>>        Integer iFile
34355>>>>>>>
34355>>>>>>>        Move False to Err
34356>>>>>>>
34356>>>>>>>        Function_Return (Err = False)
34357>>>>>>>    End_Function
34358>>>>>>>
34358>>>>>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
34360>>>>>>>        Move False to Err
34361>>>>>>>        Function_Return (Err = False)
34362>>>>>>>    End_Function
34363>>>>>>>
34363>>>>>>>End_Class
34364>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\for_all.pkg)
34364>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
34364>>>>>>>//
34364>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
34364>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
34364>>>>>>>// conjunction with constraint-clauses.
34364>>>>>>>//
34364>>>>>>>// SYNTAX:
34364>>>>>>>//
34364>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
34364>>>>>>>//    <Constraints...>
34364>>>>>>>//    {DO}
34364>>>>>>>//      <loop body>
34364>>>>>>>//  End_For_All
34364>>>>>>>//
34364>>>>>>>// This set of macros implements a constraint-oriented file enumeration
34364>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
34364>>>>>>>//
34364>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
34364>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
34364>>>>>>>//   End_For_All
34364>>>>>>>//
34364>>>>>>>// To list only Customers with a Balance greater than their credit limit:
34364>>>>>>>//
34364>>>>>>>//   For_All Customer BY Index.1
34364>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
34364>>>>>>>//     DO
34364>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
34364>>>>>>>//   End_For_All
34364>>>>>>>//
34364>>>>>>>// Constraint clauses are:
34364>>>>>>>//
34364>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
34364>>>>>>>//   CONSTRAIN <File> AS <Expression>
34364>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
34364>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
34364>>>>>>>//
34364>>>>>>>// For example, to list all customers with a bad status whose names start
34364>>>>>>>// with "A" and which have not made a payment in thirty days:
34364>>>>>>>//
34364>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
34364>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
34364>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
34364>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
34364>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
34364>>>>>>>//      DO
34364>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
34364>>>>>>>//    End_For_All
34364>>>>>>>//
34364>>>>>>>
34364>>>>>>>
34364>>>>>>>//This command starts the loop process body when constraints are used;
34364>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
34364>>>>>>>//command line, and not on a line by itself
34364>>>>>>>//
34364>>>>>>>
34364>>>>>>>//Ends a For_All loop
34364>>>>>>>//
34364>>>>>>>
34364>>>>>>>
34364>>>>>
34364>>>>>
34364>>>>>
34364>>>>>Class cDbUpdateVersion is a cObject
34365>>>>>
34365>>>>>    Procedure Construct_Object
34367>>>>>        String[] aSQLQueryMessages
34368>>>>>        Forward Send Construct_Object
34370>>>>>
34370>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
34370>>>>>        // event was triggered, thus an actual change of the database was made.
34370>>>>>        Property Boolean pbVersionUpdate False
34371>>>>>
34371>>>>>        // This property must be manually set within each cDbUpdateVersion object
34371>>>>>        // by the programmer, to a consecutive number.
34371>>>>>        Property Number pnVersionNumber
34372>>>>>
34372>>>>>        Property Boolean pbUseConnectionID True
34373>>>>>        Property Boolean private.pbToANSI   True
34374>>>>>        Property Boolean private.pbRecnum   True
34375>>>>>        Property Boolean private.pbCopyData True
34376>>>>>        Property Boolean private.pbApiTableUpdateAuto False
34377>>>>>        Property Boolean private.pbCompareDate_DateTime False
34378>>>>>        Property Boolean private.pbCompareIndexAscending False
34379>>>>>        Property Boolean private.pbCompareIndexUppercase False
34380>>>>>        Property String private.psSchema
34381>>>>>        Property String private.psBaseTableSpace
34382>>>>>        Property String private.psLongTableSpace
34383>>>>>        Property String private.psIndexTableSpace
34384>>>>>
34384>>>>>        // Driver default value settings:
34384>>>>>        Property String private.psDriverDefaultValueASCII    ""
34385>>>>>        Property String private.psDriverDefaultValueBinary   ""
34386>>>>>        Property String private.psDriverDefaultValueDate     ""
34387>>>>>        Property String private.psDriverDefaultValueDateTime ""
34388>>>>>        Property String private.psDriverDefaultValueNumeric  ""
34389>>>>>        Property String private.psDriverDefaultValueText     ""
34390>>>>>
34390>>>>>        // Driver "nullability" settings:
34390>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
34391>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
34392>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
34393>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
34394>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
34395>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
34396>>>>>
34396>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
34396>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
34396>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
34396>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
34396>>>>>        // We reset it here for each cDbUpdateVersion object
34396>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
34398>>>>>    End_Procedure
34399>>>>>
34399>>>>>    // *** Main hook event message ***
34399>>>>>    // Place your database update logic here!
34399>>>>>    Procedure OnUpdate
34401>>>>>    End_Procedure
34402>>>>>
34402>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
34402>>>>>    // imported to the cDbUpdateHandler container class which should be a
34402>>>>>    // parent object to this object. To have the Studio's Property Panel
34402>>>>>    // "behave" aka show these properties we need to duplicate them in this
34402>>>>>    // class and "relay" them to the parent object.
34402>>>>>    Procedure Set pbToANSI Boolean bState
34404>>>>>        Set private.pbToANSI  to bState
34405>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34406>>>>>        Delegate Set pbToANSI to bState
34408>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34409>>>>>    End_Procedure
34410>>>>>
34410>>>>>    Function pbToANSI Returns Boolean
34412>>>>>        Function_Return (private.pbToAnsi(Self))
34413>>>>>    End_Function
34414>>>>>
34414>>>>>    Procedure Set pbRecnum Boolean bState
34416>>>>>        Set private.pbRecnum  to bState
34417>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34418>>>>>        Delegate Set pbRecnum to bState
34420>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34421>>>>>    End_Procedure
34422>>>>>
34422>>>>>    Function pbRecnum Returns Boolean
34424>>>>>        Function_Return (private.pbRecnum(Self))
34425>>>>>    End_Function
34426>>>>>
34426>>>>>    Procedure Set pbCopyData Boolean bState
34428>>>>>        Set private.pbCopyData  to bState
34429>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34430>>>>>        Delegate Set pbCopyData to bState
34432>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34433>>>>>    End_Procedure
34434>>>>>
34434>>>>>    Function pbCopyData Returns Boolean
34436>>>>>        Function_Return (private.pbCopyData(Self))
34437>>>>>    End_Function
34438>>>>>
34438>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
34438>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
34440>>>>>        Set private.pbApiTableUpdateAuto  to bState
34441>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34442>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
34443>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34444>>>>>    End_Procedure
34445>>>>>
34445>>>>>    Function pbApiTableUpdateAuto Returns Boolean
34447>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
34448>>>>>    End_Function
34449>>>>>
34449>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
34451>>>>>        Set private.pbCompareDate_DateTime  to bState
34452>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34453>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
34454>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34455>>>>>    End_Procedure
34456>>>>>
34456>>>>>    Function pbCompareDate_DateTime Returns Boolean
34458>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
34459>>>>>    End_Function
34460>>>>>
34460>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
34462>>>>>        Set private.pbCompareIndexAscending  to bState
34463>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34464>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
34465>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34466>>>>>    End_Procedure
34467>>>>>
34467>>>>>    Function pbCompareIndexAscending Returns Boolean
34469>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
34470>>>>>    End_Function
34471>>>>>
34471>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
34473>>>>>        Set private.pbCompareIndexUppercase  to bState
34474>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34475>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
34476>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34477>>>>>    End_Procedure
34478>>>>>
34478>>>>>    Function pbCompareIndexUppercase Returns Boolean
34480>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
34481>>>>>    End_Function
34482>>>>>
34482>>>>>    Procedure Set psSchema String sValue
34484>>>>>        Set private.psSchema  to sValue
34485>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34486>>>>>        Delegate Set psSchema to sValue
34488>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34489>>>>>    End_Procedure
34490>>>>>
34490>>>>>    // First retrieve the private value that might have been set in the object.
34490>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
34490>>>>>    // it might have been specified in the SQLConnections.ini file.
34490>>>>>    Function psSchema Returns String
34492>>>>>        String sValue
34492>>>>>        Get private.psSchema to sValue
34493>>>>>        If (sValue = "") Begin
34495>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
34496>>>>>        End
34496>>>>>>
34496>>>>>        Function_Return sValue
34497>>>>>    End_Function
34498>>>>>
34498>>>>>    Procedure Set psBaseTableSpace String sValue
34500>>>>>        Set private.psBaseTableSpace  to sValue
34501>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34502>>>>>        Delegate Set psBaseTableSpace to sValue
34504>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34505>>>>>    End_Procedure
34506>>>>>
34506>>>>>    // First retrieve the private value that might have been set in the object.
34506>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
34506>>>>>    // it might have been specified in the SQLConnections.ini file.
34506>>>>>    Function psBaseTableSpace Returns String
34508>>>>>        String sValue
34508>>>>>        Get private.psBaseTableSpace to sValue
34509>>>>>        If (sValue = "") Begin
34511>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
34512>>>>>        End
34512>>>>>>
34512>>>>>        Function_Return sValue
34513>>>>>    End_Function
34514>>>>>
34514>>>>>    Procedure Set psLongTableSpace String sValue
34516>>>>>        Set private.psLongTableSpace  to sValue
34517>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34518>>>>>        Delegate Set psLongTableSpace to sValue
34520>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34521>>>>>    End_Procedure
34522>>>>>
34522>>>>>    // First retrieve the private value that might have been set in the object.
34522>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
34522>>>>>    // it might have been specified in the SQLConnections.ini file.
34522>>>>>    Function psLongTableSpace Returns String
34524>>>>>        String sValue
34524>>>>>        Get private.psLongTableSpace to sValue
34525>>>>>        If (sValue = "") Begin
34527>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
34528>>>>>        End
34528>>>>>>
34528>>>>>        Function_Return sValue
34529>>>>>    End_Function
34530>>>>>
34530>>>>>    Procedure Set psIndexTableSpace String sValue
34532>>>>>        Set private.psIndexTableSpace  to sValue
34533>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34534>>>>>        Delegate Set psIndexTableSpace to sValue
34536>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34537>>>>>    End_Procedure
34538>>>>>
34538>>>>>    // First retrieve the private value that might have been set in the object.
34538>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
34538>>>>>    // it might have been specified in the SQLConnections.ini file.
34538>>>>>    Function psIndexTableSpace Returns String
34540>>>>>        String sValue
34540>>>>>        Get private.psIndexTableSpace to sValue
34541>>>>>        If (sValue = "") Begin
34543>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
34544>>>>>        End
34544>>>>>>
34544>>>>>        Function_Return sValue
34545>>>>>    End_Function
34546>>>>>
34546>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
34548>>>>>        Set private.psDriverDefaultValueASCII  to sValue
34549>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34550>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
34552>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34553>>>>>    End_Procedure
34554>>>>>
34554>>>>>    // First retrieve the private value that might have been set in the object.
34554>>>>>    // If blank; get it from the parent object
34554>>>>>    Function psDriverDefaultValueASCII Returns String
34556>>>>>        String sValue
34556>>>>>        Get private.psDriverDefaultValueASCII to sValue
34557>>>>>        If (sValue = "") Begin
34559>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
34561>>>>>        End
34561>>>>>>
34561>>>>>        Function_Return sValue
34562>>>>>    End_Function
34563>>>>>
34563>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
34565>>>>>        Set private.psDriverDefaultValueBinary  to sValue
34566>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34567>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
34569>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34570>>>>>    End_Procedure
34571>>>>>
34571>>>>>    // First retrieve the private value that might have been set in the object.
34571>>>>>    // If blank; get it from the parent object
34571>>>>>    Function psDriverDefaultValueBinary Returns String
34573>>>>>        String sValue
34573>>>>>        Get private.psDriverDefaultValueBinary to sValue
34574>>>>>        If (sValue = "") Begin
34576>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
34578>>>>>        End
34578>>>>>>
34578>>>>>        Function_Return sValue
34579>>>>>    End_Function
34580>>>>>
34580>>>>>    Procedure Set psDriverDefaultValueDate String sValue
34582>>>>>        Set private.psDriverDefaultValueDate  to sValue
34583>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34584>>>>>        Delegate Set psDriverDefaultValueDate to sValue
34586>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34587>>>>>    End_Procedure
34588>>>>>
34588>>>>>    // First retrieve the private value that might have been set in the object.
34588>>>>>    // If blank; get it from the parent object
34588>>>>>    Function psDriverDefaultValueDate Returns String
34590>>>>>        String sValue
34590>>>>>        Get private.psDriverDefaultValueDate to sValue
34591>>>>>        If (sValue = "") Begin
34593>>>>>            Delegate Get psDriverDefaultValueDate to sValue
34595>>>>>        End
34595>>>>>>
34595>>>>>        Function_Return sValue
34596>>>>>    End_Function
34597>>>>>
34597>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
34599>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
34600>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34601>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
34603>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34604>>>>>    End_Procedure
34605>>>>>
34605>>>>>    // First retrieve the private value that might have been set in the object.
34605>>>>>    // If blank; get it from the parent object
34605>>>>>    Function psDriverDefaultValueDateTime Returns String
34607>>>>>        String sValue
34607>>>>>        Get private.psDriverDefaultValueDateTime to sValue
34608>>>>>        If (sValue = "") Begin
34610>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
34612>>>>>        End
34612>>>>>>
34612>>>>>        Function_Return sValue
34613>>>>>    End_Function
34614>>>>>
34614>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
34616>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
34617>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34618>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
34620>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34621>>>>>    End_Procedure
34622>>>>>
34622>>>>>    // First retrieve the private value that might have been set in the object.
34622>>>>>    // If blank; get it from the parent object
34622>>>>>    Function psDriverDefaultValueNumeric Returns String
34624>>>>>        String sValue
34624>>>>>        Get private.psDriverDefaultValueNumeric to sValue
34625>>>>>        If (sValue = "") Begin
34627>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
34629>>>>>        End
34629>>>>>>
34629>>>>>        Function_Return sValue
34630>>>>>    End_Function
34631>>>>>
34631>>>>>    Procedure Set psDriverDefaultValueText String sValue
34633>>>>>        Set private.psDriverDefaultValueText  to sValue
34634>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34635>>>>>        Delegate Set psDriverDefaultValueText to sValue
34637>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34638>>>>>    End_Procedure
34639>>>>>
34639>>>>>    // First retrieve the private value that might have been set in the object.
34639>>>>>    // If blank; get it from the parent object
34639>>>>>    Function psDriverDefaultValueText Returns String
34641>>>>>        String sValue
34641>>>>>        Get private.psDriverDefaultValueText to sValue
34642>>>>>        If (sValue = "") Begin
34644>>>>>            Delegate Get psDriverDefaultValueText to sValue
34646>>>>>        End
34646>>>>>>
34646>>>>>        Function_Return sValue
34647>>>>>    End_Function
34648>>>>>
34648>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
34650>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
34651>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34652>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
34654>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34655>>>>>    End_Procedure
34656>>>>>
34656>>>>>    // First retrieve the private value that might have been set in the object.
34656>>>>>    // If blank; get it from the parent object
34656>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
34658>>>>>        Boolean bState
34658>>>>>        Get private.pbDriverDefaultNullableASCII to bState
34659>>>>>        If (bState = False) Begin
34661>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
34663>>>>>        End
34663>>>>>>
34663>>>>>        Function_Return bState
34664>>>>>    End_Function
34665>>>>>
34665>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
34667>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
34668>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34669>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
34671>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34672>>>>>    End_Procedure
34673>>>>>
34673>>>>>    // First retrieve the private value that might have been set in the object.
34673>>>>>    // If blank; get it from the parent object
34673>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
34675>>>>>        Boolean bState
34675>>>>>        Get private.pbDriverDefaultNullableBinary to bState
34676>>>>>        If (bState = False) Begin
34678>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
34680>>>>>        End
34680>>>>>>
34680>>>>>        Function_Return bState
34681>>>>>    End_Function
34682>>>>>
34682>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
34684>>>>>        Set private.pbDriverDefaultNullableDate  to bState
34685>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34686>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
34688>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34689>>>>>    End_Procedure
34690>>>>>
34690>>>>>    // First retrieve the private value that might have been set in the object.
34690>>>>>    // If blank; get it from the parent object
34690>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
34692>>>>>        Boolean bState
34692>>>>>        Get private.pbDriverDefaultNullableDate to bState
34693>>>>>        If (bState = False) Begin
34695>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
34697>>>>>        End
34697>>>>>>
34697>>>>>        Function_Return bState
34698>>>>>    End_Function
34699>>>>>
34699>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
34701>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
34702>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34703>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
34705>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34706>>>>>    End_Procedure
34707>>>>>
34707>>>>>    // First retrieve the private value that might have been set in the object.
34707>>>>>    // If blank; get it from the parent object
34707>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
34709>>>>>        Boolean bState
34709>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
34710>>>>>        If (bState = False) Begin
34712>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
34714>>>>>        End
34714>>>>>>
34714>>>>>        Function_Return bState
34715>>>>>    End_Function
34716>>>>>
34716>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
34718>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
34719>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34720>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
34722>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34723>>>>>    End_Procedure
34724>>>>>
34724>>>>>    // First retrieve the private value that might have been set in the object.
34724>>>>>    // If blank; get it from the parent object
34724>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
34726>>>>>        Boolean bState
34726>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
34727>>>>>        If (bState = False) Begin
34729>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
34731>>>>>        End
34731>>>>>>
34731>>>>>        Function_Return bState
34732>>>>>    End_Function
34733>>>>>
34733>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
34735>>>>>        Set private.pbDriverDefaultNullableText  to bState
34736>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34737>>>>>        Delegate Set pbDriverDefaultNullableText to bState
34739>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34740>>>>>    End_Procedure
34741>>>>>
34741>>>>>    // First retrieve the private value that might have been set in the object.
34741>>>>>    // If blank; get it from the parent object
34741>>>>>    Function pbDriverDefaultNullableText Returns Boolean
34743>>>>>        Boolean bState
34743>>>>>        Get private.pbDriverDefaultNullableText to bState
34744>>>>>        If (bState = False) Begin
34746>>>>>            Delegate Get pbDriverDefaultNullableText to bState
34748>>>>>        End
34748>>>>>>
34748>>>>>        Function_Return bState
34749>>>>>    End_Function
34750>>>>>
34750>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
34752>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
34752>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
34752>>>>>
34752>>>>>        Get psDriverID to sDriverID
34753>>>>>        Get psSchema to sSchema
34754>>>>>
34754>>>>>        Get psBaseTableSpace to sBaseTableSpace
34755>>>>>        If (sBaseTableSpace <> "") Begin
34757>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34758>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
34760>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34761>>>>>        End
34761>>>>>>
34761>>>>>
34761>>>>>        Get psLongTableSpace to sLongTableSpace
34762>>>>>        If (sLongTableSpace <> "") Begin
34764>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34765>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
34767>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34768>>>>>        End
34768>>>>>>
34768>>>>>
34768>>>>>        Get psIndexTableSpace to sIndexTableSpace
34769>>>>>        If (sIndexTableSpace <> "") Begin
34771>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
34772>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
34774>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
34775>>>>>        End
34775>>>>>>
34775>>>>>
34775>>>>>        Get pbUseConnectionID to bUseConnectionID
34776>>>>>        Get pbToANSI          to bToANSI
34777>>>>>//ToDo: Why was this changed?
34777>>>>>//        Move True             to bRecnum
34777>>>>>//        Move True             to bCopyData
34777>>>>>        Get pbRecnum          to bRecnum
34778>>>>>        Get pbCopyData        to bCopyData
34779>>>>>
34779>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
34780>>>>>
34780>>>>>        Function_Return bOK
34781>>>>>    End_Function
34782>>>>>
34782>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
34782>>>>>//        Boolean bOK bExists
34782>>>>>//        String sDataPath sBackupFolder
34782>>>>>//        
34782>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
34782>>>>>//        Move "BackupData" to sBackupFolder
34782>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
34782>>>>>//        Get vFolderFormat sDataPath to sDataPath
34782>>>>>//        
34782>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
34782>>>>>//        If (bExists = False) Begin
34782>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
34782>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
34782>>>>>//            If (bExists = False) Begin
34782>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
34782>>>>>//                Function_Return False
34782>>>>>//            End                                                                                                                                            
34782>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
34782>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
34782>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
34782>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
34782>>>>>//        End
34782>>>>>//        
34782>>>>>//        Set Message_Text of ghoStatusPanel to ""
34782>>>>>//        Function_Return bOK
34782>>>>>//    End_Function
34782>>>>>//
34782>>>>>    // This is automatically called after the OnUpdate
34782>>>>>    // event has been executed. It will automatically update the
34782>>>>>    // version database field/column with the "pnVersionNumber"
34782>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
34782>>>>>    Procedure UpdateVersionColumnValue
34784>>>>>        Number nVersion nCurrentValue
34784>>>>>        Integer hTable iColumn
34784>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
34784>>>>>
34784>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
34784>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
34784>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
34786>>>>>        Get pbVersionUpdate to bVersionUpdate
34787>>>>>
34787>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
34789>>>>>            Get pnVersionNumber to nVersion
34790>>>>>            Delegate Get piDbVersionFileNumber  to hTable
34792>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
34794>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
34794>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
34794>>>>>            Close DF_ALL DF_PERMANENT
34795>>>>>
34795>>>>>            Open hTable
34797>>>>>
34797>>>>>            // It is then the developer responsibility to take care of finding
34797>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
34797>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
34799>>>>>            If (bUseCustomDbVersion = True) Begin
34801>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
34803>>>>>            End
34803>>>>>>
34803>>>>>
34803>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
34806>>>>>            If (nCurrentValue < nVersion) Begin
34808>>>>>                Lock
34809>>>>>>
34809>>>>>                    If (bUseCustomDbVersion = False) Begin
34811>>>>>                        Vfind hTable Recnum GE                            
34813>>>>>                    End
34813>>>>>>
34813>>>>>                    Set_Field_Value hTable iColumn to nVersion
34816>>>>>                    SaveRecord hTable
34817>>>>>                Unlock
34818>>>>>>
34818>>>>>            End
34818>>>>>>
34818>>>>>            Close hTable
34819>>>>>        End
34819>>>>>>
34819>>>>>    End_Procedure
34820>>>>>
34820>>>>>// Property of the container object (cDbUpdateHandler)
34820>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
34820>>>>>
34820>>>>>    Procedure End_Construct_Object
34822>>>>>        Forward Send End_Construct_Object
34824>>>>>        Send ProcessUpdate True
34825>>>>>    End_Procedure
34826>>>>>    
34826>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
34828>>>>>        Number nVersion nCurrentValue
34828>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber
34828>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists
34828>>>>>        String sObjectName
34828>>>>>        tDbVersionInfo[] dbVersionInfoArray
34828>>>>>        tDbVersionInfo[] dbVersionInfoArray
34829>>>>>
34829>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
34831>>>>>
34831>>>>>        // If the programmer forgot to set the version number we do not allow for the application
34831>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
34831>>>>>        // one database update is depended on an earlier update and that earlier version
34831>>>>>        // update was never executed it could lead to disastrous results.
34831>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
34831>>>>>        Get pnVersionNumber to nVersion
34832>>>>>        If (nVersion = 0) Begin
34834>>>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
34835>>>>>            Move (Name(Self)) to sObjectName
34836>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
34837>>>>>>
34837>>>>>            Send Exit_Application
34838>>>>>        End
34838>>>>>>
34838>>>>>
34838>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
34838>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
34838>>>>>        Delegate Send OnPreUpdate   // cDbUpdateHandler object event.
34840>>>>>        
34840>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
34842>>>>>        
34842>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
34844>>>>>        If (bUseCustomDbVersion = False) Begin
34846>>>>>            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
34848>>>>>        End
34848>>>>>>
34848>>>>>        Else Begin
34849>>>>>            Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
34850>>>>>            If (bTableExists = False) Begin
34852>>>>>                Delegate Send OnCreateCustomDbVersionTable
34854>>>>>            End
34854>>>>>>
34854>>>>>        End
34854>>>>>>
34854>>>>>        
34854>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
34854>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
34854>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
34856>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
34858>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
34859>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
34860>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
34861>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
34863>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
34865>>>>>        End
34865>>>>>>
34865>>>>>
34865>>>>>        Delegate Get piDbVersionFileNumber  to hTable
34867>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
34869>>>>>
34869>>>>>        Open hTable
34871>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
34874>>>>>        If (bOpened = False) Begin
34876>>>>>            Send Stop_Box CS_DbUpdateTableMissing
34877>>>>>            Send Exit_Application
34878>>>>>        End
34878>>>>>>
34878>>>>>
34878>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
34881>>>>>        If (bSystemTable = True) Begin
34883>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
34886>>>>>        End
34886>>>>>>
34886>>>>>        Else Begin
34887>>>>>            If (bUseCustomDbVersion = True) Begin
34889>>>>>                Send OnFindVersionRecord
34890>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
34893>>>>>            End
34893>>>>>>
34893>>>>>        End
34893>>>>>>
34893>>>>>
34893>>>>>        Close hTable
34894>>>>>
34894>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
34894>>>>>        // If not set we do nothing.
34894>>>>>        If (nCurrentValue < nVersion) Begin
34896>>>>>
34896>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
34896>>>>>            // execution of database update code. So if true _and_ one error
34896>>>>>            // has already occured; we're out of here.
34896>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
34898>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
34900>>>>>            If (bStopOnFirstError = True) Begin
34902>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
34904>>>>>                    Procedure_Return
34905>>>>>                End
34905>>>>>>
34905>>>>>            End
34905>>>>>>
34905>>>>>
34905>>>>>            // This is send to the parent container object (cDbUpdateHandler)
34905>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
34907>>>>>
34907>>>>>            // If the parent property pbContinueOnError = False, an update
34907>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
34907>>>>>            Delegate Get pbContinueOnError to bContinueOnError
34909>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
34911>>>>>                Procedure_Return
34912>>>>>            End
34912>>>>>>
34912>>>>>
34912>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
34914>>>>>
34914>>>>>            Set Title_Text of ghoStatusPanel to (CS_UpdateVersion * CS_UpdateFromVersion * String(nCurrentValue) * CS_UpdateToVersion * String(nVersion))
34915>>>>>
34915>>>>>            // *** Programmer's main hook event for database update functions:
34915>>>>>            Send OnUpdate
34916>>>>>
34916>>>>>            Set pbVersionUpdate to True
34917>>>>>            Send UpdateVersionColumnValue
34918>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
34920>>>>>        End
34920>>>>>>
34920>>>>>
34920>>>>>    End_Procedure
34921>>>>>
34921>>>>>End_Class
34922>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateUserCount.pkg)
34922>>>>>//****************************************************************************
34922>>>>>// $Module type: Class
34922>>>>>// $Module name: cDbUpdateUserCount.pkg
34922>>>>>// $Author     : Emil Stojanov Quantaris B.V.
34922>>>>>//
34922>>>>>//               Collected from DAW's newsgroups.
34922>>>>>//
34922>>>>>// Description : It uses the windows API to lock bytes in a file.
34922>>>>>//               If the application or PC craches it will release the lock
34922>>>>>//               automatically.
34922>>>>>//
34922>>>>>// Note 1      : It will count the number of running app's, so if a
34922>>>>>//               user starts the app twice on one machine it will count as two users.
34922>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
34922>>>>>//               However, to not conflict with any other usage of this class it was
34922>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
34922>>>>>//               and cDbUpdateVersion classes)
34922>>>>>//
34922>>>>>// $Rev History:
34922>>>>>//    2008-10-17  Module header created (Militaty data format)
34922>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
34922>>>>>//                for easy translation to other languages.
34922>>>>>//                Added the tUserCount struct for easier passing of parameters.
34922>>>>>//                Added the ApplicationPath message.
34922>>>>>//****************************************************************************
34922>>>>>Use LanguageText.pkg
34922>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF18\DbUpdateFramework2.0\AppSrc\cDbUpdateUserCount.inc)
34922>>>>>>>Use GlobalFunctionsProcedures.pkg
34922>>>>>>>// Sample:
34922>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
34922>>>>>>>
34922>>>>>>>
34922>>>>>>>// Symbols used by UserCounting
34922>>>>>>>    Define GENERIC_READ         for |CI$80000000
34922>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
34922>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
34922>>>>>>>    Define GENERIC_ALL          for |CI$10000000
34922>>>>>>>    Define CREATE_NEW           for 1
34922>>>>>>>    Define CREATE_ALWAYS        for 2
34922>>>>>>>    Define OPEN_EXISTING        for 3
34922>>>>>>>    Define OPEN_ALWAYS          for 4
34922>>>>>>>    Define TRUNCATE_EXISTING    for 5
34922>>>>>>>    Define FILE_BEGIN           for 0
34922>>>>>>>    Define FILE_CURRENT         for 1
34922>>>>>>>    Define FILE_END             for 2
34922>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
34922>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
34922>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
34922>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
34922>>>>>>>    Define _MAX_PATH  for 260
34922>>>>>>>    Define _MAX_DRIVE for 3
34922>>>>>>>    Define _MAX_DIR   for 256
34922>>>>>>>    Define _MAX_FNAME for 256
34922>>>>>>>    Define _MAX_EXT   for 256
34922>>>>>>>
34922>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
34923>>>>>>>
34923>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
34924>>>>>>>
34924>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
34925>>>>>>>
34925>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
34926>>>>>>>
34926>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
34927>>>>>>>
34927>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
34928>>>>>>>
34928>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
34929>>>>>>>
34929>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
34930>>>>>>>// Sample:
34930>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
34930>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
34932>>>>>>>    Boolean bReturn
34932>>>>>>>    Move (ToANSI(sPrinter)) to sPrinter
34933>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
34934>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
34935>>>>>>>    Function_Return bReturn
34936>>>>>>>End_Function
34937>>>>>Use vWin32fh.pkg
34937>>>>>Use seq_chnl.pkg
34937>>>>>
34937>>>>>// User interface constant strings:
34937>>>>>    Define CS_UserCountError            for "User count error:"
34937>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
34937>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
34937>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
34937>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>
34937>>>>>    Struct tUserCount
34937>>>>>        Integer iUserCount
34937>>>>>        Integer iError
34937>>>>>        String  sErrorTxt
34937>>>>>    End_Struct
34937>>>>>
34937>>>>>    Define CI_UserCountMaxUsers for 9999
34937>>>>>
34937>>>>>Class cDbUpdateUserCount is a cObject
34938>>>>>    Procedure Construct_Object
34940>>>>>        Forward Send Construct_Object
34942>>>>>
34942>>>>>        Property String  psLockFileName
34943>>>>>        Property Integer piMaxUsers
34944>>>>>        Property Boolean pbCheckDataFlexUserCount True
34945>>>>>
34945>>>>>        Property Handle  phUserCountFile
34946>>>>>        Property Integer pdwLockPosition
34947>>>>>    End_Procedure
34948>>>>>
34948>>>>>    Function IsProgramRunning Returns Boolean
34950>>>>>        tUserCount UserCount
34950>>>>>        tUserCount UserCount
34950>>>>>
34950>>>>>        Get CheckUserCount to UserCount
34951>>>>>
34951>>>>>        Function_Return (UserCount.iUserCount > 1)
34952>>>>>    End_Function
34953>>>>>
34953>>>>>    // Returns the full path of the Application (no trailing "\")
34953>>>>>    Function ApplicationPath Returns String
34955>>>>>        String sApplicationFileName sPath
34955>>>>>        Integer iNumChars iRetval
34955>>>>>
34955>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
34956>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
34957>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
34958>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
34959>>>>>        Move (CString(sApplicationFileName)) to sPath
34960>>>>>
34960>>>>>        Function_Return sPath
34961>>>>>    End_Function
34962>>>>>
34962>>>>>    Function OpenUserCountFile String sFileName Returns Handle
34964>>>>>        Handle  hFile
34964>>>>>        Pointer pFileName
34964>>>>>        String sPath sFile
34964>>>>>        Integer iCh
34964>>>>>
34964>>>>>        Move (Addressof(sFileName)) to pFileName
34965>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
34966>>>>>
34966>>>>>        // If lock file doesn't exist, create it.
34966>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
34968>>>>>            Get ApplicationPath to sPath
34969>>>>>            Get vFolderFormat sPath to sPath
34970>>>>>            Move (sPath + psLockFileName(Self)) to sFile
34971>>>>>            Get Seq_Open_Output_Channel sFile to iCh
34972>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
34974>>>>>                Function_Return 0
34975>>>>>            End
34975>>>>>>
34975>>>>>            Direct_Output channel iCh sFile
34977>>>>>                Write channel iCh ""
34979>>>>>            Send Seq_Close_Channel iCh
34980>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
34981>>>>>        End
34981>>>>>>
34981>>>>>
34981>>>>>        Function_Return hFile
34982>>>>>    End_Function
34983>>>>>
34983>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
34985>>>>>        Integer iReturnValue 
34985>>>>>        Boolean bOK
34985>>>>>
34985>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
34986>>>>>        If (iReturnValue = 0) Begin
34988>>>>>            Move False to bOK
34989>>>>>        End
34989>>>>>>
34989>>>>>        Else Begin
34990>>>>>            Move True to bOK
34991>>>>>        End
34991>>>>>>
34991>>>>>        Function_Return bOK
34992>>>>>    End_Function
34993>>>>>
34993>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
34995>>>>>        Integer iReturnValue
34995>>>>>        Boolean bOK
34995>>>>>
34995>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
34996>>>>>        If (iReturnValue = 0) Begin
34998>>>>>            Move False to bOK
34999>>>>>        End
34999>>>>>>
34999>>>>>        Else Begin
35000>>>>>            Move True to bOK
35001>>>>>        End           
35001>>>>>>
35001>>>>>        Function_Return bOK
35002>>>>>    End_Function
35003>>>>>
35003>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
35005>>>>>        dWord dwCurrPos
35005>>>>>
35005>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
35006>>>>>        Function_Return dwCurrPos
35007>>>>>    End_Function
35008>>>>>
35008>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
35010>>>>>        DWord dwCurrPos
35010>>>>>
35010>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
35011>>>>>        Function_Return dwCurrPos
35012>>>>>    End_Function
35013>>>>>
35013>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
35015>>>>>        Integer iReturnValue                               
35015>>>>>        Boolean bOK
35015>>>>>        String  sBuffer
35015>>>>>        Pointer pBuffer
35015>>>>>        String  sSize
35015>>>>>        Pointer pSize
35015>>>>>
35015>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
35016>>>>>        Move (AddressOf(sBuffer)) to pBuffer
35017>>>>>
35017>>>>>        Move (Repeat((Character(0)),4)) to sSize
35018>>>>>        Move (AddressOf(sSize)) to pSize
35019>>>>>
35019>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
35020>>>>>        If (iReturnValue = 0) Begin
35022>>>>>            Move False to bOK
35023>>>>>        End
35023>>>>>>
35023>>>>>        Else Begin
35024>>>>>            Move True to bOK
35025>>>>>        End                 
35025>>>>>>
35025>>>>>        Function_Return bOK
35026>>>>>    End_Function
35027>>>>>
35027>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
35029>>>>>        Integer iReturnValue
35029>>>>>
35029>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
35030>>>>>        Function_Return iReturnValue
35031>>>>>    End_Function
35032>>>>>
35032>>>>>    Procedure DoCheckUserCount
35034>>>>>        tUserCount UserCount
35034>>>>>        tUserCount UserCount
35034>>>>>
35034>>>>>        Get CheckUserCount to UserCount
35035>>>>>        // If all is fine, we're done.
35035>>>>>        If (UserCount.iError = 0) Begin
35037>>>>>            Procedure_Return
35038>>>>>        End
35038>>>>>>
35038>>>>>
35038>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
35039>>>>>
35039>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
35041>>>>>            Abort
35042>>>>>>
35042>>>>>        End
35042>>>>>>
35042>>>>>    End_Procedure
35043>>>>>
35043>>>>>    Function CheckUserCount Returns tUserCount
35045>>>>>        Handle  hFile
35045>>>>>        String  sPath sFile
35045>>>>>        Integer iResult
35045>>>>>        DWord   dwFilePos
35045>>>>>        Integer bLocked
35045>>>>>        Integer iMaxUsers
35045>>>>>        Integer iCurUser
35045>>>>>        tUserCount UserCount
35045>>>>>        tUserCount UserCount
35045>>>>>
35045>>>>>        Move 0 to UserCount.iError
35046>>>>>
35046>>>>>        Get phUserCountFile to hFile
35047>>>>>        If (not(hFile)) Begin
35049>>>>>            Get ApplicationPath to sPath
35050>>>>>            Get vFolderFormat sPath to sPath
35051>>>>>            Move (sPath + psLockFileName(Self)) to sFile
35052>>>>>            Get OpenUserCountFile sFile to hFile
35053>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
35055>>>>>                Move 1 to UserCount.iUserCount
35056>>>>>                Move 1 to UserCount.iError
35057>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
35058>>>>>                Function_Return UserCount
35059>>>>>            End
35059>>>>>>
35059>>>>>            Else Begin
35060>>>>>                Move False to bLocked
35061>>>>>                Set phUserCountFile to hFile
35062>>>>>                Get piMaxUsers to iMaxUsers
35063>>>>>
35063>>>>>                // Set Filepointer to beginning of the file
35063>>>>>                Get ResetUserCountPointer hFile to dwFilePos
35064>>>>>                If (dwFilePos = -1) Begin
35066>>>>>                    Move 1 to UserCount.iUserCount
35067>>>>>                    Move 2 to UserCount.iError
35068>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
35069>>>>>                    Function_Return UserCount
35070>>>>>                End
35070>>>>>>
35070>>>>>                For iCurUser from 1 to iMaxUsers
35076>>>>>>
35076>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
35077>>>>>                    If (not(iResult)) Begin  // byte is locked
35079>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
35080>>>>>                        If (dwFilePos = -1) Begin
35082>>>>>                            Move 1 to UserCount.iUserCount
35083>>>>>                            Move 3 to UserCount.iError
35084>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
35085>>>>>                            Function_Return UserCount
35086>>>>>                        End
35086>>>>>>
35086>>>>>                    End
35086>>>>>>
35086>>>>>                    Else Begin  // byte is not locked
35087>>>>>                        Set pdwLockPosition to dwFilePos
35088>>>>>                        Move True to bLocked
35089>>>>>                        Move iMaxUsers to iCurUser
35090>>>>>                    End
35090>>>>>>
35090>>>>>                Loop
35091>>>>>>
35091>>>>>                If (not(bLocked)) Begin
35093>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
35094>>>>>                    Move 4 to UserCount.iError
35095>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
35096>>>>>                    Function_Return UserCount
35097>>>>>                End
35097>>>>>>
35097>>>>>            End
35097>>>>>>
35097>>>>>        End
35097>>>>>>
35097>>>>>
35097>>>>>        Function_Return UserCount
35098>>>>>    End_Function
35099>>>>>
35099>>>>>
35099>>>>>    Procedure DoReleaseUserCount
35101>>>>>        Integer iResult
35101>>>>>        Handle  hFile
35101>>>>>        DWord   dwLockPos
35101>>>>>
35101>>>>>        Get phUserCountFile to hFile
35102>>>>>        Get pdwLockPosition to dwLockPos
35103>>>>>        If (hFile) Begin
35105>>>>>            If (dwLockPos) Begin
35107>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
35108>>>>>            End
35108>>>>>>
35108>>>>>            Get CloseUserCountFile hFile to iResult
35109>>>>>        End
35109>>>>>>
35109>>>>>    End_Procedure
35110>>>>>
35110>>>>>    Function CurrentNumberOfUsers Returns Integer
35112>>>>>        Handle  hFile
35112>>>>>        Integer iMaxUsers
35112>>>>>        DWord   dwFilePos
35112>>>>>        Integer iCurUser
35112>>>>>        Integer iResult
35112>>>>>        Integer iNumberOfLocks
35112>>>>>        String  sPath sFile
35112>>>>>
35112>>>>>        Move 0 to iNumberOfLocks
35113>>>>>
35113>>>>>        Get ApplicationPath to sPath
35114>>>>>        Get vFolderFormat sPath to sPath
35115>>>>>        Move (sPath + psLockFileName(Self)) to sFile
35116>>>>>        Get OpenUserCountFile sFile to hFile
35117>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
35119>>>>>            Send UserError CS_UnableToInitUserCountSys
35120>>>>>            Abort
35121>>>>>>
35121>>>>>        End
35121>>>>>>
35121>>>>>
35121>>>>>        If (hFile > 0) Begin
35123>>>>>            Get piMaxUsers To iMaxUsers
35124>>>>>
35124>>>>>            // Set Filepointer to beginning of the file
35124>>>>>            Get ResetUserCountPointer hFile to dwFilePos
35125>>>>>            If (dwFilePos = -1) Begin
35127>>>>>                Send UserError CS_UnableResetUserCountSys
35128>>>>>                Abort
35129>>>>>>
35129>>>>>            End
35129>>>>>>
35129>>>>>            For iCurUser from 1 to iMaxUsers
35135>>>>>>
35135>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
35136>>>>>                If (Not(iResult)) Begin  // byte is locked
35138>>>>>                    Increment iNumberOfLocks
35139>>>>>                End
35139>>>>>>
35139>>>>>                Else Begin  // byte is not locked
35140>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
35141>>>>>                End
35141>>>>>>
35141>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
35142>>>>>                If (dwFilePos = -1) Begin
35144>>>>>                    Send UserError CS_ErrorAdvancingPointer
35145>>>>>                    Abort
35146>>>>>>
35146>>>>>                End
35146>>>>>>
35146>>>>>            Loop
35147>>>>>>
35147>>>>>        End
35147>>>>>>
35147>>>>>        Get CloseUserCountFile hFile to iResult
35148>>>>>        Function_Return iNumberOfLocks
35149>>>>>    End_Function
35150>>>>>
35150>>>>>End_Class
35151>>>Use cDbUpdateFunctionLibrary.pkg
35151>>>
35151>>>//{ DataBindable=True }
35151>>>Class cDbUpdateHandler is a cObject
35152>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
35152>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
35153>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
35154>>>
35154>>>    Procedure Construct_Object
35156>>>        tUserCount UserCount
35156>>>        tUserCount UserCount
35156>>>        Integer iUserCount
35156>>>        Handle ho                     
35156>>>
35156>>>        Forward Send Construct_Object
35158>>>        Move Self to ghoDbUpdateHandler  
35159>>>        
35159>>>        // Latin1_General_CI_AS = General Insensitive collation
35159>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
35159>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
35159>>>        // Good read about which collation to select:
35159>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
35159>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
35160>>>
35160>>>        // Struct array that will contain pnVersionNumbers & object id's of
35160>>>        // all child cDbVersion objects.
35160>>>        Property tDbVersionInfo[] paDbVersionInfoArray
35161>>>
35161>>>        Property Boolean Private.pbDbVersionCheckDone False
35162>>>
35162>>>        Property Boolean pbUseCustomDbVersion False  
35163>>>        
35163>>>        // If this property = True _and_ no DbVersion table exists 
35163>>>        // when the framework is started, a DbVersion table will be created automatically.
35163>>>        Property Boolean pbAutoCreateDbVersionTable True
35164>>>
35164>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
35164>>>        // the Filelist.cfg slot number indicated by this property will be used
35164>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
35164>>>        // an Unhandled Exception Error will be genereted and the program halted. So
35164>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
35164>>>        // to a value that corresponds to a free Filelist.cfg slot number.
35164>>>        Property Integer Private.piDbVersionFileNumber -1
35165>>>        Property Integer Private.piDbVersionFieldNumber 1
35166>>>
35166>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
35166>>>        // that creates all library properties
35166>>>        Send CreateDbUpdateLibraryProperties
35167>>>
35167>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
35168>>>
35168>>>        // Error handling:
35168>>>        Property Boolean Private.pbProcessingError False
35169>>>        Property Boolean pbDbUpdateErrorHasOccured False
35170>>>        // Don't touch. It is being used by the cDbUpdateVersion
35170>>>        // subclass to tell if that particular update went OK or not.
35170>>>        Property Boolean Private.pbUpdateVersionObjectError False
35171>>>        Property String[] paSQLQueryMessages
35172>>>
35172>>>        // Error handling:
35172>>>        // We temporarily redirect all errors to this object so we can
35172>>>        // log and write errors to the log file. It will be reset after
35172>>>        // the database updates have been finished.
35172>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
35173>>>        // Temporarily redirect all errors to this object so we can silently
35173>>>        // log all errors that might appear while updating the database.
35173>>>        Move Self to Error_Object_Id
35174>>>
35174>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
35175>>>
35175>>>        // Error Reporting Related
35175>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
35175>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
35176>>>
35176>>>        // If the pbContinueOnError = False, an update
35176>>>        // of another cDbUpdateVersion object will _not_ be
35176>>>        // performed if an error occured in a previous
35176>>>        // cDbUpdateVersion object.
35176>>>        Property Boolean pbContinueOnError False
35177>>>        // Stops execution in other cDbUpdateVersion objecs,
35177>>>        // if errors occurred in one cDbUpdateVersion object.
35177>>>        Property Boolean pbStopOnFirstError False
35178>>>        // If True errors that occured while updating the database
35178>>>        // will be shown in the default app for .txt files when done.
35178>>>        // Note: The log file will _always_ be created in the Data folder.
35178>>>        Property Boolean pbShowErrorLogPostRun True
35179>>>
35179>>>        // Be _very_ careful to set this property to true!
35179>>>        // If = True, no question will be asked if the update
35179>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
35179>>>        // the error log won't be shown. The logfile itself will still be created though.
35179>>>        // You have to know what you're doing!
35179>>>        Property Boolean pbSilentMode False
35180>>>
35180>>>        // Don't touch! Very private. The value is used by the error log to write for which
35180>>>        // cDbUpdateVersion object an error occured.
35180>>>        Property Number pnCurrentVersionUpdate 0
35181>>>
35181>>>        // The user counting logic is used to safe-guard agains anybody else is
35181>>>        // using the application when a database update is to be performed.
35181>>>        // (Garters & suspenders!)
35181>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
35182>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
35183>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
35184>>>
35184>>>        // This lock file is used to guard against somebody else tries to start the
35184>>>        // application while updates are in progress.
35184>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
35185>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
35186>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
35187>>>                                                                                      // Only the current user allowed.
35187>>>        // Properties for the table & column of a system file field/column where
35187>>>        // the database version update number gets saved.
35187>>>        Property Integer Private.Data_File  0
35188>>>        Property Integer Private.Data_Field 0
35189>>>
35189>>>        // Property that is used to indicate that we have already
35189>>>        // started the database update.
35189>>>        Property Boolean Private.pbDatabaseUpdateStarted False
35190>>>
35190>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
35190>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
35190>>>        // change of the database has been made.
35190>>>        Property Boolean Private.pbDatabaseWasUpdated False
35191>>>
35191>>>        // We need to trigger the user counting system so that a bit in the
35191>>>        // user counting file is locked. This is to guard that not more than one user
35191>>>        // is currently runnning the program.
35191>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
35192>>>
35192>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
35193>>>        If (iUserCount > 0) Begin
35195>>>            Send Stop_Box CS_UpdateInProgressTxt
35196>>>            Send Exit_Application
35197>>>        End
35197>>>>
35197>>>
35197>>>        Set pbHandleQueryErrors to False
35198>>>
35198>>>        If (ghoDbUpdateFunctionLibrary = 0) Begin
35200>>>            Move Self to ghoDbUpdateFunctionLibrary
35201>>>        End
35201>>>>
35201>>>
35201>>>        Property Handle phoSQLConnectionHandler 0
35202>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
35202>>>        // we will create one as it is used for all ConnectionID, ConnectionString
35202>>>        // etc information.
35202>>>        If (ghoSQLConnectionHandler = 0) Begin
35204>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
35205>>>            Set phoSQLConnectionHandler to ho
35206>>>        End
35206>>>>
35206>>>        
35206>>>        Set Icon to "Default.ico"
35207>>>    End_Procedure
35208>>>
35208>>>    Procedure End_Construct_Object
35210>>>        Forward Send End_Construct_Object
35212>>>        Send Cleanup
35213>>>    End_Procedure
35214>>>
35214>>>    Procedure CheckAutoCreateDbVersionTable
35216>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
35216>>>        Integer iDbVersionFileNumber iRetval 
35216>>>
35216>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
35217>>>        If (bDbVersionCheckDone = True) Begin
35219>>>            Procedure_Return
35220>>>        End
35220>>>>
35220>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
35221>>>        If (bUseCustomDbVersion = True) Begin
35223>>>            Procedure_Return
35224>>>        End
35224>>>>
35224>>>
35224>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
35225>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
35227>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
35228>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
35229>>>>
35229>>>            Send Exit_Application
35230>>>        End
35230>>>>
35230>>>
35230>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
35231>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
35232>>>        If (bTableExists = True) Begin
35234>>>            Set Private.pbDbVersionCheckDone to True
35235>>>            Procedure_Return
35236>>>        End
35236>>>>
35236>>>
35236>>>        Send CreateDbVersionTable iDbVersionFileNumber
35237>>>
35237>>>        // We only need to these DbVersion checks once, but because this message is called
35237>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
35237>>>        // we use a property to only run these tests once.
35237>>>        Set Private.pbDbVersionCheckDone to True
35238>>>    End_Procedure
35239>>>
35239>>>    Procedure CreateDbVersionTable Handle hTable
35241>>>        String sTableName sColumnName sInfoTxt sDriverID 
35241>>>        Integer iLength
35241>>>        Boolean bTableExists bOK bUseConnectionID
35241>>>        tAPIColumn[] APIColumn
35241>>>        tAPIColumn[] APIColumn
35242>>>
35242>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
35243>>>        If (bTableExists = True) Begin
35245>>>            Procedure_Return
35246>>>        End
35246>>>>
35246>>>
35246>>>        Get psDriverID to sDriverID
35247>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
35248>>>
35248>>>        Move "DbVersion"        to sTableName
35249>>>        Move 1                  to APIColumn[0].iFieldNumber
35250>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
35251>>>        Move DF_BCD             to APIColumn[0].iType
35252>>>        Move False              to APIColumn[0].bIsSQLType
35253>>>        Move 4                  to APIColumn[0].iLength
35254>>>        Move 2                  to APIColumn[0].iPrecision
35255>>>
35255>>>        Move False to Err                                
35256>>>        
35256>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
35256>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
35256>>>        Set psDriverID to DATAFLEX_ID
35257>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
35258>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
35259>>>        Set psDriverID to sDriverID
35260>>>        
35260>>>        If (bOK = True and Err = False) Begin
35262>>>            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
35263>>>        End
35263>>>>
35263>>>        Else Begin
35264>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
35265>>>        End
35265>>>>
35265>>>
35265>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
35266>>>    End_Procedure
35267>>>
35267>>>    Procedure Set pbVerboseState Boolean bVerboseState
35269>>>        Handle ho
35269>>>        Get phoLogFile to ho
35270>>>        Set pbVerboseState of ho to bVerboseState
35271>>>    End_Procedure
35272>>>
35272>>>    Function pbVerboseState Returns Boolean
35274>>>        Boolean bVerboseState
35274>>>        Handle ho
35274>>>        Get phoLogFile to ho
35275>>>        Get pbVerboseState of ho to bVerboseState
35276>>>        Function_Return bVerboseState
35277>>>    End_Function
35278>>>
35278>>>    // Callback functionality used when e.g. calling driver functions directly.
35278>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
35278>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
35280>>>        Integer iPerc
35280>>>        Number nReady nTotal nVersion
35280>>>        Boolean bVerboseState
35280>>>        Handle hoLogFile
35280>>>
35280>>>        Get pbVerboseState to bVerboseState
35281>>>        Get pnCurrentVersionUpdate to nVersion
35282>>>        Get phoLogFile     to hoLogFile
35283>>>        Send DoAdvance of ghoProgressBar
35284>>>
35284>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
35286>>>            Move (Replace("Dropping index", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
35287>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_SQLDeletingIndex)) to sCallback_Text
35288>>>        End
35288>>>>
35288>>>        If (sCallback_Text contains "Creating index") Begin
35290>>>            Move (Replace("Creating index", sCallback_Text, CS_SQLCreatingIndex)) to sCallback_Text
35291>>>        End
35291>>>>
35291>>>
35291>>>        Case Begin
35291>>>            Case (iCallback_Type = DF_Message_Text)
35293>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
35294>>>                Set Action_Text  of ghoStatusPanel to ""
35295>>>                If (bVerboseState = True) Begin
35297>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
35298>>>                End
35298>>>>
35298>>>                Case Break
35299>>>            Case (iCallback_Type = DF_Message_Heading_1)
35302>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
35303>>>                If (bVerboseState = True) Begin
35305>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
35306>>>                End
35306>>>>
35306>>>                Case Break
35307>>>            Case (iCallback_Type = DF_Message_Heading_2)
35310>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
35311>>>                Set Action_Text  of ghoStatusPanel to ""
35312>>>                If (bVerboseState = True) Begin
35314>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
35315>>>                End
35315>>>>
35315>>>                Case Break
35316>>>            Case (iCallback_Type = DF_Message_Heading_3)
35319>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
35320>>>                Set Action_Text  of ghoStatusPanel to ""
35321>>>                If (bVerboseState = True) Begin
35323>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
35324>>>                End
35324>>>>
35324>>>                Case Break
35325>>>            Case (iCallback_Type = DF_Message_Heading_4)
35328>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
35329>>>                Set Action_Text  of ghoStatusPanel to ""
35330>>>                If (bVerboseState = True) Begin
35332>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
35333>>>                End
35333>>>>
35333>>>                Case Break
35334>>>            Case (iCallback_Type = DF_Message_Heading_5)
35337>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
35338>>>                Set Action_Text  of ghoStatusPanel to ""
35339>>>                If (bVerboseState = True) Begin
35341>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
35342>>>                End
35342>>>>
35342>>>                Case Break
35343>>>            Case (iCallback_Type = DF_Message_Warning)
35346>>>                If (bVerboseState = True) Begin
35348>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
35349>>>                End
35349>>>>
35349>>>                Case Break
35350>>>            Case (iCallback_Type = DF_Message_Progress_Title)
35353>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
35354>>>                Set Action_Text  of ghoStatusPanel to ""
35355>>>                If (bVerboseState = True) Begin
35357>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
35358>>>                End
35358>>>>
35358>>>                Case Break
35359>>>            Case (iCallback_Type = DF_Message_Progress_Value)
35362>>>                //*** Interpret numbers
35362>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
35363>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
35364>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
35365>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
35366>>>                Set piPosition of ghoProgressBar to iPerc
35367>>>                Case Break
35368>>>            Case Else
35368>>>                Set Message_Text to ""
35369>>>                Set Action_Text  to ""
35370>>>        Case End
35370>>>
35370>>>        Send ProcessEvents of ghoStatusPanel
35371>>>        Function_Return False
35372>>>    End_Function
35373>>>
35373>>>    // This was made to be a procedure/function pair so we
35373>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
35373>>>    Procedure Set psDriverID String sDriverID
35375>>>        If (ghoSQLConnectionHandler = 0) Begin
35377>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35378>>>>
35378>>>            Procedure_Return
35379>>>        End
35379>>>>
35379>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
35380>>>    End_Procedure
35381>>>
35381>>>    Function psDriverID Returns String
35383>>>        String sValue
35383>>>        If (ghoSQLConnectionHandler = 0) Begin
35385>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35386>>>>
35386>>>            Function_Return ""
35387>>>        End
35387>>>>
35387>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
35388>>>        Function_Return sValue
35389>>>    End_Function
35390>>>
35390>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
35392>>>        If (ghoSQLConnectionHandler = 0) Begin
35394>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35395>>>>
35395>>>            Procedure_Return
35396>>>        End
35396>>>>
35396>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
35397>>>    End_Procedure
35398>>>
35398>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
35400>>>        Integer iRetval
35400>>>        If (ghoSQLConnectionHandler = 0) Begin
35402>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35403>>>>
35403>>>            Function_Return 2
35404>>>        End
35404>>>>
35404>>>
35404>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
35405>>>        Function_Return iRetval
35406>>>    End_Function
35407>>>
35407>>>    Procedure Set psConnectionID String sValue
35409>>>        If (ghoSQLConnectionHandler = 0) Begin
35411>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35412>>>>
35412>>>            Procedure_Return
35413>>>        End
35413>>>>
35413>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
35414>>>    End_Procedure
35415>>>
35415>>>    Function psConnectionID Returns String
35417>>>        String sValue
35417>>>        If (ghoSQLConnectionHandler = 0) Begin
35419>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35420>>>>
35420>>>            Function_Return ""
35421>>>        End
35421>>>>
35421>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
35422>>>
35422>>>        Function_Return sValue
35423>>>    End_Function
35424>>>
35424>>>    // These "properties" are settings of the cCLIHandler class, but are being
35424>>>    // relayed to the ghoSQLConnectionHandler object
35424>>>    // simply by changing one of its parameters.
35424>>>    Procedure Set psServer String sValue
35426>>>        If (ghoSQLConnectionHandler = 0) Begin
35428>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35429>>>>
35429>>>            Procedure_Return
35430>>>        End
35430>>>>
35430>>>        Set psServer of ghoSQLConnectionHandler to sValue
35431>>>    End_Procedure
35432>>>
35432>>>    Function psServer Returns String
35434>>>        String sValue
35434>>>        If (ghoSQLConnectionHandler = 0) Begin
35436>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35437>>>>
35437>>>            Function_Return ""
35438>>>        End
35438>>>>
35438>>>        Get psServer of ghoSQLConnectionHandler to sValue
35439>>>
35439>>>        Function_Return sValue
35440>>>    End_Function
35441>>>
35441>>>    Procedure Set psDatabase String sValue
35443>>>        If (ghoSQLConnectionHandler = 0) Begin
35445>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35446>>>>
35446>>>            Procedure_Return
35447>>>        End
35447>>>>
35447>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
35448>>>    End_Procedure
35449>>>
35449>>>    Function psDatabase Returns String
35451>>>        String sValue
35451>>>        If (ghoSQLConnectionHandler = 0) Begin
35453>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35454>>>>
35454>>>            Function_Return ""
35455>>>        End
35455>>>>
35455>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
35456>>>
35456>>>        Function_Return sValue
35457>>>    End_Function
35458>>>
35458>>>    Procedure Set psUserID String sValue
35460>>>        If (ghoSQLConnectionHandler = 0) Begin
35462>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35463>>>>
35463>>>            Procedure_Return
35464>>>        End
35464>>>>
35464>>>        Set psUserID of ghoSQLConnectionHandler to sValue
35465>>>    End_Procedure
35466>>>
35466>>>    Function psUserID Returns String
35468>>>        String sValue
35468>>>        If (ghoSQLConnectionHandler = 0) Begin
35470>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35471>>>>
35471>>>            Function_Return ""
35472>>>        End
35472>>>>
35472>>>        Get psUserID of ghoSQLConnectionHandler to sValue
35473>>>
35473>>>        Function_Return sValue
35474>>>    End_Function
35475>>>
35475>>>    Procedure Set psPassword String sValue
35477>>>        If (ghoSQLConnectionHandler = 0) Begin
35479>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35480>>>>
35480>>>            Procedure_Return
35481>>>        End
35481>>>>
35481>>>        Set psPassword of ghoSQLConnectionHandler to sValue
35482>>>    End_Procedure
35483>>>
35483>>>    Function psPassword Returns String
35485>>>        String sValue
35485>>>        If (ghoSQLConnectionHandler = 0) Begin
35487>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35488>>>>
35488>>>            Function_Return ""
35489>>>        End
35489>>>>
35489>>>        Get psPassword of ghoSQLConnectionHandler to sValue
35490>>>
35490>>>        Function_Return sValue
35491>>>    End_Function
35492>>>
35492>>>    Procedure Set pbTrusted Boolean bValue
35494>>>        If (ghoSQLConnectionHandler = 0) Begin
35496>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35497>>>>
35497>>>            Procedure_Return
35498>>>        End
35498>>>>
35498>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
35499>>>    End_Procedure
35500>>>
35500>>>    Function pbTrusted Returns Boolean
35502>>>        Boolean bValue
35502>>>        If (ghoSQLConnectionHandler = 0) Begin
35504>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35505>>>>
35505>>>            Function_Return False
35506>>>        End
35506>>>>
35506>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
35507>>>
35507>>>        Function_Return bValue
35508>>>    End_Function
35509>>>
35509>>>    Procedure Set psConnectionString String sValue
35511>>>        If (ghoSQLConnectionHandler = 0) Begin
35513>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35514>>>>
35514>>>            Procedure_Return
35515>>>        End
35515>>>>
35515>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
35516>>>    End_Procedure
35517>>>
35517>>>    Function psConnectionString Returns String
35519>>>        String sValue
35519>>>        If (ghoSQLConnectionHandler = 0) Begin
35521>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35522>>>>
35522>>>            Function_Return ""
35523>>>        End
35523>>>>
35523>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
35524>>>
35524>>>        Function_Return sValue
35525>>>    End_Function
35526>>>
35526>>>    Function piConnectionOptions Returns Integer
35528>>>        Integer iValue
35528>>>        If (ghoSQLConnectionHandler = 0) Begin
35530>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
35531>>>>
35531>>>            Function_Return 0
35532>>>        End
35532>>>>
35532>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
35533>>>
35533>>>        Function_Return iValue
35534>>>    End_Function
35535>>>
35535>>>
35535>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
35537>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
35538>>>    End_Procedure
35539>>>
35539>>>    Function pbCheckDataFlexUserCount Returns Boolean
35541>>>        Boolean bState
35541>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
35542>>>        Function_Return bState
35543>>>    End_Function
35544>>>
35544>>>    Procedure Set psLogTextFile String sValue
35546>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
35547>>>    End_Procedure
35548>>>
35548>>>    Function psLogTextFile Returns String
35550>>>        String sValue
35550>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
35551>>>        Function_Return sValue
35552>>>    End_Function
35553>>>
35553>>>    Procedure Set psEditorProgram String sValue
35555>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
35556>>>    End_Procedure
35557>>>
35557>>>    Function psEditorProgram Returns String
35559>>>        String sValue
35559>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
35560>>>        Function_Return sValue
35561>>>    End_Function
35562>>>
35562>>>    Procedure Set pbUseDataTableLog Boolean bState
35564>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
35565>>>    End_Procedure
35566>>>
35566>>>    Function pbUseDataTableLog Returns Boolean
35568>>>        Boolean bState
35568>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
35569>>>        Function_Return bState
35570>>>    End_Function
35571>>>
35571>>>    Procedure Set pbQuickWrite Boolean bState
35573>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
35574>>>    End_Procedure
35575>>>
35575>>>    Function pbQuickWrite Returns Boolean
35577>>>        Boolean bState
35577>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
35578>>>        Function_Return bState
35579>>>    End_Function
35580>>>
35580>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
35582>>>        Boolean bUpdateVersionObjectError bVerboseState
35582>>>        Integer iSize iCount
35582>>>        Number nVersion
35582>>>        String[] aSQLQueryMessages
35583>>>
35583>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
35584>>>        Set Private.pbDatabaseWasUpdated to bState
35585>>>        // If no errors occurred in the current cDbUpdateVersion object - write
35585>>>        // to the log that it was OK.
35585>>>        If (bUpdateVersionObjectError = False) Begin
35587>>>            Get pnCurrentVersionUpdate to nVersion
35588>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
35589>>>        End
35589>>>>
35589>>>
35589>>>        Get pbVerboseState to bVerboseState
35590>>>        If (bVerboseState = True) Begin
35592>>>            Get paSQLQueryMessages to aSQLQueryMessages
35593>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
35594>>>            Decrement iSize
35595>>>            For iCount from 0 to iSize
35601>>>>
35601>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
35602>>>            Loop
35603>>>>
35603>>>        End
35603>>>>
35603>>>
35603>>>    End_Procedure 
35604>>>    
35604>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
35606>>>        Set Private.piDbVersionFileNumber to iFileNumber
35607>>>    End_Procedure                                         
35608>>>    
35608>>>    Function piDbVersionFileNumber Returns Integer
35610>>>        Function_Return (Private.piDbVersionFileNumber(Self))
35611>>>    End_Function
35612>>>
35612>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
35614>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
35615>>>    End_Procedure                                         
35616>>>    
35616>>>    Function piDbVersionFieldNumber Returns Integer
35618>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
35619>>>    End_Function
35620>>>
35620>>>    Function pbDatabaseWasUpdated Returns Boolean
35622>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
35623>>>    End_Function
35624>>>
35624>>>    Procedure ReinitializeFramework  
35626>>>        tDbVersionInfo[] aDbVersionInfoArray
35626>>>        tDbVersionInfo[] aDbVersionInfoArray
35627>>>        Handle hoDbVersionObject
35627>>>        Integer iSize iCount
35627>>>        
35627>>>        Set Private.pbDatabaseUpdateStarted to False
35628>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
35629>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
35630>>>        Decrement iSize
35631>>>        
35631>>>        For iCount from 0 to iSize
35637>>>>
35637>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
35638>>>            Send ProcessUpdate                  of hoDbVersionObject False
35639>>>        Loop
35640>>>>
35640>>>        Send Cleanup
35641>>>    End_Procedure
35642>>>    
35642>>>    // This event is triggered by the cDbUpdateVersion child class when
35642>>>    // a database change is to be started, and is considered private.
35642>>>    // It is only executed once for the first cDbUpateVersion object!
35642>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
35644>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
35644>>>        Integer iRetval iDataFlexUsers iUserCount
35644>>>        Handle hoUserCountSystem
35644>>>        tUserCount UserCount
35644>>>        tUserCount UserCount
35644>>>        DateTime dtUpdateStarted
35644>>>        tSQLConnection SQLConnection
35644>>>        tSQLConnection SQLConnection
35644>>>        String sDriverID
35644>>>
35644>>>        // *Important:* If we already started the update; we do no further checking.
35644>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
35645>>>        If (bDatabaseUpdateStarted = True) Begin
35647>>>            Procedure_Return
35648>>>        End
35648>>>>
35648>>>
35648>>>        // If not silent mode; Ask user if OK to start database update.
35648>>>        If (pbSilentMode(Self) = False) Begin
35650>>>            Get YesNo_Box CS_DatabaseNeedsUpdate CS_HeaderUpdateText to iRetval
35651>>>            If (iRetval <> MBR_Yes) Begin
35653>>>                Send Exit_Application
35654>>>            End
35654>>>>
35654>>>        End
35654>>>>
35654>>>        
35654>>>        Send EnableCancelButton     of ghoStatusPanel False
35655>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_WorkingUpdateText) CS_WorkingHeaderText ""
35656>>>        Send Start_StatusPanel      of ghoStatusPanel
35657>>>
35657>>>        // This will save the status of all open tables including Master/Alias settings,
35657>>>        // so we can restore them later;
35657>>>        Send SaveOpenTables
35658>>>
35658>>>        Move 0 to iDataFlexUsers
35659>>>        // Make various tests to check that the database is not in use.
35659>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
35660>>>        // We also use our own user counting mechanism to guard against the
35660>>>        // database isn't opened already as we need exclusive access to the tables.:
35660>>>        Get phoUserCountSystem to hoUserCountSystem
35661>>>        Get CheckUserCount of hoUserCountSystem to UserCount
35662>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
35663>>>
35663>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
35664>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
35664>>>        If (bCheckDataFlexUserCount = True) Begin
35666>>>            Get_Current_User_Count to iDataFlexUsers
35667>>>            // For some reason DataFlex - in some cases - might think that 2 users
35667>>>            // are in use while debugging from the Studio.
35667>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
35669>>>                Decrement iDataFlexUsers
35670>>>            End
35670>>>>
35670>>>        End
35670>>>>
35670>>>
35670>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
35672>>>            Get YesNo_Box CS_DatabaseInUseShort to iRetval
35673>>>            If (iRetval <> MBR_Yes) Begin
35675>>>                Send Exit_Application
35676>>>            End
35676>>>>
35676>>>        End
35676>>>>
35676>>>
35676>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
35678>>>            Send Stop_Box CS_DatabaseInUseText
35679>>>            Send Exit_Application
35680>>>        End
35680>>>>
35680>>>
35680>>>        // This will put a look on the DbUpdateLock.ucf file.
35680>>>        // It is released when the update process is finished
35680>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
35681>>>
35681>>>        Move (CurrentDateTime()) to dtUpdateStarted
35682>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
35683>>>        Set Private.pbDatabaseUpdateStarted to True
35684>>>
35684>>>        // We need to close all tables before starting to make changes.
35684>>>        Close DF_ALL DF_PERMANENT
35685>>>
35685>>>        // If these properties has not exclicitly been set in the object, set them
35685>>>        // to settings from the SQLConnections.ini file;
35685>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
35686>>>        If (psSchema(Self) = "") Begin
35688>>>            Set psSchema            to SQLConnection.sSchema
35689>>>        End
35689>>>>
35689>>>        If (psBaseTableSpace(Self) = "") Begin
35691>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
35692>>>        End
35692>>>>
35692>>>        If (psLongTableSpace(Self) = "") Begin
35694>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
35695>>>        End
35695>>>>
35695>>>        If (psIndexTableSpace(Self) = "") Begin
35697>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
35698>>>        End
35698>>>>
35698>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
35700>>>            Procedure_Return
35701>>>        End
35701>>>>
35701>>>
35701>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
35702>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
35704>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
35705>>>            Send Stop_StatusPanel of ghoStatusPanel
35706>>>            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
35707>>>>
35707>>>            Send Exit_Application
35708>>>        End
35708>>>>
35708>>>    End_Procedure
35709>>>
35709>>>    // *** Hook message for pre-processing ***
35709>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
35709>>>    // Aka, when another table than the standard "DbVersion" is used.
35709>>>    Procedure OnCreateCustomDbVersionTable
35711>>>    End_Procedure
35712>>>    
35712>>>    // *** Hook message for pre-processing ***
35712>>>    // The programmer can use this event for putting code that
35712>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
35712>>>    // child objects are executed.
35712>>>    Procedure OnPreUpdate
35714>>>    End_Procedure
35715>>>
35715>>>    // *** Hook message for post-processing ***
35715>>>    // The programmer should use this event for putting code that
35715>>>    // needs to be executed _after_ all database updates have finished.
35715>>>    Procedure OnPostUpdate
35717>>>    End_Procedure
35718>>>
35718>>>    // *** Hook message for custom DbVersion record find ***
35718>>>    // The programmer can use this event for putting code that
35718>>>    // needs to be executed to find a *custom* DbVersion table record.
35718>>>    // By default the DbVersion table is used but this can be
35718>>>    // customized by adding this line to the code;
35718>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
35718>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
35718>>>    //       to save the current database version to. Only if you use your own
35718>>>    //       table _and_ it is not a system table (contains only one record).
35718>>>    Procedure OnFindVersionRecord
35720>>>        // Open MyTable
35720>>>        // Move xx to MyTable.Field1
35720>>>        // Move yy to MyTable.Field2
35720>>>        // Find le MyTable by Index.x
35720>>>    End_Procedure
35721>>>
35721>>>    // Hook event for writing header error text (pre-update) to
35721>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
35721>>>    // Don't forget to Open the table first (!) as all
35721>>>    // tables have been closed at this stage.
35721>>>    // The start date & time is passed.
35721>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
35723>>>    End_Procedure
35724>>>
35724>>>    // Hook event to log errors to a database table.
35724>>>    // Only called if the pbUseDataTableLog = True.
35724>>>    // Don't forget to Open the table first (!) as all
35724>>>    // tables have been closed at this stage.
35724>>>    // If pbQuickWrite = True the DbUpdateErrorArray
35724>>>    // will contain just one row, as it is called for each error
35724>>>    // that occurred. Else it is called once at the end after all updates
35724>>>    // have run and contains all errors.
35724>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
35726>>>    End_Procedure
35727>>>
35727>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
35727>>>    Procedure Cleanup
35729>>>        Integer[] iFileMasterArray iFileAliasArray
35731>>>        Boolean bDatabaseWasUpdated bError
35731>>>
35731>>>        Send RestoreOpenTables
35732>>>
35732>>>        // The function library have two purposes; one is to use it in the
35732>>>        // Database Update Framework, but it can also be used on its own.
35732>>>        // If that is the case it has its own error handling system, which
35732>>>        // we temporarily disbled when running updates because we have
35732>>>        // error handling/logging here too... We now restore its setting.
35732>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
35734>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
35735>>>        End
35735>>>>
35735>>>        Set pbHandleQueryErrors to True
35736>>>
35736>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
35737>>>        Get pbDbUpdateErrorHasOccured to bError
35738>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
35740>>>
35740>>>            // We should always create the log as it also contains info about
35740>>>            // the update being successful.
35740>>>            Send WriteErrorLog of (phoLogFile(Self))
35741>>>
35741>>>            // This is a programmer's hook message:
35741>>>            Send OnPostUpdate
35742>>>
35742>>>            Send Stop_StatusPanel of ghoStatusPanel
35743>>>
35743>>>            If (pbSilentMode(Self) = False) Begin
35745>>>                If (bError = True) Begin
35747>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
35749>>>                        Send ShowErrorLog of (phoLogFile(Self))
35750>>>                    End
35750>>>>
35750>>>                    Send Info_Box CS_DbUpdatedErrorText
35751>>>                    Send Exit_Application
35752>>>                End
35752>>>>
35752>>>                Else Begin
35753>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
35755>>>                        Send Info_Box CS_DatabaseUpdatedText
35756>>>                    End
35756>>>>
35756>>>                    Else Begin
35757>>>                        Send Info_Box CS_DatabaseCheckedText
35758>>>                    End
35758>>>>
35758>>>
35758>>>                End
35758>>>>
35758>>>            End
35758>>>>
35758>>>        End
35758>>>>
35758>>>
35758>>>        // Restore the standard error handler:
35758>>>        Get piCurrentErrorHandlerID to Error_Object_Id
35759>>>    End_Procedure
35760>>>
35760>>>    // We do this _before_ we close the database to make changes, and save
35760>>>    // all 'Master' & 'Alias' tables settings so we can restore when
35760>>>    // we reopen the database.
35760>>>    Procedure SaveOpenTables
35762>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
35762>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
35763>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
35764>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
35765>>>    End_Procedure
35766>>>
35766>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
35766>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
35766>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
35768>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
35768>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
35769>>>        Integer hTable iMasterAliasType iSize
35769>>>        Boolean bOpen
35769>>>
35769>>>        Move 0 to hTable
35770>>>        Repeat
35770>>>>
35770>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
35773>>>            If (hTable <> 0) Begin
35775>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
35778>>>                If (bOpen = True) Begin
35780>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
35783>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
35784>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
35785>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
35786>>>                End
35786>>>>
35786>>>            End
35786>>>>
35786>>>        Until (hTable = 0)
35788>>>
35788>>>        Function_Return aDbUpdateHandlerMasterAlias
35789>>>    End_Function
35790>>>
35790>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
35790>>>    // Takes one parameter:
35790>>>    //   A struct array with all master & alias
35790>>>    Procedure RestoreOpenTables
35792>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
35792>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
35793>>>        Integer hTable iFileAlias iSize iCount
35793>>>        Boolean bOpen
35793>>>        String sRootName
35793>>>
35793>>>        Move 0 to hTable
35794>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
35795>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
35796>>>        Decrement iSize
35797>>>        For iCount from 0 to iSize
35803>>>>
35803>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
35804>>>            // We also need to check that the table hasn't been removed...
35804>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
35807>>>            If (hTable <> 0 and sRootName <> "") Begin
35809>>>                Open hTable
35811>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
35814>>>                If (bOpen = True) Begin
35816>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
35817>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
35819>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
35822>>>                    End
35822>>>>
35822>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
35825>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
35828>>>                    End
35828>>>>
35828>>>                End
35828>>>>
35828>>>            End
35828>>>>
35828>>>        Loop
35829>>>>
35829>>>    End_Procedure
35830>>>
35830>>>    // This checks for both duplicate pnVersionNumbers _and_ that
35830>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
35830>>>    Procedure CheckForDuplicates Number nVersion
35832>>>        tDbVersionInfo[] DbVersionInfoArray
35832>>>        tDbVersionInfo[] DbVersionInfoArray
35833>>>        Integer iCount iSize iHits iDuplicateIndex
35833>>>        Number nCompare
35833>>>        Handle hObject1 hObject2
35833>>>        String sObjectName1 sObjectName2
35833>>>        Boolean bObjectOrderError
35833>>>
35833>>>        Get paDbVersionInfoArray to DbVersionInfoArray
35834>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
35835>>>        Decrement iSize
35836>>>        Move 0 to iHits
35837>>>        Move 0 to nCompare
35838>>>        Move False to bObjectOrderError
35839>>>        For iCount from 0 to iSize
35845>>>>
35845>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
35847>>>                Increment iHits
35848>>>                If (iHits > 1) Begin
35850>>>                    Move iCount to iDuplicateIndex
35851>>>                    If (nCompare <> 0) Begin
35853>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
35854>>>                    End
35854>>>>
35854>>>                End
35854>>>>
35854>>>            End
35854>>>>
35854>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
35855>>>        Loop
35856>>>>
35856>>>        If (iHits > 1) Begin
35858>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
35859>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
35860>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
35861>>>            Move (Name(hObject1)) to sObjectName1
35862>>>            Move (Name(hObject2)) to sObjectName2
35863>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
35864>>>>
35864>>>            Send Exit_Application
35865>>>        End
35865>>>>
35865>>>        Else If (bObjectOrderError = True) Begin
35868>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
35869>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
35870>>>>
35870>>>            Send Exit_Application
35871>>>        End
35871>>>>
35871>>>    End_Procedure
35872>>>
35872>>>    // We take care of all errors in the Error_Report below and
35872>>>    // collect them all to an array property. So just ignore any
35872>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
35872>>>    // in some other package.
35872>>>    Procedure Ignore_Error Integer iError
35874>>>    End_Procedure
35875>>>
35875>>>    Procedure Trap_Error Integer iError
35877>>>    End_Procedure
35878>>>
35878>>>    // While we update the database we collect all errors in
35878>>>    // the struct array paDbUpdateErrorArray.
35878>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
35880>>>        Number nVersion
35880>>>        Handle hoLogFile 
35880>>>        
35880>>>        If (Private.pbProcessingError(Self)) Begin
35882>>>            Procedure_Return
35883>>>        End
35883>>>>
35883>>>
35883>>>        // The UtilTableNameFromHandleToString function does a:
35883>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
35883>>>        // and it generates an error if the table is of the embedded type.
35883>>>        // As we don't want to trigger an error in that very specific case,
35883>>>        // we just ignore it here.
35883>>>        //
35883>>>        // If no report mode, just set the err indicator to true.
35883>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
35885>>>            Move False to Err
35886>>>            Procedure_Return
35887>>>        End
35887>>>>
35887>>>
35887>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
35889>>>            Procedure_Return
35890>>>        End
35890>>>>
35890>>>
35890>>>        Set Private.pbProcessingError to True
35891>>>        Set Private.pbUpdateVersionObjectError to True
35892>>>
35892>>>        Set pbDbUpdateErrorHasOccured to True
35893>>>        Get pnCurrentVersionUpdate to nVersion
35894>>>        Get phoLogFile to hoLogFile
35895>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
35896>>>
35896>>>        Set Private.pbProcessingError to False
35897>>>    End_Procedure
35898>>>
35898>>>End_Class
35899>
35899>Object oApplication is a cApplication
35901>    Set psCompany to 'RDC Tools International'
35902>    Set psProduct to 'DUF Auto Update Program'
35903>    Set psProgram to 'Internal use/test of a DUF Update Package'
35904>    Set psVersion to '19.1'
35905>End_Object
35906>
35906>Get YesNo_Box ("This is a DUF test program written for INTERNAL usage only.\n\nUpdate your DEVELOPMENT DATABASE to version: 1 now?") to WindowIndex
35907>If (WindowIndex <> MBR_Yes) Begin
35909>    Send Exit_Application
35910>End
35910>
35910>Object oDbUpdateHandler is a cDbUpdateHandler
35912>    Set piDbVersionFileNumber  to 1
35913>    Set piDbVersionFieldNumber to 1
35914>    Set pbAutoCreateDbVersionTable to True
35915>
35915>    Use DUF_MultipleTables1_0.pkg
Including file: DUF_MultipleTables1_0.pkg    (C:\Projects\DF18\DbUpdateFramework2.0\Data\DUF_MultipleTables1_0.pkg)
35915>
35915>End_Object
35916>
35916>If (Private.pbDatabaseWasUpdated(ghoDbupdatehandler) = False) Begin
35918>   Send Info_Box 'Nothing to update. (Version number has not changed)'
35919>End
35919>
35919>Send Exit_Application
35920>// *** End-Of-Program Code ***
35920>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 21843
Total Resources: 6
Total Commands : 35919
Total Windows  : 0
Total Pages    : 0
Static Data    : 405825
Message area   : 165647
Total Blocks   : 14334
