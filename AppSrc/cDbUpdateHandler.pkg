//****************************************************************************
// $Module type: Class
// $Module name: cDbUpdateHandler
// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
// Web-site    : http://www.rdctools.com
// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
//
// Purpose     : A framework for doing automated code based updates of a database from within
//               a program, when it is started.
//
// Description : Place _one_ object of this class right after the cApplication object.
//               Then inside this object place a series of cDbUpdateVersion objects
//               as childs. One child object for each new database update.
//
//               - OnPreUpdate is a pre-processing event called
//               before any database changes are started.
//               - OnPostUpdate is a post-processing event called after all
//               database changes have taken place.
//
// Note        : If tables have been opened prior to an object of this class
//               (e.g. in the cApplication object), those tables will be closed.
//               In that case you need to use the OnPostUpdate hook event to re-open
//               tables after the last update has finished.
//
// Security    : Before an update is attempted; three things are checked to ensure the
//               database is not in use. Aka nobody else is running the application.
//               - All tables are tested for "Open in Exclusive_Mode"
//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
//                 pbCheckDataFlexUserCount is set to False (Default = True)
//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
//                 folder and a bit-lock is performed for each start of the application and this
//                 user counter is checked before an update is attempted.
//                 Important: Even if it seems like both garters & suspenders are used to guard
//                            against the database being "in use", there is no such guarantee! The
//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
//                 automatically be released after the update is completed.
//
//
// Usage       :  Use cDbUpdateHandler.pkg
//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
//                    // Declare the table that contains a "database version" field.
//                    Declare_Datafile Sys
//                    // Either one of these syntaxes is fine:
//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
//
//                    // Don't forget to increase the pnVersionNumber property for each
//                    // cDbUpdateVersion object!
//                    // The VersionTableColumn field/column specified above will be updated automatically
//                    // with the value of pnVersionNumber after each update has been finished.
//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
//                        Set pnVersionNumber to 1.1
//                        Use VersionUpdate1_1.pkg
//                    End_Object
//
//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
//                        Set pnVersionNumber to 1.2
//                        Use VersionUpdate1_2.pkg
//                    End_Object
//
//                End_Object
//
// *** To use the pbRestoreIntFilesNow & pbSaveIntFilesNow properties, the pbUseIntFilesBackup property needs to be True.
//     Sample Code:
//                Object oApplication is a cApplication
//                    Set peHelpType to htHtmlHelp
//                
//                    Object oConnection is a cConnection
//                        Use LoginEncryption.pkg
//                        Use DatabaseLoginDialog.dg
//                    End_Object
//                
//                    Property Boolean pbRestoreIntFilesNow False
//                    Property Boolean pbSaveIntFilesNow False
//                    // This allows the program to have the parameter "-restore" passed on the command line.
//                    // If found, it will call the "RestoreIntFiles" of the cDbUpdateHandler object.
//                    Procedure OnCreate
//                        Handle hoCmdLine
//                        Integer iSize iCount
//                        String sParam
//                        
//                        Get phoCommandLine to hoCmdLine
//                        Get CountOfArgs of hoCmdLine to iSize
//                        For iCount from 1 to iSize
//                            Get Argument of hoCmdLine iCount to sParam
//                            If (Lowercase(sParam) contains "restore") Begin
//                                Set pbRestoreIntFilesNow to True
//                            End
//                            Else If (Lowercase(sParam) contains "save") Begin
//                                Set pbSaveIntFilesNow to True
//                            End
//                        Loop
//                    End_Procedure
//                
//                End_Object
//
//                Object oDbUpdateHandler is a cDbUpdateHandler
//                    Set piDbVersionFileNumber  to 255
//                    Set piDbVersionFieldNumber to 1
//                    Set piIntFilesFileNumber to 256
//                    Set pbUseIntFilesBackup to True
//                    Set pbExitIfDebuggerActive to False
//                
//                    Procedure OnCreate
//                        String sVersionInfo sErrorText
//                        Boolean bRestoreIntFilesNow bSaveIntFilesNow bOK
//                        
//                        Get pbRestoreIntFilesNow of ghoApplication to bRestoreIntFilesNow
//                        If (bRestoreIntFilesNow = True) Begin
//                            Get RestoreIntFiles (&sErrorText) to bOK
//                        End
//                        Get pbSaveIntFilesNow of ghoApplication to bSaveIntFilesNow
//                        If (bSaveIntFilesNow = True) Begin
//                            Get SaveUpdateIntFiles (&sErrorText) to bOK
//                        End 
//                        
//                        // To check for correct the driver and db client versions, when the program starts (each-Time it is started!)
//                        Get MinMSSQLDRV_And_ClientVersion "24.0.29.10" SQLSERVER2019CLIENT True True to sVersionInfo
//                    End_Procedure
// ******************



//
// $Rev History:
//    2016-09-27  Module header created
//    2016-09-28  Removed the Master/Alias logic. All update code must
//                take place before any tables have been opened, or errors
//                could occur if the client database is out of sync with the
//                compiled program.
//                Added user counting checks + lockout while database is being
//                updated.
//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
//                as it is more in line with the child class cDbUpdateVersion name.
//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
//****************************************************************************
Use VdfBase.pkg
Use Dferror.pkg
Use seq_chnl.pkg
Use Datadict.pkg
Use DUFLanguageConstants.inc
Use DUFStatusPanel.pkg
Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Use cDbUpdateLogFile.pkg
Use cDbUpdateVersion.pkg
Use cDbUpdateUserCount.pkg
Use cDbUpdateFunctionLibrary.pkg

{ ClassType=Normal }
//{ DataBindable=True }
{ OverrideProperty=peNeighborhood Visibility=Private }
{ OverrideProperty=Delegation_Mode Visibility=Private }
{ OverrideProperty=pbApiTableUpdateAuto Visibility=Private }
{ OverrideProperty=pbCompareDate_DateTime Visibility=Private }
{ OverrideProperty=pbCompareIndexAscending Visibility=Private }
{ OverrideProperty=pbCompareIndexUppercase Visibility=Private }
Class cDbUpdateHandler is a cDbUpdateFunctionLibrary

    Procedure Construct_Object
        tUserCount UserCount
        Integer iUserCount
        Handle ho                     

        Forward Send Construct_Object
        Move Self to ghoDbUpdateHandler  
        
        { MethodType=Property Category="Convert to SQL" InitialValue="Latin1_General_CS_AS" }
        // Latin1_General_CI_AS = General Insensitive collation
        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
        // Good read about which collation to select:
        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
        { InitialValue="Latin1_General_CS_AS" EnumList="Latin1_General_CS_AS, Latin1_General_CI_AS, SQL_Latin1_General_Cp1_CS_AS" }
        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"

        // Struct array that will contain pnVersionNumbers & object id's of
        // all child cDbVersion objects.
        { Visibility=Private }
        Property tDbVersionInfo[] paDbVersionInfoArray

        { Visibility=Private }
        Property Integer Error_Processing_State False  // internal usage
        
        { Visibility=Private }
        Property Boolean Private.pbDbVersionCheckDone False

        { MethodType=Property Category="DbVersion Table" InitialValue=False }
        Property Boolean pbUseCustomDbVersion False  
        
        // If this property = True _and_ no DbVersion table exists 
        // when the framework is started, a DbVersion table will be created automatically.
        { MethodType=Property Category="DbVersion Table" InitialValue=True }
        Property Boolean pbAutoCreateDbVersionTable True

        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
        // the Filelist.cfg slot number indicated by this property will be used
        // if a DbVersion table is to be created. If this value = -1 at runtime
        // an Unhandled Exception Error will be genereted and the program halted. So
        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
        // to a value that corresponds to a free Filelist.cfg slot number.
        { Visibility=Private }
        Property Integer Private.piDbVersionFileNumber -1
        { Visibility=Private }
        Property Integer Private.piDbVersionFieldNumber 1

        { MethodType=Property Category="Check int. Files" InitialValue=False }
        Property Handle  piIntFilesFileNumber -1
        { Visibility=Private }
        Property Boolean pbRestoreIntFilesNow False   
        // In parallell with the above property, the pbSaveIntFilesNow can be set. That same property
        // also needs to be created in the ghoApplication object.
        { Visibility=Private }
        Property Boolean pbSaveIntFilesNow False
        { MethodType=Property Category="Check int. Files" InitialValue=False }
        Property Boolean pbUseIntFilesBackup False   
        { Visibility=Private }
        Property Boolean Private.pbIntFilesTablesCheckDone False
        
        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
        // that creates all library properties
        Send CreateDbUpdateLibraryProperties

        { Visibility=Private }
        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias

        // Error handling:
        { Visibility=Private }
        Property Boolean Private.pbOnCreateExecuted False
        { Visibility=Private }
        Property Boolean Private.pbOnPreUpdateExecuted False
        { Visibility=Private }
        Property Boolean Private.pbProcessingError False
        { Visibility=Private }
        Property Boolean pbDbUpdateErrorHasOccured False
        { Visibility=Private }
        // Don't touch. It is being used by the cDbUpdateVersion
        // subclass to tell if that particular update was a success or not.
        Property Boolean Private.pbUpdateVersionObjectError False
        { Category="Error Handling" MethodType=Property Visibility=Private }
        Property String[] paSQLQueryMessages
        
        Property Boolean pbExitIfDebuggerActive True
        { Visibility=Private }
        Property Integer piOrgErrorHandlerID Error_Object_Id
        { Visibility=Private }
        Move Self to Error_Object_Id
        // Error handling:
        // Temporarily redirect all errors to this object so we can silently
        // log all errors that might appear while updating the database.
        // We temporarily redirect all errors to this object so we can
        // log and write errors to the log file. It will be reset after
        // the database updates have been finished.
        Property Integer piCurrentErrorHandlerID Error_Object_Id

        { DesignTime=False }
        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))

        // Error Reporting Related
        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
        { Visibility=Private }
        Property Integer Error_Report_Mode DUF_ERROR_REPORT

        // If the pbContinueOnError = False, an update
        // of another cDbUpdateVersion object will _not_ be
        // performed if an error occured in a previous
        // cDbUpdateVersion object.
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbContinueOnError False
        // Stops execution in other cDbUpdateVersion objecs,
        // if errors occurred in one cDbUpdateVersion object.
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbStopOnFirstError False
        // If True errors that occured while updating the database
        // will be shown in the default app for .txt files when done.
        // Note: The log file will _always_ be created in the Data folder.
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbShowErrorLogPostRun True

        // Be _very_ careful to set this property to true!
        // If = True, no question will be asked if the update
        // should begin. Also, even if the pbShowErrorLogPostRun=True,
        // the error log won't be shown. The logfile itself will still be created though.
        // You have to know what you're doing!
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbSilentMode False
        
        { Category="Error Handling" MethodType=Property Visibility=Public }
        Property Boolean pbEnableCancelButton False

        { Visibility=Private }
        // Don't touch! Very private. The value is used by the error log to write for which
        // cDbUpdateVersion object an error occured.
        Property Number pnCurrentVersionUpdate 0

        { Visibility=Private }
        // The user counting logic is used to safe-guard agains anybody else is
        // using the application when a database update is to be performed.
        // (Garters & suspenders!)
        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!

        { Visibility=Private }
        // This lock file is used to guard against somebody else tries to start the
        // application while updates are in progress.
        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
                                                                                      // Only the current user allowed.
        { Visibility=Private }
        // Properties for the table & column of a system file field/column where
        // the database version update number gets saved.
        Property Integer Private.Data_File  0
        { Visibility=Private }
        Property Integer Private.Data_Field 0

        { Visibility=Private }
        // Property that is used to indicate that we have already
        // started the database update.
        Property Boolean Private.pbDatabaseUpdateStarted False

        { Visibility=Private }
        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
        // at least one OnUpdate child event has been triggered. Thus at least one active
        // change of the database has been made.
        Property Boolean Private.pbDatabaseWasUpdated False

        // We need to trigger the user counting system so that a bit in the
        // user counting file is locked. This is to guard that not more than one user
        // is currently runnning the program.
        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount

        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
        If (iUserCount > 0) Begin
            Send Stop_Box CS_DUF_UpdateInProgressTxt
            Send Exit_Application
        End

        Set pbHandleQueryErrors to False
            
        { Visibility=Private }
        Property Handle phoSQLConnectionHandler 0
        // If no ghoSQLConnectionHandler object has been created prior to this object,
        // we will create one as it is used for all ConnectionID, ConnectionString
        // etc information.
        If (ghoSQLConnectionHandler = 0) Begin
            Get Create (RefClass(cSQLConnectionHandler)) to ho
            Set phoSQLConnectionHandler to ho
        End             
        
        Set Icon to "Default.ico"
    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
        If (Private.pbOnCreateExecuted(Self) = False) Begin  
            Send OnCreate
            Set Private.pbOnCreateExecuted to True
        End
        Send Cleanup
    End_Procedure
    
    { MethodType=Event Visibility = Public }
    // Programmers hook event!
    Procedure OnCreate
    End_Procedure        
                                 
    // Note: If you get a compile Error 4295: "xxx Can't include resource FILELISTBACKUPFILE.CFG",
    //       you will need to manually make a copy of the Filelist.cfg in the Data folder -> "FilelistBackupFile.cfg"
    Include_Resource FilelistBackupFile.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
    //                                                
    // The logic is activated by setting the property "pbUseIntFilesBackup = True" in the
    // cDbUpdateHandler object.
    //
    // Checks that all .int files are intact, or else writes new copies to disk. 
    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
    //
    // If not done previously the piIntFilesFileNumber will be created and filled with data
    // from the current set of .int files - iif (if-and-only-if) this is a development
    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
    // of Filelist.cfg is made for backup purposes.
    //
    // Note: If an error occurrs the application will exit, as it means that at least one
    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.

    // Note: Include_Resource is a compiler directive!
    // It will embedd the Filelist.cfg from the developers machine
    // into the executable.        
    //
    // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
    // when we get here and then the compiler can't embedd it!        
    // NOTE: This relies on the "WriteDateTimeHeaderFile" program and that each Project has
    //       been setup to run it as the "Before Compilation Process:" (See: Project - Project Properties - Compiler tab-page)
    Function SaveUpdateIntFiles String ByRef sErrorText Returns Boolean
        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone bNewer bIsIntFileTable  bIsAlias
        String sPaths sDataPath sIntFileName sRootName sFileListName sFileListNameBackup sDDSrcPath sCurrentFolder
        String sFileListZipFile sParam sProgram sFile 
        Integer iDataPaths iCount iSize
        Handle hTable hIntFilesTable                    
        UChar[] asFileListArray 
        String[] asSavedIntFile
        tDUFIntFile[] DUFIntFiles

        // This will automatically create the piIntFilesFileNumber if not exists.
        // It is used to save data from the current set of .int files.
        // We do this on both developer & client machines.
        Get IsIntFileTable to bIsIntFileTable
        If (bIsIntFileTable = False) Begin
            Send AutoCreateIntFilesTable
            Get Private.pbIntFilesTablesCheckDone to bOK
            If (bOK = False) Begin
                Function_Return False
            End
        End                                                       
        
        Get _UtilNumberOfFileListTables to iSize
        Send StartStatusPanel "" "" iSize
        Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False

        // Check Filelist.cfg & backup file
        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath 
        Move (sDataPath + "\" + CS_FilelistBackupFile)   to sFileListNameBackup
        Get IsFileTimeNewer sFileListName sFileListNameBackup to bNewer

        Move (IsDebuggerPresent()) to bDevelop
        // Is this a client machine?
        If (bDevelop = False) Begin
            If (bNewer = True) Begin
                // Create filelist.cfg from resource backup file.
                Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
                Get WriteFileListResource asFileListArray sFileListName to bOK  
            End
        End

        Else If (bDevelop = True) Begin
            Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
            If (bNewer = True) Begin
                Get vDeleteFile sFileListNameBackup to bOK
                Get vCopyFile sFileListName sFileListNameBackup to bOK
                Move "A new backup copy of the Filelist.cfg file was made. In order to include a backup copy of the file into the program, as a resource, you will need to re-compile/restart the program." to sErrorText
            End
        End
        
        Move True to bResult 

        Get piIntFilesFileNumber to hIntFilesTable
        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths

        For iCount from 1 to iDataPaths
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
            Get vFolderFormat sDataPath to sDataPath 
            Get vFolderExists sDataPath to bExists
            If (bExists = True) Begin                  
                Move 0 to hTable
                Repeat
                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
                    If (hTable <> 0 and hTable <> 50) Begin
                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
                        Set Message_Text of ghoStatusPanel to ("Saving/updating IntFilesTable:" * String(sIntFileName))
                        Send DoAdvance of ghoProgressBar
                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
                        Get UtilTableIsAlias hTable to bIsAlias 
                        If (bIsSQL = True and bIsAlias = False) Begin
                            If (bIsSQL = True) Begin     
                                Get _TableNameOnly sIntFileName to sIntFileName
                                Move (sIntFileName + ".int")    to sIntFileName
                                Get IsIntFileSaved sIntFileName to bSaved  
                                Move True to bOK            
                                
                                // Save .int file to database if not done previously (both on development- and customer-machines).
                                If (bSaved = False) Begin
                                    Get SaveIntFileData sDataPath sIntFileName to bOK
                                    If (bOK = False) Begin
                                        Move ("The 'SaveIntFileData' function for the internal database table:" * String(sIntFileName) * "failed.") to sErrorText
                                        Error DFERR_PROGRAM sErrorText
                                        Move False to bResult    
                                    End
                                End         
                                Else Begin
                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
                                    If (SizeOfArray(asSavedIntFile) <> 0) Begin
                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
                                        If (bOK = False) Begin
                                            Move False to bResult
                                            Move ("Could not update .int file data to the internal database table:" * String(sIntFileName)) to sErrorText
                                            Error DFERR_PROGRAM sErrorText
                                        End
                                    End
                                End
                            End
                        End
                    End
                Until (hTable = 0)
            End
        Loop       
        
        Send StopStatusPanel
        // If an error occured we need to exit the application as we cannot start with an uncomplete set of .int files.
        If (bResult = False) Begin  
            Function_Return False
        End 
        Send LogError ("The *.int file backup table was updated:" * String(CS_IntFilesTableLogicalName)) False
        Function_Return True
    End_Function

    // It checks that *.int files on disk corresponds with the content in the
    // .int file backup table piIntFilesFileNumber.
    Function RestoreIntFiles String ByRef sErrorText Returns Boolean
        Boolean bCheckIntFiles bIsIntFileTable bExists bIsSQL bRestored bOK
        String sPaths sDataPath sIntFileName 
        String[] asSavedIntFile
        Integer iDataPaths iCount iRetval iSize
        Handle hTable hIntFilesTable

        Get IsIntFileTable to bIsIntFileTable
        If (bIsIntFileTable = False) Begin
            Send Info_Box "The 'IntFilesTable' has not been created. Thus no backup info for .int files exists. The property pbUseIntFilesBackup must have been set to True in the cDbUpdateHandler object for automatic creation of the table and save of all .int files."
            Function_Return False
        End
        
        Get YesNo_Box "This will restore the content of all .int files. Current .int files will be compared to the content in the backup table. If different, files on disk will be updated. Cash files (.cch) will be removed and a backup Filelist.cfg will be installed.\n\n Continue?" to iRetval
        If (iRetval <> MBR_Yes) Begin
            Function_Return False
        End
        
        Get _UtilNumberOfFileListTables to iSize
        Send StartStatusPanel "" "" iSize
        Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False

        Move False to bRestored
        Get piIntFilesFileNumber to hIntFilesTable
        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths

        For iCount from 1 to iDataPaths
            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
            Get vFolderFormat sDataPath to sDataPath 
            Get vFolderExists sDataPath to bExists
            If (bExists = True) Begin                  
                Move 0 to hTable
                Repeat
                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
                    If (hTable <> 0) Begin
                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
                        Set Message_Text of ghoStatusPanel to ("Checking info for." * String(sIntFileName))
                        Send DoAdvance of ghoProgressBar
                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
                        If (bIsSQL = True) Begin     
                            Get _TableNameOnly sIntFileName to sIntFileName
                            Move (sIntFileName + ".int")    to sIntFileName
                            Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
                            If (SizeOfArray(asSavedIntFile) <> 0) Begin
                                Set Message_Text of ghoStatusPanel to ("Restoring .int file:" * String(sIntFileName))
                                Get CreateIntFileFromSavedData sIntFileName sDataPath to bOK
                                If (bRestored = False and bOK = True) Begin
                                    Move True to bRestored
                                End
                                If (bOK = False) Begin 
                                    Move ("Could not create the .int file" * String(sIntFileName) * "from the internal database table:" * String(CS_IntFilesTableLogicalName)) to sErrorText
                                    Error DFERR_PROGRAM sErrorText
                                End
                            End
                        End
                    End
                Until (hTable = 0)
            End
        Loop       
        
        Send StopStatusPanel
        Function_Return bRestored
    End_Function

    Function IsIntFileTable Returns Boolean
        Boolean bExists
        Handle hTable
        String sLogicalName
        Move False to bExists
        Get piIntFilesFileNumber to hTable
        If (hTable > 0) Begin
            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
            Move (sLogicalName = CS_IntFilesTableLogicalName) to bExists
        End
        Function_Return bExists    
    End_Function
    
    // To update currently saved IntFile data to the database.
    // Because it is much easier, we first delete all current records and
    // then saves the changed .int file to the database.
    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
        Boolean bOK
        Move False to bOK
        Move (Lowercase(sIntFileName)) to sIntFileName
        Get DeleteIntFileData sDataPath sIntFileName to bOK
        If (bOK = True) Begin
            Get SaveIntFileData sDataPath sIntFileName to bOK
        End
        Function_Return bOK
    End_Function
    
    // Note: We use vFind here as the IntFileName may not yet have been created,
    //       and thus we cannot compile.
    Function IsIntFileSaved String sIntFileName Returns Boolean
        Handle hTable
        Boolean bOK
        Integer iColumn iIndex   
        String sFileName
        
        Move (Lowercase(sIntFileName)) to sIntFileName
        Move False to bOK  
        Get piIntFilesFileNumber to hTable
        Move 2              to iColumn // This is the "InfFileName" field no.
        Move 2              to iIndex  // This is the IntFileName + ID index.

        Open hTable
        Set_Field_Value hTable iColumn to sIntFileName
        Vfind hTable iIndex GE
        Get_Field_Value hTable iColumn to sFileName
        If (Trim(sIntFileName) = Trim(sFileName)) Begin
            Move True to bOK    
        End
        Close hTable
        
        Function_Return bOK       
    End_Function   
    
    // Checks that the passed .int file is the same as what is saved in the database.
    // If not same, the return string array will contain the read .int file,
    // else the returned array will be empty.
    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
        Boolean bIsSame
        
        Move (Lowercase(sIntFileName)) to sIntFileName
        Get ReadIntFile sDataPath sIntFileName to asIntFileOrg   
        Get RetrieveIntFileData sDataPath sIntFileName to asSavedIntFile
        Get RemoveBlankLines asIntFileOrg   to asIntFile
        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
        
        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
        If (bIsSame = False) Begin
            Move asIntFileOrg to asReturnIntFile    
        End
        
        Function_Return asReturnIntFile    
    End_Function                                   
    
    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
        Handle hTable
        Boolean bOK bErr
        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
        Number iID
        String sFileName
        String[] asIntFile
        
        // Note: We will lowercase all .int file names, to not get into having duplicates in the database
        Move (Lowercase(sIntFileName)) to sIntFileName
        
        Move Err to bErr
        Move False to Err
        Move False to bOK
        Get piIntFilesFileNumber to hTable  
        Move 1              to iIDCol
        Move 2              to iFileCol
        Move 3              to iTextCol // This is the "InfFileName" field no.
        Move 1              to iIDIdx   // Main ID index.
        Move 2              to iIndex   // This is the IntFileName + ID index.

        Get ReadIntFile sPath sIntFileName to asIntFile
        Move (SizeOfArray(asIntFile)) to iSize
        If (iSize = 0) Begin
            Function_Return False
        End
        Decrement iSize
        Open hTable  
                  
        // Find the last used ID no:
        Fill_Field hTable iIDCol with DF_HIGH
        Vfind hTable iIDIdx LE
        Get_Field_Value hTable iIDCol to iID 
        // This only happens the very first time we save a record.
        If (iID = 999999999999) Begin
            Move 0 to iID
        End
        Increment iID
        
        Lock
            For iCount from 0 to iSize
                Clear hTable
                Set_Field_Value hTable iIDCol   to iID     
                Set_Field_Value hTable iFileCol to sIntFileName
                Set_Field_Value hTable iTextCol to asIntFile[iCount]
                SaveRecord hTable
                Increment iID
            Loop
        Unlock
        Close hTable
        
        Move (not(Err)) to bOK
        Move bErr to Err
        
        Function_Return bOK
    End_Function
    
    // Deletes all records for the passed sIntFileName value,
    // from the piIntFilesFileNumber.
    // Returns True if no errors occured.
    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
        Handle hTable
        Boolean bOK bErr bFound
        Integer iFileCol iIndex
        String sVal
        String[] asIntFile
        
        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
        Move Err to bErr
        Move False to Err
        Move False to bOK
        Move 2              to iFileCol
        Move 2              to iIndex  // This is the IntFileName + ID index.
        Get piIntFilesFileNumber to hTable  
        Open hTable  
                  
        // Find the first record
        Set_Field_Value hTable iFileCol to sIntFileName
        Vfind hTable iIndex GE
        Get_Field_Value hTable iFileCol to sVal
        Move (Trim(Lowercase(sVal))) to sVal
        Move (Found and sVal = sIntFileName) to bFound
        While (bFound = True)
            Delete hTable
            Vfind hTable iIndex GT
            Get_Field_Value hTable iFileCol to sVal
            Move (Trim(Lowercase(sVal))) to sVal
            Move (Found and sVal = sIntFileName) to bFound
        Loop
        Unlock
        Close hTable
        
        Move (not(Err)) to bOK
        Move bErr to Err
        
        Function_Return bOK
    End_Function

    // Returns all saved piIntFilesFileNumber records for the passed 
    // sIntFileName value as a string array.
    Function RetrieveIntFileData String sPath String sIntFileName Returns String[]
        Handle hTable
        Boolean bOK bErr bFound
        Integer iFileCol iTextCol iIndex
        String sVal sFileName
        String[] asIntFile asEmptyArray
        
        Move (Trim(Lowercase(sIntFileName))) to sIntFileName
        Move Err to bErr
        Move False to Err
        Move False to bOK
        Move 2              to iFileCol
        Move 3              to iTextCol // This is the "InfFileName" field no.
        Move 2              to iIndex  // This is the IntFileName + ID index.
        Get piIntFilesFileNumber to hTable  
        Open hTable  
        
        // Find the first record
        Set_Field_Value hTable iFileCol to sIntFileName
        Vfind hTable iIndex GE
        Get_Field_Value hTable iFileCol to sFileName
        Move (Trim(Lowercase(sFileName))) to sFileName
        Move (Found and sFileName = sIntFileName) to bFound
        While (bFound = True)
            Get_Field_Value hTable iFileCol   to sFileName
            Move (Trim(Lowercase(sFileName))) to sFileName
            Move (Found and sFileName = sIntFileName) to bFound
            If (bFound = True) Begin
                Get_Field_Value hTable iTextCol to sVal
                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
            End
            Vfind hTable iIndex GT
        Loop
        
        Close hTable
        Move (not(Err)) to bOK
        If (bOK = False) Begin
            Move asEmptyArray to asIntFile
        End
        Move bErr to Err               
        
        Function_Return asIntFile
    End_Function

    // Reads the passed sIntFileName from disk and returns its value
    // as a string array.
    Function ReadIntFile String sPath String sIntFileName Returns String[]
        String[] asIntFile       
        String sFileName sLine
        Integer iCh iSize iCount
        
        Move (Lowercase(sIntFileName)) to sIntFileName
        Get vFolderFormat sPath to sPath
        If (not(sIntFileName contains ".")) Begin
            Move (sIntFileName + ".int") to sIntFileName
        End
        Move (sPath + sIntFileName) to sFileName
        Get Seq_Open_input_Channel sFileName to iCh
        If (iCh < 0) Begin
            Function_Return asIntFile
        End                                 
        
        Repeat
            Readln channel iCh sLine
            If (SeqEof = False) Begin
                Move (Trim(sLine)) to asIntFile[SizeOfArray(asIntFile)]
            End
        Until (SeqEof = True)
        Send Seq_Close_Channel iCh    
        
        Function_Return asIntFile
    End_Function
    
    // Reads the Filelist.cfg from memeory as a resource.
    // The Filelist.cfg has been compiled into the program.
    Function ReadFileListResource String sMemFileName Returns UChar[]
        Integer iCh iCount
        Number nByteCount
        String[] asFileListArray sEmptyArray
        String sLine
        UChar[] uCharData
        
        Move False to Err
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DFERR_PROGRAM 'No channel available...'
            Function_Return sEmptyArray
        End

        // First decide the size of the script
        Direct_Input channel iCh ("Resource: " + sMemFileName)
        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
        Close_Input channel iCh
        Send Seq_Release_Channel iCh

        Function_Return uCharData
    End_Function    
    
    // Writes a copy of the workspace Filelist.cfg to disk.
    // It does so by reading from a memory resource, as the file has
    // been compiled into the program.
    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
        Boolean bOK bErr
        Integer iSize iCh
        
        Move Err to bErr
        Move False to Err
        Move False to bOK
        Move (SizeOfArray(asFileListArray)) to iSize
        If (iSize = 0) Begin
            Function_Return False
        End

        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Error DFERR_PROGRAM 'No channel available...'
            Function_Return False
        End                      
        
        Direct_Output channel iCh sFileListName
        Writeln channel iCh asFileListArray
                
        Close_Input channel iCh
        Send Seq_Release_Channel iCh
        Move (not(Err)) to bOK
        Move bErr to Err
        
        Function_Return bOK
    End_Function

    // Writes an .int for the passed sIntFileName file to disk by reading data from the piIntFilesFileNumber data table.
    // It first deletes the .cch file (if any).
    Function CreateIntFileFromSavedData String sIntFileName String sDataPath Returns Boolean
        Boolean bOK bFound bExists bErr
        Integer iCh iSize iCount
        String sFileName sCCHFileName sVal
        String[] asIntFile
        
        Move (Lowercase(sIntFileName)) to sIntFileName
        Move Err to bErr   
        Move False to Err
        Move False to bOK

        Get RetrieveIntFileData sDataPath sIntFileName to asIntFile
        Move (SizeOfArray(asIntFile)) to iSize
        If (iSize = 0) Begin
            Function_Return False        
        End                      
        Decrement iSize
        
        Get Seq_New_Channel to iCh
        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
            Function_Return False
        End   
        
        // Before we start to actually create the new .int file, make sure we delete
        // the .cch file.                                     
        Move (Uppercase(sIntFileName)) to sCCHFileName
        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
        If (bExists = True) Begin
            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
            If (bOK = False) Begin
                Function_Return False
            End
        End
        
        Direct_Output channel iCh (sDataPath + sIntFileName)
        For iCount from 0 to iSize
            Writeln channel iCh asIntFile[iCount]
        Loop
        
        Close_Input channel iCh
        Send Seq_Release_Channel iCh
        Move (not(Err)) to bOK
        Move bErr to Err
        
        Function_Return bOK
    End_Function   
              
    // Automatically writes .int files to disk that is missing.
    // We only need to make this test this once, but because the message is called
    // from each child cDbUpdateVersion object (and it needs to be called from there),
    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
    Procedure AutoCreateIntFilesTable
        Integer hTable 
        Boolean bIntFilesTablesCheckDone bTableExists bOK
        String sInfoTxt 
        
        Get piIntFilesFileNumber to hTable  
        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
        If (bIntFilesTablesCheckDone = True) Begin
            Procedure_Return
        End

        If (hTable < 1) Begin
            Set Private.pbIntFilesTablesCheckDone to False
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Error DFERR_PROGRAM "The piIntFilesFileNumber has been set! The property MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
            Send Exit_Application
        End
        
        Get IsIntFileTable hTable to bTableExists
        If (bTableExists = True) Begin
            Set Private.pbIntFilesTablesCheckDone to True
            Procedure_Return
        End

        Send SubCreateIntFilesTable hTable
    End_Procedure
                
    Procedure SubCreateIntFilesTable Handle hTable
        String sTableName sColumnName sInfoTxt sDriverID sDataPath
        Boolean bTableExists bOK bUseConnectionID bExists
        tAPIColumn[] APIColumn

        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
        If (bTableExists = True) Begin
            Procedure_Return
        End

        Move False to Err
        Get psDriverID to sDriverID
        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID

        Move CS_IntFilesTableLogicalName to sTableName

        Move 1                  to APIColumn[0].iFieldNumber
        Move "ID"               to APIColumn[0].sFieldName
        Move DF_BCD             to APIColumn[0].iType
        Move False              to APIColumn[0].bIsSQLType
        Move 12                 to APIColumn[0].iLength
        Move 0                  to APIColumn[0].iPrecision

        Move 2                  to APIColumn[1].iFieldNumber
        Move "IntFileName"      to APIColumn[1].sFieldName
        Move DF_ASCII           to APIColumn[1].iType
        Move False              to APIColumn[1].bIsSQLType
        Move 50                 to APIColumn[1].iLength
        Move 0                  to APIColumn[1].iPrecision

        Move 3                  to APIColumn[2].iFieldNumber
        Move "IntLineText"      to APIColumn[2].sFieldName
        Move DF_ASCII           to APIColumn[2].iType
        Move False              to APIColumn[2].bIsSQLType
        Move 100                to APIColumn[2].iLength
        Move 0                  to APIColumn[2].iPrecision

        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
        
        If (bOK = True) Begin
//        If (bOK = True and Err = False) Begin
            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
        End
        Else Begin
            Set Private.pbIntFilesTablesCheckDone to False
            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
            Error DFERR_PROGRAM sInfoTxt
            Procedure_Return
        End
        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
        
        Open hTable
        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
        If (bOK = True) Begin
            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
        End
        If (bOK = False) Begin
            Set Private.pbIntFilesTablesCheckDone to False
            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
            Error DFERR_PROGRAM sInfoTxt
            Procedure_Return
        End
        
        // Check if the new .int file was created. If so and a .dat file exists - delete it.
        If (sDriverID <> DATAFLEX_ID) Begin
            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
            Get vFolderFormat sDataPath to sDataPath
            Move (CS_IntFilesTableLogicalName + ".int") to sTableName
            Get vFilePathExists (sDataPath + sTableName) to bExists
            If (bExists = True) Begin
                Move CS_IntFilesTableLogicalName to sTableName
                Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
                If (bExists = True) Begin
                    Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
                    Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
                    Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
                End
            End
        End
        
        Set Private.pbIntFilesTablesCheckDone to True
    End_Procedure

    Procedure AutoCreateDbVersionTable
        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
        Integer iDbVersionFileNumber

        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
        If (bDbVersionCheckDone = True) Begin
            Procedure_Return
        End
        Get pbUseCustomDbVersion to bUseCustomDbVersion
        If (bUseCustomDbVersion = True) Begin
            Procedure_Return
        End

        Get piDbVersionFileNumber to iDbVersionFileNumber
        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber < 1) Begin
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
            Send Exit_Application
        End

        If (bAutoCreateDbVersionTable = True) Begin
            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
            If (bTableExists = True) Begin
                Set Private.pbDbVersionCheckDone to True
                Procedure_Return
            End
            Send CreateDbVersionTable iDbVersionFileNumber
        End

        // We only need to these DbVersion checks once, but because this message is called
        // from each child cDbUpdateVersion object (and it needs to be called from there),
        // we use a property to only run these tests once.
        Set Private.pbDbVersionCheckDone to True
    End_Procedure

    Procedure CreateDbVersionTable Handle hTable
        String sTableName sColumnName sInfoTxt sDriverID 
        Boolean bTableExists bOK bUseConnectionID
        tAPIColumn[] APIColumn

        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
        If (bTableExists = True) Begin
            Procedure_Return
        End

        Get psDriverID to sDriverID
        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID

        Move "DbVersion"        to sTableName
        Move 1                  to APIColumn[0].iFieldNumber
        Move "DatabaseVersion"  to APIColumn[0].sFieldName
        Move DF_BCD             to APIColumn[0].iType
        Move False              to APIColumn[0].bIsSQLType
        Move 4                  to APIColumn[0].iLength
        Move 2                  to APIColumn[0].iPrecision

        Move False to Err                                
        
        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
        Set psDriverID to DATAFLEX_ID
        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
        Set psDriverID to sDriverID
        
        If (bOK = True and Err = False) Begin
            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
        End
        Else Begin
            Move "The DbVersion table creation failed!" to sInfoTxt
        End

        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
    End_Procedure

    { MethodType=Property Category="Error Handling" InitialValue=False }
    Procedure Set pbVerboseState Boolean bVerboseState
        Handle ho
        Get phoLogFile to ho
        Set pbVerboseState of ho to bVerboseState
    End_Procedure

    { MethodType=Property }
    Function pbVerboseState Returns Boolean
        Boolean bVerboseState
        Handle ho
        Get phoLogFile to ho
        Get pbVerboseState of ho to bVerboseState
        Function_Return bVerboseState
    End_Function

    // Callback functionality used when e.g. calling driver functions directly.
    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
        Integer iPerc
        Number nReady nTotal nVersion
        Boolean bVerboseState
        Handle hoLogFile

        Get pbVerboseState to bVerboseState
        Get pnCurrentVersionUpdate to nVersion
        Get phoLogFile     to hoLogFile
        Send DoAdvance of ghoProgressBar

        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
        End
        If (sCallback_Text contains "Creating index") Begin
            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
        End
        If (bVerboseState = True and (iCallback_Type <> DF_Message_Progress_Value)) Begin
            Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
        End
        If (iCallback_Type <> DF_Message_Progress_Value) Begin
            Set Message_Text of ghoStatusPanel to sCallback_Text
            Set Action_Text  of ghoStatusPanel to ""
        End

        Case Begin
            Case (iCallback_Type = DF_Message_Progress_Title)
                Set Action_Text  of ghoStatusPanel to ""
                Case Break
            Case (iCallback_Type = DF_Message_Progress_Value)
                //*** Interpret numbers
                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
                Move ((nReady/nTotal) * 100)                                                      to iPerc
                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
                Set piPosition of ghoProgressBar to iPerc
                Case Break
//            Case Else
//                Set Message_Text of ghoStatusPanel to ""
//                Set Action_Text  of ghoStatusPanel to ""
        Case End

        Send ProcessEvents of ghoStatusPanel
        Function_Return False
    End_Function

    // This was made to be a procedure/function pair so we
    // at the same time can set the property of the cDbUpdateFunctionLibrary

    { MethodType=Property Category="Database" InitialValue=Default }
    { EnumList="EN_DbTypeMSSQL, EN_DbTypeMySQL, EN_DbTypeOracle, EN_DbTypeDB2, EN_DbTypePostgre, EN_DbTypeDataFlex" }
    Procedure Set piDbType Integer iDbType
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set piDbType of ghoSQLConnectionHandler to iDbType
    End_Procedure

    Function piDbType Returns Integer
        Integer iDbType
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get piDbType of ghoSQLConnectionHandler to iDbType
        Function_Return iDbType
    End_Function

    { MethodType=Property Category="Database" InitialValue="Default" }
    { EnumList="DATAFLEX, MSSQLDRV, DB2_DRV, ODBC_DRV, SQL_DRV, MDSPGSQL, MDSMYSQL, ORA_DRV" }
    Procedure Set psDriverID String sDriverID
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psDriverID of ghoSQLConnectionHandler to sDriverID
    End_Procedure

    Function psDriverID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psDriverID of ghoSQLConnectionHandler to sValue
        Function_Return sValue
    End_Function
    
    Procedure Set pbUseDriverCacheFiles Boolean bUseDriverCacheFiles
        If (ghoSQLConnectionHandler = 0) Begin
            Procedure_Return
        End  
        Set Private.pbUseDriverCacheFiles of ghoSQLConnectionHandler to bUseDriverCacheFiles
    End_Procedure

    Function pbUseDriverCacheFiles Returns Boolean
        String sDriverID
        Integer iDriver
        Boolean bUseDriverCacheFiles        
        Move True to bUseDriverCacheFiles
        If (ghoSQLConnectionHandler = 0) Begin
            Function_Return False
        End
        Get psDriverID of ghoSQLConnectionHandler to sDriverID
        If (sDriverID = DATAFLEX_ID) Begin
            Function_Return False
        End
        Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriver
        If (iDriver <> 0) Begin
            Get_Attribute DF_DRIVER_USE_CACHE of iDriver to bUseDriverCacheFiles 
        End
        Function_Return bUseDriverCacheFiles 
    End_Function

    Procedure Set pbIgnoreDriverUcaseSupport Boolean bState
        If (ghoSQLConnectionHandler = 0) Begin
            Procedure_Return
        End  
        Set Private.pbIgnoreDriverUcaseSupport of ghoSQLConnectionHandler to bState
    End_Procedure

    Function pbIgnoreDriverUcaseSupport Returns Boolean
        String sDriverID
        Integer iDriver
        Boolean bIgnoreDriverUcaseSupport        
        Move True to bIgnoreDriverUcaseSupport
        If (ghoSQLConnectionHandler = 0) Begin
            Function_Return False
        End
        Get psDriverID of ghoSQLConnectionHandler to sDriverID
        If (sDriverID = DATAFLEX_ID) Begin
            Function_Return False
        End
        Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriver
        If (iDriver <> 0) Begin
            Get_Attribute DF_DRIVER_IGNORE_UCASE_SUPPORT of iDriver to bIgnoreDriverUcaseSupport 
        End
        Function_Return bIgnoreDriverUcaseSupport 
    End_Function

    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
    End_Procedure

    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
        Integer iRetval
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return 2
        End

        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
        Function_Return iRetval
    End_Function

    Procedure Set psConnectionID String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psConnectionID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psConnectionID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psConnectionID of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    // These "properties" are settings of the cCLIHandler class, but are being
    // relayed to the ghoSQLConnectionHandler object
    // simply by changing one of its parameters.
    Procedure Set psServer String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psServer of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psServer Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psServer of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    Procedure Set psDatabase String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psDatabase of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psDatabase Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psDatabase of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    Procedure Set psUserID String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psUserID of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psUserID Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psUserID of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    Procedure Set psPassword String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psPassword of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psPassword Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psPassword of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    Procedure Set pbTrusted Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set pbTrusted of ghoSQLConnectionHandler to bValue
    End_Procedure

    Function pbTrusted Returns Boolean
        Boolean bValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return False
        End
        Get pbTrusted of ghoSQLConnectionHandler to bValue

        Function_Return bValue
    End_Function

    Procedure Set psConnectionString String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Procedure_Return
        End
        Set psConnectionString of ghoSQLConnectionHandler to sValue
    End_Procedure

    Function psConnectionString Returns String
        String sValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return ""
        End
        Get psConnectionString of ghoSQLConnectionHandler to sValue

        Function_Return sValue
    End_Function

    { MethodType=Property }
    Function piConnectionOptions Returns Integer
        Integer iValue
        If (ghoSQLConnectionHandler = 0) Begin
            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
            Function_Return 0
        End
        Get piConnectionOptions of ghoSQLConnectionHandler to iValue

        Function_Return iValue
    End_Function


    { Category="Error Handling" MethodType=Property InitialValue=True }
    Procedure Set pbCheckDataFlexUserCount Boolean bState
        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
    End_Procedure

    Function pbCheckDataFlexUserCount Returns Boolean
        Boolean bState
        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
        Function_Return bState
    End_Function

    { Category="Error Handling" MethodType=Property InitialValue="DUFUpdateLog.txt" }
    Procedure Set psLogTextFile String sValue
        Set psLogTextFile of (phoLogFile(Self)) to sValue
    End_Procedure

    Function psLogTextFile Returns String
        String sValue
        Get psLogTextFile of (phoLogFile(Self)) to sValue
        Function_Return sValue
    End_Function

    { Category="Error Handling" MethodType=Property InitialValue="Windows Default Program" }
    Procedure Set psEditorProgram String sValue
        Set psEditorProgram of (phoLogFile(Self)) to sValue
    End_Procedure

    Function psEditorProgram Returns String
        String sValue
        Get psEditorProgram of (phoLogFile(Self)) to sValue
        Function_Return sValue
    End_Function

    { Category="Error Handling" MethodType=Property InitialValue=False }
    Procedure Set pbUseDataTableLog Boolean bState
        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
    End_Procedure

    Function pbUseDataTableLog Returns Boolean
        Boolean bState
        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
        Function_Return bState
    End_Function

    { Category="Error Handling" MethodType=Property InitialValue=True }
    Procedure Set pbQuickWrite Boolean bState
        Set pbQuickWrite of (phoLogFile(Self)) to bState
    End_Procedure

    Function pbQuickWrite Returns Boolean
        Boolean bState
        Get pbQuickWrite of (phoLogFile(Self)) to bState
        Function_Return bState
    End_Function

    Procedure Set pbDatabaseWasUpdated Boolean bState
        Boolean bUpdateVersionObjectError bVerboseState
        Integer iSize iCount
        Number nVersion
        String[] aSQLQueryMessages

        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
        Set Private.pbDatabaseWasUpdated to bState
        // If no errors occurred in the current cDbUpdateVersion object - write
        // to the log that it was OK.
        If (bUpdateVersionObjectError = False) Begin
            Get pnCurrentVersionUpdate to nVersion
            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
        End

        Get pbVerboseState to bVerboseState
        If (bVerboseState = True) Begin
            Get paSQLQueryMessages to aSQLQueryMessages
            Move (SizeOfArray(aSQLQueryMessages)) to iSize
            Decrement iSize
            For iCount from 0 to iSize
                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
            Loop
        End

    End_Procedure 

    // Returns the current DbVersion value (system table)
    // Note: If the DbVersion table doesn't exist yet,
    //       it will return -1.
    Function CurrentDbVersion Returns Number
        Boolean bInUse bActive
        Integer iStatus iColumn
        Number nVersion
        Handle hTable
        
        Move -1 to nVersion
        Get piDbVersionFileNumber  to hTable
        Get piDbVersionFieldNumber to iColumn
        Get _UtilTableNumberIsInUse hTable to bInUse
        If (bInUse = True) Begin
            Open hTable
            Get_Attribute DF_FILE_STATUS of hTable to iStatus
            If (iStatus = DF_FILE_INACTIVE) Begin
                Vfind hTable 0 GT
            End
            Get_Field_Value hTable iColumn to nVersion
        End
        Function_Return nVersion
    End_Function
         
    
    { MethodType=Property Category="DbVersion Table" InitialValue=-1 }
    Procedure Set piDbVersionFileNumber Integer iFileNumber
        Set Private.piDbVersionFileNumber to iFileNumber
    End_Procedure                                         
    
    { MethodType=Property Category="DbVersion Table" InitialValue=-1 }
    Function piDbVersionFileNumber Returns Integer
        Function_Return (Private.piDbVersionFileNumber(Self))
    End_Function

    { MethodType=Property Category="DbVersion Table" InitialValue=-1 }
    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
        Set Private.piDbVersionFieldNumber to iFieldNumber
    End_Procedure                                         
    
    { MethodType=Property Category="DbVersion Table" InitialValue=-1 }
    Function piDbVersionFieldNumber Returns Integer
        Function_Return (Private.piDbVersionFieldNumber(Self))
    End_Function

    Function pbDatabaseWasUpdated Returns Boolean
        Function_Return (Private.pbDatabaseWasUpdated(Self))
    End_Function
    
    // Takes a string array as parameter and returns a new
    // string array without any empty rows and all rows trimmed.
    // This is e.g. used by the HasIntFileChanged message to compare
    // two .int file arrays. 
    Function RemoveBlankLines String[] asIntFile Returns String[]
        Integer iSize iCount iRow
        String sVal        
        String[] asRetValArray
        
        Move (SizeOfArray(asIntFile)) to iSize
        If (iSize = 0) Begin
            Function_Return asRetValArray
        End                          
        Decrement iSize         
        Move 0 to iRow
        
        For iCount from 0  to iSize
            Move asIntFile[iCount] to sVal
            Move (Trim(sVal)) to sVal
            If (sVal <> "") Begin
                Move sVal to asRetValArray[iRow]
                Increment iRow        
            End
        Loop
        
        Function_Return asRetValArray
    End_Function
    
    //
    { Visibility=Public }
    Procedure ReinitializeFramework  
        tDbVersionInfo[] aDbVersionInfoArray
        Handle hoDbVersionObject
        Integer iSize iCount
        
        Set Private.pbDatabaseUpdateStarted to False
        Get paDbVersionInfoArray to aDbVersionInfoArray
        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
        Decrement iSize
        
        For iCount from 0 to iSize
            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
            Send ProcessUpdate                  of hoDbVersionObject False
        Loop
        Send Cleanup
    End_Procedure
    
    Procedure StartStatusPanel String sMsg String sMsg2 Integer iSze
        Integer iSize
        String sMessage sMessage2
        
        // Make it optional to pass an argument
        If (num_arguments > 0) Begin
            Move sMsg to sMessage
        End

        // Make it optional to pass a second argument
        If (num_arguments > 1) Begin
            Move sMsg2 to sMessage2
        End

        Move 0 to iSize
        // Make it optional to pass a third argument
        If (num_arguments > 2) Begin
            Move iSze to iSize
        End                   
        If (iSize = -1) Begin
            Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to False
        End
        If (iSize <> 0) Begin
            Set Progress_Bar_Visible_State of ghoStatusPanel to True
            Set piMaximum                  of ghoStatusPanel to iSize 
            Set piAdvanceBy                of ghoStatusPanel to 1
            Set Progress_Bar_Overall_Visible_State of ghoStatusPanel to True
        End

        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) sMessage sMessage2 
        Send Update_StatusPanel of ghoStatusPanel ""
        Send Start_StatusPanel of ghoStatusPanel
    End_Procedure
    
    Procedure StopStatusPanel
        Send Stop_StatusPanel of ghoStatusPanel
    End_Procedure
    
    { Visibility=Private }
    // This event is triggered by the cDbUpdateVersion child class when
    // a database change is to be started, and is considered private.
    // It is only executed once for the first cDbUpateVersion object!
    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
        Integer iRetval iDataFlexUsers iUserCount
        Handle hoUserCountSystem
        tUserCount UserCount
        DateTime dtUpdateStarted
        tSQLConnection SQLConnection

        // *Important:* If we already started the update; we do no further checking.
        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
        If (bDatabaseUpdateStarted = True) Begin
            Procedure_Return
        End

        // If not silent mode; Ask user if OK to start database update.
        If (pbSilentMode(Self) = False) Begin
            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
            If (iRetval <> MBR_Yes) Begin
                Send Exit_Application
            End
        End
        
        Send StartStatusPanel "" "" 1
        // This will save the status of all open tables including Master/Alias settings,
        // so we can restore them later;
        Send SaveOpenTables

        Move 0 to iDataFlexUsers
        // Make various tests to check that the database is not in use.
        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
        // We also use our own user counting mechanism to guard against the
        // database isn't opened already as we need exclusive access to the tables.:
        Get phoUserCountSystem to hoUserCountSystem
        Get CheckUserCount of hoUserCountSystem to UserCount
        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount

        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
        // Check DataFlex user count to see if anybody else is using the DataFlex license...
        If (bCheckDataFlexUserCount = True) Begin
            Get_Current_User_Count to iDataFlexUsers
            // For some reason DataFlex - in some cases - might think that 2 users
            // are in use while debugging from the Studio.
            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
                Decrement iDataFlexUsers
            End
        End 
        Else Begin
            Move 1 to iDataFlexUsers 
            Move 1 to iUserCount
            Move False to bInUse
        End

        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
            If (iRetval <> MBR_Yes) Begin
                Send Exit_Application
            End
        End

        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
            Send Stop_Box CS_DUF_DatabaseInUseText
            Send Exit_Application
        End

        // This will put a look on the DbUpdateLock.ucf file.
        // It is released when the update process is finished
        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount

        Move (CurrentDateTime()) to dtUpdateStarted
        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
        Set Private.pbDatabaseUpdateStarted to True

        // We need to close all tables before starting to make changes.
        Close DF_ALL DF_PERMANENT

        // If these properties has not exclicitly been set in the object, set them
        // to settings from the SQLConnections.ini file;
        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
        If (psSchema(Self) = "") Begin
            Set psSchema            to SQLConnection.sSchema
        End
        If (psBaseTableSpace(Self) = "") Begin
            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
        End
        If (psLongTableSpace(Self) = "") Begin
            Set psLongTableSpace    to SQLConnection.sLongTableSpace
        End
        If (psIndexTableSpace(Self) = "") Begin
            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
        End
        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
            Procedure_Return
        End

        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Send StopStatusPanel
            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
            Send Exit_Application
        End
    End_Procedure

    { MethodType=Event }
    // *** Hook message for pre-processing ***
    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
    // Aka, when another table than the standard "DbVersion" is used.
    Procedure OnCreateCustomDbVersionTable
    End_Procedure
    
    { MethodType=Event }
    // *** Hook message for pre-processing ***
    // The programmer can use this event for putting code that
    // needs to be executed _before_ code in any of the cDbUpdateVersion
    // child objects are executed.
    Procedure OnPreUpdate
    End_Procedure

    { MethodType=Event }
    // *** Hook message for post-processing ***
    // The programmer should use this event for putting code that
    // needs to be executed _after_ all database updates have finished.
    Procedure OnPostUpdate
    End_Procedure

    { MethodType=Event }
    // *** Hook message for custom DbVersion record find ***
    // The programmer can use this event for putting code that
    // needs to be executed to find a *custom* DbVersion table record.
    // By default the DbVersion table is used but this can be
    // customized by adding this line to the code;
    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
    // Note: You do _not_ need to use this event if the DbVersion table is used
    //       to save the current database version to. Only if you use your own
    //       table _and_ it is not a system table (contains only one record).
    Procedure OnFindVersionRecord
        // Open MyTable
        // Move xx to MyTable.Field1
        // Move yy to MyTable.Field2
        // Find le MyTable by Index.x
    End_Procedure

    { MethodType=Event }
    // Hook event for writing header error text (pre-update) to
    // a datatable. Only called if the pbUseDataTableLog property = True.
    // Don't forget to Open the table first (!) as all
    // tables have been closed at this stage.
    // The start date & time is passed.
    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
    End_Procedure

    { MethodType=Event }
    // Hook event to log errors to a database table.
    // Only called if the pbUseDataTableLog = True.
    // Don't forget to Open the table first (!) as all
    // tables have been closed at this stage.
    // If pbQuickWrite = True the DbUpdateErrorArray
    // will contain just one row, as it is called for each error
    // that occurred. Else it is called once at the end after all updates
    // have run and contains all errors.
    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
    End_Procedure

    { Visibility=Private }
    // Automatically send after all processing is done, but before the OnPostUpdate event.
    Procedure Cleanup
        Boolean bDatabaseWasUpdated bError bUseIntFilesBackup bOK
        String sErrorText
        
        Move "" to sErrorText
        Send AutoCreateDbVersionTable
        Send RestoreOpenTables

        // The function library have two purposes; one is to use it in the
        // Database Update Framework, but it can also be used on its own.
        // If that is the case it has its own error handling system, which
        // we temporarily disbled when running updates because we have
        // error handling/logging here too... We now restore its setting.
        If (ghoDbUpdateFunctionLibrary > 0) Begin
            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
        End
        Set pbHandleQueryErrors to True

        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
        Get pbDbUpdateErrorHasOccured to bError
        // Note: We make backup of .int files even if an error occured.
        If (bDatabaseWasUpdated = True) Begin
            // Check/create/update *.int files backup table:
            Get pbUseIntFilesBackup to bUseIntFilesBackup
            If (bUseIntFilesBackup = True) Begin
                Get SaveUpdateIntFiles (&sErrorText) to bOK
                If (bOK = False) Begin
                    Send LogError sErrorText True
                End
                Else If (sErrorText <> "") Begin
                    Send LogError sErrorText False
                End
            End
        End            
            
        If (bDatabaseWasUpdated = True or bError = True) Begin

            // We should always create the log as it also contains info about
            // the update being successful.
            Send WriteErrorLog of (phoLogFile(Self))

            // This is a programmer's hook message:
            Send OnPostUpdate

            Send StopStatusPanel
            If (pbSilentMode(Self) = False) Begin
                If (bError = True) Begin
                    If (pbShowErrorLogPostRun(Self) = True) Begin
                        Send ShowErrorLog of (phoLogFile(Self))
                    End
                    Send Info_Box CS_DUF_DbUpdatedErrorText
                    Send Exit_Application
                End
                Else Begin
                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
                        Send Info_Box CS_DUF_DatabaseUpdatedText
                    End
                    Else Begin
                        Send Info_Box CS_DUF_DatabaseCheckedText
                    End
                End
            End
        End

        // Restore the standard error handler:
        Get piOrgErrorHandlerID to Error_Object_Id
    End_Procedure

    // We do this _before_ we close the database to make changes, and save
    // all 'Master' & 'Alias' tables settings so we can restore when
    // we reopen the database.
    Procedure SaveOpenTables
        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
    End_Procedure

    // Returns a struct array with all currently open tables and a "state" that indicates if the table
    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
        Integer hTable iMasterAliasType iSize
        Boolean bOpen

        Move 0 to hTable
        Repeat
            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
            If (hTable <> 0) Begin
                Get_Attribute DF_FILE_OPENED of hTable to bOpen
                If (bOpen = True) Begin
                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
                End
            End
        Until (hTable = 0)

        Function_Return aDbUpdateHandlerMasterAlias
    End_Function

    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
    // Takes one parameter:
    //   A struct array with all master & alias
    Procedure RestoreOpenTables
        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
        Integer hTable iFileAlias iSize iCount
        Boolean bOpen
        String sRootName

        Move 0 to hTable
        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
        Decrement iSize
        For iCount from 0 to iSize
            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
            // We also need to check that the table hasn't been removed...
            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
            If (hTable <> 0 and sRootName <> "") Begin
                Open hTable
                Get_Attribute DF_FILE_OPENED of hTable to bOpen
                If (bOpen = True) Begin
                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
                    End
                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
                    End
                End
            End
        Loop
    End_Procedure

    // This checks for both duplicate pnVersionNumbers _and_ that
    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
    Procedure CheckForDuplicates Number nVersion
        tDbVersionInfo[] DbVersionInfoArray
        Integer iCount iSize iHits iDuplicateIndex
        Number nCompare
        Handle hObject1 hObject2
        String sObjectName1 sObjectName2
        Boolean bObjectOrderError

        Get paDbVersionInfoArray to DbVersionInfoArray
        Move (SizeOfArray(DbVersionInfoArray)) to iSize
        Decrement iSize
        Move 0 to iHits
        Move 0 to nCompare
        Move False to bObjectOrderError
        For iCount from 0 to iSize
            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
                Increment iHits
                If (iHits > 1) Begin
                    Move iCount to iDuplicateIndex
                    If (nCompare <> 0) Begin
                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
                    End
                End
            End
            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
        Loop
        If (iHits > 1) Begin
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
            Move (Name(hObject1)) to sObjectName1
            Move (Name(hObject2)) to sObjectName2
            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
            Send Exit_Application
        End
        Else If (bObjectOrderError = True) Begin
            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
            Send Exit_Application
        End
    End_Procedure

    // We take care of all errors in the Error_Report below and
    // collect them all to an array property. So just ignore any
    // "Ignore_Error" & "Trap_Error" messages that might be send/used
    // in some other package.
    Procedure Ignore_Error Integer iError
    End_Procedure

    Procedure Trap_Error Integer iError
    End_Procedure

    // Build complete error description from Flexerrs and user error message.
    { Visibility=Private }
    Function Error_Description Integer Error# String ErrMsg Returns String
        String Full_Error_Text
        
        Move (Trim(ErrMsg)) to ErrMsg
        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
        
        If (ErrMsg <> "") Begin
            
            If ((Full_Error_Text<>"" ) and ;
                Error_Text_Available( DESKTOP, Error# ) ) Begin
                // Make sure last character of error text is a separating symbol.
                // if not, add a "." So we have format of "error-text. error-detail"
                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;
                    Move (Full_Error_Text - ".") to Full_Error_Text
                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
            End
            Else ;
                Move ErrMsg to Full_Error_Text
            
        End
        
        Function_Return Full_Error_Text
    End_Function

    // While we update the database we collect all errors in
    // the struct array paDbUpdateErrorArray.
    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
        Number nVersion
        Handle hoLogFile 
        
        If (Private.pbProcessingError(Self)) Begin
            Procedure_Return
        End

        // The UtilTableNameFromHandleToString function does a:
        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
        // and it generates an error if the table is of the embedded type.
        // As we don't want to trigger an error in that very specific case,
        // we just ignore it here.
        //
        // If no report mode, just set the err indicator to false.
        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
            Set Private.pbProcessingError to False
            Procedure_Return
        End

        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
            Set Private.pbProcessingError to False
            Procedure_Return
        End

        Set Private.pbProcessingError to True
        Set Private.pbUpdateVersionObjectError to True

        Set pbDbUpdateErrorHasOccured to True
        Get pnCurrentVersionUpdate to nVersion
        Get phoLogFile to hoLogFile
        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True

        Set Private.pbProcessingError to False
    End_Procedure

End_Class
